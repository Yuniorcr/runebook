<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="apache_pig">
    <body>
      <group id="apache_pig">
        <trans-unit id="93b4ce281ad4d31e6af3346691bb547f398a8cbf" translate="yes" xml:space="preserve">
          <source>For example, to change &quot;open source software&quot; to &quot;open source wiki&quot; use this statement: REPLACE(string,'software','wiki')</source>
          <target state="translated">Например,чтобы изменить &quot;open source software&quot; на &quot;open source wiki&quot;,используйте это утверждение:REPLACE(string,'software','wiki')</target>
        </trans-unit>
        <trans-unit id="2558ca48598887e3d84f03a1511176c77750fd14" translate="yes" xml:space="preserve">
          <source>For example, to use the UPPER function:</source>
          <target state="translated">Например,для использования функции UPPER:</target>
        </trans-unit>
        <trans-unit id="4d06b096cbbf60674310194594b6b0d80cdfa970" translate="yes" xml:space="preserve">
          <source>For example, we could build a PigTestCase and PigTestSuite on top of PigTest to:</source>
          <target state="translated">Например,мы могли бы построить PigTestCase и PigTestSuite поверх PigTest to:</target>
        </trans-unit>
        <trans-unit id="4283542d9ba01220066fa046721637b231d54d01" translate="yes" xml:space="preserve">
          <source>For examples of how to specify more complex schemas for use with the LOAD operator, see &lt;a href=&quot;#schema-complex&quot;&gt;Schemas for Complex Data Types&lt;/a&gt; and &lt;a href=&quot;#schema-multi&quot;&gt;Schemas for Multiple Types&lt;/a&gt;.</source>
          <target state="translated">Примеры того, как задать более сложные схемы для использования с оператором LOAD, см. В разделе &lt;a href=&quot;#schema-complex&quot;&gt;Схемы для сложных типов данных&lt;/a&gt; и &lt;a href=&quot;#schema-multi&quot;&gt;Схемы для нескольких типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0686c40754484cfa3761e6447be50b4c48fea41a" translate="yes" xml:space="preserve">
          <source>For examples using the FLATTEN operator, see &lt;a href=&quot;#flatten-example&quot;&gt;FOREACH&lt;/a&gt;.</source>
          <target state="translated">Примеры использования оператора &lt;a href=&quot;#flatten-example&quot;&gt;FLATTEN&lt;/a&gt; см . В разделе FOREACH .</target>
        </trans-unit>
        <trans-unit id="e4b788869e10fe0fc5ed6fc7af3d8672e9a3c1c1" translate="yes" xml:space="preserve">
          <source>For examples, see &lt;a href=&quot;#nestedblock&quot;&gt;Example: Nested Block&lt;/a&gt;.</source>
          <target state="translated">Примеры см. В разделе &lt;a href=&quot;#nestedblock&quot;&gt;Пример: вложенный блок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96befa6a21bd8f208f36a58bec7ad77e5f99a3f3" translate="yes" xml:space="preserve">
          <source>For general information about datetime type operations, see the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/&quot;&gt;Java API Specification&lt;/a&gt;, &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Date.html&quot;&gt;Java Date class&lt;/a&gt;, and &lt;a href=&quot;http://joda-time.sourceforge.net/apidocs/index.html&quot;&gt;JODA DateTime class&lt;/a&gt;. And for the information of ISO date and time formats, please refer to &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;Date and Time Formats&lt;/a&gt;.</source>
          <target state="translated">Общие сведения об операциях типа даты и времени, см &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/&quot;&gt;API спецификации Java&lt;/a&gt; , &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Date.html&quot;&gt;Date класс Java&lt;/a&gt; и &lt;a href=&quot;http://joda-time.sourceforge.net/apidocs/index.html&quot;&gt;класс Joda DateTime&lt;/a&gt; . Информацию о форматах даты и времени ISO см. В разделе &amp;laquo; &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;Форматы даты и времени&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d633d79f93581b92a8dae397bac4a6001dcaee39" translate="yes" xml:space="preserve">
          <source>For general information about datetime type operations, see the &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/&quot;&gt;Java API Specification&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/util/Date.html&quot;&gt;Java Date class&lt;/a&gt;, and &lt;a href=&quot;http://joda-time.sourceforge.net/apidocs/index.html&quot;&gt;JODA DateTime class&lt;/a&gt;. And for the information of ISO date and time formats, please refer to &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;Date and Time Formats&lt;/a&gt;.</source>
          <target state="translated">Общие сведения об операциях типа даты и времени, см &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/&quot;&gt;API спецификации Java&lt;/a&gt; , &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/util/Date.html&quot;&gt;Date класс Java&lt;/a&gt; и &lt;a href=&quot;http://joda-time.sourceforge.net/apidocs/index.html&quot;&gt;класс Joda DateTime&lt;/a&gt; . Информацию о форматах даты и времени ISO см. В разделе &amp;laquo; &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;Форматы даты и времени&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eadda025db0b38136a2b245d3007405853dfb85" translate="yes" xml:space="preserve">
          <source>For general information about these functions, see the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/&quot;&gt;Java API Specification&lt;/a&gt;, &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html&quot;&gt;Class Math&lt;/a&gt;. Note the following:</source>
          <target state="translated">Для получения общей информации об этих функциях см. &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/&quot;&gt;Спецификацию Java API&lt;/a&gt; , &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html&quot;&gt;Class Math&lt;/a&gt; . Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="e0f888a50180fa6a9c9811bad6b91aa0cb9d7bda" translate="yes" xml:space="preserve">
          <source>For general information about these functions, see the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/&quot;&gt;Java API Specification&lt;/a&gt;, &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html&quot;&gt;Class String&lt;/a&gt;. Note the following:</source>
          <target state="translated">Для получения общей информации об этих функциях см. &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/&quot;&gt;Спецификацию Java API&lt;/a&gt; , &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html&quot;&gt;Class String&lt;/a&gt; . Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="7146eba761b0b154013f187489c2a511afce96d1" translate="yes" xml:space="preserve">
          <source>For general information about these functions, see the &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/&quot;&gt;Java API Specification&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/lang/Math.html&quot;&gt;Class Math&lt;/a&gt;. Note the following:</source>
          <target state="translated">Для получения общей информации об этих функциях см. &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/&quot;&gt;Спецификацию Java API&lt;/a&gt; , &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/lang/Math.html&quot;&gt;Class Math&lt;/a&gt; . Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="1be8ef6c2693f31106114be2bba59ee92e55f27b" translate="yes" xml:space="preserve">
          <source>For general information about these functions, see the &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/&quot;&gt;Java API Specification&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/lang/String.html&quot;&gt;Class String&lt;/a&gt;. Note the following:</source>
          <target state="translated">Для получения общей информации об этих функциях см. &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/&quot;&gt;Спецификацию Java API&lt;/a&gt; , &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/lang/String.html&quot;&gt;Class String&lt;/a&gt; . Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="6d7cf2ee337839be9124bdabdfb8feb931d9b3bd" translate="yes" xml:space="preserve">
          <source>For inner joins, the preconditions are the same as for merge join with the exception of constrains on the right-side loader. For sparse-merge joins the loader must implement IndexedLoadFunc or the join will fail.</source>
          <target state="translated">Для внутренних соединений предпосылки такие же,как и для слияния,за исключением ограничений на правостороннем загрузчике.Для разреженных соединений загрузчик должен реализовать IndexedLoadFunc,иначе соединение не удастся.</target>
        </trans-unit>
        <trans-unit id="c0abd4c0df00700b943a508d3f4fb199a6202303" translate="yes" xml:space="preserve">
          <source>For instance, let's consider function MAX which is part of the piggybank described later in this document. Given two values, the function returns the larger value. The function table for MAX looks like this:</source>
          <target state="translated">Рассмотрим,например,функцию MAX,которая является частью &quot;копилки&quot;,описанной ниже в этом документе.При двух значениях функция возвращает большее значение.Таблица функций для MAX выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="7f8c8b363d01ed47a09ff6589364651b1b31cd93" translate="yes" xml:space="preserve">
          <source>For instance, the UPPER function would now look as follows:</source>
          <target state="translated">Например,функция UPPER теперь будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="06561f328127298f1b4065e398e8abb372d54515" translate="yes" xml:space="preserve">
          <source>For maps, flatten creates a tuple with two fields containing the key and value. If we have a map field named kvpair with input as (m[k1#v1, k2#v2]) and we apply GENERATE flatten(kvpair), it will generate two tuples (k1,v1) and (k2,v2) which can be accessed as kvpair::key and kvpair::value.</source>
          <target state="translated">Для карт,flatten создает кортеж с двумя полями,содержащими ключ и значение.Если у нас есть поле карты kvpair с именем (m[k1#v1,k2#v2])и мы применим GENERATE flatten(kvpair),то он сгенерирует два кортежа (k1,v1)и (k2,v2),к которым можно получить доступ как к kvpair::key и kvpair::value.</target>
        </trans-unit>
        <trans-unit id="edaa865a2c780dd3150038a9657fef7efae66c93" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;#java-objects&quot;&gt;Java Objects&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;#java-objects&quot;&gt;Java Objects&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3105f4d5cd73703ced64c07d63b1c9bd996515" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html&quot;&gt;http://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;http://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html&quot;&gt;Http://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14095439c9444a2258529c01e8b124e7301a86bf" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;https://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html&quot;&gt;http://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html&lt;/a&gt;</source>
          <target state="translated">Подробнее см. &lt;a href=&quot;https://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html&quot;&gt;Http://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/Partitioner.html.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d2505278f41d1a4f6c2440c74d7f4cb89bb778b" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;perf#Parallel&quot;&gt;Use the Parallel Features&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;perf#Parallel&quot;&gt;Раздел Использование параллельных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33a59f727539b1eb591992fd82a899d7dc15ac30" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;perf#parallel&quot;&gt;Use the Parallel Features&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;perf#parallel&quot;&gt;Раздел Использование параллельных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d6210afb436622390c25339bb9339361b0ffe7" translate="yes" xml:space="preserve">
          <source>For multi-line comments use /* &amp;hellip;. */</source>
          <target state="translated">Для многострочных комментариев используйте / *&amp;hellip;. * /</target>
        </trans-unit>
        <trans-unit id="1c8995ca96b32e7562330a647878906e09f7acb6" translate="yes" xml:space="preserve">
          <source>For other rounding modes, consult &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html&quot;&gt;Java's documentation&lt;/a&gt;. There is no rounding mode that matches Math.round's behavior (i.e. round towards positive infinity) -- blame Java, not Pig.</source>
          <target state="translated">Для других режимов округления обратитесь &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html&quot;&gt;к документации Java&lt;/a&gt; . Не существует режима округления, соответствующего поведению Math.round (т.е. округление до положительной бесконечности) - виновата Ява, а не Свинья.</target>
        </trans-unit>
        <trans-unit id="841af2bee27af29b3a0371a8f5a2a3fb556ca089" translate="yes" xml:space="preserve">
          <source>For other rounding modes, consult &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html&quot;&gt;Java's documentation&lt;/a&gt;. There is no rounding mode that matches Math.round's behavior (i.e. round towards positive infinity) -- blame Java, not Pig.</source>
          <target state="translated">Для других режимов округления обратитесь &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html&quot;&gt;к документации Java&lt;/a&gt; . Нет режима округления, который соответствовал бы поведению Math.round (т. Е. Округление в сторону положительной бесконечности) - вините Java, а не Pig.</target>
        </trans-unit>
        <trans-unit id="dcfe0ffa092d621246ce3195642425911fd748d4" translate="yes" xml:space="preserve">
          <source>For single-line comments use --</source>
          <target state="translated">Для однострочных комментариев используйте --</target>
        </trans-unit>
        <trans-unit id="4a7c04b567b5d2689f72690e632945e5d6c5e51c" translate="yes" xml:space="preserve">
          <source>For streaming, sets the path from which not to ship data (see &lt;a href=&quot;basic#define-udfs&quot;&gt;DEFINE (UDFs, streaming)&lt;/a&gt; and &lt;a href=&quot;basic#autoship&quot;&gt; About Auto-Ship&lt;/a&gt;).</source>
          <target state="translated">Для потоковой передачи задает путь, по которому не следует отправлять данные (см. &lt;a href=&quot;basic#define-udfs&quot;&gt;DEFINE (UDF, потоковая передача)&lt;/a&gt; и &lt;a href=&quot;basic#autoship&quot;&gt;Об автоматической отправке&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9866dc294d5adf9caf23c4b6803873ea4db4b4e2" translate="yes" xml:space="preserve">
          <source>For tuples, flatten substitutes the fields of a tuple in place of the tuple. For example, consider a relation that has a tuple of the form (a, (b, c)). The expression GENERATE $0, flatten($1), will cause that tuple to become (a, b, c).</source>
          <target state="translated">Для кортежей,плоские поля кортежа заменяются полями кортежа.Например,рассмотрим отношение,которое имеет кортеж формы (a,(b,c)).Выражение GENERATE $0,flatten($1),приведет к тому,что кортеж (a,b,c)станет кортежом (a,b,c).</target>
        </trans-unit>
        <trans-unit id="ab5146bc0337c0c4ec162adcbc0f516bf45e19f0" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;</source>
          <target state="translated">Для использования, см. &lt;a href=&quot;#partitionby&quot;&gt;Пример: PARTITION BY&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f9184fa3102a195538324a094c9f3e87e8512af" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;.</source>
          <target state="translated">Для использования, см. &lt;a href=&quot;#partitionby&quot;&gt;Пример: PARTITION BY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0950ec5daec19b5369e8db389d77d478ef703948" translate="yes" xml:space="preserve">
          <source>For use with functions.</source>
          <target state="translated">Для использования с функциями.</target>
        </trans-unit>
        <trans-unit id="2e73207156965726452940b3f15d34faa203e678" translate="yes" xml:space="preserve">
          <source>For use with streaming.</source>
          <target state="translated">Для использования с потоком.</target>
        </trans-unit>
        <trans-unit id="e710be2705e01b5fdc5bc69b770043ff7d7443e6" translate="yes" xml:space="preserve">
          <source>Force parallel &quot;1&quot; for &quot;group all&quot; statement. That's because even if we set parallel to N, only 1 reducer will be used in this case and all other reducer produce empty result.</source>
          <target state="translated">Форсируйте параллельное &quot;1&quot; для выражения &quot;группа всех&quot;.Это связано с тем,что даже если мы установим параллель в N,то в этом случае будет использоваться только 1 редуктор,а все остальные редукторы дадут пустой результат.</target>
        </trans-unit>
        <trans-unit id="c4f05734f466b587d8c8a1997c40b3f98c2fd069" translate="yes" xml:space="preserve">
          <source>Format floats/doubles with %f, hexadecimal integers with %x (there are others besides -- see the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Java docs&lt;/a&gt;)</source>
          <target state="translated">Формат плавает / удваивается с% f, шестнадцатеричные целые с% x (кроме этого есть другие - см. &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Документацию&lt;/a&gt; по Java )</target>
        </trans-unit>
        <trans-unit id="deb779f9285574b99bfd399805abaf9a007a628c" translate="yes" xml:space="preserve">
          <source>Format floats/doubles with %f, hexadecimal integers with %x (there are others besides -- see the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Java docs&lt;/a&gt;)</source>
          <target state="translated">Форматируйте числа с плавающей запятой / удвоением с помощью% f, шестнадцатеричные целые числа с помощью% x (есть и другие - см. &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Документацию&lt;/a&gt; по Java )</target>
        </trans-unit>
        <trans-unit id="65b19c46035a1e459a4e6bb765528e1af24e48c0" translate="yes" xml:space="preserve">
          <source>Format strings with %s, integers with %d. Types are converted for you where reasonable (here, int -&amp;gt; string).</source>
          <target state="translated">Форматировать строки с% s, целые с% d. Типы конвертируются для вас там, где это целесообразно (здесь int -&amp;gt; string).</target>
        </trans-unit>
        <trans-unit id="f0c02fc6d4fa96dcda39151919580b8f3027d3c2" translate="yes" xml:space="preserve">
          <source>Formats a set of values according to a printf-style template, using the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;native Java Formatter&lt;/a&gt; library.</source>
          <target state="translated">Форматирует набор значений в соответствии с шаблоном в стиле printf, используя &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;собственную&lt;/a&gt; библиотеку Java Formatter .</target>
        </trans-unit>
        <trans-unit id="d6be68b0136f49eb4fca4e760405d17a6799a7b5" translate="yes" xml:space="preserve">
          <source>Formats a set of values according to a printf-style template, using the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;native Java Formatter&lt;/a&gt; library.</source>
          <target state="translated">Форматирует набор значений в соответствии с шаблоном в стиле printf, используя &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;собственную&lt;/a&gt; библиотеку Java Formatter .</target>
        </trans-unit>
        <trans-unit id="37a95ef7b2da5e9dfb0b25b33a9688c6a79aa3a1" translate="yes" xml:space="preserve">
          <source>Fragment replicate join is a special type of join that works well if one or more relations are small enough to fit into main memory. In such cases, Pig can perform a very efficient join because all of the hadoop work is done on the map side. In this type of join the large relation is followed by one or more small relations. The small relations must be small enough to fit into main memory; if they don't, the process fails and an error is generated.</source>
          <target state="translated">Фрагментное репликативное соединение-это особый тип соединения,который хорошо работает,если одно или несколько отношений достаточно малы,чтобы поместиться в основную память.В таких случаях Свинья может выполнить очень эффективное соединение,потому что вся работа с хадупом выполняется на стороне карты.В этом типе соединения за большим соединением следует одно или более мелких отношений.Малые отношения должны быть достаточно малы,чтобы поместиться в оперативную память;если они не поместятся,то процесс завершится неудачей,и будет сгенерирована ошибка.</target>
        </trans-unit>
        <trans-unit id="f7d2029d8a7b6c3c5acd074ab389e6e84bd20928" translate="yes" xml:space="preserve">
          <source>Fragment replicate joins are experimental; we don't have a strong sense of how small the small relation must be to fit into memory. In our tests with a simple query that involves just a JOIN, a relation of up to 100 M can be used if the process overall gets 1 GB of memory. Please share your observations and experience with us.</source>
          <target state="translated">Фрагменты реплицируемых соединений являются экспериментальными;у нас нет сильного ощущения того,насколько малым должно быть отношение,чтобы уместиться в памяти.В наших тестах с простым запросом,включающим только JOIN,отношение до 100 M может быть использовано,если процесс в сумме получит 1 гигабайт памяти.Пожалуйста,поделитесь с нами своими наблюдениями и опытом.</target>
        </trans-unit>
        <trans-unit id="f3b8fd3a28a763d9eab819f563e9a8f0681fa259" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idlocal.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="translated">Из текущей рабочей директории скомпилируйте программу. (Обратите внимание, что idlocal.class записывается в ваш текущий рабочий каталог. При запуске программы включайте &amp;laquo;.&amp;raquo; В путь к классам.)</target>
        </trans-unit>
        <trans-unit id="68b6e84a59d14c66e17c94d2084cee2765bf4216" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idmapreduce.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="translated">Из текущей рабочей директории скомпилируйте программу. (Обратите внимание, что idmapreduce.class записывается в текущий рабочий каталог. При запуске программы включайте &amp;laquo;.&amp;raquo; В путь к классам.)</target>
        </trans-unit>
        <trans-unit id="8d3c6572188487e7d0f0bf43f11a330f71f5a985" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the idout directory on your Hadoop system.</source>
          <target state="translated">Из текущего рабочего каталога запустите программу.Чтобы просмотреть результаты,проверьте каталог idout на Вашей системе Hadoop.</target>
        </trans-unit>
        <trans-unit id="3ae11fbd09e929b80dba1b8d2891594f82f70b9d" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the output file, id.out.</source>
          <target state="translated">Из текущего рабочего каталога запустите программу.Для просмотра результатов проверьте выходной файл,id.out.</target>
        </trans-unit>
        <trans-unit id="a7a933fc62edcf10d9c4963f8596c7a787656527" translate="yes" xml:space="preserve">
          <source>Full outer join is not supported for bloom joins.</source>
          <target state="translated">Полное внешнее соединение не поддерживается для цветковых соединений.</target>
        </trans-unit>
        <trans-unit id="5f3f294cdfe303f5625a901ee7d581a06175c157" translate="yes" xml:space="preserve">
          <source>Full outer join.</source>
          <target state="translated">Полное внешнее соединение.</target>
        </trans-unit>
        <trans-unit id="bd51a32f96535333dd4e1a84807c6dd179d912eb" translate="yes" xml:space="preserve">
          <source>Function Instantiation</source>
          <target state="translated">Функция инстанцирования</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="translated">Перегрузка функций</target>
        </trans-unit>
        <trans-unit id="41a40e8fa627c3e0562970952ab6b5e561ad1d21" translate="yes" xml:space="preserve">
          <source>Function names PigStorage and COUNT are case sensitive.</source>
          <target state="translated">Названия функций PigStorage и COUNT чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="160b3670e04858fde7e4140b45e86e3c1b2090a9" translate="yes" xml:space="preserve">
          <source>Function:</source>
          <target state="translated">Function:</target>
        </trans-unit>
        <trans-unit id="8a60d2c69bf2f39201997d6084ec499f9e7d4ad3" translate="yes" xml:space="preserve">
          <source>Functions can be a part of almost every operator in Pig. The &lt;a href=&quot;func&quot;&gt;Built In Functions&lt;/a&gt; guide describes Pig's built in functions. The &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt; manual shows you how to how to write your own functions and how to access/contribute functions using the Piggy Bank repository.</source>
          <target state="translated">Функции могут быть частью почти любого оператора в Pig. Руководство по &lt;a href=&quot;func&quot;&gt;встроенным функциям&lt;/a&gt; описывает встроенные функции Pig. В руководстве &amp;laquo; &lt;a href=&quot;udf&quot;&gt;Пользовательские функции&amp;raquo;&lt;/a&gt; показано, как написать свои собственные функции и как получить доступ к функциям или использовать их с помощью репозитория Piggy Bank.</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="69c25d3382693097f4ee01b8b77967c5ef7e79d1" translate="yes" xml:space="preserve">
          <source>Future Enhancements</source>
          <target state="translated">Будущие усовершенствования</target>
        </trans-unit>
        <trans-unit id="c47a6ad23578fb44a406e049fe66c07a90f32a42" translate="yes" xml:space="preserve">
          <source>GENERATE expression [AS schema] [expression [AS schema]&amp;hellip;.]</source>
          <target state="translated">GENERATE выражение [AS схема] [выражение [AS схема]&amp;hellip;.]</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="013e1ba0cbe0583ac34e8b6e095d4f74e6839fce" translate="yes" xml:space="preserve">
          <source>General Expressions</source>
          <target state="translated">Общие выражения</target>
        </trans-unit>
        <trans-unit id="ba7ce2025ad3e9884daf361153c61aba79035239" translate="yes" xml:space="preserve">
          <source>General expressions can be made up of UDFs and almost any operator. Since Pig does not consider boolean a base type, the result of a general expression cannot be a boolean. Field expressions are the simpliest general expressions.</source>
          <target state="translated">Общие выражения могут состоять из UDF и практически любого оператора.Поскольку Pig не считает булевым типом базы,результат общего выражения не может быть булевым.Полевые выражения являются самыми простыми выражениями общего характера.</target>
        </trans-unit>
        <trans-unit id="05659366d857f4eb5690afb9bdc9b7cff8960f88" translate="yes" xml:space="preserve">
          <source>Generates data transformations based on columns of data.</source>
          <target state="translated">Генерирует преобразования данных на основе столбцов данных.</target>
        </trans-unit>
        <trans-unit id="5d31621c5fbd4db9066caabd502e7f486ee3e5b1" translate="yes" xml:space="preserve">
          <source>GetDay</source>
          <target state="translated">GetDay</target>
        </trans-unit>
        <trans-unit id="a2818cfc533e59e26a20d03c8af18c62d9b9c5cb" translate="yes" xml:space="preserve">
          <source>GetDay(datetime)</source>
          <target state="translated">GetDay(datetime)</target>
        </trans-unit>
        <trans-unit id="3b156f58cad62688611629fcdf71abc53cfef5f1" translate="yes" xml:space="preserve">
          <source>GetHour</source>
          <target state="translated">GetHour</target>
        </trans-unit>
        <trans-unit id="7f19466d1ae92343794e23e8bd7e86f438306630" translate="yes" xml:space="preserve">
          <source>GetHour(datetime)</source>
          <target state="translated">GetHour(datetime)</target>
        </trans-unit>
        <trans-unit id="58893931dfea4b07fda21ca1e5395092265e2c3a" translate="yes" xml:space="preserve">
          <source>GetMilliSecond</source>
          <target state="translated">GetMilliSecond</target>
        </trans-unit>
        <trans-unit id="afef00aa595fe91edb36d72cf45140620b780d38" translate="yes" xml:space="preserve">
          <source>GetMilliSecond(datetime)</source>
          <target state="translated">GetMilliSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="fbac074c454a28eb5bc3652325337229670aceab" translate="yes" xml:space="preserve">
          <source>GetMinute</source>
          <target state="translated">GetMinute</target>
        </trans-unit>
        <trans-unit id="6ddb6810694ebf38157652de08ac6474351f11dd" translate="yes" xml:space="preserve">
          <source>GetMinute(datetime)</source>
          <target state="translated">GetMinute(datetime)</target>
        </trans-unit>
        <trans-unit id="9a9c8d02c50cc38f21c8d41bc770a3c35f506480" translate="yes" xml:space="preserve">
          <source>GetMonth</source>
          <target state="translated">GetMonth</target>
        </trans-unit>
        <trans-unit id="f2fff6f22018398e947df0b8d628bc57c850fec7" translate="yes" xml:space="preserve">
          <source>GetMonth(datetime)</source>
          <target state="translated">GetMonth(datetime)</target>
        </trans-unit>
        <trans-unit id="ff6d2cdc9cd0bca91c09f0335184b3630e5b2deb" translate="yes" xml:space="preserve">
          <source>GetSecond</source>
          <target state="translated">GetSecond</target>
        </trans-unit>
        <trans-unit id="45f99eb79a9b7a9ba3bd539dcbbaf4f8c0817e77" translate="yes" xml:space="preserve">
          <source>GetSecond(datetime)</source>
          <target state="translated">GetSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="dbe83da717d9b3ecc4a104bf9633dbb6f97546bc" translate="yes" xml:space="preserve">
          <source>GetWeek</source>
          <target state="translated">GetWeek</target>
        </trans-unit>
        <trans-unit id="b1f08071cdcc6fbf37da9c2cb680ecaa83720d89" translate="yes" xml:space="preserve">
          <source>GetWeek(datetime)</source>
          <target state="translated">GetWeek(datetime)</target>
        </trans-unit>
        <trans-unit id="535b65cc823f05d8dee165e5013a86a55c020e85" translate="yes" xml:space="preserve">
          <source>GetWeekYear</source>
          <target state="translated">GetWeekYear</target>
        </trans-unit>
        <trans-unit id="05f2caa2e1cdd71879407becb731af0dcee8c734" translate="yes" xml:space="preserve">
          <source>GetWeekYear(datetime)</source>
          <target state="translated">GetWeekYear(datetime)</target>
        </trans-unit>
        <trans-unit id="834cef9635aab01a61de7d362e8845f769065b31" translate="yes" xml:space="preserve">
          <source>GetYear</source>
          <target state="translated">GetYear</target>
        </trans-unit>
        <trans-unit id="fb7ba0f88bff662f921c57e03488fa999f79c2f9" translate="yes" xml:space="preserve">
          <source>GetYear(datetime)</source>
          <target state="translated">GetYear(datetime)</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="4682593736b76df959401b0677e46c3da95e5f88" translate="yes" xml:space="preserve">
          <source>Given a field named alpha whose value is ABCDEF, to return substring BCD use this statement: SUBSTRING(alpha,1,4). Note that 1 is the index of B (the first character of the substring) and 4 is the index of E (the character &lt;em&gt;following&lt;/em&gt; the last character of the substring).</source>
          <target state="translated">Для заданного поля с именем alpha, значением которого является ABCDEF, для возврата подстроки BCD используйте этот оператор: SUBSTRING (alpha, 1,4). Обратите внимание, что 1 - это индекс B (первый символ подстроки), а 4 - это индекс E (символ, &lt;em&gt;следующий&lt;/em&gt; за последним символом подстроки).</target>
        </trans-unit>
        <trans-unit id="2904ccdb85701307c7a4cf0211c6c673432f8e03" translate="yes" xml:space="preserve">
          <source>Given relation A above, the three fields are separated out in this table.</source>
          <target state="translated">Учитывая соотношение А,приведенное выше,эти три поля разделены в данной таблице.</target>
        </trans-unit>
        <trans-unit id="5a460e02a6c7ad51f55a1454d1e43a85fd04b53c" translate="yes" xml:space="preserve">
          <source>Given this {$1, $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="translated">Учитывая это {$1,$2}Свинья создает этот {($1),($2)}пакет с двумя кортежами.</target>
        </trans-unit>
        <trans-unit id="819d769c6789870f4f6ec3bd99567803b29a16b7" translate="yes" xml:space="preserve">
          <source>Given this {($1), $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="translated">Учитывая это {($1),$2}Свинья создает этот {($1),($2)}мешок с двумя кортежами.</target>
        </trans-unit>
        <trans-unit id="7b8a3b30656b5b8d1c274bf06cf27e2edc4a7002" translate="yes" xml:space="preserve">
          <source>Given this {($1, $2)} Pig creates this {($1, $2)} a bag with a single tuple</source>
          <target state="translated">Учитывая это,свинья создает этот мешок с одним кортежом...</target>
        </trans-unit>
        <trans-unit id="c18327c070894ced2aa384e5bac6ad7ebbd23172" translate="yes" xml:space="preserve">
          <source>Groovy to Pig</source>
          <target state="translated">Груви к свинье</target>
        </trans-unit>
        <trans-unit id="671afc89df0401f9442ee7ad8b3683045e599c39" translate="yes" xml:space="preserve">
          <source>Group/Organization and Version are optional fields. In such cases you can leave them blank.</source>
          <target state="translated">Группа/Организация и Версия являются необязательными полями.В таких случаях их можно оставить пустыми.</target>
        </trans-unit>
        <trans-unit id="748922032ec9b2f255ede26d965bccd104ad8a43" translate="yes" xml:space="preserve">
          <source>GroupByConstParallelSetter</source>
          <target state="translated">GroupByConstParallelSetter</target>
        </trans-unit>
        <trans-unit id="6ac2bc105d01b75f0cb6647c28ad7b1ded321074" translate="yes" xml:space="preserve">
          <source>Grouped and ordered data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously. Additionally, the data within the group is guaranteed to be sorted by the provided secondary key.</source>
          <target state="translated">Сгруппированные и упорядоченные данные - данные для одного и того же сгруппированного ключа гарантированно будут передаваться потоковому приложению непрерывно. Кроме того, данные в группе гарантированно сортируются по предоставленному вторичному ключу.</target>
        </trans-unit>
        <trans-unit id="8cb388e32ba9398b3d8e495be2290836a832d3ca" translate="yes" xml:space="preserve">
          <source>Grouped data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously</source>
          <target state="translated">Сгруппированные данные - данные для одного и того же сгруппированного ключа гарантированно будут предоставляться приложению потоковой передачи непрерывно</target>
        </trans-unit>
        <trans-unit id="20439eb031c2c2b9f6f2b1f7678cd259da8c350d" translate="yes" xml:space="preserve">
          <source>Groups the data in one or more relations.</source>
          <target state="translated">Группирует данные в одно или несколько отношений.</target>
        </trans-unit>
        <trans-unit id="f5b29066a94b56a4df47b36a243e361e26fd8c0a" translate="yes" xml:space="preserve">
          <source>HBaseStorage</source>
          <target state="translated">HBaseStorage</target>
        </trans-unit>
        <trans-unit id="bc02175406f48d300473a8fc281831d54e6647b9" translate="yes" xml:space="preserve">
          <source>HBaseStorage stores and loads data from HBase. The function takes two arguments. The first argument is a space seperated list of columns. The second optional argument is a space seperated list of options. Column syntax and available options are listed above. Note that HBaseStorage always disable split combination.</source>
          <target state="translated">HBaseStorage хранит и загружает данные из HBase.Функция принимает два аргумента.Первый аргумент представляет собой разделенный пробелами список столбцов.Второй необязательный аргумент-разделенный пробелами список опций.Синтаксис столбцов и доступные опции перечислены выше.Обратите внимание,что HBaseStorage всегда отключает комбинацию сплит.</target>
        </trans-unit>
        <trans-unit id="42e829762cee04a70bc5305f66fd119de2d0708d" translate="yes" xml:space="preserve">
          <source>HBaseStorage('columns', ['options'])</source>
          <target state="translated">HBaseStorage(&quot;столбцы&quot;,[&quot;опции&quot;]])</target>
        </trans-unit>
        <trans-unit id="a681ca832e37b54f22d309ff4273f4866e57dab0" translate="yes" xml:space="preserve">
          <source>Hadoop configuration files (include pig-cluster-hadoop-site.xml)</source>
          <target state="translated">Файлы конфигурации Hadoop (включая pig-cluster-hadoop-site.xml)</target>
        </trans-unit>
        <trans-unit id="020d890f6143875ea62437b4701c7f2b8c694a7e" translate="yes" xml:space="preserve">
          <source>Hadoop counters are easily accessible within EvalFunc by using PigStatusReporter object. Here is one example:</source>
          <target state="translated">Счётчики Hadoop легко доступны в системе EvalFunc с помощью объекта PigStatusReporter.Вот один пример:</target>
        </trans-unit>
        <trans-unit id="efd0ea6d637892905e05f7688a0e68aa55230d64" translate="yes" xml:space="preserve">
          <source>Hadoop properties are not interpreted by Pig but are passed directly to Hadoop. Any Hadoop property can be passed this way.</source>
          <target state="translated">Свойства Hadoop не интерпретируются Свиньей,а передаются непосредственно в Hadoop.Любое свойство Hadoop может быть передано таким образом.</target>
        </trans-unit>
        <trans-unit id="4c073bed947ef004c13b391708120392ca11dadb" translate="yes" xml:space="preserve">
          <source>Handling Compression</source>
          <target state="translated">Сжатие при работе</target>
        </trans-unit>
        <trans-unit id="4f90cbd026c5d20793d9146514d003112f491dc9" translate="yes" xml:space="preserve">
          <source>Handling null values in dimensions</source>
          <target state="translated">Обработка нулевых значений в размерах</target>
        </trans-unit>
        <trans-unit id="456113f4880e946d95b861c54ca030a6ccd9d9bc" translate="yes" xml:space="preserve">
          <source>Has no effect.</source>
          <target state="translated">Не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="ae32223dae550e038f070d4468e48d2258fd9abe" translate="yes" xml:space="preserve">
          <source>Hash-based Aggregation in Map Task</source>
          <target state="translated">Агрегация на основе хэша в задачах карты</target>
        </trans-unit>
        <trans-unit id="41e875e1fcc46eff88f8e5016b5fc7b546a006fe" translate="yes" xml:space="preserve">
          <source>Hash-based aggregation has been shown to improve the speed of group-by operations by up to 50%. However, since this is a very new feature, it is currently turned OFF by default. To turn it ON, set the property pig.exec.mapPartAgg to true.</source>
          <target state="translated">Показано,что хэш-агрегация увеличивает скорость групповых операций до 50%.Однако,поскольку это очень новая функция,по умолчанию она отключена.Чтобы включить его,установите свойство pig.exec.mapPartAgg в true.</target>
        </trans-unit>
        <trans-unit id="2c2640b5898454356e628151c15672d38e055e19" translate="yes" xml:space="preserve">
          <source>Having a deterministic schema is very powerful; however, sometimes it comes at the cost of performance. Consider the following example:</source>
          <target state="translated">Наличие детерминистической схемы очень мощно,однако иногда это происходит за счет производительности.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="bfef818e148e3b8356ff2f774f2b9ee7df4e0e3b" translate="yes" xml:space="preserve">
          <source>Here D will be splitted into:</source>
          <target state="translated">Здесь D будет разделена:</target>
        </trans-unit>
        <trans-unit id="5b126cd838c032776e841c16e4e7635096eb5aff" translate="yes" xml:space="preserve">
          <source>Here Python UDFs means C Python UDFs. It uses python command line to run the Python UDFs. It is different than Jython, which relies on Jython library. Instead, it streams the data in and out of the python process. The implementation mechanism is completely different than Jython.</source>
          <target state="translated">Здесь Python UDF означает C Python UDF.Он использует командную строку питона для запуска Python UDF.Он отличается от Jython,который полагается на Jython библиотеку.Вместо этого,она передаёт данные в и из питоновского процесса.Механизм реализации полностью отличается от Jython.</target>
        </trans-unit>
        <trans-unit id="5f2c08c455258fee101fb67d0b42f00bc1baf24c" translate="yes" xml:space="preserve">
          <source>Here are two complete Ruby UDF samples.</source>
          <target state="translated">Вот два полных образца Рубинового UDF.</target>
        </trans-unit>
        <trans-unit id="b8dcfe1b81cf245877e8f5d58903219442973ef1" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Avro values to Pig:</source>
          <target state="translated">Вот как AvroStorage переводит значения Avro в Pig:</target>
        </trans-unit>
        <trans-unit id="6e9d5893cd22a1028524ead1e3803b984d8322c6" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Pig values to Avro:</source>
          <target state="translated">Вот как AvroStorage переводит значения Pig в Avro:</target>
        </trans-unit>
        <trans-unit id="d29548e0cb2915ac50ffc61f38a48d8d0a1e70d9" translate="yes" xml:space="preserve">
          <source>Here is the code for SimpleCustomPartitioner:</source>
          <target state="translated">Вот код SimpleCustomPartitioner:</target>
        </trans-unit>
        <trans-unit id="8d42a9f211cf946a11b895acfcf50eecca384660" translate="yes" xml:space="preserve">
          <source>Here us a code snippet of the integer version of the MAX function that implements the interface:</source>
          <target state="translated">Здесь приведен фрагмент кода целочисленной версии MAX-функции,реализующей интерфейс:</target>
        </trans-unit>
        <trans-unit id="69363bb44856067aa39c56a08488523df0c874c7" translate="yes" xml:space="preserve">
          <source>Here's the way to think about this in the Hadoop world. The exec function of the Initial class is invoked once for each input tuple by the map process and produces partial results. The exec function of the Intermed class is invoked once by each combiner invocation (which can happen zero or more times) and also produces partial results. The exec function of the Final class is invoked once by the reducer and produces the final result.</source>
          <target state="translated">Вот как об этом думать в мире Хадуп.Функция выполнения класса Initial вызывается один раз для каждого входного кортежа в процессе работы с картой и дает частичный результат.Функция выполнения класса Intermed вызывается один раз при каждом вызове комбинатора (что может произойти ноль и более раз),а также дает частичный результат.Функция выполнения класса Final вызывается редуктором один раз и дает конечный результат.</target>
        </trans-unit>
        <trans-unit id="729230c39ce6b3b3af88b635a6fffcb4e16631bf" translate="yes" xml:space="preserve">
          <source>Here's what the multi-query execution does to increase the performance:</source>
          <target state="translated">Вот что делает выполнение нескольких запросов,чтобы увеличить производительность:</target>
        </trans-unit>
        <trans-unit id="d08b502754ac5a29f00b79cc168f4200278b24f3" translate="yes" xml:space="preserve">
          <source>Here, we read the file 'flights.txt' out of HDFS and store the results into the relation A. We extract a unique ID for the flight, its source and destination and the tail number from the given file. When STORE'ing back into Accumulo, we specify the column specifications (in this case, just a column family). It is also important to note that four elements are provided as columns because the first element in the Tuple is used as the row in Accumulo.</source>
          <target state="translated">Здесь мы читаем файл 'flights.txt' из HDFS и сохраняем результаты в соотношении А.Мы извлекаем уникальный идентификатор рейса,его источник и пункт назначения,а также хвостовой номер из данного файла.При возврате STORE'ing обратно в Accumulo,мы указываем спецификации столбцов (в данном случае,просто семейство столбцов).Важно также отметить,что четыре элемента предоставляются в виде колонок,поскольку первый элемент в кортеже используется в качестве строки в Accumulo.</target>
        </trans-unit>
        <trans-unit id="88f4ff51e4104da0415333a640e6fd975154c6c2" translate="yes" xml:space="preserve">
          <source>Hive UDF</source>
          <target state="translated">ОДС улей</target>
        </trans-unit>
        <trans-unit id="f9ce0b773269b974a71ef6d3a6fce10ebf9a16ec" translate="yes" xml:space="preserve">
          <source>Hive UDF name. This can be a fully qualified class name of the Hive UDF/UDTF/UDAF class, or a registered short name in Hive FunctionRegistry (most Hive builtin UDF does that)</source>
          <target state="translated">Назовите имя UDF.Это может быть полностью квалифицированное имя класса Hive UDF/UDTF/UDAF,или зарегистрированное короткое имя в Hive FunctionRegistry (большинство Hive builtin UDF делает это).</target>
        </trans-unit>
        <trans-unit id="c5b9d1b74a891758ac6053ce9ef2656a452abb0a" translate="yes" xml:space="preserve">
          <source>HiveUDAF</source>
          <target state="translated">HiveUDAF</target>
        </trans-unit>
        <trans-unit id="a7bf7f603ccf4f8e5fd4d24a6b4801fd41785386" translate="yes" xml:space="preserve">
          <source>HiveUDAF with constant parameter</source>
          <target state="translated">HiveUDAF с постоянным параметром</target>
        </trans-unit>
        <trans-unit id="6be8ec051a4a129cb854a01427a634a2d62c1beb" translate="yes" xml:space="preserve">
          <source>HiveUDF</source>
          <target state="translated">HiveUDF</target>
        </trans-unit>
        <trans-unit id="1f5b904784c7a83976cd781e900ba741b08bcc25" translate="yes" xml:space="preserve">
          <source>HiveUDF(name[, constant parameters])</source>
          <target state="translated">HiveUDF(name[,constant parameters]))</target>
        </trans-unit>
        <trans-unit id="57b25bdd42a8bfd89cde5d17150a800bbdd82d46" translate="yes" xml:space="preserve">
          <source>HiveUDF, HiveUDAF, HiveUDTF share the same syntax.</source>
          <target state="translated">HiveUDF,HiveUDAF,HiveUDTF имеют один и тот же синтаксис.</target>
        </trans-unit>
        <trans-unit id="b176b48a267bfe0c13f39e147ccb976626dc67ed" translate="yes" xml:space="preserve">
          <source>HiveUDTF</source>
          <target state="translated">HiveUDTF</target>
        </trans-unit>
        <trans-unit id="0c649e2ec017b5914ee8ac547ddec61818f46581" translate="yes" xml:space="preserve">
          <source>Horizontal ellipsis points indicate that you can repeat a portion of the code.</source>
          <target state="translated">Горизонтальные точки эллипса указывают на то,что можно повторить часть кода.</target>
        </trans-unit>
        <trans-unit id="a3c07a08d24fc29656223d7ad5fe33d21d2ff9db" translate="yes" xml:space="preserve">
          <source>HoursBetween</source>
          <target state="translated">HoursBetween</target>
        </trans-unit>
        <trans-unit id="d85ad836458e49eb6188932c56b1a9f36287859a" translate="yes" xml:space="preserve">
          <source>HoursBetween(datetime1, datetime2)</source>
          <target state="translated">Часы между (дата1,дата2)</target>
        </trans-unit>
        <trans-unit id="100cb0b9b76cf128bd36c57de623e9519f3f1a9c" translate="yes" xml:space="preserve">
          <source>How it Works</source>
          <target state="translated">Как это работает</target>
        </trans-unit>
        <trans-unit id="5a512c42842d315c68d30298afe72953eec16d9c" translate="yes" xml:space="preserve">
          <source>How to Use a Simple Eval Function</source>
          <target state="translated">Как использовать простую функцию оценки</target>
        </trans-unit>
        <trans-unit id="859136ad08aa1c154af53341ef9e723eb18c7e39" translate="yes" xml:space="preserve">
          <source>How to Write a Simple Eval Function</source>
          <target state="translated">Как написать простую функцию оценки?</target>
        </trans-unit>
        <trans-unit id="d404f08d8481d9ea8efead4d447a2938101dcb8f" translate="yes" xml:space="preserve">
          <source>How to enable Tez</source>
          <target state="translated">Как включить Tez</target>
        </trans-unit>
        <trans-unit id="9a04bea978466940a152fd73b98e9fbace4a67cf" translate="yes" xml:space="preserve">
          <source>However, if you further process relation X (Y = FILTER X BY $0 &amp;gt; 1;) there is no guarantee that the data will be processed in the order you originally specified (descending).</source>
          <target state="translated">Однако при дальнейшей обработке отношения X (Y = FILTER X BY $ 0&amp;gt; 1;) нет никакой гарантии, что данные будут обработаны в порядке, который вы первоначально указали (по убыванию).</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="74d77878ac50a503b2a5ae4d6f5d12f747eb630d" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE</source>
          <target state="translated">ILLUSTRATE</target>
        </trans-unit>
        <trans-unit id="4cf3dfa0284dcad8ef3078afd5ea4e09752b0fad" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE is based on an example generator (see &lt;a href=&quot;http://research.yahoo.com/files/paper_5.pdf&quot;&gt;Generating Example Data for Dataflow Programs&lt;/a&gt;). The algorithm works by retrieving a small sample of the input data and then propagating this data through the pipeline. However, some operators, such as JOIN and FILTER, can eliminate tuples from the data - and this could result in no data following through the pipeline. To address this issue, the algorithm will automatically generate example data, in near real-time. Thus, you might see data propagating through the pipeline that was not found in the original input data, but this data changes nothing and ensures that you will be able to examine the semantics of your Pig Latin statements.</source>
          <target state="translated">ILLUSTRATE основан на примере генератора (см. &amp;laquo; &lt;a href=&quot;http://research.yahoo.com/files/paper_5.pdf&quot;&gt;Создание примеров данных для программ потока данных&amp;raquo;&lt;/a&gt; ). Алгоритм работает, получая небольшую выборку входных данных и затем распространяя эти данные по конвейеру. Однако некоторые операторы, такие как JOIN и FILTER, могут исключать кортежи из данных - и это может привести к тому, что данные не будут проходить через конвейер. Чтобы решить эту проблему, алгоритм автоматически сгенерирует пример данных почти в реальном времени. Таким образом, вы можете увидеть данные, распространяющиеся по конвейеру, которые не были найдены в исходных входных данных, но эти данные ничего не меняют и гарантируют, что вы сможете проверить семантику ваших операторов Pig Latin.</target>
        </trans-unit>
        <trans-unit id="3eac28999aea33c81cb98bea80ea6fcce043fe8e" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE {alias | -script scriptfile};</source>
          <target state="translated">ILLUSTRATE {alias |-файл сценария};</target>
        </trans-unit>
        <trans-unit id="b034fe864d511351df0ee4a7cfd55942cb62d4ba" translate="yes" xml:space="preserve">
          <source>IMPORT</source>
          <target state="translated">IMPORT</target>
        </trans-unit>
        <trans-unit id="89fff016f6b8ebc8add59a5f8f96f47f4a92e5df" translate="yes" xml:space="preserve">
          <source>IMPORT 'file-with-macro';</source>
          <target state="translated">ВАЖНО &quot;файл с макро&quot;;</target>
        </trans-unit>
        <trans-unit id="1167b0e824163ea9e215a382f87b8f12fbf29970" translate="yes" xml:space="preserve">
          <source>IMPORT (macros)</source>
          <target state="translated">ВАЖНО (макросы)</target>
        </trans-unit>
        <trans-unit id="5badbc082509a68348d1b2de0b506786bd7658d9" translate="yes" xml:space="preserve">
          <source>IMPORT adds the macro definitions to the Pig Latin namespace; these macros can then be invoked as if they were defined in the same file.</source>
          <target state="translated">IMPORT добавляет макроопределения в пространство имён Pig Latin;эти макросы могут быть вызваны,как если бы они были определены в том же файле.</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="059d298a40b3fec4385406229f5af45d61612a3d" translate="yes" xml:space="preserve">
          <source>IN (expression)</source>
          <target state="translated">IN (выражение)</target>
        </trans-unit>
        <trans-unit id="c55aaf120352287dba10abc369c393e2d067b025" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to help reduce the need for multiple OR conditions.</source>
          <target state="translated">Оператор IN позволяет легко проверить,совпадает ли выражение с каким-либо значением в списке значений.Он используется для того,чтобы уменьшить необходимость использования нескольких условий &quot;ИЛИ&quot;.</target>
        </trans-unit>
        <trans-unit id="4d85ce819eaff4a81308dc90de69623bf9480d8a" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to reduce the need for multiple OR conditions.</source>
          <target state="translated">Оператор IN позволяет легко проверить,совпадает ли выражение с каким-либо значением в списке значений.Он используется для уменьшения необходимости использования нескольких условий &quot;ИЛИ&quot;.</target>
        </trans-unit>
        <trans-unit id="3f22e0a8543ace135a5f509674fc4700b89a5896" translate="yes" xml:space="preserve">
          <source>IN operator is equivalent to nested OR operators.</source>
          <target state="translated">Оператор IN эквивалентен вложенным операторам ИЛИ.</target>
        </trans-unit>
        <trans-unit id="d219b4dc13cdee432eb9cf599decd114b681ee36" translate="yes" xml:space="preserve">
          <source>INDEXOF</source>
          <target state="translated">INDEXOF</target>
        </trans-unit>
        <trans-unit id="2c95e05e2e3fc975e680d037087c38ecaa793399" translate="yes" xml:space="preserve">
          <source>INDEXOF(string, 'character', startIndex)</source>
          <target state="translated">INDEXOF(string,'character',startIndex)</target>
        </trans-unit>
        <trans-unit id="091cedb09a5345c158de5c9b9ce5201d93e5d038" translate="yes" xml:space="preserve">
          <source>INPUT &amp;ndash; Keyword.</source>
          <target state="translated">ВВОД - Ключевое слово.</target>
        </trans-unit>
        <trans-unit id="e2e6f67f49f77e6f17a5a4a70377d85084890b16" translate="yes" xml:space="preserve">
          <source>INPUT ( {stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer] &amp;hellip;] )</source>
          <target state="translated">INPUT ({stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer]&amp;hellip;])</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="0fe012d40367d7664e9b3bf78c05516e6b49cdfd" translate="yes" xml:space="preserve">
          <source>Identifiers include the names of relations (aliases), fields, variables, and so on. In Pig, identifiers start with a letter and can be followed by any number of letters, digits, or underscores.</source>
          <target state="translated">Идентификаторы включают в себя названия отношений (псевдонимы),полей,переменных и так далее.В Pig идентификаторы начинаются с буквы и могут сопровождаться любым количеством букв,цифр или символов подчеркивания.</target>
        </trans-unit>
        <trans-unit id="33cf76ea88eecf41631c2c6696ed2f52f782942a" translate="yes" xml:space="preserve">
          <source>If A is a relation (outer bag), a FOREACH statement could look like this.</source>
          <target state="translated">Если А-это родственник (внешняя сумка),заявление ФОРЕХА может выглядеть так.</target>
        </trans-unit>
        <trans-unit id="afe0e53cb4d9d90b6ba1aca74a93d2f8445ecde1" translate="yes" xml:space="preserve">
          <source>If A is an inner bag, a FOREACH statement could look like this.</source>
          <target state="translated">Если &quot;А&quot;-это внутренняя сумка,заявление ФОРЕХА может выглядеть вот так.</target>
        </trans-unit>
        <trans-unit id="3c63da8e13e1306df1c5329f267b1cf013f00c39" translate="yes" xml:space="preserve">
          <source>If CUBE and ROLLUP operations are used together, the output groups will be the cross product of all groups generated by cube and rollup operation. If there are m dimensions in cube operations and n dimensions in rollup operation then overall number of combinations will be (2^m) * (n+1).</source>
          <target state="translated">Если операции CUBE и ROLLUP используются вместе,то группы вывода будут представлять собой перекрестный продукт всех групп,генерируемых операцией &quot;куб&quot; и операцией &quot;рулон&quot;.Если в операциях куба m размеров и n размеров в операции отката,то общее количество комбинаций будет (2^m)*(n+1).</target>
        </trans-unit>
        <trans-unit id="53995723b5b706a6616e5f264aad6a4b93b46fe0" translate="yes" xml:space="preserve">
          <source>If MyUDF is algebraic, the query will use combiner and run much faster. You can run explain command on your query to make sure that combiner is used.</source>
          <target state="translated">Если MyUDF алгебраический,то запрос будет использовать комбинатор и выполняться намного быстрее.Вы можете запустить команду explain в вашем запросе,чтобы убедиться,что используется комбинатор.</target>
        </trans-unit>
        <trans-unit id="fbc88faf080a72258643a84cf95f10e149e13ae3" translate="yes" xml:space="preserve">
          <source>If Pig cannot resolve incompatible types through implicit casts, an error will occur. For example, you cannot add chararray and float (see the &lt;a href=&quot;#types-table-add&quot;&gt;Types Table for addition and subtraction&lt;/a&gt;).</source>
          <target state="translated">Если Pig не может разрешить несовместимые типы посредством неявного приведения, произойдет ошибка. Например, вы не можете добавить chararray и float (см. &lt;a href=&quot;#types-table-add&quot;&gt;Таблицу типов для сложения и вычитания&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e01f1d7383a02a96bedbc379dd0c0288bc379a73" translate="yes" xml:space="preserve">
          <source>If Pig determines that it needs to auto-ship an absolute path it will not ship it at all since there is no way to ship files to the necessary location (lack of permissions and so on).</source>
          <target state="translated">Если Свинья определит,что ей необходимо автоматически отправить абсолютный путь,она не будет отправлять его вообще,так как нет возможности отправить файлы в нужное место (отсутствие прав и т.д.).</target>
        </trans-unit>
        <trans-unit id="e62658035d80920f5b1abb78f7987725661dad47" translate="yes" xml:space="preserve">
          <source>If Pig is unable to process the expression, Pig returns an exception.</source>
          <target state="translated">Если Свинья не может обработать выражение,Свинья возвращает исключение.</target>
        </trans-unit>
        <trans-unit id="3816a983fff2acee696300df0a392ba6e758130e" translate="yes" xml:space="preserve">
          <source>If a UDF returns a tuple or a bag and schema information is not provided, Pig assumes that the tuple contains a single field of type bytearray. If this is not the case, then not specifying the schema can cause failures. We look at this next.</source>
          <target state="translated">Если UDF возвращает кортеж кортежа или пакет и информация о схеме не предоставляется,Pig предполагает,что кортеж содержит одно поле типа bytearray.Если это не так,то отсутствие указания схемы может привести к сбоям.Мы рассмотрим это далее.</target>
        </trans-unit>
        <trans-unit id="486e4f66991631e2d049a07741fd4d7ef1bfe823" translate="yes" xml:space="preserve">
          <source>If a custom loader using a text-based InputFormat or a file-based InputFormat would like to read files in all subdirectories under a given input directory recursively, then it should use the PigTextInputFormat and PigFileInputFormat classes provided in org.apache.pig.backend.hadoop.executionengine.mapReduceLayer. The Pig InputFormat classes work around a current limitation in the Hadoop TextInputFormat and FileInputFormat classes which only read one level down from the provided input directory. For example, if the input in the load statement is 'dir1' and there are subdirs 'dir2' and 'dir2/dir3' beneath dir1, the Hadoop TextInputFormat and FileInputFormat classes read the files under 'dir1' only. Using PigTextInputFormat or PigFileInputFormat (or by extending them), the files in all the directories can be read.</source>
          <target state="translated">Если пользовательский загрузчик,использующий текстовый InputFormat или файловый InputFormat,хочет рекурсивно читать файлы во всех подкаталогах под заданным входным каталогом,то он должен использовать классы PigTextInputFormat и PigFileInputFormat,предоставленные в org.apache.pig.backend.backend.hadoop.executionengine.mapReduceLayer.Классы PigFutFormat работают вокруг текущего ограничения в классах Hadoop TextInputFormat и FileInputFormat,которые читают только на один уровень ниже из предоставленной директории ввода.Например,если в операторе загрузки вводится 'dir1',а под dir1 находятся поддиректории 'dir2' и 'dir2/dir3',то классы Hadoop TextInputFormat и FileInputFormat читают файлы только под директрисой 'dir1'.Используя PigTextInputFormat или PigFileInputFormat (или расширяя их),можно читать файлы во всех каталогах.</target>
        </trans-unit>
        <trans-unit id="a4794078ab3e12dc82064bb4f0a80d07b3c59c8f" translate="yes" xml:space="preserve">
          <source>If a function is algebraic but can be used in a FOREACH statement with accumulator functions, it needs to implement the Accumulator interface in addition to the Algebraic interface.</source>
          <target state="translated">Если функция является алгебраической,но может быть использована в выписке FOREACH с функциями аккумулятора,необходимо реализовать интерфейс Accumulator в дополнение к алгебраическому интерфейсу.</target>
        </trans-unit>
        <trans-unit id="ccda3daa249c8bc65b4370e66326a311939c526e" translate="yes" xml:space="preserve">
          <source>If a loader implements IndexableLoadFunc, or implements OrderedLoadFunc and CollectableLoadFunc, its input splits won't be subject to possible combinations.</source>
          <target state="translated">Если загрузчик реализует IndexableLoadFunc или реализует OrderedLoadFunc и CollectableLoadFunc,его входные сплайты не будут подвержены возможным комбинациям.</target>
        </trans-unit>
        <trans-unit id="d22536397a6526bff16d2b44ae5ad32b2dad3166" translate="yes" xml:space="preserve">
          <source>If a schema is defined as part of a load statement, the load function will attempt to enforce the schema. If the data does not conform to the schema, the loader will generate a null value or an error.</source>
          <target state="translated">Если схема определена как часть оператора нагрузки,функция загрузки попытается принудительно применить схему.Если данные не соответствуют схеме,загрузчик сгенерирует нулевое значение или ошибку.</target>
        </trans-unit>
        <trans-unit id="d20b21a086aff45ff998ceac8189b33486fbc4c6" translate="yes" xml:space="preserve">
          <source>If a script has dependencies on the execution order outside of what Pig knows about, execution may fail.</source>
          <target state="translated">Если у скрипта есть зависимости от порядка выполнения,отличного от того,о чем знает Pig,то выполнение может быть неудачным.</target>
        </trans-unit>
        <trans-unit id="c60b8394e3c8ca844c4dd6c95b31ff82395596c7" translate="yes" xml:space="preserve">
          <source>If a script with a alias is specified, it will output the plan for the given alias.</source>
          <target state="translated">Если указан скрипт с псевдонимом,он выведет план для данного псевдонима.</target>
        </trans-unit>
        <trans-unit id="c929a573b654a6447af3bebd28ecf3072a0bfa7e" translate="yes" xml:space="preserve">
          <source>If a script without an alias is specified, it will output the entire execution graph (logical, physical, or map reduce).</source>
          <target state="translated">Если указан скрипт без псевдонима,то он выведет весь график выполнения (логический,физический,или уменьшенный на карту).</target>
        </trans-unit>
        <trans-unit id="7b66f4af28f8442dd36e47f974b35d46ae1ab601" translate="yes" xml:space="preserve">
          <source>If a type is declared then ALL values in the map must be of this type.</source>
          <target state="translated">Если тип объявлен,то ВСЕ значения на карте должны быть этого типа.</target>
        </trans-unit>
        <trans-unit id="a9165157e4c228dc6b25213c7bef47de768cebba" translate="yes" xml:space="preserve">
          <source>If an explicit cast is not supported, an error will occur. For example, you cannot cast a chararray to int.</source>
          <target state="translated">Если явное приведение не поддерживается,произойдет ошибка.Например,невозможно привести символ chararray к int.</target>
        </trans-unit>
        <trans-unit id="1c8c61b8e893dc2134f7b454bd561bcf24bcadc6" translate="yes" xml:space="preserve">
          <source>If any subexpression is null, the resulting expression is null.</source>
          <target state="translated">Если какое-либо подвыражение является нулевым,то результирующее выражение является нулевым.</target>
        </trans-unit>
        <trans-unit id="bb9518c418a6a42b64160ff3fdffbdf9e983c161" translate="yes" xml:space="preserve">
          <source>If arguments are not bags, an IOException is thrown.</source>
          <target state="translated">Если аргументы не мешки,то бросается IOException.</target>
        </trans-unit>
        <trans-unit id="67c0548636f03fb391aff763f50ae24a819f4ca2" translate="yes" xml:space="preserve">
          <source>If desired, custom logic can also be implemented for error handling by creating a subclass of MonitoredUDFExecutor.ErrorCallback, and overriding its handleError and/or handleTimeout methods. Both of those methods are static, and are passed in the instance of the EvalFunc that produced an exception, as well as an exception, so you may use any state you have in the UDF to process the errors as desired. The default behavior is to increment Hadoop counters every time an error is encountered. Once you have an implementation of the ErrorCallback that performs your custom logic, you can provide it in the annotation:</source>
          <target state="translated">При желании пользовательская логика также может быть реализована для обработки ошибок путем создания подкласса MonitoredUDFExecutor.ErrorCallback и переопределения его методов handleError и/или handleTimeout.Оба этих метода являются статическими и передаются в экземпляре EvalFunc,который создал исключение,так же как и исключение,поэтому вы можете использовать любое состояние,которое у вас есть в UDF,чтобы обрабатывать ошибки по своему усмотрению.Поведение по умолчанию заключается в инкременте счетчиков Hadoop каждый раз,когда возникает ошибка.Как только у вас появится реализация ErrorCallback,выполняющая вашу пользовательскую логику,вы можете предоставить её в аннотации:</target>
        </trans-unit>
        <trans-unit id="a9eef31189a46ca896e1a11d04cfdc69be907574" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the result is null.</source>
          <target state="translated">Если любое из подвыражений равно нулю,то результат будет нулевым.</target>
        </trans-unit>
        <trans-unit id="fbb8787a10e9277578f3bacf3c583933a72af49a" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the resulting expression is null.</source>
          <target state="translated">Если любое из подвыражений является нулевым,то результирующее выражение является нулевым.</target>
        </trans-unit>
        <trans-unit id="df9492dcb135b34471ac4c01597f6c3e6e9d0c72" translate="yes" xml:space="preserve">
          <source>If either the string being matched against or the string defining the match is null, the result is null.</source>
          <target state="translated">Если либо совпадающая строка,либо строка,определяющая соответствие,будет нулевой,то результат будет нулевым.</target>
        </trans-unit>
        <trans-unit id="7c7b8337ae5bc3235aee39b3bf00c4a3b18c0f1e" translate="yes" xml:space="preserve">
          <source>If field_delimiter is null or not passed, the following will be used as delimiters: space [ ], double quote [ &quot; ], coma [ , ] parenthesis [ () ], star [ * ].</source>
          <target state="translated">Если параметр field_delimiter равен нулю или не передан,в качестве разделителей будут использоваться:пробел[],двойная кавычка[&quot; ],кома[,],круглая скобка[()],звезда[*].</target>
        </trans-unit>
        <trans-unit id="d38b38abb97f4eb1e0dcf9186921de58382f8118" translate="yes" xml:space="preserve">
          <source>If invoking Pig in Java, there is change in PigStats and PigProgressNotificationListener if using PigRunner.run(), check &lt;a href=&quot;test#pig-statistics&quot;&gt;Pig Statistics&lt;/a&gt; and &lt;a href=&quot;test#ppnl&quot;&gt;Pig Progress Notification Listener&lt;/a&gt;</source>
          <target state="translated">Если применение Свиньи в Java, есть изменения в PigStats и PigProgressNotificationListener при использовании PigRunner.run (), проверьте &lt;a href=&quot;test#pig-statistics&quot;&gt;Pig Статистики&lt;/a&gt; и &lt;a href=&quot;test#ppnl&quot;&gt;Pig Progress Извещения Слушателя&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94ca295cf76f515a0109ec429d1f4a34670cbbe4" translate="yes" xml:space="preserve">
          <source>If load statement specify a schema, Pig will convert the complex type according to schema. If conversion fails, the affected item will be null (see &lt;a href=&quot;basic#nulls&quot;&gt;Nulls and Pig Latin&lt;/a&gt;).</source>
          <target state="translated">Если оператор load задает схему, Pig преобразует сложный тип в соответствии со схемой. Если конверсия не удалась, затронутый элемент будет нулевым (см. &lt;a href=&quot;basic#nulls&quot;&gt;Null и Pig Latin&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9f3c3c0240ae80e56e35fc2fe724ffaf7f5b93b5" translate="yes" xml:space="preserve">
          <source>If neither &quot;set default parallel&quot; nor the PARALLEL clause are used, Pig sets the number of reducers using a heuristic based on the size of the input data. You can set the values for these properties:</source>
          <target state="translated">Если ни &quot;установить параллель по умолчанию&quot;,ни пункт PARALLEL не используются,Pig задает количество редукторов с помощью эвристики,основываясь на размере входных данных.Вы можете задать значения для этих свойств:</target>
        </trans-unit>
        <trans-unit id="c1dbfad22027ead0b9c53033155be2cdf92f70af" translate="yes" xml:space="preserve">
          <source>If no script is given:</source>
          <target state="translated">Если скрипт не задан:</target>
        </trans-unit>
        <trans-unit id="3c30b8a15458b41c3c14a039867b1afab3f19551" translate="yes" xml:space="preserve">
          <source>If null, bag arguments are replaced by empty bags.</source>
          <target state="translated">Если ноль,аргументы в пользу мешков заменяются на пустые мешки.</target>
        </trans-unit>
        <trans-unit id="1f86825c5ae24539f35706c23d25d87bce6d588c" translate="yes" xml:space="preserve">
          <source>If one is running Pig in Tez mode (or both Tez/MapReduce mode), should pass PigTezProgressNotificationListener which extends PigProgressNotificationListener to PigRunner.run() to make sure to get notification in both Tez mode or MapReduce mode.</source>
          <target state="translated">Если PigProgressNotificationListener работает в режиме Tez (или в обоих режимах Tez/MapReduce),необходимо передать PigTezProgressNotificationListener,который расширяет PigProgressNotificationListener на PigRunner.run(),чтобы удостовериться в том,что вы получили уведомление в режиме Tez или MapReduce.</target>
        </trans-unit>
        <trans-unit id="a520e683b22094fd77e688c9dcd1fed6eddf94bb" translate="yes" xml:space="preserve">
          <source>If one of the data sets is small enough to fit into memory, a Replicated Join is very likely to provide better performance.</source>
          <target state="translated">Если один из наборов данных достаточно мал,чтобы поместиться в память,то Replicated Join,скорее всего,обеспечит лучшую производительность.</target>
        </trans-unit>
        <trans-unit id="207190487fec91fe50bf8a8e561b556722ac4451" translate="yes" xml:space="preserve">
          <source>If only one argument is given, the field is delimited with underscore characters</source>
          <target state="translated">Если задан только один аргумент,то поле делится символами подчеркивания</target>
        </trans-unit>
        <trans-unit id="979bda1c695b72deb2de992c0dbc8fd750122f17" translate="yes" xml:space="preserve">
          <source>If parameters are specified in the Pig command line or in a parameter file, the script should include a $param_name for each para_name included in the command line or parameter file.</source>
          <target state="translated">Если параметры заданы в командной строке Pig или в файле параметров,скрипт должен включать имя $param_name для каждого имени para_name,включенного в командную строку или файл параметров.</target>
        </trans-unit>
        <trans-unit id="b3bd4de29e52beea43d5160ea3b5d527766906ff" translate="yes" xml:space="preserve">
          <source>If parameters are specified using the preprocessor statements, the script should include either %declare or %default.</source>
          <target state="translated">Если параметры задаются с помощью операторов препроцессора,то скрипт должен включать либо %declare,либо %default.</target>
        </trans-unit>
        <trans-unit id="52ce5e98f919ecf8fe4edf9131ddd0faddc8d6f2" translate="yes" xml:space="preserve">
          <source>If sort is provided by the loader, rather than an explicit Order operation, the right-side loader must implement either the {OrderedLoadFunc} interface or {IndexableLoadFunc} interface.</source>
          <target state="translated">Если загрузчик предоставляет сортировку,а не явные операции Order,то правый загрузчик должен реализовать либо интерфейс {OrderedLoadFunc},либо интерфейс {IndexableLoadFunc}.</target>
        </trans-unit>
        <trans-unit id="aee0b5384005bdfb9e581a456be8ae8427f85fcd" translate="yes" xml:space="preserve">
          <source>If tagPath or tagFile option is specified, PigStorage will add a pseudo-column INPUT_FILE_PATH or INPUT_FILE_NAME respectively to the beginning of the record. As the name suggests, it is the input file path/name containing this particular record. Please note tagsource is deprecated.</source>
          <target state="translated">Если указана опция tagPath или tagFile,PigStorage добавит псевдо-колонку INPUT_FILE_PATH или INPUT_FILE_NAME соответственно к началу записи.Как следует из названия,это путь/название входного файла,содержащего именно эту запись.Обратите внимание,что источник тегов является устаревшим.</target>
        </trans-unit>
        <trans-unit id="0d16362f5232337bd67ea5e2e860c60236bd2764" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used, enclose the schema in parentheses.</source>
          <target state="translated">Если &lt;a href=&quot;#flatten&quot;&gt;используется&lt;/a&gt; оператор FLATTEN , заключите схему в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="0caf7a1673c2590cb133f449af480656dad1cb8b" translate="yes" xml:space="preserve">
          <source>If the FLATTEN operator is not used, don't enclose the schema in parentheses.</source>
          <target state="translated">Если оператор FLATTEN не используется,не заключайте схему в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="8742c01ca7dfdb8c7b97679f58a80857cfe6e74b" translate="yes" xml:space="preserve">
          <source>If the STORE and LOAD both had exact matching file paths, Pig will recognize the implicit dependency and launch two different mapreduce jobs/Tez DAGs with the second job depending on the output of the first one. exec is not required to be specified in that case.</source>
          <target state="translated">Если STORE и LOAD оба имели точно совпадающие пути к файлам,Pig распознает неявную зависимость и запустит два разных задания mapreduce/Tez DAG со вторым заданием в зависимости от вывода первого.выполнение в этом случае не требуется.</target>
        </trans-unit>
        <trans-unit id="ce8a9990603bf3420d85f373d9702d4a3cac5619" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default load function PigStorage is used.</source>
          <target state="translated">Если пункт USING опущен,используется функция загрузки по умолчанию PigStorage.</target>
        </trans-unit>
        <trans-unit id="caf383bc86d8a53d213a4ff08b295b5cdb463fbc" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default store function PigStorage is used.</source>
          <target state="translated">Если пункт USING опущен,используется функция хранения по умолчанию PigStorage.</target>
        </trans-unit>
        <trans-unit id="8ade11ca523a11122e604fa8fcd322615b76561d" translate="yes" xml:space="preserve">
          <source>If the build is successful, you should see the pig.jar file created in that directory.</source>
          <target state="translated">Если сборка прошла успешно,вы должны увидеть файл pig.jar,созданный в этом каталоге.</target>
        </trans-unit>
        <trans-unit id="2e73841d4f5c17efd8924856bacadb48c1718106" translate="yes" xml:space="preserve">
          <source>If the de-referenced tuple or map is null, returns null.</source>
          <target state="translated">Если кортеж или карта,на которые не ссылаются,равны нулю,возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="136bbc1ae8c1804896ccba758e270481404a38b7" translate="yes" xml:space="preserve">
          <source>If the first word on the streaming command is perl or python, Pig assumes that the binary is the first non-quoted string it encounters that does not start with dash.</source>
          <target state="translated">Если первое слово в стриминговой команде-perl или python,Pig предполагает,что двоичный файл-это первая нецитируемая строка,с которой он сталкивается и которая не начинается с тире.</target>
        </trans-unit>
        <trans-unit id="2edbaa925c2b4bb7fab3191de0feae3407e8c8ae" translate="yes" xml:space="preserve">
          <source>If the group-by keys used for grouping don't result in a sufficient reduction in the number of records, the performance might be worse with this feature turned ON. To prevent this from happening, the feature turns itself off if the reduction in records sent to combiner is not more than a configurable threshold. This threshold can be set using the property pig.exec.mapPartAgg.minReduction. It is set to a default value of 10, which means that the number of records that get sent to the combiner should be reduced by a factor of 10 or more.</source>
          <target state="translated">Если используемые для группировки ключи не приводят к достаточному сокращению количества записей,производительность может быть хуже при включении этой функции.Чтобы этого не произошло,функция отключается,если уменьшение количества записей,отправляемых в сумматор,не превышает настраиваемого порога.Этот порог может быть установлен с помощью свойства pig.exec.mapPartAgg.minReduction.Оно установлено в значение по умолчанию 10,что означает,что количество записей,отправляемых в комбинатор,должно быть уменьшено в 10 или более раз.</target>
        </trans-unit>
        <trans-unit id="f0a0dbd61aa62c74fcf75355267ae83889868c65" translate="yes" xml:space="preserve">
          <source>If the input relation has a schema, you can refer to columns by alias rather than by column position. You can also combine aliases and column positions in an expression; for example, &quot;col1 .. $5&quot; is valid.</source>
          <target state="translated">Если входное отношение имеет схему,то к столбцам можно обращаться не по положению столбцов,а по псевдониму.Можно также комбинировать псевдонимы и позиции столбцов в выражении;например,&quot;столбец1 ...$5&quot; является действительным.</target>
        </trans-unit>
        <trans-unit id="1aceb56e8670ae04161c5161bd71a70daf79faf0" translate="yes" xml:space="preserve">
          <source>If the macro has no return alias, then void must be specified.</source>
          <target state="translated">Если у макроса нет возвращаемого псевдонима,то должен быть указан недействительный.</target>
        </trans-unit>
        <trans-unit id="ab05a18b7e2fd87f280e1388a3db09480d98d569" translate="yes" xml:space="preserve">
          <source>If the noschema option is NOT specified, and a schema is found, it gets loaded when loading data.</source>
          <target state="translated">Если опция noschema НЕ указана,а схема найдена,то она загружается при загрузке данных.</target>
        </trans-unit>
        <trans-unit id="cc815978d8fbacfa3f024e4ccf2f529fd09fcb51" translate="yes" xml:space="preserve">
          <source>If the parameters of the EvalFunc are all constants, Pig could evaluate the result at compile time. The benefit of evaluating at compile time is performance optimization, and enable certain other optimizations at front end (such as partition pruning, which only allow constant not UDF in filter condition). By default, compile time evaluation is disabled in EvalFunc to prevent potential side effect. To enable it, override allowCompileTimeCalculation. For example:</source>
          <target state="translated">Если все параметры EvalFunc являются константами,то Pig может оценить результат во время компиляции.Преимуществом оценки во время компиляции является оптимизация производительности,а также включение некоторых других оптимизаций на фронтальной стороне (таких как обрезка разделов,которая допускает только константы,а не UDF в состоянии фильтра).По умолчанию,оценка времени компиляции отключена в EvalFunc для предотвращения потенциального побочного эффекта.Чтобы включить ее,переопределите allowCompileTimeCalculation.Например:</target>
        </trans-unit>
        <trans-unit id="37792a4c1c43f548d87fd2c3c9b325971248e022" translate="yes" xml:space="preserve">
          <source>If the query is rewritten to</source>
          <target state="translated">Если запрос переписан на</target>
        </trans-unit>
        <trans-unit id="884e911c9fc042d4017b9c9111d9b8041a7952e3" translate="yes" xml:space="preserve">
          <source>If the result value is not a number (NaN), Pig returns null.</source>
          <target state="translated">Если значение результата не является числом (NaN),Свинья возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="7c1585043821cee828c177bd1dee01acb15c382d" translate="yes" xml:space="preserve">
          <source>If the result value is null or empty, Pig returns null.</source>
          <target state="translated">Если значение результата нулевое или пустое,Свинья возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="832a57705057f4442db3191d05182bfe04aabc3e" translate="yes" xml:space="preserve">
          <source>If the schema is null, Pig treats all fields as bytearray (in the backend, Pig will determine the real type for the fields dynamically)</source>
          <target state="translated">Если схема нулевая,Pig рассматривает все поля как байтеррей (в бекенде Pig будет определять реальный тип для полей динамически)</target>
        </trans-unit>
        <trans-unit id="b0b624c38d08281a478732651dc5b82106034b90" translate="yes" xml:space="preserve">
          <source>If the schema of a relation can&amp;rsquo;t be inferred, Pig will just use the runtime data as is and propagate it through the pipeline.</source>
          <target state="translated">Если схема отношения не может быть выведена, Pig просто использует данные времени выполнения как есть и распространяет их по конвейеру.</target>
        </trans-unit>
        <trans-unit id="0e6717986491eb0953097c78d9d3c2a67abe2393" translate="yes" xml:space="preserve">
          <source>If the schema option is NOT specified, a schema will not be written when storing data.</source>
          <target state="translated">Если параметр &quot;Схема&quot; не указан,то при хранении данных схема не будет записываться.</target>
        </trans-unit>
        <trans-unit id="ff2b36c03367bc79f4d31985e06636e1530acb9a" translate="yes" xml:space="preserve">
          <source>If the schema option is specified, a hidden &quot;.pig_schema&quot; file is created in the output directory when storing data. It is used by PigStorage (with or without -schema) during loading to determine the field names and types of the data without the need for a user to explicitly provide the schema in an as clause, unless noschema is specified. No attempt to merge conflicting schemas is made during loading. The first schema encountered during a file system scan is used.</source>
          <target state="translated">Если указана опция схемы,то при хранении данных в выходном каталоге создается скрытый файл &quot;.pig_schema&quot;.Он используется PigStorage (с -schema или без -schema)во время загрузки для определения имен полей и типов данных без необходимости явного указания пользователем схемы в виде пункта,если только не указана noschema.Никаких попыток объединения конфликтующих схем во время загрузки не предпринимается.Используется первая схема,встречающаяся во время сканирования файловой системы.</target>
        </trans-unit>
        <trans-unit id="eda78a9c0114a6e6fb5cb21af8108768e29477da" translate="yes" xml:space="preserve">
          <source>If the script doesn't re-load A' for the processing of A the steps above A' will be duplicated. This is a special case of Example 2 above, so the same steps are recommended. With multi-query execution, the script will process A and dump A' as a side-effect.</source>
          <target state="translated">Если скрипт не перезагрузит A' для обработки A,то шаги,описанные выше A',будут продублированы.Это особый случай Примера 2 выше,поэтому рекомендуются те же самые шаги.При выполнении нескольких запросов скрипт будет обрабатывать A и дамп A' как побочный эффект.</target>
        </trans-unit>
        <trans-unit id="56ff9b9e7d57fa5c8fe5a67569d32c6b3312a279" translate="yes" xml:space="preserve">
          <source>If the ship and cache options are not specified, Pig will attempt to auto-ship the binary in the following way:</source>
          <target state="translated">Если опции &quot;корабль&quot; и &quot;кэш&quot; не заданы,Pig попытается автоматически отправить двоичный файл следующим образом:</target>
        </trans-unit>
        <trans-unit id="6540b7615ec5950ced044baf9a5fecbbb70e65b7" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is equal to or exceeds the number of tuples in the relation, all tuples in the relation are returned.</source>
          <target state="translated">Если указанное количество выходных кортежей равно или превышает количество кортежей в соотношении,то возвращаются все кортежи в соотношении.</target>
        </trans-unit>
        <trans-unit id="661dd3451b1f1f8a9425df1c0a8c2855275567c4" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is less than the number of tuples in the relation, then n tuples are returned. There is no guarantee which n tuples will be returned, and the tuples that are returned can change from one run to the next. A particular set of tuples can be requested using the ORDER operator followed by LIMIT.</source>
          <target state="translated">Если указанное количество выходных кортежей меньше,чем количество кортежей в соотношении,то возвращается n кортежей.Нет гарантии,какой кортеж n будет возвращен,и возвращаемые кортежи могут меняться от одного прогона к другому.Определенный набор кортежей можно запросить с помощью оператора ORDER,за которым следует LIMIT.</target>
        </trans-unit>
        <trans-unit id="018691f5562232d00cbae123ff01bedb87fa8b15" translate="yes" xml:space="preserve">
          <source>If the tested object is null, returns null.</source>
          <target state="translated">Если тестируемый объект равен нулю,возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="9e1b93c2a09e03a21f0905f246868a8fad2e9176" translate="yes" xml:space="preserve">
          <source>If the tested object is null, the SIZE function returns null.</source>
          <target state="translated">Если тестируемый объект равен нулю,функция SIZE возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="52452dd37cfe0e014d1a5eeb279eb873c8dd2f17" translate="yes" xml:space="preserve">
          <source>If the tested value is not null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="translated">Если проверенное значение не является нулем, возвращает true; в противном случае возвращает false (см. &lt;a href=&quot;#null_operators&quot;&gt;нулевые операторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="05bcf78db415053b73d510bab61b81cfa58b8490" translate="yes" xml:space="preserve">
          <source>If the tested value is null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="translated">Если проверенное значение равно нулю, возвращает true; в противном случае возвращает false (см. &lt;a href=&quot;#null_operators&quot;&gt;нулевые операторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45e72887e023eb789c7ad2ce2f5d3f8a9395e06f" translate="yes" xml:space="preserve">
          <source>If the the underlying data is sufficiently skewed, bloom join might not help. Skewed join can be considered for those cases.</source>
          <target state="translated">Если исходные данные достаточно искажены,то соединение цветов может не помочь.В таких случаях можно рассмотреть перекошенный шарнир.</target>
        </trans-unit>
        <trans-unit id="a278eee26bc0d40cd14c07492b34d0e32ef8c022" translate="yes" xml:space="preserve">
          <source>If the type is omitted, the field defaults to type bytearray.</source>
          <target state="translated">Если тип опущен,по умолчанию в поле вводится байтаррей.</target>
        </trans-unit>
        <trans-unit id="df75bf757439ba68f277b7d366c1fe4887dcb0d3" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied for the length of the result tuple.</source>
          <target state="translated">При отрицательном значении длина кортежа результата не ограничивается.</target>
        </trans-unit>
        <trans-unit id="36672551acc7fb0ca7d3aa692155b038a5a092b7" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied to the size of the result bag.</source>
          <target state="translated">Если значение отрицательное,то ограничение на размер пакета с результатами не применяется.</target>
        </trans-unit>
        <trans-unit id="989efda04814537696830f9d12387663f1d8fe4d" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum length of the result tuple. The last element of the result tuple will contain all input after the last match.</source>
          <target state="translated">Если значение положительное,то шаблон (скомпилированное представление регулярного выражения)применяется максимум 1 раз,поэтому значение аргумента означает максимальную длину кортежа результата.Последний элемент кортежа результата будет содержать все входные данные после последнего совмещения.</target>
        </trans-unit>
        <trans-unit id="c6d264e7216fcd7fd94f7b27901536988583458c" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum size of the result bag. The last tuple of the result bag will contain all input after the last match.</source>
          <target state="translated">Если значение положительное,то шаблон (скомпилированное представление регулярного выражения)применяется максимум 1 раз,поэтому значение аргумента означает максимальный размер пакета результатов.Последний кортеж результирующего мешка будет содержать все входные данные после последнего совмещения.</target>
        </trans-unit>
        <trans-unit id="03070291f5db09d8b1e48844535ce39e98bd447f" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied for the length of the result tuple too, and trailing empty strings (if any) will be removed.</source>
          <target state="translated">Если значение равно нулю,то ограничение на длину кортежа результата тоже не применяется,и пустые строки в трейлинге (если таковые имеются)будут удалены.</target>
        </trans-unit>
        <trans-unit id="7e89973f6facf127728c69232069efe9c532fbb6" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied to the size of the result bag too, and trailing empty strings (if any) will be removed.</source>
          <target state="translated">Если значение равно нулю,то не применяется ограничение и на размер пакета результата,и пустые строки в трейлинге (если таковые имеются)будут удалены.</target>
        </trans-unit>
        <trans-unit id="6231df4fcddcd0669f4101ebd7715a2f671b8fe9" translate="yes" xml:space="preserve">
          <source>If there is a filter statement right after OrcStorage, Pig will push the filter condition to the loader. OrcStorage will prune file/stripe/row group which does not satisfy the condition entirely. For the file/stripe/row group contains data that satisfies the filter condition, OrcStorage will load the file/stripe/row group and Pig will evaluate the filter condition again to remove additional data which does not satisfy the filter condition.</source>
          <target state="translated">Если сразу после OrcStorage появляется оператор фильтра,Свинья подтолкнет состояние фильтра к загрузчику.OrcStorage урежет файл/полоску/группу строк,которая не полностью удовлетворяет условию.Для файла/полосы/группы строк,содержащей данные,удовлетворяющие условию фильтра,OrcStorage загрузит файл/полоску/группу строк,а Pig снова оценит состояние фильтра,чтобы удалить дополнительные данные,не удовлетворяющие условию фильтра.</target>
        </trans-unit>
        <trans-unit id="59ca04d3d9150ea272608b03ae0156c687fc7b38" translate="yes" xml:space="preserve">
          <source>If types are not specified in the load statement, Pig assumes the type of =double= for numeric computations. A lot of the time, your data would be much smaller, maybe, integer or long. Specifying the real type will help with speed of arithmetic computation. It has an additional advantage of early error detection.</source>
          <target state="translated">Если типы не указаны в операторе нагрузки,Pig предполагает тип =double=для числовых вычислений.В большинстве случаев ваши данные будут намного меньше,может быть,целочисленными или длинными.Указание вещественного типа поможет ускорить арифметические вычисления.Это имеет дополнительное преимущество раннего обнаружения ошибок.</target>
        </trans-unit>
        <trans-unit id="24fb50f409eb821f7919123b47b4f273f7700fc1" translate="yes" xml:space="preserve">
          <source>If user specify neither &quot;parallel&quot; or &quot;default_parallel&quot;, Pig will use automatic parallelism. In MapReduce, Pig submit one MapReduce job a time and before submiting a job, Pig has chance to automatically set reduce parallelism based on the size of input file. On the contrary, Tez submit a DAG as a unit and automatic parallelism is managed in three parts</source>
          <target state="translated">Если пользователь не укажет ни &quot;parallel&quot;,ни &quot;default_parallel&quot;,Pig будет использовать автоматический параллелизм.В MapReduce,Pig подает одно задание MapReduce за раз,и перед подачей задания,Pig имеет возможность автоматически установить понижающий параллелизм,исходя из размера входного файла.Напротив,Tez представляет группу DAG как единое целое,и автоматический параллелизм управляется тремя частями</target>
        </trans-unit>
        <trans-unit id="b4dc665c403c330f35903b458f6fe6096a2ced59" translate="yes" xml:space="preserve">
          <source>If you FLATTEN a bag with empty inner schema, the schema for the resulting relation is null.</source>
          <target state="translated">Если вы FLATTEN мешок с пустой внутренней схемой,то схема для результирующего соотношения будет нулевой.</target>
        </trans-unit>
        <trans-unit id="a9dad6c87764738da3cfc061e6f727d2a6799327" translate="yes" xml:space="preserve">
          <source>If you UNION two relations with incompatible schema, the schema for resulting relation is null.</source>
          <target state="translated">Если вы UNION два отношения с несовместимой схемой,то схема для результирующего отношения будет нулевой.</target>
        </trans-unit>
        <trans-unit id="56e8101602c2d9c75a14cf49e518adb7c0ea62ba" translate="yes" xml:space="preserve">
          <source>If you are just a user of UDFs, this is most of what you need to know about UDFs to use them in your code.</source>
          <target state="translated">Если вы просто пользователь UDFs,это большая часть того,что вам нужно знать о UDFs,чтобы использовать их в своем коде.</target>
        </trans-unit>
        <trans-unit id="7c772834e2a9aed00764a6e96ad1c9163813c083" translate="yes" xml:space="preserve">
          <source>If you are using Spark, you will also need to specify SPARK_HOME and specify SPARK_JAR which is the hdfs location where you uploaded $SPARK_HOME/lib/spark-assembly*.jar:</source>
          <target state="translated">Если вы используете Spark,вам также нужно указать SPARK_HOME и SPARK_JAR,который является hdfs местом,куда вы загрузили $SPARK_HOME/lib/spark-assembly*.jar:</target>
        </trans-unit>
        <trans-unit id="6cb81c239c67bf888e13b2d22dde63010dbe3dfb" translate="yes" xml:space="preserve">
          <source>If you are using Tez, you will also need to put Tez configuration directory (the directory that contains the tez-site.xml):</source>
          <target state="translated">Если вы используете Tez,вам также нужно поместить каталог конфигурации Tez (каталог,который содержит tez-site.xml):</target>
        </trans-unit>
        <trans-unit id="f86801fd7dc0106a735a5ab7b2fbc69bbc1e2ca3" translate="yes" xml:space="preserve">
          <source>If you assign a name to a field, you can refer to that field using the name or by positional notation. If you don't assign a name to a field (the field is un-named) you can only refer to the field using positional notation.</source>
          <target state="translated">Если вы назначаете имя полю,вы можете ссылаться на это поле с помощью имени или позиционной нотации.Если вы не присваиваете имя полю (поле не является именованным),вы можете ссылаться на поле только с помощью позиционной нотации.</target>
        </trans-unit>
        <trans-unit id="5c2068efddb33c739f6e1e4118009324d44d4dc5" translate="yes" xml:space="preserve">
          <source>If you assign a type to a field, you can subsequently change the type using the cast operators. If you don't assign a type to a field, the field defaults to bytearray; you can change the default type using the cast operators.</source>
          <target state="translated">Если вы назначаете тип поля,вы можете впоследствии изменить тип с помощью операторов литья.Если вы не назначили тип для поля,то по умолчанию для поля используется байтаррей;вы можете изменить тип по умолчанию с помощью операторов литья.</target>
        </trans-unit>
        <trans-unit id="93009caea4faeed63c7a3f49e29e15e2d31dcaf9" translate="yes" xml:space="preserve">
          <source>If you do &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt; on B, you will see a single column of type double. This is because Pig makes the safest choice and uses the largest numeric type when the schema is not know. In practice, the input data could contain integer values; however, Pig will cast the data to double and make sure that a double result is returned.</source>
          <target state="translated">Если вы выполните &lt;a href=&quot;test#describe&quot;&gt;команду DESCRIBE&lt;/a&gt; для B, вы увидите один столбец типа double. Это потому, что Pig делает самый безопасный выбор и использует самый большой числовой тип, когда схема не известна. На практике входные данные могут содержать целочисленные значения; однако, Pig преобразует данные в удвоенные и гарантирует, что возвращается двойной результат.</target>
        </trans-unit>
        <trans-unit id="c200fd2558a69c650aaf5de63cfc921f16db98be" translate="yes" xml:space="preserve">
          <source>If you don't supply a DEFINE for a given streaming command, then auto-shipping is turned off.</source>
          <target state="translated">Если вы не предоставляете DEFINE для заданной команды потоковой передачи,то автоматическая отправка отключается.</target>
        </trans-unit>
        <trans-unit id="c7d732bcc63d3993a0471861bd1df7f8145f5af3" translate="yes" xml:space="preserve">
          <source>If you have more questions, you can ask on the &lt;a href=&quot;http://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;Pig Mailing Lists&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть дополнительные вопросы, вы можете задать их в &lt;a href=&quot;http://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;списках рассылки свиней&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0f6cff2c5cea68ddc0fdb9d43dd36ab817fbf71" translate="yes" xml:space="preserve">
          <source>If you have more questions, you can ask on the &lt;a href=&quot;https://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;Pig Mailing Lists&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть дополнительные вопросы, вы можете задать их в &lt;a href=&quot;https://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;списках рассылки Pig&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76dbbb85aae7650b87268f029aecb7ef5ea47ad5" translate="yes" xml:space="preserve">
          <source>If you need an alternative format, you will need to create a custom serializer/deserializer by implementing the following interfaces.</source>
          <target state="translated">Если вам нужен альтернативный формат,вам необходимо создать пользовательский сериализатор/десериализатор,реализовав следующие интерфейсы.</target>
        </trans-unit>
        <trans-unit id="3ab330aaf103a3416195109dc88d65171a3113af" translate="yes" xml:space="preserve">
          <source>If you order relation A to produce relation X (X = ORDER A BY * DESC;) relations A and X still contain the same data.</source>
          <target state="translated">Если вы заказываете отношение A для получения отношения X (X=ORDER A BY*DESC;),то отношения A и X все равно содержат одни и те же данные.</target>
        </trans-unit>
        <trans-unit id="4e50578ad11c2c7c9f284f3844fbe57c5a3d59d7" translate="yes" xml:space="preserve">
          <source>If you pass a parameter to a script that the script does not use, this parameter is silently ignored. If the script has a parameter and no value is supplied or substituted, an error will result.</source>
          <target state="translated">Если вы передаете параметр скрипту,который не используется скриптом,этот параметр игнорируется.Если у скрипта есть параметр,а значение не подается и не подставляется,это приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="1369a59a2bb2e259294a035010e7c4da3f78013e" translate="yes" xml:space="preserve">
          <source>If you retrieve relation X (DUMP X;) the data is guaranteed to be in the order you specified (descending).</source>
          <target state="translated">Если вы извлекаете отношение X (DUMP X;),то данные гарантированно будут в указанном вами порядке (по убыванию).</target>
        </trans-unit>
        <trans-unit id="07b727742d1a4fca1de7143e1c07d0e86425235b" translate="yes" xml:space="preserve">
          <source>If you specify a directory name, all the files in the directory are loaded.</source>
          <target state="translated">При указании имени каталога загружаются все файлы в нем.</target>
        </trans-unit>
        <trans-unit id="2b27e9a3e53e3fef81b3d326d2e23e78ab25c9ea" translate="yes" xml:space="preserve">
          <source>If you use a local cluster, you need to set the required environment variables before starting it:</source>
          <target state="translated">Если вы используете локальный кластер,вам нужно установить необходимые переменные окружения перед его запуском:</target>
        </trans-unit>
        <trans-unit id="f6a85122c8dd900955aa81ccb9781c63a8e5c20c" translate="yes" xml:space="preserve">
          <source>If you use concatenated bzip files with your Pig jobs, you will NOT see a failure but the results will be INCORRECT.</source>
          <target state="translated">Если вы используете конкатенированные bzip-файлы с вашими заданиями Pig,вы НЕ увидите сбой,но результаты будут INCORRECT (ВНИМАНИЕ).</target>
        </trans-unit>
        <trans-unit id="ec27bed12f5b3966ebd9a9d8528ad6a6ed6a7aba" translate="yes" xml:space="preserve">
          <source>If your Pig script generates a sequence of MapReduce jobs, you can compress the output of the intermediate jobs using LZO compression. (Use the &lt;a href=&quot;test#EXPLAIN&quot;&gt;EXPLAIN&lt;/a&gt; operator to determine if your script produces multiple MapReduce Jobs.)</source>
          <target state="translated">Если ваш сценарий Pig генерирует последовательность заданий MapReduce, вы можете сжать выходные данные промежуточных заданий, используя сжатие LZO. (Используйте оператор &lt;a href=&quot;test#EXPLAIN&quot;&gt;EXPLAIN,&lt;/a&gt; чтобы определить, создает ли ваш скрипт несколько заданий MapReduce.)</target>
        </trans-unit>
        <trans-unit id="1239ee562b13227e2353dd2b5d0642351c9fb666" translate="yes" xml:space="preserve">
          <source>If your UDF can't be made Algebraic but is able to deal with getting input in chunks rather than all at once, consider implementing the Accumulator interface to reduce the amount of memory used by your script. If your function &lt;em&gt;is&lt;/em&gt; Algebraic and can be used on conjunction with Accumulator functions, you will need to implement the Accumulator interface as well as the Algebraic interface. For more information, see &lt;a href=&quot;udf#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;.</source>
          <target state="translated">Если ваш UDF не может быть сделан алгебраическим, но способен справляться с получением входных данных частями, а не сразу, рассмотрите возможность реализации интерфейса Accumulator, чтобы уменьшить объем памяти, используемой вашим сценарием. Если ваша функция &lt;em&gt;является&lt;/em&gt; алгебраической и может использоваться вместе с функциями аккумулятора, вам необходимо реализовать интерфейс аккумулятора, а также интерфейс алгебры. Для получения дополнительной информации см. &lt;a href=&quot;udf#accumulator-interface&quot;&gt;Интерфейс аккумулятора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="349f0b1b2f441677a38531ccee38d0d7d15aa938" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, the &amp;lsquo;merge&amp;rsquo; clause to perform an optimized version of COGROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="translated">Если ваши данные и загрузчики удовлетворяют этим условиям, предложение 'merge' выполняет оптимизированную версию COGROUP; операция будет выполняться на стороне карты и избежать фазы уменьшения.</target>
        </trans-unit>
        <trans-unit id="f86b761e8e078b0506cc07cd02d05eb34d02e1a7" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, use the &amp;lsquo;collected&amp;rsquo; clause to perform an optimized version of GROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="translated">Если ваши данные и загрузчики удовлетворяют этим условиям, используйте предложение &amp;laquo;собрано&amp;raquo; для выполнения оптимизированной версии GROUP; операция будет выполняться на стороне карты и избежать фазы уменьшения.</target>
        </trans-unit>
        <trans-unit id="feef6e3b59816e49d675edf99fac1a33a1fb5a57" translate="yes" xml:space="preserve">
          <source>If your loader implementation makes use of the PigSplit object passed through the prepareToRead method, then you may need to rebuild the loader since the definition of PigSplit has been modified.</source>
          <target state="translated">Если в реализации загрузчика используется объект PigSplit,прошедший через метод prepareToRead,то,возможно,вам потребуется пересобрать загрузчик,так как определение PigSplit было изменено.</target>
        </trans-unit>
        <trans-unit id="dee1bf176cbe01fd0441b1a12c13b06adb1b7153" translate="yes" xml:space="preserve">
          <source>Implement UDF by Simulation</source>
          <target state="translated">Внедрение ОДС с помощью моделирования</target>
        </trans-unit>
        <trans-unit id="5827f6f79b07ec443d93d8058ad81cc9d4d2ac27" translate="yes" xml:space="preserve">
          <source>Implicit Dependencies</source>
          <target state="translated">Неявные зависимости</target>
        </trans-unit>
        <trans-unit id="4c4d1de553948a314adeca034d84e23cd3b9ae4a" translate="yes" xml:space="preserve">
          <source>Import Lists</source>
          <target state="translated">Импортные списки</target>
        </trans-unit>
        <trans-unit id="1e56c1186fa7d5c3374f67d59101df99e56c90cb" translate="yes" xml:space="preserve">
          <source>Import macros defined in a separate file.</source>
          <target state="translated">Импорт макросов,определенных в отдельном файле.</target>
        </trans-unit>
        <trans-unit id="fe0f554fef6d8bbe2bada744a7a99611cdfdc416" translate="yes" xml:space="preserve">
          <source>Importing Modules</source>
          <target state="translated">Импортные модули</target>
        </trans-unit>
        <trans-unit id="398119218cf11b626396e7917ac6cf24641f838c" translate="yes" xml:space="preserve">
          <source>Improvements and other components based on PigUnit that could be built later.</source>
          <target state="translated">Усовершенствования и другие компоненты на основе PigUnit,которые могут быть построены позже.</target>
        </trans-unit>
        <trans-unit id="ab855867b4034f4bb99051d1f3ccaf64cefc7280" translate="yes" xml:space="preserve">
          <source>In Pig Latin,</source>
          <target state="translated">На свиной латыни,</target>
        </trans-unit>
        <trans-unit id="7b89c2531e0f47016cb2eac1f0115cc5c90e90d9" translate="yes" xml:space="preserve">
          <source>In Pig Latin, expressions are language constructs used with the FILTER, FOREACH, GROUP, and SPLIT operators as well as the eval functions.</source>
          <target state="translated">В Pig Latin выражения-это языковые конструкции,используемые с операторами FILTER,FOREACH,GROUP,SPLIT,а также с функциями eval.</target>
        </trans-unit>
        <trans-unit id="047330b0ff963c6df380d337f23e804c0fa8f828" translate="yes" xml:space="preserve">
          <source>In Pig Latin, nulls are implemented using the SQL definition of null as unknown or non-existent. Nulls can occur naturally in data or can be the result of an operation.</source>
          <target state="translated">В Pig Latin nulls реализованы с использованием SQL определения null как неизвестного или несуществующего.Нули могут возникать в данных естественным образом или быть результатом операции.</target>
        </trans-unit>
        <trans-unit id="e2b472a5cb1d2bb6677c5894a233ab880022ee5b" translate="yes" xml:space="preserve">
          <source>In Pig, problems with memory usage can occur when data, which results from a group or cogroup operation, needs to be placed in a bag and passed in its entirety to a UDF.</source>
          <target state="translated">В Pig могут возникнуть проблемы с использованием памяти,когда данные,полученные в результате групповой или когтевой операции,нужно поместить в пакет и передать его целиком в UDF.</target>
        </trans-unit>
        <trans-unit id="77ac446bcfdd607749e9908e882446119d984b45" translate="yes" xml:space="preserve">
          <source>In Pig, relations are unordered (see &lt;a href=&quot;#relations&quot;&gt;Relations, Bags, Tuples, Fields&lt;/a&gt;):</source>
          <target state="translated">В Pig отношения неупорядочены (см. &lt;a href=&quot;#relations&quot;&gt;Отношения, Сумки, Кортежи, Поля&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="77395bf675c2c5145ba7cb6ba484de1ce1ad1445" translate="yes" xml:space="preserve">
          <source>In Tez, jvm could reuse for other tasks. It is important to cleanup static variable to make sure there is no side effect. Here is one example:</source>
          <target state="translated">В Тезе,jvm может повторно использоваться для других задач.Важно очистить статическую переменную,чтобы убедиться в отсутствии побочных эффектов.Вот один пример:</target>
        </trans-unit>
        <trans-unit id="7dd89a54572b05053fd654da00615655e3c8186b" translate="yes" xml:space="preserve">
          <source>In a load statement, the loader will inject null into the tuple. The actual value that is substituted for null is loader specific; for example, PigStorage substitutes an empty field for null.</source>
          <target state="translated">В нагрузочной ведомости погрузчик впрыскивает в кортеж ноль.Фактическое значение,которое подставляется в кортеж,является специфическим для загрузчика;например,PigStorage подставляет пустое поле в нулевое.</target>
        </trans-unit>
        <trans-unit id="9ab73a609fcb251095ae635071ba701b69b3b5ae" translate="yes" xml:space="preserve">
          <source>In a non-load statement, if a requested field is missing from a tuple, Pig will inject null.</source>
          <target state="translated">В заявлении о ненагрузке,если запрашиваемое поле отсутствует в кортеже,Свинья вводит ноль.</target>
        </trans-unit>
        <trans-unit id="761d64cc264226017ae6e486dbdb548f042b4ea4" translate="yes" xml:space="preserve">
          <source>In addition to position, data grouping and ordering can be determined by the data itself. However, you need to know the property of the data to be able to take advantage of its structure.</source>
          <target state="translated">Помимо позиции,группировка данных и заказ могут определяться самими данными.Однако,чтобы воспользоваться преимуществами структуры данных,необходимо знать их свойства.</target>
        </trans-unit>
        <trans-unit id="4e5448a648336936524e336b0e640a723e9a9434" translate="yes" xml:space="preserve">
          <source>In addition to providing Pig script via a string, you can store it in a file and pass the file to the compile call:</source>
          <target state="translated">Помимо предоставления скрипта Pig через строку,вы можете сохранить его в файле и передать файл на вызов компиляции:</target>
        </trans-unit>
        <trans-unit id="1ea3be12b2777f643d5e98b83b6f48b651f89c54" translate="yes" xml:space="preserve">
          <source>In cases where the schema is stored as part of the StoreFunc like PigStorage, JsonStorage, AvroStorage or OrcStorage, users generally have to use an extra FOREACH before STORE to rename the field names and remove the disambiguate operator from the names. To automatically remove the disambiguate operator from the schema for the STORE operation, the pig.store.schema.disambiguate Pig property can be set to &quot;false&quot;. It is the responsibility of the user to make sure that there is no conflict in the field names when using this setting.</source>
          <target state="translated">В случаях,когда схема хранится как часть StoreFunc,например PigStorage,JsonStorage,AvroStorage или OrcStorage,пользователи обычно должны использовать дополнительный FOREACH перед STORE,чтобы переименовать имена полей и удалить оператор disiguate из имен.Для автоматического удаления оператора disambiguate из схемы для операции STORE можно установить свойство pig.store.schema.disambiguate Pig в значение &quot;false&quot;.Пользователь несет ответственность за то,чтобы при использовании этой настройки не возникало конфликтов в именах полей.</target>
        </trans-unit>
        <trans-unit id="cb09a5599dba9a08193e6ba5ca41cf184a2941b2" translate="yes" xml:space="preserve">
          <source>In general, lowercase type indicates elements that you supply.</source>
          <target state="translated">В общем случае,нижний регистр указывает на элементы,которые Вы поставляете.</target>
        </trans-unit>
        <trans-unit id="667bae580123f622168d5ecaf410d9ca73353cd3" translate="yes" xml:space="preserve">
          <source>In general, uppercase type indicates elements the system supplies.</source>
          <target state="translated">В общем,заглавный тип обозначает элементы,поставляемые системой.</target>
        </trans-unit>
        <trans-unit id="43385afe9d70e705c298432cd61a48b9ebab8e78" translate="yes" xml:space="preserve">
          <source>In its basic form, compile just takes a Pig Latin fragment that defines the pipeline as described in the previous section. Additionally, the pipeline can be given a name. This name is only used when the embedded script is invoked via the PigRunner Java API (as discussed later in this document).</source>
          <target state="translated">В своей базовой форме компилятор просто берет фрагмент Pig Latin,который определяет трубопровод,как описано в предыдущем разделе.Кроме того,конвейеру можно дать имя.Это имя используется только при вызове встроенного скрипта через PigRunner Java API (как будет рассмотрено далее в этом документе).</target>
        </trans-unit>
        <trans-unit id="c386aecc87f49116be4bbc8980ea9301e6beef05" translate="yes" xml:space="preserve">
          <source>In its simplest form, bind takes no parameters. In this case, an implicit bind is performed; Pig internally constructs a map of parameters from the local variables specified by the user in the script.</source>
          <target state="translated">В своей простейшей форме привязка не принимает параметров.В этом случае выполняется неявная привязка;Pig внутренне строит карту параметров из локальных переменных,указанных пользователем в скрипте.</target>
        </trans-unit>
        <trans-unit id="a6ce11ff76294b5348b9aa96365ef9638cb0d1b7" translate="yes" xml:space="preserve">
          <source>In many cases, AvroStorage will automatically translate your data correctly and you will not need to provide any more information to AvroStorage. But sometimes, it may be convenient to manually provide a schema to AvroStorge. See the example selection below for examples on manually specifying a schema with AvroStorage.</source>
          <target state="translated">Во многих случаях AvroStorage автоматически переводит ваши данные корректно,и вам не нужно предоставлять больше информации в AvroStorage.Но иногда бывает удобно вручную предоставить в AvroStorge схему.См.примеры выбора примера ниже,чтобы вручную указать схему с AvroStorage.</target>
        </trans-unit>
        <trans-unit id="5d274aa391941e3db3eaf1d92d4ca5b2b777dcc2" translate="yes" xml:space="preserve">
          <source>In map-reduce mode, the following script will load from &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/data1&quot; and store into &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/tmp/out1&quot;.</source>
          <target state="translated">В режиме отображения карты следующий скрипт будет загружаться из &amp;laquo;hdfs: // &amp;lt;хост&amp;gt;: &amp;lt;порт&amp;gt; / data1&amp;raquo; и сохраняться в &amp;laquo;hdfs: // &amp;lt;хост&amp;gt;: &amp;lt;порт&amp;gt; / tmp / out1&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fbac605553184ef19261778bcb7ec6f398ca51e3" translate="yes" xml:space="preserve">
          <source>In order to avoid replicated joins on large relations, we fail if size of relation(s) to be replicated (in bytes) is greater than pig.join.replicated.max.bytes (default = 1GB).</source>
          <target state="translated">Чтобы избежать реплицируемых соединений на больших соединениях,мы не сможем,если размер реплицируемых соединений (в байтах)будет больше,чем pig.join.replicated.max.bytes (по умолчанию=1Гб).</target>
        </trans-unit>
        <trans-unit id="f6df614c8a5e9de3ecdeefdab6a02557f17f3174" translate="yes" xml:space="preserve">
          <source>In parameter file, as part of a command line.</source>
          <target state="translated">В файле параметров,как часть командной строки.</target>
        </trans-unit>
        <trans-unit id="a83607c547c007f3cf1a9c56712a1e100cdccaa1" translate="yes" xml:space="preserve">
          <source>In prior Pig releases, Example 1 will dump A' to disk and then start jobs for B' and C'. Example 2 will execute all the dependencies of B' and store it and then execute all the dependencies of C' and store it. Both are equivalent, but the performance will be different.</source>
          <target state="translated">В предыдущих релизах Pig,Пример 1 будет выгружать A' на диск,а затем запускать задания для B' и C'.Пример 2 выполнит все зависимости B' и сохранит их,а затем выполнит все зависимости C' и сохранит их.Оба эквивалентны,но производительность будет разной.</target>
        </trans-unit>
        <trans-unit id="3dd2199bc012d7207d555ef9e715d44419202375" translate="yes" xml:space="preserve">
          <source>In some cases it might be desirable to fail the entire script upon detecting the first failed job. This can be achieved with the &quot;-F&quot; or &quot;-stop_on_failure&quot; command line flag. If used, Pig will stop execution when the first failed job is detected and discontinue further processing. This also means that file commands that come after a failed store in the script will not be executed (this can be used to create &quot;done&quot; files).</source>
          <target state="translated">В некоторых случаях может быть желательно провалить весь скрипт при обнаружении первого неудачного задания.Этого можно добиться с помощью флага командной строки &quot;-F&quot; или &quot;-stop_on_failure&quot;.При его использовании Pig остановит выполнение при обнаружении первого неудачного задания и прекратит дальнейшую обработку.Это также означает,что команды файла,которые приходят после неудачного сохранения в скрипте,не будут выполнены (это может быть использовано для создания &quot;готовых&quot; файлов).</target>
        </trans-unit>
        <trans-unit id="a902912f349147fbbe0eb2d57a40fcb3a4e6de06" translate="yes" xml:space="preserve">
          <source>In the FOREACH statement, the field in relation B is referred to by positional notation ($0).</source>
          <target state="translated">В FOREACH-отчете поле по отношению B обозначается позиционной нотацией ($0).</target>
        </trans-unit>
        <trans-unit id="0534091b29b78ead8b83df710a7671a6499bd98e" translate="yes" xml:space="preserve">
          <source>In the SQL case, the SQLLoader function is invoked with 'sql://mytable'.</source>
          <target state="translated">В случае SQL функция SQLLoader вызывается с помощью 'sql://mytable'.</target>
        </trans-unit>
        <trans-unit id="7013811a67a11af4ac23552269ed48873de74a1b" translate="yes" xml:space="preserve">
          <source>In the above example, a variety of expressions can be applied to algebraic functions including:</source>
          <target state="translated">В приведенном выше примере к алгебраическим функциям можно применять различные выражения,в том числе:</target>
        </trans-unit>
        <trans-unit id="4e34e2cb53ddbb0085cbc3e5a61b4772c7d5c3c2" translate="yes" xml:space="preserve">
          <source>In the above example:</source>
          <target state="translated">В приведенном выше примере:</target>
        </trans-unit>
        <trans-unit id="789a8aaef2965b6eb70d651d97130eed1c314f0f" translate="yes" xml:space="preserve">
          <source>In the case of inner join and right outer join, the right most relation is used for building the bloom filter and the users are expected to specify the smaller dataset as the right most relation. But in the case of left outer join, the left most relation is used for building the bloom filter and is expected to be the smaller dataset. This is because all records of the outer relation should be in the result and no records can be filtered. If the left relation turns out to be the bigger dataset, it would not be as efficient to build the bloom filter on the bigger dataset. But it might still perform better than a regular join if it is able to filter lot of records from the right relation.</source>
          <target state="translated">В случае внутреннего и правого внешнего соединения,правое наибольшее соотношение используется для построения фильтра цветения,а пользователи должны указать меньший набор данных как правое наибольшее соотношение.Но в случае левого внешнего соединения,левое наибольшее соотношение используется для построения фильтра цветения и ожидается,что это будет меньший набор данных.Это связано с тем,что все записи внешнего соединения должны быть в результате и никакие записи не могут быть отфильтрованы.Если левое соотношение окажется большим набором данных,то построить фильтр цветения на большом наборе данных будет не так эффективно.Но он все равно может работать лучше,чем обычное соединение,если сможет отфильтровать много записей из правого соотношения.</target>
        </trans-unit>
        <trans-unit id="366cfaa9f77dcf4de6672d5c4eeb8495d9aab995" translate="yes" xml:space="preserve">
          <source>In the example above relation A is loaded from HDFS and stored in HBase. Note that the schema of relation A is a tuple of size 3, but only two column descriptor names are passed to the HBaseStorage constructor. This is because the first entry in the tuple is used as the HBase rowKey.</source>
          <target state="translated">В приведенном выше примере отношение A загружается из HDFS и сохраняется в HBase.Обратите внимание,что схема отношения A представляет собой кортеж размером 3,но в конструктор HBaseStorage передаются только имена дескрипторов двух столбцов.Это связано с тем,что первая запись в кортеже используется в качестве HBase rowKey.</target>
        </trans-unit>
        <trans-unit id="8768ae4a7963f867789d54883f792a4b049338c3" translate="yes" xml:space="preserve">
          <source>In the example below, note the following:</source>
          <target state="translated">В примере,приведенном ниже,обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="810f4025eba8164da7f5c931db880c74c3f881c2" translate="yes" xml:space="preserve">
          <source>In the script, parameter names can be escaped with the backslash character ( \ ) in which case substitution does not take place.</source>
          <target state="translated">В скрипте имена параметров могут быть экранированы символом обратного слеша(\ ),в этом случае подстановка не происходит.</target>
        </trans-unit>
        <trans-unit id="823a66cbb60bb79080f0a8b1ea0d329c7d74614e" translate="yes" xml:space="preserve">
          <source>In these examples a directory is created, a file is copied, a file is listed.</source>
          <target state="translated">В этих примерах создается каталог,копируется файл,перечисляется файл.</target>
        </trans-unit>
        <trans-unit id="9fb53acc5fc864b189dffd5763e2ccfc43d29a03" translate="yes" xml:space="preserve">
          <source>In this example A is a relation or bag of tuples. You can think of this bag as an outer bag.</source>
          <target state="translated">В этом примере А-это родственник или мешок кортежей.Вы можете думать об этом мешке как о внешней сумке.</target>
        </trans-unit>
        <trans-unit id="c2b8d5695ad31a39e71eead60f9a78e531f16388" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used to load multiple locations.</source>
          <target state="translated">В этом примере BinStorage используется для загрузки нескольких местоположений.</target>
        </trans-unit>
        <trans-unit id="fb4dad7abc1d7506c6a665f7d105adc4e5904a6a" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used with the LOAD and STORE functions.</source>
          <target state="translated">В данном примере BinStorage используется с функциями LOAD и STORE.</target>
        </trans-unit>
        <trans-unit id="5a58d2ef04a5cda433ef29f50daa6af7e7faab9f" translate="yes" xml:space="preserve">
          <source>In this example COUNT_STAR is used to count the tuples in a bag.</source>
          <target state="translated">В этом примере COUNT_STAR используется для подсчета кортежей в мешке.</target>
        </trans-unit>
        <trans-unit id="1ff7470c5528ca285c04a3c3ac0c8d55936316c0" translate="yes" xml:space="preserve">
          <source>In this example DIFF compares the tuples in two bags.</source>
          <target state="translated">В этом примере DIFF сравнивает кортежи в двух пакетах.</target>
        </trans-unit>
        <trans-unit id="59300d5fb1b29001840b069de1bdcfdde402ef36" translate="yes" xml:space="preserve">
          <source>In this example FOREACH is nested to the second level.</source>
          <target state="translated">В данном примере FOREACH вложен во второй уровень.</target>
        </trans-unit>
        <trans-unit id="c1481519e4226587e1177016b76ec2132f08cef8" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used to store a relation into HBase.</source>
          <target state="translated">В данном примере HBaseStorage используется для хранения отношения в HBase.</target>
        </trans-unit>
        <trans-unit id="ab84b86ed1cd0f81d89240b20eeb6f47b9930a87" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used with the LOAD function with an explicit schema.</source>
          <target state="translated">В данном примере HBaseStorage используется с функцией LOAD с явной схемой.</target>
        </trans-unit>
        <trans-unit id="435c4dd4d77b5e857be6bf8ad142ee3d71a0e7a5" translate="yes" xml:space="preserve">
          <source>In this example PARALLEL is used with the GROUP operator.</source>
          <target state="translated">В данном примере PARALLEL используется с оператором GROUP.</target>
        </trans-unit>
        <trans-unit id="40cb6c5ae4d9ef5896bcd6d4b036252b875f816a" translate="yes" xml:space="preserve">
          <source>In this example Pig will validate, but not execute, the LOAD and FOREACH statements.</source>
          <target state="translated">В этом примере Свинья будет проверять,но не выполнять заявления LOAD и FOREACH.</target>
        </trans-unit>
        <trans-unit id="de61ae61ea6032b2e228021c21932ce307a7c989" translate="yes" xml:space="preserve">
          <source>In this example PigDump is used with the STORE function.</source>
          <target state="translated">В данном примере PigDump используется с функцией STORE.</target>
        </trans-unit>
        <trans-unit id="46d2148592ebc16cb761333836a92127b54281f5" translate="yes" xml:space="preserve">
          <source>In this example PigStorage expects input.txt to contain tab-separated fields and newline-separated records. The statements are equivalent.</source>
          <target state="translated">В данном примере PigStorage ожидает,что input.txt будет содержать поля,разделенные на табуляции,и записи,разделенные на новые строки.Эти утверждения эквивалентны.</target>
        </trans-unit>
        <trans-unit id="6470b4bdc80ce6ec14c6b369cff173d8a96a70af" translate="yes" xml:space="preserve">
          <source>In this example PigStorage stores the contents of X into files with fields that are delimited with an asterisk ( * ). The STORE statement specifies that the files will be located in a directory named output and that the files will be named part-nnnnn (for example, part-00000).</source>
          <target state="translated">В этом примере PigStorage хранит содержимое X в файлах с полями,разделенными звездочкой(*).В операторе STORE указано,что файлы будут находиться в директории с именем вывода и что файлы будут именоваться part-nnnn (например,part-00000).</target>
        </trans-unit>
        <trans-unit id="3545f3dfb4a61c191d5ce7c17db12055dbea1552" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is the default serialization/deserialization function. The tuples from relation A are converted to tab-delimited lines that are passed to the script.</source>
          <target state="translated">В данном примере PigStreaming является функцией сериализации/десериализации по умолчанию.Кортежи из отношения A преобразуются в строки,разделенные табуляциями,которые передаются в скрипт.</target>
        </trans-unit>
        <trans-unit id="53acd63180313d053382b996221400c3670c3ad0" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is used as the serialization/deserialization function, but a comma is used as the delimiter.</source>
          <target state="translated">В данном примере PigStreaming используется в качестве функции сериализации/десериализации,но в качестве разделителя используется запятая.</target>
        </trans-unit>
        <trans-unit id="505900e4da0fa482992eb1a2f88bcc0e5d38a43b" translate="yes" xml:space="preserve">
          <source>In this example REGISTER states that the JavaScript module, myfunc.js, is located in the /src directory.</source>
          <target state="translated">В данном примере REGISTER заявляет,что модуль JavaScript,myfunc.js,находится в каталоге /src.</target>
        </trans-unit>
        <trans-unit id="50cb9301684455fe267eae841880105c8315f523" translate="yes" xml:space="preserve">
          <source>In this example TextLoader is used with the LOAD function.</source>
          <target state="translated">В данном примере TextLoader используется с функцией LOAD.</target>
        </trans-unit>
        <trans-unit id="3c5e9d3dd6f9a44bb764a99545f07562b251abc9" translate="yes" xml:space="preserve">
          <source>In this example X is a relation or bag of tuples. The tuples in relation X have two fields. The first field is type int. The second field is type bag; you can think of this bag as an inner bag.</source>
          <target state="translated">В этом примере Х-это родственник или мешок кортежей.Кортежи по отношению к Х имеют два поля.Первое поле-тип int.Второе поле-тип мешка;можно считать этот мешок внутренним мешком.</target>
        </trans-unit>
        <trans-unit id="2bf5f5dc213edcf0c2a75a62d467adfd719f4117" translate="yes" xml:space="preserve">
          <source>In this example a CROSS is performed within the nested block.</source>
          <target state="translated">В данном примере CROSS выполняется внутри вложенного блока.</target>
        </trans-unit>
        <trans-unit id="9d96da638dd744c8666b0a4d7441d6698bbcae66" translate="yes" xml:space="preserve">
          <source>In this example a JAR file stored in HDFS and a local JAR file are registered.</source>
          <target state="translated">В этом примере регистрируется JAR-файл,хранящийся в HDFS,и локальный JAR-файл.</target>
        </trans-unit>
        <trans-unit id="c853730b16a0a6d3de6a48047bf1fd0903963d8c" translate="yes" xml:space="preserve">
          <source>In this example a and null are projected.</source>
          <target state="translated">В данном примере прогнозируется a и null.</target>
        </trans-unit>
        <trans-unit id="252278b82d54611f8604f3c1c4920b5131753f06" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type bag.</source>
          <target state="translated">В этом примере байтеррей (fld по отношению к A)заливается для печати мешка.</target>
        </trans-unit>
        <trans-unit id="52be4343435f44112a5462538218eec269b8c99a" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type map.</source>
          <target state="translated">В этом примере байтеррей (fld по отношению к A)приводится к типу карты.</target>
        </trans-unit>
        <trans-unit id="adc6b1c539b7f3b4f765bf66f1bbf223243eec17" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type tuple.</source>
          <target state="translated">В этом примере байтеррей (fld по отношению к A)приводится к типу кортежа.</target>
        </trans-unit>
        <trans-unit id="b780edd4e748b15aca64e2b122fa86c500341bd8" translate="yes" xml:space="preserve">
          <source>In this example a command is defined for use with the &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; operator.</source>
          <target state="translated">В этом примере команда определена для использования с оператором &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a42086ec48674799538294ab226a5ef8414b48d8" translate="yes" xml:space="preserve">
          <source>In this example a dump is performed after each statement.</source>
          <target state="translated">В данном примере дамп выполняется после каждого утверждения.</target>
        </trans-unit>
        <trans-unit id="28b34e252e518f10cb207856de095b2d0a0edae9" translate="yes" xml:space="preserve">
          <source>In this example a field delimiter is specified.</source>
          <target state="translated">В данном примере указан разделитель полей.</target>
        </trans-unit>
        <trans-unit id="231dd12f30cc168f8fe434f1dc9d10741002943a" translate="yes" xml:space="preserve">
          <source>In this example a function is defined for use with the FOREACH &amp;hellip;GENERATE operator.</source>
          <target state="translated">В этом примере определена функция для использования с оператором FOREACH&amp;hellip; GENERATE.</target>
        </trans-unit>
        <trans-unit id="902f7920721a3a412c9e07306586280fa07bbed2" translate="yes" xml:space="preserve">
          <source>In this example a macro (group_with_parallel) refers to another macro (foreach_count).</source>
          <target state="translated">В данном примере макрос (group_with_parallel)относится к другому макросу (foreach_count).</target>
        </trans-unit>
        <trans-unit id="c526f01c29f290403e51e19b0ba26f8e808e9d41" translate="yes" xml:space="preserve">
          <source>In this example a multi-field tuple is used. For the FILTER statement, Pig performs an implicit cast. For the FOREACH statement, an explicit cast is used.</source>
          <target state="translated">В этом примере используется кортеж с несколькими полями.Для оператора FILTER Свинья выполняет неявное кастинг.Для оператора FOREACH используется явное кастинг.</target>
        </trans-unit>
        <trans-unit id="f34e9ccd45ed5247a9948b597bda137a57066df6" translate="yes" xml:space="preserve">
          <source>In this example a name collision will occur. Here letter B is used as alias name and as name in user-defined schema. Pig will throw an exception when name collision is detected.</source>
          <target state="translated">В этом примере произойдет столкновение имен.Здесь буква B используется как псевдоним и как имя в пользовательской схеме.Свинья будет бросать исключение при обнаружении столкновения имен.</target>
        </trans-unit>
        <trans-unit id="fe539b60b5336a69ebbb6e4634bb45d1f0a5d224" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified as part of the STREAM statement.</source>
          <target state="translated">В этом примере схема указана как часть оператора STREAM.</target>
        </trans-unit>
        <trans-unit id="06061e753d06a1e6057c5ffcb4a812aa78fbf9d1" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS clause. If all data conforms to the schema, Pig will use the assigned types.</source>
          <target state="translated">В данном примере схема задается с помощью пункта AS.Если все данные соответствуют схеме,Pig будет использовать назначенные типы.</target>
        </trans-unit>
        <trans-unit id="34acf70f365e4b31c6e0e3cccb93c0182b8a1c41" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS keyword. The two LOAD statements are equivalent. You can use the DESCRIBE and ILLUSTRATE operators to view the schema.</source>
          <target state="translated">В данном примере схема задается с помощью ключевого слова AS.Два оператора LOAD эквивалентны.Для просмотра схемы можно использовать операторы DESCRIBE и ILLUSTRATE.</target>
        </trans-unit>
        <trans-unit id="dc43776c73d7d053427079800e34a406b2a45d68" translate="yes" xml:space="preserve">
          <source>In this example additional JAR files are registered via PIG_OPTS environment variable.</source>
          <target state="translated">В данном примере дополнительные JAR-файлы регистрируются через переменную окружения PIG_OPTS.</target>
        </trans-unit>
        <trans-unit id="16dcc4a12858c636c8fa146c2aad2b889eb7fae9" translate="yes" xml:space="preserve">
          <source>In this example all duplicate tuples are removed.</source>
          <target state="translated">В данном примере все дублирующие кортежи удалены.</target>
        </trans-unit>
        <trans-unit id="b618f5f0bcbb7b8e5bdafd32f7a9e4baece8803f" translate="yes" xml:space="preserve">
          <source>In this example all students with an SSN but no name are located.</source>
          <target state="translated">В этом примере все ученики с SSN,но без имени,находятся.</target>
        </trans-unit>
        <trans-unit id="79068ccaa260466fc6f972d14a88f57c0fcfb5d3" translate="yes" xml:space="preserve">
          <source>In this example all the MapReduce jobs that get launched use 20 reducers.</source>
          <target state="translated">В этом примере все запущенные задания MapReduce используют 20 редукторов.</target>
        </trans-unit>
        <trans-unit id="b770e6fe233709b0a9582cf8bb7b9270df9258d2" translate="yes" xml:space="preserve">
          <source>In this example an error is generated because the requested column ($3) is outside of the declared schema (positional notation begins with $0). Note that the error is caught before the statements are executed.</source>
          <target state="translated">В этом примере возникает ошибка,потому что запрашиваемый столбец ($3)находится вне объявленной схемы (позиционная запись начинается с $0).Обратите внимание,что ошибка фиксируется до выполнения операторов.</target>
        </trans-unit>
        <trans-unit id="019c413fae337da8ece686fc5d54f62505ef2c7a" translate="yes" xml:space="preserve">
          <source>In this example an int is cast to type chararray (see relation X).</source>
          <target state="translated">В этом примере int приводится к типу chararray (см.отношение X).</target>
        </trans-unit>
        <trans-unit id="93db6358d966d0c7d514bd2decd538210cc879e4" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be cast to int, a implicitly, and null explicitly.</source>
          <target state="translated">В данном примере и a,и null будут приведены к int,a неявно,и null явно.</target>
        </trans-unit>
        <trans-unit id="f959bad76d0bbfd8004a39fa235bd4ca5f054f65" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be implicitly cast to double.</source>
          <target state="translated">В данном примере и a,и null будут неявно приведены к удвоению.</target>
        </trans-unit>
        <trans-unit id="e27f98b53bc5588e16ad4f1af469c5dfda881206" translate="yes" xml:space="preserve">
          <source>In this example cache is used to specify a file located on the cluster compute nodes.</source>
          <target state="translated">В этом примере кэш используется для указания файла,расположенного на узлах вычислений кластера.</target>
        </trans-unit>
        <trans-unit id="0dfa087e0c75a861542022b8ebc000c17d370200" translate="yes" xml:space="preserve">
          <source>In this example data is loaded with a schema.</source>
          <target state="translated">В данном примере данные загружаются со схемой.</target>
        </trans-unit>
        <trans-unit id="d52a2a475a46079874a2842b0e1af3a3ae07325b" translate="yes" xml:space="preserve">
          <source>In this example data is loaded without a schema; it assumes there is a .pig_schema (produced by JsonStorage) in the input directory.</source>
          <target state="translated">В этом примере данные загружаются без схемы;предполагается,что во входном каталоге есть .pig_schema (произведенная JsonStorage).</target>
        </trans-unit>
        <trans-unit id="98510e7774ca7a3b39f659179e898062288bbc9c" translate="yes" xml:space="preserve">
          <source>In this example data is stored using PigStorage and the asterisk character (*) as the field delimiter.</source>
          <target state="translated">В этом примере данные хранятся с использованием PigStorage и символа звездочки (*)в качестве разделителя полей.</target>
        </trans-unit>
        <trans-unit id="993517c57ee376d2b7b84473441b0326f8a923af" translate="yes" xml:space="preserve">
          <source>In this example default_parallel is set in the Pig script; all MapReduce jobs that get launched will use 20 reducers.</source>
          <target state="translated">В этом примере в скрипте Pig установлен параметр default_parallel;все запущенные задания MapReduce будут использовать 20 редукторов.</target>
        </trans-unit>
        <trans-unit id="004f088c97324626f2f5dd9f710d01d17559c6aa" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to look up the value of key 'open'.</source>
          <target state="translated">В этом примере разыменование используется для поиска значения ключа 'open'.</target>
        </trans-unit>
        <trans-unit id="6b80a144f43f789acea82e8c85d4bcbd2d95337f" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to project a field (f1) from a tuple (group) and a field (f1) from a bag (a).</source>
          <target state="translated">В этом примере разыменование используется для проектирования поля (f1)из кортежа (группы)и поля (f1)из пакета (a).</target>
        </trans-unit>
        <trans-unit id="212fc5892a721a0060e45e75350a1fbdbf50b4be" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to retrieve two fields from tuple f2.</source>
          <target state="translated">В этом примере разыменование используется для получения двух полей из кортежа f2.</target>
        </trans-unit>
        <trans-unit id="904d63269308c6655e00fc821dff1fc33db0eed0" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used with relation X to project the first field (f1) of each tuple in the bag (a).</source>
          <target state="translated">В этом примере разыменование используется с отношением X к проектированию первого поля (f1)каждого кортежа в пакете (a).</target>
        </trans-unit>
        <trans-unit id="bd906ea6b105d25e2f0d5b0003b730ae52af1ed4" translate="yes" xml:space="preserve">
          <source>In this example field &quot;gpa&quot; will default to bytearray because no type is declared.</source>
          <target state="translated">В этом примере поле &quot;gpa&quot; по умолчанию будет байтером,так как тип не объявлен.</target>
        </trans-unit>
        <trans-unit id="71b7c69ad52a06b1bcb69143364d7c4a4045b02f" translate="yes" xml:space="preserve">
          <source>In this example if one of the fields in the input relation is a tuple, bag or map, we can perform a projection on that field (using a deference operator).</source>
          <target state="translated">В данном примере,если одним из полей во входном соотношении является кортеж,мешок или карта,мы можем выполнить проекцию на это поле (с помощью оператора deference).</target>
        </trans-unit>
        <trans-unit id="381c3ad80f6a75a1d6369b158db1f23e56c0c1a2" translate="yes" xml:space="preserve">
          <source>In this example key value pairs are set at the command line.</source>
          <target state="translated">В данном примере пары значений ключей задаются в командной строке.</target>
        </trans-unit>
        <trans-unit id="036d7f9ad9b7cc7d5a796a8fa59f8957b424182b" translate="yes" xml:space="preserve">
          <source>In this example multiple key value pairs are set in the Pig script. These key value pairs are put in job-conf by Pig (making the pairs available to Pig and Hadoop). This is a script-wide setting; if a key value is defined multiple times in the script the last value will take effect and will be set for all jobs generated by the script.</source>
          <target state="translated">В этом примере несколько пар значений клавиш заданы в сценарии Pig.Эти пары значений ключей помещаются в job-conf с помощью Pig (делая пары доступными для Pig и Hadoop).Это настройка для всего скрипта;если значение ключа определено несколько раз в скрипте,то последнее значение вступит в силу и будет установлено для всех рабочих мест,генерируемых скриптом.</target>
        </trans-unit>
        <trans-unit id="5f41fb70f423cb0dbfced17b805614a0b220128e" translate="yes" xml:space="preserve">
          <source>In this example multiple nested columns are retained.</source>
          <target state="translated">В этом примере сохраняются несколько вложенных столбцов.</target>
        </trans-unit>
        <trans-unit id="0d5857ac7ca8abbc90407cf41477661d258b1c55" translate="yes" xml:space="preserve">
          <source>In this example multiple parameters are specified.</source>
          <target state="translated">В данном примере указано несколько параметров.</target>
        </trans-unit>
        <trans-unit id="74314f14b6f4d8ce3ccc71bc58e4f39e20febcce" translate="yes" xml:space="preserve">
          <source>In this example my_macro (defined above) is expanded. Because alias B is not visible from the outside it is renamed macro_my_macro_B_0.</source>
          <target state="translated">В этом примере раскрывается my_macro (определено выше).Поскольку псевдоним B не виден извне,он переименован в макро_my_macro_B_0.</target>
        </trans-unit>
        <trans-unit id="8ef086a29e25d0a628246ae86a8dfd0251c73a5a" translate="yes" xml:space="preserve">
          <source>In this example no parameters are passed to the macro.</source>
          <target state="translated">В данном примере макросу не передаются никакие параметры.</target>
        </trans-unit>
        <trans-unit id="4c2b33f77cda03a397ae83edefe497af878760f6" translate="yes" xml:space="preserve">
          <source>In this example no schema is specified. All fields default to type bytearray or long (see Data Types).</source>
          <target state="translated">В данном примере схема не указана.Все поля по умолчанию для ввода bytearray или long (см.Типы данных).</target>
        </trans-unit>
        <trans-unit id="60048a1c8591e593e65c99554a20d95fc58747db" translate="yes" xml:space="preserve">
          <source>In this example nulls are injected if fields do not have data.</source>
          <target state="translated">В этом примере нули вводятся,если в полях нет данных.</target>
        </trans-unit>
        <trans-unit id="c8c2d3f0591222c2c9f03e628a85df359bc7b283" translate="yes" xml:space="preserve">
          <source>In this example of an outer join, if the join key is missing from a table it is replaced by null.</source>
          <target state="translated">В данном примере внешнего соединения,если ключ соединения отсутствует в таблице,он заменяется нулем.</target>
        </trans-unit>
        <trans-unit id="0107821bc8812479bdbf1f64b26078690d140226" translate="yes" xml:space="preserve">
          <source>In this example output is limited to 3 tuples. Note that there is no guarantee which three tuples will be output.</source>
          <target state="translated">В этом примере выход ограничивается 3 кортежами.Обратите внимание,что нет гарантии,какие три кортежа будут выведены.</target>
        </trans-unit>
        <trans-unit id="6926a0c31dcd9e33a949b13c70271304c004ba03" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the exec command.</source>
          <target state="translated">В этом примере подстановка параметров используется с командой выполнения.</target>
        </trans-unit>
        <trans-unit id="8418fd14b7d1e17833903e6a625c75e3ce956813" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the run command.</source>
          <target state="translated">В этом примере подстановка параметров используется с командой run.</target>
        </trans-unit>
        <trans-unit id="829f361647b770f5f6f543d85b2622ed7c6cd584" translate="yes" xml:space="preserve">
          <source>In this example parameters are passed and returned.</source>
          <target state="translated">В этом примере параметры передаются и возвращаются.</target>
        </trans-unit>
        <trans-unit id="f8309b5f7726c99d87799e05a93319a66d843c5f" translate="yes" xml:space="preserve">
          <source>In this example relation A is sorted by the third field, f3 in descending order. Note that the order of the three tuples ending in 3 can vary.</source>
          <target state="translated">В данном примере отношение A сортируется по третьему полю,f3 в порядке убывания.Обратите внимание,что порядок трех кортежей,оканчивающихся на 3,может меняться.</target>
        </trans-unit>
        <trans-unit id="c7a76748d23607d469a11fdd632d38e8948725ce" translate="yes" xml:space="preserve">
          <source>In this example relation A is split into three relations, X, Y, and Z.</source>
          <target state="translated">В этом примере отношение A разбито на три отношения:X,Y и Z.</target>
        </trans-unit>
        <trans-unit id="ea5ae7eac546e34a2d13c3fafaa1736e62a4a6ac" translate="yes" xml:space="preserve">
          <source>In this example relation X will contain 1% of the data in relation A.</source>
          <target state="translated">В этом примере отношение X будет содержать 1% данных в отношении A.</target>
        </trans-unit>
        <trans-unit id="e048f00ed84c4268f680319e8d3e4543df48f677" translate="yes" xml:space="preserve">
          <source>In this example relations A and B are joined by their first fields.</source>
          <target state="translated">В этом примере к отношениям А и Б присоединяются их первые поля.</target>
        </trans-unit>
        <trans-unit id="1fbb00b56354e90b99f0d0abee287efa949183ef" translate="yes" xml:space="preserve">
          <source>In this example ship is used to send the script to the cluster compute nodes.</source>
          <target state="translated">В этом примере корабль используется для отправки скрипта на узлы вычислений кластера.</target>
        </trans-unit>
        <trans-unit id="bb32f8e1cb739afed30691ec54c7d7d010de23a0" translate="yes" xml:space="preserve">
          <source>In this example single word values that don't use special characters (in this case, mydata) don't have to be enclosed in quotes.</source>
          <target state="translated">В этом примере значения одного слова,не использующие специальные символы (в данном случае мидаты),не обязательно заключать в кавычки.</target>
        </trans-unit>
        <trans-unit id="cb06a1600d91e4a228d8c694d3f8cc460e0f109e" translate="yes" xml:space="preserve">
          <source>In this example the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used to eliminate nesting.</source>
          <target state="translated">В этом примере оператор &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; используется для устранения вложенности.</target>
        </trans-unit>
        <trans-unit id="00106135a67fa0fb49d05b22a6af49367f72d99b" translate="yes" xml:space="preserve">
          <source>In this example the EXPLAIN operator produces all three plans. (Note that only a portion of the output is shown in this example.)</source>
          <target state="translated">В данном примере оператор EXPLAIN производит все три плана.(Обратите внимание,что в этом примере показана только часть выходного сигнала).</target>
        </trans-unit>
        <trans-unit id="e7c916eb550f56bcc8d23590cbf1cf0c80f42104" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes FLATTEN and a schema for simple data types.</source>
          <target state="translated">В этом примере оператор FOREACH включает FLATTEN и схему для простых типов данных.</target>
        </trans-unit>
        <trans-unit id="417fccbcd046561d8ffe25457defbd55e880d1fe" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schema for simple expression.</source>
          <target state="translated">В данном примере оператор FOREACH включает схему для простого выражения.</target>
        </trans-unit>
        <trans-unit id="e7d9bf5151735fb7eac9687d81ce6fb8ed553219" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schemas for multiple fields.</source>
          <target state="translated">В этом примере оператор FOREACH включает в себя схемы для нескольких полей.</target>
        </trans-unit>
        <trans-unit id="24842feb372ec793af9f761b6b82120ae0b6939d" translate="yes" xml:space="preserve">
          <source>In this example the LOAD statement includes a schema definition for simple data types.</source>
          <target state="translated">В этом примере оператор LOAD включает определение схемы для простых типов данных.</target>
        </trans-unit>
        <trans-unit id="9b1685e1972a2735b748823663c7d18cc3169868" translate="yes" xml:space="preserve">
          <source>In this example the ORDER operator is used to order the tuples and the LIMIT operator is used to output the first three tuples.</source>
          <target state="translated">В данном примере оператор ORDER используется для заказа кортежей,а оператор LIMIT-для вывода первых трех кортежей.</target>
        </trans-unit>
        <trans-unit id="d46d714daa065ac64bf616b27d931b45616989ad" translate="yes" xml:space="preserve">
          <source>In this example the asterisk (*) is used to project all fields from relation A to relation X. Relation A and X are identical.</source>
          <target state="translated">В этом примере звездочка (*)используется для проецирования всех полей от отношения A к отношению X.Отношения A и X идентичны.</target>
        </trans-unit>
        <trans-unit id="f747b7eff53d66ec54b4dcd3a59958f8f656a8bc" translate="yes" xml:space="preserve">
          <source>In this example the average GPA for each student is computed (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="translated">В этом примере вычисляется средний средний балл для каждого учащегося (см. Оператор &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; для получения информации об именах полей в отношении B).</target>
        </trans-unit>
        <trans-unit id="ce3f8dbd72e1ca5670215036e9a44f0b071ca7c3" translate="yes" xml:space="preserve">
          <source>In this example the bincond operator is used with fields f2 and B. The condition is &quot;f2 equals 1&quot;; if the condition is true, return 1; if the condition is false, return the count of the number of tuples in B.</source>
          <target state="translated">В данном примере оператор bincond используется с полями f2 и B.Условие &quot;f2 равно 1&quot;;если условие истинно,возвращаем 1;если условие ложно,возвращаем счетчик количества кортежей в B.</target>
        </trans-unit>
        <trans-unit id="6aaa13edf7e147edb799d5432c00b145a2899bd3" translate="yes" xml:space="preserve">
          <source>In this example the built in function SUM() is used to sum a set of numbers in a bag.</source>
          <target state="translated">В данном примере встроенная функция SUM()используется для суммирования набора чисел в пакете.</target>
        </trans-unit>
        <trans-unit id="f0ad9fb42b25648f0ae623cc3fafcfffe7daac86" translate="yes" xml:space="preserve">
          <source>In this example the case operator is used with field f2. The expression is &quot;f2 % 2&quot;; if the expression is equal to 0, return 'even'; if the expression is equal to 1, return 'odd'.</source>
          <target state="translated">В данном примере оператор случая используется с полем f2.Выражение-&quot;f2 % 2&quot;;если выражение равно 0,вернуть 'even';если выражение равно 1,вернуть 'odd'.</target>
        </trans-unit>
        <trans-unit id="092f4e5a8bef8cb9851796d251a7997b165bdd80" translate="yes" xml:space="preserve">
          <source>In this example the characters (in this case, Joe's URL) can be enclosed in single or double quotes, and quotes within the sequence of characters can be escaped.</source>
          <target state="translated">В этом примере символы (в данном случае URL Джо)могут быть заключены в одинарные или двойные кавычки,а кавычки в последовательности символов могут быть экранированы.</target>
        </trans-unit>
        <trans-unit id="ede799c3bc9b3029dc9c8360cd04456907800fde" translate="yes" xml:space="preserve">
          <source>In this example the clear command clean up Pig grunt shell.</source>
          <target state="translated">В этом примере команда clear clean up Pig grunt shell.</target>
        </trans-unit>
        <trans-unit id="25d6ee41375a393d7a680688e835a625f56d5bef" translate="yes" xml:space="preserve">
          <source>In this example the command is enclosed in back ticks. First, the parameters mycmd and date are substituted when the declare statement is encountered. Then the resulting command is executed and its stdout is placed in the path before the load statement is run.</source>
          <target state="translated">В данном примере команда заключена в обратные тики.Сначала при встрече оператора объявления подставляются параметры mycmd и дата.Затем выполняется результирующая команда и ее stdout помещается в путь до выполнения оператора загрузки.</target>
        </trans-unit>
        <trans-unit id="b89b66c6c88049c686630255f175fff0f626bdcf" translate="yes" xml:space="preserve">
          <source>In this example the command is executed and its stdout is used as the parameter value.</source>
          <target state="translated">В данном примере команда выполняется,а в качестве значения параметра используется stdout.</target>
        </trans-unit>
        <trans-unit id="8ce0f2c976b3fe8e4f40f38c3029dab1eb1cec85" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the first field equals 8 or if the sum of fields f2 and f3 is not greater than first field, then include the tuple relation X.</source>
          <target state="translated">В этом примере условие гласит,что если первое поле равно 8 или если сумма полей f2 и f3 не больше,чем первое поле,то включается отношение кортежа X.</target>
        </trans-unit>
        <trans-unit id="26b224c7415697f3852d73862430dd9075adbd5f" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the third field equals 3, then include the tuple with relation X.</source>
          <target state="translated">В этом примере условие гласит,что если третье поле равно 3,то включается кортеж с отношением X.</target>
        </trans-unit>
        <trans-unit id="d1025ef014af40aa64437028c4999384b00c45c4" translate="yes" xml:space="preserve">
          <source>In this example the cross product of relation A and B is computed.</source>
          <target state="translated">В этом примере вычисляется перекрестное произведение отношения A и B.</target>
        </trans-unit>
        <trans-unit id="acbe209f9e9a1e61b98b326bbd67ec1907b268ea" translate="yes" xml:space="preserve">
          <source>In this example the data file contains tuples. A schema for complex data types (in this case, tuples) is used to load the data. Then, dereference operators (the dot in t1.t1a and t2.$0) are used to access the fields in the tuples. Note that when you assign names to fields you can still refer to these fields using positional notation.</source>
          <target state="translated">В данном примере файл данных содержит кортежи.Для загрузки данных используется схема для сложных типов данных (в данном случае кортежей).Затем для доступа к полям в кортежах используются операторы разыменования (точка в t1.t1a и t2.$0).Обратите внимание,что когда вы присваиваете имена полям,вы все равно можете ссылаться на эти поля,используя позиционную нотацию.</target>
        </trans-unit>
        <trans-unit id="4e4e82302c1dcf3cf245b321e2f2024b324f3f18" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped and ordered.</source>
          <target state="translated">В данном примере данные сгруппированы и упорядочены.</target>
        </trans-unit>
        <trans-unit id="d6c450e1b8e75a80b634b42feb0e20c5b019d350" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped.</source>
          <target state="translated">В данном примере данные сгруппированы.</target>
        </trans-unit>
        <trans-unit id="cb28ee9adf8539445368e3a7354c61897a47de43" translate="yes" xml:space="preserve">
          <source>In this example the data is unordered.</source>
          <target state="translated">В данном примере данные не упорядочены.</target>
        </trans-unit>
        <trans-unit id="6603ac59abe4e83a9f3630ed1514e5ee65f95568" translate="yes" xml:space="preserve">
          <source>In this example the default load function, PigStorage, loads data from myfile.txt to form relation A. The two LOAD statements are equivalent. Note that, because no schema is specified, the fields are not named and all fields default to type bytearray.</source>
          <target state="translated">В этом примере функция загрузки по умолчанию PigStorage загружает данные из файла myfile.txt для формирования отношения A.Два утверждения LOAD эквивалентны.Обратите внимание,что поскольку схема не указана,поля не именуются,и все поля по умолчанию вводятся байтером.</target>
        </trans-unit>
        <trans-unit id="eb0d387430982dda1c08cffe6bc594f972418231" translate="yes" xml:space="preserve">
          <source>In this example the history command shows all the statements with line numbers and without them.</source>
          <target state="translated">В данном примере команда &quot;История&quot; показывает все операторы с номерами строк и без них.</target>
        </trans-unit>
        <trans-unit id="476af286c3ec71967ab312182ce2b62adf926b94" translate="yes" xml:space="preserve">
          <source>In this example the job with id job_0001 is killed.</source>
          <target state="translated">В данном примере задание с id job_0001 убито.</target>
        </trans-unit>
        <trans-unit id="b029e1c370efb6daa4ba5eb4f901c821a93416f8" translate="yes" xml:space="preserve">
          <source>In this example the limit is expressed as a scalar.</source>
          <target state="translated">В данном примере предел выражается скаляром.</target>
        </trans-unit>
        <trans-unit id="2e34eec81ca9c49c22acf02db69215d8d4e34e78" translate="yes" xml:space="preserve">
          <source>In this example the ls command is invoked.</source>
          <target state="translated">В данном примере вызывается команда ls.</target>
        </trans-unit>
        <trans-unit id="76f374ece7dcad13158f830af8da60b38d97b189" translate="yes" xml:space="preserve">
          <source>In this example the macro does not have a return alias; thus, void must be specified.</source>
          <target state="translated">В данном примере макрос не имеет псевдонима возврата,поэтому должен быть указан void.</target>
        </trans-unit>
        <trans-unit id="cd64ffc9b96611ae3793e3e5ba859e7d36b80811" translate="yes" xml:space="preserve">
          <source>In this example the macro is named my_macro. Note that only aliases A and C are visible from the outside; alias B is not visible from the outside.</source>
          <target state="translated">В данном примере макрос называется my_macro.Обратите внимание,что со стороны видны только псевдонимы A и C;со стороны псевдоним B не виден.</target>
        </trans-unit>
        <trans-unit id="6404afa0a6b34470610936e43c5cf53ae1ed10be" translate="yes" xml:space="preserve">
          <source>In this example the map includes two key value pairs.</source>
          <target state="translated">В данном примере карта включает в себя две пары ключевых значений.</target>
        </trans-unit>
        <trans-unit id="1711a19cfa3302a682910d13c83d53af9d0f1b78" translate="yes" xml:space="preserve">
          <source>In this example the maximum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">В этом примере максимальный GPA для всех терминов вычисляется для каждого студента (информацию о названиях полей в соотношении В см.в операторе GROUP).</target>
        </trans-unit>
        <trans-unit id="9d880bfbdf389fd36ac97f66b734bd7cf322568a" translate="yes" xml:space="preserve">
          <source>In this example the minimum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">В этом примере минимальный GPA для всех терминов вычисляется для каждого студента (см.информацию об именах полей в отношении В в операторе GROUP).</target>
        </trans-unit>
        <trans-unit id="6f6938263aa57a2bb9d2caa685487136b07bb471" translate="yes" xml:space="preserve">
          <source>In this example the modulo operator is used with fields f1 and f2.</source>
          <target state="translated">В данном примере оператор modulo используется с полями f1 и f2.</target>
        </trans-unit>
        <trans-unit id="9587d64b9e55a467c8f05370b86a5919538e4e78" translate="yes" xml:space="preserve">
          <source>In this example the number of characters in the first field is computed.</source>
          <target state="translated">В данном примере подсчитывается количество символов в первом поле.</target>
        </trans-unit>
        <trans-unit id="1b286a09468d93c61174ef82f5d5ce20e0200311" translate="yes" xml:space="preserve">
          <source>In this example the number of pets is computed. (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">В данном примере подсчитывается количество домашних животных.(Информацию о названиях полей в отношении B см.в операторе GROUP).</target>
        </trans-unit>
        <trans-unit id="1317fabb77110a5157dbf3c1989811a052d00d38" translate="yes" xml:space="preserve">
          <source>In this example the parameter (DATE) and value ('20090101') are specified in the Pig script using the default statement. If a value for DATE is not specified elsewhere, the default value 20090101 is used.</source>
          <target state="translated">В этом примере параметр (DATE)и значение ('20090101')задаются в скрипте Pig с помощью оператора по умолчанию.Если значение для DATE нигде не указано,используется значение по умолчанию 20090101.</target>
        </trans-unit>
        <trans-unit id="2e98bd8685b77fd467a6fbb1af6b37b502f7b21e" translate="yes" xml:space="preserve">
          <source>In this example the parameter (data) and the parameter value (mydata) are specified in the command line. If the parameter name in the command line (data) and the parameter name in the script ($data) do not match, the script will not run. If the value for the parameter (mydata) is not found, an error is generated.</source>
          <target state="translated">В данном примере параметр (данные)и значение параметра (миданные)задаются в командной строке.Если имя параметра в командной строке (данные)и имя параметра в скрипте ($data)не совпадают,скрипт не запустится.Если значение параметра (mydata)не найдено,генерируется ошибка.</target>
        </trans-unit>
        <trans-unit id="6ed4d9d9c3e64f1c8ed8531ebff8cca25da2370b" translate="yes" xml:space="preserve">
          <source>In this example the parameters and values are passed to the script using the parameter file.</source>
          <target state="translated">В данном примере параметры и значения передаются в скрипт с помощью файла параметров.</target>
        </trans-unit>
        <trans-unit id="a1b2909b057f9a09ca537aaf439edc1877ad06cf" translate="yes" xml:space="preserve">
          <source>In this example the percentage of clicks belonging to a particular user are computed. For the FOREACH statement, an explicit cast is used. If the SUM is not given a name, a position can be used as well (userid, clicks/(double)C.$0).</source>
          <target state="translated">В данном примере вычисляется процент кликов,принадлежащих определенному пользователю.Для утверждения FOREACH используется явная кастинг.Если SUM не имеет имени,может быть использована и позиция (userid,click/(double)C.$0).</target>
        </trans-unit>
        <trans-unit id="d4aff9a2fd5846372e7438a9400d514b26787e3a" translate="yes" xml:space="preserve">
          <source>In this example the quit command exits the Pig grunt shall.</source>
          <target state="translated">В этом примере команда &quot;Выход&quot; выходит из &quot;Свиной ворчания&quot;.</target>
        </trans-unit>
        <trans-unit id="2d4709cf6d5853667a759dfa1d106eed84020b7e" translate="yes" xml:space="preserve">
          <source>In this example the same data is loaded twice using aliases A and B.</source>
          <target state="translated">В данном примере одни и те же данные загружаются дважды с использованием псевдонимов A и B.</target>
        </trans-unit>
        <trans-unit id="fc5789de4d75cad94be41c5facecc34fe4971feb" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a bag. The two load statements are equivalent.</source>
          <target state="translated">В этом примере схема определяет пакет.Оба вида нагрузки эквивалентны.</target>
        </trans-unit>
        <trans-unit id="8755ba412043fe803f3282f9a04a78a7dee177a3" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a tuple, bag, and map.</source>
          <target state="translated">В этом примере схема определяет кортеж,сумку и карту.</target>
        </trans-unit>
        <trans-unit id="7cd7118a92ca87fa2d331c8470cf4842dff265de" translate="yes" xml:space="preserve">
          <source>In this example the schema defines an untyped map (the map values default to bytearray). The load statements are equivalent.</source>
          <target state="translated">В этом примере схема определяет нетиповую карту (значения карты по умолчанию-Bytearray).Операторы нагрузки эквивалентны.</target>
        </trans-unit>
        <trans-unit id="5cd0cb1fc97ce5841696cd76163b3e5eb768aca1" translate="yes" xml:space="preserve">
          <source>In this example the schema defines multiple types.</source>
          <target state="translated">В данном примере схема определяет несколько типов.</target>
        </trans-unit>
        <trans-unit id="82f2e4223d2166be4de020826791e51ada52b60a" translate="yes" xml:space="preserve">
          <source>In this example the schema defines one tuple. The load statements are equivalent.</source>
          <target state="translated">В этом примере схема определяет один кортеж.Нагрузочные утверждения эквивалентны.</target>
        </trans-unit>
        <trans-unit id="bf67db086de69e41eae0849cf525acbd64482062" translate="yes" xml:space="preserve">
          <source>In this example the schema defines two tuples.</source>
          <target state="translated">В этом примере схема определяет два кортежа.</target>
        </trans-unit>
        <trans-unit id="374e1d1c9089f64e9a3f6e17445b7108876892bc" translate="yes" xml:space="preserve">
          <source>In this example the script interacts with the results of commands issued via the Grunt shell.</source>
          <target state="translated">В данном примере скрипт взаимодействует с результатами команд,выданных через оболочку Grunt.</target>
        </trans-unit>
        <trans-unit id="99317ecfb2f2d2f8e22397ef775944c5ef25b329" translate="yes" xml:space="preserve">
          <source>In this example the script is displayed and run.</source>
          <target state="translated">В этом примере скрипт отображается и выполняется.</target>
        </trans-unit>
        <trans-unit id="2e598eccd5a601dd744d347f16c97195afdc76a1" translate="yes" xml:space="preserve">
          <source>In this example the streaming stderr is stored in the _logs/&amp;lt;dir&amp;gt; directory of the job's output directory. Because the job can have multiple streaming applications associated with it, you need to ensure that different directory names are used to avoid conflicts. Pig stores up to 100 tasks per streaming job.</source>
          <target state="translated">В этом примере потоковый stderr хранится в каталоге _logs / &amp;lt;dir&amp;gt; выходного каталога задания. Поскольку задание может иметь несколько потоковых приложений, связанных с ним, необходимо убедиться, что разные имена каталогов используются во избежание конфликтов. Свинья хранит до 100 задач на потоковую работу.</target>
        </trans-unit>
        <trans-unit id="12004346bfe8b9058047ed1fff89d8df9e7971b7" translate="yes" xml:space="preserve">
          <source>In this example the strings in each row are split.</source>
          <target state="translated">В данном примере строки в каждой строке разделены.</target>
        </trans-unit>
        <trans-unit id="5ca70fcce90aa1c6cf4766d1a9176002ded5188b" translate="yes" xml:space="preserve">
          <source>In this example the top 10 occurrences are returned.</source>
          <target state="translated">В этом примере возвращается 10 лучших происшествий.</target>
        </trans-unit>
        <trans-unit id="021afd1412e5a5955bb3fb59bfd3c0a85c063129" translate="yes" xml:space="preserve">
          <source>In this example the tuple contains three fields.</source>
          <target state="translated">В данном примере кортеж содержит три поля.</target>
        </trans-unit>
        <trans-unit id="f597683856676d8bafb6405513e3ebe7baf66915" translate="yes" xml:space="preserve">
          <source>In this example the tuples are grouped using an expression, f2*f3.</source>
          <target state="translated">В данном примере кортежи сгруппированы с помощью выражения,f2*f3.</target>
        </trans-unit>
        <trans-unit id="5e310234a9bc1536d78449f454a40dbd0fea419f" translate="yes" xml:space="preserve">
          <source>In this example the tuples in the bag are counted (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="translated">В этом примере подсчитываются кортежи в сумке (см. Оператор &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; для получения информации об именах полей в отношении B).</target>
        </trans-unit>
        <trans-unit id="c431411d674fcbd3d4993f3b148f0ab1fd9627c8" translate="yes" xml:space="preserve">
          <source>In this example the union of relation A and B is computed.</source>
          <target state="translated">В этом примере вычисляется союз отношений А и Б.</target>
        </trans-unit>
        <trans-unit id="6d9b64e41ad4836645b8177be3ac9c0030fd0d8b" translate="yes" xml:space="preserve">
          <source>In this example tuples are co-grouped using field &amp;ldquo;owner&amp;rdquo; from relation A and field &amp;ldquo;friend2&amp;rdquo; from relation B as the key fields. The DESCRIBE operator shows the schema for relation X, which has three fields, &quot;group&quot;, &quot;A&quot; and &quot;B&quot; (see the GROUP operator for information about the field names).</source>
          <target state="translated">В этом примере кортежи объединяются с использованием поля &amp;laquo;owner&amp;raquo; из отношения A и поля &amp;laquo;friend2&amp;raquo; из отношения B в качестве ключевых полей. Оператор DESCRIBE показывает схему для отношения X, которая имеет три поля: &amp;laquo;группа&amp;raquo;, &amp;laquo;A&amp;raquo; и &amp;laquo;B&amp;raquo; (см. Оператор GROUP для получения информации об именах полей).</target>
        </trans-unit>
        <trans-unit id="dde4ecc1f27426000ba5fe853e50128821f2f398" translate="yes" xml:space="preserve">
          <source>In this example two fields from relation A are projected to form relation X.</source>
          <target state="translated">В этом примере два поля из соотношения A спроецированы на формирование отношения X.</target>
        </trans-unit>
        <trans-unit id="bc47fb195353fb6458455bd7a9f15093c04fb95c" translate="yes" xml:space="preserve">
          <source>In this example two fields in relation A are summed to form relation X. A schema is defined for the projected field.</source>
          <target state="translated">В этом примере два поля в соотношении A суммируются для формирования соотношения X.Для проектируемого поля задается схема.</target>
        </trans-unit>
        <trans-unit id="374e1a3a44b5c072bbee353fcde0ae6d5ba08c31" translate="yes" xml:space="preserve">
          <source>In this example user defined serialization/deserialization functions are used with the script.</source>
          <target state="translated">В данном примере скрипт использует функции сериализации/десериализации,определенные пользователем.</target>
        </trans-unit>
        <trans-unit id="7c1a5311dceb63c974e9b2cfc727be221f3bb244" translate="yes" xml:space="preserve">
          <source>In this example we filter out ID 4 and 6.</source>
          <target state="translated">В данном примере мы отфильтровываем ID 4 и 6.</target>
        </trans-unit>
        <trans-unit id="12cea5022f6e359ede64a2f3cade86cdf43e9f89" translate="yes" xml:space="preserve">
          <source>In this example we perform two of the operations allowed in a nested block, FILTER and DISTINCT. Note that the last statement in the nested block must be GENERATE. Also, note the use of projection (PA = FA.outlink;) to retrieve a field. DISTINCT can be applied to a subset of fields (as opposed to a relation) only within a nested block.</source>
          <target state="translated">В данном примере мы выполняем две операции,разрешенные во вложенном блоке,FILTER и DISTINCT.Обратите внимание,что последнее утверждение во вложенном блоке должно быть GENERATE.Также обратите внимание на использование проекции (PA=FA.outlink;)для получения поля.DISTINCT может быть применен к подмножеству полей (в отличие от отношения)только внутри вложенного блока.</target>
        </trans-unit>
        <trans-unit id="fa386fd96cd26dfb68e71c6977b54eb2ca55f776" translate="yes" xml:space="preserve">
          <source>In this example, Pig will validate and then execute the LOAD, FOREACH, and DUMP statements.</source>
          <target state="translated">В этом примере Свинья будет проверять,а затем выполнять операторы LOAD,FOREACH и DUMP.</target>
        </trans-unit>
        <trans-unit id="d4558a0e1b18bdd5eee2ed93dafa87c2da9e505c" translate="yes" xml:space="preserve">
          <source>In this example, PigStorage loads data with complex data type, a bag of map and double.</source>
          <target state="translated">В этом примере PigStorage загружает данные со сложным типом данных,пакет с картой и двойной.</target>
        </trans-unit>
        <trans-unit id="b9f6baa8723253b0ff5da6f6200823682a8e7924" translate="yes" xml:space="preserve">
          <source>In this example, SUBTRACT creates a new bag composed of B1 elements that are not in B2.</source>
          <target state="translated">В данном примере SUBTRACT создает новый пакет,состоящий из элементов B1,которые не входят в B2.</target>
        </trans-unit>
        <trans-unit id="628bdb7c844633083f052de93a85c78a122db14c" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with one field is converted to a tuple.</source>
          <target state="translated">В этом примере сумка,содержащая кортежи с одним полем,преобразуется в кортеж.</target>
        </trans-unit>
        <trans-unit id="31ad0d826c111e02076048c8e848b2bc5512a7f5" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with two fields is converted to a tuple.</source>
          <target state="translated">В этом примере сумка,содержащая кортежи с двумя полями,конвертируется в кортеж.</target>
        </trans-unit>
        <trans-unit id="7ba1ab45b8d5e801bda851513ebce706791389a2" translate="yes" xml:space="preserve">
          <source>In this example, a scalar expression is used (it will sample approximately 1000 records from the input).</source>
          <target state="translated">В данном примере используется скалярное выражение (из входных данных будет взята выборка примерно 1000 записей).</target>
        </trans-unit>
        <trans-unit id="0c050f08cf94a0faf1569c2cd017c23c7029793b" translate="yes" xml:space="preserve">
          <source>In this example, because a path is not given, Pig will use the import path specified in pig.import.search.path.</source>
          <target state="translated">В этом примере,поскольку путь не задан,Свинья будет использовать путь импорта,указанный в pig.import.search.path.</target>
        </trans-unit>
        <trans-unit id="f8d18d2738156bb9536be2726da1b0055af29572" translate="yes" xml:space="preserve">
          <source>In this example, fields f1 and f3 are converted to tuples that are then placed in a bag.</source>
          <target state="translated">В этом примере поля f1 и f3 преобразуются в кортежи,которые затем помещаются в пакет.</target>
        </trans-unit>
        <trans-unit id="8b5550925189ae7bf57a03a71682900e5449f00f" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, an underscore string literal, f2 and f3 are concatenated.</source>
          <target state="translated">В этом примере поля f1,литерал подчеркивающей строки,f2 и f3 объединены.</target>
        </trans-unit>
        <trans-unit id="3ab2c3d36b021dc631caeb2e9d192769dc62ae3c" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, f2 and f3 are converted to a tuple.</source>
          <target state="translated">В этом примере поля f1,f2 и f3 преобразуются в кортеж.</target>
        </trans-unit>
        <trans-unit id="7924a4aff410ec62e1625fb749420c25e9e40967" translate="yes" xml:space="preserve">
          <source>In this example, parameters passed to run/exec command or declared within the called scripts are not visible to the caller.</source>
          <target state="translated">В данном примере параметры,переданные для выполнения/выполнения команды или объявленные в вызываемых скриптах,не видны вызывающему абоненту.</target>
        </trans-unit>
        <trans-unit id="3bb04af80246e86e73ab32302c82691b112dec27" translate="yes" xml:space="preserve">
          <source>In this example, student names (type chararray) and student GPAs (type float) are used to create three maps.</source>
          <target state="translated">В этом примере имена учеников (тип chararray)и GPA учеников (тип float)используются для создания трех карт.</target>
        </trans-unit>
        <trans-unit id="e7bb96091fb633aa0dd9a62cf0641bf708fbda94" translate="yes" xml:space="preserve">
          <source>In this example, the CONCAT function is used to format the data before it is stored.</source>
          <target state="translated">В данном примере функция CONCAT используется для форматирования данных перед их сохранением.</target>
        </trans-unit>
        <trans-unit id="067351e08e674c5bf43312d16f3cfc906bf4efea" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator does not change the order of the relation and simply prepends to each tuple a sequential value.</source>
          <target state="translated">В данном примере оператор RANK не изменяет порядок следования соотношений и просто предваряет каждому кортежу последовательное значение.</target>
        </trans-unit>
        <trans-unit id="f697de11b6e8be82a227e004decddf6bf4447be5" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator works with f1 and f2 fields, and each one with different sorting order. RANK sorts the relation on these fields and prepends the rank value to each tuple. Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="translated">В данном примере оператор RANK работает с полями f1 и f2,причем каждое из полей имеет свой порядок сортировки.RANK сортирует отношение по этим полям и предваряет значение ранга к каждому кортежу.В противном случае оператор &quot;Ранк&quot; использует каждое поле (или набор полей)для сортировки отношения.Ранг кортежа-это один плюс число различных значений ранга,предшествующих ему.Если два или более кортежей связывают значения полей сортировки,то они получают одну и ту же ранговую оценку.</target>
        </trans-unit>
        <trans-unit id="1f3b4221a79d008988b7876075995e6b8d7835e6" translate="yes" xml:space="preserve">
          <source>In this example, the SPLIT and FILTER statements are essentially equivalent. However, because SPLIT is implemented as &quot;split the data stream and then apply filters&quot; the SPLIT statement is more expensive than the FILTER statement because Pig needs to filter and store two data streams.</source>
          <target state="translated">В этом примере заявления SPLIT и FILTER по существу эквивалентны.Однако,поскольку SPLIT реализован как &quot;разделить поток данных и затем применить фильтры&quot;,утверждение SPLIT более дорогое,чем утверждение FILTER,поскольку Pig необходимо отфильтровать и хранить два потока данных.</target>
        </trans-unit>
        <trans-unit id="14d08384e4aaff3f8be0a78561d22848f60f1375" translate="yes" xml:space="preserve">
          <source>In this example, the function gets one parameter of type float and another of type double. The best fit will be the function that takes two double values. Pig makes this choice on the user's behalf by inserting implicit casts for the parameters. Running the script above is equivalent to running the script below:</source>
          <target state="translated">В данном примере функция получает один параметр типа float,а другой тип double.Наилучшим вариантом будет функция,которая принимает два значения типа double.Pig делает этот выбор от имени пользователя,вставляя неявные касты для параметров.Запуск скрипта выше эквивалентен запуску скрипта ниже:</target>
        </trans-unit>
        <trans-unit id="881155eba58f9e850386857207058c2bcc0dde01" translate="yes" xml:space="preserve">
          <source>In this example, the negation operator is applied to the &quot;x&quot; values.</source>
          <target state="translated">В данном примере оператор отрицания применяется к значениям &quot;x&quot;.</target>
        </trans-unit>
        <trans-unit id="ed1b3ee3654de3cdf2209317bbe036a32a65e1c9" translate="yes" xml:space="preserve">
          <source>In this example, to disambiguate y, use A::y or B::y. In cases where there is no ambiguity, such as z, the :: is not necessary but is still supported.</source>
          <target state="translated">В данном примере,чтобы разделить y,используйте A::y или B::y.В случаях,когда неоднозначность отсутствует,например,z,параметр :::не является необходимым,но все же поддерживается.</target>
        </trans-unit>
        <trans-unit id="0224a2baaf9cd9707e2e7cf53337aeaeaf373da6" translate="yes" xml:space="preserve">
          <source>In this example, values that are not null are obtained.</source>
          <target state="translated">В данном примере получены значения,которые не являются нулевыми.</target>
        </trans-unit>
        <trans-unit id="6e4679058adb8da48ed2faf2b2035bd49505dbe0" translate="yes" xml:space="preserve">
          <source>In this example, we pass (null, &quot;names.txt&quot;) to the construct of UDF in_file, meaning the first parameter is regular, the second parameter is a constant. names.txt can be double quoted (unlike other Pig syntax), or quoted in \'. Note we need to pass 'names.txt' again in line 3. This looks stupid but we need to do this to fill the semantic gap between Pig and Hive. We need to pass the constant in the data pipeline in line 3, which is similar Pig UDF. Initialization code in Hive UDF takes ObjectInspector, which capture the data type and whether or not the parameter is a constant. However, initialization code in Pig takes schema, which only capture the former. We need to use additional mechanism (construct parameter) to convey the later.</source>
          <target state="translated">В этом примере мы передаем (null,&quot;names.txt&quot;)в конструкцию UDF in_file,то есть первый параметр является регулярным,второй параметр-константой.names.txt может быть двойной кавычкой (в отличие от других синтаксисов Pig),или кавычкой в \'.Обратите внимание,что нам нужно снова передать 'names.txt' в строке 3.Это выглядит глупо,но мы должны сделать это,чтобы заполнить семантический разрыв между Pig и Hive.Нам нужно передать константу в информационном конвейере в строке 3,которая похожа на Pig UDF.Код инициализации в Hive UDF принимает ObjectInspector,который захватывает тип данных и является ли параметр константой или нет.Однако код инициализации в Pig принимает схему,которая захватывает только первую.Нужно использовать дополнительный механизм (конструировать параметр)для передачи последующего.</target>
        </trans-unit>
        <trans-unit id="9c2dcd3fec58a0ebe5b61ce427c75e4270cee26f" translate="yes" xml:space="preserve">
          <source>In this example, we're passing a BigInteger and using NOT operator, thereby negating the passed list of fields in the IN clause</source>
          <target state="translated">В этом примере мы передаем BigInteger и используем оператор NOT,тем самым отрицая переданный список полей в пункте IN</target>
        </trans-unit>
        <trans-unit id="b8ac1c53434de8d305b7f189975c25cebec6a49b" translate="yes" xml:space="preserve">
          <source>In this script, MYUDF might try to read from out1, a file that A was just stored into. However, Pig does not know that MYUDF depends on the out1 file and might submit the jobs producing the out2 and out1 files at the same time.</source>
          <target state="translated">В этом скрипте MYUDF может попытаться прочитать из out1,файл,в который A только что был сохранен.Однако Свинья не знает,что MYUDF зависит от файла out1 и может отправлять задания,производящие файлы out2 и out1 одновременно.</target>
        </trans-unit>
        <trans-unit id="eaeebfe1f5eff1ee401092bdf4bfaa13b02e1352" translate="yes" xml:space="preserve">
          <source>In this script, the STORE/LOAD operators have different file paths; however, the LOAD operator depends on the STORE operator.</source>
          <target state="translated">В этом сценарии операторы STORE/LOAD имеют различные пути к файлам,однако,оператор LOAD зависит от оператора STORE.</target>
        </trans-unit>
        <trans-unit id="388a7f3ab68e1015ed7e6c293c2ff263c2a3d0ea" translate="yes" xml:space="preserve">
          <source>Increase the parallelism of a job by specifying the number of reduce tasks, n.</source>
          <target state="translated">Увеличьте параллельность задания,указав количество сокращенных заданий,n.</target>
        </trans-unit>
        <trans-unit id="e9a90a62d3ab8cd810db61a4caae391f73d2d675" translate="yes" xml:space="preserve">
          <source>Inner merge join (between two tables) will only work under these conditions:</source>
          <target state="translated">Внутреннее соединение слияния (между двумя таблицами)будет работать только при этих условиях:</target>
        </trans-unit>
        <trans-unit id="03a548863c266dc43de099b2b4dcd58730363f30" translate="yes" xml:space="preserve">
          <source>InputStats</source>
          <target state="translated">InputStats</target>
        </trans-unit>
        <trans-unit id="a881c6dfaceae2347739afd1176127808734fa29" translate="yes" xml:space="preserve">
          <source>Inside your script, you can define parameters and then pass parameters from command line to your script. There are two ways to pass parameters to your script:</source>
          <target state="translated">Внутри вашего скрипта вы можете определить параметры,а затем передать параметры из командной строки в ваш скрипт.Есть два способа передачи параметров вашему скрипту:</target>
        </trans-unit>
        <trans-unit id="d38ec86271222cf540ae29ce6fdce3cf0bb0bdae" translate="yes" xml:space="preserve">
          <source>Instead of figuring out the dependencies manually, downloading them and registering each jar using the above &lt;a href=&quot;#register-jar&quot;&gt;register command&lt;/a&gt;, you can specify the artifact's coordinates and expect pig to automatically fetch the required dependencies, download and register them.</source>
          <target state="translated">Вместо того, чтобы вычислять зависимости вручную, загружать их и регистрировать каждый jar с помощью приведенной выше &lt;a href=&quot;#register-jar&quot;&gt;команды register&lt;/a&gt; , вы можете указать координаты артефакта и ожидать, что pig автоматически выберет необходимые зависимости, загрузит и зарегистрирует их.</target>
        </trans-unit>
        <trans-unit id="f6e225003256a2a1b59e6d92b0617521bd13c8e2" translate="yes" xml:space="preserve">
          <source>Instead use ToString to format the date/time portions and SPRINTF to layout the results.</source>
          <target state="translated">Вместо этого используйте ToString для форматирования фрагментов даты/времени и SPRINTF для компоновки результатов.</target>
        </trans-unit>
        <trans-unit id="4cf0450c6e840f4cdcb5c3195b6b05d10c9d0ad9" translate="yes" xml:space="preserve">
          <source>Instead, assemble it in pieces. In step 2, we sort on one field but process another; it remains in the sorted order.</source>
          <target state="translated">Вместо этого,соберите его по частям.На шаге 2 мы сортируем на одном поле,а обрабатываем на другом,оно остается в отсортированном порядке.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="94dc8e4a59fafe99eded0ffa98b6e8ea00efeca7" translate="yes" xml:space="preserve">
          <source>Interaction</source>
          <target state="translated">Interaction</target>
        </trans-unit>
        <trans-unit id="af3758608388b05871589b2b19e12008ace4a0d4" translate="yes" xml:space="preserve">
          <source>Interactive Mode</source>
          <target state="translated">Интерактивный режим</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="048850efc4e3902868045111cefcac3a0e527ce7" translate="yes" xml:space="preserve">
          <source>Invalid identifiers:</source>
          <target state="translated">Недействительные идентификаторы:</target>
        </trans-unit>
        <trans-unit id="888bb77151bd6eaba885bae449bb376eb7118989" translate="yes" xml:space="preserve">
          <source>Invocation Basics</source>
          <target state="translated">Приглашение Основы</target>
        </trans-unit>
        <trans-unit id="b747cea14bf58e7def2e01119aae868ffb489ab7" translate="yes" xml:space="preserve">
          <source>Invocation Details</source>
          <target state="translated">Справка о приглашении Детали</target>
        </trans-unit>
        <trans-unit id="cb31f6339e723fd50bd0157d6fe131b36204092b" translate="yes" xml:space="preserve">
          <source>Invokes any FsShell command from within a Pig script or the Grunt shell.</source>
          <target state="translated">Призывает любую команду FsShell из скрипта Pig или оболочки Grunt.</target>
        </trans-unit>
        <trans-unit id="387341bd057cbb29666274908fe3359e6d22dd4f" translate="yes" xml:space="preserve">
          <source>Invokes any sh shell command from within a Pig script or the Grunt shell.</source>
          <target state="translated">Призывает любую команду оболочки sh из скрипта Pig или оболочки Grunt.</target>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="363a45b6f463769784d3f21486a12e29d0abf261" translate="yes" xml:space="preserve">
          <source>IsEmpty(expression)</source>
          <target state="translated">IsEmpty(expression)</target>
        </trans-unit>
        <trans-unit id="88de2259b3b3f72d4d9041583c92b54b45aa01e0" translate="yes" xml:space="preserve">
          <source>It is possible to enable a Hadoop job to request new tickets when they expire by creating a keytab file and make it part of the job that is running in the cluster. This will extend the maximum job duration beyond the maximum renew time of the kerberos tickets.</source>
          <target state="translated">Можно включить задание Hadoop для запроса новых билетов по истечении их срока действия,создав файл с клавиатурой,и сделать его частью задания,выполняемого в кластере.Это позволит продлить максимальную длительность задания,превышающую максимальное время обновления керберо-билетов.</target>
        </trans-unit>
        <trans-unit id="33cd6ef902f5caf739b2a2823cacab7fda072487" translate="yes" xml:space="preserve">
          <source>It is safe only to ship files to be executed from the current working directory on the task on the cluster.</source>
          <target state="translated">Безопасно только отправлять файлы для выполнения из текущей рабочей директории на задачу на кластере.</target>
        </trans-unit>
        <trans-unit id="d9433ba5a82fa587313360ad26116c0000526441" translate="yes" xml:space="preserve">
          <source>It is simple to fetch all columns from Airport codes that fall between Boston and San Francisco that can be viewed with 'auth1' and/or 'auth2' Accumulo authorizations.</source>
          <target state="translated">Просто получить все колонки из кодов аэропортов,которые находятся между Бостоном и Сан-Франциско,которые можно просмотреть с помощью 'auth1' и/или 'auth2' Accumulo авторизации.</target>
        </trans-unit>
        <trans-unit id="eb8f70933c32c8862ef0e315b9d3b91803410867" translate="yes" xml:space="preserve">
          <source>It is very important for performance to make sure that aggregate functions that are algebraic are implemented as such. Let's look at the implementation of the COUNT function to see what this means. (Error handling and some other code is omitted to save space. The full code can be accessed &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt; here&lt;/a&gt;.)</source>
          <target state="translated">Для производительности очень важно убедиться, что агрегатные функции, которые являются алгебраическими, реализованы как таковые. Давайте посмотрим на реализацию функции COUNT, чтобы увидеть, что это значит. (Обработка ошибок и некоторый другой код опущен для экономии места. Полный код доступен &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt;здесь&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="73440bfe667d9a800a12a41ebcd900edfd1b1df4" translate="yes" xml:space="preserve">
          <source>It is very important for performance to make sure that aggregate functions that are algebraic are implemented as such. Let's look at the implementation of the COUNT function to see what this means. (Error handling and some other code is omitted to save space. The full code can be accessed &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt; here&lt;/a&gt;.)</source>
          <target state="translated">Для производительности очень важно убедиться, что алгебраические агрегатные функции реализованы как таковые. Давайте посмотрим на реализацию функции COUNT, чтобы понять, что это означает. (Обработка ошибок и некоторый другой код опущены для экономии места. Полный код можно найти &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt;здесь&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="27ef4d2a6cf1d08c5ea52e79fbc6638e458ce3ab" translate="yes" xml:space="preserve">
          <source>It's OK to supply too many, though</source>
          <target state="translated">Это нормально,поставлять слишком много,хотя...</target>
        </trans-unit>
        <trans-unit id="720a64aa2e384f654ad24f02483f843d4fa544c7" translate="yes" xml:space="preserve">
          <source>JOIN (inner)</source>
          <target state="translated">Джойн (внутренний)</target>
        </trans-unit>
        <trans-unit id="10dbe28c733242b09a204b8afa7bda322c04edfb" translate="yes" xml:space="preserve">
          <source>JOIN (outer)</source>
          <target state="translated">Джойн (внешний)</target>
        </trans-unit>
        <trans-unit id="7d1cb24c2595ad4575c4ec6e01cbd73136b6732a" translate="yes" xml:space="preserve">
          <source>Jars required for user defined functions (UDFs) are copied to distributed cache by pig to make them available on task nodes. To put these jars on distributed cache, pig clients copy these jars to HDFS under a temporary location. For scheduled jobs, these jars do not change frequently. Also, creating a lot of small jar files on HDFS is not HDFS friendly. To avoid copying these small jar files to HDFS again and again, pig allows users to configure a user level jar cache (readable only to the user for security reasons). If pig.user.cache.enabled flag is set to true, UDF jars are copied to jar cache location (configurable) under a directory named with the hash (SHA) of the jar. Hash of the jar is used to identify the existence of the jar in subsequent uses of the jar by the user. If a jar with same hash and filename is found in the cache, it is used avoiding copy of the jar to hdfs.</source>
          <target state="translated">Баночки,необходимые для определенных пользователем функций (UDF),копируются в распределенный кэш по свинью,чтобы сделать их доступными на узлах задач.Чтобы поместить эти банки на распределённое кэширование,клиенты &quot;свиньи&quot; копируют эти банки на HDFS во временное место.Для запланированных заданий эти банки не меняются часто.Кроме того,создание большого количества маленьких банок на HDFS не очень удобно для HDFS.Чтобы избежать повторного копирования этих маленьких баночек на HDFS,pig позволяет пользователям настраивать кэш на пользовательском уровне (читаемый только пользователю из соображений безопасности).Если флаг pig.user.cache.enabled установлен в true,банки UDF копируются в место расположения jar-кэша (настраиваемого)под директорией с именем хэша (SHA)банки.Хэш банки используется для идентификации существования банки при последующем ее использовании пользователем.Если банка с тем же хэшем и именем файла находится в кэше,она используется во избежание копирования банки в hdfs.</target>
        </trans-unit>
        <trans-unit id="95430344cb2583fdd1f91fe40b6a426c6cdb7d10" translate="yes" xml:space="preserve">
          <source>Java API</source>
          <target state="translated">Java API</target>
        </trans-unit>
        <trans-unit id="220874040658928dfd28599011834e1d343f6a06" translate="yes" xml:space="preserve">
          <source>Java BigDecimal</source>
          <target state="translated">Java BigDecimal</target>
        </trans-unit>
        <trans-unit id="08f070a244c3d5ae1d6e726845ba3cf27ed3a4ee" translate="yes" xml:space="preserve">
          <source>Java BigInteger</source>
          <target state="translated">Java BigInteger</target>
        </trans-unit>
        <trans-unit id="8c689b2df07d5ac7a956c5d5f96beb6beed619e6" translate="yes" xml:space="preserve">
          <source>Java Class</source>
          <target state="translated">класс Java</target>
        </trans-unit>
        <trans-unit id="ecdb578d70bdad641779bb3cf2409b8a930d4cc0" translate="yes" xml:space="preserve">
          <source>Java Objects</source>
          <target state="translated">Java-объекты</target>
        </trans-unit>
        <trans-unit id="4e2d7efd6e5d57f9e2fd04c772bf368801395eaf" translate="yes" xml:space="preserve">
          <source>Java Test</source>
          <target state="translated">Java-тест</target>
        </trans-unit>
        <trans-unit id="c016599191077ac21a20ca4a9937da89712a611b" translate="yes" xml:space="preserve">
          <source>Java UDFs can be invoked multiple ways. The simplest UDF can just extend EvalFunc, which requires only the exec function to be implemented (see &lt;a href=&quot;#eval-functions-write&quot;&gt; How to Write a Simple Eval Function&lt;/a&gt;). Every eval UDF must implement this. Additionally, if a function is algebraic, it can implement Algebraic interface to significantly improve query performance in the cases when combiner can be used (see &lt;a href=&quot;#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;). Finally, a function that can process tuples in an incremental fashion can also implement the Accumulator interface to improve query memory consumption (see &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;).</source>
          <target state="translated">Java UDF могут вызываться несколькими способами. Простейшая UDF может просто расширить EvalFunc, для которой требуется реализация только функции exec (см. &lt;a href=&quot;#eval-functions-write&quot;&gt;Как написать простую функцию Eval&lt;/a&gt; ). Каждый eval UDF должен реализовать это. Кроме того, если функция алгебраическая, она может реализовать алгебраический интерфейс, чтобы значительно улучшить производительность запросов в тех случаях, когда можно использовать объединитель (см. &lt;a href=&quot;#algebraic-interface&quot;&gt;Алгебраический интерфейс&lt;/a&gt; ). Наконец, функция, которая может обрабатывать кортежи в инкрементном режиме, также может реализовать интерфейс Accumulator для улучшения потребления памяти запросов (см. &lt;a href=&quot;#accumulator-interface&quot;&gt;Интерфейс Accumulator&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d5889044826a763834c9c012a37f5c86407ecc85" translate="yes" xml:space="preserve">
          <source>Job XML</source>
          <target state="translated">Иов XML</target>
        </trans-unit>
        <trans-unit id="6cc61673b0dee9980ed3e68bb162982c295dc41b" translate="yes" xml:space="preserve">
          <source>JobStats</source>
          <target state="translated">JobStats</target>
        </trans-unit>
        <trans-unit id="5753a498f025464d72e088a9d5d6e872592d5f91" translate="yes" xml:space="preserve">
          <source>John</source>
          <target state="translated">John</target>
        </trans-unit>
        <trans-unit id="13b0d0b8d9cc13668684c1e4def8925fe90d5929" translate="yes" xml:space="preserve">
          <source>JsonLoader( ['schema'] )</source>
          <target state="translated">JsonLoader(((схема)))</target>
        </trans-unit>
        <trans-unit id="8ecc1bbc9be4c62ea582a64bff9ee07d59799f5d" translate="yes" xml:space="preserve">
          <source>JsonLoader, JsonStorage</source>
          <target state="translated">JsonLoader,JsonStorage</target>
        </trans-unit>
        <trans-unit id="606d2a58b14210dd67ff5015b481adddb0d11fcd" translate="yes" xml:space="preserve">
          <source>JsonStorage( )</source>
          <target state="translated">JsonStorage()</target>
        </trans-unit>
        <trans-unit id="4f52e476a57f572278206a16e11c4378156dad2a" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt; and &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming&lt;/a&gt;, Java UDF has a getLoadCaster() method that returns &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; to convert byte arrays to specific types. A UDf implementation should implement this if casts (implicit or explicit) from DataByteArray fields to other types need to be supported. Default implementation returns null and Pig will determine if all parameters passed to the UDF have identical loadcaster and use it when true.</source>
          <target state="translated">Как и &lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt; и &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming&lt;/a&gt; , Java UDF имеет метод getLoadCaster (), который возвращает &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; для преобразования байтовых массивов в определенные типы. Реализация UDf должна реализовывать это, если необходимо поддерживать приведение (неявное или явное) из полей DataByteArray к другим типам. Реализация по умолчанию возвращает null, и Pig определит, все ли параметры, переданные в UDF, имеют идентичный loadcaster, и будет использовать его, когда true.</target>
        </trans-unit>
        <trans-unit id="f3f833ff5ef88804097d26686e1b02d746ab0aef" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt; and &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming&lt;/a&gt;, Java UDF has a getLoadCaster() method that returns &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; to convert byte arrays to specific types. A UDf implementation should implement this if casts (implicit or explicit) from DataByteArray fields to other types need to be supported. Default implementation returns null and Pig will determine if all parameters passed to the UDF have identical loadcaster and use it when true.</source>
          <target state="translated">Как и &lt;a href=&quot;#load-functions&quot;&gt;функция загрузки&lt;/a&gt; и &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;потоковая передача&lt;/a&gt; , в Java UDF есть метод getLoadCaster (), который возвращает &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; для преобразования байтовых массивов в определенные типы. Реализация UDf должна реализовать это, если необходимо поддерживать приведение (неявное или явное) из полей DataByteArray в другие типы. Реализация по умолчанию возвращает значение null, и Pig определит, все ли параметры, переданные в UDF, имеют идентичный загрузчик, и будет использовать его, если оно истинно.</target>
        </trans-unit>
        <trans-unit id="b07a29909bdb4a7c9a4c7d68a06e09221fc27e7c" translate="yes" xml:space="preserve">
          <source>Just like MapReduce, if user specify &quot;parallel&quot; in their Pig statement, or user define default_parallel in Tez mode, Pig will honor it (the only exception is if user specify a parallel which is apparently too low, Pig will override it)</source>
          <target state="translated">Так же как и MapReduce,если пользователь укажет &quot;parallel&quot; в своем операторе Pig,или если пользователь определит default_parallel в режиме Tez,то Pig выполнит его (единственное исключение-если пользователь укажет параллель,которая,очевидно,слишком низкая,то Pig ее переопределит).</target>
        </trans-unit>
        <trans-unit id="362ce6c69aec6aa228025cdea51fbad41241c2ee" translate="yes" xml:space="preserve">
          <source>Kerberos is a authentication system that uses tickets with a limited validity time.</source>
          <target state="translated">Kerberos-это система аутентификации,использующая билеты с ограниченным сроком действия.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="134d1eb6aa3d758c6d2a1058ae3736bf8dd9041a" translate="yes" xml:space="preserve">
          <source>Key (see table). Case sensitive.</source>
          <target state="translated">Ключ (см.таблицу).Чувствительный к регистру.</target>
        </trans-unit>
        <trans-unit id="6cca404086c0c970a335a2fb82ffafe8356b46e5" translate="yes" xml:space="preserve">
          <source>Key value pairs are separated by the pound sign #.</source>
          <target state="translated">Пары ключевых значений разделены знаком фунта #.</target>
        </trans-unit>
        <trans-unit id="8098eb09dd0aab077b1f27f175c7ab7b69b5f496" translate="yes" xml:space="preserve">
          <source>Key values within a relation must be unique.</source>
          <target state="translated">Ключевые значения внутри отношения должны быть уникальными.</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="20f56842c9025d12cf677dcfcfc8d42101d62d87" translate="yes" xml:space="preserve">
          <source>Keyword.</source>
          <target state="translated">Keyword.</target>
        </trans-unit>
        <trans-unit id="59a29873cf3f108383cd6005d3b1061f15d203a8" translate="yes" xml:space="preserve">
          <source>Keyword. Use ALL if you want all tuples to go to a single group; for example, when doing aggregates across entire relations.</source>
          <target state="translated">Ключевое слово.Используйте ВСЕ,если Вы хотите,чтобы все кортежи переходили в одну группу;например,при выполнении агрегатов по всем отношениям.</target>
        </trans-unit>
        <trans-unit id="a7c4c244651ed2eef71562ff0f3f4ddcc23cb537" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to group the relation by field, tuple or expression.</source>
          <target state="translated">Ключевое слово.С помощью этого пункта можно сгруппировать отношение по полям,кортежам или выражениям.</target>
        </trans-unit>
        <trans-unit id="319289cdafee96fb1df0ad9cc8cefb1bd579fb6b" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to name the store function.</source>
          <target state="translated">Ключевое слово.Используйте это выражение для наименования функции магазина.</target>
        </trans-unit>
        <trans-unit id="67bd5860f834413aaa7d43179cf49527a0e0a2a6" translate="yes" xml:space="preserve">
          <source>Keywords LOAD, USING, AS, GROUP, BY, FOREACH, GENERATE, and DUMP are case insensitive. They can also be written as load, using, as, group, by, etc.</source>
          <target state="translated">Ключевые слова LOAD,USING,AS,GROUP,BY,FOREACH,GENERATE и DUMP не чувствительны к регистру.Они также могут быть записаны как загрузка,использование,как,группа,по и т.д.</target>
        </trans-unit>
        <trans-unit id="0edfbf0b2bd967f0c42ea28a41230fdd455d94f6" translate="yes" xml:space="preserve">
          <source>Kills a job.</source>
          <target state="translated">Убивает работу.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">Известные проблемы</target>
        </trans-unit>
        <trans-unit id="081687e57ce32b0d5310545712b5004fdc61e427" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF</source>
          <target state="translated">LAST_INDEX_OF</target>
        </trans-unit>
        <trans-unit id="df47fe57bbca631a9709a10608e1b138590b99bd" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF(string, 'character')</source>
          <target state="translated">LAST_INDEX_OF(string,'character')</target>
        </trans-unit>
        <trans-unit id="52e4213745bcac792482d968e621c5b7a8d439c9" translate="yes" xml:space="preserve">
          <source>LCFIRST</source>
          <target state="translated">LCFIRST</target>
        </trans-unit>
        <trans-unit id="97e019a4f6ed7512191b214c6cc6b45d3f156619" translate="yes" xml:space="preserve">
          <source>LCFIRST(expression)</source>
          <target state="translated">LCFIRST(expression)</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="4774d9fc38721cde600e4accf82d0e696ef36f65" translate="yes" xml:space="preserve">
          <source>LOAD '/mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00//&lt;strong&gt;part &lt;/strong&gt;'</source>
          <target state="translated">НАГРУЗКА &amp;laquo;/mydata/20110423ndom00,01,02,03,04,05,06,07,08,09, enj10..23 routcasts00// &lt;strong&gt;part&lt;/strong&gt; '</target>
        </trans-unit>
        <trans-unit id="9a4fc268593a3d77b3f981e8ec7b7ac700de71ad" translate="yes" xml:space="preserve">
          <source>LOAD 'data' [USING function] [AS schema];</source>
          <target state="translated">LOAD 'data' [USING function][AS schema];</target>
        </trans-unit>
        <trans-unit id="285ba2da17d87dd834eefed1cada61171d7d941f" translate="yes" xml:space="preserve">
          <source>LOAD ... USING ... AS</source>
          <target state="translated">ЛОАД...ИСПОЛЬЗОВАНИЕ ...AS</target>
        </trans-unit>
        <trans-unit id="6a8f5f55cccc7758440851683be6f04c67cd6f96" translate="yes" xml:space="preserve">
          <source>LOAD, AS - Pig keywords</source>
          <target state="translated">LOAD,AS-Ключевые слова свиней</target>
        </trans-unit>
        <trans-unit id="94b16081400651bfe270528a0e3ee7024a5f9ca3" translate="yes" xml:space="preserve">
          <source>LOG</source>
          <target state="translated">LOG</target>
        </trans-unit>
        <trans-unit id="fd8045b04b52cf7e9e6124cd894331256d12dd1a" translate="yes" xml:space="preserve">
          <source>LOG(expression)</source>
          <target state="translated">LOG(expression)</target>
        </trans-unit>
        <trans-unit id="bc31df31706dbabb2fd79fd247573138a9a82419" translate="yes" xml:space="preserve">
          <source>LOG10</source>
          <target state="translated">LOG10</target>
        </trans-unit>
        <trans-unit id="bf7398056782a2eb6fd651f94e9a8d6d8204c678" translate="yes" xml:space="preserve">
          <source>LOG10(expression)</source>
          <target state="translated">LOG10(expression)</target>
        </trans-unit>
        <trans-unit id="e2b5c793d8e006e471a5275e68adfb98fe059dc4" translate="yes" xml:space="preserve">
          <source>LOWER</source>
          <target state="translated">LOWER</target>
        </trans-unit>
        <trans-unit id="92aead129812450be477e67e7eb989a4e9f71ce9" translate="yes" xml:space="preserve">
          <source>LOWER(expression)</source>
          <target state="translated">LOWER(expression)</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="27e73e8192dd9ba4f47ae3488ff498e67ffd4019" translate="yes" xml:space="preserve">
          <source>LTRIM(expression)</source>
          <target state="translated">LTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="fc5aafa84439164f5915b1b47617fd862bbd82b2" translate="yes" xml:space="preserve">
          <source>Left outer join.</source>
          <target state="translated">Левый внешний шарнир.</target>
        </trans-unit>
        <trans-unit id="13b628b4ab8b2509575a1cd6f8cb5fda2b247abd" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement the {CollectableLoader} interface as well as {OrderedLoadFunc} interface.</source>
          <target state="translated">Крайний левый загрузчик должен реализовать интерфейс {CollectableLoader},а также интерфейс {OrderedLoadFunc}.</target>
        </trans-unit>
        <trans-unit id="73cd7b56ef42ec03731837023a47cd87b79de49f" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement {CollectableLoader} interface as well as {OrderedLoadFunc}.</source>
          <target state="translated">Крайний левый загрузчик должен реализовать интерфейс {CollectableLoader},а также {OrderedLoadFunc}.</target>
        </trans-unit>
        <trans-unit id="ca2f7f65c0903edf089f4879169677e242e0ac7f" translate="yes" xml:space="preserve">
          <source>Let's assume that we have UDF Swap that, given a tuple with two fields, swaps their order. Let's assume that the UDF does not specify a schema and look at the scripts below:</source>
          <target state="translated">Предположим,что у нас есть UDF Swap,который,учитывая кортеж с двумя полями,меняет их порядок.Предположим,что UDF не указывает схему и посмотрим на скрипты ниже:</target>
        </trans-unit>
        <trans-unit id="32d45a02984af444cda547a94ac518a5c5a58bc4" translate="yes" xml:space="preserve">
          <source>Let's now look at the implementation of the UPPER UDF.</source>
          <target state="translated">Теперь рассмотрим реализацию UPPER UDF.</target>
        </trans-unit>
        <trans-unit id="fe6299c19bf8df974b9bebf8fccacccb0c36ebbe" translate="yes" xml:space="preserve">
          <source>Let's now see how this function can be used in a Pig script:</source>
          <target state="translated">Теперь посмотрим,как эту функцию можно использовать в скрипте Pig:</target>
        </trans-unit>
        <trans-unit id="ea4e0d6736c7d827cc4e7a66876464026006c55b" translate="yes" xml:space="preserve">
          <source>Let's revisit the UPPER function from our first example. As it is written now, it would only work if the data passed to it is of type chararray. To make it work with data whose type is not explicitly set, a function table with a single entry needs to be added:</source>
          <target state="translated">Давайте вернемся к функции UPPER из нашего первого примера.Как сейчас написано,она будет работать только в том случае,если передаваемые ей данные имеют тип chararray.Чтобы она работала с данными,тип которых явно не задан,необходимо добавить таблицу функции с одной единственной записью:</target>
        </trans-unit>
        <trans-unit id="475a9652b88fed65852bd4b23c1359282ee6e175" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache Software License version 2.0.</source>
          <target state="translated">Лицензия на программное обеспечение Apache версии 2.0.</target>
        </trans-unit>
        <trans-unit id="4ae3881b2b0fb732bb6de9dde72017285f72800a" translate="yes" xml:space="preserve">
          <source>Like any other expression, null constants can be implicitly or explicitly cast.</source>
          <target state="translated">Как и любое другое выражение,нулевые константы могут быть выражены неявно или явно.</target>
        </trans-unit>
        <trans-unit id="854814e315400972c4441dad1114f75bef4e9cc4" translate="yes" xml:space="preserve">
          <source>Likewise, TrevniStorage is very closely related to AvroStorage, and shares the same options as AvroStorage. See &lt;a href=&quot;#AvroStorage&quot;&gt;AvroStorage&lt;/a&gt; for a detailed description of the arguments for TrevniStorage.</source>
          <target state="translated">Аналогично, TrevniStorage очень тесно связан с AvroStorage и имеет те же параметры, что и AvroStorage. См. &lt;a href=&quot;#AvroStorage&quot;&gt;AvroStorage&lt;/a&gt; для подробного описания аргументов для TrevniStorage.</target>
        </trans-unit>
        <trans-unit id="b87f80550d82a9e0365779f8be23adc0ee585a43" translate="yes" xml:space="preserve">
          <source>LimitOptimizer</source>
          <target state="translated">LimitOptimizer</target>
        </trans-unit>
        <trans-unit id="6195b6b19ca290cb1f0c777b8f337e23861be917" translate="yes" xml:space="preserve">
          <source>Limited support is provided for Jython, Python, JavaScript, Ruby and Groovy functions. These functions are new, still evolving, additions to the system. Currently only the basic interface is supported; load/store functions are not supported. Furthermore, JavaScript, Ruby and Groovy are provided as experimental features because they did not go through the same amount of testing as Java or Jython. At runtime note that Pig will automatically detect the usage of a scripting UDF in the Pig script and will automatically ship the corresponding scripting jar, either Jython, Rhino, JRuby or Groovy-all, to the backend. Python does not require any runtime engine since it invoke python command line and stream data in and out of it.</source>
          <target state="translated">Ограничена поддержка функций Jython,Python,JavaScript,Ruby и Groovy.Эти функции являются новыми,все еще развивающимися,дополнениями к системе.В настоящее время поддерживается только базовый интерфейс;функции загрузки/хранения не поддерживаются.Кроме того,JavaScript,Ruby и Groovy предоставляются в качестве экспериментальных функций,так как они не прошли такого же количества тестирования,как Java или Jython.Во время выполнения обратите внимание,что Pig автоматически обнаружит использование скриптового UDF в скрипте Pig и автоматически отправит соответствующую банку скриптов,либо Jython,Rhino,JRuby или Groovy-all,в бэкэнд.Python не требует никакого исполнительного движка,так как он вызывает командную строку python и передаёт данные внутрь и наружу.</target>
        </trans-unit>
        <trans-unit id="7515906f2285af7d60e86a7d43455b7a249592bf" translate="yes" xml:space="preserve">
          <source>Limits the number of output tuples.</source>
          <target state="translated">Ограничивает количество выходных кортежей.</target>
        </trans-unit>
        <trans-unit id="956e1330b61723ff186fcbcfd265adba91e6af54" translate="yes" xml:space="preserve">
          <source>Line 1 indicates that the function is part of the myudfs package. The UDF class extends the EvalFunc class which is the base class for all eval functions. It is parameterized with the return type of the UDF which is a Java String in this case. We will look into the EvalFunc class in more detail later, but for now all we need to do is to implement the exec function. This function is invoked on every input tuple. The input into the function is a tuple with input parameters in the order they are passed to the function in the Pig script. In our example, it will contain a single string field corresponding to the student name.</source>
          <target state="translated">В первой строке указано,что функция является частью пакета myudfs.Класс UDF расширяет класс EvalFunc,который является базовым классом для всех eval-функций.Он параметризован типом возврата UDF,который в данном случае является Java-строкой.Подробнее о классе EvalFunc мы поговорим позже,но пока нам остаётся только реализовать функцию execution.Эта функция вызывается на каждом входном кортеже.Входом в функцию является кортеж с входными параметрами в порядке их передачи в функцию в сценарии Pig.В нашем примере она будет содержать одно строковое поле,соответствующее имени ученика.</target>
        </trans-unit>
        <trans-unit id="5caa6119e5a5784410641134836063fbda7a2642" translate="yes" xml:space="preserve">
          <source>List Pig properties.</source>
          <target state="translated">Список свойств свиней.</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="f021aa6572ced84b6338a8aa2d7c6ec393f0e8e9" translate="yes" xml:space="preserve">
          <source>Load Example</source>
          <target state="translated">Пример загрузки</target>
        </trans-unit>
        <trans-unit id="1c6f5e374c495440813dfb8c43762f92a485801a" translate="yes" xml:space="preserve">
          <source>Load Examples</source>
          <target state="translated">Загрузить примеры</target>
        </trans-unit>
        <trans-unit id="153ed64057be54f8d2533568f5517a405ba5a31f" translate="yes" xml:space="preserve">
          <source>Load Functions</source>
          <target state="translated">Функции загрузки</target>
        </trans-unit>
        <trans-unit id="c84877c34cdbb71bdceab39a857b49dc7dd074db" translate="yes" xml:space="preserve">
          <source>Load or store JSON data.</source>
          <target state="translated">Загрузить или сохранить данные JSON.</target>
        </trans-unit>
        <trans-unit id="b8a5a6a4984d874b5d5fc5f56453ae2255a611d3" translate="yes" xml:space="preserve">
          <source>Load statements &amp;ndash; PigStorage expects data to be formatted using field delimiters, either the tab character ('\t') or other specified character.</source>
          <target state="translated">Операторы загрузки - PigStorage ожидает, что данные будут отформатированы с использованием разделителей полей, либо символа табуляции ('\ t'), либо другого указанного символа.</target>
        </trans-unit>
        <trans-unit id="8394a86595651bd6aa48839d4b9509225529fe8b" translate="yes" xml:space="preserve">
          <source>Load/Store Functions</source>
          <target state="translated">Функции загрузки/хранения</target>
        </trans-unit>
        <trans-unit id="1ff3612ad5b787d3be631d6699ef0010173126d2" translate="yes" xml:space="preserve">
          <source>Load/store functions determine how data goes into Pig and comes out of Pig. Pig provides a set of built-in load/store functions, described in the sections below. You can also write your own load/store functions (see &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt;).</source>
          <target state="translated">Функции загрузки / сохранения определяют, как данные поступают в Pig и выходят из Pig. Pig предоставляет набор встроенных функций загрузки / хранения, описанных в следующих разделах. Вы также можете написать свои собственные функции загрузки / сохранения (см. &lt;a href=&quot;udf&quot;&gt;Пользовательские функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c431ce3cc6de545c006a5dc4f55812d9901c37ac" translate="yes" xml:space="preserve">
          <source>Loader side:</source>
          <target state="translated">Со стороны погрузчика:</target>
        </trans-unit>
        <trans-unit id="292c202d7f33de20bb18cb9b0cd78363326e07b9" translate="yes" xml:space="preserve">
          <source>Loader will be instructed to loader the partition with dt=='201310' and state=='CA'</source>
          <target state="translated">Загрузчику будет дано указание загрузить раздел с dt=='201310' и состоянием=='CA''.</target>
        </trans-unit>
        <trans-unit id="1bbec1f2925e33de29cc103440eaad38ddc86d8c" translate="yes" xml:space="preserve">
          <source>Loading Data</source>
          <target state="translated">Загрузка данных</target>
        </trans-unit>
        <trans-unit id="c2683406031d7a18de1fd67e1e11494ce9bebe57" translate="yes" xml:space="preserve">
          <source>Loads and stores data as structured text files.</source>
          <target state="translated">Загружает и сохраняет данные в виде структурированных текстовых файлов.</target>
        </trans-unit>
        <trans-unit id="c5ab9df0752359ce2a9010c5aca5c7b13218b8ac" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Avro files.</source>
          <target state="translated">Загружает и сохраняет данные из файлов Avro.</target>
        </trans-unit>
        <trans-unit id="fd223bb0ff10c21f09b831e58eea8a6f58904d01" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Trevni files.</source>
          <target state="translated">Загружает и хранит данные из файлов Trevni.</target>
        </trans-unit>
        <trans-unit id="80db5f3f39fbbc84dd2b14e51899dff294e39ece" translate="yes" xml:space="preserve">
          <source>Loads and stores data from an HBase table.</source>
          <target state="translated">Загружает и сохраняет данные из таблицы HBase.</target>
        </trans-unit>
        <trans-unit id="d72f04a406a7e49e13a302e150306baf032923ec" translate="yes" xml:space="preserve">
          <source>Loads and stores data in machine-readable format.</source>
          <target state="translated">Загружает и сохраняет данные в машиночитаемом формате.</target>
        </trans-unit>
        <trans-unit id="7c132ef27274638f19bb72b1001c8a9395135f95" translate="yes" xml:space="preserve">
          <source>Loads data from the file system.</source>
          <target state="translated">Загружает данные из файловой системы.</target>
        </trans-unit>
        <trans-unit id="eea9cefa9b896289e9167b60ed8b404fccfd5b53" translate="yes" xml:space="preserve">
          <source>Loads from or stores data to Orc file.</source>
          <target state="translated">Загружает из или сохраняет данные в файл Orc.</target>
        </trans-unit>
        <trans-unit id="18e8e0842b1999e676731438c4dea4a56f79cd4c" translate="yes" xml:space="preserve">
          <source>Loads or stores data from an Accumulo table. The first element in a Tuple is equivalent to the &quot;row&quot; from the Accumulo Key, while the columns in that row are can be grouped in various static or wildcarded ways. Basic wildcarding functionality exists to group various columns families/qualifiers into a Map for LOADs, or serialize a Map into some group of column families or qualifiers on STOREs.</source>
          <target state="translated">Загружает или сохраняет данные из таблицы Accumulo.Первый элемент кортежа эквивалентен &quot;строке&quot; из ключа Accumulo,в то время как столбцы в этой строке могут быть сгруппированы различными статическими или подстановочными знаками.Базовая функциональность подстановочных знаков существует для группировки различных семейств/квалификаторов столбцов в карте для LOAD,или сериализации карты в какую-либо группу семейств столбцов или классификаторов на STORE.</target>
        </trans-unit>
        <trans-unit id="740ccec530db15440e48181713136ee050ab7097" translate="yes" xml:space="preserve">
          <source>Loads unstructured data in UTF-8 format.</source>
          <target state="translated">Загружает неструктурированные данные в формате UTF-8.</target>
        </trans-unit>
        <trans-unit id="b3b24cc821e27fff117200af94d65c12872874b1" translate="yes" xml:space="preserve">
          <source>Local Mode</source>
          <target state="translated">Местный режим</target>
        </trans-unit>
        <trans-unit id="ea7076530ceab2e77fb3cb520efd850a7ddef48b" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (local mode)</source>
          <target state="translated">Файл журнала,поисковая система Excite (локальный режим)</target>
        </trans-unit>
        <trans-unit id="863629ee92f0cce989f168afc709eb06192b10b7" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (mapreduce)</source>
          <target state="translated">Лог-файл,поисковая система Excite (mapreduce)</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="0178a9a96c884d695567e06fe46d3aa4cbf9b156" translate="yes" xml:space="preserve">
          <source>Long lived jobs</source>
          <target state="translated">Долгосрочная работа</target>
        </trans-unit>
        <trans-unit id="c95e7e6f6a263bc67561c7fc8ceb0607d15d1cba" translate="yes" xml:space="preserve">
          <source>Long: long</source>
          <target state="translated">Долго:долго</target>
        </trans-unit>
        <trans-unit id="3316c8ddabfaccc1e70bfecfd5b7747a06043e4b" translate="yes" xml:space="preserve">
          <source>Longs</source>
          <target state="translated">Longs</target>
        </trans-unit>
        <trans-unit id="7b186e235f284107df6b4dbe6060d2b6a5d9f1e5" translate="yes" xml:space="preserve">
          <source>MAX</source>
          <target state="translated">MAX</target>
        </trans-unit>
        <trans-unit id="3ada24ec29991deafbe9dbcbe2155e2e6ee05875" translate="yes" xml:space="preserve">
          <source>MAX(expression)</source>
          <target state="translated">MAX(expression)</target>
        </trans-unit>
        <trans-unit id="04e66352aa8f9c4c5f26b71bf380973ada994760" translate="yes" xml:space="preserve">
          <source>MIN</source>
          <target state="translated">MIN</target>
        </trans-unit>
        <trans-unit id="9f16fb3a367f47ced429f9a96ee8af3d40dcccdd" translate="yes" xml:space="preserve">
          <source>MIN(expression)</source>
          <target state="translated">MIN(expression)</target>
        </trans-unit>
        <trans-unit id="4a83930aeba65503717c88ca93580a0d643e3c2d" translate="yes" xml:space="preserve">
          <source>Macro expansion is not a complete replacement for function calls. Recursive expansions are not supported.</source>
          <target state="translated">Расширение макросов не является полной заменой для вызовов функций.Рекурсивные расширения не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="90103d0b5c28db7922249a3fa2ea7bfff2ba0064" translate="yes" xml:space="preserve">
          <source>Macro names are global and all macros share the same name space. While the file can contain more than one macro definition, having two macros with the same name in your execution context will result in an error.</source>
          <target state="translated">Названия макросов являются глобальными,и все макросы имеют одно и то же пространство имён.Хотя файл может содержать более одного определения макроса,наличие двух макросов с одним и тем же именем в контексте исполнения приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="a950d781ec76e0d5d8f9a49df1d80136a24daf6d" translate="yes" xml:space="preserve">
          <source>Macros are NOT alllowed inside a nested block.</source>
          <target state="translated">Макросы НЕ помещаются внутри вложенного блока.</target>
        </trans-unit>
        <trans-unit id="e0fe92ab842bd9468af7fe40e3c0e996ece09d87" translate="yes" xml:space="preserve">
          <source>Macros are not allowed inside a &lt;a href=&quot;basic#nested-block&quot;&gt;FOREACH&lt;/a&gt; nested block.</source>
          <target state="translated">Макросы не допускаются внутри вложенного блока &lt;a href=&quot;basic#nested-block&quot;&gt;FOREACH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec793f1eac030adf34d2e41a8195b5aa6af3faa2" translate="yes" xml:space="preserve">
          <source>Macros can only contain Pig Latin statements; Grunt shell commands are not supported. REGISTER statements and parameter definitions with %default or %declare are both valid however. Your macro file also IMPORT other macro files, so long as these imports are not recursive.</source>
          <target state="translated">Макросы могут содержать только операторы Pig Latin;команды оболочки Grunt не поддерживаются.Тем не менее,оба оператора REGISTER и определения параметров с %default или %declare являются действительными.Ваш файл с макросами также ВНИМАНИЕ других макрофайлов,при условии,что эти импорты не являются рекурсивными.</target>
        </trans-unit>
        <trans-unit id="8f5d729039ce92b99bf31323c027bd3e1999e4d3" translate="yes" xml:space="preserve">
          <source>Macros cannot contain &lt;a href=&quot;cmds#shell-cmds&quot;&gt;Grunt shell commands&lt;/a&gt;.</source>
          <target state="translated">Макросы не могут содержать &lt;a href=&quot;cmds#shell-cmds&quot;&gt;команды оболочки Grunt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4798c01e02a87a25ab288415fe8315792ab65a" translate="yes" xml:space="preserve">
          <source>Macros cannot include a user-defined schema that has a name collision with an alias in the macro.</source>
          <target state="translated">Макросы не могут включать пользовательскую схему,которая имеет столкновение имени с псевдонимом в макросе.</target>
        </trans-unit>
        <trans-unit id="b90c9bc525fef91c7051e223d84db955ed26d8b6" translate="yes" xml:space="preserve">
          <source>Make Your UDFs Algebraic</source>
          <target state="translated">Сделайте ваши UDFs алгебраической</target>
        </trans-unit>
        <trans-unit id="0c76e7b16941afa21f1bc061662c5afc67e30d7d" translate="yes" xml:space="preserve">
          <source>Make sure that for each function, you add a corresponding test class in the test part of the tree.</source>
          <target state="translated">Убедитесь,что для каждой функции в тестовую часть дерева добавлен соответствующий тестовый класс.</target>
        </trans-unit>
        <trans-unit id="89075a765b1a0bbdfb1037d1e343f2d19beb8ffd" translate="yes" xml:space="preserve">
          <source>Make sure that your code follows Pig coding conventions described in &lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;How to Contribute to Pig&lt;/a&gt;.</source>
          <target state="translated">Убедитесь, что ваш код соответствует правилам кодирования Pig, описанным в &lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;разделе Как внести вклад в Pig&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1453bf305e9c5ecb3fb272c5a0f810f865052a67" translate="yes" xml:space="preserve">
          <source>Make sure that your function is well documented and uses the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; style of documentation.</source>
          <target state="translated">Убедитесь, что ваша функция хорошо документирована и использует стиль документации &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fa6c86cb9399aa3a0540995df395572f4b9530e" translate="yes" xml:space="preserve">
          <source>Make sure that your function is well documented and uses the &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; style of documentation.</source>
          <target state="translated">Убедитесь, что ваша функция хорошо документирована и использует стиль документации &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02bf56b1b68374b208d34a48eae88f93b5114cb8" translate="yes" xml:space="preserve">
          <source>Make sure the JAVA_HOME environment variable is set the root of your Java installation.</source>
          <target state="translated">Убедитесь,что переменная окружения JAVA_HOME установлена в качестве корня вашей установки Java.</target>
        </trans-unit>
        <trans-unit id="f0a14e7b46d7b053eeee4d905350e82494b9e784" translate="yes" xml:space="preserve">
          <source>Make sure your PATH includes bin/pig (this enables you to run the tutorials using the &quot;pig&quot; command).</source>
          <target state="translated">Убедитесь,что ваш PATH включает bin/pig (это позволяет вам запускать учебники с помощью команды &quot;свинья&quot;).</target>
        </trans-unit>
        <trans-unit id="8f2f922bc9ecd3f2a3cdc0e7b3ae6ed62fb20721" translate="yes" xml:space="preserve">
          <source>Makes the split non-blocking and allows processing to continue. This helps reduce the amount of data that has to be stored right at the split.</source>
          <target state="translated">Делает разделение неблокирующим и позволяет продолжить обработку.Это помогает уменьшить объем данных,которые должны храниться прямо на сплите.</target>
        </trans-unit>
        <trans-unit id="209567b32f8fea5e9ef198fb3941b8730fad033c" translate="yes" xml:space="preserve">
          <source>Many PigUnit examples are available in the &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;PigUnit tests&lt;/a&gt;.</source>
          <target state="translated">Многие примеры PigUnit доступны в &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;тестах PigUnit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="118c725ac270a315a161cdd1a2c7988e8672f297" translate="yes" xml:space="preserve">
          <source>Many PigUnit examples are available in the &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;PigUnit tests&lt;/a&gt;.</source>
          <target state="translated">Многие примеры PigUnit доступны в &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;тестах PigUnit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="dae74f13b986a147221f41b0053b991ea203fea3" translate="yes" xml:space="preserve">
          <source>Map Schemas</source>
          <target state="translated">Карта Схемы</target>
        </trans-unit>
        <trans-unit id="8af46e94e502b7aa7a2f1aa05b12cb0c07e01870" translate="yes" xml:space="preserve">
          <source>Map dereferencing must be done by key (field_name#key or $0#key). If the pound operator is applied to a bytearray, the bytearray is assumed to be a map. If the key does not exist, the empty string is returned.</source>
          <target state="translated">Разыменование карты должно быть выполнено по ключу (field_name#key или $0#key).Если к байтеру применяется оператор pound,то байтером считается карта.Если клавиша не существует,возвращается пустая строка.</target>
        </trans-unit>
        <trans-unit id="172c8b9363030fc7be69a2798cd806007e34c86e" translate="yes" xml:space="preserve">
          <source>Map&amp;lt;Object, Object&amp;gt;</source>
          <target state="translated">Карта &amp;lt;Объект, Объект&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5a376ab0b0389e27d40fa426227bc396c3d2e452" translate="yes" xml:space="preserve">
          <source>Map: java.util.Map</source>
          <target state="translated">Карта:java.util.карта</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="1a50f5954df4dfe8722ed6d174a9520e089c8ce6" translate="yes" xml:space="preserve">
          <source>Maps are enclosed in straight brackets [ ].</source>
          <target state="translated">Карты заключены в прямые скобки[].</target>
        </trans-unit>
        <trans-unit id="1756bec08ab2e5a4f6f3ea1577c5665ca0e8a418" translate="yes" xml:space="preserve">
          <source>Math Functions</source>
          <target state="translated">Математические функции</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">Управление памятью</target>
        </trans-unit>
        <trans-unit id="ffc4d0fd84372762976635002c427e810e8329a6" translate="yes" xml:space="preserve">
          <source>Merge Joins</source>
          <target state="translated">Соединять Соединения</target>
        </trans-unit>
        <trans-unit id="627dc8ff0cef660b000fb836bad32ded77d9db38" translate="yes" xml:space="preserve">
          <source>Merge filter conditions after PushUpFilter rule to decrease the number of filter statements.</source>
          <target state="translated">Объединить условия фильтра после правила PushUpFilter,чтобы уменьшить количество операторов фильтра.</target>
        </trans-unit>
        <trans-unit id="51c7b431837f24885f18db611764cb39830ff71e" translate="yes" xml:space="preserve">
          <source>Merge-Sparse Joins</source>
          <target state="translated">Слияние-разделение Соединения</target>
        </trans-unit>
        <trans-unit id="8fea2fed8c16c2288bb31ada275a77e267a6ab5c" translate="yes" xml:space="preserve">
          <source>Merge-Sparse join is a specialization of merge join. Merge-sparse join is intended for use when one of the tables is very sparse, meaning you expect only a small number of records to be matched during the join. In tests this join performed well for cases where less than 1% of the data was matched in the join.</source>
          <target state="translated">Merge-Sparse join-это специализация merge-Sparse join.Слияние-разрывное соединение предназначено для использования,когда одна из таблиц очень разрежена,т.е.вы ожидаете,что во время соединения будет сопоставлено только небольшое количество записей.В тестах этот join хорошо себя зарекомендовал для случаев,когда в join совпадало менее 1% данных.</target>
        </trans-unit>
        <trans-unit id="a4bdcc67e1fd583bc328f53c3b10ec1e75cec47e" translate="yes" xml:space="preserve">
          <source>Merge-sparse join only works for inner joins and is not currently implemented for outer joins.</source>
          <target state="translated">Сплошное соединение работает только для внутренних соединений и в настоящее время не реализуется для внешних соединений.</target>
        </trans-unit>
        <trans-unit id="c8fae7f7316c44f46454df38407830d960deca78" translate="yes" xml:space="preserve">
          <source>MergeFilter</source>
          <target state="translated">MergeFilter</target>
        </trans-unit>
        <trans-unit id="23a02331f579c7154e40a84a1946289d36647520" translate="yes" xml:space="preserve">
          <source>MergeForEach</source>
          <target state="translated">MergeForEach</target>
        </trans-unit>
        <trans-unit id="6b121c3e89581e5ceab18466104db8aab4915066" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween</source>
          <target state="translated">MilliSecondsBetween</target>
        </trans-unit>
        <trans-unit id="e71ec4d9c2fb04eac5ce8aa7ddfc94b4e537dc73" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween(datetime1, datetime2)</source>
          <target state="translated">МиллисекундыПромежуток (дата1,дата2)</target>
        </trans-unit>
        <trans-unit id="6295a9ae493dccb2f773f064edfa765b839ab428" translate="yes" xml:space="preserve">
          <source>MiniCluster generates one in build/classes.</source>
          <target state="translated">MiniCluster генерирует один в сборе/классах.</target>
        </trans-unit>
        <trans-unit id="13b68c92e094101ca904236df27e6d286dfc4604" translate="yes" xml:space="preserve">
          <source>MinutesBetween</source>
          <target state="translated">MinutesBetween</target>
        </trans-unit>
        <trans-unit id="121265c9da1c27a9e91b296b9a032f9dc043e2cf" translate="yes" xml:space="preserve">
          <source>MinutesBetween(datetime1, datetime2)</source>
          <target state="translated">МинутыПромежуток(дата1,дата2)</target>
        </trans-unit>
        <trans-unit id="5af6b4c2a5b65cc8ab62dc972a6b79fd159c1004" translate="yes" xml:space="preserve">
          <source>MissingFormatArgumentException: Format specifier '%-8s'</source>
          <target state="translated">Пропущенный форматАргометрЭкзцепция:Спецификатор формата '%-8s'</target>
        </trans-unit>
        <trans-unit id="99a3402325144d291bec7ddf15b2b92ddc5bc907" translate="yes" xml:space="preserve">
          <source>Mocking</source>
          <target state="translated">Mocking</target>
        </trans-unit>
        <trans-unit id="98c1556eb14f903ff0cc6da7fce11300097e4f71" translate="yes" xml:space="preserve">
          <source>Monitoring Long-Running UDFs</source>
          <target state="translated">Мониторинг ОДС,работающие на протяжении длительного времени</target>
        </trans-unit>
        <trans-unit id="f4e4587a8e5bc89978b95fd14712b5c637d334c7" translate="yes" xml:space="preserve">
          <source>MonthsBetween</source>
          <target state="translated">MonthsBetween</target>
        </trans-unit>
        <trans-unit id="c2497de4c3a7f46f52e471bf016580c8b05abe79" translate="yes" xml:space="preserve">
          <source>MonthsBetween(datetime1, datetime2)</source>
          <target state="translated">МесяцыПромежуток(дата1,дата2)</target>
        </trans-unit>
        <trans-unit id="5d01423227f4b2cd4ded59e2cdbfb0057686b879" translate="yes" xml:space="preserve">
          <source>Most Orc data type has one to one mapping to Pig data type. Several exceptions are:</source>
          <target state="translated">Большинство типов данных орков имеют от одного до одного отображения к типу данных свиней.Есть несколько исключений:</target>
        </trans-unit>
        <trans-unit id="cdfa5243b3d54966023e586cfec06cfd9d7a42dd" translate="yes" xml:space="preserve">
          <source>Most existing Pig scripts will produce the same result with or without the multi-query execution. There are cases though where this is not true. Path names and schemes are discussed here.</source>
          <target state="translated">Большинство существующих скриптов Pig будут давать один и тот же результат с выполнением нескольких запросов или без него.Однако бывают случаи,когда это не так.Здесь обсуждаются имена путей и схем.</target>
        </trans-unit>
        <trans-unit id="b10b3ed627fb4772162ce992b3ea0544246f7c8b" translate="yes" xml:space="preserve">
          <source>Most of the time, single-tuple processing within a UDF is very short and does not require a UDF to heartbeat. The same is true for aggregate functions that operate on large bags because bag iteration code takes care of it. However, if you have a function that performs a complex computation that can take an order of minutes to execute, you should add a progress indicator to your code. This is very easy to accomplish. The EvalFunc class provides a progress function that you need to call in your exec method.</source>
          <target state="translated">В большинстве случаев,обработка одного файла в ОДС является очень короткой и не требует UDF для сердцебиения.То же самое относится и к агрегатным функциям,которые работают на больших мешках,потому что код итерации мешков заботится об этом.Однако,если у вас есть функция,выполняющая сложные вычисления,на выполнение которой может потребоваться порядка нескольких минут,вы должны добавить в свой код индикатор выполнения.Это очень легко сделать.Класс EvalFunc предоставляет функцию прогресса,которую необходимо вызвать в своем методе выполнения.</target>
        </trans-unit>
        <trans-unit id="e6ca4666a38ad0441b66ffd38051824a3e1f9b9e" translate="yes" xml:space="preserve">
          <source>Most times, it is not necessary, nor desired for performance reasons, to fetch all columns.</source>
          <target state="translated">В большинстве случаев,не обязательно,и не желательно по соображениям производительности,брать все колонки.</target>
        </trans-unit>
        <trans-unit id="12fdb217bf25b1d89a39ced7476e27e33bf049f6" translate="yes" xml:space="preserve">
          <source>Move to the Pig tutorial directory (.../pig-0.17.0/tutorial).</source>
          <target state="translated">Перейдите в каталог учебного пособия Pig (.../pig-0.17.0/tutorial).</target>
        </trans-unit>
        <trans-unit id="31c02a320c089f6597a14f81e99bbbb176a8d14f" translate="yes" xml:space="preserve">
          <source>Move to the pigtmp directory.</source>
          <target state="translated">Перейдите в каталог pigtmp.</target>
        </trans-unit>
        <trans-unit id="6ac8dd3fbae422b42dfb2b029fcf9ffa579e90ba" translate="yes" xml:space="preserve">
          <source>Multi-Query Execution</source>
          <target state="translated">Multi-Query Исполнение</target>
        </trans-unit>
        <trans-unit id="01b85aabcb3b39447e1aab1a2ca45fed5b213163" translate="yes" xml:space="preserve">
          <source>Multi-query execution introduces some changes:</source>
          <target state="translated">Выполнение нескольких запросов вносит некоторые изменения:</target>
        </trans-unit>
        <trans-unit id="be0c81ed15124e2c9f58dac0249e297166b9f212" translate="yes" xml:space="preserve">
          <source>Multi-query execution is turned on by default. To turn it off and revert to Pig's &quot;execute-on-dump/store&quot; behavior, use the &quot;-M&quot; or &quot;-no_multiquery&quot; options.</source>
          <target state="translated">Выполнение нескольких запросов включено по умолчанию.Чтобы выключить его и вернуться к поведению Pig &quot;execute-on-dump/store&quot;,используйте опции &quot;-M&quot; или &quot;-no_multiquery&quot;.</target>
        </trans-unit>
        <trans-unit id="df511d0b9ccb7e1d2a7d7c5c3de6213920d670e9" translate="yes" xml:space="preserve">
          <source>Multiple fields are enclosed in parentheses and separated by commas.</source>
          <target state="translated">Несколько полей заключены в круглые скобки и разделены запятыми.</target>
        </trans-unit>
        <trans-unit id="49c92016401e9e368896026aade96455b23a26cb" translate="yes" xml:space="preserve">
          <source>Multiple files can be specified. If the same parameter is present multiple times in the file, the last value will be used and a warning will be generated. If a parameter present in multiple files, the value from the last file will be used and a warning will be generated.</source>
          <target state="translated">Можно указать несколько файлов.Если один и тот же параметр присутствует в файле несколько раз,то будет использовано последнее значение и будет выдано предупреждение.Если один и тот же параметр присутствует в нескольких файлах,то будет использовано значение из последнего файла и выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="78de899b1c722999a754115b391c3f6d8afcc630" translate="yes" xml:space="preserve">
          <source>Multiple items:</source>
          <target state="translated">Несколько пунктов:</target>
        </trans-unit>
        <trans-unit id="4fd56e73c50d1cf9df45651cb8969f782fc4bd9d" translate="yes" xml:space="preserve">
          <source>Multiple parameters can be specified. If the same parameter is specified multiple times, the last value will be used and a warning will be generated.</source>
          <target state="translated">Можно указать несколько параметров.Если один и тот же параметр будет указан несколько раз,то будет использовано последнее значение и будет выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="a7224113267e40a9f1083035389fd70d294aaf25" translate="yes" xml:space="preserve">
          <source>Multiple register commands can be used in the same script. If the same fully-qualified function is present in multiple jars, the first occurrence will be used consistently with Java semantics.</source>
          <target state="translated">В одном и том же скрипте можно использовать несколько команд регистра.Если одна и та же полностью квалифицированная функция присутствует в нескольких баночках,то первое вхождение будет использоваться последовательно с семантикой Java.</target>
        </trans-unit>
        <trans-unit id="3e91b337a11e8be469e11fd079a265758b7d0f67" translate="yes" xml:space="preserve">
          <source>Must be chararray data type. Must be a unique value.</source>
          <target state="translated">Должно быть,это тип данных в виде диаграмм.Должно быть уникальное значение.</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="dbda54bf8f5b0c2cab6b61e46d69af778895241e" translate="yes" xml:space="preserve">
          <source>NATIVE</source>
          <target state="translated">NATIVE</target>
        </trans-unit>
        <trans-unit id="8e7f35442a0cbdf6e52522bf252417e0672f3cf5" translate="yes" xml:space="preserve">
          <source>NGramGenerator</source>
          <target state="translated">NGramGenerator</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="434fe5f55d2da77a8c38d9d086d184382c0431af" translate="yes" xml:space="preserve">
          <source>Names are assigned by you using schemas (or, in the case of the GROUP operator and some functions, by the system). You can use any name that is not a Pig keyword (see &lt;a href=&quot;#identifiers&quot;&gt;Identifiers&lt;/a&gt; for valid name examples).</source>
          <target state="translated">Имена присваиваются вами с использованием схем (или, в случае оператора GROUP и некоторых функций, системой). Вы можете использовать любое имя, которое не является ключевым словом Pig ( действительные примеры имен см. В разделе &amp;laquo; &lt;a href=&quot;#identifiers&quot;&gt;Идентификаторы&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1cd1435493b07624397f0caecc9c127f1237605" translate="yes" xml:space="preserve">
          <source>Nested FOREACH...GENERATE block used with a inner bag. Use this syntax:</source>
          <target state="translated">Вложенный блок FOREACH...GENERATE,используемый с внутренним мешком.Используйте этот синтаксис:</target>
        </trans-unit>
        <trans-unit id="856b986d3b3538c9f63c14a8bfa923da457a6cbf" translate="yes" xml:space="preserve">
          <source>No gap in the ranking values.</source>
          <target state="translated">Никаких разрывов в рейтинговых значениях.</target>
        </trans-unit>
        <trans-unit id="8afea8785f2d471644a7e2ce83ccf7eaafc476b5" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the LOAD and COGROUP statements.</source>
          <target state="translated">Никакие другие операции не могут быть выполнены между LOAD и COGROUP заявлениями.</target>
        </trans-unit>
        <trans-unit id="6cacbef0c08a2a634815e58b66c00fed7c2c41d6" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the load and join statements.</source>
          <target state="translated">Никакие другие операции не могут быть выполнены в промежутке между нагрузкой и заявлениями о присоединении.</target>
        </trans-unit>
        <trans-unit id="37c34486a47e980837dfed80ad60c633165578bc" translate="yes" xml:space="preserve">
          <source>No terms.</source>
          <target state="translated">Никаких условий.</target>
        </trans-unit>
        <trans-unit id="4f05f854bcf667613eb1bcf644bf89bea7c04c22" translate="yes" xml:space="preserve">
          <source>Non-empty bag: {code}{(tuple1),(tuple2),(tuple3)}{code}</source>
          <target state="translated">Непустая сумка:{код}{(tuple1),(tuple2),(tuple3)}{код}</target>
        </trans-unit>
        <trans-unit id="a9028fbba3faab3bb8d6374d3d3b12e55ec4d07e" translate="yes" xml:space="preserve">
          <source>Non-empty map: [key1#value1,key2#value2]</source>
          <target state="translated">Непустая карта:[key1#value1,key2#value2]</target>
        </trans-unit>
        <trans-unit id="454c82816301c007849136a6a6afd39e636c7a7d" translate="yes" xml:space="preserve">
          <source>Non-empty tuple: (item1,item2,item3)</source>
          <target state="translated">Непустой кортеж:(пункт 1,пункт 2,пункт 3)</target>
        </trans-unit>
        <trans-unit id="8bb35935b1c067f8f5b9269c75f07f122dc91e0b" translate="yes" xml:space="preserve">
          <source>NonURLDetector</source>
          <target state="translated">NonURLDetector</target>
        </trans-unit>
        <trans-unit id="f3a561a666d179ca85f5eca5281a4cc29dc561d4" translate="yes" xml:space="preserve">
          <source>Not applicable.</source>
          <target state="translated">Не применимо.</target>
        </trans-unit>
        <trans-unit id="3097e34dbf20e18d2f69780a551e61726fd84f2e" translate="yes" xml:space="preserve">
          <source>Not only inside outputSchema at compile time, input schema is also accessible in exec at runtime. For example:</source>
          <target state="translated">Не только внутри outputSchema во время компиляции,входная схема также доступна во время выполнения.Например:</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fe6878280c596a2dd5322865b0537fe6209c86bf" translate="yes" xml:space="preserve">
          <source>Note 1: boolean (Tuple A is equal to tuple B if they have the same size s, and for all 0 &amp;lt;= i &amp;lt; s A[i] == B[i])</source>
          <target state="translated">Примечание 1: логическое значение (кортеж A равен кортежу B, если они имеют одинаковый размер s, и для всех 0 &amp;lt;= i &amp;lt;s A [i] == B [i])</target>
        </trans-unit>
        <trans-unit id="e7ce1a756a8dac8acf02cf7ce21512a25d378b81" translate="yes" xml:space="preserve">
          <source>Note 2: boolean (Map A is equal to map B if A and B have the same number of entries, and for every key k1 in A with a value of v1, there is a key k2 in B with a value of v2, such that k1 == k2 and v1 == v2)</source>
          <target state="translated">Замечание 2:булева (Карта A равна карте B,если A и B имеют одинаковое количество записей,а для каждого ключа k1 в A со значением v1 есть ключ k2 в B со значением v2,так что k1 ==k2 и v1 ==v2)</target>
        </trans-unit>
        <trans-unit id="7b6c6d89bc2c99329a0bff371ae22ebd24929b95" translate="yes" xml:space="preserve">
          <source>Note that a DUMP or STORE statement is required to generate output.</source>
          <target state="translated">Обратите внимание,что для генерации вывода требуется оператор DUMP или STORE.</target>
        </trans-unit>
        <trans-unit id="7830de9d278f278b280af353b2b1e821813572b3" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Java UDF may be embedded in Python, JavaScript, Groovy, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что языки хоста и языки UDF (включенные как часть встроенной Pig) полностью ортогональны. Например, оператор Pig Latin, который регистрирует Java UDF, может быть встроен в Python, JavaScript, Groovy или Java. Исключением из этого правила являются &amp;laquo;комбинированные&amp;raquo; сценарии - здесь должны совпадать языки (см. Раздел &amp;laquo; &lt;a href=&quot;udf#jython-advanced&quot;&gt;Дополнительные разделы для Python&amp;raquo;&lt;/a&gt; , &amp;laquo; &lt;a href=&quot;udf#js-advanced&quot;&gt;Дополнительные разделы для JavaScript&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Дополнительные разделы для Groovy&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ced2283529be7070b1816e7bc88ea7c4ff8a20e9" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Python UDF may be embedded in Python, JavaScript, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что языки хоста и языки UDF (включенные как часть встроенной Pig) полностью ортогональны. Например, оператор Pig Latin, который регистрирует UDF Python, может быть встроен в Python, JavaScript или Java. Исключением из этого правила являются &amp;laquo;комбинированные&amp;raquo; сценарии - здесь должны совпадать языки (см. Раздел &amp;laquo; &lt;a href=&quot;udf#jython-advanced&quot;&gt;Дополнительные разделы для Python&amp;raquo;&lt;/a&gt; , &amp;laquo; &lt;a href=&quot;udf#js-advanced&quot;&gt;Дополнительные разделы для JavaScript&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Дополнительные разделы для Groovy&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a92b6e8e114c8750692dc7d3c9a3cb2162bb5174" translate="yes" xml:space="preserve">
          <source>Note that only real programs can be run form the sh command. Commands such as cd are not programs but part of the shell environment and as such cannot be executed unless the user invokes the shell explicitly, like &quot;bash cd&quot;.</source>
          <target state="translated">Обратите внимание,что только реальные программы могут быть запущены из команды sh.Такие команды,как cd,являются не программами,а частью окружения оболочки,и поэтому не могут быть выполнены,если пользователь явно не вызывает оболочку,например,&quot;bash cd&quot;.</target>
        </trans-unit>
        <trans-unit id="c3b397cb98d2ff8d3aff186a2a49ff9b5ce0dce4" translate="yes" xml:space="preserve">
          <source>Note that production scripts SHOULD NOT use DUMP as it will disable multi-query optimizations and is likely to slow down execution (see &lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что производственным сценариям НЕ СЛЕДУЕТ использовать DUMP, так как он отключит оптимизацию нескольких запросов и, скорее всего, замедлит выполнение (см. &lt;a href=&quot;perf#store-dump&quot;&gt;Store против Dump&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="220abe9e473e98cfec1e0a00df725cde1dc89b0a" translate="yes" xml:space="preserve">
          <source>Note that regardless of whether or not you store the schema, you always need to specify the correct delimiter to read your data. If you store using delimiter &quot;#&quot; and then load using the default delimiter, your data will not be parsed correctly.</source>
          <target state="translated">Обратите внимание,что независимо от того,храните вы схему или нет,вам всегда нужно указывать правильный разделитель для чтения ваших данных.Если вы храните с помощью разделителя &quot;#&quot;,а затем загружаете с помощью разделителя по умолчанию,то ваши данные будут разобраны некорректно.</target>
        </trans-unit>
        <trans-unit id="cd60f49eedb0eb2995d8bffd71cf6b05d7d5ba0e" translate="yes" xml:space="preserve">
          <source>Note that the REPLACE function is internally implemented using &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt; java.string.replaceAll(String regex, String replacement)&lt;/a&gt; where 'regExp' and 'newChar' are passed as the 1st and 2nd argument respectively. If you want to replace &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt; special characters&lt;/a&gt; such as '[' in the string literal, it is necessary to escape them in 'regExp' by prefixing them with double backslashes (e.g. '\\[').</source>
          <target state="translated">Обратите внимание, что функция REPLACE внутренне реализована с использованием &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt;java.string.replaceAll (регулярное выражение строки, замена строки),&lt;/a&gt; где &amp;laquo;regExp&amp;raquo; и &amp;laquo;newChar&amp;raquo; передаются как 1-й и 2-й аргументы соответственно. Если вы хотите заменить &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt;специальные символы,&lt;/a&gt; такие как &amp;laquo;[&amp;raquo; в строковом литерале, необходимо экранировать их в &amp;laquo;regExp&amp;raquo;, добавив перед ними двойной обратный слеш (например, &amp;laquo;\\ [&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="2728b339c8a82eb88c3fd4800ee4688acd5189e0" translate="yes" xml:space="preserve">
          <source>Note that the REPLACE function is internally implemented using &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt; java.string.replaceAll(String regex, String replacement)&lt;/a&gt; where 'regExp' and 'newChar' are passed as the 1st and 2nd argument respectively. If you want to replace &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt; special characters&lt;/a&gt; such as '[' in the string literal, it is necessary to escape them in 'regExp' by prefixing them with double backslashes (e.g. '\\[').</source>
          <target state="translated">Обратите внимание, что функция REPLACE внутренне реализована с использованием &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt;java.string.replaceAll (регулярное выражение строки, замена строки),&lt;/a&gt; где &amp;laquo;regExp&amp;raquo; и &amp;laquo;newChar&amp;raquo; передаются как 1-й и 2-й аргумент соответственно. Если вы хотите заменить &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt;специальные символы,&lt;/a&gt; такие как '[' в строковом литерале, необходимо экранировать их в 'regExp', добавив к ним двойной обратный слеш (например, '\\ [').</target>
        </trans-unit>
        <trans-unit id="7e09f5334aab86da1b1a89569910200108793437" translate="yes" xml:space="preserve">
          <source>Note that the ship option has two components: the source specification, provided in the ship( ) clause, is the view of your machine; the command specification is the view of the actual cluster. The only guarantee is that the shipped files are available in the current working directory of the launched job and that your current working directory is also on the PATH environment variable.</source>
          <target state="translated">Обратите внимание,что опция ship имеет две составляющие:исходная спецификация,представленная в пункте ship(),является видом вашей машины;спецификация команды-видом реального кластера.Единственная гарантия состоит в том,что отгруженные файлы доступны в текущей рабочей директории запущенного задания и что ваша текущая рабочая директория также находится в переменной окружения PATH.</target>
        </trans-unit>
        <trans-unit id="4e1565e4014885607dad5c0c2988001edad8fcbf" translate="yes" xml:space="preserve">
          <source>Note that there is no concept of delimit in JsonLoader or JsonStorage. The data is encoded in standard JSON format. JsonLoader optionally takes a schema as the construct argument.</source>
          <target state="translated">Обратите внимание,что в JsonLoader или JsonStorage нет понятия разграничения.Данные кодируются в стандартном формате JSON.JsonLoader опционально принимает схему в качестве аргумента конструкции.</target>
        </trans-unit>
        <trans-unit id="f363dfb66c51fc8e96f3f1500d605d9e9288e8c2" translate="yes" xml:space="preserve">
          <source>Note that type is NOT part of parameter definition. It is your responsibility to document the types of the parameters in a macro.</source>
          <target state="translated">Обратите внимание,что тип НЕ является частью определения параметров.Вы обязаны документировать типы параметров в макросе.</target>
        </trans-unit>
        <trans-unit id="2d208e362ac7a9c4e5eb23ba8f74811e2d7eaa7a" translate="yes" xml:space="preserve">
          <source>Note that, even if filtering is omitted, the same results will be produced because the foreach results is a cross product and cross products get rid of empty bags. However, doing up-front filtering is more efficient since it reduces the input of the cross product.</source>
          <target state="translated">Обратите внимание,что даже при отсутствии фильтрации будут получены те же самые результаты,так как в результате скрещивания получается перекрестный продукт,а из пустых мешков избавляются перекрестные продукты.Однако предварительная фильтрация более эффективна,так как она уменьшает поступление перекрестного продукта.</target>
        </trans-unit>
        <trans-unit id="1ed3db195fd189a63eb841d3fbd72406806084cd" translate="yes" xml:space="preserve">
          <source>Note the following about bags:</source>
          <target state="translated">Обратите внимание на следующее о сумках:</target>
        </trans-unit>
        <trans-unit id="d3b92c42da2b629b81e09e80527a3382ab34212d" translate="yes" xml:space="preserve">
          <source>Note the following about the GROUP/COGROUP and JOIN operators:</source>
          <target state="translated">Обратите внимание на следующие моменты,касающиеся операторов GROUP/COGROUP и JOIN:</target>
        </trans-unit>
        <trans-unit id="cc2f3dea19169906a9c3f9ebf1959122ab5b196c" translate="yes" xml:space="preserve">
          <source>Note the following general observations about data types:</source>
          <target state="translated">Обратите внимание на следующие общие замечания о типах данных:</target>
        </trans-unit>
        <trans-unit id="69a5304de52ed596021b9b04debf06f38d8482d3" translate="yes" xml:space="preserve">
          <source>Note the following restrictions:</source>
          <target state="translated">Обратите внимание на следующие ограничения:</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="473512170f0fb2c20a02c7d3b244817ba7bd30ab" translate="yes" xml:space="preserve">
          <source>Note the second column, &amp;lsquo;cube&amp;rsquo; field which is a bag of all tuples that belong to &amp;lsquo;group&amp;rsquo;. Also note that the measure attribute &amp;lsquo;sales&amp;rsquo; along with other unused dimensions in load statement are pushed down so that it can be referenced later while computing aggregates on the measure, like in this case SUM(cube.sales).</source>
          <target state="translated">Обратите внимание на второй столбец, поле &amp;laquo;куб&amp;raquo;, которое представляет собой пакет всех кортежей, принадлежащих группе. Также обратите внимание, что атрибут меры 'sales' вместе с другими неиспользуемыми измерениями в операторе загрузки сдвигается вниз, чтобы на него можно было ссылаться позже при вычислении агрегатов по мере, как в этом случае SUM (cube.sales).</target>
        </trans-unit>
        <trans-unit id="2e3c6dd868a0b7f3f2667d05913760948c880115" translate="yes" xml:space="preserve">
          <source>Note, the legacy property pig.additional.jars which use colon as separator is still supported. But we recommend to use pig.additional.jars.uris since colon is also used in URL scheme, and thus we cannot use full scheme in the list. We will deprecate pig.additional.jar in future releases.</source>
          <target state="translated">Обратите внимание,что все еще поддерживаются унаследованные свойства свиных.дополнительных.банок,которые используют двоеточие в качестве разделителя.Но мы рекомендуем использовать свиной.additional.jars.uris,так как двоеточие также используется в URL схеме,и поэтому мы не можем использовать полную схему в списке.В будущих релизах мы будем не использовать свинью.additional.jars.jars.</target>
        </trans-unit>
        <trans-unit id="965007b15476572db9ef0dd93fbea3f0a4093cfd" translate="yes" xml:space="preserve">
          <source>Note: A few Hive 0.14 UDF contains bug which affects Pig and are fixed in Hive 1.0. Here is a list: compute_stats, context_ngrams, count, ewah_bitmap, histogram_numeric, collect_list, collect_set, ngrams, case, in, named_struct, stack, percentile_approx.</source>
          <target state="translated">Замечание:Несколько ульев 0.14 UDF содержат ошибку,которая влияет на Свинью и исправлена в улье 1.0.Вот список:compute_stats,context_ngrams,count,ewah_bitmap,histogram_numeric,collect_list,collect_set,ngrams,case,in,named_struct,stack,percentile_approx.</target>
        </trans-unit>
        <trans-unit id="1dc746cfe7d74da28d435069888547345cd0e6c0" translate="yes" xml:space="preserve">
          <source>Note: FOREACH statements can be nested to two levels only. FOREACH statements that are nested to three or more levels will result in a grammar error.</source>
          <target state="translated">Примечание:Операторы FOREACH могут быть вложены только в два уровня.Операторы FOREACH,вложенные в три и более уровня,приведут к грамматической ошибке.</target>
        </trans-unit>
        <trans-unit id="80e6a55bf31a90c13baf56b918aa0883b6a73cca" translate="yes" xml:space="preserve">
          <source>Note: For performance reasons the loader may not immediately convert the data to the specified format; however, you can still operate on the data assuming the specified type.</source>
          <target state="translated">Примечание:По причинам производительности загрузчик не может сразу конвертировать данные в указанный формат,однако вы все равно можете работать с данными,предполагая указанный тип.</target>
        </trans-unit>
        <trans-unit id="ef3e4fdc51f94140b39d0bd6e49fb88dc740fa81" translate="yes" xml:space="preserve">
          <source>Note: PigStorage and TextLoader correctly read compressed files as long as they are NOT CONCATENATED bz/bz2 FILES generated in this manner:</source>
          <target state="translated">Примечание:PigStorage и TextLoader правильно читают сжатые файлы до тех пор,пока они НЕ являются КОНКРАТИРОВАННЫМ bz/bz2 ФАЙЛАМИ,сгенерированным таким образом:</target>
        </trans-unit>
        <trans-unit id="c0518f86c35b79620a3094a43a0ad3c6c991d598" translate="yes" xml:space="preserve">
          <source>Note: The GROUP and COGROUP operators are identical. Both operators work with one or more relations. For readability GROUP is used in statements involving one relation and COGROUP is used in statements involving two or more relations. You can COGROUP up to but no more than 127 relations at a time.</source>
          <target state="translated">Примечание:Операторы GROUP и COGROUP идентичны.Оба оператора работают с одним или несколькими отношениями.Для удобочитаемости ГРУППА используется в заявлениях,касающихся одного отношения,а COGROUP-в заявлениях,касающихся двух или более отношений.Вы можете СОГРОУПИТЬ до 127 отношений одновременно,но не более.</target>
        </trans-unit>
        <trans-unit id="1dd595d75ed7d8086119b3f8ba5b4bdfe66882d8" translate="yes" xml:space="preserve">
          <source>Note: The LIMIT operator allows Pig to avoid processing all tuples in a relation. In most cases a query that uses LIMIT will run more efficiently than an identical query that does not use LIMIT. It is always a good idea to use limit if you can.</source>
          <target state="translated">Примечание:Оператор LIMIT позволяет Свиньям избежать обработки всех кортежей в соотношении.В большинстве случаев запрос,использующий LIMIT,будет выполняться более эффективно,чем идентичный запрос,не использующий LIMIT.Всегда полезно использовать лимит,если можно.</target>
        </trans-unit>
        <trans-unit id="2b9a0acdfe2379b3842f287d992bccd78205e712" translate="yes" xml:space="preserve">
          <source>Note: The expression can consist of constants or scalars; it cannot contain any columns from the input relation.</source>
          <target state="translated">Примечание:Выражение может состоять из констант или скаляров;оно не может содержать никаких столбцов из входного соотношения.</target>
        </trans-unit>
        <trans-unit id="c0f3237ae0f4fc4380931b678193ed2fc302b2e4" translate="yes" xml:space="preserve">
          <source>Note: To debug scripts during development, you can use &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; to check intermediate results.</source>
          <target state="translated">Примечание. Для отладки сценариев во время разработки вы можете использовать &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; для проверки промежуточных результатов.</target>
        </trans-unit>
        <trans-unit id="b80c89e4cc5f492c5be085c22ab1f50cca4f91fc" translate="yes" xml:space="preserve">
          <source>Note: Using a scalar instead of a constant in LIMIT automatically disables most optimizations (only push-before-foreach is performed).</source>
          <target state="translated">Примечание:Использование скаляра вместо константы в LIMIT автоматически отключает большинство оптимизаций (выполняется только push-beforeach).</target>
        </trans-unit>
        <trans-unit id="ee0e474fc81852f36c5fdc6b3952b10b45bbe057" translate="yes" xml:space="preserve">
          <source>Note: You cannot use the tuple designator (*) with COUNT; that is, COUNT(*) will not work.</source>
          <target state="translated">Примечание:Вы не можете использовать обозначение кортежа (*)с COUNT,то есть COUNT(*)не будет работать.</target>
        </trans-unit>
        <trans-unit id="109a6c5afefe5d900d28ab42046f4fa5d0b0d109" translate="yes" xml:space="preserve">
          <source>Note: exec, run, and explain also support parameter substitution.</source>
          <target state="translated">Замечание:выполнение,запуск и объяснение также поддерживает подстановку параметров.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c256885553501e3fcd67fb31c3651f0b8df34e96" translate="yes" xml:space="preserve">
          <source>Now that we have the function implemented, it needs to be compiled and included in a jar. You will need to build pig.jar to compile your UDF. You can use the following set of commands to checkout the code from SVN repository and create pig.jar:</source>
          <target state="translated">Теперь,когда функция реализована,ее нужно скомпилировать и включить в банку.Для компиляции UDF вам нужно будет скомпилировать свинью.jar.Вы можете использовать следующий набор команд для извлечения кода из SVN-репозитория и создания pig.jar:</target>
        </trans-unit>
        <trans-unit id="bb88ad100d7880e07c6d760abded0864a9d02ad0" translate="yes" xml:space="preserve">
          <source>Now the following script will ran:</source>
          <target state="translated">Теперь будет запущен следующий сценарий:</target>
        </trans-unit>
        <trans-unit id="1f2d994aef96688f7037755c22498e05bc932790" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A by the first field to form relation X.</source>
          <target state="translated">Теперь предположим,что мы группируем отношение A по первому полю,чтобы сформировать отношение X.</target>
        </trans-unit>
        <trans-unit id="80712e1ab7247b5e2bf95f9c76ec0fce22fb65e3" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A on field &quot;age&quot; for form relation B. We can use the DESCRIBE and ILLUSTRATE operators to examine the structure of relation B. Relation B has two fields. The first field is named &quot;group&quot; and is type int, the same as field &quot;age&quot; in relation A. The second field is name &quot;A&quot; after relation A and is type bag.</source>
          <target state="translated">Теперь предположим,что мы группируем отношение A по полю &quot;возраст&quot; для отношения формы B.Мы можем использовать операторы DESCRIBE и ILLUSTRATE для изучения структуры отношения B.Отношение B имеет два поля.Первое поле называется &quot;group&quot; и является типом int,таким же,как и поле &quot;age&quot; в соотношении A.Второе поле является именем &quot;A&quot; после отношения A и является типом bag.</target>
        </trans-unit>
        <trans-unit id="217dc9412f1631b0d14b11b385eb5f1c8fece4f7" translate="yes" xml:space="preserve">
          <source>Now, you can assert that a0 column in your data is &amp;gt;0, fail if otherwise</source>
          <target state="translated">Теперь вы можете утверждать, что столбец a0 в ваших данных&amp;gt; 0, если нет, в противном случае</target>
        </trans-unit>
        <trans-unit id="b5fa110064ef2aba05aa7955d4237db465bf6269" translate="yes" xml:space="preserve">
          <source>Null Operators</source>
          <target state="translated">Корпусные операторы</target>
        </trans-unit>
        <trans-unit id="d723cf2b44d40a1ac71aeacb0490bce050f06594" translate="yes" xml:space="preserve">
          <source>Null operator:</source>
          <target state="translated">Нулл-оператор:</target>
        </trans-unit>
        <trans-unit id="9a0b4f0bceedd8bee0e9f98e565c8e1a7a905e08" translate="yes" xml:space="preserve">
          <source>Nulls and Constants</source>
          <target state="translated">Налл и константы</target>
        </trans-unit>
        <trans-unit id="f8e886cfbe6cffa98e03a6ad89d5caf8d8cf99de" translate="yes" xml:space="preserve">
          <source>Nulls and GROUP/COGROUP Operators</source>
          <target state="translated">Операторы Nulls и GROUP/COGROUP</target>
        </trans-unit>
        <trans-unit id="9d0af334fae1ee9bc62facfa1200db1ece9b07c4" translate="yes" xml:space="preserve">
          <source>Nulls and JOIN Operator</source>
          <target state="translated">Nulls and JOIN Оператор</target>
        </trans-unit>
        <trans-unit id="0b3c1a0927de16437ff4e83643fa705f3fbadba3" translate="yes" xml:space="preserve">
          <source>Nulls and Load Functions</source>
          <target state="translated">Нули и функции нагрузки</target>
        </trans-unit>
        <trans-unit id="d3eb7d232fed3cb6080570b64943cc8ecee344e0" translate="yes" xml:space="preserve">
          <source>Nulls and Pig Latin</source>
          <target state="translated">Нуль и свинья латынь</target>
        </trans-unit>
        <trans-unit id="6da7a1f37680b518d10a94f89d73ceb2846a7f55" translate="yes" xml:space="preserve">
          <source>Nulls are considered smaller than evertyhing. If data contains null keys, they should occur before anything else.</source>
          <target state="translated">Нули считаются меньшими,чем когда-либо.Если данные содержат нулевые ключи,то они должны появиться раньше,чем что-либо другое.</target>
        </trans-unit>
        <trans-unit id="e071444e347313a47d45e426ba220f983bb2317e" translate="yes" xml:space="preserve">
          <source>Nulls can be used as constant expressions in place of expressions of any type.</source>
          <target state="translated">Нуль может использоваться в качестве константных выражений вместо выражений любого типа.</target>
        </trans-unit>
        <trans-unit id="1208e9e89c0a8cbfe9919e6706a3a570ae6c30f8" translate="yes" xml:space="preserve">
          <source>Nulls, Operators, and Functions</source>
          <target state="translated">Нуллс,Операторы и Функции</target>
        </trans-unit>
        <trans-unit id="67b2f87c7a2f07028b46ec3058b64c67312a49b0" translate="yes" xml:space="preserve">
          <source>Numerics take a prefix modifier: , for locale-specific thousands-delimiting, 0 for zero-padding; + to always show a plus sign for positive numbers; space  to allow a space preceding positive numbers; ( to indicate negative numbers with parentheses (accountant-style).</source>
          <target state="translated">Цифры принимают префиксный модификатор:,для локального разделения тысяч,0 для нулевой подстановки;+для положительных чисел всегда показывать знак плюс;пробел для пробела перед положительными числами;(для обозначения отрицательных чисел круглыми скобками (по-бухгалтерски).</target>
        </trans-unit>
        <trans-unit id="e98bff99da15229b9b6d25ba78b508e05e344875" translate="yes" xml:space="preserve">
          <source>ONSCHEMA</source>
          <target state="translated">ONSCHEMA</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">ЗАКАЗ</target>
        </trans-unit>
        <trans-unit id="7b09d896b967e0241fb1f8e717db211b19ad86b0" translate="yes" xml:space="preserve">
          <source>OTHERWISE</source>
          <target state="translated">OTHERWISE</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="91ecfe414d0fb8ea8961b0c7b022ed8849f2e096" translate="yes" xml:space="preserve">
          <source>OUTPUT &amp;ndash; Keyword.</source>
          <target state="translated">ВЫХОД - Ключевое слово.</target>
        </trans-unit>
        <trans-unit id="5e8b6c4fabb5fcd98502309908c5ae2f7f3b3d89" translate="yes" xml:space="preserve">
          <source>OUTPUT ( {stdout | stderr | 'path'} [USING deserializer] [, {stdout | stderr | 'path'} [USING deserializer] &amp;hellip;] )</source>
          <target state="translated">ВЫХОД ({stdout | stderr | 'путь'} [ИСПОЛЬЗОВАНИЕ десериализатора] [, {stdout | stderr | 'путь'} [ИСПОЛЬЗОВАНИЕ десериализатора]&amp;hellip;])</target>
        </trans-unit>
        <trans-unit id="436316c809cb5512af5763e373c28a63cb305e4d" translate="yes" xml:space="preserve">
          <source>Object[]: Tuple</source>
          <target state="translated">Объект[]:Кортеж</target>
        </trans-unit>
        <trans-unit id="a921503fb0dae8fda28f9d3615aba523991068c2" translate="yes" xml:space="preserve">
          <source>Occasionally, users use BinStorage to store their own data. However, because BinStorage is a proprietary binary format, the original data is never in BinStorage - it is always a derivation of some other data.</source>
          <target state="translated">Иногда пользователи используют BinStorage для хранения собственных данных.Однако,поскольку BinStorage является собственным бинарным форматом,исходные данные никогда не бывают в BinStorage-они всегда являются производными от некоторых других данных.</target>
        </trans-unit>
        <trans-unit id="0bc92801b465b9bb97e55a1a664340f960368994" translate="yes" xml:space="preserve">
          <source>Often user data is stored such that both inputs are already sorted on the join key. In this case, it is possible to join the data in the map phase of a MapReduce job. This provides a significant performance improvement compared to passing all of the data through unneeded sort and shuffle phases.</source>
          <target state="translated">Часто данные пользователя хранятся так,что оба входа уже отсортированы по клавише соединения.В этом случае возможно соединение данных в фазе карты задания MapReduce.Это обеспечивает значительное улучшение производительности по сравнению с передачей всех данных через ненужные фазы сортировки и тасовки.</target>
        </trans-unit>
        <trans-unit id="f378e4a14200e531d64d8be58a4840b795824261" translate="yes" xml:space="preserve">
          <source>Often you are not interested in the entire output but rather a sample or top results. In such cases, using LIMIT can yield a much better performance as we push the limit as high as possible to minimize the amount of data travelling through the pipeline.</source>
          <target state="translated">Часто вас интересует не весь результат,а скорее образец или лучшие результаты.В таких случаях использование LIMIT может дать гораздо лучшие результаты,так как мы максимально увеличиваем лимит,чтобы свести к минимуму объем данных,проходящих по трубопроводу.</target>
        </trans-unit>
        <trans-unit id="cf71a41255fb73b5c3854a80e8b93532dd87b916" translate="yes" xml:space="preserve">
          <source>Often you may need to use a simple function that is already provided by standard Java libraries, but for which a &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDF) has not been written. Dynamic invokers allow you to refer to Java functions without having to wrap them in custom UDFs, at the cost of doing some Java reflection on every function call.</source>
          <target state="translated">Часто вам может понадобиться использовать простую функцию, которая уже предоставляется стандартными библиотеками Java, но для которой не определены &lt;a href=&quot;udf&quot;&gt;пользовательские функции&lt;/a&gt; (UDF). Динамические вызовы позволяют вам обращаться к функциям Java без необходимости заключать их в пользовательские пользовательские функции за счет некоторого отражения Java при каждом вызове функции.</target>
        </trans-unit>
        <trans-unit id="c0734e56926091020e2bafbec598196d6c34bd12" translate="yes" xml:space="preserve">
          <source>Omit line numbers in the list.</source>
          <target state="translated">Опустите номера строк в списке.</target>
        </trans-unit>
        <trans-unit id="5922013b0865acdbeeb785909913820c1e623db4" translate="yes" xml:space="preserve">
          <source>On UTF-8 systems you can specify string constants consisting of printable ASCII characters such as 'abc'; you can specify control characters such as '\t'; and, you can specify a character in Unicode by starting it with '\u', for instance, '\u0001' represents Ctrl-A in hexadecimal (see Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;). In theory, you should be able to specify non-UTF-8 constants on non-UTF-8 systems but as far as we know this has not been tested.</source>
          <target state="translated">В системах UTF-8 вы можете указать строковые константы, состоящие из печатных символов ASCII, таких как 'abc'; Вы можете указать управляющие символы, такие как '\ t'; и вы можете указать символ в Юникоде, начав его с &amp;laquo;\ u&amp;raquo;, например, &amp;laquo;\ u0001&amp;raquo; представляет Ctrl-A в шестнадцатеричном формате (см. Википедия &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; и &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; ). Теоретически, вы должны иметь возможность указывать не-UTF-8 константы в не-UTF-8 системах, но, насколько нам известно, это не было проверено.</target>
        </trans-unit>
        <trans-unit id="433273a64fe8abce869e5c1ef87deb06a2066c02" translate="yes" xml:space="preserve">
          <source>On UTF-8 systems you can specify string constants consisting of printable ASCII characters such as 'abc'; you can specify control characters such as '\t'; and, you can specify a character in Unicode by starting it with '\u', for instance, '\u0001' represents Ctrl-A in hexadecimal (see Wikipedia &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;). In theory, you should be able to specify non-UTF-8 constants on non-UTF-8 systems but as far as we know this has not been tested.</source>
          <target state="translated">В системах UTF-8 вы можете указать строковые константы, состоящие из печатаемых символов ASCII, таких как 'abc'; вы можете указать управляющие символы, такие как '\ t'; и вы можете указать символ в Unicode, начав его с '\ u', например, '\ u0001' представляет Ctrl-A в шестнадцатеричном формате (см. Wikipedia &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; и &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; ). Теоретически вы должны иметь возможность указывать константы, отличные от UTF-8, в системах, отличных от UTF-8, но, насколько нам известно, это не было проверено.</target>
        </trans-unit>
        <trans-unit id="fccca353eb6301c93d9f86e365716c6debf47b6c" translate="yes" xml:space="preserve">
          <source>On the non-trivial queries (one ran longer than a couple of minutes) we saw significant improvements both in terms of query latency and space usage. For some queries we saw up to 96% disk saving and up to 4x query speed up. Of course, the performance characteristics are very much query and data dependent and testing needs to be done to determine gains. We did not see any slowdown in the tests we peformed which means that you are at least saving on space while using compression.</source>
          <target state="translated">На нетривиальных запросах (один выполнялся дольше пары минут)мы увидели значительные улучшения как с точки зрения задержки запросов,так и с точки зрения использования пространства.Для некоторых запросов мы видели до 96% экономии диска и до 4-х кратного ускорения запросов.Конечно,характеристики производительности очень сильно зависят от запросов и данных,и для определения выигрыша необходимо провести тестирование.Мы не заметили никакого замедления в тестах,которые мы претерпели,а это означает,что вы,как минимум,экономите место при использовании сжатия.</target>
        </trans-unit>
        <trans-unit id="4c24fbf5c7d7120112ceec12106504825249996b" translate="yes" xml:space="preserve">
          <source>One case where pushing filters up might not be a good idea is if the cost of applying filter is very high and only a small amount of data is filtered out.</source>
          <target state="translated">Один из случаев,в котором увеличение количества фильтров может быть не очень хорошей идеей,это когда стоимость применения фильтра очень высока и отфильтровывается только небольшой объем данных.</target>
        </trans-unit>
        <trans-unit id="c2cbc2e2cd29c7b36db51b7156f79f696494a899" translate="yes" xml:space="preserve">
          <source>One downside of MapReduce is the startup cost for a job is very high. That hurts the performance especially for small job. Tez alleviate the problem by using session and container reuse, so it is not necessary to start an application master for every job, and start a JVM for every task. By default, session/container reuse is on and we usually shall not turn it off. JVM reuse might cause some side effect if static variable is used since static variable might live across different jobs. So if static variable is used in EvalFunc/LoadFunc/StoreFunc, be sure to implement a cleanup function and register with &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt;.</source>
          <target state="translated">Недостатком MapReduce является то, что стоимость запуска для работы очень высока. Это вредит производительности, особенно для небольшой работы. Tez облегчает проблему, используя повторное использование сеансов и контейнеров, поэтому нет необходимости запускать мастер-приложение для каждой работы и запускать JVM для каждой задачи. По умолчанию повторное использование сеанса / контейнера включено, и мы обычно не выключаем его. Повторное использование JVM может вызвать некоторый побочный эффект, если используется статическая переменная, поскольку статическая переменная может находиться в разных заданиях. Поэтому, если в EvalFunc / LoadFunc / StoreFunc используется статическая переменная, обязательно реализуйте функцию очистки и зарегистрируйтесь в &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d52719618c3bc8377b58610e8ea40170f8c1a3d" translate="yes" xml:space="preserve">
          <source>One downside of MapReduce is the startup cost for a job is very high. That hurts the performance especially for small job. Tez alleviate the problem by using session and container reuse, so it is not necessary to start an application master for every job, and start a JVM for every task. By default, session/container reuse is on and we usually shall not turn it off. JVM reuse might cause some side effect if static variable is used since static variable might live across different jobs. So if static variable is used in EvalFunc/LoadFunc/StoreFunc, be sure to implement a cleanup function and register with &lt;a href=&quot;https://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt;.</source>
          <target state="translated">Одним из недостатков MapReduce является очень высокая начальная стоимость работы. Это ухудшает производительность, особенно при выполнении небольших работ. Tez решает эту проблему, используя повторное использование сеанса и контейнера, поэтому нет необходимости запускать мастер приложения для каждого задания и запускать JVM для каждой задачи. По умолчанию повторное использование сеанса / контейнера включено, и мы обычно не отключаем его. Повторное использование JVM может вызвать побочный эффект, если используется статическая переменная, поскольку статическая переменная может существовать в разных заданиях. Поэтому, если в EvalFunc / LoadFunc / StoreFunc используется статическая переменная, обязательно реализуйте функцию очистки и зарегистрируйтесь в &lt;a href=&quot;https://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01399f316fca8487fd4f55faaee3ac7bb6836292" translate="yes" xml:space="preserve">
          <source>One more note about schemas and UDFs. Users have requested the ability to examine the input schema of the data before processing the data via a UDF. For example, they would like to know how to convert an input tuple to a map such that the keys in the map are the names of the input columns. Currently there is no way to do this. This is a feature we would like to support in the future.</source>
          <target state="translated">Еще одна заметка о схемах и ОДС.Пользователи запросили возможность изучить входную схему данных перед обработкой данных с помощью UDF.Например,они хотели бы знать,как преобразовать входной кортеж в карту таким образом,чтобы ключами на карте были названия входных столбцов.В настоящее время такого способа нет.Эту функцию мы хотели бы поддержать в будущем.</target>
        </trans-unit>
        <trans-unit id="86b1a003236c7726fc8c1ef65c53f5899623c990" translate="yes" xml:space="preserve">
          <source>One or more Pig Latin statements, enclosed in curly brackets.</source>
          <target state="translated">Одно или несколько высказываний на латинском языке свиней,заключенные в фигурные скобки.</target>
        </trans-unit>
        <trans-unit id="cb292bd04b825808a658558eceff1f99e3746de2" translate="yes" xml:space="preserve">
          <source>One problem that users run into is when they make assumption about how many times a constructor for their UDF is called. For instance, they might be creating side files in the store function and doing it in the constructor seems like a good idea. The problem with this approach is that in most cases Pig instantiates functions on the client side to, for instance, examine the schema of the data.</source>
          <target state="translated">Одна из проблем,с которой сталкиваются пользователи,это когда они делают предположения о том,сколько раз вызывается конструктор для их UDF.Например,они могут создавать боковые файлы в функции store и делать это в конструкторе кажется хорошей идеей.Проблема такого подхода заключается в том,что в большинстве случаев Pig инстанцирует функции на стороне клиента,чтобы,например,рассмотреть схему данных.</target>
        </trans-unit>
        <trans-unit id="768e440f42a11fcbfa95a4b6852f49f12632d6f7" translate="yes" xml:space="preserve">
          <source>Only files, not directories, can be specified with the ship option. One way to work around this limitation is to tar all the dependencies into a tar file that accurately reflects the structure needed on the compute nodes, then have a wrapper for your script that un-tars the dependencies prior to execution.</source>
          <target state="translated">С помощью опции &quot;Корабль&quot; можно указать только файлы,а не каталоги.Одним из способов обойти это ограничение является дезактивирование всех зависимостей в tar-файл,который точно отражает структуру,необходимую для вычислительных узлов,а затем имеет обертку для вашего скрипта,которая дезактивирует зависимости перед выполнением.</target>
        </trans-unit>
        <trans-unit id="2f500bcae0ac1d9a7f69a316f1483fc4cc7418c1" translate="yes" xml:space="preserve">
          <source>Only left outer join is supported for replicated joins.</source>
          <target state="translated">Для реплицированных соединений поддерживается только левое внешнее соединение.</target>
        </trans-unit>
        <trans-unit id="98c134b4570970f85b7a28cd1d729744bbdd592f" translate="yes" xml:space="preserve">
          <source>Only methods annotated with either @OutputSchema or @OutputSchemaFunction will be exposed to Pig as UDFs. In the example above, squareSchema will not be available in Pig as a UDF.</source>
          <target state="translated">Только методы,аннотированные либо @OutputSchema,либо @OutputSchemaFunction,будут подвергаться воздействию Pig в виде UDF.В приведенном выше примере функция squareSchema не будет доступна в Pig в виде UDF.</target>
        </trans-unit>
        <trans-unit id="7404c733035e01f2951203e52a17f2d7b25c3f70" translate="yes" xml:space="preserve">
          <source>Only primitives can be used for numbers; no capital-letter numeric classes can be used as arguments. Depending on the return type, a specific kind of invoker must be used: InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble, or InvokeForFloat.</source>
          <target state="translated">Для чисел могут использоваться только примитивы;в качестве аргументов не могут использоваться никакие числовые классы,написанные заглавными буквами.В зависимости от типа возвращаемого числа,должен использоваться определенный тип инвокера:InvokeForString,InvokeForInt,InvokeForLong,InvokeForDouble или InvokeForFloat.</target>
        </trans-unit>
        <trans-unit id="c500f72032e0fffa7307e38303bd6bd22f060e21" translate="yes" xml:space="preserve">
          <source>Operations That Produce Nulls</source>
          <target state="translated">Операции по производству нулей</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="6ff265181afd92a333026e2c5d5e199dc5da7ef8" translate="yes" xml:space="preserve">
          <source>Operators:</source>
          <target state="translated">Operators:</target>
        </trans-unit>
        <trans-unit id="6c7f4f579b94c45bf7d1ec93c8760a07327897b1" translate="yes" xml:space="preserve">
          <source>Optimization Rules</source>
          <target state="translated">Правила оптимизации</target>
        </trans-unit>
        <trans-unit id="04659a29a038f8b6f95d9df28a89681d94dc2803" translate="yes" xml:space="preserve">
          <source>Optimization can also be achieved using fragment replicate joins, skewed joins, and merge joins. For more information see &lt;a href=&quot;perf#specialized-joins&quot;&gt;Specialized Joins&lt;/a&gt;.</source>
          <target state="translated">Оптимизация также может быть достигнута с помощью объединений фрагментов с дублированием, наклонных объединений и объединений слиянием. Для получения дополнительной информации см. &lt;a href=&quot;perf#specialized-joins&quot;&gt;Специализированные соединения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f92b41bb13aa91ef73f2405bc184ea22fe7ab53" translate="yes" xml:space="preserve">
          <source>Optimization for regular joins ensures that the last table in the join is not brought into memory but streamed through instead. Optimization reduces the amount of memory used which means you can avoid spilling the data and also should be able to scale your query to larger data volumes.</source>
          <target state="translated">Оптимизация для регулярных соединений гарантирует,что последняя таблица в соединении не заносится в память,а проходит через нее.Оптимизация уменьшает объем используемой памяти,что означает,что вы можете избежать утечки данных,а также должны иметь возможность масштабировать запрос на большие объемы данных.</target>
        </trans-unit>
        <trans-unit id="f8766608ab14ae4c0ace8e4aee51b7a378f862b8" translate="yes" xml:space="preserve">
          <source>Optional items:</source>
          <target state="translated">Дополнительные пункты:</target>
        </trans-unit>
        <trans-unit id="9efc8753c1e4995cd0d1185902d8c3c9200a5b32" translate="yes" xml:space="preserve">
          <source>Optional keyword. Designates a default relation.</source>
          <target state="translated">Необязательное ключевое слово.Обозначает отношение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f9d88b237b4a78d338edf7da6c0b3e11382d6f4d" translate="yes" xml:space="preserve">
          <source>Optional tuple representing constant parameters of a Hive UDF/UDTF/UDAF. If Hive UDF requires a constant parameter, there is no other way Pig can pass that information to Hive, since Pig schema does not carry the information whether a parameter is constant or not. Null item in the tuple means this field is not a constant. Non-null item represents a constant field. Data type for the item is determined by Pig contant parser.</source>
          <target state="translated">Дополнительный кортеж,представляющий постоянные параметры Hive UDF/UDTF/UDAF.Если Hive UDF требует постоянного параметра,то нет другого способа,которым Pig может передать эту информацию в Hive,так как Pig схема не несет информацию о том,является ли параметр постоянным или нет.Нулевой элемент в кортеже означает,что это поле не является константой.Нулевой элемент представляет собой поле константы.Тип данных для элемента определяется парсером Pig contant.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="371b0ae2ff2ab087176f32bee166d4da2913bff3" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark local mode:</source>
          <target state="translated">Или если вы используете локальный режим искры:</target>
        </trans-unit>
        <trans-unit id="095b0c2883ec0b939fed65357c1b04420e296e0a" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark:</source>
          <target state="translated">Или если ты используешь Спарк:</target>
        </trans-unit>
        <trans-unit id="907c1518b24f449be57666853914f303931b978f" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez local mode:</source>
          <target state="translated">Или если вы используете локальный режим Tez:</target>
        </trans-unit>
        <trans-unit id="5a4c4c74b3f7d241b86e5336001adb11c6de88bf" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez:</source>
          <target state="translated">Или если ты используешь Теса:</target>
        </trans-unit>
        <trans-unit id="4c9450cd3b04d1fd47af444a11a91bb90f9a49d5" translate="yes" xml:space="preserve">
          <source>Orc BYTE/BINARY all map to Pig bytearray</source>
          <target state="translated">Орк Байт/Бинарий все карты до Свиньи Байтэррей</target>
        </trans-unit>
        <trans-unit id="b510b6858c4b9765788f82d0e9c521f50419cd2f" translate="yes" xml:space="preserve">
          <source>Orc DECIMAL maps to Pig bigdecimal</source>
          <target state="translated">Карты орков ДЕЦИМАЛЬНЫЕ на Свинью большого диаметра</target>
        </trans-unit>
        <trans-unit id="9961f1b05ddf0fc66a4ab6a46c676c806aebb176" translate="yes" xml:space="preserve">
          <source>Orc STRING/CHAR/VARCHAR all map to Pig varchar</source>
          <target state="translated">Орк СТРИНГ/ЧАР/КАРТИНГ все карта до Свиньи Варчара</target>
        </trans-unit>
        <trans-unit id="6d27972086aacd281681114b9c28fd369d9c4b9f" translate="yes" xml:space="preserve">
          <source>Orc TIMESTAMP/DATE all maps to Pig datetime</source>
          <target state="translated">ВРЕМЯ КОМПАНИИ КОМПАНИИ Орков/ДАТА всех карт ВРЕМЯ Свиньи</target>
        </trans-unit>
        <trans-unit id="a1591da02510a2712f04308058e399add5eca1dd" translate="yes" xml:space="preserve">
          <source>OrcStorage</source>
          <target state="translated">OrcStorage</target>
        </trans-unit>
        <trans-unit id="4c9f23c645f12bfa00bd50f98ef015ca573fdaf2" translate="yes" xml:space="preserve">
          <source>OrcStorage as a LoadFunc.</source>
          <target state="translated">Оркскскрипт как LoadFunc.</target>
        </trans-unit>
        <trans-unit id="3eb7b9cec1cdd27213bef34fc6170acf9fdd4faa" translate="yes" xml:space="preserve">
          <source>OrcStorage as a StoreFunc.</source>
          <target state="translated">Хранилище как Хранилище.</target>
        </trans-unit>
        <trans-unit id="469606f67e8335e115993b24e3f6965fc1459c33" translate="yes" xml:space="preserve">
          <source>OrcStorage predicate pushdown currently support all primitive data types but none of the complex data types. For example, map condition cannot push into OrcStorage:</source>
          <target state="translated">OrcStorage предикат pushdown в настоящее время поддерживает все примитивные типы данных,но ни один из сложных типов данных не поддерживается.Например,состояние карты не может быть выведено в OrcStorage:</target>
        </trans-unit>
        <trans-unit id="1bfcf8f6cfd1ff12ec733abbdfb29a53dcdc9dcc" translate="yes" xml:space="preserve">
          <source>OrcStorage(['options'])</source>
          <target state="translated">OrcStorage(['options'])</target>
        </trans-unit>
        <trans-unit id="d0fe29562a7c21056884a2c410f56a9812b54c99" translate="yes" xml:space="preserve">
          <source>Original Avro Types</source>
          <target state="translated">Оригинальные Avro Типы</target>
        </trans-unit>
        <trans-unit id="882617723625c587393c99fb5f6b0d0cf3ad5a0e" translate="yes" xml:space="preserve">
          <source>Original Pig Type</source>
          <target state="translated">Оригинальный тип свиньи</target>
        </trans-unit>
        <trans-unit id="be0be73dfa142afb06644b4bd429b15778e4bac4" translate="yes" xml:space="preserve">
          <source>Other Modes</source>
          <target state="translated">Другие модели</target>
        </trans-unit>
        <trans-unit id="ebe6018e98731e126f80812a6b4853d5ee2275d6" translate="yes" xml:space="preserve">
          <source>Other properties</source>
          <target state="translated">Другие свойства</target>
        </trans-unit>
        <trans-unit id="701a7e9210bdedb5978458dbeba9fb2d822971a2" translate="yes" xml:space="preserve">
          <source>Otherwise, Pig will attempt to ship the first string from the command line as long as it does not come from /bin, /usr/bin, /usr/local/bin. Pig will determine this by scanning the path if an absolute path is provided or by executing which. The paths can be made configurable using the &lt;a href=&quot;cmds#set&quot;&gt;set stream.skippath&lt;/a&gt; option (you can use multiple set commands to specify more than one path to skip).</source>
          <target state="translated">В противном случае Pig попытается отправить первую строку из командной строки, если она не поступает из / bin, / usr / bin, / usr / local / bin. Pig определит это путем сканирования пути, если указан абсолютный путь, или путем выполнения которого. Пути можно настроить с &lt;a href=&quot;cmds#set&quot;&gt;помощью&lt;/a&gt; опции set stream.skippath (вы можете использовать несколько команд set, чтобы указать несколько путей для пропуска).</target>
        </trans-unit>
        <trans-unit id="a338e1e79d114a1522d9eb5979c8db612a93073a" translate="yes" xml:space="preserve">
          <source>Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="translated">В противном случае оператор РАНК использует каждое поле (или набор полей)для сортировки отношения.Ранг кортежа-это один плюс число различных значений ранга,предшествующих ему.Если два или более кортежей связывают значения полей сортировки,то они получают одну и ту же ранговую оценку.</target>
        </trans-unit>
        <trans-unit id="5cd2e1cb8ff03e85d7add8f6016467a3f5e57d79" translate="yes" xml:space="preserve">
          <source>Outer joins will only work for two-way joins; to perform a multi-way outer join, you will need to perform multiple two-way outer join statements.</source>
          <target state="translated">Внешние соединения будут работать только для двухсторонних соединений;для выполнения многостороннего внешнего соединения вам нужно будет выполнить несколько заявлений о двухстороннем внешнем соединении.</target>
        </trans-unit>
        <trans-unit id="600054c2fe7432d844752d909a7af30d0a800923" translate="yes" xml:space="preserve">
          <source>Outer joins will only work provided the relations which need to produce nulls (in the case of non-matching keys) have schemas.</source>
          <target state="translated">Внешние соединения будут работать только при условии,что отношения,которые должны производить нули (в случае несовпадения ключей),имеют схемы.</target>
        </trans-unit>
        <trans-unit id="c746f245398c7408bb6df1ccfc1430c711902402" translate="yes" xml:space="preserve">
          <source>Outer merge join (between two tables) and inner merge join (between three or more tables) will only work under these conditions:</source>
          <target state="translated">Внешнее соединение слияния (между двумя таблицами)и внутреннее соединение слияния (между тремя и более таблицами)будут работать только при этих условиях:</target>
        </trans-unit>
        <trans-unit id="0d2a263550d66b9f4e2dd5cc2ce0bd6b5aa3b982" translate="yes" xml:space="preserve">
          <source>Output location strict check</source>
          <target state="translated">Местоположение выхода строгая проверка</target>
        </trans-unit>
        <trans-unit id="c5729f9b287de5b3dfc0238cb6432a164885bc6a" translate="yes" xml:space="preserve">
          <source>Output schema</source>
          <target state="translated">Выходная схема</target>
        </trans-unit>
        <trans-unit id="f1657b858c692a8810b394c9fbe10ef1f3ebefa9" translate="yes" xml:space="preserve">
          <source>OutputStats</source>
          <target state="translated">OutputStats</target>
        </trans-unit>
        <trans-unit id="efbc45e086170113898fb269e6cf4a872cd68ed5" translate="yes" xml:space="preserve">
          <source>Overall you would create a file that looks like this (assume we call it niels.kerberos.properties):</source>
          <target state="translated">В общем,вы создадите файл,который выглядит так (предположим,что мы называем его niels.kerberos.properties):</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="96ce24f1a92e6b30382bcf71beddd1d02bbf7658" translate="yes" xml:space="preserve">
          <source>PARALLEL n</source>
          <target state="translated">ПАРАЛЛЕЛЬ n</target>
        </trans-unit>
        <trans-unit id="b00fec6efa227099463e118d74a38da9dc9e323c" translate="yes" xml:space="preserve">
          <source>PARTITION BY partitioner</source>
          <target state="translated">УЧАСТИЕ ПРОГРАММЫ</target>
        </trans-unit>
        <trans-unit id="2b338af39aea20defe562c404d22d384da1fb4d9" translate="yes" xml:space="preserve">
          <source>Parallel Execution</source>
          <target state="translated">Параллельное выполнение</target>
        </trans-unit>
        <trans-unit id="58171bd8fa88aa62d26baf06d454a174292bf115" translate="yes" xml:space="preserve">
          <source>Parallel joins are vulnerable to the presence of skew in the underlying data. If the underlying data is sufficiently skewed, load imbalances will swamp any of the parallelism gains. In order to counteract this problem, skewed join computes a histogram of the key space and uses this data to allocate reducers for a given key. Skewed join does not place a restriction on the size of the input keys. It accomplishes this by splitting the left input on the join predicate and streaming the right input. The left input is sampled to create the histogram.</source>
          <target state="translated">Параллельные соединения уязвимы для наличия перекоса в исходных данных.Если исходные данные достаточно перекошены,то дисбаланс нагрузки заблокирует любой прирост параллелизма.Для решения этой проблемы перекошенный шарнир вычисляет гистограмму пространства ключа и использует эти данные для выделения редукторов для данного ключа.Наклонное соединение не накладывает ограничений на размер входных клавиш.Это достигается путем разделения левого входа на предикат соединения и потоком правого входа.Для создания гистограммы используется выборка левого входа.</target>
        </trans-unit>
        <trans-unit id="3375c065590ef4a44f56b15335a0387a3cccbc5a" translate="yes" xml:space="preserve">
          <source>Parameter Substitution</source>
          <target state="translated">Замена параметров</target>
        </trans-unit>
        <trans-unit id="7790c9a165b0c914283a93f7037cf0b0cc4cb830" translate="yes" xml:space="preserve">
          <source>Parameter files are scanned in the order they are specified on the command line. Within each file, the parameters are processed in the order they are listed.</source>
          <target state="translated">Файлы параметров сканируются в порядке,указанном в командной строке.В каждом файле параметры обрабатываются в том порядке,в котором они перечислены.</target>
        </trans-unit>
        <trans-unit id="70117576ffa2ad03e5513ff9b3fbd512b8641d45" translate="yes" xml:space="preserve">
          <source>Parameter names are case insensitive.</source>
          <target state="translated">Имена параметров не чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="f6466211ad9aa97ba4dc313d987046ab6af23120" translate="yes" xml:space="preserve">
          <source>Parameter substitution enables you to write Pig scripts that include parameters and to supply values for these parameters at run time. For instance, suppose you have a job that needs to run every day using the current day's data. You can create a Pig script that includes a parameter for the date. Then, when you run this script you can specify or supply a value for the date parameter using one of the supported methods.</source>
          <target state="translated">Замена параметров позволяет записывать скрипты Pig,включающие параметры,и предоставлять значения для этих параметров во время выполнения.Например,предположим,что у вас есть работа,которая должна выполняться каждый день,используя данные текущего дня.Вы можете создать скрипт Pig,который будет содержать параметр для даты.Затем,когда вы запускаете этот сценарий,вы можете указать или предоставить значение для параметра даты,используя один из поддерживаемых методов.</target>
        </trans-unit>
        <trans-unit id="f69e14d703d0fb6cfc378c0a831efb4f72f66bf1" translate="yes" xml:space="preserve">
          <source>Parameter substitution may be used inside of macros. When there are conflicts between names of parameters defined at the top level and names of arguments or return values for a given macro, then ones inside the macro are used. See &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (macros)&lt;/a&gt;.</source>
          <target state="translated">Подстановка параметров может использоваться внутри макросов. Когда возникают конфликты между именами параметров, определенных на верхнем уровне, и именами аргументов или возвращаемых значений для данного макроса, тогда используются те, которые находятся внутри макроса. Смотрите &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (макросы)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c256c12a753b5b6bd6decc3861da77cc5d8f2234" translate="yes" xml:space="preserve">
          <source>Parameters Supported in the Query String</source>
          <target state="translated">Параметры,поддерживаемые в строке запроса</target>
        </trans-unit>
        <trans-unit id="769003fbcc6fc353a4044c923e34ca968752f228" translate="yes" xml:space="preserve">
          <source>Parameters are processed as follows:</source>
          <target state="translated">Параметры обрабатываются следующим образом:</target>
        </trans-unit>
        <trans-unit id="0074ddadeda7d41356f958931e0fcd57e8b79c9b" translate="yes" xml:space="preserve">
          <source>Parameters defined in parameter files specified by -param_file</source>
          <target state="translated">Параметры,заданные в файлах параметров,заданных с помощью -param_file</target>
        </trans-unit>
        <trans-unit id="70543f43b0b77a80afe0d18b065682a97d7fcc6d" translate="yes" xml:space="preserve">
          <source>Parameters defined in the command line using -param</source>
          <target state="translated">Параметры,определенные в командной строке с помощью -param</target>
        </trans-unit>
        <trans-unit id="e7a454f5498afc7a5bd9a3b2032372bdf7551245" translate="yes" xml:space="preserve">
          <source>Parameters defined using the declare statement</source>
          <target state="translated">Параметры,определенные с помощью заявления об объявлении</target>
        </trans-unit>
        <trans-unit id="7030e575509b3a9849a213f50450f6c3ea2b9a16" translate="yes" xml:space="preserve">
          <source>Parameters defined using the default statement</source>
          <target state="translated">Параметры,определенные с помощью оператора по умолчанию</target>
        </trans-unit>
        <trans-unit id="ef98d6e375037bebdef260ca6d55bd8ab3dd0e64" translate="yes" xml:space="preserve">
          <source>Parentheses are also used to indicate the tuple data type.</source>
          <target state="translated">Круглые скобки также используются для указания типа данных кортежа.</target>
        </trans-unit>
        <trans-unit id="ddc4e9e14a7a05acd86ecf4b274ad71ee33e5bcd" translate="yes" xml:space="preserve">
          <source>Parentheses enclose one or more items.</source>
          <target state="translated">К скобкам прилагается один или несколько пунктов.</target>
        </trans-unit>
        <trans-unit id="9277a0569e80e9b319b019aefc95b0225b6e8571" translate="yes" xml:space="preserve">
          <source>PartitionFilterOptimizer</source>
          <target state="translated">PartitionFilterOptimizer</target>
        </trans-unit>
        <trans-unit id="97a0e02c60f7bd5b056aeeb4d721b45b24381261" translate="yes" xml:space="preserve">
          <source>Partitions a relation into two or more relations.</source>
          <target state="translated">Разделяет отношение на два или более.</target>
        </trans-unit>
        <trans-unit id="5fffb570a05163ec7d3a9ee94c710223f45deb55" translate="yes" xml:space="preserve">
          <source>Passing Configurations to UDFs</source>
          <target state="translated">Передача конфигурации в UDF</target>
        </trans-unit>
        <trans-unit id="900e8b0d2c1088af54281fa7b734ee24070da72e" translate="yes" xml:space="preserve">
          <source>Passing Parameters to a Script</source>
          <target state="translated">Передача параметров к скрипту</target>
        </trans-unit>
        <trans-unit id="30e96c64e3d87a1b3ae0dcab374223bf047c1fd7" translate="yes" xml:space="preserve">
          <source>Passing a Pig Script</source>
          <target state="translated">Передача Свиного сценария</target>
        </trans-unit>
        <trans-unit id="bc0b27a7477f8ed02a5b4c719673367cbbf610fe" translate="yes" xml:space="preserve">
          <source>Perform a bloom join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations. Bloom filter is built from join keys of the right most relation which is small and the filter is applied on the big and medium relations. None of the relations are required to fit into main memory.</source>
          <target state="translated">Выполните объединение Блума с предложением USING (см. &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (внутренний)&lt;/a&gt; и &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (внешний)&lt;/a&gt; ). В этом примере большое отношение объединяется с двумя меньшими отношениями. Обратите внимание, что сначала следует большое отношение, за которым следуют меньшие отношения. Фильтр Блума строится из ключей соединения самого правого отношения, которое является маленьким, и фильтр применяется к большим и средним отношениям. Ни одно из отношений не требуется вписываться в основную память.</target>
        </trans-unit>
        <trans-unit id="67969b99648d91d1035f722084db31dddca473ad" translate="yes" xml:space="preserve">
          <source>Perform a merge join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="translated">Выполните объединение с помощью предложения USING (см. &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (внутренний)&lt;/a&gt; и &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (внешний)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd5572ed8b373fc67c4f3724a55aa798b14ca3c3" translate="yes" xml:space="preserve">
          <source>Perform a merge-sparse join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt;).</source>
          <target state="translated">Выполните разреженное объединение с помощью предложения USING (см. &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (внутренний)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="402e4b589f5a0d62e1e68cc5769ea6fe810721f3" translate="yes" xml:space="preserve">
          <source>Perform a replicated join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations; and, all small relations together must fit into main memory, otherwise an error is generated.</source>
          <target state="translated">Выполните реплицированное соединение с предложением USING (см. &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (внутренний)&lt;/a&gt; и &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (внешний)&lt;/a&gt; ). В этом примере большое отношение объединяется с двумя меньшими отношениями. Обратите внимание, что сначала следует большое отношение, за которым следуют меньшие отношения; и все небольшие отношения вместе должны вписываться в основную память, в противном случае генерируется ошибка.</target>
        </trans-unit>
        <trans-unit id="1f464de18fcec5cc28885815dcee4e7667a7ec7e" translate="yes" xml:space="preserve">
          <source>Perform a skewed join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="translated">Выполните наклонное соединение с предложением USING (см. &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (внутренний)&lt;/a&gt; и &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (внешний)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3130994b43da1d8950109e1c6564a8348e9d6104" translate="yes" xml:space="preserve">
          <source>Performance Considerations</source>
          <target state="translated">Показатели эффективности</target>
        </trans-unit>
        <trans-unit id="f24e3938bb4e4cb45e3fceea03006c92f75688c9" translate="yes" xml:space="preserve">
          <source>Performance Enhancers</source>
          <target state="translated">Повышение эффективности</target>
        </trans-unit>
        <trans-unit id="25a6857524ecb9afe00595831a6eabce0d0dfafa" translate="yes" xml:space="preserve">
          <source>Performance and Efficiency</source>
          <target state="translated">Производительность и эффективность</target>
        </trans-unit>
        <trans-unit id="8f76637cf34db3a94cdd1b0e2b9af4d58294a730" translate="yes" xml:space="preserve">
          <source>Performs an inner join of two or more relations based on common field values.</source>
          <target state="translated">Выполняет внутреннее соединение двух или более отношений на основе общих значений поля.</target>
        </trans-unit>
        <trans-unit id="1e1e34d4c871c8f4da9be20b9f4469a363f98b73" translate="yes" xml:space="preserve">
          <source>Performs an outer join of two relations based on common field values.</source>
          <target state="translated">Выполняет внешнее соединение двух отношений на основе общих значений поля.</target>
        </trans-unit>
        <trans-unit id="cad8be75b29842759141027890e92f4432bb017a" translate="yes" xml:space="preserve">
          <source>Performs cube/rollup operations.</source>
          <target state="translated">Выполняет операции по кубированию/прокрутке.</target>
        </trans-unit>
        <trans-unit id="d24cf8c587230b4ed2537a805a07c9584dcfb6ca" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts all matched groups.</source>
          <target state="translated">Выполняет сравнение регулярных выражений и извлекает все совпадающие группы.</target>
        </trans-unit>
        <trans-unit id="9018076e46e8c3ab55cf8633b09942355fa4aec9" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts the matched group defined by an index parameter.</source>
          <target state="translated">Выполняет сравнение регулярных выражений и извлекает соответствующую группу,определенную параметром индекса.</target>
        </trans-unit>
        <trans-unit id="ebeb13a8133f2d73bb66dcd9301c11a7ab8ac32f" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and searches all matched characters in a string.</source>
          <target state="translated">Выполняет сравнение регулярных выражений и ищет все совпадающие символы в строке.</target>
        </trans-unit>
        <trans-unit id="28e7ba6ea4395e9894a796bb57462b156a7c5827" translate="yes" xml:space="preserve">
          <source>Pig JAR file</source>
          <target state="translated">JAR-файл Pig</target>
        </trans-unit>
        <trans-unit id="92283693de8e1c937c436504772afa7e54d4d779" translate="yes" xml:space="preserve">
          <source>Pig Latin Basics</source>
          <target state="translated">Свинья Латинские Основы</target>
        </trans-unit>
        <trans-unit id="278a8301cb0641c9a4edbfd68852047e3b82ffe2" translate="yes" xml:space="preserve">
          <source>Pig Latin Statements</source>
          <target state="translated">Свиньи Латинские заявления</target>
        </trans-unit>
        <trans-unit id="abe1ac30b366cc27ad64f6b2a535541e0d5bd848" translate="yes" xml:space="preserve">
          <source>Pig Latin operators and functions interact with nulls as shown in this table.</source>
          <target state="translated">Свиные латинские операторы и функции взаимодействуют с нулями,как показано в этой таблице.</target>
        </trans-unit>
        <trans-unit id="3c6a60413a273559ed0f210ce1379e5ecd049483" translate="yes" xml:space="preserve">
          <source>Pig Latin provides operators that can help you debug your Pig Latin statements:</source>
          <target state="translated">Pig Latin предоставляет операторов,которые могут помочь вам отладить ваши утверждения Pig Latin:</target>
        </trans-unit>
        <trans-unit id="f38d85519e485d8e2d061fcc97d35bf4ac9736e0" translate="yes" xml:space="preserve">
          <source>Pig Latin statement:</source>
          <target state="translated">Свиное латинское заявление:</target>
        </trans-unit>
        <trans-unit id="aafb100d0f8b7f3882c6325c161b1a4b645fc993" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are generally organized as follows:</source>
          <target state="translated">Свинолатинские высказывания,как правило,организованы следующим образом:</target>
        </trans-unit>
        <trans-unit id="dfefbefcd550d25bef5229b93a8fd8ba2bde0953" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are the basic constructs you use to process data using Pig. A Pig Latin statement is an operator that takes a &lt;a href=&quot;basic#relations&quot;&gt;relation&lt;/a&gt; as input and produces another relation as output. (This definition applies to all Pig Latin operators except LOAD and STORE which read data from and write data to the file system.) Pig Latin statements may include &lt;a href=&quot;basic#expressions&quot;&gt;expressions&lt;/a&gt; and &lt;a href=&quot;basic#schemas&quot;&gt;schemas&lt;/a&gt;. Pig Latin statements can span multiple lines and must end with a semi-colon ( ; ). By default, Pig Latin statements are processed using &lt;a href=&quot;perf#multi-query-execution&quot;&gt;multi-query execution&lt;/a&gt;.</source>
          <target state="translated">Операторы Pig Latin - это основные конструкции, которые вы используете для обработки данных с использованием Pig. Оператор Pig Latin - это оператор, который принимает &lt;a href=&quot;basic#relations&quot;&gt;отношение в&lt;/a&gt; качестве входных данных и создает другое отношение в качестве выходных данных. (Это определение применяется ко всем операторам Pig Latin, кроме LOAD и STORE, которые считывают данные и записывают данные в файловую систему.) Операторы Pig Latin могут включать &lt;a href=&quot;basic#expressions&quot;&gt;выражения&lt;/a&gt; и &lt;a href=&quot;basic#schemas&quot;&gt;схемы&lt;/a&gt; . Латинские операторы Pig могут занимать несколько строк и заканчиваться точкой с запятой (;). По умолчанию операторы Pig Latin обрабатываются с использованием &lt;a href=&quot;perf#multi-query-execution&quot;&gt;нескольких запросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d6b1b831ea171957ed0e1ca09e2fcb0f0cc8198" translate="yes" xml:space="preserve">
          <source>Pig Latin supports casts as shown in this table.</source>
          <target state="translated">Свиная латынь поддерживает касты,как показано в этой таблице.</target>
        </trans-unit>
        <trans-unit id="d272d6e8e9fd410fba40f8d7f45eb3ef23d66fd5" translate="yes" xml:space="preserve">
          <source>Pig Latin supports the definition, expansion, and import of macros.</source>
          <target state="translated">Pig Latin поддерживает определение,расширение и импорт макросов.</target>
        </trans-unit>
        <trans-unit id="a52974cdd3ea4e71d39c1a5b454a4491f41f2366" translate="yes" xml:space="preserve">
          <source>Pig Latin syntax statement:</source>
          <target state="translated">Свиной латинский синтаксис:</target>
        </trans-unit>
        <trans-unit id="a6de2cdfe9e769e638ae13f67688e2ebf50c4116" translate="yes" xml:space="preserve">
          <source>Pig Macros</source>
          <target state="translated">Свиные макросы</target>
        </trans-unit>
        <trans-unit id="4a2ca1d4b92ee91ccc81dde3263e5535ea441ba7" translate="yes" xml:space="preserve">
          <source>Pig Object</source>
          <target state="translated">Свиной объект</target>
        </trans-unit>
        <trans-unit id="9fd1a1cb2d567f7a5ff0480ca9134d87032c5949" translate="yes" xml:space="preserve">
          <source>Pig Progress Notification Listener</source>
          <target state="translated">Уведомление о прогрессе свиньи Слушатель</target>
        </trans-unit>
        <trans-unit id="99c542779d91327bc9bd3447f9526c2088c67b88" translate="yes" xml:space="preserve">
          <source>Pig Properties</source>
          <target state="translated">Свинина Свойства</target>
        </trans-unit>
        <trans-unit id="734f02bedf731c9ba833109c0b94942fe59227b8" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (local mode)</source>
          <target state="translated">Свинья Сценарий 1,Популярность фразы запроса (локальный режим)</target>
        </trans-unit>
        <trans-unit id="0e141603768346ca22cbf8799fa641ebc9a2665a" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (mapreduce mode)</source>
          <target state="translated">Свинья Сценарий 1,Популярность фразы &quot;Запрос&quot; (режим картографирования)</target>
        </trans-unit>
        <trans-unit id="2da304232e645beee888e58d6826aa40479df310" translate="yes" xml:space="preserve">
          <source>Pig Script 1: Query Phrase Popularity</source>
          <target state="translated">Свиной сценарий 1:Фраза-запрос Популярность</target>
        </trans-unit>
        <trans-unit id="f9be711a0ed7d8a9d09e991f0c431dfed287b99e" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (local mode)</source>
          <target state="translated">Свинопись 2,Временная фраза-запрос Популярность (локальный режим)</target>
        </trans-unit>
        <trans-unit id="f2397170eecb6952fd14aafebda31090031e9196" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (mapreduce mode)</source>
          <target state="translated">Свинопись 2,Временная фраза-запрос Популярность (режим mapreduce)</target>
        </trans-unit>
        <trans-unit id="96a4246b4d848f77f5340b34b8f5f9356de36427" translate="yes" xml:space="preserve">
          <source>Pig Script 2: Temporal Query Phrase Popularity</source>
          <target state="translated">Свиной сценарий 2:Временная фраза-запрос Популярность</target>
        </trans-unit>
        <trans-unit id="d650e124b03231e4f6e63a60633af92981457281" translate="yes" xml:space="preserve">
          <source>Pig Scripts</source>
          <target state="translated">Свиньи Сценарии</target>
        </trans-unit>
        <trans-unit id="3711a90b3c1fa50c85635bc7e599451f34dc20e0" translate="yes" xml:space="preserve">
          <source>Pig Scripts and MapReduce Job IDs (MapReduce mode only)</source>
          <target state="translated">Свиные скрипты и MapReduce ID заданий (только в режиме MapReduce)</target>
        </trans-unit>
        <trans-unit id="43590fd010743d8912e0f24af54d70fb5088bcc6" translate="yes" xml:space="preserve">
          <source>Pig Setup</source>
          <target state="translated">Настройка свиней</target>
        </trans-unit>
        <trans-unit id="ad6533e178840e687da8395d7e65379f0284aea8" translate="yes" xml:space="preserve">
          <source>Pig Statistics</source>
          <target state="translated">Статистика свиней</target>
        </trans-unit>
        <trans-unit id="e124c110e55a5e3fc700ba74964a062c34387574" translate="yes" xml:space="preserve">
          <source>Pig Statistics is a framework for collecting and storing script-level statistics for Pig Latin. Characteristics of Pig Latin scripts and the resulting MapReduce jobs are collected while the script is executed. These statistics are then available for Pig users and tools using Pig (such as Oozie) to retrieve after the job is done.</source>
          <target state="translated">Pig Statistics-это основа для сбора и хранения статистики на уровне скрипта для Pig Latin.Характеристики скриптов Pig Latin и полученные в результате задания MapReduce собираются во время выполнения скрипта.Эта статистика затем доступна пользователям Pig и инструментам,использующим Pig (таким как Oozie)для получения после выполнения задания.</target>
        </trans-unit>
        <trans-unit id="612dd975aa5ad31fc345b7a3ddd612ad0616e4ab" translate="yes" xml:space="preserve">
          <source>Pig Tutorial</source>
          <target state="translated">урок свиньи</target>
        </trans-unit>
        <trans-unit id="4757ba63e67d355d84729fef8914757bf15f22dd" translate="yes" xml:space="preserve">
          <source>Pig Tutorial Files</source>
          <target state="translated">Файлы-учебники</target>
        </trans-unit>
        <trans-unit id="f4e3c20276b1374c79d691d19de05b31570ed547" translate="yes" xml:space="preserve">
          <source>Pig Type</source>
          <target state="translated">Тип свиньи</target>
        </trans-unit>
        <trans-unit id="47775b7064fc01c255082ec71e837ab11cb3bfdc" translate="yes" xml:space="preserve">
          <source>Pig Types and Native Java Types</source>
          <target state="translated">Свиньи Типы и родной Java Типы</target>
        </trans-unit>
        <trans-unit id="763ba17130114f0d728d2c9da6a94cee2662e38e" translate="yes" xml:space="preserve">
          <source>Pig allocates a fix amount of memory to store bags and spills to disk as soon as the memory limit is reached. This is very similar to how Hadoop decides when to spill data accumulated by the combiner.</source>
          <target state="translated">Свинья выделяет фиксированный объем памяти для хранения мешков и проливается на диск,как только достигается лимит памяти.Это очень похоже на то,как Hadoop решает,когда разливать данные,накопленные сумматором.</target>
        </trans-unit>
        <trans-unit id="11d7036422db3b031d72375b00787ef03de9aa59" translate="yes" xml:space="preserve">
          <source>Pig allows you to cast the elements of a single-tuple relation into a scalar value. The tuple can be a single-field or multi-field tulple. If the relation contains more than one tuple, however, a runtime error is generated: &quot;Scalar has more than one row in the output&quot;.</source>
          <target state="translated">Свинья позволяет преобразовывать элементы однофазного отношения в скалярное значение.Кортеж может быть однопольным или многопольным тюльпаном.Однако,если отношение содержит более одного кортежа,генерируется ошибка во время выполнения:&quot;Скаляр имеет более одной строки на выходе&quot;.</target>
        </trans-unit>
        <trans-unit id="e6f9793557df721a51315601bec2173f9083f743" translate="yes" xml:space="preserve">
          <source>Pig allows you to transform data in many ways. As a starting point, become familiar with these operators:</source>
          <target state="translated">Свинья позволяет преобразовывать данные различными способами.В качестве отправной точки познакомьтесь с этими операторами:</target>
        </trans-unit>
        <trans-unit id="73604424b7f623aa52673331d4844b85c87dfa4e" translate="yes" xml:space="preserve">
          <source>Pig also provides support for Piggy Bank, a repository for JAVA UDFs. Through Piggy Bank you can access Java UDFs written by other users and contribute Java UDFs that you have written.</source>
          <target state="translated">Piggy Bank также обеспечивает поддержку Piggy Bank,репозитория для UDFs JAVA.Через Piggy Bank вы можете получить доступ к Java UDF,написанным другими пользователями,а также внести написанные вами Java UDF.</target>
        </trans-unit>
        <trans-unit id="f2ee3d36a3dc27b7f962519361eb68284ec849ad" translate="yes" xml:space="preserve">
          <source>Pig bigdecimal/biginteger all map to Orc DECIMAL</source>
          <target state="translated">Свинья большегрудая/большой десятичной/большой десятичной все карты к орку DECIMAL</target>
        </trans-unit>
        <trans-unit id="5a000788cb7b838a8a19059f606035a562b8829b" translate="yes" xml:space="preserve">
          <source>Pig bytearray maps to Orc BINARY</source>
          <target state="translated">Карты байтаррей свиней до оркского Бинария</target>
        </trans-unit>
        <trans-unit id="da371b573e3bcb43e639b2160b5c518b0b7700f1" translate="yes" xml:space="preserve">
          <source>Pig chararray maps to Orc STRING</source>
          <target state="translated">Свиные карты-схемы для орков</target>
        </trans-unit>
        <trans-unit id="7d31dc542bef65e4c473198b27d60992d79d21e7" translate="yes" xml:space="preserve">
          <source>Pig comes with a set of built in functions (the eval, load/store, math, string, bag and tuple functions). Two main properties differentiate built in functions from &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDFs). First, built in functions don't need to be registered because Pig knows where they are. Second, built in functions don't need to be qualified when they are used because Pig knows where to find them.</source>
          <target state="translated">Pig поставляется с набором встроенных функций (функции eval, load / store, math, string, bag и tuple). Два основных свойства отличают встроенные функции от &lt;a href=&quot;udf&quot;&gt;пользовательских функций&lt;/a&gt; (UDF). Во-первых, встроенные функции не нужно регистрировать, потому что Pig знает, где они находятся. Во-вторых, встроенные функции не нужно уточнять, когда они используются, потому что Pig знает, где их найти.</target>
        </trans-unit>
        <trans-unit id="ec76128e5910a6c0dc476b3ee3f3c86bf0e02469" translate="yes" xml:space="preserve">
          <source>Pig currently drops all STORE and DUMP commands. You can tell PigUnit to keep the commands and execute the script:</source>
          <target state="translated">Свинья в данный момент сбрасывает все команды STORE и DUMP.Вы можете попросить PigUnit сохранить команды и выполнить скрипт:</target>
        </trans-unit>
        <trans-unit id="3ad1529318465104bd4cda2ad68472350964be44" translate="yes" xml:space="preserve">
          <source>Pig currently supports ordering on fields with simple types or by tuple designator (*). You cannot order on fields with complex types or by expressions.</source>
          <target state="translated">Свинья в настоящее время поддерживает заказ на поля с простыми типами или по обозначению кортежа (*).Вы не можете упорядочивать поля со сложными типами или по выражениям.</target>
        </trans-unit>
        <trans-unit id="d9f5530e025cc570af7472498b65ad3cdc347893" translate="yes" xml:space="preserve">
          <source>Pig datetime maps to Orc TIMESTAMP</source>
          <target state="translated">Карты даты свиньи к ТИМИРОВАНИЮ Орка</target>
        </trans-unit>
        <trans-unit id="b06635ad448da689ef56ed31a6a822d359c09cd2" translate="yes" xml:space="preserve">
          <source>Pig does not (yet) determine when a field is no longer needed and drop the field from the row. For example, say you have a query like:</source>
          <target state="translated">Свинья не (пока)определяет,когда поле больше не нужно,и выпадает из строки.Например,скажем,у вас есть запрос типа:</target>
        </trans-unit>
        <trans-unit id="4c9e85a8b2e0c0dd60b8ab7196e655a11595d0e5" translate="yes" xml:space="preserve">
          <source>Pig does not provide a loader that supports outer merge joins. You will need to build your own loader to take advantage of this feature.</source>
          <target state="translated">Свинья не предоставляет погрузчик,поддерживающий внешние соединения.Чтобы воспользоваться этой функцией,вам нужно будет построить собственный погрузчик.</target>
        </trans-unit>
        <trans-unit id="78bf7455f2e9a63798376b4de79dec1915e2cc29" translate="yes" xml:space="preserve">
          <source>Pig function names are case sensitive and UPPER CASE.</source>
          <target state="translated">Имена свиноводческих функций чувствительны к регистру и имеют значение ВЫШЕЙ КАССИ.</target>
        </trans-unit>
        <trans-unit id="3497b8a9c4307da9ad98ce7b329893e102bfadf9" translate="yes" xml:space="preserve">
          <source>Pig has implemented a merge join algorithm, or sort-merge join. It works on pre-sorted data, and does not sort data for you. See Conditions, below, for restrictions that apply when using this join algorithm. Pig implements the merge join algorithm by selecting the left input of the join to be the input file for the map phase, and the right input of the join to be the side file. It then samples records from the right input to build an index that contains, for each sampled record, the key(s) the filename and the offset into the file the record begins at. This sampling is done in the first MapReduce job. A second MapReduce job is then initiated, with the left input as its input. Each map uses the index to seek to the appropriate record in the right input and begin doing the join.</source>
          <target state="translated">Свинья реализовала алгоритм слияния соединений,или сортировочного соединения.Он работает на предварительно отсортированных данных и не сортирует данные за вас.Ограничения,которые действуют при использовании этого алгоритма слияния,см.ниже в разделе Условия.Pig реализует алгоритм слияния соединений,выбирая левый входной файл соединения как входной файл для фазы карты,а правый входной файл соединения как боковой файл.Затем он сэмплирует записи с правого входа,чтобы построить индекс,содержащий для каждой сэмплированной записи ключ(ы),имя файла и смещение в файл,с которого начинается запись.Эта выборка выполняется в первом задании MapReduce.Затем инициируется второе задание MapReduce с левым входом в качестве входа.Каждая карта использует индекс для поиска соответствующей записи на правом входе и начала выполнения соединения.</target>
        </trans-unit>
        <trans-unit id="8c465a5a14c5bf2028d4313b2065c52ed6b1f407" translate="yes" xml:space="preserve">
          <source>Pig has six execution modes or exectypes:</source>
          <target state="translated">Свинья имеет шесть режимов исполнения или исполнительных типов:</target>
        </trans-unit>
        <trans-unit id="abe1a7ac5158db2e5d49b5c0bf1750141f4b1162" translate="yes" xml:space="preserve">
          <source>Pig invokes all types of Hive UDF, including UDF, GenericUDF, UDAF, GenericUDAF and GenericUDTF. Depending on the Hive UDF you want to use, you need to declare it in Pig with HiveUDF(handles UDF and GenericUDF), HiveUDAF(handles UDAF and GenericUDAF), HiveUDTF(handles GenericUDTF).</source>
          <target state="translated">Свинья ссылается на все типы ульев UDF,включая UDF,GenericUDF,UDAF,GenericUDAF и GenericUDTF.В зависимости от Hive UDF,который вы хотите использовать,вы должны объявить его в Pig with HiveUDF(handleles UDF и GenericUDF),HiveUDAF(handleles UDAF и GenericUDAF),HiveUDTF(handleles GenericUDTF).</target>
        </trans-unit>
        <trans-unit id="ab624fcbf738a4b8acd080c76087b67d14708f02" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification. If any of the input parameters are null or if an insufficient number of parameters are supplied, NULL is returned.</source>
          <target state="translated">Свинья может обрабатывать результаты иначе,чем указано в спецификации Java API.Если любой из входных параметров равен нулю или поставляется недостаточное количество параметров,возвращается NULL.</target>
        </trans-unit>
        <trans-unit id="5a922bbffcd1b5032fad1768816830c613580833" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification:</source>
          <target state="translated">Свинья может обрабатывать результаты иначе,чем указано в спецификации Java API:</target>
        </trans-unit>
        <trans-unit id="9471d85941c65173fff582e14b71cf4f967ea913" translate="yes" xml:space="preserve">
          <source>Pig provides constant representations for all data types except bytearrays.</source>
          <target state="translated">Свинья обеспечивает постоянные представления для всех типов данных,кроме байтерей.</target>
        </trans-unit>
        <trans-unit id="87c574c013f523193858b45a84f91642023a8f10" translate="yes" xml:space="preserve">
          <source>Pig provides extensive support for user defined functions (UDFs) as a way to specify custom processing. Pig UDFs can currently be implemented in six languages: Java, Jython, Python, JavaScript, Ruby and Groovy.</source>
          <target state="translated">Pig предоставляет обширную поддержку для определенных пользователем функций (UDF),как способ указать пользовательскую обработку.В настоящее время UDF-функции Pig могут быть реализованы на шести языках:Java,Jython,Python,JavaScript,Ruby и Groovy.</target>
        </trans-unit>
        <trans-unit id="ceda33dea4ba3f881c49648249091f447f7a880a" translate="yes" xml:space="preserve">
          <source>Pig provides shortcuts for the frequently used debugging operators (DUMP, DESCRIBE, EXPLAIN, ILLUSTRATE). These shortcuts can be used in Grunt shell or within pig scripts. Following are the shortcuts supported by pig</source>
          <target state="translated">Pig предоставляет ярлыки для часто используемых операторов отладки (DUMP,DESCRIBE,EXPLAIN,ILLUSTRATE).Эти ярлыки могут быть использованы в панцире Grunt или в скриптах для свиней.Ниже приведены ярлыки,поддерживаемые свиньями</target>
        </trans-unit>
        <trans-unit id="8e8994ca2f5728663eb94fb005036ffcd6396df7" translate="yes" xml:space="preserve">
          <source>Pig provides the ability to register a listener to receive event notifications during the execution of a script. Events include MapReduce plan creation, script launch, script progress, script completion, job submit, job start, job completion and job failure.</source>
          <target state="translated">Pig предоставляет возможность зарегистрировать слушателя для получения уведомлений о событиях во время выполнения скрипта.События включают в себя создание плана MapReduce,запуск скрипта,ход выполнения скрипта,завершение работы скрипта,подача заявки,начало работы,завершение работы и сбой в работе.</target>
        </trans-unit>
        <trans-unit id="aa6596e8905b3938c3700ea230f899c89f11a17f" translate="yes" xml:space="preserve">
          <source>Pig reserved keywords are listed here.</source>
          <target state="translated">Ключевые слова,зарезервированные за свиньями,перечислены здесь.</target>
        </trans-unit>
        <trans-unit id="8ee530c88eb069019e89fb162c7af7e0491d6334" translate="yes" xml:space="preserve">
          <source>Pig scripts allow you to pass values to parameters using &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;parameter substitution&lt;/a&gt;.</source>
          <target state="translated">Скриптовые сценарии позволяют передавать значения в параметры с помощью &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;подстановки параметров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7af5953cb1970013fe65b12593533955cde08d36" translate="yes" xml:space="preserve">
          <source>Pig scripts could contain multiple STORE statements. There are cases when one would like to avoid writing to the same output location. Pig provides admins/script writers with a property to check if multiple STORE statements make an attempt to write to the same output directory. And fail fast letting the user know of the same.</source>
          <target state="translated">Свиные скрипты могут содержать несколько утверждений STORE.Бывают случаи,когда хочется избежать записи в одно и то же место вывода.Pig предоставляет администраторам/сценаристам свойство проверять,не делают ли несколько операторов STORE попытки записи в одну и ту же выходную директорию.И не удается быстро дать пользователю знать то же самое.</target>
        </trans-unit>
        <trans-unit id="f4f54e08d6f27a21247ba6b73114b665162748d1" translate="yes" xml:space="preserve">
          <source>Pig stores the intermediate data generated between MapReduce jobs in a temporary location on HDFS. This location must already exist on HDFS prior to use. This location can be configured using the pig.temp.dir property. The property's default value is &quot;/tmp&quot; which is the same as the hardcoded location in Pig 0.7.0 and earlier versions.</source>
          <target state="translated">Свинья хранит промежуточные данные,сгенерированные между заданиями MapReduce во временном месте на HDFS.Это местоположение должно уже существовать на HDFS перед использованием.Это местоположение можно настроить,используя свойство pig.temp.dir.Значение свойства по умолчанию равно &quot;/tmp&quot;,что соответствует жестко закодированному местоположению в версии Pig 0.7.0 и более ранних версиях.</target>
        </trans-unit>
        <trans-unit id="714c7646d7666c8d22f8f121acb63f13797f2c2b" translate="yes" xml:space="preserve">
          <source>Pig string functions have an extra, first parameter: the string to which all the operations are applied.</source>
          <target state="translated">Функции &quot;Свиная строка&quot; имеют дополнительный,первый параметр:строку,к которой применяются все операции.</target>
        </trans-unit>
        <trans-unit id="d463cd387da41f017a06eeec2ec8c8e1a5cb86d2" translate="yes" xml:space="preserve">
          <source>Pig supports a number of Java properties that you can use to customize Pig behavior. You can retrieve a list of the properties using the &lt;a href=&quot;cmds#help&quot;&gt;help properties&lt;/a&gt; command. All of these properties are optional; none are required.</source>
          <target state="translated">Pig поддерживает ряд свойств Java, которые можно использовать для настройки поведения Pig. Вы можете получить список свойств с &lt;a href=&quot;cmds#help&quot;&gt;помощью&lt;/a&gt; команды help properties . Все эти свойства являются необязательными; ничего не требуется.</target>
        </trans-unit>
        <trans-unit id="baff641180058647b74777d2576baee8385ad92c" translate="yes" xml:space="preserve">
          <source>Pig supports running scripts (and Jar files) that are stored in HDFS, Amazon S3, and other distributed file systems. The script's full location URI is required (see &lt;a href=&quot;basic#register&quot;&gt;REGISTER&lt;/a&gt; for information about Jar files). For example, to run a Pig script on HDFS, do the following:</source>
          <target state="translated">Pig поддерживает запуск скриптов (и файлов Jar), ​​которые хранятся в HDFS, Amazon S3 и других распределенных файловых системах. Требуется полный URI-адрес скрипта ( для получения информации о файлах Jar см. &lt;a href=&quot;basic#register&quot;&gt;РЕГИСТРАЦИЯ&lt;/a&gt; ). Например, чтобы запустить сценарий Pig в HDFS, выполните следующие действия:</target>
        </trans-unit>
        <trans-unit id="93b8509eca6765e62d9376104cd05a29add5f154" translate="yes" xml:space="preserve">
          <source>Pig supports various &lt;a href=&quot;perf#optimization-rules&quot;&gt;optimization rules&lt;/a&gt; which are turned on by default. Become familiar with these rules.</source>
          <target state="translated">Свинья поддерживает различные &lt;a href=&quot;perf#optimization-rules&quot;&gt;правила оптимизации,&lt;/a&gt; которые включены по умолчанию. Ознакомьтесь с этими правилами.</target>
        </trans-unit>
        <trans-unit id="7db2788da4d3cb08c1ef2ff25689ec2ee8056211" translate="yes" xml:space="preserve">
          <source>Pig supports various optimization rules, all of which are enabled by default. To disable all or specific optimizations, use one or more of the following methods. Note some optimization rules are mandatory and cannot be disabled.</source>
          <target state="translated">Свинья поддерживает различные правила оптимизации,все из которых включены по умолчанию.Чтобы отключить все или отдельные оптимизации,используйте один или несколько из следующих методов.Обратите внимание,что некоторые правила оптимизации являются обязательными и не могут быть отключены.</target>
        </trans-unit>
        <trans-unit id="dec5b4fd96103af2122e2313ddd5abca5934ce71" translate="yes" xml:space="preserve">
          <source>Pig to Groovy</source>
          <target state="translated">Свинья в Груви</target>
        </trans-unit>
        <trans-unit id="ffd9764afd639133c7dcafbb3bfb8b5a0f6b5c57" translate="yes" xml:space="preserve">
          <source>Pig uses BinStorage to load and store the temporary data that is generated between multiple MapReduce jobs.</source>
          <target state="translated">Pig использует BinStorage для загрузки и хранения временных данных,которые генерируются между несколькими заданиями MapReduce.</target>
        </trans-unit>
        <trans-unit id="e6f964ef2f2e1463a5575b90549505104722c310" translate="yes" xml:space="preserve">
          <source>Pig uses type information for validation and performance. It is important for UDFs to participate in type propagation. Our UDFs generally make no effort to communicate their output schema to Pig. This is because Pig can usually figure out this information by using Java's &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html&quot;&gt; Reflection&lt;/a&gt;. If your UDF returns a scalar or a map, no work is required. However, if your UDF returns a tuple or a bag (of tuples), it needs to help Pig figure out the structure of the tuple.</source>
          <target state="translated">Свинья использует информацию о типе для проверки и производительности. Для UDF важно участвовать в распространении типов. Наши пользовательские функции обычно не прилагают усилий для передачи своей схемы вывода Pig. Это потому, что Свинья обычно может выяснить эту информацию с помощью &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html&quot;&gt;отражения&lt;/a&gt; Java . Если ваш UDF возвращает скаляр или карту, никаких действий не требуется. Однако, если ваш UDF возвращает кортеж или сумку (с кортежами), он должен помочь Пиг понять структуру кортежа.</target>
        </trans-unit>
        <trans-unit id="b6c4f473278cb2c4d79b79244d369de45127e72f" translate="yes" xml:space="preserve">
          <source>Pig will look for the #!/usr/bin/python line in the script.</source>
          <target state="translated">Свинья будет искать в скрипте строку #!/usr/bin/python.</target>
        </trans-unit>
        <trans-unit id="e77ea84c3c6071688fbeecc5c58ee3a6a8b11e23" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.groovy extension in the script.</source>
          <target state="translated">Свинья будет искать расширение *.groovy в скрипте.</target>
        </trans-unit>
        <trans-unit id="0364a2ce40f5c70f5452cfa0554c3480442e1323" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.js extension in the script.</source>
          <target state="translated">Свинья будет искать расширение *.js в скрипте.</target>
        </trans-unit>
        <trans-unit id="91634384ed9e6b31da4cf199ee9633830ca9b602" translate="yes" xml:space="preserve">
          <source>Pig will not auto-ship files in the following system directories (this is determined by executing 'which &amp;lt;file&amp;gt;' command).</source>
          <target state="translated">Pig не будет автоматически отправлять файлы в следующие системные каталоги (это определяется выполнением команды which &amp;lt;file&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="25b2234668fa28c694ddf8954f0db6fd297cd55d" translate="yes" xml:space="preserve">
          <source>PigDump</source>
          <target state="translated">PigDump</target>
        </trans-unit>
        <trans-unit id="cd0f4a6c71f7d548ed016babe0f1794757d97253" translate="yes" xml:space="preserve">
          <source>PigDump stores data as tuples in human-readable UTF-8 format.</source>
          <target state="translated">PigDump хранит данные в виде кортежей в читаемом человеком формате UTF-8.</target>
        </trans-unit>
        <trans-unit id="076d83430955260169fb65f99eac100421155024" translate="yes" xml:space="preserve">
          <source>PigDump()</source>
          <target state="translated">PigDump()</target>
        </trans-unit>
        <trans-unit id="7e5a4069b9fdb2979478c1ee4fdbc3e2c6ad6bac" translate="yes" xml:space="preserve">
          <source>PigProgressNotificationListener Object</source>
          <target state="translated">PigProgressNotificationListener Объект</target>
        </trans-unit>
        <trans-unit id="3b203b52f09d0ae21512293305adfa539797f50a" translate="yes" xml:space="preserve">
          <source>PigRunner API</source>
          <target state="translated">API PigRunner</target>
        </trans-unit>
        <trans-unit id="c591d5d2fae917bd8241460a851795d39ef7fd4d" translate="yes" xml:space="preserve">
          <source>PigServer Interface</source>
          <target state="translated">интерфейс PigServer</target>
        </trans-unit>
        <trans-unit id="2f322dd1e3ab68730e8f4ea4e48514c5d2b0e8fe" translate="yes" xml:space="preserve">
          <source>PigStats</source>
          <target state="translated">PigStats</target>
        </trans-unit>
        <trans-unit id="09ef3422b57b20584bb4bd1065c0d793e6c60aa6" translate="yes" xml:space="preserve">
          <source>PigStats Object</source>
          <target state="translated">объект PigStats</target>
        </trans-unit>
        <trans-unit id="8c9ea42da56c5bce11828868d9a6b3bd2007fda6" translate="yes" xml:space="preserve">
          <source>PigStats is now an abstract class. (PigStats as it was before has become SimplePigStats.)</source>
          <target state="translated">PigStats теперь абстрактный класс.(PigStats,как и раньше,стал SimplePigStats).</target>
        </trans-unit>
        <trans-unit id="25cdca4514b647129134787cd149f41de99035d4" translate="yes" xml:space="preserve">
          <source>PigStorage</source>
          <target state="translated">PigStorage</target>
        </trans-unit>
        <trans-unit id="189d56b69a7325ea9365151a6fd186619f7dba18" translate="yes" xml:space="preserve">
          <source>PigStorage is the default function used by Pig to load/store the data. PigStorage supports structured text files (in human-readable UTF-8 format) in compressed or uncompressed form (see &lt;a href=&quot;#handling-compression&quot;&gt;Handling Compression&lt;/a&gt;). All Pig &lt;a href=&quot;basic#data-types&quot;&gt;data types&lt;/a&gt; (both simple and complex) can be read/written using this function. The input data to the load can be a file, a directory or a glob.</source>
          <target state="translated">PigStorage - это функция по умолчанию, используемая Pig для загрузки / хранения данных. PigStorage поддерживает структурированные текстовые файлы (в удобочитаемом формате UTF-8) в сжатом или несжатом виде (см. &lt;a href=&quot;#handling-compression&quot;&gt;Обработка сжатия&lt;/a&gt; ). Все &lt;a href=&quot;basic#data-types&quot;&gt;типы данных&lt;/a&gt; Pig (простые и сложные) могут быть прочитаны / записаны с помощью этой функции. Входные данные для загрузки могут быть файлом, каталогом или глобусом.</target>
        </trans-unit>
        <trans-unit id="db2e71c500f2a58ecf6be6205a6d15e6c21c547c" translate="yes" xml:space="preserve">
          <source>PigStorage is the default load function for the LOAD operator. In this example the is not null operator is used to filter names with null values.</source>
          <target state="translated">PigStorage является функцией загрузки по умолчанию для оператора LOAD.В данном примере оператор не является нулевым используется для фильтрации имен с нулевыми значениями.</target>
        </trans-unit>
        <trans-unit id="851b7752cd0d7ce793cb4e4ca346b699d8bf7ba9" translate="yes" xml:space="preserve">
          <source>PigStorage( [field_delimiter] , ['options'] )</source>
          <target state="translated">PigStorage([field_delimiter],['options'])</target>
        </trans-unit>
        <trans-unit id="0d3b09a00028b253cd0f1f6c7b23a76114298a8a" translate="yes" xml:space="preserve">
          <source>PigUnit</source>
          <target state="translated">PigUnit</target>
        </trans-unit>
        <trans-unit id="dbc328ccebde1c387467a71ae41410ef063708a6" translate="yes" xml:space="preserve">
          <source>PigUnit Example</source>
          <target state="translated">Пример свиньи</target>
        </trans-unit>
        <trans-unit id="e58deab3203c61b8478e84f609cbbfd6830c6870" translate="yes" xml:space="preserve">
          <source>PigUnit also runs in Pig's mapreduce/tez/tez_local mode. Mapreduce/Tez mode requires you to use a Hadoop cluster and HDFS installation. It is enabled when the Java system property pigunit.exectype is set to specific values (mr/tez/tez_local): e.g. -Dpigunit.exectype=mr or System.getProperties().setProperty(&quot;pigunit.exectype&quot;, &quot;mr&quot;), which means PigUnit will run in mr mode. The cluster you select to run mr/tez test must be specified in the CLASSPATH (similar to the HADOOP_CONF_DIR variable).</source>
          <target state="translated">PigUnit также работает в режиме Pig's mapreduce/tez/tez_local.Режим Mapreduce/Tez требует использования кластера Hadoop и установки HDFS.Он включается,когда свойство Java-системы pigunit.exectype установлено в определенные значения (mr/tez/tez_local):например,-Dpigunit.exectype=mr или System.getProperties().setProperty(&quot;pigunit.exectype&quot;,&quot;mr&quot;),что означает,что PigUnit будет работать в режиме mr.Кластер,выбранный для запуска теста mr/tez,должен быть указан в CLASSPATH (аналогично переменной HADOOP_CONF_DIR).</target>
        </trans-unit>
        <trans-unit id="5efb4aafd77f51485d9e22a5331f73c21b84e2d1" translate="yes" xml:space="preserve">
          <source>PigUnit is a simple xUnit framework that enables you to easily test your Pig scripts. With PigUnit you can perform unit testing, regression testing, and rapid prototyping. No cluster set up is required if you run Pig in local mode.</source>
          <target state="translated">PigUnit-это простой xUnit-фреймворк,позволяющий легко тестировать ваши скрипты Pig.С помощью PigUnit вы можете выполнять юнит-тестирование,регрессионное тестирование и быстрое создание прототипов.Настройка кластера не требуется,если вы запускаете Pig в локальном режиме.</target>
        </trans-unit>
        <trans-unit id="e825c7a9656dd5933b89b6587e34170d6f8b825d" translate="yes" xml:space="preserve">
          <source>PigUnit runs in Pig's local mode by default. Local mode is fast and enables you to use your local file system as the HDFS cluster. Local mode does not require a real cluster but a new local one is created each time.</source>
          <target state="translated">По умолчанию PigUnit запускается в локальном режиме PigUnit.Локальный режим быстр и позволяет использовать локальную файловую систему в качестве кластера HDFS.Локальный режим не требует наличия реального кластера,но каждый раз создаётся новый локальный.</target>
        </trans-unit>
        <trans-unit id="51485a7e9c11278ddb30a38747984651921c7357" translate="yes" xml:space="preserve">
          <source>Piggy Bank</source>
          <target state="translated">Свиная банка</target>
        </trans-unit>
        <trans-unit id="94706352a7655c2f04cd6d5b3c48f2991946cce6" translate="yes" xml:space="preserve">
          <source>Piggy Bank is a place for Pig users to share the Java UDFs they have written for use with Pig. The functions are contributed &quot;as-is.&quot; If you find a bug in a function, take the time to fix it and contribute the fix to Piggy Bank. If you don't find the UDF you need, take the time to write and contribute the function to Piggy Bank.</source>
          <target state="translated">Свинобанк-это место,где пользователи Свиньи могут поделиться с Свиньями написанными ими Java UDF.Функции предоставляются &quot;как есть&quot;.Если вы обнаружили ошибку в функции,найдите время,чтобы исправить ее и внести исправление в Хрюшачью банку.Если вы не нашли UDF,который вам нужен,найдите время,чтобы написать и внести функцию в Хрюшачью банку.</target>
        </trans-unit>
        <trans-unit id="548bf24c348f6ecb39a696616e88c2bdb8fc7c48" translate="yes" xml:space="preserve">
          <source>Piggybank now contains a load function called org.apache.pig.piggybank.storage.IndexedStorage that is a derivation of PigStorage and implements IndexedLoadFunc. This is the only loader included in the standard Pig distribution that can be used for merge-sparse join.</source>
          <target state="translated">Piggybank теперь содержит функцию загрузки под названием org.apache.pig.piggybank.storage.IndexedStorage,которая является производной PigStorage и реализует IndexedLoadFunc.Это единственный загрузчик,включенный в стандартный дистрибутив Piggybank,который может быть использован для слияния разреженных соединений.</target>
        </trans-unit>
        <trans-unit id="80e46ef91cf972b79cfeb37c8c0b0f1a663a2b3c" translate="yes" xml:space="preserve">
          <source>Place your java code in the directory that makes sense for your function. The directory structure currently has two levels: (1) function type, as described in &lt;a href=&quot;#piggbank-access&quot;&gt;Accessing Functions&lt;/a&gt;, and (2) function subtype, for some of the types (like math or string for eval functions). If you think your function requires a new subtype, feel free to add one.</source>
          <target state="translated">Поместите свой код Java в каталог, который имеет смысл для вашей функции. Структура каталогов в настоящее время имеет два уровня: (1) тип функции, как описано в &lt;a href=&quot;#piggbank-access&quot;&gt;разделе &amp;laquo;Доступ к функциям&amp;raquo;&lt;/a&gt; , и (2) подтип функции, для некоторых типов (например, математика или строка для функций eval). Если вы думаете, что ваша функция требует нового подтипа, не стесняйтесь добавлять его.</target>
        </trans-unit>
        <trans-unit id="45b51fb4489a0001750d8a0d80a1eabd943fd26b" translate="yes" xml:space="preserve">
          <source>Please note that all parameters must be resolved during bind. Having unbound parameters while running your script is an error. Also note that even if your script is fully defined during compile, bind without parameters still must be called.</source>
          <target state="translated">Обратите внимание,что все параметры должны быть разрешены во время привязки.Наличие несвязанных параметров во время выполнения скрипта является ошибкой.Также обратите внимание,что даже если ваш скрипт полностью определен во время компиляции,все равно должна быть вызвана привязка без параметров.</target>
        </trans-unit>
        <trans-unit id="6a06967c386bbcf581bbbff0858c5a65621763d0" translate="yes" xml:space="preserve">
          <source>Please note that the script above can be made more efficient by performing filtering before the GROUP statement:</source>
          <target state="translated">Пожалуйста,обратите внимание,что вышеприведенный скрипт можно сделать более эффективным,выполнив фильтрацию перед заявлением GROUP:</target>
        </trans-unit>
        <trans-unit id="1e1fc2184a267b82bd60f72a9ca2cc38f005be8b" translate="yes" xml:space="preserve">
          <source>Please note the following:</source>
          <target state="translated">Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="1e0f495264f489ed260b938fbaf923286b89db5c" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;http://joda-time.sourceforge.net/timezones.html&quot;&gt;the Joda-Time doc&lt;/a&gt; for available timezone IDs.</source>
          <target state="translated">Пожалуйста, смотрите документацию &lt;a href=&quot;http://joda-time.sourceforge.net/timezones.html&quot;&gt;Joda-Time&lt;/a&gt; для доступных идентификаторов часовых поясов.</target>
        </trans-unit>
        <trans-unit id="c3414cc34b87b848682458107bbe3817781eebf0" translate="yes" xml:space="preserve">
          <source>PluckTuple</source>
          <target state="translated">PluckTuple</target>
        </trans-unit>
        <trans-unit id="5d6a4911520319a2d3e4452f20e0a79aefaaa5b1" translate="yes" xml:space="preserve">
          <source>Point $HADOOPDIR to the directory that contains the hadoop-site.xml file. Example:</source>
          <target state="translated">Наведите $HADOOPDIR на каталог,содержащий файл hasoop-site.xml.Пример:</target>
        </trans-unit>
        <trans-unit id="dbec33ded970d7645cff3e7a90ffcb1db17bf2b3" translate="yes" xml:space="preserve">
          <source>Positional notation (generated by system)</source>
          <target state="translated">Позиционная нотация (генерируемая системой)</target>
        </trans-unit>
        <trans-unit id="7a1a9c9263f88ba37537ce91842a5071d4c86b03" translate="yes" xml:space="preserve">
          <source>Positional notation is generated by the system. Positional notation is indicated with the dollar sign ($) and begins with zero (0); for example, $0, $1, $2.</source>
          <target state="translated">Позиционная нотация генерируется системой.Позиционная нотация обозначается знаком доллара ($)и начинается с нуля (0);например,$0,$1,$2.</target>
        </trans-unit>
        <trans-unit id="470b7c6b31d52098c05a7c0eb3537e05b562b162" translate="yes" xml:space="preserve">
          <source>Possible name (assigned by you using a schema)</source>
          <target state="translated">Возможное имя (назначенное Вами по схеме)</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="c62fe3da66de5300e411627aa04bcf8aba54c94e" translate="yes" xml:space="preserve">
          <source>Precedence for parameters is as follows, from highest to lowest:</source>
          <target state="translated">Приоритет для параметров следующий,от самого высокого до самого низкого:</target>
        </trans-unit>
        <trans-unit id="aa06e8fd282659ac6d432bb0788f9503111f1ec3" translate="yes" xml:space="preserve">
          <source>Predicate pushdown</source>
          <target state="translated">Predicate pushdown</target>
        </trans-unit>
        <trans-unit id="67219f57bcad6686b5aafd1fa4c0f49cde92f4ad" translate="yes" xml:space="preserve">
          <source>PredicatePushdownOptimizer</source>
          <target state="translated">PredicatePushdownOptimizer</target>
        </trans-unit>
        <trans-unit id="8adf8f822b81878db822737e2402a291fabdb7a0" translate="yes" xml:space="preserve">
          <source>Prefer DISTINCT over GROUP BY/GENERATE</source>
          <target state="translated">Предпочтителен РАЗРЕШЕНИЕ,а не ГРУППА ГЕНЕРАЛЬНОГО ХОЗЯЙСТВА.</target>
        </trans-unit>
        <trans-unit id="71ee3d895930077b420791fb640e0fcf277eb35a" translate="yes" xml:space="preserve">
          <source>Preprocessor statement included in a Pig script.</source>
          <target state="translated">Препроцессорный оператор,включенный в скрипт Pig.</target>
        </trans-unit>
        <trans-unit id="0e7683a0a1b3a8c7fba74716254c107f2f5e90e3" translate="yes" xml:space="preserve">
          <source>Prerequisite: Tez requires the tez tarball to be available in hdfs while running a job on the cluster and a tez-site.xml with tez.lib.uris setting pointing to that hdfs location in classpath. Copy the tez tarball to hdfs and add the tez conf directory($TEZ_HOME/conf) containing tez-site.xml to environmental variable &quot;PIG_CLASSPATH&quot; if pig on tez fails with &quot;tez.lib.uris is not defined&quot;. This is required by the Apache Pig distribution.</source>
          <target state="translated">Предпосылка:Tez требует,чтобы tez тарбол был доступен в hdfs во время выполнения задания на кластере и tez-site.xml с настройкой tez.lib.uris,указывающей на местоположение hdfs в classpath.Скопируйте tez tarball в hdfs и добавьте каталог tez conf($TEZ_HOME/conf),содержащий tez-site.xml,в переменную окружения &quot;PIG_CLASSPATH&quot;,если при работе с tez &quot;tez.lib.uris не определен&quot;.Это требуется в дистрибутиве Apache Pig.</target>
        </trans-unit>
        <trans-unit id="68c4f7f4e32d071edfecdccbc2955d1848fe5d3f" translate="yes" xml:space="preserve">
          <source>Previous Relation Shortcut</source>
          <target state="translated">Предыдущий краткий обзор отношений</target>
        </trans-unit>
        <trans-unit id="91668392239b2ed6e082ab66f5115752a3228d5d" translate="yes" xml:space="preserve">
          <source>Prints a list of Pig commands or properties.</source>
          <target state="translated">Печатает список команд или свойств Pig.</target>
        </trans-unit>
        <trans-unit id="64172510397f433c399b5d42e0b1269626b1a958" translate="yes" xml:space="preserve">
          <source>Processing Order and Precedence</source>
          <target state="translated">Порядок обработки и приоритет</target>
        </trans-unit>
        <trans-unit id="985f018300a3bcf017393d943a21bd0b142ab797" translate="yes" xml:space="preserve">
          <source>Processing input (either user input or intermediate input) from multiple small files can be inefficient because a separate map has to be created for each file. Pig can now combined small files so that they are processed as a single map.</source>
          <target state="translated">Обработка входных данных (либо пользовательского ввода,либо промежуточного ввода)из нескольких небольших файлов может быть неэффективной,поскольку для каждого файла должна быть создана отдельная карта.Свиньи теперь могут объединять небольшие файлы так,чтобы они обрабатывались как одна карта.</target>
        </trans-unit>
        <trans-unit id="068b6f370b0ca1593f3b3fbac750583d9d7d8efa" translate="yes" xml:space="preserve">
          <source>Processing small mapreduce jobs on hadoop cluster could be slow as it has overhead of job startup and job scheduling. For jobs with small input data, pig can convert them to run them as in-process mapreduce with hadoop's local mode. If pig.auto.local.enabled flag is set to true, pig will convert mapreduce jobs with input data less than pig.auto.local.input.maxbytes (100MB by default) to run in local mode, provided the number of reducers required by the job are less than or equal to 1. Note, jobs converted to run in local mode load and store data from HDFS, so any job in the pig workflow(dag) could be converted to run in local mode without affecting its downstream jobs.</source>
          <target state="translated">Обработка небольших картографических заданий на кластере хадуп может быть медленной,так как она связана с накладными расходами на запуск заданий и планирование заданий.Для заданий с небольшими входными данными свиньи могут преобразовывать их для запуска в качестве карт-продукции в процессе с локальным режимом хадуп.Если флаг pig.auto.local.enabled установлен в true,то pig будет преобразовывать задания с входными данными меньше,чем pig.auto.local.input.maxbytes (100МБ по умолчанию)для запуска в локальном режиме,при условии,что количество редукторов,требуемое для задания,меньше или равно 1.Обратите внимание,задания,преобразованные для работы в локальном режиме,загружаются и хранят данные из HDFS,поэтому любое задание в свиноводческом рабочем процессе (dag)может быть преобразовано для работы в локальном режиме без влияния на его задания,расположенные ниже по потоку.</target>
        </trans-unit>
        <trans-unit id="1d28a282560bb759052a3e6e6fcd13088d888408" translate="yes" xml:space="preserve">
          <source>Project Early and Often</source>
          <target state="translated">Ранний и частый проект</target>
        </trans-unit>
        <trans-unit id="9155c425ec77a3089191509a98c385937bbb07a9" translate="yes" xml:space="preserve">
          <source>Project-Range Expressions</source>
          <target state="translated">Выражения проектных расстояний</target>
        </trans-unit>
        <trans-unit id="549f47352730051b89a49356a5aa47d12e349987" translate="yes" xml:space="preserve">
          <source>Project-range ( .. ) expressions can be used to project a range of columns from input. For example:</source>
          <target state="translated">Выражения диапазона проектирования(...)могут быть использованы для проектирования ряда столбцов из входных данных.Например:</target>
        </trans-unit>
        <trans-unit id="badce2f5aad822deab06383975c71e3c2b6f9be2" translate="yes" xml:space="preserve">
          <source>Project-range can be used in all cases where the &lt;a href=&quot;#sexp&quot;&gt;star expression&lt;/a&gt; ( * ) is allowed.</source>
          <target state="translated">Project-range может использоваться во всех случаях, когда разрешено &lt;a href=&quot;#sexp&quot;&gt;звездное выражение&lt;/a&gt; (*).</target>
        </trans-unit>
        <trans-unit id="5c69909c9dc93448f96162044d8b25b4d837f86e" translate="yes" xml:space="preserve">
          <source>Project-range can be used in the following statements: &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt;, &lt;a href=&quot;#join-inner&quot;&gt;JOIN&lt;/a&gt;, &lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt;, &lt;a href=&quot;#cogroup&quot;&gt;COGROUP&lt;/a&gt;, and &lt;a href=&quot;#order-by&quot;&gt;ORDER BY&lt;/a&gt; (also when ORDER BY is used within a nested FOREACH block).</source>
          <target state="translated">Диапазон проекта можно использовать в следующих инструкциях: &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt; , &lt;a href=&quot;#join-inner&quot;&gt;JOIN&lt;/a&gt; , &lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt; , &lt;a href=&quot;#cogroup&quot;&gt;COGROUP&lt;/a&gt; и &lt;a href=&quot;#order-by&quot;&gt;ORDER BY&lt;/a&gt; (также когда ORDER BY используется во вложенном блоке FOREACH).</target>
        </trans-unit>
        <trans-unit id="fa33f39f5421ef81d13a830fb4443370104ee3c9" translate="yes" xml:space="preserve">
          <source>Projections (dimensions) of the relation. Supports field, star and project-range expressions.</source>
          <target state="translated">Проекции (размеры)соотношения.Поддерживает выражения поля,звезды и диапазона проекта.</target>
        </trans-unit>
        <trans-unit id="2ec840bd9176cde5b4141fc791989284f3e9ed0c" translate="yes" xml:space="preserve">
          <source>Prune the loader to only load necessary columns. The performance gain is more significant if the corresponding loader support column pruning and only load necessary columns (See LoadPushDown.pushProjection). Otherwise, ColumnMapKeyPrune will insert a ForEach statement right after loader.</source>
          <target state="translated">Настройте погрузчик только на загрузку необходимых колонн.Прирост производительности будет более существенным,если соответствующий загрузчик поддерживает обрезку колонн и загружает только необходимые колонки (см.LoadPushDown.pushProjection).В противном случае,ColumnMapKeyPrune вставит ForEach сразу после загрузчика.</target>
        </trans-unit>
        <trans-unit id="c46a0e7afbefa23c27c29686d94920c8b40fe658" translate="yes" xml:space="preserve">
          <source>Prune unused column as soon as possible. In addition to prune the loader in ColumnMapKeyPrune, we can prune a column as soon as it is not used in the rest of the script</source>
          <target state="translated">Удалите неиспользованную колонку как можно быстрее.В дополнение к подрезанию загрузчика в ColumnMapKeyPrune,мы можем подрезать колонку,как только она не будет использована в остальной части скрипта</target>
        </trans-unit>
        <trans-unit id="c7931337f31f75950cb4c2cdebc73bd2f84097cc" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader.</source>
          <target state="translated">Введите состояние фильтра в погрузчик.</target>
        </trans-unit>
        <trans-unit id="fc4197eb949bc0da0a0aeedd23a8819a37dc696c" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader. Different than PartitionFilterOptimizer, the filter condition will be evaluated in Pig. In other words, the filter condition pushed to the loader is a hint. Loader might still load records which does not satisfy filter condition.</source>
          <target state="translated">Введите состояние фильтра в погрузчик.В отличие от PartitionFilterOptimizer,условие фильтра будет оценено в Pig.Другими словами,условие фильтра,переданное загрузчику,является подсказкой.Загрузчик все равно может загрузить записи,которые не удовлетворяют условию фильтра.</target>
        </trans-unit>
        <trans-unit id="c6019407474c8f4cd672f2782447a068a3eff87a" translate="yes" xml:space="preserve">
          <source>PushDownForEachFlatten</source>
          <target state="translated">PushDownForEachFlatten</target>
        </trans-unit>
        <trans-unit id="00d23fd27f64adf999e795e338babf1919b5159b" translate="yes" xml:space="preserve">
          <source>PushUpFilter</source>
          <target state="translated">PushUpFilter</target>
        </trans-unit>
        <trans-unit id="9e91ff7fcaea97ed1e629c1ea1dd3a3be1f9a961" translate="yes" xml:space="preserve">
          <source>Queries that can take advantage of the combiner generally ran much faster (sometimes several times faster) than the versions that don't. The latest code significantly improves combiner usage; however, you need to make sure you do your part. If you have a UDF that works on grouped data and is, by nature, algebraic (meaning their computation can be decomposed into multiple steps) make sure you implement it as such. For details on how to write algebraic UDFs, see &lt;a href=&quot;udf#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;.</source>
          <target state="translated">Запросы, которые могут использовать объединитель, обычно выполняются намного быстрее (иногда в несколько раз быстрее), чем версии, которые этого не делают. Последний код значительно улучшает использование комбайнера; Тем не менее, вы должны убедиться, что вы делаете свою часть. Если у вас есть UDF, который работает с сгруппированными данными и по своей природе является алгебраическим (то есть их вычисления могут быть разбиты на несколько этапов), убедитесь, что вы реализуете его как таковой. Для получения подробной информации о том, как писать алгебраические UDF, см. &lt;a href=&quot;udf#algebraic-interface&quot;&gt;Алгебраический интерфейс&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7189bc7a153aae22c9ad9fbdd927084b0fc40f73" translate="yes" xml:space="preserve">
          <source>Quits from the Pig grunt shell.</source>
          <target state="translated">Выходит из панциря Свиньи.</target>
        </trans-unit>
        <trans-unit id="620db5d9320e96ee12d500dbe6be7488db8de087" translate="yes" xml:space="preserve">
          <source>RANDOM</source>
          <target state="translated">RANDOM</target>
        </trans-unit>
        <trans-unit id="9e3bfd1f2a524ee518de592cf7435459586a3d76" translate="yes" xml:space="preserve">
          <source>RANDOM( )</source>
          <target state="translated">RANDOM()</target>
        </trans-unit>
        <trans-unit id="9cc2229409ebf7a451b2509c23892c92fff169d6" translate="yes" xml:space="preserve">
          <source>RANK</source>
          <target state="translated">RANK</target>
        </trans-unit>
        <trans-unit id="94e87841c18078a6be5f0c47297fcf1078db118b" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT</source>
          <target state="translated">REGEX_EXTRACT</target>
        </trans-unit>
        <trans-unit id="25060cd6008a61bda5883baa15d7cfb4500fcb19" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT (string, regex, index)</source>
          <target state="translated">REGEX_EXTRACT (строка,регекс,индекс)</target>
        </trans-unit>
        <trans-unit id="0921fe22357a6d6189cafbbaccb9446992f7c4b5" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL</source>
          <target state="translated">REGEX_EXTRACT_ALL</target>
        </trans-unit>
        <trans-unit id="0b2e921ca3a52345dca73d874d8ecb7ca4ad0cc1" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL (string, regex)</source>
          <target state="translated">REGEX_EXTRACT_ALL (строка,регекс)</target>
        </trans-unit>
        <trans-unit id="7aa14173b8000e15aca4adfdc3b1a5e0d8c44ef0" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH</source>
          <target state="translated">REGEX_SEARCH</target>
        </trans-unit>
        <trans-unit id="4c56880804c60faefafcbee89177e1727de2dff4" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH(string, 'regExp');</source>
          <target state="translated">REGEX_SEARCH(string,'regExp');</target>
        </trans-unit>
        <trans-unit id="018678424b56c2120abb69e981ef3eec820e05dd" translate="yes" xml:space="preserve">
          <source>REGISTER (a jar/script)</source>
          <target state="translated">РЕГИСТЕР (банка/сценарий)</target>
        </trans-unit>
        <trans-unit id="c28d820c6f95eb8bc2a1c939755c4308dae8a884" translate="yes" xml:space="preserve">
          <source>REGISTER (an artifact)</source>
          <target state="translated">РЕГИСТЕР (артефакт)</target>
        </trans-unit>
        <trans-unit id="c2f18c3d25c024de2d314688e5568c2e2b885ce4" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://group:module:version?querystring</source>
          <target state="translated">REGISTER ivy://group:module:version?querystring</target>
        </trans-unit>
        <trans-unit id="3213ec58664edb7df53533dc66ffd9af231fd2cb" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?classifier=value</source>
          <target state="translated">REGISTER ivy://org:module:version?classifier=значение</target>
        </trans-unit>
        <trans-unit id="298b74bfc4131cf922f0663bebad6b611ebc696d" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?exclude=org:mod,org:mod,...</source>
          <target state="translated">REGISTER ivy://org:module:version?exclud=org:mod,org:mod,....</target>
        </trans-unit>
        <trans-unit id="f9f07df8a78db31fca096c05b31f0bcd7a3a50f7" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?transitive=false</source>
          <target state="translated">REGISTER ivy://org:module:version?transitive=false</target>
        </trans-unit>
        <trans-unit id="523fb225d3a2759dc8655903d1bc6a8288ada1ba" translate="yes" xml:space="preserve">
          <source>REGISTER path;</source>
          <target state="translated">Задний ход;</target>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="e04cf56acc0c4981837a53b7ff1256bf0c0ff4fe" translate="yes" xml:space="preserve">
          <source>REPLACE(string, 'regExp', 'newChar');</source>
          <target state="translated">REPLACE(string,'regExp','newChar');</target>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="7f78099ba5db4acf80827e5f3d1a83db2ae525ec" translate="yes" xml:space="preserve">
          <source>ROLLUP</source>
          <target state="translated">ROLLUP</target>
        </trans-unit>
        <trans-unit id="8580cec9b53e98ece67f310e025d4a349121f88a" translate="yes" xml:space="preserve">
          <source>ROUND</source>
          <target state="translated">ROUND</target>
        </trans-unit>
        <trans-unit id="cacfa70692e87c3321966a012a48ba58ce3bb591" translate="yes" xml:space="preserve">
          <source>ROUND(expression)</source>
          <target state="translated">ROUND(expression)</target>
        </trans-unit>
        <trans-unit id="c4c0b1ef3217efe1d9bf9b7d827e6ad059b864bd" translate="yes" xml:space="preserve">
          <source>ROUND(x)</source>
          <target state="translated">ROUND(x)</target>
        </trans-unit>
        <trans-unit id="0715c249cd668d5284678dca026287c3e463851a" translate="yes" xml:space="preserve">
          <source>ROUND_TO</source>
          <target state="translated">ROUND_TO</target>
        </trans-unit>
        <trans-unit id="9e50ef723b8064863d96f779d169424a37563aa0" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits [, mode])</source>
          <target state="translated">ROUND_TO(val,цифры [,режим]))</target>
        </trans-unit>
        <trans-unit id="8552829751a281e6ba49d05c41a939ede5eaafcb" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits)</source>
          <target state="translated">ROUND_TO(val,цифры)</target>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="d0176c9b5630a9edca1e76d654fc1c435437c454" translate="yes" xml:space="preserve">
          <source>RTRIM(expression)</source>
          <target state="translated">RTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="2a967919b023bdd7576620af97326ae9c9f3491d" translate="yes" xml:space="preserve">
          <source>Record Deliminters &amp;ndash; For load statements Pig interprets the line feed ( '\n' ), carriage return ( '\r' or CTRL-M) and combined CR + LF ( '\r\n' ) characters as record delimiters (do not use these characters as field delimiters). For store statements Pig uses the line feed ('\n') character as the record delimiter.</source>
          <target state="translated">Ограничители записей - Для операторов загрузки Pig интерпретирует перевод строки ('\ n'), возврат каретки ('\ r' или CTRL-M) и комбинированные символы CR + LF ('\ r \ n') как разделители записей (не используйте эти символы в качестве разделителей полей). Для операторов store Pig использует символ перевода строки ('\ n') в качестве разделителя записей.</target>
        </trans-unit>
        <trans-unit id="ef6b7434b39836c7b5476b127140cb9fc733f047" translate="yes" xml:space="preserve">
          <source>Reduce Your Operator Pipeline</source>
          <target state="translated">Уменьшите количество трубопроводов оператора</target>
        </trans-unit>
        <trans-unit id="a5b5c7ea81e2d801d5ee70f53f3a6c23d9a8c4e6" translate="yes" xml:space="preserve">
          <source>Reducer Estimation</source>
          <target state="translated">Снижение оценки</target>
        </trans-unit>
        <trans-unit id="62beeb3ebea5d1b6fbcca509b70d060344fdd22b" translate="yes" xml:space="preserve">
          <source>Refer to args positionally and as many times as you like using %(pos)$.... Use %&amp;lt;... to refer to the previously-specified arg.</source>
          <target state="translated">Используйте аргументы позиционно и сколько угодно раз, используя% (pos) $ .... Используйте% &amp;lt;... для ссылки на ранее указанный аргумент.</target>
        </trans-unit>
        <trans-unit id="4737d8da85fe53493025312e1f0d18e0867c487c" translate="yes" xml:space="preserve">
          <source>Referencing Fields</source>
          <target state="translated">Поля ссылок</target>
        </trans-unit>
        <trans-unit id="4cae9bdf3920da7757a8c85f6b54d8738dd7967d" translate="yes" xml:space="preserve">
          <source>Referencing Fields that are Complex Data Types</source>
          <target state="translated">Ссылочные Поля,которые являются сложными типами данных</target>
        </trans-unit>
        <trans-unit id="d23bb24e2f8bcaae71a9d10cc001c98353b1b509" translate="yes" xml:space="preserve">
          <source>Referencing Relations</source>
          <target state="translated">Ссылки Отношения</target>
        </trans-unit>
        <trans-unit id="dc42ec7da7d0e19f1a5ed6e62ea29d2d256d89ad" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the included UDFs can be called in the script.</source>
          <target state="translated">Зарегистрируйте обучающий JAR-файл,чтобы включенные в него UDF-файлы можно было вызывать в скрипте.</target>
        </trans-unit>
        <trans-unit id="6692a10545ad9ae35c076d55ecf3df797aeb3ad4" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the user defined functions (UDFs) can be called in the script.</source>
          <target state="translated">Зарегистрируйте обучающий JAR-файл,чтобы в скрипте можно было вызывать определенные пользователем функции (UDF).</target>
        </trans-unit>
        <trans-unit id="26c92f3731d6fecfb43c28c225f8c2bc30998abb" translate="yes" xml:space="preserve">
          <source>Registering an Artifact and all its dependencies.</source>
          <target state="translated">Регистрация артефакта и всех его зависимостей.</target>
        </trans-unit>
        <trans-unit id="dc29b2e11b3b43cda736fcba0bb6760a606e849e" translate="yes" xml:space="preserve">
          <source>Registering an artifact by excluding specific dependencies.</source>
          <target state="translated">Регистрация артефакта путем исключения конкретных зависимостей.</target>
        </trans-unit>
        <trans-unit id="5f4ed5bdc8024ad52459ee1a00ab28199dd38f89" translate="yes" xml:space="preserve">
          <source>Registering an artifact without a group or organization. Just skip them.</source>
          <target state="translated">Регистрация артефакта без группы или организации.Пропустите их.</target>
        </trans-unit>
        <trans-unit id="3d4a9d6f350eea88c38c96fd0c95e87ab7bbad29" translate="yes" xml:space="preserve">
          <source>Registering an artifact without getting its dependencies.</source>
          <target state="translated">Регистрация артефакта без получения его зависимостей.</target>
        </trans-unit>
        <trans-unit id="da1d3a98f791337ad0a4ec68eae079eb6ef95ae7" translate="yes" xml:space="preserve">
          <source>Registering the UDF</source>
          <target state="translated">Регистрация ОДС</target>
        </trans-unit>
        <trans-unit id="8a29de9c3832ce4b8e6b18747e5a829713fca18d" translate="yes" xml:space="preserve">
          <source>Registering the latest artifact.</source>
          <target state="translated">Регистрирую последний артефакт.</target>
        </trans-unit>
        <trans-unit id="dd54c0c65bf4584f34e8a3942380ffcf0970fe76" translate="yes" xml:space="preserve">
          <source>Registers a JAR file so that the UDFs in the file can be used.</source>
          <target state="translated">Регистрирует JAR-файл,чтобы можно было использовать UDF-файлы в этом файле.</target>
        </trans-unit>
        <trans-unit id="428be11df215f5cd15290e03edfab6e2024b704f" translate="yes" xml:space="preserve">
          <source>Relation X looks like this. A tuple is created for each unique key field. The tuple includes the key field and two bags. The first bag is the tuples from the first relation with the matching key field. The second bag is the tuples from the second relation with the matching key field. If no tuples match the key field, the bag is empty.</source>
          <target state="translated">Отношение Х выглядит вот так.Для каждого уникального ключевого поля создается кортеж.Кортеж включает в себя ключевое поле и две сумки.Первая сумка-это кортежи из первого соотношения с соответствующим полем ключа.Вторая сумка-кортежи из второго соотношения с полем ключа.Если ни один кортеж не совпадает с полем ключей,сумка пуста.</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">Операторы связи</target>
        </trans-unit>
        <trans-unit id="ac6eb526c4d3427712a60a1a682dfb9f6e58dad9" translate="yes" xml:space="preserve">
          <source>Relations are referred to by name (or alias). Names are assigned by you as part of the Pig Latin statement. In this example the name (alias) of the relation is A.</source>
          <target state="translated">Отношения называются по имени (или псевдониму).Имена присваиваются Вами в рамках утверждения Pig Latin.В этом примере имя (псевдоним)отношения-А.</target>
        </trans-unit>
        <trans-unit id="657fe9adf3cabd570b43f36ea037911276330628" translate="yes" xml:space="preserve">
          <source>Relations, Bags, Tuples, Fields</source>
          <target state="translated">Отношения,сумки,кортежи,поля.</target>
        </trans-unit>
        <trans-unit id="47f90b570611ed6b62f0263d679682900ef503e8" translate="yes" xml:space="preserve">
          <source>Remove the boiler plate code appearing when there is more than one test methods.</source>
          <target state="translated">Удалить кодовую табличку котла,появляющуюся при наличии нескольких методов испытаний.</target>
        </trans-unit>
        <trans-unit id="f90556d367ec2b7b89d6cb1145ec2ab9a7d43795" translate="yes" xml:space="preserve">
          <source>Removes duplicate tuples in a relation.</source>
          <target state="translated">Удаляет дубликаты кортежей в соотношении.</target>
        </trans-unit>
        <trans-unit id="d5aed14a2d8cc1e13aa0226552743bc08f973991" translate="yes" xml:space="preserve">
          <source>Removes the record if the query field is empty or a URL.</source>
          <target state="translated">Удаляет запись,если поле запроса пустое или URL.</target>
        </trans-unit>
        <trans-unit id="01b967cc6fcf66fa1a327d6e23a3adcc183a7585" translate="yes" xml:space="preserve">
          <source>Replaces existing characters in a string with new characters.</source>
          <target state="translated">Заменяет существующие символы в строке на новые.</target>
        </trans-unit>
        <trans-unit id="7c9f7314d870cf506926a81a725609a309180df7" translate="yes" xml:space="preserve">
          <source>Replicated Joins</source>
          <target state="translated">Реплицированные присоединения</target>
        </trans-unit>
        <trans-unit id="8e2d170ab822648a868ed17db41712a1e458ed56" translate="yes" xml:space="preserve">
          <source>Reporting Progress</source>
          <target state="translated">Отчетность Прогресс</target>
        </trans-unit>
        <trans-unit id="c3ab25ae5e2cc5df52b11a23cfbf50e86331bacb" translate="yes" xml:space="preserve">
          <source>Required keyword.</source>
          <target state="translated">Необходимое ключевое слово.</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="4fef845de7495dcd1565cda432d4b9908db6c9c9" translate="yes" xml:space="preserve">
          <source>Reserved Keywords</source>
          <target state="translated">Зарезервированные ключевые слова</target>
        </trans-unit>
        <trans-unit id="d486788d225653651eb6a74aed6bf2b553d1d42b" translate="yes" xml:space="preserve">
          <source>Return Types and Schemas</source>
          <target state="translated">Типы и схемы возврата</target>
        </trans-unit>
        <trans-unit id="5d4dbb16b26776ff0a9681435fb191cc339ea164" translate="yes" xml:space="preserve">
          <source>Return code 0: All jobs succeeded</source>
          <target state="translated">Код возврата 0:все задания выполнены</target>
        </trans-unit>
        <trans-unit id="dcf12244c4ffa52bf59195a2ed18fd4736d7b67b" translate="yes" xml:space="preserve">
          <source>Return code 1: &lt;em&gt;Used for retrievable errors&lt;/em&gt;</source>
          <target state="translated">Код возврата 1: &lt;em&gt;используется для поиска ошибок&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0358e44b177069a82ad64649295be297b6b49ac" translate="yes" xml:space="preserve">
          <source>Return code 2: All jobs have failed</source>
          <target state="translated">Код возврата 2:Все задания не удались</target>
        </trans-unit>
        <trans-unit id="1491195b66e37f39862ac3347539de9fd938e5ac" translate="yes" xml:space="preserve">
          <source>Return code 3: Some jobs have failed</source>
          <target state="translated">Код возврата 3:некоторые вакансии не удалось</target>
        </trans-unit>
        <trans-unit id="419dc24bbf3839e94617bca8e82b80dcf575f429" translate="yes" xml:space="preserve">
          <source>Returns Euler's number e raised to the power of x.</source>
          <target state="translated">Возвращает Эйлеру номер e,поднятый до силы Х.</target>
        </trans-unit>
        <trans-unit id="513587fb94f9ca8a02c2130dbf24ce9970499d45" translate="yes" xml:space="preserve">
          <source>Returns a DateTime object according to parameters.</source>
          <target state="translated">Возвращает объект DateTime в соответствии с параметрами.</target>
        </trans-unit>
        <trans-unit id="36cf64f64f1683a1f6fd71ff4731efb70faacd64" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with leading and trailing white space removed.</source>
          <target state="translated">Возвращает копию строки с удалением лидирующего и скользящего пробела.</target>
        </trans-unit>
        <trans-unit id="881fb398d9c55cad7a537386644c3c3154142c43" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only leading white space removed.</source>
          <target state="translated">Возвращает копию строки с удалением только ведущего пробела.</target>
        </trans-unit>
        <trans-unit id="c7af3ae3ff3f406d011103cff7ba952d404e72e2" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only trailing white space removed.</source>
          <target state="translated">Возвращает копию строки с удаленным пробелом.</target>
        </trans-unit>
        <trans-unit id="2fc98512d189e4d3f3c0cca8ae024088810e4bc5" translate="yes" xml:space="preserve">
          <source>Returns a pseudo random number.</source>
          <target state="translated">Возвращает псевдо-случайное число.</target>
        </trans-unit>
        <trans-unit id="08d59bcf7e4da2d316cce1fe0f800acd9ca0e768" translate="yes" xml:space="preserve">
          <source>Returns a string converted to upper case.</source>
          <target state="translated">Возвращает строку,преобразованную в верхний регистр.</target>
        </trans-unit>
        <trans-unit id="60bd6525d26a868296aef9ef39229cb4f21b553b" translate="yes" xml:space="preserve">
          <source>Returns a string with the first character converted to upper case.</source>
          <target state="translated">Возвращает строку с первым символом,преобразованным в верхний регистр.</target>
        </trans-unit>
        <trans-unit id="0a6ceee3abe688e26f32d11ad4e8bfa6056694d1" translate="yes" xml:space="preserve">
          <source>Returns a string, an int, a long, a double, or a float</source>
          <target state="translated">Возвращает строку,int,длинную,двойную или плавающую.</target>
        </trans-unit>
        <trans-unit id="149929531961b59343eac086b94315964280e9c6" translate="yes" xml:space="preserve">
          <source>Returns a substring from a given string.</source>
          <target state="translated">Возвращает подстроку из заданной строки.</target>
        </trans-unit>
        <trans-unit id="f650c7101aebe01253479ec3832aa36457dd38e0" translate="yes" xml:space="preserve">
          <source>Returns a unique id string for each record in the alias.</source>
          <target state="translated">Возвращает уникальную идентификационную строку для каждой записи в псевдониме.</target>
        </trans-unit>
        <trans-unit id="1d2e7b7f3392f0d0a7f4edac2ffbf6e49ec75c21" translate="yes" xml:space="preserve">
          <source>Returns each tuple with the rank within a relation.</source>
          <target state="translated">Возвращает каждый кортеж с рангом в соотношении.</target>
        </trans-unit>
        <trans-unit id="5de4cf3d0ef61696c28177da2c48a786b952ce4f" translate="yes" xml:space="preserve">
          <source>Returns from user defined functions (UDFs)</source>
          <target state="translated">Возвращается из определенных пользователем функций (UDF)</target>
        </trans-unit>
        <trans-unit id="22f2b5afc5bcb54987844be722ae41dd06fae1e6" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) if any single argument is null.</source>
          <target state="translated">Возвращает ноль (без ошибок или предупреждений),если любой единственный аргумент равен нулю.</target>
        </trans-unit>
        <trans-unit id="a9d33c367a852dbfb596f52d5473ef9e15fc1757" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) with a null format string.</source>
          <target state="translated">Возвращает ноль (без ошибок или предупреждений)со строкой нулевого формата.</target>
        </trans-unit>
        <trans-unit id="69abd17980fc8fc326fac6f58dfef8a3d54c981e" translate="yes" xml:space="preserve">
          <source>Returns the DateTime object of the current time.</source>
          <target state="translated">Возвращает объект DateTime текущего времени.</target>
        </trans-unit>
        <trans-unit id="37ef5243e85c9e64bfe6667ede2cdc7c7805da8c" translate="yes" xml:space="preserve">
          <source>Returns the Unix Time as long for a DateTime object. UnixTime is the number of seconds elapsed since January 1, 1970, 00:00:00.000 GMT.</source>
          <target state="translated">Возвращает Unix Time столько же времени для объекта DateTime.UnixTime-это количество секунд,прошедших с 1 января 1970 года,00:00:00.000 GMT.</target>
        </trans-unit>
        <trans-unit id="e2205e5e3349d473a1aa00a87ddbbfaf4cef2bfb" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of an expression.</source>
          <target state="translated">Возвращает абсолютное значение выражения.</target>
        </trans-unit>
        <trans-unit id="85b804678f1cf453ee531619aad616e9ee0444a6" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of an expression.</source>
          <target state="translated">Возвращает дуговой косинус выражения.</target>
        </trans-unit>
        <trans-unit id="e39a89b4ea91acef8e89dd0bab73bd8c9003ffe3" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of an expression.</source>
          <target state="translated">Возвращает дуговой синус выражения.</target>
        </trans-unit>
        <trans-unit id="ed3aecce972de660c52bf3943dca60cdc02e893a" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of an expression.</source>
          <target state="translated">Возвращает касательную дуги выражения.</target>
        </trans-unit>
        <trans-unit id="11d674b8dd60cc025724efb8108982d963bec977" translate="yes" xml:space="preserve">
          <source>Returns the base 10 logarithm of an expression.</source>
          <target state="translated">Возвращает базовый логарифм выражения 10.</target>
        </trans-unit>
        <trans-unit id="6204881bdacb24f052b8f2ce9e963bcd536065ea" translate="yes" xml:space="preserve">
          <source>Returns the cube root of an expression.</source>
          <target state="translated">Возвращает кубический корень выражения.</target>
        </trans-unit>
        <trans-unit id="b91499640701da81cac5582f0880c4af26e4863c" translate="yes" xml:space="preserve">
          <source>Returns the day of a month from a DateTime object.</source>
          <target state="translated">Возвращает день месяца с объекта DateTime.</target>
        </trans-unit>
        <trans-unit id="046718c428dc7dd4d4c49d04ec41ba4ec46e1f95" translate="yes" xml:space="preserve">
          <source>Returns the hour of a day from a DateTime object.</source>
          <target state="translated">Возвращает час дня с объекта DateTime.</target>
        </trans-unit>
        <trans-unit id="e9e27533f3b351679e918b0146c940f249292548" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic cosine of an expression.</source>
          <target state="translated">Возвращает гиперболический косинус выражения.</target>
        </trans-unit>
        <trans-unit id="41ba86c915c553776146f87efe83c29cb5788f94" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic sine of an expression.</source>
          <target state="translated">Возвращает гиперболический синус выражения.</target>
        </trans-unit>
        <trans-unit id="29c1b5b8c50562788b9f9d48e7847459fbd66840" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic tangent of an expression.</source>
          <target state="translated">Возвращает гиперболический тангенс выражения.</target>
        </trans-unit>
        <trans-unit id="4ba0b6ea8572bf47f2c36352a0d682f2633e3113" translate="yes" xml:space="preserve">
          <source>Returns the index of the first occurrence of a character in a string, searching forward from a start index.</source>
          <target state="translated">Возвращает индекс первого появления символа в строке,перебирая вперёд из стартового индекса.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
