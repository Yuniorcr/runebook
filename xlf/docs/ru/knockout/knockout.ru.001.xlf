<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="55f7a75bfb6b682f736e46b92c2f236aae124e0e" translate="yes" xml:space="preserve">
          <source>&quot;afterkeydown&quot; - updates your view model as soon as the user begins typing a character. This works by catching the browser&amp;rsquo;s keydown event and handling the event asynchronously. This does not work in some mobile browsers.</source>
          <target state="translated">&amp;laquo;afterkeydown&amp;raquo; - обновляет вашу модель представления, как только пользователь начинает вводить символ. Это работает, перехватывая событие нажатия клавиши браузера и обрабатывая событие асинхронно. Это не работает в некоторых мобильных браузерах.</target>
        </trans-unit>
        <trans-unit id="9bf88a9f967d7e0a2ecb9a2c3cb373e62550ca35" translate="yes" xml:space="preserve">
          <source>&quot;input&quot; - updates your view model when the value of an &amp;lt;input&amp;gt; or &amp;lt;textarea&amp;gt; element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</source>
          <target state="translated">&amp;laquo;input&amp;raquo; - обновляет вашу модель представления при изменении значения элемента &amp;lt;input&amp;gt; или &amp;lt;textarea&amp;gt;. Обратите внимание, что это событие возникает только в достаточно современных браузерах (например, IE 9+).</target>
        </trans-unit>
        <trans-unit id="43249745c4adbf35a9cb9922652997d87dbe4042" translate="yes" xml:space="preserve">
          <source>&quot;keypress&quot; - updates your view model when the user has typed a key. Unlike keyup, this updates repeatedly while the user holds a key down</source>
          <target state="translated">&quot;keypress&quot; - обновляет вашу модель представления, когда пользователь набрал клавишу. В отличие от keyup, он обновляется постоянно, пока пользователь удерживает клавишу</target>
        </trans-unit>
        <trans-unit id="754a19ddfd1580a60ebdb60a67460f4ed1868828" translate="yes" xml:space="preserve">
          <source>&quot;keyup&quot; - updates your view model when the user releases a key</source>
          <target state="translated">&quot;keyup&quot; - обновляет вашу модель представления, когда пользователь отпускает клавишу</target>
        </trans-unit>
        <trans-unit id="b023c5f7752f43d6081c327d978bba7f21cae65e" translate="yes" xml:space="preserve">
          <source>&quot;notifyAtFixedRate&quot; &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a76466185a7fa8b0e097018e39dd0d76592070" translate="yes" xml:space="preserve">
          <source>&quot;notifyWhenChangesStop&quot; &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e067625ca975ca350ad14ef24cf6b1eeeb932ab7" translate="yes" xml:space="preserve">
          <source>$component</source>
          <target state="translated">$component</target>
        </trans-unit>
        <trans-unit id="f27c0d6823b43be383afbf56a525fa3e7b5bca08" translate="yes" xml:space="preserve">
          <source>$componentTemplateNodes</source>
          <target state="translated">$componentTemplateNodes</target>
        </trans-unit>
        <trans-unit id="b4aa877f2150e2e324627c78466629fcce97867e" translate="yes" xml:space="preserve">
          <source>$context</source>
          <target state="translated">$context</target>
        </trans-unit>
        <trans-unit id="461e9bac5c124e13e943d74294b5b3c23e91e59a" translate="yes" xml:space="preserve">
          <source>$data</source>
          <target state="translated">$data</target>
        </trans-unit>
        <trans-unit id="8d42409e40e4019fe1ad3970dab02ce54792984f" translate="yes" xml:space="preserve">
          <source>$element</source>
          <target state="translated">$element</target>
        </trans-unit>
        <trans-unit id="a7455dbeff981624c8fd90602ba9b39d8a3236fe" translate="yes" xml:space="preserve">
          <source>$index (only available within foreach bindings)</source>
          <target state="translated">$ index (доступно только в привязках foreach)</target>
        </trans-unit>
        <trans-unit id="45e7737b5f1d96d16a40213881d84a2a492be556" translate="yes" xml:space="preserve">
          <source>$parent</source>
          <target state="translated">$parent</target>
        </trans-unit>
        <trans-unit id="95e2237aee892666510550fbfab5413dc3d3c57a" translate="yes" xml:space="preserve">
          <source>$parentContext</source>
          <target state="translated">$parentContext</target>
        </trans-unit>
        <trans-unit id="551e29188e6f391357b84d891bae6ddf016d5ab0" translate="yes" xml:space="preserve">
          <source>$parents</source>
          <target state="translated">$parents</target>
        </trans-unit>
        <trans-unit id="f68b486675e88b186e3e5d97a647fbca76132e19" translate="yes" xml:space="preserve">
          <source>$parents[0] is the view model from the parent context (i.e., it&amp;rsquo;s the same as $parent)</source>
          <target state="translated">$ parent [0] - это модель представления из родительского контекста (т. е. такая же, как $ parent)</target>
        </trans-unit>
        <trans-unit id="65c4ecaa451b9f437d3935b91802b54bbb000546" translate="yes" xml:space="preserve">
          <source>$parents[1] is the view model from the grandparent context</source>
          <target state="translated">$ parent [1] - модель представления из контекста дедушки и бабушки.</target>
        </trans-unit>
        <trans-unit id="3cdd4ec57af42ab07ce806176c82747601207768" translate="yes" xml:space="preserve">
          <source>$parents[2] is the view model from the great-grandparent context</source>
          <target state="translated">$ parent [2] - это модель представления из контекста прадедов.</target>
        </trans-unit>
        <trans-unit id="7efb9bde8c0dcb7c458231902442f2ac06b5d48e" translate="yes" xml:space="preserve">
          <source>$rawData</source>
          <target state="translated">$rawData</target>
        </trans-unit>
        <trans-unit id="b764ba81776db6e2c0d3c795e5f0fb4f7b3b3158" translate="yes" xml:space="preserve">
          <source>$root</source>
          <target state="translated">$root</target>
        </trans-unit>
        <trans-unit id="281a6ce7dc200bc3ee6a1f7a74996c60f02fadb8" translate="yes" xml:space="preserve">
          <source>&amp;copy; Steven Sanderson, the Knockout.js team, and other contributors</source>
          <target state="translated">&amp;copy; Стивен Сандерсон, команда Knockout.js и другие участники</target>
        </trans-unit>
        <trans-unit id="a48ee17c964423bf4cc960d5d152f164fe712d06" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and IE 6 renders no whitespace before the words to our web site, you can avoid the problem by putting any text into the &amp;lt;span&amp;gt;, e.g.:</source>
          <target state="translated">&amp;hellip; И IE 6 не отображает пробелов перед словами нашего веб-сайта, вы можете избежать проблемы, поместив любой текст в &amp;lt;span&amp;gt;, например:</target>
        </trans-unit>
        <trans-unit id="e27c42ca2533fdefaeb58cc1b7eb45a5f42080eb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model (i.e., the object that contains myData):</source>
          <target state="translated">&amp;hellip; И определите соответствующую функцию в своей модели представления (т. Е. Объект, содержащий myData):</target>
        </trans-unit>
        <trans-unit id="cd11f3ee80ccedd0afebd460c00d949f65c71240" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e4a9ac6cd86f6006efcb5074a7cfc4a95acc99" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and so on.</source>
          <target state="translated">&amp;hellip; и так далее.</target>
        </trans-unit>
        <trans-unit id="5a844d0606e2cebac6157c81cc9a6f5ca56660d6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the following custom loader will take care of loading viewmodels configured with a viaLoader value:</source>
          <target state="translated">&amp;hellip; И следующий пользовательский загрузчик позаботится о загрузке моделей просмотра, настроенных со значением viaLoader:</target>
        </trans-unit>
        <trans-unit id="2392c33f696700587811efee0b525c35b66a8113" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the template markup is in the file path/my-component.html, then you have these benefits:</source>
          <target state="translated">&amp;hellip; А разметка шаблона находится в пути к файлу / my-component.html, тогда у вас есть следующие преимущества:</target>
        </trans-unit>
        <trans-unit id="306ad3adf4c6d524c866e2da9e33f77bb76e411e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and then you can use it on any number of DOM elements:</source>
          <target state="translated">&amp;hellip; И затем вы можете использовать его на любом количестве элементов DOM:</target>
        </trans-unit>
        <trans-unit id="1d1269190ed98d387c971daefbe0a562031c6ac7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and they will be updated whenever firstName or lastName changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</source>
          <target state="translated">&amp;hellip; И они будут обновляться при изменении firstName или lastName (ваша функция оценщика будет вызываться один раз при изменении любой из ее зависимостей, и любое возвращаемое вами значение будет передано наблюдателям, таким как элементы пользовательского интерфейса или другие вычисленные наблюдаемые).</target>
        </trans-unit>
        <trans-unit id="f0e6d69780be5a001171b8e0891626e76815b8cb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and you can do so using custom loaders.</source>
          <target state="translated">&amp;hellip; И вы можете сделать это с помощью специальных загрузчиков.</target>
        </trans-unit>
        <trans-unit id="c678b47361f53960d600a49f5e2a49ab33bf1efb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; assuming that someProperty is &lt;em&gt;observable&lt;/em&gt; and hence you need to invoke it as a function to obtain the current value.</source>
          <target state="translated">&amp;hellip; Предполагая, что someProperty является &lt;em&gt;наблюдаемым&lt;/em&gt; и, следовательно, вам нужно вызвать его как функцию для получения текущего значения.</target>
        </trans-unit>
        <trans-unit id="436bfbadf0d7e3d2acd161b36e9fa6c0aee1ca68" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because data-something isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip; Потому что данные-что-то не является юридическим именем идентификатора в этот момент. Решение простое: просто заключите имя идентификатора в кавычки, чтобы он стал строковым литералом, что допустимо в литерале объекта JavaScript. Например,</target>
        </trans-unit>
        <trans-unit id="d96ec87b990d2a5f05fcb8d21bf32f55812f3e19" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because my-class isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip; Потому что my-class в этот момент не является допустимым именем идентификатора. Решение простое: просто заключите имя идентификатора в кавычки, чтобы он стал строковым литералом, что допустимо в литерале объекта JavaScript. Например,</target>
        </trans-unit>
        <trans-unit id="e308fd02d63129d37593963615074a07790d41e5" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway.</source>
          <target state="translated">&amp;hellip; Но это не обязательно, потому что firstName в любом случае будет оцениваться в контексте $ data по умолчанию.</target>
        </trans-unit>
        <trans-unit id="675271334f75433b76e0d2ca2daa2caedcb7aa93" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway. If the items in the array are observables, $data will refer to the value of each observable. To refer to the observable itself, use $rawData.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd0331bbbc30c917af2ce818fb5586d7cecd6f7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be injected with:</source>
          <target state="translated">&amp;hellip; Можно вводить:</target>
        </trans-unit>
        <trans-unit id="7f3a7cb698f6c8ba821554005a2fe7438261aff6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be used as the template for a component by specifying its ID:</source>
          <target state="translated">&amp;hellip; Можно использовать в качестве шаблона для компонента, указав его идентификатор:</target>
        </trans-unit>
        <trans-unit id="9ddd2ca25a0f65763e8a310b7c6de249963ba2b7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; is equivalent to the following:</source>
          <target state="translated">&amp;hellip; Эквивалентно следующему:</target>
        </trans-unit>
        <trans-unit id="fd4393ed67ac1cfb24dad9cf459b5a8aa896d33c" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a createViewModel function, e.g.:</source>
          <target state="translated">&amp;hellip; Или функцию createViewModel, например:</target>
        </trans-unit>
        <trans-unit id="4445358862216b92eb56a5a61275070dfed5150b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a shared object instance, e.g.:</source>
          <target state="translated">&amp;hellip; Или экземпляр общего объекта, например:</target>
        </trans-unit>
        <trans-unit id="9f9f2be5a24b6d2be93f0a540aa1c45603b7e12d" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</source>
          <target state="translated">&amp;hellip; Или любой другой формы, описанной здесь, хотя было бы необычно для других быть полезным при получении шаблонов через AMD.</target>
        </trans-unit>
        <trans-unit id="dfd09f5a0fc940760751819d925befbc4f3884f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or even, though it&amp;rsquo;s unlikely you&amp;rsquo;d want to do this, a reference to a different AMD module, e.g.:</source>
          <target state="translated">&amp;hellip; Или даже, хотя вряд ли вы захотите это сделать, ссылку на другой модуль AMD, например:</target>
        </trans-unit>
        <trans-unit id="76deaf0467a8d01ce5fda8253ca2bf94e5c1d09f" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or passing parameters:</source>
          <target state="translated">&amp;hellip; Или передача параметров:</target>
        </trans-unit>
        <trans-unit id="c8dde18842940735246b96ebc2b6801af0bff816" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or you can send data to the server:</source>
          <target state="translated">&amp;hellip; Или вы можете отправить данные на сервер:</target>
        </trans-unit>
        <trans-unit id="83dd09db0bbbaf75986c9f14324dd51a6c7b3c2b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or, more conveniently, as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">&amp;hellip; Или, что более удобно, как &lt;a href=&quot;component-custom-elements&quot;&gt;настраиваемый элемент&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9a0cac50f6e17cb0207d461cfe3eadb4c1cb5b0b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; the component viewmodel&amp;rsquo;s params parameter will contain three values:</source>
          <target state="translated">&amp;hellip; Параметр params модели представления компонента будет содержать три значения:</target>
        </trans-unit>
        <trans-unit id="d03a96e5ee2c9a78e87d9468f59e17ba046629a1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then see &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;the documentation for virtual elements&lt;/a&gt;.</source>
          <target state="translated">&amp;hellip; Затем просмотрите &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;документацию по виртуальным элементам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eb4b5f8187f3ef64e228acdde18a278aa6c4f55" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will be recomputed immediately, before your next line of code runs. But if you instead define name using rateLimit as follows:</source>
          <target state="translated">&amp;hellip; Тогда upperCaseName будет немедленно пересчитан перед выполнением следующей строки кода. Но если вместо этого вы определите имя с помощью rateLimit следующим образом:</target>
        </trans-unit>
        <trans-unit id="d6d1fbc554c515663655cf7715837ed5aa4d192b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will not be recomputed immediately when name changes&amp;mdash;instead, name will wait for 500 milliseconds (half a second) before notifying its new value to upperCaseName, which will then recompute its value. No matter how many times name is changed during those 500 ms, upperCaseName will only be updated once with the most recent value.</source>
          <target state="translated">&amp;hellip; Тогда upperCaseName не будет пересчитываться немедленно при изменении имени - вместо этого name будет ждать 500 миллисекунд (полсекунды), прежде чем уведомить о своем новом значении upperCaseName, который затем пересчитает его значение. Независимо от того, сколько раз имя было изменено в течение этих 500 мс, upperCaseName будет обновляться только один раз с самым последним значением.</target>
        </trans-unit>
        <trans-unit id="6b92e76aa3ffd11c41f69f8adf6378acda520d0e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then you&amp;rsquo;ll get the error The binding 'randomOrder' cannot be used with virtual elements. Let&amp;rsquo;s fix this. To make randomOrder usable with virtual elements, start by telling Knockout to allow it. Add the following:</source>
          <target state="translated">&amp;hellip; Тогда вы получите ошибку. Привязка randomOrder не может использоваться с виртуальными элементами. Давайте исправим это. Чтобы сделать randomOrder пригодным для использования с виртуальными элементами, начните с того, что разрешите Knockout. Добавьте следующее:</target>
        </trans-unit>
        <trans-unit id="80d023722c8262c22ad3fc675542d06cee7a10d4" translate="yes" xml:space="preserve">
          <source>&amp;hellip; this would &lt;em&gt;not&lt;/em&gt; render as italic text, but would render as literal text with visible angle brackets.</source>
          <target state="translated">&amp;hellip; Это &lt;em&gt;не&lt;/em&gt; будет отображаться как курсивный текст, но будет отображаться как буквальный текст с видимыми угловыми скобками.</target>
        </trans-unit>
        <trans-unit id="4fe8ec038bc4329e9e45b5dfe41cee9f2fe195b1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you can write:</source>
          <target state="translated">&amp;hellip; ты можешь написать:</target>
        </trans-unit>
        <trans-unit id="b66a8f7dc087cc3fe583564359f2ab71878995ff" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you could add a computed observable to return the full name:</source>
          <target state="translated">&amp;hellip; Вы можете добавить вычисляемую наблюдаемую, чтобы вернуть полное имя:</target>
        </trans-unit>
        <trans-unit id="71d7c773808d5efbd7cce431ad808079c3272374" translate="yes" xml:space="preserve">
          <source>&amp;hellip;all Knockout does is call require(['some/module/name'], callback) and require(['text!some-template.html'], callback), and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</source>
          <target state="translated">&amp;hellip; Все, что делает Knockout, это вызывает require (['some / module / name'], обратный вызов) и require (['text! Some-template.html'], callback), и использует асинхронно возвращаемые объекты в качестве модели представления и шаблона. определения. Так,</target>
        </trans-unit>
        <trans-unit id="38ee4fba456bf575e89e5da4159e11ef4ef51e69" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can be composed together (nested) or inherited from other components</source>
          <target state="translated">&amp;hellip; Могут быть составлены вместе (вложены) или унаследованы от других компонентов</target>
        </trans-unit>
        <trans-unit id="162d2e6a27442e0aa5ac2c677764866d6758b55a" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can easily be packaged for reuse across projects</source>
          <target state="translated">&amp;hellip; Можно легко упаковать для повторного использования в проектах</target>
        </trans-unit>
        <trans-unit id="bcba4513804170c2cfb012b6c5f4e034f8b93be4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</source>
          <target state="translated">&amp;hellip; Могут быть предварительно загружены или загружены асинхронно (по запросу) через AMD или другие модульные системы</target>
        </trans-unit>
        <trans-unit id="7734991d30f834e7dc1591e178e0cd0b0d5521fb" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can receive parameters, and optionally write back changes to them or invoke callbacks</source>
          <target state="translated">&amp;hellip; Может получать параметры и, при желании, записывать в них изменения или вызывать обратные вызовы</target>
        </trans-unit>
        <trans-unit id="37c9fb1cbc39cb59f3625da14f6e4805d7b6d501" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can represent individual controls/widgets, or entire sections of your application</source>
          <target state="translated">&amp;hellip; Может представлять отдельные элементы управления / виджеты или целые разделы вашего приложения</target>
        </trans-unit>
        <trans-unit id="1c2182731546dc53e24b1c9569feb025fd6bb517" translate="yes" xml:space="preserve">
          <source>&amp;hellip;contain their own view, and usually (but optionally) their own viewmodel</source>
          <target state="translated">&amp;hellip; Содержат собственное представление и обычно (но необязательно) свою собственную модель представления</target>
        </trans-unit>
        <trans-unit id="62feedff48dd72e9502546eae6f60f51588cac08" translate="yes" xml:space="preserve">
          <source>&amp;hellip;let you define your own conventions/logic for configuration and loading</source>
          <target state="translated">&amp;hellip; Позволяют вам определять свои собственные соглашения / логику для конфигурации и загрузки</target>
        </trans-unit>
        <trans-unit id="1d6d88d1123b98cbd0f1f5e62ff9ab2b24498c00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad39df7089dc71921905acab8fd21922898ed00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb3c78ce58dd06a6d43eb3b9ff55c63d6083256" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c61fd8db0084748a81447c5ac602f14593ede76" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9a2f7e913b123d1b2147b6fcea7fc3b56f2226" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', 'font-weight': isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5c19398840fdde1cad04e87976626ec9752a56" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', fontWeight: isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="translated">&amp;lt;div data-bind = &quot;style: {color: currentProfit () &amp;lt;0? 'red': 'black', fontWeight: isSevere ()? 'bold': ''}&quot;&amp;gt; ... &amp;lt;/div&amp;gt;</target>
        </trans-unit>
        <trans-unit id="38e9d45ee1eed004e555cb8df16e05183c19f62c" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind = 'options: myOptions, optionsCaption: &quot;Выбрать элемент ...&quot;, значение: myChosenValue'&amp;gt; &amp;lt;/select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="db710280a1f20bb61913609f07dc49291fe0ba4f" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsIncludeDestroyed: true'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind = 'options: myOptions, optionsIncludeDestroyed: true'&amp;gt; &amp;lt;/select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eb1429e4a9ace15f00ed398e300f2d1e6d8acde7" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply a CSS class but instead want to assign a style attribute value directly, see &lt;a href=&quot;style-binding&quot;&gt;the style binding&lt;/a&gt;.)</source>
          <target state="translated">(Примечание: если вы не хотите применять класс CSS, а вместо этого хотите напрямую присвоить значение атрибута стиля, см. &lt;a href=&quot;style-binding&quot;&gt;Привязку стиля&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="15891bb9e3faad48e1edd4725ace6108a9566b87" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the class or css binding&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a142a8a08360ecb44da2e404e6e9702082412cb" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the css binding&lt;/a&gt;.)</source>
          <target state="translated">(Примечание: если вы не хотите применять явное значение стиля, но вместо этого хотите назначить класс CSS, см. &lt;a href=&quot;css-binding&quot;&gt;Привязку css&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="fd7f1dbd9b0a6243440f34f5f4c46eeb6f3829a1" translate="yes" xml:space="preserve">
          <source>(The awake event also applies to normal computed observables created with the deferEvaluation option.)</source>
          <target state="translated">(Событие пробуждения также применяется к обычным вычисляемым наблюдаемым, созданным с помощью опции deferEvaluation.)</target>
        </trans-unit>
        <trans-unit id="8626117b5c558a6896256b03c3366c11dc83bf9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; is a popular library for referencing JavaScript libraries with a Node-style synchronous require syntax. It&amp;rsquo;s often considered as an alternative to an AMD loader such as require.js. However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD.</source>
          <target state="translated">&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; - популярная библиотека для обращения к библиотекам JavaScript с синтаксисом синхронного требования в стиле узла. Его часто рассматривают как альтернативу загрузчику AMD, например require.js. Однако Browserify решает совсем другую проблему: синхронное разрешение ссылок во время сборки, а не асинхронное разрешение ссылок во время выполнения, которое обрабатывает AMD.</target>
        </trans-unit>
        <trans-unit id="b39766fa59a9837dc3c0076b5c0edc9947c018b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="translated">&lt;a href=&quot;ratelimit-observable&quot;&gt;ограниченные по скорости&lt;/a&gt; и &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;дросселированные&lt;/a&gt; вычисления</target>
        </trans-unit>
        <trans-unit id="1b4bb06f8e720378aa0ea6e2adc0ff799010ff99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799efd7655ba3b9889f9740fd0862be90bc93730" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to supply configurations programmatically based on names, e.g., to implement a naming convention.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Определите это, если:&lt;/strong&gt; вы хотите предоставить конфигурации программно на основе имен, например, для реализации соглашения об именах.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6212d983fffffd9e6209c49fa2c090cd3246f96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard viewModel/template pair format.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Определите это, если:&lt;/strong&gt; вы хотите контролировать, как интерпретируются конфигурации компонентов, например, если вы не хотите использовать стандартный формат пары viewModel / template.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a555c705767297e9a26aa2786f606e4bddfbdc4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Определите это, если:&lt;/strong&gt; вы хотите использовать настраиваемую логику для предоставления узлов DOM для данной конфигурации шаблона (например, используя запрос ajax для получения шаблона по URL-адресу).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42c134db8841f2566f885e08b68c5c8d619f2908" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Определите это, если:&lt;/strong&gt; вы хотите использовать настраиваемую логику для предоставления фабрики модели представления для данной конфигурации модели представления (например, интеграция со сторонним загрузчиком модулей или системой внедрения зависимостей).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="951a4f2777566b4db649df1913890afa95d9199f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners don&amp;rsquo;t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Новичкам не нужно об этом знать, но более продвинутые разработчики захотят знать, почему мы продолжаем делать все эти заявления о том, что KO автоматически отслеживает зависимости и обновляет нужные части пользовательского интерфейса ...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa952fc0ed2f794d316a68b12bbe7feaad64baf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners may wish to skip this section - writable computed observables are fairly advanced and are not necessary in most situations&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Новички могут захотеть пропустить этот раздел - доступные для записи вычисляемые наблюдаемые достаточно продвинуты и не нужны в большинстве ситуаций.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b05d71845457c0f57f5c46e823954aa6b0676cbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deferred&lt;/em&gt; &amp;ndash; Notifications happen asynchronously, immediately after the current task and generally before any UI redraws.</source>
          <target state="translated">&lt;em&gt;Отложено&lt;/em&gt; - уведомления происходят асинхронно, сразу после текущей задачи и обычно до перерисовки пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="1a3eb4911a7639fdbf44236533a918c6726b8746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Model-View-View Model (MVVM)&lt;/em&gt; is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</source>
          <target state="translated">&lt;em&gt;Модель-представление-представление Модель (MVVM)&lt;/em&gt; - это шаблон проектирования для создания пользовательских интерфейсов. В нем описывается, как можно упростить потенциально сложный пользовательский интерфейс, разделив его на три части:</target>
        </trans-unit>
        <trans-unit id="8d5d07f2734b6af11f85414b793aa7ddf201eb11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Native templating&lt;/em&gt; is the mechanism that underpins foreach, if, with, and other control flow bindings. Internally, those control flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item. This feature is built into Knockout and doesn&amp;rsquo;t require any external library.</source>
          <target state="translated">&lt;em&gt;Собственные шаблоны&lt;/em&gt; - это механизм, лежащий в основе foreach, if, with и других привязок потока управления. Внутри эти привязки потока управления захватывают разметку HTML, содержащуюся в вашем элементе, и используют ее в качестве шаблона для рендеринга для произвольного элемента данных. Эта функция встроена в Knockout и не требует внешней библиотеки.</target>
        </trans-unit>
        <trans-unit id="62995f07b684cd1e442b8e8983d90777e3520707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: As an alternative, it&amp;rsquo;s possible to implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that fetches components by your own conventions instead of explicit configuration.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание. В качестве альтернативы можно реализовать &lt;a href=&quot;component-loaders&quot;&gt;пользовательский загрузчик компонентов,&lt;/a&gt; который выбирает компоненты в соответствии с вашими собственными соглашениями вместо явной конфигурации.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d338d1a1dd37312fe044a380c3ea1d735e815b63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later. For previous versions, the &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Deferred Updates&lt;/a&gt; plugin provides similar support.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание. Эта документация относится к Knockout 3.4.0 и новее. Для предыдущих версий плагин &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Deferred Updates&lt;/a&gt; предоставляет аналогичную поддержку.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62498b02454097b103305de14b9e278671df1dae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание. Эта документация относится к Knockout 3.4.0 и новее.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8a670cb7b1ce7328b8161c795abd85a6da3f03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This feature, introduced in Knockout 3.5.0, is experimental, and may change in future versions.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a452d27c97bc5cb3c05b0a492913c856dfecc7e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание. Это продвинутый метод, обычно используемый только при создании библиотек многоразовых привязок или расширенных синтаксисов. Это не то, что вам обычно нужно делать при создании приложений с помощью Knockout.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d10f8fcc7959551d54bb29ecb4d9c7d6381a396c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание. Это продвинутый метод, который обычно используется только при создании библиотек многоразовых привязок. Это не то, что вам обычно нужно делать при создании приложений с помощью Knockout.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13a617cb2c3f39c989433be077da2528155d2c63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание. Этот API ограничения скорости был добавлен в Knockout 3.1.0. В предыдущих версиях &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;расширитель дроссельной заслонки имел&lt;/a&gt; аналогичные функции.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f07301b891a79e640658b5d5f6382bfcb281196" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68ff05c21394b3c8fde74181447625b3f4a3c9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables</source>
          <target state="translated">&lt;em&gt;Чистые&lt;/em&gt; вычисленные наблюдаемые</target>
        </trans-unit>
        <trans-unit id="a8a339e267cfb8f1a5acc964a91f6bddd68f8c55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables work slightly differently. For more details, see the documentation for &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observables&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Чистые&lt;/em&gt; вычисленные наблюдаемые работают немного иначе. Дополнительные сведения см. В документации по &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;чисто&lt;/em&gt; вычисляемым наблюдаемым&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d78dec7911bd8203863417e869cad05a283e2aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications. This is because a &lt;em&gt;pure&lt;/em&gt; computed observable doesn&amp;rsquo;t maintain subscriptions to its dependencies when it has no subscribers itself. This feature:</source>
          <target state="translated">&lt;em&gt;Чистые&lt;/em&gt; вычисляемые наблюдаемые, представленные в Knockout 3.2.0, обеспечивают преимущества производительности и памяти по сравнению с обычными вычисляемыми наблюдаемыми для большинства приложений. Это связано с тем, что &lt;em&gt;чисто&lt;/em&gt; вычисляемый наблюдаемый объект не поддерживает подписки на свои зависимости, если у него нет подписчиков. Эта особенность:</target>
        </trans-unit>
        <trans-unit id="874de401496e2450d62370c0489d8134a4680445" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rate-limited&lt;/em&gt; &amp;ndash; Notifications happen after the specified period of time (a minimum of 2-10 ms depending on the browser).</source>
          <target state="translated">&lt;em&gt;С ограничением скорости&lt;/em&gt; - уведомления приходят через указанный период времени (минимум 2&amp;ndash;10 мс в зависимости от браузера).</target>
        </trans-unit>
        <trans-unit id="e9fb2be0abb789016ac0a5f7e66231b360cba479" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Standard&lt;/em&gt; &amp;ndash; Notifications happen immediately and synchronously. Dependencies are often notified of intermediate values.</source>
          <target state="translated">&lt;em&gt;Стандартный&lt;/em&gt; - Уведомления происходят немедленно и синхронно. Зависимости часто уведомляются о промежуточных значениях.</target>
        </trans-unit>
        <trans-unit id="a530af1836dfa7520cbd67286036f07b4d5db232" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;String-based templating&lt;/em&gt; is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to the external template engine and inject the resulting markup string into your document. See below for examples that use the &lt;em&gt;jquery.tmpl&lt;/em&gt; and &lt;em&gt;Underscore&lt;/em&gt; template engines.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Шаблоны на &lt;em&gt;основе строк&lt;/em&gt; - это способ подключить Knockout к стороннему шаблонизатору. Knockout будет передавать значения вашей модели внешнему шаблонизатору и вставлять полученную строку разметки в ваш документ. Ниже приведены примеры, в которых используются &lt;em&gt;механизмы&lt;/em&gt; шаблонов &lt;em&gt;jquery.tmpl&lt;/em&gt; и &lt;em&gt;Underscore&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="95d18c945a954e5590e42b342e105bd6d20d1a6e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This advanced technique for working with observables was added in Knockout 3.5.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89db5d2a0f4af59a6f45fb25a27d621ea08d0a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Writes&lt;/em&gt; to observables are not delayed; the observable&amp;rsquo;s value is updated right away. For writable computed observables, this means that the write function is always run right away.</source>
          <target state="translated">&lt;em&gt;Запись&lt;/em&gt; в наблюдаемые объекты не задерживается; значение наблюдаемого обновляется сразу. Для доступных для записи вычисляемых наблюдаемых это означает, что функция записи всегда запускается сразу.</target>
        </trans-unit>
        <trans-unit id="976802e52d04d57e933efed69813c57bdea15efe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You won&amp;rsquo;t normally need to set up subscriptions manually, so beginners should skip this section.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Обычно вам не нужно настраивать подписки вручную, поэтому новичкам следует пропустить этот раздел.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6f4cea10f713ca2c89ae228e3ad371071a148e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;Version 2.0&lt;/a&gt;&lt;/strong&gt; (8.6kb minified)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;Версия 2.0&lt;/a&gt;&lt;/strong&gt; (уменьшенная до 8,6 КБ)</target>
        </trans-unit>
        <trans-unit id="9fc9b0f2bd6f8643b58e34e7531e60e824fddf5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; It&amp;rsquo;s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don&amp;rsquo;t need to add a custom function to these namespaces if you&amp;rsquo;re only planning to use it once.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Примечание.&lt;/em&gt;&lt;/strong&gt; Лучше всего использовать эту точку расширения только для настраиваемых функций, которые действительно применимы в широком диапазоне сценариев. Вам не нужно добавлять пользовательскую функцию в эти пространства имен, если вы планируете использовать ее только один раз.</target>
        </trans-unit>
        <trans-unit id="af169da745a1392a07e007770b35a87197553011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser event quirks handling&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обработка причуд событий браузера&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4642b89f0bf9cae05827d33f0e6b50627671416f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be added on top of your existing web application&lt;/strong&gt; without requiring major architectural changes</source>
          <target state="translated">&lt;strong&gt;Может быть добавлен поверх существующего веб-приложения&lt;/strong&gt; без серьезных архитектурных изменений</target>
        </trans-unit>
        <trans-unit id="3f22e14067daefd1c483604455b05ad6c16fab03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compact&lt;/strong&gt; - around 13kb after gzipping</source>
          <target state="translated">&lt;strong&gt;Компактный&lt;/strong&gt; - около 13 КБ после сжатия</target>
        </trans-unit>
        <trans-unit id="21be6783f2642d52a3544838078409e490d219d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components&lt;/strong&gt; are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</source>
          <target state="translated">&lt;strong&gt;Компоненты&lt;/strong&gt; - это мощный и чистый способ организации кода пользовательского интерфейса в автономные многократно используемые блоки. Oни:</target>
        </trans-unit>
        <trans-unit id="67202d2d955236aa4dfeac5729c2f6c4ab70604a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comprehensive suite of specifications&lt;/strong&gt; (developed BDD-style) means its correct functioning can easily be verified on new browsers and platforms</source>
          <target state="translated">&lt;strong&gt;Исчерпывающий набор спецификаций&lt;/strong&gt; (разработанный в стиле BDD) означает, что его правильное функционирование может быть легко проверено в новых браузерах и платформах.</target>
        </trans-unit>
        <trans-unit id="fe040890c716ea22696a8f2b6f9be7582d520286" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Custom elements&lt;/strong&gt; are an optional but convenient syntax for consuming components. Instead of needing placeholder &amp;lt;div&amp;gt;s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., &amp;lt;voting-button&amp;gt; or &amp;lt;product-editor&amp;gt;). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</source>
          <target state="translated">&lt;strong&gt;Пользовательские элементы&lt;/strong&gt; - это необязательный, но удобный синтаксис для использования компонентов. Вместо того, чтобы требовать заполнителей &amp;lt;div&amp;gt;, в которые компоненты вводятся с привязками, вы можете использовать более информативную разметку с именами настраиваемых элементов (например, &amp;lt;voting-button&amp;gt; или &amp;lt;product-editor&amp;gt;). Knockout заботится о совместимости даже со старыми браузерами, такими как IE 6.</target>
        </trans-unit>
        <trans-unit id="14acee7d825a2fe41e8bcf0a2ee1b89a69b3b6a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Declarative bindings&lt;/strong&gt; - a simple and obvious way to connect parts of your UI to your data model. You can construct a complex dynamic UIs easily using arbitrarily nested binding contexts.</source>
          <target state="translated">&lt;strong&gt;Декларативные привязки&lt;/strong&gt; - простой и очевидный способ связать части вашего пользовательского интерфейса с вашей моделью данных. Вы можете легко создавать сложные динамические пользовательские интерфейсы, используя произвольно вложенные контексты привязки.</target>
        </trans-unit>
        <trans-unit id="990b12697bf051a85eebd23ba9e0305e64003986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Elegant dependency tracking&lt;/strong&gt; - automatically updates the right parts of your UI whenever your data model changes.</source>
          <target state="translated">&lt;strong&gt;Элегантное отслеживание зависимостей&lt;/strong&gt; - автоматически обновляет правильные части вашего пользовательского интерфейса при изменении вашей модели данных.</target>
        </trans-unit>
        <trans-unit id="2c47af57f11ec324216f4b036c02f4d8a8dd1885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Полный синтаксис&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd14d38224fd44da0d36469b3026a46c9a2a53c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the component has a viewmodel, it is instantiated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если у компонента есть модель просмотра, он создается&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="853557afd32cc4840ee8b113330eee7c54353605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immediate updates&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Немедленные обновления&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="005d93bacec0cddafeed676ed8ea8668552bc146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet Explorer 6 to 8&lt;/strong&gt; also supports custom elements, &lt;em&gt;but only if they are registered before the HTML parser encounters any of those elements&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 6&amp;ndash;8&lt;/strong&gt; также поддерживает настраиваемые элементы, &lt;em&gt;но только если они зарегистрированы до того, как анализатор HTML обнаружит любой из этих элементов&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dd066585f0b991d7b67e9c322cf8b29f5934ed43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout does not interpret the module name&lt;/strong&gt; in any way - it merely passes it through to require(). So of course Knockout does not know or care about where your module files are loaded from. That&amp;rsquo;s up to your AMD loader and how you&amp;rsquo;ve configured it.</source>
          <target state="translated">&lt;strong&gt;Knockout никоим образом не интерпретирует имя модуля&lt;/strong&gt; - он просто передает его в require (). Поэтому, конечно, Knockout не знает и не заботится о том, откуда загружаются файлы вашего модуля. Это зависит от вашего загрузчика AMD и того, как вы его настроили.</target>
        </trans-unit>
        <trans-unit id="b14afc719747032408502f996f8253babcf10125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout doesn&amp;rsquo;t know or care whether your AMD modules are anonymous or not&lt;/strong&gt;. Typically we find it&amp;rsquo;s most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.</source>
          <target state="translated">&lt;strong&gt;Knockout не знает и не заботится о том, анонимны ли ваши модули AMD&lt;/strong&gt; . Обычно мы считаем, что удобнее всего определять компоненты как анонимные модули, но это совершенно не касается KO.</target>
        </trans-unit>
        <trans-unit id="7623301b20fba50846d11ffcff0175e2f950b534" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Native templating&lt;/strong&gt; does not require any library other than Knockout itself</source>
          <target state="translated">&lt;strong&gt;Для создания собственных шаблонов&lt;/strong&gt; не требуется никакой библиотеки, кроме самой Knockout.</target>
        </trans-unit>
        <trans-unit id="cce7f1297a779b792b0890892033a0603eadd234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Normally, you&amp;rsquo;d load the view model and template from external files&lt;/strong&gt; instead of declaring them inline like this. We&amp;rsquo;ll get to that later.</source>
          <target state="translated">&lt;strong&gt;Обычно вы загружаете модель представления и шаблон из внешних файлов&lt;/strong&gt; вместо того, чтобы объявлять их встроенными, как это. Мы вернемся к этому позже.</target>
        </trans-unit>
        <trans-unit id="9547e2cb901643dbdb78d8aee63e0abb0b96ab2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; для таких тривиальных требований, как проверка того, что ввод является числовым, этот метод является излишним. Было бы намного проще использовать jQuery Validation и его числовой класс в элементе &amp;lt;input&amp;gt;. Knockout и jQuery Validation прекрасно работают вместе, как показано на примере &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;редактора сетки&lt;/a&gt; . Однако предыдущий пример демонстрирует более общий механизм фильтрации и проверки с помощью настраиваемой логики для управления тем, какие отзывы пользователей появляются, что может быть полезно, если ваш сценарий более сложен, чем jQuery Validation обрабатывает изначально.</target>
        </trans-unit>
        <trans-unit id="b19719b50b1d1146b5c1b9e976c239dc581c1e36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c1d2bdf3c7252f3d741539a13c27876814e6d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; These callbacks are &lt;em&gt;only&lt;/em&gt; intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt; instead, because then you can use that behavior anywhere, independently of the foreach binding.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Эти обратные вызовы предназначены &lt;em&gt;только&lt;/em&gt; для запуска анимации, связанной с изменениями в списке. Если ваша цель на самом деле состоит в том, чтобы прикрепить другое поведение к новым элементам DOM, когда они были добавлены (например, обработчики событий или активация сторонних элементов управления пользовательским интерфейсом), тогда ваша работа будет намного проще, если вы реализуете это новое поведение как &lt;a href=&quot;custom-bindings&quot;&gt;пользовательское связывание&lt;/a&gt; вместо этого, потому что тогда вы можете использовать это поведение в любом месте, независимо от Еогеасп связывания.</target>
        </trans-unit>
        <trans-unit id="8cf6a6684f50f3ea7a170aa3398f4403873e6036" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Parameters:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96f242a46391269bfbcea22f170fb9153b44f393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prevents memory leaks&lt;/strong&gt; from computed observables that are no longer referenced in an application but whose dependencies still exist.</source>
          <target state="translated">&lt;strong&gt;Предотвращает утечку памяти&lt;/strong&gt; из вычисленных наблюдаемых объектов, на которые больше не ссылаются в приложении, но чьи зависимости все еще существуют.</target>
        </trans-unit>
        <trans-unit id="5af02e14314a6af73700df96c09743c910918af4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pure JavaScript library&lt;/strong&gt; - works with any server or client-side technology</source>
          <target state="translated">&lt;strong&gt;Библиотека чистого JavaScript&lt;/strong&gt; - работает с любой серверной или клиентской технологией</target>
        </trans-unit>
        <trans-unit id="65b27346b30be7b0a4f38908addd9e6f4370dbcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reduces computation overhead&lt;/strong&gt; by not re-calculating computed observables whose value isn&amp;rsquo;t being observed.</source>
          <target state="translated">&lt;strong&gt;Снижает накладные расходы&lt;/strong&gt; на &lt;strong&gt;вычисления за&lt;/strong&gt; счет &lt;strong&gt;отказа&lt;/strong&gt; от повторного вычисления вычисленных наблюдаемых, значение которых не наблюдается.</target>
        </trans-unit>
        <trans-unit id="36974a86b9014bdc65e78c9d0ffe9aae3425befe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Requirements&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38b847315206d412de961c02dd15d22a61454dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return value&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Возвращаемое значение&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="538d30d06518081cbff7ad599fc04c913bb63f0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorthand syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сокращенный синтаксис&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c03113c1df32711c668bb01816e62caf66f8cf31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String-based templating&lt;/strong&gt; works only once you&amp;rsquo;ve referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;Шаблоны на &lt;strong&gt;основе строк&lt;/strong&gt; работают только после того, как вы указали подходящий механизм шаблонов, такой как jQuery.tmpl или механизм шаблонов Underscore.</target>
        </trans-unit>
        <trans-unit id="01f4687a04e08868399938b56a400b5cef0e8132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscriptions&lt;/strong&gt; to observables continue to fire until explicitly disposed.</source>
          <target state="translated">&lt;strong&gt;Подписки&lt;/strong&gt; на наблюдаемые объекты продолжают активироваться, пока не будут удалены явно.</target>
        </trans-unit>
        <trans-unit id="32f777cc20c7769740052cd86dadccf8d489dfd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is active&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Компонент активен&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7395eabba8d626f204fa038e96ea461092ce9a5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is torn down, and the viewmodel is disposed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Компонент снят, а модель представления удалена.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b6f57d0a651bb6db8d366391beeb0328a19e7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component template is cloned and injected into the container element&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Шаблон компонента клонируется и вводится в элемент контейнера.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82e6e92787d7eb666a8b10c3b0f889e56b7acf80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The viewmodel is bound to the view&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Модель просмотра привязана к представлению&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6460afbcbb4cbdec561841a248ba1e6424d666a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This does not take a strict dependency on &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt; or any other particular module loader. &lt;em&gt;Any&lt;/em&gt; module loader that provides an AMD-style require API will do. If you want to integrate with a module loader whose API is different, you can implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Это не требует строгой зависимости от &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt; или любого другого конкретного загрузчика модуля. &lt;em&gt;Подойдет любой&lt;/em&gt; загрузчик модулей, который предоставляет требуемый API в стиле AMD. Если вы хотите интегрироваться с загрузчиком модуля, API которого отличается, вы можете реализовать &lt;a href=&quot;component-loaders&quot;&gt;собственный загрузчик компонентов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c04dcd21b22096736da7955495e67376657beed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trivially extensible&lt;/strong&gt; - implement custom behaviors as new declarative bindings for easy reuse in just a few lines of code.</source>
          <target state="translated">&lt;strong&gt;Тривиально расширяемый&lt;/strong&gt; - реализуйте настраиваемые поведения в виде новых декларативных привязок для удобного повторного использования всего в нескольких строках кода.</target>
        </trans-unit>
        <trans-unit id="f0992ab4728f88b2a84a0b8caa835c1cf39986f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the component&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Использование компонента&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32cbc5d0a2b4f65ca0027e1ba199cc25d7d8a11a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is component loading normally forced to be asynchronous?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Почему загрузка компонентов обычно выполняется асинхронно?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efa66cf89ab1790c16c3bd2f001aebe35bb73112" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why would you ever enable synchronous loading?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Зачем вообще включать синхронную загрузку?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6f570eaf052941ca34607e3a4699d3fedd619ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Works on any mainstream browser&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge, others)</source>
          <target state="translated">&lt;strong&gt;Работает в любом основном браузере&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge и др.)</target>
        </trans-unit>
        <trans-unit id="b78c43aa7b941a0cf5c09e85ba15c220598279bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your component loaders are asked to supply the viewmodel factory and template&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вашим загрузчикам компонентов предлагается предоставить фабрику и шаблон модели представления.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96c74267b4a56b3e028b9afdd40d0fafdfcfdcb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binding context&lt;/em&gt; is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the viewModel parameter you supplied to ko.applyBindings(viewModel). Then, each time you use a control flow binding such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, that creates a child binding context that refers to the nested view model data.</source>
          <target state="translated">&lt;em&gt;Связывания контекста&lt;/em&gt; является объектом , который содержит данные, которые вы можете ссылаться с креплений. При применении привязок Knockout автоматически создает иерархию контекстов привязки и управляет ею. Корневой уровень иерархии относится к параметру viewModel, который вы указали для ko.applyBindings (viewModel). Затем, каждый раз, когда вы используете привязку потока управления, такую ​​как &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; или &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; , создается дочерний контекст привязки, который ссылается на данные модели вложенного представления.</target>
        </trans-unit>
        <trans-unit id="f4a248fb269bbbb88f6088e277f3883569cefc2a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;model&lt;/em&gt;: your application&amp;rsquo;s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</source>
          <target state="translated">&lt;em&gt;Модель&lt;/em&gt; : сохраненные данные вашего приложения. Эти данные представляют объекты и операции в вашей бизнес-сфере (например, банковские счета, по которым можно осуществлять денежные переводы) и не зависят от какого-либо пользовательского интерфейса. При использовании KO вы обычно будете выполнять Ajax-вызовы некоторого серверного кода для чтения и записи этих сохраненных данных модели.</target>
        </trans-unit>
        <trans-unit id="672cec499a5e1f1cee87a332d86b3b33abc231fe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pure&lt;/em&gt; computed observable automatically switches between two states based on whether it has change subscribers.</source>
          <target state="translated">&lt;em&gt;Чистый&lt;/em&gt; вычисленные наблюдаемое автоматически переключается между двумя государствами на основе того, имеет ли это абоненты изменений.</target>
        </trans-unit>
        <trans-unit id="59bc15f49d66eaa773779760f79faa3fa9423729" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view model&lt;/em&gt;: a pure-code representation of the data and operations on a UI. For example, if you&amp;rsquo;re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</source>
          <target state="translated">Модель &lt;em&gt;представления&lt;/em&gt; : представление данных и операций в пользовательском интерфейсе в чистом виде. Например, если вы реализуете редактор списков, ваша модель представления будет представлять собой объект, содержащий список элементов и предоставляющий методы для добавления и удаления элементов.</target>
        </trans-unit>
        <trans-unit id="eace4ec15816838615483a0f9f07130cd593dae7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view&lt;/em&gt;: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</source>
          <target state="translated">&lt;em&gt;Вид&lt;/em&gt; : видимый, интерактивный пользовательский интерфейс , представляющий состояние модели представления. Он отображает информацию из модели представления, отправляет команды модели представления (например, когда пользователь нажимает кнопки) и обновляется всякий раз, когда изменяется состояние модели представления.</target>
        </trans-unit>
        <trans-unit id="ca93da47b0c5a3da43e52690cd086f2e1a2ebd77" translate="yes" xml:space="preserve">
          <source>A DOM node being added to the document</source>
          <target state="translated">DOM-узел добавляется в документ.</target>
        </trans-unit>
        <trans-unit id="d551d8332829826ecacd9fb849d14363184a926a" translate="yes" xml:space="preserve">
          <source>A DOM node that may be about to move</source>
          <target state="translated">DOM-узел,который может вот-вот переместиться...</target>
        </trans-unit>
        <trans-unit id="6331cd6f9ebb43fddcf15dfc9b7fb432c2f730af" translate="yes" xml:space="preserve">
          <source>A DOM node that may have moved</source>
          <target state="translated">DOM-узел,который,возможно,переместился</target>
        </trans-unit>
        <trans-unit id="9a3f7e5611e70df33d8f227c6f7b7360a7dd399e" translate="yes" xml:space="preserve">
          <source>A DOM node that you should remove</source>
          <target state="translated">DOM-узел,который вы должны удалить</target>
        </trans-unit>
        <trans-unit id="73d257d4d5c6be661a1e19a48818fd69414e6730" translate="yes" xml:space="preserve">
          <source>A JavaScript object whose properties will be copied to the binding context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9b23eb6c3fecb0a19eee9723a2f762712f465" translate="yes" xml:space="preserve">
          <source>A binding consists of two items, the binding &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt;, separated by a colon. Here is an example of a single, simple binding:</source>
          <target state="translated">Привязка состоит из двух элементов, связывающего &lt;em&gt;имени&lt;/em&gt; и &lt;em&gt;значения&lt;/em&gt; , разделенных двоеточием. Вот пример простой привязки:</target>
        </trans-unit>
        <trans-unit id="b97f27c6008d5459bdb04cdb810c301f0271f67b" translate="yes" xml:space="preserve">
          <source>A computed observable can be constructed using one of the following forms:</source>
          <target state="translated">Расчетная наблюдаемая форма может быть построена с использованием одной из следующих форм:</target>
        </trans-unit>
        <trans-unit id="9b3c42d55504f21b1b9ff8c6dc937021d9e0fbbb" translate="yes" xml:space="preserve">
          <source>A computed observable provides the following functions:</source>
          <target state="translated">Рассчитанный наблюдаемый обеспечивает следующие функции:</target>
        </trans-unit>
        <trans-unit id="ee2ee99b4fbef7f88d22ec53a5ac2485da3ddb43" translate="yes" xml:space="preserve">
          <source>A constructor function</source>
          <target state="translated">Функция конструктора</target>
        </trans-unit>
        <trans-unit id="d421b1fb0fc49225f6485c171df52e5c3cf18816" translate="yes" xml:space="preserve">
          <source>A createViewModel factory function</source>
          <target state="translated">Функция фабрики createViewModel</target>
        </trans-unit>
        <trans-unit id="3140686e93078602a724ffd63d00b2000a63120a" translate="yes" xml:space="preserve">
          <source>A custom component loader is simply an object whose properties are &lt;strong&gt;any combination&lt;/strong&gt; of the following functions:</source>
          <target state="translated">Загрузчик пользовательских компонентов - это просто объект, свойства которого представляют собой &lt;strong&gt;любую комбинацию&lt;/strong&gt; следующих функций:</target>
        </trans-unit>
        <trans-unit id="875be908e85823e41220d8f215eb69acb7523ecf" translate="yes" xml:space="preserve">
          <source>A custom element can have a regular data-bind attribute (in addition to any params attribute) if needed. For example,</source>
          <target state="translated">При необходимости пользовательский элемент может иметь обычный атрибут data-bind (в дополнение к любому атрибуту params).Например,</target>
        </trans-unit>
        <trans-unit id="ed4ac8818951d35d2d4f2644dd9eaf887a755c40" translate="yes" xml:space="preserve">
          <source>A custom function that will handle the scheduling of notifications. For example, you could use Underscore&amp;rsquo;s throttle method: myObservable.extend({ rateLimit: { timeout: 500, method: _.throttle } }); For more details, see the section below on custom rate-limit methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbce704022becdf28532ea1454acbf19683d7755" translate="yes" xml:space="preserve">
          <source>A document fragment</source>
          <target state="translated">Фрагмент документа</target>
        </trans-unit>
        <trans-unit id="a84827e1e80c6d853c30bc27f2185443890c1904" translate="yes" xml:space="preserve">
          <source>A popular convention that simplifies things</source>
          <target state="translated">Популярная конвенция,которая упрощает</target>
        </trans-unit>
        <trans-unit id="0fb40af78bc85a323dc4a804096a956f6e13aef0" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies an awake event (using its current value) whenever it enters the &lt;em&gt;listening&lt;/em&gt; state and notifies an asleep event (using an undefined value) whevener it enter the &lt;em&gt;sleeping&lt;/em&gt; state. You won&amp;rsquo;t normally need to know about the internal state of your computed observables. But since the internal state can correspond to whether the computed observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</source>
          <target state="translated">Чистый вычисляемый наблюдаемый уведомляет о событии бодрствования (используя свое текущее значение) всякий раз, когда он входит в состояние &lt;em&gt;прослушивания,&lt;/em&gt; и уведомляет о событии сна (используя неопределенное значение), когда он входит в состояние &lt;em&gt;сна&lt;/em&gt; . Обычно вам не нужно знать о внутреннем состоянии ваших вычисленных наблюдаемых. Но поскольку внутреннее состояние может соответствовать тому, привязана ли вычисляемая наблюдаемая к представлению или нет, вы можете использовать эту информацию для инициализации или очистки некоторой модели представления.</target>
        </trans-unit>
        <trans-unit id="d17d0e20bbc6723a6f53f7095e5b9e515f8490db" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies some events that allow you to respond to changes to the state of the observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219abd734eaa39b3e5af5d4aae85aae74f210ba7" translate="yes" xml:space="preserve">
          <source>A recommended AMD module pattern</source>
          <target state="translated">Рекомендуемый образец модуля AMD</target>
        </trans-unit>
        <trans-unit id="96a16d06ab9525707f973555c03a9a069b2890ef" translate="yes" xml:space="preserve">
          <source>A shared object instance</source>
          <target state="translated">Общий объект экземпляр</target>
        </trans-unit>
        <trans-unit id="f05cd21e831a202875a8dffd0d37c25b82bec9e6" translate="yes" xml:space="preserve">
          <source>A simpler and more elegant option, however, is to use as to declare a name for your iteration variables. For example:</source>
          <target state="translated">Простой и элегантный вариант,однако,состоит в том,чтобы использовать его для объявления имени итерационных переменных.Например:</target>
        </trans-unit>
        <trans-unit id="a7c8841f5e8f9c936c29327e4d6733bdab3c12e1" translate="yes" xml:space="preserve">
          <source>A string of markup</source>
          <target state="translated">Строка разметки</target>
        </trans-unit>
        <trans-unit id="41a59868d9ef75167ce556f0565eb922f6cc31f5" translate="yes" xml:space="preserve">
          <source>A value that controls whether or not the associated DOM element should be enabled.</source>
          <target state="translated">Значение,которое контролирует,должен ли соответствующий элемент флэш-памяти быть включен или нет.</target>
        </trans-unit>
        <trans-unit id="1629231a910c1a9903f050df95a79a00ff663fe9" translate="yes" xml:space="preserve">
          <source>AMD modules are loaded only on demand</source>
          <target state="translated">AMD модули загружаются только по требованию</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="dba104dad21c672e8d177c331e1988224ee9c40f" translate="yes" xml:space="preserve">
          <source>Activating Knockout</source>
          <target state="translated">Активирующий нокаут</target>
        </trans-unit>
        <trans-unit id="9e50bbf06486aad9ed5858d61f790ecc35cf4bdb" translate="yes" xml:space="preserve">
          <source>Adding custom functions using &quot;fn&quot;</source>
          <target state="translated">Добавление пользовательских функций с помощью &quot;fn&quot;</target>
        </trans-unit>
        <trans-unit id="5f55b709f75ff470666d48ed8e0dd3202f9462b3" translate="yes" xml:space="preserve">
          <source>Additional benefits:</source>
          <target state="translated">Дополнительные преимущества:</target>
        </trans-unit>
        <trans-unit id="d9ca1471a1c5c73c1eaf333a7d893c103077a28a" translate="yes" xml:space="preserve">
          <source>Additional parameters</source>
          <target state="translated">Дополнительные параметры</target>
        </trans-unit>
        <trans-unit id="2eecc85d283c6cfc2c01cf8cf19d07776798fd03" translate="yes" xml:space="preserve">
          <source>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</source>
          <target state="translated">Кроме того,Knockout предоставляет похожие функции,которые могут работать на наблюдаемых и вычисляемых наблюдениях:</target>
        </trans-unit>
        <trans-unit id="69d691f44445960d684f25080c894d46d0ef6515" translate="yes" xml:space="preserve">
          <source>Advanced queue control</source>
          <target state="translated">Расширенный контроль очереди</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">Расширенное использование</target>
        </trans-unit>
        <trans-unit id="bdafa12daa294233db606dc624e7cfa8736c4318" translate="yes" xml:space="preserve">
          <source>Advanced: Accessing $raw parameters</source>
          <target state="translated">Продвинутый:Доступ к параметрам $raw</target>
        </trans-unit>
        <trans-unit id="acb27fde407851516098c690ede0080b631c0f01" translate="yes" xml:space="preserve">
          <source>Advanced: Custom component loaders</source>
          <target state="translated">Продвинутый:Пользовательские погрузчики компонентов</target>
        </trans-unit>
        <trans-unit id="6b68add7c4ef423265bf6c36f75e07b61ca328f2" translate="yes" xml:space="preserve">
          <source>After you have defined the module update the input element from the HTML example above to be:</source>
          <target state="translated">После определения модуля обновите входной элемент из приведенного выше примера HTML:</target>
        </trans-unit>
        <trans-unit id="329df29582c6ec3024bef034171a5a78bd9cbb39" translate="yes" xml:space="preserve">
          <source>Again, only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned for use as the component&amp;rsquo;s template.</source>
          <target state="translated">Опять же, только узлы &lt;em&gt;внутри&lt;/em&gt; указанного элемента будут клонированы для использования в качестве шаблона компонента.</target>
        </trans-unit>
        <trans-unit id="a9180eedfdd61587618067116c1c45385c35cb38" translate="yes" xml:space="preserve">
          <source>All change notifications are delayed, including when calling valueHasMutated manually. This means you can&amp;rsquo;t use valueHasMutated to force a rate-limited observable to notify an un-changed value.</source>
          <target state="translated">Все уведомления об изменениях задерживаются, в том числе при вызове valueHasMutated вручную. Это означает, что вы не можете использовать valueHasMutated, чтобы заставить ограниченную по скорости наблюдаемую уведомлять о неизмененном значении.</target>
        </trans-unit>
        <trans-unit id="1faff78215a2b42eb91a45b8356b4f79235b938d" translate="yes" xml:space="preserve">
          <source>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</source>
          <target state="translated">Все эти функции эквивалентны запуску родных JavaScript-функций массива на базовом массиве,а затем оповещению слушателей об изменении:</target>
        </trans-unit>
        <trans-unit id="2c9de1c05e289fb463cf3a1c26f4670e737ed411" translate="yes" xml:space="preserve">
          <source>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</source>
          <target state="translated">Все свойства объекта преобразуются в наблюдаемые.Если обновление изменит значение,то это приведет к обновлению наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="38c026ebda36ef4388e796344b3abce466922b2b" translate="yes" xml:space="preserve">
          <source>Also, randomOrder will still work with regular DOM elements, because all of the ko.virtualElements APIs are backwardly compatible with regular DOM elements.</source>
          <target state="translated">Кроме того,randomOrder будет по-прежнему работать с обычными DOM-элементами,потому что все API ko.virtualElements обратно совместимы с обычными DOM-элементами.</target>
        </trans-unit>
        <trans-unit id="8fda4896a6cfabf38010923d25545054759b05e1" translate="yes" xml:space="preserve">
          <source>Also, since ko.components.defaultLoader is a component loader, it implements the following standard component loader functions. You can invoke these directly, e.g., as part of your implementation of a custom loader:</source>
          <target state="translated">Также,поскольку ko.components.defaultLoader является загрузчиком компонентов,он реализует следующие стандартные функции загрузчика компонентов.Вы можете вызывать их напрямую,например,в рамках реализации пользовательского загрузчика:</target>
        </trans-unit>
        <trans-unit id="4edfae09ecfcc29756a62316c12a008c591612f8" translate="yes" xml:space="preserve">
          <source>Also, you need to have referenced a suitable module loader library (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) or implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that knows how to grab your files.</source>
          <target state="translated">Кроме того, вам необходимо иметь ссылку на подходящую библиотеку загрузчика модулей (например, &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; ) или реализовать &lt;a href=&quot;component-loaders&quot;&gt;пользовательский загрузчик компонентов,&lt;/a&gt; который знает, как получать ваши файлы.</target>
        </trans-unit>
        <trans-unit id="db4db8b9b399a9292d2681e94db2f56cc50be27a" translate="yes" xml:space="preserve">
          <source>Alternatively, components also support a direct method to receive a descendantsComplete notification. If your component view model has a koDescendantsComplete function, Knockout will call it with the component&amp;rsquo;s node once all descendants are bound. For example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5cc861eaf7ac508de6b2b58d1ed770fee1e988" translate="yes" xml:space="preserve">
          <source>Alternatively, if you prefer to avoid the function literal in your view, you can use the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;bind&lt;/a&gt; function, which attaches specific parameter values to a function reference:</source>
          <target state="translated">В качестве альтернативы, если вы предпочитаете избегать использования литерала функции в своем представлении, вы можете использовать функцию &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;привязки&lt;/a&gt; , которая прикрепляет определенные значения параметров к ссылке на функцию:</target>
        </trans-unit>
        <trans-unit id="fa6e7ea09a57e761a9110c8a9df4784c24443111" translate="yes" xml:space="preserve">
          <source>Alternatively, pass a JavaScript object literal with a property called data which is the array you wish to iterate over. The object literal may also have other properties, such as afterAdd or includeDestroyed &amp;mdash; see below for details of these extra options and examples of their use.</source>
          <target state="translated">В качестве альтернативы передайте литерал объекта JavaScript со свойством data, которое представляет собой массив, по которому вы хотите выполнить итерацию. Литерал объекта может также иметь другие свойства, такие как afterAdd или includeDestroyed - подробности об этих дополнительных параметрах и примеры их использования см. Ниже.</target>
        </trans-unit>
        <trans-unit id="b7dfbc21d336e304b1aefd8da00433e7d002f8f1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;override getComponentNameForNode&lt;/a&gt; to control dynamically which elements map to which component names, independently of preregistration.</source>
          <target state="translated">В качестве альтернативы вы можете &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;переопределить getComponentNameForNode,&lt;/a&gt; чтобы динамически контролировать, какие элементы сопоставляются с именами компонентов, независимо от предварительной регистрации.</target>
        </trans-unit>
        <trans-unit id="ae14a33d0421d469795c28cb8d6c7b5a300d1437" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the pure option with ko.computed:</source>
          <target state="translated">Кроме того,вы можете использовать чистый вариант с ko.computed:</target>
        </trans-unit>
        <trans-unit id="c6881ab5fe1c9360a98b31b040fcb030610e5b9a" translate="yes" xml:space="preserve">
          <source>Alternatively, you don&amp;rsquo;t need to create a computed observable if you&amp;rsquo;re doing something simple like this. You can pass an arbitrary JavaScript expression to the text binding. For example,</source>
          <target state="translated">В качестве альтернативы вам не нужно создавать вычисляемую наблюдаемую, если вы делаете что-то простое, подобное этому. В привязку текста можно передать произвольное выражение JavaScript. Например,</target>
        </trans-unit>
        <trans-unit id="467b199c0d9c0c472351991602cecc7ed24eedcf" translate="yes" xml:space="preserve">
          <source>Although deferred, asynchronous notifications are generally better because of fewer UI updates, it can be a problem if you need to update the UI immediately. Sometimes, for proper functionality, you need an intermediate value pushed to the UI. You can accomplish this using the &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;ko.tasks.runEarly method&lt;/a&gt;. For example:</source>
          <target state="translated">Хотя отложенные, асинхронные уведомления обычно лучше из-за меньшего количества обновлений пользовательского интерфейса, это может быть проблемой, если вам нужно обновить пользовательский интерфейс немедленно. Иногда для правильной работы вам нужно передать промежуточное значение в пользовательский интерфейс. Вы можете сделать это с &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;помощью метода ko.tasks.runEarly&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="cccda6b76e9fe36a78cbb8b19672fab53b808ae3" translate="yes" xml:space="preserve">
          <source>Although the &lt;a href=&quot;value-binding&quot;&gt;value binding&lt;/a&gt; can also perform two-way binding between text boxes and viewmodel properties, you should prefer textInput whenever you want immediate live updates. The main differences are:</source>
          <target state="translated">Хотя &lt;a href=&quot;value-binding&quot;&gt;привязка значения&lt;/a&gt; также может выполнять двустороннюю привязку между текстовыми полями и свойствами модели представления, вы должны предпочесть textInput всякий раз, когда вам нужны немедленные обновления в реальном времени. Основные отличия:</target>
        </trans-unit>
        <trans-unit id="54e9247f8574a1aa66c8291b2a6f5cecfef75b1e" translate="yes" xml:space="preserve">
          <source>Although the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, my-special-list), which can include them in its output however it wishes.</source>
          <target state="translated">Хотя DOM-узлы в этом элементе будут удалены и не привязаны по умолчанию,они не потеряны.Вместо этого они поставляются компоненту (в данном случае-my-special-list),который может включать их в свой выход,как ему заблагорассудится.</target>
        </trans-unit>
        <trans-unit id="065f5f46184d6f9b66cb0337f9c8985d191e4c55" translate="yes" xml:space="preserve">
          <source>Although you can subscribe to and access an observableArray just like any other observable, Knockout also provides a super-fast method to find out how an observable array has changed (i.e., which items were just added, deleted, or moved). You subscribe to array changes as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64e2a25f4ecdbf890fa878004386d735536f164" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a template</source>
          <target state="translated">Модуль AMD,значение которого описывает шаблон</target>
        </trans-unit>
        <trans-unit id="e68eb6e1b6701b3c386d6f393c8c2332fcca13e2" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a viewmodel</source>
          <target state="translated">Модуль AMD,значение которого описывает вид-модель</target>
        </trans-unit>
        <trans-unit id="242417090831cde58cc194cc22ae4eab474f143d" translate="yes" xml:space="preserve">
          <source>An array of DOM nodes</source>
          <target state="translated">Массив DOM-узлов</target>
        </trans-unit>
        <trans-unit id="968a4f61a70888dd1fa2a0eb32b82dc937a8263d" translate="yes" xml:space="preserve">
          <source>An array of the inserted DOM elements</source>
          <target state="translated">Массив вставленных DOM-элементов</target>
        </trans-unit>
        <trans-unit id="677bc5c11af17aad4286438791881da11106a6b3" translate="yes" xml:space="preserve">
          <source>An element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:</source>
          <target state="translated">Элемент может включать в себя несколько привязок (связанных или несвязанных),при этом каждая привязка отделяется запятой.Приведем несколько примеров:</target>
        </trans-unit>
        <trans-unit id="4d626c0f133638f459d4ffb6d3a56ba114d6d9ce" translate="yes" xml:space="preserve">
          <source>An existing element ID</source>
          <target state="translated">Существующий идентификатор элемента</target>
        </trans-unit>
        <trans-unit id="e36639c5e653a711057a5a79fa2fd56cc32a4737" translate="yes" xml:space="preserve">
          <source>An existing element instance</source>
          <target state="translated">Существующий элементный экземпляр</target>
        </trans-unit>
        <trans-unit id="f48281418a421e56b65e2f335f96fc8ee14c0591" translate="yes" xml:space="preserve">
          <source>An object whose keys determine which bindings are usable with virtual elements. Set ko.virtualElements.allowedBindings.mySuperBinding = true to allow mySuperBinding to be used with virtual elements.</source>
          <target state="translated">Объект,ключи которого определяют,какие привязки можно использовать с виртуальными элементами.Установите ko.virtualElements.allowedBindings.mySuperBinding=true,чтобы разрешить использование mySuperBinding с виртуальными элементами.</target>
        </trans-unit>
        <trans-unit id="dd15fd1ba5ddf1cc618917899b23e48ea396d2d4" translate="yes" xml:space="preserve">
          <source>An observableArray has array tracking enabled at construction, but you can extend any other subscribable (i.e. ko.observable and ko.computed) as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750e1b4a97e09ed466c53a7a581f325eb74fda90" translate="yes" xml:space="preserve">
          <source>And name would have changed as expected. However, in the children array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the name property of the child was updated from Alicw to Alice, not that the entire child was replaced!</source>
          <target state="translated">И имя бы изменилось,как и ожидалось.Однако,в дочернем массиве (Alicw)дочерний элемент (Alice)был бы полностью удален,а новый элемент (Alice)был бы добавлен.Это не совсем то,что вы ожидали.Вместо этого,вы бы ожидали,что только свойства имени дочернего массива были обновлены от Alicw к Alice,а не заменены полностью!</target>
        </trans-unit>
        <trans-unit id="e9ca86081be1235e5d657f4784b8eda45576a203" translate="yes" xml:space="preserve">
          <source>Any existing content is removed and discarded.</source>
          <target state="translated">Любое существующее содержимое удаляется и отбрасывается.</target>
        </trans-unit>
        <trans-unit id="4f4f05405754c54fdd9676fba604372b29335c05" translate="yes" xml:space="preserve">
          <source>Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their *JS counterparts.</source>
          <target state="translated">Кроме того,что они работают с JSON-строками вместо JS-объектов,эти функции полностью идентичны своим *JS аналогам.</target>
        </trans-unit>
        <trans-unit id="7f1ccfc969139d4ee723e3cd26a3b87a5f4bd6fb" translate="yes" xml:space="preserve">
          <source>Applications can reference this trivially, i.e., ko.components.register('my-component', { require: 'path/my-component' });</source>
          <target state="translated">Приложения могут ссылаться на это тривиально,т.е.ko.components.register('my-component',{требуется:'path/my-component' });</target>
        </trans-unit>
        <trans-unit id="c1c42fc46dfc0ee9be1215927e31c8ac247229ec" translate="yes" xml:space="preserve">
          <source>Applying multiple extenders</source>
          <target state="translated">Применение нескольких удлинителей</target>
        </trans-unit>
        <trans-unit id="bb775857f1edfb66da986af1438cdd40f990f61d" translate="yes" xml:space="preserve">
          <source>Applying the rateLimit extender</source>
          <target state="translated">Применение ограничителя скоростиLimit Extender</target>
        </trans-unit>
        <trans-unit id="a30bfe9fb3fdb4e5e2bd1e24672ab720fe7f064f" translate="yes" xml:space="preserve">
          <source>Arrays are converted into &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt;. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</source>
          <target state="translated">Массивы преобразуются в &lt;a href=&quot;observablearrays&quot;&gt;наблюдаемые массивы&lt;/a&gt; . Если обновление изменит количество элементов, оно выполнит соответствующие действия добавления / удаления. Он также попытается сохранить порядок в исходном массиве JavaScript.</target>
        </trans-unit>
        <trans-unit id="64e6eb4e5415e08468cb571b630e6982ce45a64e" translate="yes" xml:space="preserve">
          <source>As an alternative, Knockout provides two helper functions that allow you to identify the data associated with a DOM element:</source>
          <target state="translated">В качестве альтернативы Knockout предоставляет две вспомогательные функции,которые позволяют идентифицировать данные,связанные с элементом DOM:</target>
        </trans-unit>
        <trans-unit id="18bd9d7dc396ea105d8584c5d8a67ce95140998c" translate="yes" xml:space="preserve">
          <source>As an array, $componentTemplateNodes, available to any binding expression in the component&amp;rsquo;s template (i.e., as a &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; property). Usually this is the most convenient way to use the supplied markup. See the example below.</source>
          <target state="translated">Как массив $ componentTemplateNodes, доступный для любого выражения привязки в шаблоне компонента (то есть как свойство &lt;a href=&quot;binding-context&quot;&gt;контекста привязки&lt;/a&gt; ). Обычно это наиболее удобный способ использования предоставленной разметки. См. Пример ниже.</target>
        </trans-unit>
        <trans-unit id="bdc42cbe041397354fa48d36ba2fff1663ff9d0f" translate="yes" xml:space="preserve">
          <source>As an array, componentInfo.templateNodes, passed to its &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;createViewModel function&lt;/a&gt;</source>
          <target state="translated">Как массив componentInfo.templateNodes, переданный его &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;функции createViewModel&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ab4f1ab556f0024f4505366ba60640abe3aa3a6" translate="yes" xml:space="preserve">
          <source>As described in Note 1, you can refer to each array entry using the $data &lt;a href=&quot;binding-context&quot;&gt;context variable&lt;/a&gt;. In some cases though, it may be useful to give the current item a more descriptive name using the as option like:</source>
          <target state="translated">Как описано в примечании 1, вы можете ссылаться на каждую запись массива с помощью &lt;a href=&quot;binding-context&quot;&gt;контекстной переменной&lt;/a&gt; $ data . Однако в некоторых случаях может быть полезно дать текущему элементу более информативное имя, используя параметр as, например:</target>
        </trans-unit>
        <trans-unit id="c9e6cce525faa11e83082f916934eb369ee22979" translate="yes" xml:space="preserve">
          <source>As illustrated in this example, KO passes the form element as a parameter to your submit handler function. You can ignore that parameter if you want, or there are various ways you might want to use it, for example:</source>
          <target state="translated">Как показано в этом примере,KO передает элемент формы в качестве параметра в вашу функцию обработчика отправки.Вы можете игнорировать этот параметр,если хотите,или есть различные способы его использования,например:</target>
        </trans-unit>
        <trans-unit id="5900cfc0e230ba6370b7536d4e0bc93369597873" translate="yes" xml:space="preserve">
          <source>As long as they reference different CSS class names, you can include both class and css bindings on the same element. Thus you can have some classes that are set based on a true/false value and others that are calculated dynamically. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb01af05163d90a3c9bcdc7eb32c655738d0ff1e" translate="yes" xml:space="preserve">
          <source>As shown above, the changes are reported as a list of &lt;em&gt;added&lt;/em&gt; and &lt;em&gt;deleted&lt;/em&gt; values. The indexes for &lt;em&gt;deleted&lt;/em&gt; items refer to the original array, and the indexes for &lt;em&gt;added&lt;/em&gt; items refer to the new array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40531ab2533e66fef97d544b345056144f69e728" translate="yes" xml:space="preserve">
          <source>As shown in the above examples, bindings within the foreach block can refer to properties on the array entries. For example, &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; referenced the firstName and lastName properties on each array entry.</source>
          <target state="translated">Как показано в приведенных выше примерах, привязки внутри блока foreach могут ссылаться на свойства записей массива. Например, &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Пример 1&lt;/a&gt; ссылается на свойства firstName и lastName для каждой записи массива.</target>
        </trans-unit>
        <trans-unit id="03dd56f30baeedf6f43ffeb0f96b6c0c125970f3" translate="yes" xml:space="preserve">
          <source>As soon as your UI gets nontrivial and has a few overlapping behaviors, things can get tricky and expensive to maintain if you only use jQuery. Consider an example: you&amp;rsquo;re displaying a list of items, stating the number of items in that list, and want to enable an &amp;lsquo;Add&amp;rsquo; button only when there are fewer than 5 items. jQuery doesn&amp;rsquo;t have a concept of an underlying data model, so to get the number of items you have to infer it from the number of TRs in a table or the number of DIVs with a certain CSS class. Maybe the number of items is displayed in some SPAN, and you have to remember to update that SPAN&amp;rsquo;s text when the user adds an item. You also must remember to disable the &amp;lsquo;Add&amp;rsquo; button when the number of TRs is 5. Later, you&amp;rsquo;re asked also to implement a &amp;lsquo;Delete&amp;rsquo; button and you have to figure out which DOM elements to change whenever it&amp;rsquo;s clicked.</source>
          <target state="translated">Как только ваш пользовательский интерфейс становится нетривиальным и имеет несколько дублирующих друг друга поведений, обслуживание становится сложным и дорогостоящим, если вы используете только jQuery. Рассмотрим пример: вы показываете список элементов, указываете количество элементов в этом списке и хотите активировать кнопку &amp;laquo;Добавить&amp;raquo; только тогда, когда их меньше 5. jQuery не имеет концепции базовой модели данных, поэтому, чтобы получить количество элементов, вы должны вывести его из количества TR в таблице или количества DIV с определенным классом CSS. Возможно, количество элементов отображается в каком-то SPAN, и вы должны помнить об обновлении текста этого SPAN, когда пользователь добавляет элемент. Вы также должны не забыть отключить кнопку &amp;laquo;Добавить&amp;raquo;, когда количество TR равно 5. Позже вас также попросят реализовать кнопку &amp;laquo;Удалить&amp;raquo;, и вы должны выяснить, какие элементы DOM следует изменять при каждом нажатии.</target>
        </trans-unit>
        <trans-unit id="3824481999af1a08c2a42310b9623d970b4c8e60" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="translated">Как обычно,в качестве значений параметров можно использовать произвольные выражения JavaScript или функции.KO будет оценивать их и использовать полученные значения для определения применяемых значений стиля.</target>
        </trans-unit>
        <trans-unit id="ce18070a48ec4dcf3c21d8c773695eaa7e43f60a" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="translated">Как обычно,в качестве значений параметров можно использовать произвольные выражения JavaScript или функции.KO будет оценивать их и использовать полученные значения для определения соответствующих CSS классов для добавления или удаления.</target>
        </trans-unit>
        <trans-unit id="be219c6df3733113cae67ffbcbc8620e153c2b9c" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting value to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4da197852de89fac4dcfd406e4865e31c17c79" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fd897b08c686dca588676f977987af4cbc17de" translate="yes" xml:space="preserve">
          <source>As well as (or instead of) template and viewModel, your component configuration object can have arbitrary other properties. This configuration object is made available to any &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; you may be using.</source>
          <target state="translated">Помимо (или вместо) шаблона и viewModel, ваш объект конфигурации компонента может иметь любые другие свойства. Этот объект конфигурации доступен для любого &lt;a href=&quot;component-loaders&quot;&gt;загрузчика пользовательских компонентов, который&lt;/a&gt; вы можете использовать.</target>
        </trans-unit>
        <trans-unit id="271643e4723e546ecfd37518fb0f1e341e319028" translate="yes" xml:space="preserve">
          <source>As you can see from Example 2 above, it&amp;rsquo;s possible to use $index to refer to the zero-based index of the current array item. $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">Как видно из примера 2 выше, можно использовать $ index для ссылки на отсчитываемый от нуля индекс текущего элемента массива. $ index является наблюдаемым и обновляется всякий раз, когда индекс элемента изменяется (например, если элементы добавляются в массив или удаляются из него).</target>
        </trans-unit>
        <trans-unit id="cabec4e28a1cc149d5844e47658d55240bebd319" translate="yes" xml:space="preserve">
          <source>As you can see, binding contexts have an extend function that produces a clone with extra properties. The extend function accepts either an object with the properties to copy or a function that returns such an object. The function syntax is preferred so that future changes in the binding value are always updated in the binding context. This process doesn&amp;rsquo;t affect the original binding context, so there is no danger of affecting sibling-level elements - it will only affect descendants.</source>
          <target state="translated">Как видите, контексты привязки имеют функцию расширения, которая создает клон с дополнительными свойствами. Функция расширения принимает либо объект со свойствами для копирования, либо функцию, возвращающую такой объект. Синтаксис функции является предпочтительным, чтобы будущие изменения значения привязки всегда обновлялись в контексте привязки. Этот процесс не влияет на исходный контекст привязки, поэтому нет опасности повлиять на элементы уровня одного и того же уровня - он затронет только потомков.</target>
        </trans-unit>
        <trans-unit id="9ea6690b6b5207f9ef37a626e0bbe8a12a55cab9" translate="yes" xml:space="preserve">
          <source>As you have seen in the examples above, you can use a params attribute to supply parameters to the component viewmodel. The contents of the params attribute are interpreted like a JavaScript object literal (just like a data-bind attribute), so you can pass arbitrary values of any type. Example:</source>
          <target state="translated">Как вы видели в примерах выше,вы можете использовать атрибут params для поставки параметров в viewmodel компонента.Содержимое атрибута params интерпретируется как литературный объект JavaScript (точно так же,как и атрибут data-bind),поэтому Вы можете передавать произвольные значения любого типа.Пример:</target>
        </trans-unit>
        <trans-unit id="e34c40ba0f5fa3fb6eb13d61c372271984f13555" translate="yes" xml:space="preserve">
          <source>Assuming your array is an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire foreach output after each array change.</source>
          <target state="translated">Предполагая, что ваш массив является &lt;a href=&quot;observablearrays&quot;&gt;наблюдаемым массивом&lt;/a&gt; , всякий раз, когда вы позже добавляете, удаляете или переупорядочиваете записи массива, привязка будет эффективно обновлять пользовательский интерфейс для соответствия - вставляя или удаляя больше копий разметки или переупорядочивая существующие элементы DOM, без влияет на любые другие элементы DOM. Это намного быстрее, чем восстановление всего вывода foreach после каждого изменения массива.</target>
        </trans-unit>
        <trans-unit id="0a29a876f6fee0ab06e8d6374c2a1f8b7410a520" translate="yes" xml:space="preserve">
          <source>Asynchronous Module Definition (AMD) With RequireJs</source>
          <target state="translated">Асинхронное определение модуля (AMD)с RequireJs</target>
        </trans-unit>
        <trans-unit id="f15ea1e1d443f1c22a341a9e0edeca34b288d76c" translate="yes" xml:space="preserve">
          <source>Asynchronous error handling</source>
          <target state="translated">Асинхронная обработка ошибок</target>
        </trans-unit>
        <trans-unit id="f8b6cc5cdc6b8261c411bf780fb442ecccc793b5" translate="yes" xml:space="preserve">
          <source>Asynchronous module definition (AMD) with requireJs</source>
          <target state="translated">Асинхронное определение модуля (AMD)с requireJs</target>
        </trans-unit>
        <trans-unit id="4669c785b85f8d268aedb9a3b7494a7c8313488f" translate="yes" xml:space="preserve">
          <source>Because of inheritance, if you attach a function to ko.subscribable, it will be available on all the others too. If you attach a function to ko.observable, it will be inherited by ko.observableArray but not by ko.computed.</source>
          <target state="translated">Из-за наследования,если вы прикрепите функцию к ko.subscribable,она будет доступна и на всех остальных.Если вы прикрепите функцию к ko.observable,она будет наследована ko.observableArray,но не ko.calculated.</target>
        </trans-unit>
        <trans-unit id="3aa536687687d7362ee99aa5d4ec974df63a5c14" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="translated">Поскольку self фиксируется в замыкании функции, он остается доступным и непротиворечивым во всех вложенных функциях, таких как вычислитель вычисляемого наблюдаемого. Это соглашение еще более полезно, когда дело касается обработчиков событий, как вы увидите во многих &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;живых примерах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd834cbc10e441f97b7b77e9db5957d9221be9db" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;https://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550907ac1f6696f0600c8c1a60187b368d514a83" translate="yes" xml:space="preserve">
          <source>Because the computed observable evaluates both pageIndex and pageSize, it becomes dependent on both of them. So, this code will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;$.getJSON function&lt;/a&gt; to reload currentPageData when a GridViewModel is first instantiated &lt;em&gt;and&lt;/em&gt; whenever the pageIndex or pageSize properties are later changed.</source>
          <target state="translated">Поскольку вычисляемый наблюдаемый объект оценивает и pageIndex, и pageSize, он становится зависимым от них обоих. Таким образом, этот код будет использовать &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;функцию&lt;/a&gt; jQuery $ .getJSON для перезагрузки currentPageData при первом создании экземпляра GridViewModel &lt;em&gt;и&lt;/em&gt; при каждом последующем изменении свойств pageIndex или pageSize.</target>
        </trans-unit>
        <trans-unit id="0c00e991fcf301ea36ef0431f7266e3845d6942f" translate="yes" xml:space="preserve">
          <source>Because the hasFocus binding works in both directions (setting the associated value focuses or unfocuses the element; focusing or unfocusing the element sets the associated value), it&amp;rsquo;s a convenient way to toggle an &amp;ldquo;edit&amp;rdquo; mode. In this example, the UI displays either a &amp;lt;span&amp;gt; or an &amp;lt;input&amp;gt; element depending on the model&amp;rsquo;s editing property. Unfocusing the &amp;lt;input&amp;gt; element sets editing to false, so the UI switches out of &amp;ldquo;edit&amp;rdquo; mode.</source>
          <target state="translated">Поскольку привязка hasFocus работает в обоих направлениях (установка связанного значения фокусирует или расфокусирует элемент; фокусировка или расфокусировка элемента устанавливает связанное значение), это удобный способ переключения режима &amp;laquo;редактирования&amp;raquo;. В этом примере пользовательский интерфейс отображает элемент &amp;lt;span&amp;gt; или &amp;lt;input&amp;gt; в зависимости от свойства редактирования модели. При расфокусировке элемента &amp;lt;input&amp;gt; для редактирования устанавливается значение false, поэтому пользовательский интерфейс выходит из режима &amp;laquo;редактирования&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bd8beb104f73636a98fcd6cda7c1acde17a32e28" translate="yes" xml:space="preserve">
          <source>Behind the scenes, an observableArray is actually an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</source>
          <target state="translated">За кулисами observableArray на самом деле является &lt;a href=&quot;observables&quot;&gt;наблюдаемым&lt;/a&gt; , значением которого является массив (плюс, observableArray добавляет некоторые дополнительные функции, описанные ниже). Итак, вы можете получить базовый массив JavaScript, вызвав observableArray как функцию без параметров, как и любой другой наблюдаемый объект. Затем вы можете прочитать информацию из этого базового массива. Например,</target>
        </trans-unit>
        <trans-unit id="9cd4c935e79a15a4f2de856a72f11306af77e87c" translate="yes" xml:space="preserve">
          <source>Better yet, this techinique could be used to support event delegation. jQuery&amp;rsquo;s live/delegate/on functions are an easy way to make this happen:</source>
          <target state="translated">Еще лучше, этот прием можно использовать для поддержки делегирования событий. Функции jQuery live / delegate / on - это простой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="7f0043e684cc2e548822e45bee14ea4c4673e262" translate="yes" xml:space="preserve">
          <source>Binding</source>
          <target state="translated">Binding</target>
        </trans-unit>
        <trans-unit id="3a81a526cb1140d2e424d0180bf85d9cd3d1c460" translate="yes" xml:space="preserve">
          <source>Binding context</source>
          <target state="translated">Связывающий контекст</target>
        </trans-unit>
        <trans-unit id="93d552de279f9f9e13483b79acf3dd9808266d2b" translate="yes" xml:space="preserve">
          <source>Binding lifecycle events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f722c7a7e44d3deb47b141e7f82c81b0815261" translate="yes" xml:space="preserve">
          <source>Binding preprocessor reference</source>
          <target state="translated">Ссылка на переплетный препроцессор</target>
        </trans-unit>
        <trans-unit id="7bd59c5a7fe5f05639190e405278fb2261e77836" translate="yes" xml:space="preserve">
          <source>Binding syntax</source>
          <target state="translated">Связывающий синтаксис</target>
        </trans-unit>
        <trans-unit id="a9b9212b6073a73407ac32ba882e6a4bcaeeaed2" translate="yes" xml:space="preserve">
          <source>Binding values</source>
          <target state="translated">Связывающие значения</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="89aea1a967b670a09ecb14ffdbd5170d33e77df9" translate="yes" xml:space="preserve">
          <source>Bindings can include JavaScript-style comments (//... and /*...*/). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0f9a9f1a5ef31bad0fa03e077b16e18f5a9b5" translate="yes" xml:space="preserve">
          <source>Bindings can include any amount of &lt;em&gt;whitespace&lt;/em&gt; (spaces, tab, and newlines), so you&amp;rsquo;re free to use it to arrange your bindings as you like. The following examples are all equivalent:</source>
          <target state="translated">Привязки могут включать любое количество &lt;em&gt;пробелов&lt;/em&gt; (пробелы, табуляция и символы новой строки), поэтому вы можете использовать их для упорядочивания привязок по своему усмотрению. Все следующие примеры эквивалентны:</target>
        </trans-unit>
        <trans-unit id="92f78f786d943b799c2c8bf4c4f8c9a36f323743" translate="yes" xml:space="preserve">
          <source>Bindings contexts offer the following special properties that you can reference in any binding:</source>
          <target state="translated">Контексты переплетов предлагают следующие специальные свойства,на которые вы можете ссылаться в любом переплёте:</target>
        </trans-unit>
        <trans-unit id="f7dfee65d89e215d7fc623cc4674a60289e7c1ce" translate="yes" xml:space="preserve">
          <source>Bindings such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; create extra levels in the binding context hierarchy. This means that their descendants can access data at outer levels by using $parent, $parents, $root, or $parentContext.</source>
          <target state="translated">Привязки, такие как &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; и &lt;a href=&quot;foreach-binding&quot;&gt;foreach,&lt;/a&gt; создают дополнительные уровни в иерархии контекста привязки. Это означает, что их потомки могут получать доступ к данным на внешних уровнях с помощью $ parent, $ parent, $ root или $ parentContext.</target>
        </trans-unit>
        <trans-unit id="6acc9a939f24c837662878de4c3d39eeade8294a" translate="yes" xml:space="preserve">
          <source>Both result and result2 will be:</source>
          <target state="translated">И результат,и результат2 будут:</target>
        </trans-unit>
        <trans-unit id="0b375916d78848c4b0ac042003d5c4e6a2e1607f" translate="yes" xml:space="preserve">
          <source>Browsers are highly inconsistent in the events that fire in response to unusual text entry mechanisms such as cutting, dragging, or accepting autocomplete suggestions. The value binding, even with extra options such as valueUpdate: afterkeydown to get updates on particular events, does not cover all text entry scenarios on all browsers.</source>
          <target state="translated">Браузеры крайне непоследовательны в событиях,которые срабатывают в ответ на необычные механизмы ввода текста,такие как вырезание,перетаскивание или принятие предложений автозавершения.Привязка значений,даже с дополнительными опциями,такими как valueUpdate:afterkeydown для получения обновлений по определенным событиям,не охватывает все сценарии ввода текста во всех браузерах.</target>
        </trans-unit>
        <trans-unit id="82dc9108de5adbfed209f29bd45aca2f7129d561" translate="yes" xml:space="preserve">
          <source>But what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the &lt;a href=&quot;binding-context&quot;&gt;special context property&lt;/a&gt; $data. Within a foreach block, it means &amp;ldquo;the current item&amp;rdquo;. For example,</source>
          <target state="translated">Но что, если вы хотите обратиться к самой записи массива (а не только к одному из его свойств)? В этом случае вы можете использовать &lt;a href=&quot;binding-context&quot;&gt;специальное свойство контекста&lt;/a&gt; $ data. Внутри блока foreach это означает &amp;laquo;текущий элемент&amp;raquo;. Например,</target>
        </trans-unit>
        <trans-unit id="eec18f7623a3b7b58d6302099822dbf86dd41114" translate="yes" xml:space="preserve">
          <source>By default, Knockout assumes that your custom element tag names correspond exactly to the names of components registered using ko.components.register. This convention-over-configuration strategy is ideal for most applications.</source>
          <target state="translated">По умолчанию Knockout предполагает,что имена пользовательских тегов элементов в точности соответствуют именам компонентов,зарегистрированных с помощью ko.components.register.Эта стратегия перехода на новую конфигурацию идеально подходит для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="dfd4b509346f65fb32adf29e6062d88da4847b7c" translate="yes" xml:space="preserve">
          <source>By default, Knockout comes with support for &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt;. To use it, you need to reference the following libraries, in this order:</source>
          <target state="translated">По умолчанию Knockout поддерживает &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt; . Чтобы использовать его, вам необходимо сослаться на следующие библиотеки в таком порядке:</target>
        </trans-unit>
        <trans-unit id="a6a1b05bbc994e6ce05943724747faea53070d14" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the click event to continue to bubble up to any higher level event handlers. For example, if your element and a parent of that element are both handling the click event, then the click handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named clickBubble and passing false to it, as in this example:</source>
          <target state="translated">По умолчанию Knockout позволяет событиям щелчков продолжать пузыриться до любых обработчиков событий более высокого уровня.Например,если ваш элемент и родитель этого элемента обрабатывают событие щелчка,то сработает обработчик щелчка для обоих элементов.При необходимости можно предотвратить возникновение пузырька события,включив дополнительную привязку с именем clickBubble и передав ей false,как в данном примере:</target>
        </trans-unit>
        <trans-unit id="f653a59193ad26cd8f474a7f1ec0369bc69dd3cf" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the event to continue to bubble up to any higher level event handlers. For example, if your element is handling a mouseover event and a parent of the element also handles that same event, then the event handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named youreventBubble and passing false to it, as in this example:</source>
          <target state="translated">По умолчанию Knockout позволяет событию продолжать пузыриться до любых обработчиков событий более высокого уровня.Например,если ваш элемент обрабатывает событие при наведении курсора мыши,а родитель элемента также обрабатывает это же событие,то будет запущен обработчик события для обоих элементов.При необходимости можно предотвратить возникновение пузырькового события,включив дополнительную привязку с именем youreventBubble и передав ей false,как в данном примере:</target>
        </trans-unit>
        <trans-unit id="0213c08b2e3987a7bcfe88f7f8be8cd23b5038ae" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the click event from taking any default action. This means that if you use the click binding on an a tag (a link), for example, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">По умолчанию Knockout не позволяет событию click выполнять какие-либо действия по умолчанию. Это означает, что, например, если вы используете привязку клика к тегу a (ссылке), браузер будет вызывать только вашу функцию-обработчик и &lt;em&gt;не&lt;/em&gt; будет переходить к href ссылки. Это полезный вариант по умолчанию, потому что, когда вы используете привязку щелчка, это обычно связано с тем, что вы используете ссылку как часть пользовательского интерфейса, который управляет вашей моделью представления, а не как обычную гиперссылку на другую веб-страницу.</target>
        </trans-unit>
        <trans-unit id="25eb83de5d5b73340ff952e4e80755f80b025215" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the event from taking any default action. For example if you use the event binding to capture the keypress event of an input tag, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; add the value of the key to the input element&amp;rsquo;s value. A more common example is using &lt;a href=&quot;click-binding&quot;&gt;the click binding&lt;/a&gt;, which internally uses this binding, where your handler function will be called, but the browser will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">По умолчанию Knockout не позволяет событию выполнять какие-либо действия по умолчанию. Например, если вы используете привязку события для захвата события нажатия клавиши тега ввода, браузер будет вызывать только вашу функцию-обработчик и &lt;em&gt;не&lt;/em&gt; будет добавлять значение ключа к значению элемента ввода. Более распространенным примером является использование &lt;a href=&quot;click-binding&quot;&gt;привязки щелчка&lt;/a&gt; , которая внутренне использует эту привязку, где будет вызываться ваша функция-обработчик, но браузер &lt;em&gt;не&lt;/em&gt; будет переходить к href ссылки. Это полезный вариант по умолчанию, потому что, когда вы используете привязку щелчка, это обычно связано с тем, что вы используете ссылку как часть пользовательского интерфейса, который управляет вашей моделью представления, а не как обычную гиперссылку на другую веб-страницу.</target>
        </trans-unit>
        <trans-unit id="68e7b48de47c13e7d29cf450260662702544cfb2" translate="yes" xml:space="preserve">
          <source>By default, bindings only affect the element to which they are applied. But what if you want to affect all descendant elements too? This is possible. Your binding can tell Knockout &lt;em&gt;not&lt;/em&gt; to bind descendants at all, and then your custom binding can do whatever it likes to bind them in a different way.</source>
          <target state="translated">По умолчанию привязки влияют только на тот элемент, к которому они применяются. Но что, если вы хотите затронуть и все дочерние элементы? Это возможно. Ваша привязка может указать Knockout &lt;em&gt;не&lt;/em&gt; связывать потомков вообще, а затем ваша настраиваемая привязка может делать все, что угодно, связывать их другим способом.</target>
        </trans-unit>
        <trans-unit id="1c243a6737db34c7b0eeac830e3f8771116e5e45" translate="yes" xml:space="preserve">
          <source>By default, the DOM nodes inside &amp;lt;my-special-list&amp;gt; will be stripped out (without being bound to any viewmodel) and replaced by the component&amp;rsquo;s output. However, those DOM nodes aren&amp;rsquo;t lost: they are remembered, and are supplied to the component in two ways:</source>
          <target state="translated">По умолчанию узлы DOM внутри &amp;lt;my-special-list&amp;gt; будут удалены (без привязки к какой-либо модели представления) и заменены выводом компонента. Однако эти узлы DOM не теряются: они запоминаются и передаются компоненту двумя способами:</target>
        </trans-unit>
        <trans-unit id="e8fbd98fd6d39033349a1b00ea69a73c915cbf4b" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will show all array entries, even those that are marked as destroyed. If you want to hide destroyed entries, set the includeDestroyed option to false. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c47fdcb3268ade367b3d412d238b7c1e97b37a3" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the includeDestroyed option. For example,</source>
          <target state="translated">По умолчанию,привязка фораха пропускает (т.е.скрывает)любые элементы массива,которые помечены как разрушенные.Если вы хотите показать уничтоженные записи,используйте опцию includeDestroyed.Например,</target>
        </trans-unit>
        <trans-unit id="8d966b6b812aaffebe3e1b225c111fc8166fe9bd" translate="yes" xml:space="preserve">
          <source>By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:</source>
          <target state="translated">По умолчанию,привязка опций пропустит (т.е.спрячет)все записи массива,которые помечены как уничтоженные.Если вы хотите показать уничтоженные записи,то укажите этот дополнительный параметр как:</target>
        </trans-unit>
        <trans-unit id="dd4b73242b19586f5ded1578826470337eec450d" translate="yes" xml:space="preserve">
          <source>By modifying binding contexts and controlling descendant bindings, you have a powerful and advanced tool to create custom binding mechanisms of your own.</source>
          <target state="translated">Изменяя контекст переплета и управляя переплетами потомков,вы получаете мощный и продвинутый инструмент для создания собственных механизмов переплета.</target>
        </trans-unit>
        <trans-unit id="3ffe9da1a370013ec59a35300a7401d42fae6091" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; getConfig functions in turn, until the first one supplies a non-null componentConfig.</source>
          <target state="translated">Вызывает по очереди каждую из зарегистрированных функций загрузчика getConfig, пока первый не предоставит ненулевой componentConfig.</target>
        </trans-unit>
        <trans-unit id="ce90863a4388baecfe3dc5e7b6c6832eca44d46f" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadTemplate functions in turn, until the first one supplies a non-null DOM array.</source>
          <target state="translated">Вызывает по очереди каждую из зарегистрированных функций загрузчика loadTemplate, пока первая не предоставит ненулевой массив DOM.</target>
        </trans-unit>
        <trans-unit id="cd542f36c0ad03db70cea2aa6e54148b04219c1b" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadViewModel functions in turn, until the first one supplies a non-null createViewModel function.</source>
          <target state="translated">Вызывает по очереди каждую из зарегистрированных функций загрузчика loadViewModel, пока первая не предоставит ненулевую функцию createViewModel.</target>
        </trans-unit>
        <trans-unit id="5ff3b8319fac2d8b7d9acad81d7aa35a5ad48a52" translate="yes" xml:space="preserve">
          <source>Changes to items or selectedIndexes will ripple through the chain of computed observables, which in turn will update any UI elements bound to them.</source>
          <target state="translated">Изменения элементов или selectedIndexes будут пульсировать по цепочке вычисляемых наблюдаемых объектов,что,в свою очередь,приведет к обновлению всех привязанных к ним элементов пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="0c1d4b0b47058f82dd1b216d04be28f56938456f" translate="yes" xml:space="preserve">
          <source>Combining multiple changes into a single update</source>
          <target state="translated">Объединение нескольких изменений в одно обновление</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="49288181e14cf83b9352f7e2e0537da14cdcb5e8" translate="yes" xml:space="preserve">
          <source>Communication between parent and child components</source>
          <target state="translated">Коммуникация между родительским и детским компонентами</target>
        </trans-unit>
        <trans-unit id="c97e23b3c4d2518efc7bf5b1e60ef2c00b9c85c1" translate="yes" xml:space="preserve">
          <source>Comparison with deferred updates</source>
          <target state="translated">Сравнение с отложенными обновлениями</target>
        </trans-unit>
        <trans-unit id="fb8c2f5e94bd4d3fa6518057575ef05920fde751" translate="yes" xml:space="preserve">
          <source>Comparison with the throttle extender</source>
          <target state="translated">Сравнение с расширителем дроссельной заслонки</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="4a87edfaece4a4e94d877c76e134bc7cf6471a21" translate="yes" xml:space="preserve">
          <source>Component lifecycle</source>
          <target state="translated">Жизненный цикл компонентов</target>
        </trans-unit>
        <trans-unit id="2ffddfd282dff2b14a0ea7fa7125f3df71357ad8" translate="yes" xml:space="preserve">
          <source>Component loader utility functions</source>
          <target state="translated">Функции утилиты загрузчика компонентов</target>
        </trans-unit>
        <trans-unit id="761842342f7602addd473021216f52faa86cae83" translate="yes" xml:space="preserve">
          <source>Component loaders</source>
          <target state="translated">Компонентные погрузчики</target>
        </trans-unit>
        <trans-unit id="f452457ae4b51fa02b1e173b4b0f6a1052bd7c42" translate="yes" xml:space="preserve">
          <source>Component registration</source>
          <target state="translated">Регистрация компонентов</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="eed91a528f2fc4fa5bc0cc953effda03077582c3" translate="yes" xml:space="preserve">
          <source>Components and Custom Elements - Overview</source>
          <target state="translated">Компоненты и пользовательские элементы-Обзор</target>
        </trans-unit>
        <trans-unit id="659136f125703fbf239b6fdcbf9807af68bdd3ca" translate="yes" xml:space="preserve">
          <source>Components usually have viewmodels, but they don&amp;rsquo;t necessarily have to. A component can specify just a template.</source>
          <target state="translated">Компоненты обычно имеют модели просмотра, но это не обязательно. Компонент может указывать только шаблон.</target>
        </trans-unit>
        <trans-unit id="02608739ad96779f6714a96facc9a51c046de4d6" translate="yes" xml:space="preserve">
          <source>Computed Observable Reference</source>
          <target state="translated">Расчетная наблюдаемая ссылка</target>
        </trans-unit>
        <trans-unit id="cac67370227943652edb1bf32470cb7ededf3cd3" translate="yes" xml:space="preserve">
          <source>Computed Observables</source>
          <target state="translated">Расчетные наблюдения</target>
        </trans-unit>
        <trans-unit id="d98b156baebd0cc88075e455bd6e7b1bb0e76a4b" translate="yes" xml:space="preserve">
          <source>Computed observable reference</source>
          <target state="translated">Расчетная наблюдаемая ссылка</target>
        </trans-unit>
        <trans-unit id="d2ec0435fbe18656377dae8b79915d57ab98a0b9" translate="yes" xml:space="preserve">
          <source>Computed observables</source>
          <target state="translated">Расчетные таблицы</target>
        </trans-unit>
        <trans-unit id="5be6efbe0cdf63c1654669d988fd6948bafd8cb6" translate="yes" xml:space="preserve">
          <source>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn&amp;rsquo;t make sense to include cycles in your dependency chains. Cycles would &lt;em&gt;not&lt;/em&gt; be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</source>
          <target state="translated">Предполагается, что вычисленные наблюдаемые отображают набор наблюдаемых входных данных в один наблюдаемый выход. Таким образом, нет смысла включать циклы в цепочки зависимостей. Циклы &lt;em&gt;не были&lt;/em&gt; бы аналогичны рекурсии; они были бы аналогичны наличию двух ячеек электронной таблицы, которые вычисляются как функции друг друга. Это привело бы к бесконечному циклу оценки.</target>
        </trans-unit>
        <trans-unit id="2947b370ef1780b5ce5f7b757f8fbc6949d5aa95" translate="yes" xml:space="preserve">
          <source>Consider a special list component that can be invoked as follows:</source>
          <target state="translated">Рассмотрим специальный компонент списка,который можно вызвать следующим образом:</target>
        </trans-unit>
        <trans-unit id="cdc5c7e600b4462cb7a47184c49b5743744e2362" translate="yes" xml:space="preserve">
          <source>Consider the following unusual case, in which useObservable1, observable1, and observable2 are all observables:</source>
          <target state="translated">Рассмотрим следующий необычный случай,в котором useObservable1,observable1,and observable2-все наблюдаемые:</target>
        </trans-unit>
        <trans-unit id="2013a8ac11dfd30a4371b3a3b80a3e57ac8e78e1" translate="yes" xml:space="preserve">
          <source>Consider the observables in the following code:</source>
          <target state="translated">Рассмотрим наблюдения в следующем коде:</target>
        </trans-unit>
        <trans-unit id="1117c8b3e83be86f1626d72435beb4550b6b1224" translate="yes" xml:space="preserve">
          <source>Constructing a computed observable</source>
          <target state="translated">Построение вычисляемого наблюдаемого</target>
        </trans-unit>
        <trans-unit id="4221e67369d1a203bdb0ecf119eb9ef7949b278f" translate="yes" xml:space="preserve">
          <source>Consults each registered loader in turn (by default, that&amp;rsquo;s just the default loader), to find the first one that supplies a viewmodel/template definition for the named component, then invokes callback to return than viewmodel/template declaration. Invokes callback(null) if none of the registered loaders know about this component.</source>
          <target state="translated">По очереди обращается к каждому зарегистрированному загрузчику (по умолчанию это просто загрузчик по умолчанию), чтобы найти первый, который предоставляет определение модели представления / шаблона для названного компонента, а затем вызывает обратный вызов для возврата, чем объявление модели представления / шаблона. Вызывает обратный вызов (null), если ни один из зарегистрированных загрузчиков не знает об этом компоненте.</target>
        </trans-unit>
        <trans-unit id="edea616075e1b992e2a1f7d2acc1cdd1bdf21fbc" translate="yes" xml:space="preserve">
          <source>Continuing the previous example, you might want slideVisible to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:</source>
          <target state="translated">Продолжая предыдущий пример,вы можете захотеть,чтобы слайдVisible устанавливал элемент,который будет мгновенно видимым или невидимым при первом появлении страницы (без анимированного слайда),так чтобы анимация запускалась только при изменении пользователем состояния модели.Это можно сделать следующим образом:</target>
        </trans-unit>
        <trans-unit id="ce832f145332955eb3265a8ede075cf6b1348107" translate="yes" xml:space="preserve">
          <source>Controlling custom element tag names</source>
          <target state="translated">Управление именами пользовательских тегов элементов</target>
        </trans-unit>
        <trans-unit id="b8f133feb465932694ab2a98e1eb7747d66f64e3" translate="yes" xml:space="preserve">
          <source>Controlling dependencies using peek</source>
          <target state="translated">Управление зависимостями с помощью подглядывания</target>
        </trans-unit>
        <trans-unit id="dc6504831105dad1f130ff746a8aac74129f3308" translate="yes" xml:space="preserve">
          <source>Controlling or modifying the binding context in custom bindings</source>
          <target state="translated">Управление или изменение контекста привязки в пользовательских привязках</target>
        </trans-unit>
        <trans-unit id="7001c43b6b88f7e449641661e4b5f14d9fd1e3c4" translate="yes" xml:space="preserve">
          <source>Controlling precedence</source>
          <target state="translated">Контрольный приоритет</target>
        </trans-unit>
        <trans-unit id="5a2bc032092b4e94355ac6de4992fb4188dcfb12" translate="yes" xml:space="preserve">
          <source>Controlling synchronous/asynchronous loading</source>
          <target state="translated">Управление синхронной/асинхронной загрузкой</target>
        </trans-unit>
        <trans-unit id="1c7def4489979402bef239f8ce6c91bfba309a07" translate="yes" xml:space="preserve">
          <source>Converting View Model Data to Plain JSON</source>
          <target state="translated">Преобразование данных модели представления в простой JSON</target>
        </trans-unit>
        <trans-unit id="6db93df4caeca527834703cd00425530177a63ba" translate="yes" xml:space="preserve">
          <source>Copying certain properties using &amp;ldquo;copy&amp;rdquo;</source>
          <target state="translated">Копирование определенных свойств с помощью &amp;laquo;копии&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="2203e5a230379d565a0c899ed4adc6b93e7f6dea" translate="yes" xml:space="preserve">
          <source>Creating an extender involves adding a function to the ko.extenders object. The function takes in the observable itself as the first argument and any options in the second argument. It can then either return the observable or return something new like a computed observable that uses the original observable in some way.</source>
          <target state="translated">Создание расширителя включает в себя добавление функции в объект ko.extenders.Функция принимает в качестве первого аргумента сам наблюдаемый объект,а во втором-любые опции.Затем она может либо вернуть наблюдаемое,либо вернуть что-то новое,например,вычисленное наблюдаемое,использующее исходное наблюдаемое в некотором роде.</target>
        </trans-unit>
        <trans-unit id="4039add3326a9c3c1c76f899ffeb9a382a6a0bbb" translate="yes" xml:space="preserve">
          <source>Creating custom bindings</source>
          <target state="translated">Создание пользовательских переплётов</target>
        </trans-unit>
        <trans-unit id="ffb9756189a28d9adfb06e166fd3288595e0d920" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that control descendant bindings</source>
          <target state="translated">Создание пользовательских креплений,которые управляют креплениями для потомков.</target>
        </trans-unit>
        <trans-unit id="f643fe053a4c78aac0aa1cb4ee160c7166f2853b" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that support virtual elements</source>
          <target state="translated">Создание пользовательских привязок,поддерживающих виртуальные элементы.</target>
        </trans-unit>
        <trans-unit id="bb539e2cde83f162d3671d028d8f300a026106c8" translate="yes" xml:space="preserve">
          <source>Custom bindings</source>
          <target state="translated">Нестандартные крепления</target>
        </trans-unit>
        <trans-unit id="33671f984027a68370db04ee2850cad72a30b9b1" translate="yes" xml:space="preserve">
          <source>Custom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the ko.virtualElements.allowedBindings API.</source>
          <target state="translated">Пользовательские привязки могут работать и с виртуальными элементами,но чтобы включить это,вы должны явно сказать Knockout,что ваша привязка понимает виртуальные элементы,используя ko.virtualElements.allowedBindings API.</target>
        </trans-unit>
        <trans-unit id="b02f7ac0bddff91f51122a7841af16420a2282a7" translate="yes" xml:space="preserve">
          <source>Custom disposal logic</source>
          <target state="translated">Индивидуальная логика утилизации</target>
        </trans-unit>
        <trans-unit id="6789075eb722c50f4da3df82b6df6ba9f8fa1b61" translate="yes" xml:space="preserve">
          <source>Custom elements</source>
          <target state="translated">Пользовательские элементы</target>
        </trans-unit>
        <trans-unit id="3ac9f87f42e53076f0f3bc01bdfc33cd3a3330a1" translate="yes" xml:space="preserve">
          <source>Custom elements are a syntactical alternative to the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; (and in fact, custom elements make use of a component binding behind the scenes).</source>
          <target state="translated">Пользовательские элементы являются синтаксической альтернативой &lt;a href=&quot;component-binding&quot;&gt;привязке компонентов&lt;/a&gt; (и фактически, пользовательские элементы используют привязку компонентов за кулисами).</target>
        </trans-unit>
        <trans-unit id="8bdeeedc365799bc2628a672569777dea3cd4f5b" translate="yes" xml:space="preserve">
          <source>Custom elements provide a convenient way of injecting &lt;a href=&quot;component-overview&quot;&gt;components&lt;/a&gt; into your views.</source>
          <target state="translated">Пользовательские элементы обеспечивают удобный способ внедрения &lt;a href=&quot;component-overview&quot;&gt;компонентов&lt;/a&gt; в ваши представления.</target>
        </trans-unit>
        <trans-unit id="253deb0b4c3f25b5d0a8ab69ab15a0a5e8a1bbf9" translate="yes" xml:space="preserve">
          <source>Custom functions</source>
          <target state="translated">Пользовательские функции</target>
        </trans-unit>
        <trans-unit id="20edd160b708193b8cd0d39f58c10bc666a47f89" translate="yes" xml:space="preserve">
          <source>Custom loaders can plug into any part of this process, so you can take control over supplying configurations, interpreting configurations, supplying DOM nodes, or supplying viewmodel factory functions. By putting custom loaders into a chosen order inside ko.components.loaders, you can control the priority order of different loading strategies.</source>
          <target state="translated">Клиентские погрузчики могут подключаться к любой части этого процесса,так что вы можете взять на себя управление поставкой конфигураций,интерпретацией конфигураций,поставкой DOM-узлов или поставкой заводских функций Viewmodel.Поставляя пользовательские погрузчики в выбранном порядке внутри ko.components.loaders,вы можете управлять приоритетным порядком различных стратегий загрузки.</target>
        </trans-unit>
        <trans-unit id="a613a57094a36803b28114f2b5a1abcb9176c942" translate="yes" xml:space="preserve">
          <source>Custom rate-limit methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1cea07f3d8dcbe1745bc7ec0339edf9dd8a1c9" translate="yes" xml:space="preserve">
          <source>Customizing object construction using &amp;ldquo;create&amp;rdquo;</source>
          <target state="translated">Настройка конструкции объекта с помощью &amp;laquo;создать&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="c50ee97e0e3e0b6e26cae536ab969b9b4086cfdd" translate="yes" xml:space="preserve">
          <source>Customizing object updating using &amp;ldquo;update&amp;rdquo;</source>
          <target state="translated">Настройка обновления объекта с помощью &amp;laquo;обновления&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="a2e01b2c84eeb85c92c0c227a329d46faf0286ed" translate="yes" xml:space="preserve">
          <source>Declarative bindings</source>
          <target state="translated">Декларативные переплеты</target>
        </trans-unit>
        <trans-unit id="602e3ca9311ed01ea1f90901d68acf0154edb840" translate="yes" xml:space="preserve">
          <source>Deferred updates</source>
          <target state="translated">Отложенные обновления</target>
        </trans-unit>
        <trans-unit id="d33bdc7c7c750f5687e4acfbfe0dbcbd94980b54" translate="yes" xml:space="preserve">
          <source>Deferred updates are turned off by default to provide compatibility with existing applications. To use deferred updates for your application, you must enable it before initializing your viewmodels by setting the following option:</source>
          <target state="translated">Отложенные обновления по умолчанию отключены для обеспечения совместимости с существующими приложениями.Чтобы использовать отложенные обновления для вашего приложения,вы должны включить его перед инициализацией Viewmodels,установив следующую опцию:</target>
        </trans-unit>
        <trans-unit id="222e63650134f06185ff4eba850a6bbc59f05df7" translate="yes" xml:space="preserve">
          <source>Defining and registering components</source>
          <target state="translated">Определение и регистрация компонентов</target>
        </trans-unit>
        <trans-unit id="82561171b4e8eed7831575a3bd0fd837f8a82416" translate="yes" xml:space="preserve">
          <source>Delaying and/or suppressing change notifications</source>
          <target state="translated">Задержка и/или подавление уведомлений об изменениях</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a811f27fa09ba74dbb3e42867afbb878bcbad3e6" translate="yes" xml:space="preserve">
          <source>Dependency chains just work</source>
          <target state="translated">Цепочки зависимостей просто работают</target>
        </trans-unit>
        <trans-unit id="7c363ed6db02f3ea32be85600b21f30d4c97ea44" translate="yes" xml:space="preserve">
          <source>Descendant bindings</source>
          <target state="translated">Крепления для потомков</target>
        </trans-unit>
        <trans-unit id="59380b44a10043c9034706c8bb58c001df92a319" translate="yes" xml:space="preserve">
          <source>Determining if a property is a computed observable</source>
          <target state="translated">Определение того,является ли объект недвижимости вычисляемым наблюдаемым.</target>
        </trans-unit>
        <trans-unit id="7d7568009623a301a6c07b4b81d08e0e95375454" translate="yes" xml:space="preserve">
          <source>Determining if a property is a pure computed observable</source>
          <target state="translated">Определение того,является ли свойство чисто вычисленным наблюдаемым.</target>
        </trans-unit>
        <trans-unit id="f8ade81c4c64f53543f1c485af47d756a3b07816" translate="yes" xml:space="preserve">
          <source>Determining if a property is an observableArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8177b5ed57d02388907afbbf9df075dc986c6b4a" translate="yes" xml:space="preserve">
          <source>Determining the observable type</source>
          <target state="translated">Определение наблюдаемого типа</target>
        </trans-unit>
        <trans-unit id="2ff2f116ddb0dad37555150f401b3a0c8dbb95b1" translate="yes" xml:space="preserve">
          <source>Developers familiar with Ruby on Rails, ASP.NET MVC, or other MV* technologies may see MVVM as a real-time form of MVC with declarative syntax. In another sense, you can think of KO as a general way to make UIs for editing JSON data&amp;hellip; whatever works for you :)</source>
          <target state="translated">Разработчики, знакомые с Ruby on Rails, ASP.NET MVC или другими технологиями MV *, могут рассматривать MVVM как форму MVC реального времени с декларативным синтаксисом. С другой стороны, вы можете думать о KO как об общем способе создания пользовательских интерфейсов для редактирования данных JSON&amp;hellip; все, что вам подходит :)</target>
        </trans-unit>
        <trans-unit id="853ee1f12570f18e3388b47c2a0f03eb555b5bbd" translate="yes" xml:space="preserve">
          <source>Disposal and memory management</source>
          <target state="translated">Утилизация и управление памятью</target>
        </trans-unit>
        <trans-unit id="1b44b6295dded1bbfd5d400fc72e1bf24012f125" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;custom-bindings&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="translated">Документацию по обработчикам привязки в целом можно найти &lt;a href=&quot;custom-bindings&quot;&gt;здесь&lt;/a&gt; . Этот раздел предназначен для демонстрации возможностей модулей AMD для поддержки ваших пользовательских обработчиков. Мы возьмем пример ko.bindingHandlers.hasFocus из документации по обработчикам привязок. Обернув этот обработчик в отдельный модуль, вы можете ограничить его использование только теми страницами, которые в нем нуждаются. Обернутый модуль становится:</target>
        </trans-unit>
        <trans-unit id="63aac2ff7f975838de0c8c949cea93205b344a59" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;http://knockoutjs.com/documentation/custom-bindings.html&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e71968601f25cc8d728fb672b3c6eef4f524e2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t return non-string values. That wouldn&amp;rsquo;t make sense, because markup is always a string.</source>
          <target state="translated">Не возвращайте нестроковые значения. В этом нет смысла, потому что разметка всегда представляет собой строку.</target>
        </trans-unit>
        <trans-unit id="3c7559a433a9d713a940341db539ff9c4b28ea8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to use the value and textInput bindings together on the same element, as that won&amp;rsquo;t achieve anything useful.</source>
          <target state="translated">Не пытайтесь использовать привязки value и textInput вместе в одном элементе, так как это не принесет ничего полезного.</target>
        </trans-unit>
        <trans-unit id="6f44f2279c8cf4e05783eedaa0f0f9909bcb3b91" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {font-weight:someValue}; do write {fontWeight:someValue}</source>
          <target state="translated">Не пишите {font-weight: someValue}; напишите {fontWeight: someValue}</target>
        </trans-unit>
        <trans-unit id="6be7c5667ed6550d41ae6c0658c6f47b62d579f4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {text-decoration:someValue}; do write {textDecoration:someValue}</source>
          <target state="translated">Не пишите {text-decoration: someValue}; напишите {textDecoration: someValue}</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="f9ae8a63307356d3207b70880fd5b3983d9bf72f" translate="yes" xml:space="preserve">
          <source>Drilling down into arrays/objects works but copy and observe can conflict:</source>
          <target state="translated">Сверление вниз в массивы/объекты работает,но копирование и наблюдение может привести к конфликту:</target>
        </trans-unit>
        <trans-unit id="b14f1acd92dd2af3e3a0d2d48a5aca685f3a348f" translate="yes" xml:space="preserve">
          <source>During the execution of a computed observable&amp;rsquo;s evaluator function, you can access ko.computedContext to get information about the current computed property. It provides the following functions:</source>
          <target state="translated">Во время выполнения функции оценщика вычисляемого наблюдаемого вы можете получить доступ к ko.computedContext, чтобы получить информацию о текущем вычисляемом свойстве. Он предоставляет следующие функции:</target>
        </trans-unit>
        <trans-unit id="cb51b2c1c5469acfdd11fbdd71a5689e012cc63b" translate="yes" xml:space="preserve">
          <source>Each time you click the button, this will invoke incrementClickCounter() on the view model, which in turn changes the view model state, which causes the UI to update.</source>
          <target state="translated">Каждый раз при нажатии на кнопку будет вызываться функция incrementClickCounter()на модели представления,которая,в свою очередь,изменяет состояние модели представления,что приводит к обновлению пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="0cec7a4fc80a79a8517827ff50614001f95e25f2" translate="yes" xml:space="preserve">
          <source>Either { 'font-weight': someValue } or { fontWeight: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea802701347963a7c6d7d1af9b4192766647022" translate="yes" xml:space="preserve">
          <source>Either { 'text-decoration': someValue } or { textDecoration: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9b2101da6336d889f8e0edd362bebf4c734ee" translate="yes" xml:space="preserve">
          <source>Enabling deferred updates</source>
          <target state="translated">Включение отложенных обновлений</target>
        </trans-unit>
        <trans-unit id="15ae64a2d0e5091397c73f3a4af82d2c60920a8a" translate="yes" xml:space="preserve">
          <source>Ensure you call ko.components.register('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements</source>
          <target state="translated">Убедитесь, что вы вызываете ko.components.register ('your-component') &lt;em&gt;до&lt;/em&gt; того, как парсер HTML увидит какие-либо элементы &amp;lt;your-component&amp;gt;</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="1dad2cf157eb99bbacb6f803399efe19332b4be1" translate="yes" xml:space="preserve">
          <source>Evaluating the computed observable should not cause any side effects.</source>
          <target state="translated">Оценка вычисляемой наблюдаемости не должна вызывать никаких побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="bb63aeafbc8fa85c1955b6434579c431172024e1" translate="yes" xml:space="preserve">
          <source>Evaluation of a rate-limited computed observable isn&amp;rsquo;t rate-limited; it will re-evaluate if you read its value.</source>
          <target state="translated">Оценка вычисляемой наблюдаемой с ограничением по скорости не ограничена по скорости; он будет переоценен, если вы прочтете его значение.</target>
        </trans-unit>
        <trans-unit id="9a4dd6b0c34a91a968005c6fdb0958613d790b68" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t enable deferred updates for your whole application, you can still benefit from this feature by specifically making certain observables deferred. This is done using the deferred extender:</source>
          <target state="translated">Даже если вы не включите отложенные обновления для всего приложения, вы все равно можете воспользоваться этой функцией, специально сделав определенные наблюдаемые отложенными. Это делается с помощью отложенного расширителя:</target>
        </trans-unit>
        <trans-unit id="eabc790d00812b33da77b202701e348d39479228" translate="yes" xml:space="preserve">
          <source>Event handling</source>
          <target state="translated">Обработка событий</target>
        </trans-unit>
        <trans-unit id="ecaca2e0dae16fbf4a4ad04e56b1d2b31b12e57f" translate="yes" xml:space="preserve">
          <source>Everyone loves jQuery! It&amp;rsquo;s an outstanding replacement for the clunky, inconsistent DOM API we had to put up with in the past. jQuery is an excellent low-level way to manipulate elements and event handlers in a web page. KO solves a different problem.</source>
          <target state="translated">Все любят jQuery! Это отличная замена неуклюжему и непоследовательному DOM API, с которым нам приходилось мириться в прошлом. jQuery - отличный низкоуровневый способ управления элементами и обработчиками событий на веб-странице. KO решает другую задачу.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">Пример 1</target>
        </trans-unit>
        <trans-unit id="77ef6015f49d42a91349a37284f0d10ce58dfca6" translate="yes" xml:space="preserve">
          <source>Example 1 showed how a writable computed observable can effectively &lt;em&gt;filter&lt;/em&gt; its incoming data by choosing not to write certain values back to the underlying observables if they don&amp;rsquo;t meet some criteria. It ignored full name values that didn&amp;rsquo;t include a space.</source>
          <target state="translated">Пример 1 показал, как записываемый вычисляемый наблюдаемый объект может эффективно &lt;em&gt;фильтровать&lt;/em&gt; свои входящие данные, не записывая определенные значения обратно в базовые наблюдаемые объекты, если они не соответствуют некоторым критериям. Он игнорировал значения полного имени, которые не включали пробел.</target>
        </trans-unit>
        <trans-unit id="4c47207b8b7ae8ab2d635eb01fc483f744594a47" translate="yes" xml:space="preserve">
          <source>Example 1: A component loader that sets up naming conventions</source>
          <target state="translated">Пример 1:Компонентный загрузчик,устанавливающий соглашения по наименованию.</target>
        </trans-unit>
        <trans-unit id="25518d7fb94487e753554d645c6334d7a18971ef" translate="yes" xml:space="preserve">
          <source>Example 1: Decomposing user input</source>
          <target state="translated">Пример 1:Разлагающийся пользовательский ввод</target>
        </trans-unit>
        <trans-unit id="4ea51a4ffde5737f46b31ecbe0d2ce38e03e5c87" translate="yes" xml:space="preserve">
          <source>Example 1: Drop-down list</source>
          <target state="translated">Пример 1:Выпадающий список</target>
        </trans-unit>
        <trans-unit id="0d4cfa89e17777c37aa14362706fd9828f313abe" translate="yes" xml:space="preserve">
          <source>Example 1: Iterating over an array</source>
          <target state="translated">Пример 1:Итерация по массиву</target>
        </trans-unit>
        <trans-unit id="cde8db0303a6ef26ab001c13fc6ef4c4a5867277" translate="yes" xml:space="preserve">
          <source>Example 1: Setting a default value for a binding</source>
          <target state="translated">Пример 1:Установка значения по умолчанию для переплета</target>
        </trans-unit>
        <trans-unit id="0b080011a40c4eb15898518a2e3a11c9a40dc6a7" translate="yes" xml:space="preserve">
          <source>Example 1: The basics</source>
          <target state="translated">Пример 1:Основы</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">Пример 2</target>
        </trans-unit>
        <trans-unit id="de3d10fd223ba2f62435c7e02579b9cdc45e4ca2" translate="yes" xml:space="preserve">
          <source>Example 2: A component loader that loads external files using custom code</source>
          <target state="translated">Пример 2:Компонентный загрузчик,загружающий внешние файлы с помощью пользовательского кода.</target>
        </trans-unit>
        <trans-unit id="152baefa2649a3e481777e4febefb3f62efbbff0" translate="yes" xml:space="preserve">
          <source>Example 2: Binding expressions to events</source>
          <target state="translated">Пример 2:Привязка выражений к событиям</target>
        </trans-unit>
        <trans-unit id="d9d8b537de776eff6af7ceab0dd013a34c60123d" translate="yes" xml:space="preserve">
          <source>Example 2: Click-to-edit</source>
          <target state="translated">Пример 2:Нажмите на кнопку редактирования</target>
        </trans-unit>
        <trans-unit id="d220784caedb8582e4b56dcacda886e7debebcbd" translate="yes" xml:space="preserve">
          <source>Example 2: Doing something when the user stops typing</source>
          <target state="translated">Пример 2:Делать что-то,когда пользователь перестает печатать.</target>
        </trans-unit>
        <trans-unit id="68cfd4d2225424d953c697fb7607585a091cb604" translate="yes" xml:space="preserve">
          <source>Example 2: Live example with add/remove</source>
          <target state="translated">Пример 2:Живой пример с добавлением/удалением</target>
        </trans-unit>
        <trans-unit id="cc3711f3c0d99468999474edf36f69743a26180f" translate="yes" xml:space="preserve">
          <source>Example 2: Multi-select list</source>
          <target state="translated">Пример 2:Список с несколькими вариантами выбора</target>
        </trans-unit>
        <trans-unit id="46b269bb32dd9e2791dd2abef3477feb53abf1d7" translate="yes" xml:space="preserve">
          <source>Example 2: Selecting/deselecting all items</source>
          <target state="translated">Пример 2:Выбор/отклонение всех элементов</target>
        </trans-unit>
        <trans-unit id="50e87750a3521296001652d5e8e5eb52d3e10882" translate="yes" xml:space="preserve">
          <source>Example 3: A value converter</source>
          <target state="translated">Пример 3:Преобразователь величин</target>
        </trans-unit>
        <trans-unit id="1ae049f41b4bef03f225ee3aa4c5f8f8e6b59956" translate="yes" xml:space="preserve">
          <source>Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings</source>
          <target state="translated">Пример 3:Выпадающий список,представляющий произвольные объекты JavaScript,а не только строки</target>
        </trans-unit>
        <trans-unit id="65ad7a42106a9c349f796f4927c5d9dd3e154f38" translate="yes" xml:space="preserve">
          <source>Example 3: Virtual template elements</source>
          <target state="translated">Пример 3:Элементы виртуального шаблона</target>
        </trans-unit>
        <trans-unit id="2c6ee2315f1fbb9f42c5ff7683886da7013cc130" translate="yes" xml:space="preserve">
          <source>Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item</source>
          <target state="translated">Пример 4:Выпадающий список,представляющий произвольные JavaScript-объекты,с выведенным на экран текстом,вычисленным как функция представляемого элемента</target>
        </trans-unit>
        <trans-unit id="113b6fb251c660444fac91367247b19ef5ceb219" translate="yes" xml:space="preserve">
          <source>Example 4: Filtering and validating user input</source>
          <target state="translated">Пример 4:Фильтрация и проверка вводимых пользователем данных</target>
        </trans-unit>
        <trans-unit id="b5a7dec77db39f767aebc5bdc16bef64364a4359" translate="yes" xml:space="preserve">
          <source>Example adding checkboxes bound to an array</source>
          <target state="translated">Пример добавления флажков,привязанных к массиву</target>
        </trans-unit>
        <trans-unit id="50416933cd6d1c51d0982199bf3a9959f145560c" translate="yes" xml:space="preserve">
          <source>Example adding radio buttons</source>
          <target state="translated">Пример добавления радиокнопок</target>
        </trans-unit>
        <trans-unit id="0c0fb6e0f3233e0276bdc610ce75b2efce4645ad" translate="yes" xml:space="preserve">
          <source>Example with checkbox</source>
          <target state="translated">Пример с флажком</target>
        </trans-unit>
        <trans-unit id="3d8ebdde40a810f8bcecb22744e7b919dc5edb75" translate="yes" xml:space="preserve">
          <source>Example with dynamic classes</source>
          <target state="translated">Пример с динамическими классами</target>
        </trans-unit>
        <trans-unit id="6433628dbf98786e98c232e686cdd5f6a5f19fc7" translate="yes" xml:space="preserve">
          <source>Example with static classes</source>
          <target state="translated">Пример со статическими классами</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="32d559acc95c5e2026c88355b2fc6dbb56610729" translate="yes" xml:space="preserve">
          <source>Example: A filtered view of an observable array</source>
          <target state="translated">Пример:Отфильтрованный вид наблюдаемого массива</target>
        </trans-unit>
        <trans-unit id="48ca56b48fa467d7cffa5a1ad762033d25d9baf5" translate="yes" xml:space="preserve">
          <source>Example: A like/dislike widget</source>
          <target state="translated">Пример:Виджет типа &quot;нравится/не нравится</target>
        </trans-unit>
        <trans-unit id="550a2ef513bd2e9716cf255edf159d7eac98e6ab" translate="yes" xml:space="preserve">
          <source>Example: Adding extra levels in the binding context hierarchy</source>
          <target state="translated">Пример:Добавление дополнительных уровней в контекстной иерархии связывания</target>
        </trans-unit>
        <trans-unit id="530246441e8d386c7708bd3e341f39543a901741" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple Ajax requests</source>
          <target state="translated">Пример:Избегание нескольких запросов Ajax</target>
        </trans-unit>
        <trans-unit id="ed1408f9ac2794bd9571def8f7b6df4057a59a28" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple UI updates</source>
          <target state="translated">Пример:Избегание многократного обновления пользовательского интерфейса</target>
        </trans-unit>
        <trans-unit id="c2642b17305d614b451304cd70c56ebaa48362c4" translate="yes" xml:space="preserve">
          <source>Example: Controlling whether or not descendant bindings are applied</source>
          <target state="translated">Пример:Контроль того,применяются ли нисходящие крепления</target>
        </trans-unit>
        <trans-unit id="5c3289a0b0b51a0be2ba51f5bf9c959f825caa0c" translate="yes" xml:space="preserve">
          <source>Example: Loading the like/dislike widget from external files, on demand</source>
          <target state="translated">Пример:Загрузка like/dislike виджета из внешних файлов,по запросу</target>
        </trans-unit>
        <trans-unit id="6597b4b37cee763a15316f6ba15516f4f3baf020" translate="yes" xml:space="preserve">
          <source>Example: Manual mapping without the ko.mapping plugin</source>
          <target state="translated">Пример:Ручная картография без плагина ko.mapping</target>
        </trans-unit>
        <trans-unit id="c298c6fe3398c7d0b1e666fec016b7d667c91616" translate="yes" xml:space="preserve">
          <source>Example: Supplying additional values to descendant bindings</source>
          <target state="translated">Пример:Обеспечение дополнительных значений для креплений по нисходящей линии</target>
        </trans-unit>
        <trans-unit id="30054173d63a971c583a297024b8430fbad005a6" translate="yes" xml:space="preserve">
          <source>Example: Using ko.mapping</source>
          <target state="translated">Пример:Использование ko.mapping</target>
        </trans-unit>
        <trans-unit id="5b10251ba9ffb2c86c7da769237457e995ac6fa9" translate="yes" xml:space="preserve">
          <source>Excerpt From &lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;Writing Modular JavaScript With AMD, CommonJs &amp;amp; ES Harmony&lt;/a&gt;:</source>
          <target state="translated">Выдержка из &lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;написания модульного JavaScript с использованием AMD, CommonJs и ES Harmony&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5bdedba4c5ce2948fd4206f7e11d5e6799420d42" translate="yes" xml:space="preserve">
          <source>Explicitly subscribing to observables</source>
          <target state="translated">Явно выраженная подписка на наблюдаемые</target>
        </trans-unit>
        <trans-unit id="1208c99ef5025c09bf368869c5593ca302f58dd8" translate="yes" xml:space="preserve">
          <source>Extending Knockout's binding syntax using preprocessing</source>
          <target state="translated">Расширение синтаксиса связывания Knockout с помощью препроцессирования</target>
        </trans-unit>
        <trans-unit id="477b9ac7b2012a7c4ef01dab5b6738e39bfd0290" translate="yes" xml:space="preserve">
          <source>Extending observables</source>
          <target state="translated">Расширяющиеся наблюдаемые объекты</target>
        </trans-unit>
        <trans-unit id="6d075b19378326b1dd5562c4110427dc1221e6d9" translate="yes" xml:space="preserve">
          <source>Extracting additional data or state from the form elements</source>
          <target state="translated">Извлечение дополнительных данных или состояния из элементов формы</target>
        </trans-unit>
        <trans-unit id="aa46347e225c51cf57a22ad6da0baa8c26e37d15" translate="yes" xml:space="preserve">
          <source>Finally, to update your view model using this data (without using the mapping plugin), you would write:</source>
          <target state="translated">Наконец,чтобы обновить модель представления,используя эти данные (без использования связующего плагина),вы бы записали:</target>
        </trans-unit>
        <trans-unit id="95a70ce88e1373d7443eeddd31cb4fdbb0259963" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false.</source>
          <target state="translated">Для &lt;strong&gt;флажков&lt;/strong&gt; KO установит элемент, который будет &lt;em&gt;проверяться,&lt;/em&gt; когда значение параметра истинно, и &lt;em&gt;снятым,&lt;/em&gt; если оно ложно. Если вы укажете значение, которое на самом деле не является логическим, оно будет интерпретироваться свободно. Это означает, что ненулевые числа, ненулевые объекты и непустые строки будут интерпретироваться как истинные, тогда как нулевые, нулевые, неопределенные и пустые строки будут интерпретироваться как ложные.</target>
        </trans-unit>
        <trans-unit id="1972d38c80951a9e678c4ff687d7462b49456982" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false. When the user checks or unchecks the checkbox, Knockout will set your model property to true or false accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28d41ab8ba0a18cc5a9b626ab01db87a9b2b8cd" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if and only if the parameter value equals the radio button node&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="translated">Для &lt;strong&gt;радиокнопок&lt;/strong&gt; KO устанавливает &lt;em&gt;проверяемый&lt;/em&gt; элемент тогда и только тогда, когда значение параметра равно атрибуту значения узла радиокнопки или значению, заданному параметром checkedValue. В предыдущем примере переключатель со значением = &amp;laquo;almond&amp;raquo; был установлен только тогда, когда свойство spamFlavor модели представления было равно &amp;laquo;almond&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cc3c89585ed643a35bcd1fe16e2cc01737ccbce0" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value equals the radio button element&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d85206a98cfdd4a13c8db149c728546b8ffb8cf" translate="yes" xml:space="preserve">
          <source>For Knockout to be able to load and instantiate your components, you must register them using ko.components.register, providing a configuration as described here.</source>
          <target state="translated">Для того,чтобы Knockout мог загрузить и инстанцировать ваши компоненты,вы должны зарегистрировать их с помощью ko.components.register,предоставив конфигурацию,как описано здесь.</target>
        </trans-unit>
        <trans-unit id="fb653bd6fda509ae69de2f3c411ab3f9ecc16aff" translate="yes" xml:space="preserve">
          <source>For a computed observable, the rate-limit timer is triggered when one of the computed observable&amp;rsquo;s dependencies change instead of when its value changes. The computed observable is not re-evaluated until its value is actually needed&amp;mdash;after the timeout period when the change notification should happen, or when the computed observable value is accessed directly. If you need to access the value of the computed&amp;rsquo;s most recent evaluation, you can do so with the peek method.</source>
          <target state="translated">Для вычисляемого наблюдаемого таймер ограничения скорости запускается, когда изменяется одна из зависимостей вычисляемого наблюдаемого, а не при изменении его значения. Вычисленная наблюдаемая не переоценивается до тех пор, пока ее значение не станет действительно необходимым - по истечении периода ожидания, когда должно произойти уведомление об изменении, или когда к вычисленному наблюдаемому значению обращаются напрямую. Если вам нужно получить доступ к значению последней оценки вычисленного, вы можете сделать это с помощью метода peek.</target>
        </trans-unit>
        <trans-unit id="f6a669cb32d714a0fa05339382fe1c38249fefbd" translate="yes" xml:space="preserve">
          <source>For a multi-select list, you can read and write the selection state using selectedOptions. Technically this is a separate binding, so it has &lt;a href=&quot;selectedoptions-binding&quot;&gt;its own documentation&lt;/a&gt;.</source>
          <target state="translated">Для списка с множественным выбором вы можете читать и записывать состояние выбора с помощью selectedOptions. Технически это отдельная привязка, поэтому для нее есть &lt;a href=&quot;selectedoptions-binding&quot;&gt;своя документация&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd598195e6041713fa3eb6fa2ec0c343db66800" translate="yes" xml:space="preserve">
          <source>For a very simple example, here&amp;rsquo;s a custom binding called allowBindings that allows descendant bindings to be applied only if its value is true. If the value is false, then allowBindings tells Knockout that it is responsible for descendant bindings so they won&amp;rsquo;t be bound as usual.</source>
          <target state="translated">В качестве очень простого примера приведем настраиваемую привязку под названием allowBindings, которая позволяет применять привязки потомков, только если его значение истинно. Если значение равно false, то allowBindings сообщает Knockout, что он отвечает за привязки потомков, поэтому они не будут привязаны как обычно.</target>
        </trans-unit>
        <trans-unit id="f738301a087259c2cb88d3ee079875129c0660ae" translate="yes" xml:space="preserve">
          <source>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their subscribe function. For example:</source>
          <target state="translated">Для опытных пользователей,если вы хотите зарегистрировать свою подписку,чтобы получать уведомления об изменениях в наблюдаемых объектах,вы можете вызвать их функцию подписки.Например:</target>
        </trans-unit>
        <trans-unit id="0f758951954c6cb5686e9de3f4ea46d08e3e6c56" translate="yes" xml:space="preserve">
          <source>For backward compatibility, you can also use the css binding with a string value like the class binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc285857d05b5c21a59d307e884dc555d9c7a77" translate="yes" xml:space="preserve">
          <source>For complete syntax, see the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt;.</source>
          <target state="translated">Полный синтаксис см. В &lt;a href=&quot;computed-reference&quot;&gt;справочнике&lt;/a&gt; по вычисляемым наблюдаемым .</target>
        </trans-unit>
        <trans-unit id="4f8598317b25a1d69826eb855f00f8318431cdf0" translate="yes" xml:space="preserve">
          <source>For documentation on these standard component loader functions, see &lt;a href=&quot;#custom-component-loader&quot;&gt;implementing a custom component loader&lt;/a&gt;.</source>
          <target state="translated">Для документации по этим стандартным функциям загрузчика компонентов см. &lt;a href=&quot;#custom-component-loader&quot;&gt;Реализацию пользовательского загрузчика компонентов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75d6aa97d869ac1df9beec0c8c0cbb559a4d3a8d" translate="yes" xml:space="preserve">
          <source>For even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:</source>
          <target state="translated">Для еще лучшей инкапсуляции можно упаковать компонент в один самописывающий AMD-модуль.Тогда вы можете ссылаться на компонент так же просто,как:</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="7f3364ff4802481e63e46cadfbc8760e3675bb8b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like { template: 'someElementId', viewModel: { require: 'myModule' } } can be understood and instantiated by the default loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6431474d550826b851e8376cf48298a6011540b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like {template:'someElementId',viewModel:{require:'myModule'}} can be understood and instantiated by the default loader.</source>
          <target state="translated">Например,компонентConfig вроде {template:'someElementId',viewModel:{require:'myModule'}}может быть понятен и инстанцирован загрузчиком по умолчанию.</target>
        </trans-unit>
        <trans-unit id="63125df5cb160d3708cafec1f0e9b2f0547ee516" translate="yes" xml:space="preserve">
          <source>For example, define a view model as follows:</source>
          <target state="translated">Например,определите модель вида следующим образом:</target>
        </trans-unit>
        <trans-unit id="36572a6a5e79cde64bef7c1785b1f36c362c494f" translate="yes" xml:space="preserve">
          <source>For example, given the following view model class,</source>
          <target state="translated">Например,учитывая следующий класс модели представления,</target>
        </trans-unit>
        <trans-unit id="8c8a073a43cbbbf266ce41b059e8d1e1736f0261" translate="yes" xml:space="preserve">
          <source>For example, if the following is in a file at path/my-component.js,</source>
          <target state="translated">Например,если в файле path/my-component.js находится следующее,</target>
        </trans-unit>
        <trans-unit id="389a8f18d6ec0043db2935b9cac1d05b35c584a6" translate="yes" xml:space="preserve">
          <source>For example, if you return 'value + &quot;.toUpperCase()&quot;' as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="translated">Например,если вы возвращаете 'value+&quot;.toUpperCase()' в виде строки,то ваша привязка:&quot;Bert&quot; будет интерпретироваться так,как если бы разметка содержала вашу привязку:&quot;Bert&quot;.toUpperCase()&quot;.Нокаут будет обрабатывать возвращаемое значение обычным способом,так что это должно быть легальное JavaScript выражение.</target>
        </trans-unit>
        <trans-unit id="631d5ff146ac1b7e8d91b5960cafd4e8fdada71b" translate="yes" xml:space="preserve">
          <source>For example, if you return value + &quot;.toUpperCase()&quot; as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1345d943ae097566d0a2d604bb67d731cf352713" translate="yes" xml:space="preserve">
          <source>For example, if you structure your page like this, then everything will be OK:</source>
          <target state="translated">Например,если вы структурируете свою страницу таким образом,то все будет в порядке:</target>
        </trans-unit>
        <trans-unit id="a37e35428471e05739a74959c92c8f8eda5e555f" translate="yes" xml:space="preserve">
          <source>For example, if your component is inside some other element with an &lt;a href=&quot;if-binding&quot;&gt;if binding&lt;/a&gt; (or another control flow binding), then it will not cause the AMD module to be loaded until the if condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the require call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.</source>
          <target state="translated">Например, если ваш компонент находится внутри какого-либо другого элемента с &lt;a href=&quot;if-binding&quot;&gt;привязкой if&lt;/a&gt; (или другой привязкой потока управления), то это не приведет к загрузке модуля AMD, пока условие if не будет истинным. Конечно, если модуль AMD уже был загружен (например, в предварительно загруженном пакете), то вызов require не инициирует никаких дополнительных HTTP-запросов, поэтому вы можете контролировать, что предварительно загружается, а что загружается по запросу.</target>
        </trans-unit>
        <trans-unit id="e99ffdec1cc7a8a75e2b94b719091deff0a98942" translate="yes" xml:space="preserve">
          <source>For example, instead of writing this:</source>
          <target state="translated">Например,вместо того,чтобы писать это:</target>
        </trans-unit>
        <trans-unit id="9a23df25508d72cfc8abcacad7f0ed1d5ab1eb72" translate="yes" xml:space="preserve">
          <source>For example, rewrite the preceding view model object as follows:</source>
          <target state="translated">Например,перепишите предыдущий объект модели представления следующим образом:</target>
        </trans-unit>
        <trans-unit id="abacb1facc5d8e8adbbbcedeb1ae28fe320f9867" translate="yes" xml:space="preserve">
          <source>For example, the following element:</source>
          <target state="translated">Например,следующий элемент:</target>
        </trans-unit>
        <trans-unit id="64c9c667af6bb9f6172083bac994162a1c1b7a9a" translate="yes" xml:space="preserve">
          <source>For example, the my-special-list component&amp;rsquo;s template can reference $componentTemplateNodes so that its output includes the supplied markup. Here&amp;rsquo;s the complete working example:</source>
          <target state="translated">Например, шаблон компонента my-special-list может ссылаться на $ componentTemplateNodes, чтобы его выходные данные включали предоставленную разметку. Вот полный рабочий пример:</target>
        </trans-unit>
        <trans-unit id="2b6ff54598ebe3588255d709e9a0c9f753a2b35d" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="translated">Например, вы можете создавать интерактивные компоненты, такие как сетки, наборы вкладок и т. Д., В форме настраиваемых привязок (см. &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;Пример сетки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="259dc2bfcba22b9dd8b551f2db8f17cbb974e01e" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;https://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a7c228afe4cc9a5c128478008d3b1f5884e84" translate="yes" xml:space="preserve">
          <source>For example, you might have been controlling an element&amp;rsquo;s visibility using the visible binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery&amp;rsquo;s slideUp/slideDown functions:</source>
          <target state="translated">Например, вы могли управлять видимостью элемента с помощью видимой привязки, но теперь вы хотите пойти дальше и анимировать переход. Вы хотите, чтобы элементы появлялись и исчезали в соответствии со значением наблюдаемого. Вы можете сделать это, написав настраиваемую привязку, которая вызывает функции jQuery slideUp / slideDown:</target>
        </trans-unit>
        <trans-unit id="a0af413f30c072cb2f86c4d5c9c43068f2afe457" translate="yes" xml:space="preserve">
          <source>For example, you might want to enable configuration formats like the following:</source>
          <target state="translated">Например,вы можете захотеть включить следующие форматы конфигурации:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="f678f7a6798df2a555b214e68d162f307fd8e326" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="translated">Примеры afterAdd и beforeRemove см. В &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;анимированных переходах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05e3b099a296c9a13aa7e5074fa8572b152dae60" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;https://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eebaa938c7aaf194d0d6134712c9458bdd1e31e" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated which means there is a significant difference between using KO&amp;rsquo;s methods (i.e., observableArray.push(...) ) and JavaScript native array methods (i.e., observableArray().push(...)) as the latter don&amp;rsquo;t send any notification to the array&amp;rsquo;s subscribers that its content has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fee50827f83055c14d664c8ae49efc9b3ea847" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</source>
          <target state="translated">Для функций, которые изменяют содержимое массива, таких как push и splice, методы KO автоматически запускают механизм отслеживания зависимостей, так что все зарегистрированные слушатели уведомляются об изменении, а ваш пользовательский интерфейс автоматически обновляется.</target>
        </trans-unit>
        <trans-unit id="76a00e59b8c3067b079a7bc20c769830ca1ae02b" translate="yes" xml:space="preserve">
          <source>For information about how to pass additional parameters to your submit handler function, or how to control the this handle when invoking functions that aren&amp;rsquo;t on your view model, see the notes relating to the &lt;a href=&quot;click-binding&quot;&gt;click binding&lt;/a&gt;. All the notes on that page apply to submit handlers too.</source>
          <target state="translated">Для получения информации о том, как передать дополнительные параметры вашей функции обработчика отправки или как управлять этим дескриптором при вызове функций, которых нет в вашей модели представления, см. Примечания, относящиеся к &lt;a href=&quot;click-binding&quot;&gt;привязке щелчка&lt;/a&gt; . Все примечания на этой странице относятся и к обработчикам отправки.</target>
        </trans-unit>
        <trans-unit id="c7f48a902247b730ada79fe82babfb437d3afca3" translate="yes" xml:space="preserve">
          <source>For loading, update your view model using data that you&amp;rsquo;ve received using one of the above techniques</source>
          <target state="translated">Для загрузки обновите модель представления, используя данные, полученные с помощью одного из описанных выше методов.</target>
        </trans-unit>
        <trans-unit id="7adb7866a71f6f46b996a32c046194acab2ca099" translate="yes" xml:space="preserve">
          <source>For more control, pass a JavaScript object with some combination of the following properties:</source>
          <target state="translated">Для большего контроля передайте объект JavaScript с некоторой комбинацией следующих свойств:</target>
        </trans-unit>
        <trans-unit id="ad4b6504c8a1b8acae6adc1c35890de1f949db77" translate="yes" xml:space="preserve">
          <source>For more details about these observableArray functions, see the equivalent documentation of the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;standard JavaScript array functions&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения об этих функциях observableArray см. В эквивалентной документации &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;стандартных функций массива JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33ebce62a68ac66ad4bdebcd712e571477e40bce" translate="yes" xml:space="preserve">
          <source>For more information about $index and other context properties such as $parent, see documentation for &lt;a href=&quot;binding-context&quot;&gt;binding context properties&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о $ index и других свойствах контекста, таких как $ parent, см. В документации по &lt;a href=&quot;binding-context&quot;&gt;привязке свойств контекста&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d002e63ef2bdfe307b7dc6dd93d11d5d0f3420e" translate="yes" xml:space="preserve">
          <source>For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques</source>
          <target state="translated">Для сохранения данных модели представления в простой JSON-формат,чтобы вы могли отправить их с помощью одной из вышеперечисленных методик.</target>
        </trans-unit>
        <trans-unit id="6ed6deeffb9be7ad51042e1a135e3e9e951b890d" translate="yes" xml:space="preserve">
          <source>For the using binding, although you can use this option, it would generally be more efficient and descriptive to use the &lt;a href=&quot;let-binding&quot;&gt;let binding&lt;/a&gt; instead. Rather than using: currentPerson, as: 'person', noChildContext: true, you&amp;rsquo;d use let: { person: currentPerson }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e09e1e68bd9f09528070843f84d40f2039aa8c2" translate="yes" xml:space="preserve">
          <source>For the using binding, descendant elements will remain in the document and their bindings re-evaluated with the new context value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f20975442dd142df3dfc2e9186957414d588e0" translate="yes" xml:space="preserve">
          <source>For the using binding, it is generally incorrect to supply a null or undefined value since it will try to use that value as the context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299f2d31774daca6f4077fc8efaadbf7175a173" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1234d03268a26c263a165b8d5a4f87d33c04e4" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22b50f0de3d7cac900daaf7c9e5b4041689cd2f" translate="yes" xml:space="preserve">
          <source>For this to work, the files &lt;a href=&quot;files/component-like-widget.js&quot;&gt;files/component-like-widget.js&lt;/a&gt; and &lt;a href=&quot;files/component-like-widget&quot;&gt;files/component-like-widget.html&lt;/a&gt; need to exist. Check them out (and &lt;em&gt;view source&lt;/em&gt; on the .html one) - as you&amp;rsquo;ll see, this is cleaner and more convenient that including the code inline in the definition.</source>
          <target state="translated">Чтобы это &lt;a href=&quot;files/component-like-widget&quot;&gt;работало,&lt;/a&gt; должны существовать файлы &lt;a href=&quot;files/component-like-widget.js&quot;&gt;files / component-like-widget.js&lt;/a&gt; и files / component-like-widget.html . &lt;em&gt;Просмотрите&lt;/em&gt; их (и &lt;em&gt;просмотрите исходный код&lt;/em&gt; на .html) - как вы увидите, это чище и удобнее, чем включение кода, встроенного в определение.</target>
        </trans-unit>
        <trans-unit id="5b3f6e3b0f1ca1f18fefa1a37d9ba45e25616b20" translate="yes" xml:space="preserve">
          <source>Forcing computed observables to always notify subscribers</source>
          <target state="translated">Принуждение расчетных наблюдений всегда уведомлять абонентов</target>
        </trans-unit>
        <trans-unit id="84662a42c470dcc749e4f555eafc404bee27a93f" translate="yes" xml:space="preserve">
          <source>Forcing deferred notifications to happen early</source>
          <target state="translated">Принуждение к заблаговременному уведомлению</target>
        </trans-unit>
        <trans-unit id="5f499a5d8b4de8fa658740f93586939f3677a5ae" translate="yes" xml:space="preserve">
          <source>Forcing deferred observables to always notify subscribers</source>
          <target state="translated">Принуждение отложенных наблюдений всегда уведомлять абонентов</target>
        </trans-unit>
        <trans-unit id="98d0c19699f7a2e290891f5a4e98f8719c1258d5" translate="yes" xml:space="preserve">
          <source>Forcing observables to always notify subscribers</source>
          <target state="translated">Принуждение наблюдателей всегда уведомлять абонентов</target>
        </trans-unit>
        <trans-unit id="f54bb0060ff337df25025c131396a49f22403fe7" translate="yes" xml:space="preserve">
          <source>Forcing rate-limited observables to always notify subscribers</source>
          <target state="translated">Принудительное информирование абонентов с помощью наблюдательных приборов с ограниченным тарифом.</target>
        </trans-unit>
        <trans-unit id="6e02a1c244564b921ceb8e82920afc310566e328" translate="yes" xml:space="preserve">
          <source>Full details:</source>
          <target state="translated">Полная информация:</target>
        </trans-unit>
        <trans-unit id="2c93794a5d7ef6cb3e1c45af5db6db00afa54472" translate="yes" xml:space="preserve">
          <source>Functions on your view model are slightly special because you can reference them by name, i.e., you can write submit: doSomething and &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have to write submit: viewModel.doSomething (though technically that&amp;rsquo;s also valid).</source>
          <target state="translated">Функции в вашей модели представления немного особенные, потому что вы можете ссылаться на них по имени, т. Е. Вы можете написать submit: doSomething и &lt;em&gt;не&lt;/em&gt; должны писать submit: viewModel.doSomething (хотя технически это тоже верно).</target>
        </trans-unit>
        <trans-unit id="45c386b929cd8059a6ebbcf8d5cf6632dffb76e7" translate="yes" xml:space="preserve">
          <source>Functions you can implement</source>
          <target state="translated">Функции,которые вы можете реализовать</target>
        </trans-unit>
        <trans-unit id="5b8ebd236050a24d7ee285b263736dd0ada77452" translate="yes" xml:space="preserve">
          <source>Generally, the best way to perform such post-processing on DOM elements is to write a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt;, but if you really just want to access the raw DOM elements emitted by a template, you can use afterRender.</source>
          <target state="translated">Как правило, лучший способ выполнить такую ​​постобработку элементов DOM - это написать &lt;a href=&quot;custom-bindings&quot;&gt;настраиваемую привязку&lt;/a&gt; , но если вы действительно хотите получить доступ к необработанным элементам DOM, генерируемым шаблоном, вы можете использовать afterRender.</target>
        </trans-unit>
        <trans-unit id="74b46ff2fa2d37b0a8e7636b52d4e4152c5f19f8" translate="yes" xml:space="preserve">
          <source>Generally, there would be little reason to subscribe to the childrenComplete event in such a binding since it would be the same as just running your post-processing code after ko.applyBindingsToDescendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc53371ed103fecb3625d6b54a824260aab0b6d" translate="yes" xml:space="preserve">
          <source>Going back to the classic &amp;ldquo;first name + last name = full name&amp;rdquo; example, you can turn things back-to-front: make the fullName computed observable writable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying firstName and lastName observables. In this example, the write callback handles incoming values by splitting the incoming text into &amp;ldquo;firstName&amp;rdquo; and &amp;ldquo;lastName&amp;rdquo; components, and writing those values back to the underlying observables.</source>
          <target state="translated">Возвращаясь к классическому примеру &amp;laquo;имя + фамилия = полное имя&amp;raquo;, вы можете перевернуть все наоборот: сделать вычисляемое fullName доступным для записи, чтобы пользователь мог напрямую редактировать полное имя, и предоставленное им значение будет быть проанализированы и отображены обратно в базовые наблюдаемые firstName и lastName. В этом примере обратный вызов записи обрабатывает входящие значения, разделяя входящий текст на компоненты &amp;laquo;firstName&amp;raquo; и &amp;laquo;lastName&amp;raquo; и записывая эти значения обратно в базовые наблюдаемые объекты.</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="e790fc9db2ebd2516f36edd273ef2c230b8019be" translate="yes" xml:space="preserve">
          <source>HTML5-era browsers, which includes &lt;strong&gt;Internet Explorer 9&lt;/strong&gt; and later, automatically allow for custom elements with no difficulties.</source>
          <target state="translated">Браузеры эпохи HTML5, в том числе &lt;strong&gt;Internet Explorer 9&lt;/strong&gt; и более поздние версии, автоматически поддерживают настраиваемые элементы без проблем.</target>
        </trans-unit>
        <trans-unit id="db3faaddbfebaf215e63526cf28c5c5fa9f0ccf7" translate="yes" xml:space="preserve">
          <source>Headline features:</source>
          <target state="translated">Особенности заголовков:</target>
        </trans-unit>
        <trans-unit id="4e7751af05ac722a6fb5ef531e8dadad667d4de0" translate="yes" xml:space="preserve">
          <source>Here a few situations in which you might want to use these mapping options.</source>
          <target state="translated">Вот несколько ситуаций,в которых вы,возможно,захотите использовать эти опции отображения.</target>
        </trans-unit>
        <trans-unit id="6ec4c1a3ba1febd520b968b83993af24bd3d1248" translate="yes" xml:space="preserve">
          <source>Here are examples of how the changes are reported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc2db2d3dd09d2d25123ee5014cb4e846965eaa" translate="yes" xml:space="preserve">
          <source>Here is a basic example of setting values using let that are then available in all descendant elements, regardless of context changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e69de42d839b42bf754d25ca92cab286df4be6" translate="yes" xml:space="preserve">
          <source>Here is a very basic example of switching the binding context to a child object. Notice that in the data-bind attributes, it is &lt;em&gt;not&lt;/em&gt; necessary to prefix latitude or longitude with coords., because the binding context is switched to coords.</source>
          <target state="translated">Вот очень простой пример переключения контекста привязки на дочерний объект. Обратите внимание, что в атрибутах привязки данных &lt;em&gt;нет&lt;/em&gt; необходимости в префиксе широты или долготы с помощью coords., Потому что контекст привязки переключается на coords.</target>
        </trans-unit>
        <trans-unit id="b82739780a396a71434b267de5bea3a454dbbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration that will add some text to the incoming data before updating:</source>
          <target state="translated">Вот пример конфигурации,которая добавит некоторый текст во входящие данные перед обновлением:</target>
        </trans-unit>
        <trans-unit id="3280dba535f19f2febc60673f89c1a84ba00d47d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;a simple implementation of integrating Underscore templates with Knockout&lt;/a&gt;. The integration code is just 16 lines long, but it&amp;rsquo;s enough to support Knockout data-bind attributes (and hence nested templates) and Knockout &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables ($parent, $root, etc.).</source>
          <target state="translated">Вот &lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;простая реализация интеграции шаблонов Underscore с Knockout&lt;/a&gt; . Код интеграции состоит всего из 16 строк, но этого достаточно для поддержки атрибутов привязки данных Knockout (и, следовательно, вложенных шаблонов) и переменных &lt;a href=&quot;binding-context&quot;&gt;контекста привязки&lt;/a&gt; Knockout ($ parent, $ root и т. Д.).</target>
        </trans-unit>
        <trans-unit id="84443bf9a128caa94205efa8ada501ff154e881b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a trivial example that uses afterAdd to apply the classic &amp;ldquo;yellow fade&amp;rdquo; effect to newly-added items. It requires the &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;jQuery Color plugin&lt;/a&gt; to enable animation of background colors.</source>
          <target state="translated">Вот тривиальный пример, который использует afterAdd для применения классического эффекта &amp;laquo;желтого затухания&amp;raquo; к вновь добавленным элементам. Для включения анимации фоновых цветов требуется &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;плагин jQuery Color&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37cf14e229e69417a43a02c23085e0aa99c73561" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a way to define a filterByProperty function that will become available on all subsequently-created ko.observableArray instances:</source>
          <target state="translated">Вот способ определить функцию filterByProperty, которая станет доступной для всех создаваемых впоследствии экземпляров ko.observableArray:</target>
        </trans-unit>
        <trans-unit id="8fb66c98e55cbff21c223380e9a5374ec4c0a1ef" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example configuration:</source>
          <target state="translated">Вот пример конфигурации:</target>
        </trans-unit>
        <trans-unit id="b05ce77e66ba4c65f03af6e3ab19e65b03d68454" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of using the above custom binding:</source>
          <target state="translated">Вот пример использования указанной выше настраиваемой привязки:</target>
        </trans-unit>
        <trans-unit id="66b583251e6c4a39e879523f6accea2dbf4b4259" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that uses optionsAfterRender to add a disable binding to each option.</source>
          <target state="translated">Вот пример, который использует optionsAfterRender для добавления привязки отключения к каждой опции.</target>
        </trans-unit>
        <trans-unit id="30b31c34d144c1947d36ca331230826869c8a16e" translate="yes" xml:space="preserve">
          <source>How Knockout loads components via AMD</source>
          <target state="translated">Как Knockout загружает компоненты через AMD</target>
        </trans-unit>
        <trans-unit id="7e306597890108bc7fc111d560e6054689ac6ebc" translate="yes" xml:space="preserve">
          <source>How dependency tracking works</source>
          <target state="translated">Как работает отслеживание зависимостей</target>
        </trans-unit>
        <trans-unit id="93fddf00520975913c2fecc46ee1c69334b1426a" translate="yes" xml:space="preserve">
          <source>How is Knockout different?</source>
          <target state="translated">Чем отличается Нокаут?</target>
        </trans-unit>
        <trans-unit id="47ba114c765ebcdb727f9bec12dc3ebaf5886692" translate="yes" xml:space="preserve">
          <source>How things are mapped</source>
          <target state="translated">Как все картируется</target>
        </trans-unit>
        <trans-unit id="361fb2674c6c2b62b9aae1a7ce5281fcff2e1a0b" translate="yes" xml:space="preserve">
          <source>How to create an extender</source>
          <target state="translated">Как создать удлинитель</target>
        </trans-unit>
        <trans-unit id="ae005b5e0ed8d5109a9c1e98c6cbd19a088774bc" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default action proceed, just return true from your event handler function.</source>
          <target state="translated">Тем не менее, если вы &lt;em&gt;действительно&lt;/em&gt; хотите , чтобы действие по умолчанию продолжить, просто возвращает истину от вашей функции обработчика событий.</target>
        </trans-unit>
        <trans-unit id="64ce42b8e7f69d107832250d68dbd01a878deeb2" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default click action proceed, just return true from your click handler function.</source>
          <target state="translated">Тем не менее, если вы &lt;em&gt;действительно&lt;/em&gt; хотите , чтобы действие по умолчанию нажмите продолжить, просто возвращает истину от вашей функции обработчика щелчка.</target>
        </trans-unit>
        <trans-unit id="a6e2915dc92ca412b52398579f1e49c3c8348959" translate="yes" xml:space="preserve">
          <source>However, if you use value to link a form element to a &lt;em&gt;non&lt;/em&gt;-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:</source>
          <target state="translated">Однако, если вы используете значение , чтобы связать элемент формы с , &lt;em&gt;не&lt;/em&gt; -observable свойства (например, простой старой строкой или произвольным выражением JavaScript), KO будет сделать следующее:</target>
        </trans-unit>
        <trans-unit id="8c30fbacefa412111122658b9f8bc072a603ddd1" translate="yes" xml:space="preserve">
          <source>However, it does &lt;em&gt;not&lt;/em&gt; work with virtual elements. If you try the following:</source>
          <target state="translated">Однако это &lt;em&gt;не&lt;/em&gt; работает с виртуальными элементами. Если вы попробуете следующее:</target>
        </trans-unit>
        <trans-unit id="8531b5d91c66d42745ea8deb05f270abe4564d92" translate="yes" xml:space="preserve">
          <source>However, it does not make sense to use bindings that would modify the element&amp;rsquo;s contents, such as the &lt;a href=&quot;text-binding&quot;&gt;text&lt;/a&gt; or &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; bindings, since they would overwrite the template injected by your component.</source>
          <target state="translated">Однако не имеет смысла использовать привязки, которые изменяли бы содержимое элемента, например привязки &lt;a href=&quot;text-binding&quot;&gt;текста&lt;/a&gt; или &lt;a href=&quot;template-binding&quot;&gt;шаблона&lt;/a&gt; , поскольку они перезаписывают шаблон, введенный вашим компонентом.</target>
        </trans-unit>
        <trans-unit id="8b2c1d7baa87a948e36706143a1b3bd56c309bf4" translate="yes" xml:space="preserve">
          <source>However, many developers prefer to use a more conventions-based approach to updating their view models using incoming data without manually writing a line of code for every property to be updated. This can be beneficial if your view models have many properties, or deeply nested data structures, because it can greatly reduce the amount of manual mapping code you need to write. For more details about this technique, see &lt;a href=&quot;plugins-mapping&quot;&gt;the knockout.mapping plugin&lt;/a&gt;.</source>
          <target state="translated">Однако многие разработчики предпочитают использовать подход, основанный на соглашениях, для обновления своих моделей представлений с использованием входящих данных без ручного написания строки кода для каждого обновляемого свойства. Это может быть полезно, если ваши модели представления имеют много свойств или глубоко вложенных структур данных, потому что это может значительно сократить объем ручного кода сопоставления, который вам нужно написать. Дополнительные сведения об этой технике см. &lt;a href=&quot;plugins-mapping&quot;&gt;В плагине knockout.mapping&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df78c9be1d978ee24c637cf614f8f43143a6b702" translate="yes" xml:space="preserve">
          <source>However, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the &amp;lt;select&amp;gt;, then specify valueAllowUnset: true. In this case, whenever your model value cannot be represented in the &amp;lt;select&amp;gt;, then the &amp;lt;select&amp;gt; simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:</source>
          <target state="translated">Однако иногда такое поведение может быть нежелательным. Если вместо этого вы хотите, чтобы Knockout позволял вашей наблюдаемой модели принимать значения, для которых нет соответствующей записи в &amp;lt;select&amp;gt;, укажите valueAllowUnset: true. В этом случае, если ваше модельное значение не может быть представлено в &amp;lt;select&amp;gt;, тогда &amp;lt;select&amp;gt; просто не имеет выбранного значения в это время, что визуально представлено пустым. Когда пользователь позже выберет запись из раскрывающегося списка, это будет записано в вашу модель как обычно. Например:</target>
        </trans-unit>
        <trans-unit id="0df1b7294fed0a051d101c1ced30ea172ab4baf7" translate="yes" xml:space="preserve">
          <source>However, the value of the computed property is itself an observable. This would seem to lead to an awkward scenario, where reading its current value would involve double-unwrapping (i.e., params.myExpr()(), where the first parentheses give the value of the expression, and the second give the value of the resulting observable instance).</source>
          <target state="translated">Однако стоимость вычисленного свойства сама по себе является наблюдаемой.Казалось бы,это приведет к неловкому сценарию,при котором чтение его текущего значения будет связано с двойной оберткой (т.е.params.myExpr()(),где в первых круглых скобках указано значение выражения,а во вторых-значение результирующего наблюдаемого экземпляра).</target>
        </trans-unit>
        <trans-unit id="be4ce8e4d8bb3b24ee5b708a10a1169afa34a1e3" translate="yes" xml:space="preserve">
          <source>IE 6 does not allow radio buttons to be checked if they don&amp;rsquo;t have a name attribute. Most of the time this is irrelevant because your radio button elements &lt;em&gt;will&lt;/em&gt; have name attributes to put them into mutually-exclusive groups. However, just in case you didn&amp;rsquo;t add a name attribute because it&amp;rsquo;s unnecessary in your case, KO will internally use uniqueName on those elements to ensure they can be checked.</source>
          <target state="translated">IE 6 не позволяет проверять переключатели, если у них нет атрибута имени. В большинстве случаев это не имеет значения, потому что ваши элементы переключателя &lt;em&gt;будут&lt;/em&gt; иметь атрибуты имени, чтобы помещать их во взаимоисключающие группы. Однако на тот случай, если вы не добавили атрибут name, потому что он не нужен в вашем случае, KO будет внутренне использовать uniqueName для этих элементов, чтобы гарантировать, что они могут быть проверены.</target>
        </trans-unit>
        <trans-unit id="2fcefc92a53613238743a06738a1a958455ef2e0" translate="yes" xml:space="preserve">
          <source>IE 6 has a strange quirk whereby it sometimes ignores whitespace that immediately follows an empty span. This has nothing directly to do with Knockout, but in case you do want to write:</source>
          <target state="translated">В IE 6 есть странная причуда,в которой он иногда игнорирует пробелы,которые сразу же следуют за пустым пробелом.Это не имеет прямого отношения к Нокауту,но в случае,если вы действительно хотите писать:</target>
        </trans-unit>
        <trans-unit id="91559d59670bd974a48fef061e5a488f693ecb19" translate="yes" xml:space="preserve">
          <source>IE 6-8&amp;rsquo;s HTML parser will discard any unrecognized elements. To ensure it doesn&amp;rsquo;t throw out your custom elements, you must do one of the following:</source>
          <target state="translated">Парсер HTML IE 6-8 отбрасывает все нераспознанные элементы. Чтобы убедиться, что он не выбрасывает ваши пользовательские элементы, вы должны выполнить одно из следующих действий:</target>
        </trans-unit>
        <trans-unit id="2d16b47ea598c9827309c0d43dee7b26141e40d5" translate="yes" xml:space="preserve">
          <source>If a binding includes a manual subscription, this can be set to dispose automatically by calling its disposeWhenNodeIsRemoved method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa5f5e45ca2c0ef94cde806f22f9193ea7e171a" translate="yes" xml:space="preserve">
          <source>If a dependency is on an external object, then be sure to use .dispose() on the computed property, otherwise it (and possibly also your viewmodel) will be held in memory. Alternatively, consider using a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed&lt;/a&gt; to avoid the need for manual disposal.</source>
          <target state="translated">Если зависимость находится от внешнего объекта, обязательно используйте .dispose () для вычисляемого свойства, в противном случае оно (и, возможно, ваша модель просмотра) будет храниться в памяти. В качестве альтернативы, рассмотрите возможность использования &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;чистых&lt;/em&gt; вычислений,&lt;/a&gt; чтобы избежать необходимости ручного удаления.</target>
        </trans-unit>
        <trans-unit id="d97a8252f992217661b3da8e9168c34da29b4082" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does not&lt;/strong&gt; involve evaluating an observable/computed, it is passed literally.</source>
          <target state="translated">Если оценка параметра &lt;strong&gt;не&lt;/strong&gt; включает оценку наблюдаемого / вычисляемого, он передается буквально.</target>
        </trans-unit>
        <trans-unit id="85bdcb92d8fed08ef07c5a9167f6303fb9542783" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does&lt;/strong&gt; involve evaluating one or more observables/computeds, it is passed as a computed property so that you can react to changes in the parameter value.</source>
          <target state="translated">Если оценка параметра &lt;strong&gt;действительно&lt;/strong&gt; включает оценку одного или нескольких наблюдаемых / вычисляемых значений, оно передается как вычисляемое свойство, чтобы вы могли реагировать на изменения значения параметра.</target>
        </trans-unit>
        <trans-unit id="1f49d13df2276280d49d2672aa1b68bc3513435f" translate="yes" xml:space="preserve">
          <source>If a task throws an exception, it will not interrupt the task queue, which will continue until it is empty. The exception will instead be postponed to a later event and can be handled using &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; or window.onerror.</source>
          <target state="translated">Если задача вызывает исключение, она не прерывает очередь задач, которая будет продолжаться до тех пор, пока она не станет пустой. Вместо этого исключение будет отложено до более позднего события и может быть обработано с помощью &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; или window.onerror.</target>
        </trans-unit>
        <trans-unit id="c0e58b3f0b1346e29b75ea079a4a3af7f374c623" translate="yes" xml:space="preserve">
          <source>If any of the parameters passed to the component is observable, then the component can of course observe any changes, or even write back modified values. This is how it can communicate cleanly with its parent, without tightly coupling the component code to any parent that uses it.</source>
          <target state="translated">Если какой-либо из параметров,переданных компоненту,заметен,то компонент,конечно же,может наблюдать любые изменения или даже записывать обратно измененные значения.Таким образом,он может чисто общаться со своим родителем,не связывая код компонента с любым родителем,который его использует.</target>
        </trans-unit>
        <trans-unit id="d2042df6fe8e9a541f83353153b54cf9ca0fb63e" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to convert a componentConfig object into a viewmodel/template pair.</source>
          <target state="translated">Если объявлено,Knockout вызовет эту функцию для преобразования объекта componentConfig в пару viewmodel/template.</target>
        </trans-unit>
        <trans-unit id="399dea5a85a9f6316a3592794fb48cd5d6a619e0" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to obtain a configuration object for each component being instantiated.</source>
          <target state="translated">Если будет объявлено,нокаут вызовет эту функцию,чтобы получить объект конфигурации для каждого компонента,который будет инстанцирован.</target>
        </trans-unit>
        <trans-unit id="be4cb475157b09548b6d107ebd37c013b2c16886" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each &amp;lt;name&amp;gt; binding before the binding is evaluated.</source>
          <target state="translated">Если определено, эта функция будет вызываться для каждой привязки &amp;lt;name&amp;gt; перед оценкой привязки.</target>
        </trans-unit>
        <trans-unit id="6a046840fb4cbdaaea31db2bea0e71b5d3908b95" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each DOM node before bindings are processed. The function can modify, remove, or replace node. Any new nodes must be inserted immediately before node, and if any nodes were added or node was removed, the function must return an array of the new nodes that are now in the document in place of node.</source>
          <target state="translated">Если она определена,то перед обработкой привязок эта функция будет вызвана для каждого DOM-узла.Функция может модифицировать,удалять или заменять узел.Любые новые узлы должны быть вставлены непосредственно перед узлом,и если какие-либо узлы были добавлены или удалены,то функция должна вернуть массив новых узлов,которые сейчас в документе находятся на месте узла.</target>
        </trans-unit>
        <trans-unit id="8a2cb3b57840c0deef2eb7e49e7b4db257ff08df" translate="yes" xml:space="preserve">
          <source>If no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.</source>
          <target state="translated">Если вид-модель не задана,компонент рассматривается как простой блок HTML,который будет привязан к любым параметрам,переданным компоненту.</target>
        </trans-unit>
        <trans-unit id="6caa6867d855ce7ca277ec137fe7e6b2092a7de4" translate="yes" xml:space="preserve">
          <source>If required, you can remove ko.components.defaultLoader from the loaders array altogether.</source>
          <target state="translated">При необходимости можно полностью удалить ko.components.defaultLoader из массива загрузчиков.</target>
        </trans-unit>
        <trans-unit id="03317c5ba9cb772a076d1cd9742af2eaadf6c3ea" translate="yes" xml:space="preserve">
          <source>If the array you supply is observable, the foreach binding will respond to any future changes in the array&amp;rsquo;s contents by adding or removing corresponding sections of markup in the DOM.</source>
          <target state="translated">Если предоставленный вами массив является наблюдаемым, привязка foreach будет реагировать на любые будущие изменения содержимого массива, добавляя или удаляя соответствующие разделы разметки в DOM.</target>
        </trans-unit>
        <trans-unit id="612f5263f91277945f3c298ba4abc465bd6747bb" translate="yes" xml:space="preserve">
          <source>If the checkedValue parameter is set, that value is used instead of true to represent a &lt;em&gt;checked&lt;/em&gt; status, and an &lt;em&gt;unchecked&lt;/em&gt; status is represented with a value of undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ef00d24a33559e687f508a59c22e7850ec79c" translate="yes" xml:space="preserve">
          <source>If the component binding&amp;rsquo;s name value changes observably, or if an enclosing control-flow binding causes the container element to be removed, then any dispose function on the viewmodel is called just before the container element is removed from the DOM. See also: &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposal and memory management&lt;/a&gt;.</source>
          <target state="translated">Если значение имени привязки компонента изменяется наблюдаемым образом или если охватывающая привязка потока управления вызывает удаление элемента контейнера, то любая функция удаления в модели представления вызывается непосредственно перед тем, как элемент контейнера удаляется из модели DOM. См. Также: &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;удаление и управление памятью&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da622aea8b5c8a482d41ae46dd18ebd2d3a51d5" translate="yes" xml:space="preserve">
          <source>If the expression you provide to the let binding unwraps any observables, each descendant binding will include an additional dependency on the let binding. This is true whether or not the binding references any of the custom context properties. If you want to make an observable value available through let, it is generally better to set the observable itself rather than unwrap it and set the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354afd97c35f636203d9262ca360ec893a10aa03" translate="yes" xml:space="preserve">
          <source>If the expression you supply evaluates to null or undefined, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="translated">Если предоставленное вами выражение имеет значение null или undefined, дочерние элементы &lt;em&gt;вообще не&lt;/em&gt; будут связаны, а вместо этого будут удалены из документа.</target>
        </trans-unit>
        <trans-unit id="348434b438cb1d0346b5c2336a1b0270a699841f" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. Then, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new evaluation result.</source>
          <target state="translated">Если предоставленное вами выражение включает какие-либо наблюдаемые значения, выражение будет повторно оцениваться при изменении любого из этих наблюдаемых значений. Затем дочерние элементы будут удалены, и &lt;strong&gt;новая копия разметки&lt;/strong&gt; будет добавлена ​​в ваш документ и привязана в контексте нового результата оценки.</target>
        </trans-unit>
        <trans-unit id="3f2e0923cee18f9719776d03929fd49911724f4b" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. These bindings differ in how they react when the bound value changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623412eb267c55f2826cce3e4419e3b4cba4388f" translate="yes" xml:space="preserve">
          <source>If the expression you supply unwraps any observable values, the expression will be re-evaluated whenever any of those observables change. Additionally, the bindings for all descendant elements will be re-evaluated as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61935dcf249e331edbcc8210b8ebbb2409b5384" translate="yes" xml:space="preserve">
          <source>If the firstName observable&amp;rsquo;s value was changed to Ted, then the console would show first name: Ted.</source>
          <target state="translated">Если значение наблюдаемого объекта firstName было изменено на Ted, то на консоли отобразилось бы имя: Ted.</target>
        </trans-unit>
        <trans-unit id="90ee5b54e158b99edb3b0d00a6d84366ceb29486" translate="yes" xml:space="preserve">
          <source>If the user manually focuses or unfocuses the associated element, the viewmodel property will be set to true or false accordingly.</source>
          <target state="translated">Если пользователь вручную фокусирует или расфокусирует ассоциированный элемент,свойство viewmodel будет установлено в true или false соответственно.</target>
        </trans-unit>
        <trans-unit id="bbaee0a673e126908759d4192388e02a5778a34a" translate="yes" xml:space="preserve">
          <source>If the value you supply is observable, the hasFocus binding will update the element&amp;rsquo;s focus state whenever that observable value changes.</source>
          <target state="translated">Если предоставленное вами значение является наблюдаемым, привязка hasFocus будет обновлять состояние фокуса элемента всякий раз, когда это наблюдаемое значение изменяется.</target>
        </trans-unit>
        <trans-unit id="b5c5acd515e8ae2158bb6854344b82731dca4d6c" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a constructor function, this means Knockout calls new YourViewModel(params).</source>
          <target state="translated">Если Viewmodel задана в качестве функции конструктора,то это означает,что Knockout вызывает новую YourViewModel(params).</target>
        </trans-unit>
        <trans-unit id="73a19cfa23e05247f726bb0c3e3e11110deb972d" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a createViewModel factory function, Knockout calls createViewModel(params, componentInfo), where componentInfo.element is the element into which the not-yet-bound template has already been injected.</source>
          <target state="translated">Если видовая модель задана как заводская функция createViewModel,Knockout вызывает createViewModel(params,componentInfo),где componentInfo.element-элемент,в который уже был вставлен шаблон,не связанный с темой.</target>
        </trans-unit>
        <trans-unit id="105d045e38636fe798ecdb5a45a203d90df04fff" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s available options whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s available options once and will not update them again later.</source>
          <target state="translated">Если этот параметр является наблюдаемым значением, привязка будет обновлять доступные параметры элемента при изменении значения. Если параметр не является наблюдаемым, он устанавливает доступные параметры элемента только один раз и не обновляет их позже.</target>
        </trans-unit>
        <trans-unit id="cb1eb730b6d4db61f330d71ef6135d8fac903258" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s content whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s content once and will not update it again later.</source>
          <target state="translated">Если этот параметр является наблюдаемым значением, привязка будет обновлять содержимое элемента всякий раз, когда значение изменяется. Если параметр не является наблюдаемым, он устанавливает содержимое элемента только один раз и не обновляет его позже.</target>
        </trans-unit>
        <trans-unit id="d54c813843091459c90fd11e7297fc0446687938" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s text whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s text once and will not update it again later.</source>
          <target state="translated">Если этот параметр является наблюдаемым значением, привязка будет обновлять текст элемента всякий раз, когда значение изменяется. Если параметр не является наблюдаемым, он установит текст элемента только один раз и не будет обновлять его позже.</target>
        </trans-unit>
        <trans-unit id="7a744e971b96b18141128533922f19a87beb8881" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the observable value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">Если этот параметр является наблюдаемым значением, привязка будет обновлять значение элемента всякий раз, когда наблюдаемое значение изменяется. Если параметр не является наблюдаемым, он установит значение элемента только один раз и не будет обновлять его позже.</target>
        </trans-unit>
        <trans-unit id="47eda63e6c27e664a420f7aabc543742f5f58f16" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">Если этот параметр является наблюдаемым значением, привязка будет обновлять значение элемента при каждом изменении значения. Если параметр не является наблюдаемым, он установит значение элемента только один раз и не будет обновлять его позже.</target>
        </trans-unit>
        <trans-unit id="697682d3cadcd44d9c1d1305da3a61036fdfa605" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s visibility whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s visibility once and will not update it again later.</source>
          <target state="translated">Если этот параметр является наблюдаемым значением, привязка будет обновлять видимость элемента при изменении значения. Если параметр не является наблюдаемым, он только один раз установит видимость элемента и не будет обновлять ее позже.</target>
        </trans-unit>
        <trans-unit id="f45c52f51bf20ce24a7e4b608d15ab347ed9c290" translate="yes" xml:space="preserve">
          <source>If valueAllowUnset had not been enabled, then Knockout would have overwritten selectedCountry with undefined, so that it would match the value of the 'Choose one...' caption entry.</source>
          <target state="translated">Если бы значениеAllowUnset не было включено,то Knockout перезаписал бы selectedCountry с неопределенным значением,чтобы оно совпадало со значением заголовка 'Choose one...'.</target>
        </trans-unit>
        <trans-unit id="a24740e5d492d0bcabc30118270e3e7eae827804" translate="yes" xml:space="preserve">
          <source>If you apply a simple numeric value to a style that requires a unit, Knockout will append px to the value before setting the style. For example, style: { width: 100 } will set the width to 100px.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3ea4a49bfcd03916cd06d69dac827b155984b2" translate="yes" xml:space="preserve">
          <source>If you are trying to bind an &amp;lt;input type=&quot;text&quot; /&amp;gt; or &amp;lt;textarea&amp;gt; to get instant updates to your viewmodel, use the &lt;a href=&quot;textinput-binding&quot;&gt;the textInput binding&lt;/a&gt;. It has better support for browser edge cases than any combination of valueUpdate options.</source>
          <target state="translated">Если вы пытаетесь привязать &amp;lt;input type = &quot;text&quot; /&amp;gt; или &amp;lt;textarea&amp;gt; для получения мгновенных обновлений вашей модели просмотра, используйте &lt;a href=&quot;textinput-binding&quot;&gt;привязку textInput&lt;/a&gt; . Он лучше поддерживает крайние случаи браузера, чем любая комбинация параметров valueUpdate.</target>
        </trans-unit>
        <trans-unit id="1a7f396d14387545628545aeb2802baaa004a716" translate="yes" xml:space="preserve">
          <source>If you are using a component loader to fetch components by a naming convention, and are &lt;em&gt;not&lt;/em&gt; registering your components using ko.components.register, then those components will not automatically be usable as custom elements (because you haven&amp;rsquo;t told Knockout that they even exist).</source>
          <target state="translated">Если вы используете загрузчик компонентов для извлечения компонентов по соглашению об именах и &lt;em&gt;не&lt;/em&gt; регистрируете свои компоненты с помощью ko.components.register, то эти компоненты не будут автоматически использоваться в качестве настраиваемых элементов (поскольку вы не сказали Knockout, что они даже существует).</target>
        </trans-unit>
        <trans-unit id="57acecaab300936e5fb81a00ce2ade1592a7db93" translate="yes" xml:space="preserve">
          <source>If you are using foreach and only want to be notified about elements that are specifically being added or are being removed, you can use afterAdd and beforeRemove instead. For details, see documentation for the &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;.</source>
          <target state="translated">Если вы используете foreach и хотите получать уведомления только об элементах, которые специально добавляются или удаляются, вы можете вместо этого использовать afterAdd и beforeRemove. Дополнительные сведения см. В документации по &lt;a href=&quot;foreach-binding&quot;&gt;привязке foreach&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce083543ff1be7a981205d49b50c12c2d35aab21" translate="yes" xml:space="preserve">
          <source>If you are using static CSS class names, then you can pass a JavaScript object in which the property names are your CSS classes, and their values evaluate to true or false according to whether the class should currently be applied.</source>
          <target state="translated">Если вы используете статические имена CSS классов,то вы можете передать объект JavaScript,в котором имена свойств являются вашими CSS классами,и их значения оцениваются до true или false в зависимости от того,должен ли класс применяться в данный момент.</target>
        </trans-unit>
        <trans-unit id="b409ece9cd23f86abee691f7b17d7b89e59dbba4" translate="yes" xml:space="preserve">
          <source>If you are using the default component loader, and hence are registering your components using ko.components.register, then there is nothing extra you need to do. Components registered this way are immediately available for use as custom elements.</source>
          <target state="translated">Если вы используете загрузчик компонентов по умолчанию,и,следовательно,регистрируете свои компоненты с помощью ko.components.register,то ничего лишнего делать не нужно.Зарегистрированные таким образом компоненты немедленно доступны для использования в качестве пользовательских элементов.</target>
        </trans-unit>
        <trans-unit id="8ddcd80cbca13d044050f160b5fe2da2f4edef8d" translate="yes" xml:space="preserve">
          <source>If you commonly include template content using virtual elements, the normal syntax can feel a bit verbose. Using preprocessing, you can add a new template format that uses a single comment:</source>
          <target state="translated">Если вы обычно включаете содержимое шаблона,используя виртуальные элементы,обычный синтаксис может показаться немного многословным.Используя препроцессирование,вы можете добавить новый формат шаблона,который использует один комментарий:</target>
        </trans-unit>
        <trans-unit id="c1d7cd0691a5cabd2961f5bde8eb238a8f9e084c" translate="yes" xml:space="preserve">
          <source>If you create a computed observable in a custom binding, rather than using a custom disposal callback, you can set the computed to dispose automatically when the node is removed. When constructing the computed observable, provide the node using the disposeWhenNodeIsRemoved option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dac748b82ce1d7e9df2f75a51a1b265e4aee88" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a configuration for the named component, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Если вы не хотите,чтобы ваш загрузчик поставлял конфигурацию для именованного компонента,то позвоните обратно (null).Затем нокаут проконсультируется с любыми другими зарегистрированными загрузчиками по порядку,пока один из них не поставит ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="a803a11622a50576c908d4836ed761b181f5ff65" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a createViewModel function for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Если вы не хотите,чтобы загрузчик поставлял функцию createViewModel для заданных параметров (например,потому что он не распознает формат конфигурации),вызовите функцию calllback(null).После этого нокаут проконсультируется с любыми другими зарегистрированными загрузчиками по порядку,пока один из них не поставит ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="88a98aefdcf31a903e5d480df483166240bfba37" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a template for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Если вы не хотите,чтобы загрузчик предоставлял шаблон для заданных параметров (например,потому что он не распознает формат конфигурации),вызовите обратный вызов (null).После этого Knockout проконсультируется с другими зарегистрированными загрузчиками по порядку,пока один из них не выдаст ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="96bd57dfc5e8e227d695eb9cc1de257c99d1c474" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a viewmodel/template pair for the given parameters, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Если вы не хотите,чтобы загрузчик поставлял пару viewmodel/template для заданных параметров,то вызовите calllback(null).Затем нокаут проконсультируется с любыми другими зарегистрированными загрузчиками по порядку,пока один из них не поставит ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="c512ba9128c02d4d1a3f480875fdee4dc35677d7" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the optionsText option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.</source>
          <target state="translated">Если вы не хотите отображать только простое значение свойства в качестве текста для каждого элемента в раскрывающемся списке, вы можете передать функцию JavaScript для параметра optionsText и предоставить свою собственную произвольную логику для вычисления отображаемого текста в терминах представленного объекта. , См. Пример 4 выше, в котором показано, как можно создать отображаемый текст, объединив несколько значений свойств.</target>
        </trans-unit>
        <trans-unit id="4830a1b281a9a9be8b4899be04ed0ad714a44701" translate="yes" xml:space="preserve">
          <source>If you have a reference to a DOM element in your code, you can use it as a container for template markup:</source>
          <target state="translated">Если в вашем коде есть ссылка на DOM-элемент,вы можете использовать его как контейнер для разметки шаблона:</target>
        </trans-unit>
        <trans-unit id="6fc07db8d07ca18d202ff7e05a94198b45413180" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a template. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">Если у вас есть загрузчик AMD (например, &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; ) на вашей странице, вы можете использовать его для получения шаблона. Подробнее о том, как это работает, см. Ниже , &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;как Knockout загружает компоненты через AMD&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="9a69d18b622bb3cca3c70f1710dff19c9f5aca93" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">Если у вас есть загрузчик AMD (например, &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; ) на вашей странице, вы можете использовать его для получения модели просмотра. Подробнее о том, как это работает, см. Ниже , &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;как Knockout загружает компоненты через AMD&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="8d613332487fc8236cb7e6d5e6bc539bf312e263" translate="yes" xml:space="preserve">
          <source>If you have implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;, and are not using ko.components.register, then you need to tell Knockout about any element names you wish to use as custom elements. To do this, simply call ko.components.register - you don&amp;rsquo;t need to specify any configuration, since your custom component loader won&amp;rsquo;t be using the configuration anyway. For example,</source>
          <target state="translated">Если вы реализовали &lt;a href=&quot;component-loaders&quot;&gt;загрузчик настраиваемых компонентов&lt;/a&gt; и не используете ko.components.register, вам необходимо сообщить Knockout о любых именах элементов, которые вы хотите использовать в качестве настраиваемых элементов. Для этого просто вызовите ko.components.register - вам не нужно указывать какую-либо конфигурацию, поскольку ваш пользовательский загрузчик компонентов в любом случае не будет использовать эту конфигурацию. Например,</target>
        </trans-unit>
        <trans-unit id="c6dc783c88a9a55d059f753b19bf7c4b10f1293f" translate="yes" xml:space="preserve">
          <source>If you have multiple named templates, you can pass an observable for the name option. As the observable&amp;rsquo;s value is updated, the element&amp;rsquo;s contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the foreach template mode, Knockout will evaluate the function for each item in your array, passing that item&amp;rsquo;s value as the only argument. Otherwise, the function will be given the data option&amp;rsquo;s value or fall back to providing your whole current model object.</source>
          <target state="translated">Если у вас есть несколько именованных шаблонов, вы можете передать наблюдаемое значение для параметра имени. По мере обновления значения наблюдаемого содержимое элемента будет повторно отображено с использованием соответствующего шаблона. Кроме того, вы можете передать функцию обратного вызова, чтобы определить, какой шаблон использовать. Если вы используете режим шаблона foreach, Knockout будет оценивать функцию для каждого элемента в вашем массиве, передавая значение этого элемента в качестве единственного аргумента. В противном случае функции будет присвоено значение параметра данных или она вернется к предоставлению всего текущего объекта модели.</target>
        </trans-unit>
        <trans-unit id="f9fde0bfc8d899331beb6d9ec952dcb2dab1b640" translate="yes" xml:space="preserve">
          <source>If you have subscribed to an external observable, be sure to use .dispose() on the subscription, otherwise the callback (and possibly also your viewmodel) will be held in memory.</source>
          <target state="translated">Если вы подписались на внешнее наблюдаемое,обязательно используйте .dispose()в подписке,иначе обратный вызов (и,возможно,также вашу viewmodel)будет храниться в памяти.</target>
        </trans-unit>
        <trans-unit id="3c4d57bb828a71531ceeb4aa49b28a3c60f87e52" translate="yes" xml:space="preserve">
          <source>If you leave off the value of a binding, it&amp;rsquo;s bound to undefined by default. If you want to have a different default value for a binding, you can do so with a preprocessor. For example, you can allow uniqueName to be bound without a value by making its default value true:</source>
          <target state="translated">Если вы не укажете значение привязки, по умолчанию оно будет иметь значение undefined. Если вы хотите иметь другое значение по умолчанию для привязки, вы можете сделать это с помощью препроцессора. Например, вы можете разрешить привязку uniqueName без значения, установив для него значение по умолчанию true:</target>
        </trans-unit>
        <trans-unit id="df6baaff79cb69e31e568c59ade70f1456f1c34c" translate="yes" xml:space="preserve">
          <source>If you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:</source>
          <target state="translated">Если вам нужно передать больше параметров,то один из способов сделать это-обернуть обработчик в функцию буквально,которая принимает параметр,как в данном примере:</target>
        </trans-unit>
        <trans-unit id="395b1c02e2a6fd4dd3478f8ed3123de446425e64" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below.</source>
          <target state="translated">Если вам нужно запустить дополнительную пользовательскую логику на сгенерированных элементах DOM,вы можете использовать любой из afterRender/afterAdd/beforeRemove/beforeMove/afterMove callback,описанных ниже.</target>
        </trans-unit>
        <trans-unit id="e172b40bc2aac406378c1826a63899ef1e1c8897" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. See Note 2 below.</source>
          <target state="translated">Если вам нужно запустить дополнительную пользовательскую логику для сгенерированных элементов опций,вы можете использовать опциюАфтерРендер обратного вызова.См.примечание 2 ниже.</target>
        </trans-unit>
        <trans-unit id="e0946163467362f9f0453888bade424cd2a18cd9" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. The callback function is invoked each time an option element is inserted into the list, with the following parameters:</source>
          <target state="translated">Если вам нужно запустить дополнительную пользовательскую логику для сгенерированных элементов опций,вы можете использовать опциюАфтерРендер обратного вызова.Функция обратного вызова вызывается каждый раз,когда элемент опции добавляется в список,со следующими параметрами:</target>
        </trans-unit>
        <trans-unit id="7add5138afadba9db94cdfc48e15c94798748a29" translate="yes" xml:space="preserve">
          <source>If you need to set HTML content in this manner, see &lt;a href=&quot;html-binding&quot;&gt;the html binding&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно настроить HTML-содержимое таким образом, см. &lt;a href=&quot;html-binding&quot;&gt;Привязку html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e813a05b4d4fc8d95d220cb80a0c91d23fba7f44" translate="yes" xml:space="preserve">
          <source>If you only need to combine updates without adding a delay, &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; provides a more efficient method.</source>
          <target state="translated">Если вам нужно только объединить обновления без добавления задержки, &lt;a href=&quot;deferred-updates&quot;&gt;отложенные обновления&lt;/a&gt; предоставляют более эффективный метод.</target>
        </trans-unit>
        <trans-unit id="5e7be95f226e675b640699b19295d6d29cb25a1d" translate="yes" xml:space="preserve">
          <source>If you only need to use the compound full name in the UI you could declare it as:</source>
          <target state="translated">Если вам нужно использовать только полное название соединения в пользовательском интерфейсе,вы можете объявить его как:</target>
        </trans-unit>
        <trans-unit id="fd19412014a27de66dbd7f90139a256b3d51da33" translate="yes" xml:space="preserve">
          <source>If you open your browser developer tools&amp;rsquo; &lt;strong&gt;Network&lt;/strong&gt; inspector before your first click on &lt;em&gt;Add product&lt;/em&gt;, you&amp;rsquo;ll see that the component&amp;rsquo;s .js/.html files are fetched on demand when first required, and thereafter retained for reuse.</source>
          <target state="translated">Если вы откроете Инспектор &lt;strong&gt;сети&lt;/strong&gt; инструментов разработчика браузера до того, как в первый раз нажмете &amp;laquo; &lt;em&gt;Добавить продукт&amp;raquo;&lt;/em&gt; , вы увидите, что файлы .js / .html компонента извлекаются по запросу, когда они впервые требуются, а затем сохраняются для повторного использования.</target>
        </trans-unit>
        <trans-unit id="7e3531ed2ee3130336ffaac70ea47406b8f9ad62" translate="yes" xml:space="preserve">
          <source>If you pass just a string, it is interpreted as a component name. The named component is then injected without supplying any parameters to it. Example:</source>
          <target state="translated">Если вы передаете только строку,она интерпретируется как имя компонента.Именованный компонент вводится без указания параметров.Пример:</target>
        </trans-unit>
        <trans-unit id="d8655e03ea768a2840f2c814ce3e4612e25b0a0e" translate="yes" xml:space="preserve">
          <source>If you prefer, you could combine templateFromUrlLoader and viewModelCustomLoader into a single loader by putting the loadTemplate and loadViewModel functions on a single object. However it&amp;rsquo;s quite nice to separate out these concerns, since their implementations are quite independent.</source>
          <target state="translated">При желании вы можете объединить templateFromUrlLoader и viewModelCustomLoader в один загрузчик, поместив функции loadTemplate и loadViewModel в один объект. Однако неплохо разделить эти проблемы, так как их реализации довольно независимы.</target>
        </trans-unit>
        <trans-unit id="7d9099195cbde906f499c9495d5f5fd785651e50" translate="yes" xml:space="preserve">
          <source>If you refer to model properties in a params attribute, then you are of course referring to the properties on the viewmodel outside the component (the &amp;lsquo;parent&amp;rsquo; or &amp;lsquo;host&amp;rsquo; viewmodel), since the component itself is not instantiated yet. In the above example, myModelValue would be a property on the parent viewmodel, and would be received by the child component viewmodel&amp;rsquo;s constructor as params.someModelProperty.</source>
          <target state="translated">Если вы ссылаетесь на свойства модели в атрибуте params, то вы, конечно, имеете в виду свойства модели представления за пределами компонента (&amp;laquo;родительская&amp;raquo; или &amp;laquo;основная&amp;raquo; модель представления), поскольку сам компонент еще не создан. В приведенном выше примере myModelValue будет свойством в родительской модели представления и будет получено конструктором модели представления дочернего компонента как params.someModelProperty.</target>
        </trans-unit>
        <trans-unit id="7b53a3732a6bc04d508eda25f801b0bef1ad6dfd" translate="yes" xml:space="preserve">
          <source>If you reference a &lt;em&gt;simple property&lt;/em&gt;, i.e., it is just a regular property on your view model, KO will set the form element&amp;rsquo;s initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn&amp;rsquo;t observable), so this is only a 1-way binding.</source>
          <target state="translated">Если вы ссылаетесь на &lt;em&gt;простое свойство&lt;/em&gt; , т. Е. Это просто обычное свойство в вашей модели представления, KO установит начальное состояние элемента формы в значение свойства, а когда элемент формы будет отредактирован, KO запишет изменения обратно в ваше свойство , Он не может определить, когда свойство изменяется (потому что это не наблюдается), поэтому это только односторонняя привязка.</target>
        </trans-unit>
        <trans-unit id="7d891ed8be741967c449e958da98ffc8cc566217" translate="yes" xml:space="preserve">
          <source>If you reference something that is &lt;em&gt;not&lt;/em&gt; a simple property, e.g., the result of a function call or comparison operation, KO will set the form element&amp;rsquo;s initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it&amp;rsquo;s a one-time-only value setter, not an ongoing binding that reacts to changes.</source>
          <target state="translated">Если вы ссылаетесь на что-то, что &lt;em&gt;не&lt;/em&gt; является простым свойством, например, результат вызова функции или операции сравнения, KO установит начальное состояние элемента формы на это значение, но не сможет записать какие-либо изменения обратно, когда пользователь редактирует элемент формы. В данном случае это одноразовое средство установки значения, а не постоянная привязка, которая реагирует на изменения.</target>
        </trans-unit>
        <trans-unit id="4136055364963301ac3a0672768006e0b60b4010" translate="yes" xml:space="preserve">
          <source>If you set the viewmodel property to true or false, the associated element will become focused or unfocused.</source>
          <target state="translated">Если вы установите свойство viewmodel равным true или false,то связанный с ним элемент станет сфокусированным или разфокусированным.</target>
        </trans-unit>
        <trans-unit id="b04308191c20dd0438d23903c6a2d68567c5dfe6" translate="yes" xml:space="preserve">
          <source>If you specify bindings without a value, Knockout will give the binding an undefined value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea10c506e67e02d37f3ff59d06b553132c889a0" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString()</source>
          <target state="translated">Если вы предоставляете что-то кроме числа или строки (например,передаете объект или массив),отображаемый текст будет эквивалентен yourParameter.toString().</target>
        </trans-unit>
        <trans-unit id="8f936a4cf3802ef50c0aec5ecfef503f372a0ded" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString() (that&amp;rsquo;s usually not very useful, so it&amp;rsquo;s best to supply string or numeric values).</source>
          <target state="translated">Если вы вводите что-то иное, кроме числа или строки (например, вы передаете объект или массив), отображаемый текст будет эквивалентен yourParameter.toString () (что обычно не очень полезно, поэтому лучше предоставить строку или числовой ценности).</target>
        </trans-unit>
        <trans-unit id="33531730aa65cc0aed58be0f106c04649fd218ba" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the innerHTML will be equivalent to yourParameter.toString()</source>
          <target state="translated">Если вы предоставляете что-то кроме числа или строки (например,передаете объект или массив),то innerHTML будет эквивалентен yourParameter.toString().</target>
        </trans-unit>
        <trans-unit id="d0c67876e2d6e6a962ee02ea3bfd2bc8d147be3f" translate="yes" xml:space="preserve">
          <source>If you tend to filter observable arrays a lot, adding a filterByProperty globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose &lt;em&gt;not&lt;/em&gt; to attach to ko.observableArray.fn, and instead just construct doneTasks by hand as follows:</source>
          <target state="translated">Если вы склонны часто фильтровать наблюдаемые массивы, добавление filterByProperty глобально ко всем наблюдаемым массивам может сделать ваш код более аккуратным. Но если вам нужно фильтровать только время от времени, вы можете вместо этого &lt;em&gt;отказаться&lt;/em&gt; от присоединения к ko.observableArray.fn, а вместо этого просто создать doneTasks вручную следующим образом:</target>
        </trans-unit>
        <trans-unit id="e10e3c94b35fd8632dab2ca5d675651a6b4f0bb0" translate="yes" xml:space="preserve">
          <source>If you use value to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.</source>
          <target state="translated">Если вы используете значение,чтобы связать элемент формы с наблюдаемым свойством,KO может настроить двухстороннюю привязку так,чтобы изменения повлияли на другое.</target>
        </trans-unit>
        <trans-unit id="e93054a2d66f23c13f6c50afc30a17cac10665b4" translate="yes" xml:space="preserve">
          <source>If you want Knockout to allow your model property to take values that have no corresponding entry in your &amp;lt;select&amp;gt; element (and display this by making the &amp;lt;select&amp;gt; element blank), then see &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;documentation for valueAllowUnset&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите, чтобы Knockout позволял свойству модели принимать значения, которые не имеют соответствующей записи в вашем элементе &amp;lt;select&amp;gt; (и отображать это, сделав элемент &amp;lt;select&amp;gt; пустым), см. &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;Документацию для valueAllowUnset&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a89bcaf9d5696bd11fb99d2d58e919ab34e4a21" translate="yes" xml:space="preserve">
          <source>If you want a custom binding to be usable with Knockout&amp;rsquo;s &lt;em&gt;virtual elements&lt;/em&gt; syntax, e.g.:</source>
          <target state="translated">Если вы хотите, чтобы пользовательскую привязку можно было использовать с синтаксисом &lt;em&gt;виртуальных элементов&lt;/em&gt; Knockout , например:</target>
        </trans-unit>
        <trans-unit id="12de6cba1d2b34cbb4e79120d38a72eb8f87f4f5" translate="yes" xml:space="preserve">
          <source>If you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):</source>
          <target state="translated">Если вы хотите,чтобы все экземпляры вашего компонента имели один и тот же экземпляр объекта Viewmodel (что обычно нежелательно):</target>
        </trans-unit>
        <trans-unit id="2f370654b97f0f29acfaf8c9f3cbd1053b47dfd4" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of a foreach binding, but using a named template, you can do so in the natural way:</source>
          <target state="translated">Если вам нужен эквивалент привязки фораха,но с использованием именованного шаблона,вы можете сделать это естественным образом:</target>
        </trans-unit>
        <trans-unit id="e0687bb9af427b875127182534a1eca56e0d6596" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify an array of propertynames to ignore:</source>
          <target state="translated">Если вы хотите,чтобы плагин mapping игнорировал некоторые свойства вашего JS объекта (т.е.не отображал их),вы можете указать массив имен свойств для игнорирования:</target>
        </trans-unit>
        <trans-unit id="48877e0877c23be66516c571a7f2f9808b04bbbc" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to only create observables of some properties of your JS object and copy the rest, you can specify an array of propertynames to observe:</source>
          <target state="translated">Если вы хотите,чтобы плагин mapping создавал наблюдения только некоторых свойств вашего JS объекта,а остальные копировал,вы можете указать массив имен свойств для наблюдения:</target>
        </trans-unit>
        <trans-unit id="1a610cb362a9cb355f038caa3483260b1682b467" translate="yes" xml:space="preserve">
          <source>If you want to access data/functions from parent binding contexts, you can use &lt;a href=&quot;binding-context&quot;&gt;special context properties such as $parent and $root&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите получить доступ к данным / функциям из родительских контекстов привязки, вы можете использовать &lt;a href=&quot;binding-context&quot;&gt;специальные свойства контекста, такие как $ parent и $ root&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5e8a9598e8913d6b161a0231caddfc4c3d6385d" translate="yes" xml:space="preserve">
          <source>If you want to apply a font-weight or text-decoration style, or any other style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you must use the &lt;em&gt;JavaScript name&lt;/em&gt; for that style. For example,</source>
          <target state="translated">Если вы хотите применить стиль font-weight или text-decoration, или любой другой стиль, имя которого не является допустимым идентификатором JavaScript (например, потому что оно содержит дефис), вы должны использовать &lt;em&gt;имя JavaScript&lt;/em&gt; для этого стиля. Например,</target>
        </trans-unit>
        <trans-unit id="42a04b9a7a064c9209637e25fdea69c9c72b38f4" translate="yes" xml:space="preserve">
          <source>If you want to apply a style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you can either put it in quotes or use the JavaScript name for that style. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1a7840c3566eba919210c187885f629cdea7e6" translate="yes" xml:space="preserve">
          <source>If you want to apply the CSS class my-class, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">Если вы хотите применить класс CSS my-class, вы &lt;em&gt;не можете&lt;/em&gt; написать это:</target>
        </trans-unit>
        <trans-unit id="400ea2089a975a1be517a84a31ee89203ffb5ce6" translate="yes" xml:space="preserve">
          <source>If you want to apply the attribute data-something, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">Если вы хотите применить атрибут data-something, вы &lt;em&gt;не можете&lt;/em&gt; написать это:</target>
        </trans-unit>
        <trans-unit id="926dd1aabde3cc388fd5f78c44f8b0dc656ffe88" translate="yes" xml:space="preserve">
          <source>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the beforeChange event. For example:</source>
          <target state="translated">Если вы хотите,чтобы вас уведомили о значении наблюдаемого до того,как оно будет изменено,вы можете подписаться на событие beforeChange.Например:</target>
        </trans-unit>
        <trans-unit id="4dc22f6555d4554142d875304efe0f5c3fb52625" translate="yes" xml:space="preserve">
          <source>If you want to change the policy for a particular component, you can specify synchronous: true on that component&amp;rsquo;s configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load. However, if your component can always be loaded and initialized synchronously, then enabling this option will ensure consistently synchronous behavior. This might be important if you&amp;rsquo;re using a component within a foreach binding and want to use the afterAdd or afterRender options to do post-processing.</source>
          <target state="translated">Если вы хотите изменить политику для определенного компонента, вы можете указать synchronous: true в конфигурации этого компонента. Затем он может загружаться асинхронно при первом использовании, а затем синхронно при всех последующих использованиях. Если вы это сделаете, вам нужно будет учитывать это изменчивое поведение в любом коде, который ожидает загрузки компонентов. Однако, если ваш компонент всегда можно загрузить и инициализировать синхронно, то включение этой опции обеспечит стабильное синхронное поведение. Это может быть важно, если вы используете компонент в привязке foreach и хотите использовать параметры afterAdd или afterRender для последующей обработки.</target>
        </trans-unit>
        <trans-unit id="5d46531ca9799ade7ca26f1bed17707b4876bd54" translate="yes" xml:space="preserve">
          <source>If you want to convert your mapped object back to a regular JS object, use:</source>
          <target state="translated">Если вы хотите преобразовать свой отображаемый объект обратно в обычный JS-объект,используйте его:</target>
        </trans-unit>
        <trans-unit id="20972324a8ac6446023da390397678c0423402dd" translate="yes" xml:space="preserve">
          <source>If you want to detect and respond to changes on one object, you&amp;rsquo;d use &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;. If you want to detect and respond to changes of a &lt;em&gt;collection of things&lt;/em&gt;, use an observableArray. This is useful in many scenarios where you&amp;rsquo;re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</source>
          <target state="translated">Если вы хотите обнаруживать изменения одного объекта и реагировать на них, вы должны использовать &lt;a href=&quot;observables&quot;&gt;наблюдаемые&lt;/a&gt; объекты . Если вы хотите обнаруживать изменения &lt;em&gt;набора вещей&lt;/em&gt; и реагировать на них , используйте observableArray. Это полезно во многих сценариях, когда вы отображаете или редактируете несколько значений и вам нужно, чтобы повторяющиеся разделы пользовательского интерфейса появлялись и исчезали по мере добавления и удаления элементов.</target>
        </trans-unit>
        <trans-unit id="5dbe5851856488928c88861ca66a429c2a8a54c3" translate="yes" xml:space="preserve">
          <source>If you want to detemine text programmatically, one option is to create a &lt;a href=&quot;computedobservables&quot;&gt;computed observable&lt;/a&gt;, and use its evaluator function as a place for your code that works out what text to display.</source>
          <target state="translated">Если вы хотите определить текст программно, один из вариантов - создать &lt;a href=&quot;computedobservables&quot;&gt;вычисляемую наблюдаемую&lt;/a&gt; и использовать ее функцию оценки в качестве места для вашего кода, который определяет, какой текст отображать.</target>
        </trans-unit>
        <trans-unit id="a0e5d4f6f665f1af91a7e87e9210302dace1de3d" translate="yes" xml:space="preserve">
          <source>If you want to do this in custom bindings, then instead of using bindingContext.extend(), use bindingContext.createChildContext(someData). This returns a new binding context whose viewmodel is someData and whose $parentContext is bindingContext. If you want, you can then extend the child context with extra properties using ko.utils.extend. For example,</source>
          <target state="translated">Если вы хотите сделать это в пользовательских привязках,то вместо того,чтобы использовать bindingContext.extension(),используйте bindingContext.createChildContext(someData).Это вернет новый контекст привязки,Viewmodel которого является someData и $parentContext является bindingContext.При желании вы можете расширить дочерний контекст дополнительными свойствами,используя ko.utils.extension.Например,</target>
        </trans-unit>
        <trans-unit id="87af9ca294d83f6fba572d78050da057a49b8c89" translate="yes" xml:space="preserve">
          <source>If you want to ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender in addition to rateLimit:</source>
          <target state="translated">Если вы хотите,чтобы абоненты всегда уведомлялись об обновлении,даже если его значение одинаково,вы используете расширитель уведомлений в дополнение к rateLimit:</target>
        </trans-unit>
        <trans-unit id="44cdfd3b6064088d2c5aa5fc20d93a5155c03685" translate="yes" xml:space="preserve">
          <source>If you want to handle a part of the mapping yourself, you can also provide a create callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</source>
          <target state="translated">Если вы хотите самостоятельно обработать часть карты,вы также можете обеспечить обратный вызов для создания карты.Если этот обратный вызов присутствует,плагин отображения позволит вам сделать эту часть отображения самостоятельно.</target>
        </trans-unit>
        <trans-unit id="72b1f64bd3585abcdb719c6af16ba28b06cb4a0c" translate="yes" xml:space="preserve">
          <source>If you want to have different custom element tag names, you can override getComponentNameForNode to control this. For example,</source>
          <target state="translated">Если вы хотите иметь различные имена тегов пользовательских элементов,вы можете переопределить getComponentNameForNode для управления этим.Например,</target>
        </trans-unit>
        <trans-unit id="f48f247482677e3d298eb9f8794c7720f2d28823" translate="yes" xml:space="preserve">
          <source>If you want to map the children array yourself, you can specify that like this:</source>
          <target state="translated">Если вы хотите самостоятельно составить карту дочернего массива,вы можете указать это следующим образом:</target>
        </trans-unit>
        <trans-unit id="1351e5f77b9081488d46eb8f548df93a34b7ae41" translate="yes" xml:space="preserve">
          <source>If you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:</source>
          <target state="translated">Если вы хотите запустить любую логику установки на связанном элементе до того,как он будет привязан к Viewmodel,или использовать произвольную логику,чтобы решить,какой класс viewmodel должен инстанцироваться:</target>
        </trans-unit>
        <trans-unit id="c66df88a215f6f7b24bd3deee59aec7e6d2e2f59" translate="yes" xml:space="preserve">
          <source>If you want to use dynamic CSS class names, then you can pass a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, then the binding will remove any previously added classes and add the class or classes corresponding to the observable&amp;rsquo;s new value.</source>
          <target state="translated">Если вы хотите использовать имена динамических классов CSS, вы можете передать строку, соответствующую классу или классам CSS, которые вы хотите добавить к элементу. Если параметр ссылается на наблюдаемое значение, то привязка удалит все ранее добавленные классы и добавит класс или классы, соответствующие новому значению наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="6d39bf93c568ed46321d7833a330f6569b221b30" translate="yes" xml:space="preserve">
          <source>If you want your custom loader to take precedence over the default loader (so it gets the first opportunity to supply configuration/values), then add it to the &lt;em&gt;beginning&lt;/em&gt; of the array. If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the &lt;em&gt;end&lt;/em&gt; of the array.</source>
          <target state="translated">Если вы хотите, чтобы ваш пользовательский загрузчик имел приоритет над загрузчиком по умолчанию (чтобы он получил первую возможность предоставить конфигурацию / значения), добавьте его в &lt;em&gt;начало&lt;/em&gt; массива. Если вы хотите, чтобы загрузчик по умолчанию имел приоритет (так что ваш пользовательский загрузчик вызывается только для компонентов, не зарегистрированных явно), добавьте его в &lt;em&gt;конец&lt;/em&gt; массива.</target>
        </trans-unit>
        <trans-unit id="5ceafe6c0f244a6b62bf46e8591b041a309c0459" translate="yes" xml:space="preserve">
          <source>If you want your observable array &lt;strong&gt;not&lt;/strong&gt; to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</source>
          <target state="translated">Если вы хотите, чтобы ваш наблюдаемый массив &lt;strong&gt;не&lt;/strong&gt; начинался пустым, а содержал некоторые начальные элементы, передайте эти элементы как массив конструктору. Например,</target>
        </trans-unit>
        <trans-unit id="e61100d48bd38e328d61f92193723be823f648bd" translate="yes" xml:space="preserve">
          <source>If you wanted, you could use $data as a prefix when referencing properties on each entry. For example, you could rewrite part of &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; as follows:</source>
          <target state="translated">Если хотите, вы можете использовать $ data в качестве префикса при ссылке на свойства каждой записи. Например, вы можете переписать часть &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;примера 1&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="1d0c200b210145556f08539e16369c8ae1101651" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to be able to bind expressions to click events (rather than a function reference as Knockout expects), you can set up a preprocessor for the click handler to support this syntax:</source>
          <target state="translated">Если вы хотите иметь возможность связывать выражения с событиями щелчка (а не ссылкой на функцию, как ожидает Knockout), вы можете настроить препроцессор для обработчика щелчков для поддержки этого синтаксиса:</target>
        </trans-unit>
        <trans-unit id="907374589d9e730eb5f8d2c95837b3f35a14d2f1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to migrate code from using the deprecated throttle extender, you should note the following ways that the rateLimit extender is different from the throttle extender.</source>
          <target state="translated">Если вы хотите перенести код с устаревшего расширителя дроссельной заслонки, вы должны отметить следующие отличия расширителя rateLimit от расширителя дроссельной заслонки.</target>
        </trans-unit>
        <trans-unit id="82cf070f85ee99e13abeb8d98714402eb45540b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have a DocumentFragment object, you can use it as a component template:</source>
          <target state="translated">Если вы создаете конфигурации программно и у вас есть объект DocumentFragment, вы можете использовать его как шаблон компонента:</target>
        </trans-unit>
        <trans-unit id="362388121008c8da14509414fa3107e12b516595" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:</source>
          <target state="translated">Если вы создаете конфигурации программно и у вас есть массив узлов DOM, вы можете использовать их как шаблон компонента:</target>
        </trans-unit>
        <trans-unit id="e5fbe4f70abc50527b7288b53aa01cad2d4a9fe8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re inside a nested &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, for example if you&amp;rsquo;re inside a foreach or a with block, but your handler function is on the root viewmodel or some other parent context, you&amp;rsquo;ll need to use a prefix such as $parent or $root to locate the handler function.</source>
          <target state="translated">Если вы находитесь внутри вложенного &lt;a href=&quot;binding-context&quot;&gt;контекста привязки&lt;/a&gt; , например, если вы внутри блока foreach или with, но ваша функция-обработчик находится в корневой модели представления или каком-либо другом родительском контексте, вам необходимо использовать префикс, например $ parent или $ root, чтобы найти функцию-обработчик.</target>
        </trans-unit>
        <trans-unit id="b30aa6dd1b7b726ed22a1386408193b3ed07cc63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not a fan of the &amp;lt;%= ... %&amp;gt; delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.</source>
          <target state="translated">Если вы не являетесь поклонником разделителей &amp;lt;% = ...%&amp;gt;, вы можете настроить механизм шаблонов Underscore для использования любых других символов разделителей по вашему выбору.</target>
        </trans-unit>
        <trans-unit id="128a03e2b47df3a4720a787432ce69b6c26af34a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $component refers to the viewmodel for that component. It&amp;rsquo;s the component-specific equivalent to $root. In the case of nested components, $component refers to the viewmodel for the closest component.</source>
          <target state="translated">Если вы находитесь в контексте определенного шаблона &lt;a href=&quot;component-overview&quot;&gt;компонента&lt;/a&gt; , то $ component относится к модели представления для этого компонента. Это компонентный эквивалент $ root. В случае вложенных компонентов $ component относится к модели просмотра ближайшего компонента.</target>
        </trans-unit>
        <trans-unit id="8207088fe6ea022be6846a6dde93cdfdbb4659e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $componentTemplateNodes is an array containing any DOM nodes that were passed to that component. This makes it easy to build components that receive templates, for example a grid component that accepts a template to define its output rows. For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="translated">Если вы находитесь в контексте определенного шаблона &lt;a href=&quot;component-overview&quot;&gt;компонента&lt;/a&gt; , то $ componentTemplateNodes представляет собой массив, содержащий любые узлы DOM, которые были переданы этому компоненту. Это упрощает создание компонентов, которые получают шаблоны, например компонент сетки, который принимает шаблон для определения своих выходных строк. Полный пример см. В разделе &amp;laquo; &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;Передача разметки в компоненты&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50cd6a8b962993f971b8353a9f4567faa0ee548a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working with AMD, then you might prefer a structure like this:</source>
          <target state="translated">Если вы работаете с AMD, вы можете предпочесть такую ​​структуру:</target>
        </trans-unit>
        <trans-unit id="3d7b9ced2efd23f656198e4a25fb4db243307f5a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve loaded some data from the server and want to use it to update your view model, the most straightforward way is to do it yourself. For example,</source>
          <target state="translated">Если вы загрузили некоторые данные с сервера и хотите использовать их для обновления своей модели представления, самый простой способ - сделать это самостоятельно. Например,</target>
        </trans-unit>
        <trans-unit id="bf20ec3aaef79dcc3c3e98b605cfa93d5c521bb6" translate="yes" xml:space="preserve">
          <source>If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function ko.mapping.fromJSON to create and update your view model instead. To unmap, you can use ko.mapping.toJSON.</source>
          <target state="translated">Если ваш вызов Ajax возвращает JSON строку (и не десериализует ее в объект JavaScript),то вы можете использовать функцию ko.mapping.fromJSON для создания и обновления вашей модели представления вместо нее.Для распаковки вы можете использовать ko.mapping.toJSON.</target>
        </trans-unit>
        <trans-unit id="b44f19840a62453340adc3a1ccb826f912401798" translate="yes" xml:space="preserve">
          <source>If your binding also includes a parameter called valueUpdate, this defines additional browser events KO should use to detect changes besides the change event. The following string values are the most commonly useful choices:</source>
          <target state="translated">Если ваша привязка также включает в себя параметр,называемый valueUpdate,это определяет дополнительные события браузера,которые KO должен использовать для обнаружения изменений помимо события изменения.Следующие строковые значения являются наиболее часто используемыми:</target>
        </trans-unit>
        <trans-unit id="d155bf9b29c1f0a2a9418e2feadc2ccfa15452dc" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically.</source>
          <target state="translated">Если ваша привязка также включает checkedValue, это определяет значение, используемое привязкой checked вместо атрибута value элемента. Это полезно, если вы хотите, чтобы значение было чем-то отличным от строки (например, целым числом или объектом), или если вы хотите, чтобы значение устанавливалось динамически.</target>
        </trans-unit>
        <trans-unit id="b3ab84e69e9a2c18e82003929561e37ee4fbb1d3" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically. For normally boolean checkboxes, this value is used instead of true to represent the &lt;em&gt;checked&lt;/em&gt; state, with undefined used for the &lt;em&gt;unchecked&lt;/em&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d14bdc74a8da6a89453d8ef51d2e2cc6ebf79fa" translate="yes" xml:space="preserve">
          <source>If your binding uses a preprocess function but should still have undefined as a default value, the function should return the string &quot;undefined&quot; rather than an undefined value. Returning undefined will remove the binding instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588138852c7a0d26f567881e0157a12d1880b4b0" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes bound to an array, it will remove the previous value from the array and add the new value. Otherwise, it will just update the model value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10fa5bcf76b5721cd82848b0bb414540b34d62f" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes, it will remove the old value from the array and add the new value. For radio buttons, it will just update the model value.</source>
          <target state="translated">Если ваш checkValue параметр является наблюдаемым значением,то всякий раз,когда значение изменяется и элемент проверяется в данный момент,привязка будет обновлять свойство проверяемой модели.Для флажков,он удалит старое значение из массива и добавит новое.Для радиокнопок-просто обновит значение модели.</target>
        </trans-unit>
        <trans-unit id="1dbc2f2301ffac98a49b2e6297ccb2fb1e2c8d49" translate="yes" xml:space="preserve">
          <source>If your component configuration has a boolean synchronous property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is false (i.e., forced to be asynchronous). For example,</source>
          <target state="translated">Если конфигурация вашего компонента имеет свойство булевой синхронизации,Knockout использует это свойство для определения того,разрешена ли загрузка и инжекция компонента синхронно.По умолчанию используется false (т.е.принудительная асинхронная загрузка).Например,</target>
        </trans-unit>
        <trans-unit id="b9854050320055febc419828d11cb1650e59a3b0" translate="yes" xml:space="preserve">
          <source>If your computed observable simply calculates and returns a value based on some observable dependencies, then it&amp;rsquo;s better to declare it as a ko.pureComputed instead of a ko.computed. For example:</source>
          <target state="translated">Если ваш вычисляемый наблюдаемый просто вычисляет и возвращает значение, основанное на некоторых наблюдаемых зависимостях, то лучше объявить его как ko.pureComputed вместо ko.computed. Например:</target>
        </trans-unit>
        <trans-unit id="f07feff737da55640367588cd5b8867853add3d9" translate="yes" xml:space="preserve">
          <source>If your custom loader implements loadTemplate and/or loadViewModel, then you can plug in custom code to the loading process. You can also use these functions to interpret custom configuration formats.</source>
          <target state="translated">Если Ваш пользовательский загрузчик реализует loadTemplate и/или loadViewModel,то Вы можете подключить пользовательский код к процессу загрузки.Вы также можете использовать эти функции для интерпретации пользовательских форматов конфигурации.</target>
        </trans-unit>
        <trans-unit id="f9e85383888aee26e47a33473edbdb8e84955e5a" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="translated">Если ваше выражение включает какие-либо наблюдаемые значения, выражение будет повторно оцениваться при каждом изменении любого из них. Соответственно, разметка в вашем блоке if может быть добавлена ​​или удалена динамически в результате изменения выражения. Атрибуты привязки данных будут применяться к &lt;strong&gt;новой копии содержащейся разметки&lt;/strong&gt; всякий раз, когда она будет добавлена ​​повторно.</target>
        </trans-unit>
        <trans-unit id="8e661a6c7ed635e0bf691bba88868184d5c21e24" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if or ifnot block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226676b80f71bd0aee4405b7dbac5960cfd4e3e7" translate="yes" xml:space="preserve">
          <source>If your function accepts a second parameter, then it will receive the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. You can then access $parent or any other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:</source>
          <target state="translated">Если ваша функция принимает второй параметр, она получит весь &lt;a href=&quot;binding-context&quot;&gt;контекст привязки&lt;/a&gt; . Затем вы можете получить доступ к $ parent или любой другой переменной &lt;a href=&quot;binding-context&quot;&gt;контекста привязки&lt;/a&gt; при динамическом выборе шаблона. Например, вы можете изменить предыдущий фрагмент кода следующим образом:</target>
        </trans-unit>
        <trans-unit id="9b4eec9f8db27a16ed532421672ba7179cce19f2" translate="yes" xml:space="preserve">
          <source>If your function references observable values, then the binding will update whenever any of those values change. This will cause the data to be re-rendered using the appropriate template.</source>
          <target state="translated">Если ваша функция ссылается на наблюдаемые значения,то привязка будет обновляться всякий раз,когда какое-либо из этих значений изменится.Это приведет к переотправке данных по соответствующему шаблону.</target>
        </trans-unit>
        <trans-unit id="6374db41fb1a34f6794e3a7a263b2a5d8f3d6ae6" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable array, the binding will update the element&amp;rsquo;s selection whenever the array changes (e.g., via push, pop or &lt;a href=&quot;observablearrays&quot;&gt;other observable array methods&lt;/a&gt;). If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s selection state once and will not update it again later.</source>
          <target state="translated">Если ваш параметр является наблюдаемым массивом, привязка будет обновлять выбор элемента при каждом изменении массива (например, с помощью push, pop или &lt;a href=&quot;observablearrays&quot;&gt;других методов наблюдаемого массива&lt;/a&gt; ). Если параметр не является наблюдаемым, он только один раз установит состояние выбора элемента и не будет обновлять его позже.</target>
        </trans-unit>
        <trans-unit id="4ddb383dfae6006d12773bd8bc5511d587b2ccb9" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable value, the binding will update the element&amp;rsquo;s checked state whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s checked state once and will not update it again later.</source>
          <target state="translated">Если ваш параметр является наблюдаемым значением, привязка будет обновлять отмеченное состояние элемента всякий раз, когда значение изменяется. Если параметр не является наблюдаемым, он только один раз установит проверяемое состояние элемента и не будет обновлять его позже.</target>
        </trans-unit>
        <trans-unit id="1fff36bdc6055d9bb8992e0fdfb26a189710fb02" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later.</source>
          <target state="translated">Если ваш параметр ссылается на наблюдаемое значение, привязка будет добавлять или удалять класс CSS всякий раз, когда наблюдаемое значение изменяется. Если параметр не ссылается на наблюдаемое значение, он добавит или удалит класс только один раз и больше не будет делать этого позже.</target>
        </trans-unit>
        <trans-unit id="aa6f113eec157fdb2ab367ee2fd9cbd80ddb0996" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the attribute whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the attribute once and will not update it later.</source>
          <target state="translated">Если ваш параметр ссылается на наблюдаемое значение, привязка будет обновлять атрибут при изменении наблюдаемого значения. Если параметр не ссылается на наблюдаемое значение, он установит атрибут только один раз и не будет обновлять его позже.</target>
        </trans-unit>
        <trans-unit id="633f858df401ebd55c78f8496da63fdb61af5458" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the enabled/disabled state whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the state once and will not do so again later.</source>
          <target state="translated">Если ваш параметр ссылается на наблюдаемое значение, привязка будет обновлять включенное / выключенное состояние всякий раз, когда наблюдаемое значение изменяется. Если параметр не ссылается на наблюдаемое значение, он установит состояние только один раз и больше не будет делать это позже.</target>
        </trans-unit>
        <trans-unit id="6d3819bd4ed3fd60e94476b444ece0ada882cf49" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the styles whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the styles once and will not update them later.</source>
          <target state="translated">Если ваш параметр ссылается на наблюдаемое значение, привязка будет обновлять стили при каждом изменении наблюдаемого значения. Если параметр не ссылается на наблюдаемое значение, он установит стили только один раз и не будет обновлять их позже.</target>
        </trans-unit>
        <trans-unit id="d9c0408c9bf4c4a37030fc7cdecf2361bd78f581" translate="yes" xml:space="preserve">
          <source>If your parameter&amp;rsquo;s value is an array of strings, you don&amp;rsquo;t need to give any other parameters. The &amp;lt;select&amp;gt; element will display an option for each string value. However, if you want to let the user choose from an array of &lt;em&gt;arbitrary JavaScript objects&lt;/em&gt; (not merely strings), then see the optionsText and optionsValue parameters below.</source>
          <target state="translated">Если значение вашего параметра представляет собой массив строк, вам не нужно указывать другие параметры. Элемент &amp;lt;select&amp;gt; отобразит параметр для каждого строкового значения. Однако, если вы хотите позволить пользователю выбирать из массива &lt;em&gt;произвольных объектов JavaScript&lt;/em&gt; (а не только строк), см. Параметры optionsText и optionsValue ниже.</target>
        </trans-unit>
        <trans-unit id="a69077a26824bf6bf1d9998d4bf4a08fe6a1767d" translate="yes" xml:space="preserve">
          <source>If, like in the example above, you are performing the mapping inside of a class, you would like to have this as the target of your mapping operation. The third parameter to ko.mapping.fromJS indicates the target. For example,</source>
          <target state="translated">Если,как в примере выше,вы выполняете отображение внутри класса,вы хотите,чтобы это было целью вашей операции отображения.Третий параметр ko.mapping.fromJS указывает на цель.Например,</target>
        </trans-unit>
        <trans-unit id="9ee772074f2af1d7a8aaad138b9ed8cf1f46dbbc" translate="yes" xml:space="preserve">
          <source>Ignoring certain properties using &amp;ldquo;ignore&amp;rdquo;</source>
          <target state="translated">Игнорирование определенных свойств с помощью &amp;laquo;игнорировать&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="862cab77807ae3aed03ab6e5350848a0245d7862" translate="yes" xml:space="preserve">
          <source>Ignoring dependencies within a computed</source>
          <target state="translated">Игнорирование зависимостей внутри вычисленного</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="e98d0b401da7a27f72e4030036db78a4058a43b6" translate="yes" xml:space="preserve">
          <source>Implementing a custom component loader</source>
          <target state="translated">Внедрение пользовательского загрузчика компонентов</target>
        </trans-unit>
        <trans-unit id="9e1f2cc17fbee96463fbddbcea3b554850c3baa9" translate="yes" xml:space="preserve">
          <source>In a binding&amp;rsquo;s init function, using a computed observable to update the bound element.</source>
          <target state="translated">В функции инициализации привязки использование вычисляемого наблюдаемого для обновления связанного элемента.</target>
        </trans-unit>
        <trans-unit id="a6abb210083356c831fde074a2c122126ad2030b" translate="yes" xml:space="preserve">
          <source>In a typical Knockout application, DOM elements are dynamically added and removed, for example using the &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; binding or via control-flow bindings (&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;ifnot-binding&quot;&gt;ifnot&lt;/a&gt;, &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;, and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.</source>
          <target state="translated">В типичном применении Knockout, динамически добавляются DOM элементы и удалены, например , с помощью &lt;a href=&quot;template-binding&quot;&gt;шаблона&lt;/a&gt; связывания или с помощью привязок управления потоком ( &lt;a href=&quot;if-binding&quot;&gt;если&lt;/a&gt; , &lt;a href=&quot;ifnot-binding&quot;&gt;IFNOT&lt;/a&gt; , &lt;a href=&quot;with-binding&quot;&gt;с&lt;/a&gt; , и &lt;a href=&quot;foreach-binding&quot;&gt;Еогеасп&lt;/a&gt; ). При создании настраиваемой привязки часто желательно добавить логику очистки, которая запускается, когда элемент, связанный с вашей настраиваемой привязкой, удаляется с помощью Knockout.</target>
        </trans-unit>
        <trans-unit id="141b57414e301727c0b0d54cb5649b30de0602c3" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re wondering what the parameters to ko.applyBindings do,</source>
          <target state="translated">Если вам интересно, что делают параметры ko.applyBindings,</target>
        </trans-unit>
        <trans-unit id="934ed4b9942e197c4b326248bae145be6b363266" translate="yes" xml:space="preserve">
          <source>In complex applications, with multiple, intertwined dependencies, updating a single &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; might trigger a cascade of &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;, manual subscriptions, and UI binding updates. These updates can be expensive and inefficient if unnecessary intermediate values are pushed to the view or result in extra computed observable evaluations. Even in a simple application, updating related observables or a single observable multiple times (such as filling an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;) can have a similar effect.</source>
          <target state="translated">В сложных приложениях с множеством взаимосвязанных зависимостей обновление одного &lt;a href=&quot;observables&quot;&gt;наблюдаемого&lt;/a&gt; может вызвать каскад &lt;a href=&quot;computedobservables&quot;&gt;вычисляемых наблюдаемых&lt;/a&gt; , подписок вручную и обновлений привязки пользовательского интерфейса. Эти обновления могут быть дорогостоящими и неэффективными, если ненужные промежуточные значения помещаются в представление или приводят к дополнительным вычисленным наблюдаемым оценкам. Даже в простом приложении обновление связанных наблюдаемых объектов или одного наблюдаемого несколько раз (например, заполнение &lt;a href=&quot;observablearrays&quot;&gt;наблюдаемого массива&lt;/a&gt; ) может иметь аналогичный эффект.</target>
        </trans-unit>
        <trans-unit id="298a4f1f3d69231f90369b88842f87a3f201c02d" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the observable was simply passed without evaluating it), then the value is passed literally.</source>
          <target state="translated">В общем, если оценка параметра не включает оценку наблюдаемого (в этом случае наблюдаемое было просто передано без его оценки), то значение передается буквально.</target>
        </trans-unit>
        <trans-unit id="9fea9cada35fecd5a76c1bf34c364291fb1dfeb5" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the value did not involve observables at all), then the value is passed literally. If the value was an object, then the child component could mutate it, but since it&amp;rsquo;s not observable the parent would not know the child had done so.</source>
          <target state="translated">В общем, если оценка параметра не включает оценку наблюдаемого (в этом случае значение вообще не включает наблюдаемые), то значение передается буквально. Если бы значение было объектом, то дочерний компонент мог бы его видоизменить, но, поскольку это не наблюдается, родитель не узнает, что это сделал дочерний элемент.</target>
        </trans-unit>
        <trans-unit id="9408b29fab575c1d6a718e0d164b10b2342550d4" translate="yes" xml:space="preserve">
          <source>In general, with custom elements, if a parameter&amp;rsquo;s evaluation involves evaluating an observable, then Knockout automatically constructs a ko.computed value to give the expression&amp;rsquo;s result, and supplies that to the component.</source>
          <target state="translated">В общем, с настраиваемыми элементами, если оценка параметра включает оценку наблюдаемого, Knockout автоматически создает вычисленное значение ko.com, чтобы дать результат выражения, и передает его компоненту.</target>
        </trans-unit>
        <trans-unit id="dada114537b3d8ec4d940c1f848a0b4d17e427dd" translate="yes" xml:space="preserve">
          <source>In many scenarios, this direct approach is the simplest and most flexible solution. Of course, as you update the properties on your view model, Knockout will take care of updating the visible UI to match it.</source>
          <target state="translated">Во многих сценариях такой прямой подход является самым простым и гибким решением.Конечно,по мере обновления свойств модели представления,Knockout позаботится об обновлении видимого пользовательского интерфейса в соответствии с ним.</target>
        </trans-unit>
        <trans-unit id="1336d55dbbe8a14101718dce289bfc08355c43e3" translate="yes" xml:space="preserve">
          <source>In most applications, you&amp;rsquo;ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</source>
          <target state="translated">В большинстве приложений вы захотите сохранить модели представления компонентов и шаблоны во внешних файлах. Если вы сконфигурируете Knockout для их загрузки через загрузчик модулей AMD, например &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; , они могут быть либо предварительно загружены (возможно, объединены / уменьшены), либо загружены по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="9393d5a40d776a6854af0f2c50bfec273ef93bff" translate="yes" xml:space="preserve">
          <source>In most cases, data-bind attributes provide a clean and succinct way to bind to a view model. However, event handling is one area that can often result in verbose data-bind attributes, as anonymous functions were typically the recommended techinique to pass arguments. For example:</source>
          <target state="translated">В большинстве случаев атрибуты привязки данных обеспечивают чистый и лаконичный способ привязки к модели представления.Однако,обработка событий-это одна из областей,которая часто может приводить к многословным атрибутам привязки данных,так как анонимные функции,как правило,были рекомендуемой технологией для передачи аргументов.Например:</target>
        </trans-unit>
        <trans-unit id="e51abc57c35dadaabfdce19179eb0debbebbeaf7" translate="yes" xml:space="preserve">
          <source>In older browsers (ie8 and below) using reserved javascript words as attribute names causes an error. You can get around this by quoting them like this:</source>
          <target state="translated">В старых браузерах (ie8 и ниже)использование зарезервированных слов javascript в качестве имен атрибутов приводит к ошибке.Вы можете обойти это,процитировав их так:</target>
        </trans-unit>
        <trans-unit id="78c97a2a9b619f6af8e28ca3d1b212c9106b36d9" translate="yes" xml:space="preserve">
          <source>In some cases, you might want to duplicate a section of markup, but you don&amp;rsquo;t have any container element on which to put a foreach binding. For example, you might want to generate the following:</source>
          <target state="translated">В некоторых случаях вам может потребоваться продублировать раздел разметки, но у вас нет элемента контейнера, на который можно было бы поместить привязку foreach. Например, вы можете захотеть создать следующее:</target>
        </trans-unit>
        <trans-unit id="24cb80dcb3e226fb881227f4a0ccddef514b98a4" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, ko.isComputed to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</source>
          <target state="translated">В некоторых сценариях полезно программно определить,имеете ли вы дело с вычисленным наблюдаемым.Knockout предоставляет утилитную функцию ko.isComputed,которая помогает справиться с этой ситуацией.Например,вы можете захотеть исключить вычисленные наблюдаемые объекты из данных,которые вы отправляете обратно на сервер.</target>
        </trans-unit>
        <trans-unit id="6e3b5296e5cf5300764dcbb83ced0ab56bb3f938" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a pure computed observable. Knockout provides a utility function, ko.isPureComputed to help with this situation. For example, you might want to exclude non-pure computed observables from data that you are sending back to the server.</source>
          <target state="translated">В некоторых сценариях полезно программно определить,имеете ли вы дело с чисто вычисленным наблюдаемым.Knockout предоставляет утилитную функцию ko.isPureComputed для помощи в этой ситуации.Например,вы можете захотеть исключить нечистые вычисленные наблюдаемые данные из данных,которые вы отправляете обратно на сервер.</target>
        </trans-unit>
        <trans-unit id="f78cb94e8b3d800b2ea0fcaad4990a5f1a56de28" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with an observableArray. Knockout provides a utility function, ko.isObservableArray to help with this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b0b573c69ea5aac246a77f09332e0af893398" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your click event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">В некоторых сценариях вам может понадобиться доступ к объекту DOM event,связанному с событием щелчка мышью.Нокаут передаст событие в качестве второго параметра в вашу функцию,как в данном примере:</target>
        </trans-unit>
        <trans-unit id="89a035bdd8bde1fc808e15cc5a03eb180ed46c10" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">В некоторых сценариях вам может понадобиться доступ к объекту DOM событий,связанному с вашим событием.Нокаут передаст событие в качестве второго параметра в вашу функцию,как в данном примере:</target>
        </trans-unit>
        <trans-unit id="8a7c3e36457e6b3964cbe1d0bb7c4a44fc9b6097" translate="yes" xml:space="preserve">
          <source>In summary, the general rule is:</source>
          <target state="translated">Таким образом,общее правило таково:</target>
        </trans-unit>
        <trans-unit id="7abd619b7fce5ea9d7c5cd5e72650986e1b05fc5" translate="yes" xml:space="preserve">
          <source>In the above example, selectedCountry will retain the value 'Latvia', and the dropdown will be blank, because there is no corresponding option.</source>
          <target state="translated">В вышеприведенном примере выбранная страна сохранит значение &quot;Латвия&quot;,а выпадающее значение будет пустым,так как нет соответствующей опции.</target>
        </trans-unit>
        <trans-unit id="a079557bbe2fc66148c2ddbfa0077e907128f7e8" translate="yes" xml:space="preserve">
          <source>In the example below, a computed observable is used to reload an observable named currentPageData using Ajax with data from two other observable properties. The computed observable will update whenever pageIndex changes, but it ignores changes to selectedItem because it is accessed using peek. In this case, the user might want to use the current value of selectedItem only for tracking purposes when a new set of data is loaded.</source>
          <target state="translated">В примере ниже,вычисленная наблюдаемая используется для перезагрузки наблюдаемой по имени currentPageData с помощью Ajax с данными из двух других наблюдаемых свойств.Вычисленная наблюдаемая будет обновляться всякий раз,когда изменяется pageIndex,но игнорирует изменения в selectItem,так как доступ к ней осуществляется с помощью peek.В этом случае,пользователь может захотеть использовать текущее значение selectedItem только для отслеживания при загрузке нового набора данных.</target>
        </trans-unit>
        <trans-unit id="257966647233e2e113fd6e59387bdb2e8ee4f13b" translate="yes" xml:space="preserve">
          <source>In the example code above, the user can choose from an array of string values. You&amp;rsquo;re &lt;em&gt;not&lt;/em&gt; limited to providing strings - your options array can contain arbitrary JavaScript objects if you wish. See &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; for details on how to control how arbitrary objects should be displayed in the list.</source>
          <target state="translated">В приведенном выше примере кода пользователь может выбирать из массива строковых значений. Вы &lt;em&gt;не&lt;/em&gt; ограничены предоставлением строк - ваш массив параметров может содержать произвольные объекты JavaScript, если хотите. См. &lt;a href=&quot;options-binding&quot;&gt;Привязку параметров&lt;/a&gt; для получения подробной информации о том, как управлять отображением произвольных объектов в списке.</target>
        </trans-unit>
        <trans-unit id="7f1eec557c11682dd0041b7ee985e305de5b96b1" translate="yes" xml:space="preserve">
          <source>In the following example of a simple wizard interface, the fullName &lt;em&gt;pure&lt;/em&gt; computed is only bound to the view during the final step and so is only updated when that step is active.</source>
          <target state="translated">В следующем примере простого интерфейса мастера вычисление fullName &lt;em&gt;pure&lt;/em&gt; привязывается к представлению только на последнем шаге и поэтому обновляется только тогда, когда этот шаг активен.</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">В следующем примере,</target>
        </trans-unit>
        <trans-unit id="e6b59bdb65eb1fb7ea8933f16ea767b69ee4a3eb" translate="yes" xml:space="preserve">
          <source>In the following example, the &amp;lt;div&amp;gt; element will be empty for &amp;ldquo;Mercury&amp;rdquo;, but populated for &amp;ldquo;Earth&amp;rdquo;. That&amp;rsquo;s because Earth has a non-null capital property, whereas &amp;ldquo;Mercury&amp;rdquo; has null for that property.</source>
          <target state="translated">В следующем примере элемент &amp;lt;div&amp;gt; будет пустым для &amp;laquo;Меркурия&amp;raquo;, но заполненным для &amp;laquo;Земли&amp;raquo;. Это потому, что у Земли есть свойство капитала, отличное от нуля, тогда как у Меркурия это свойство имеет значение null.</target>
        </trans-unit>
        <trans-unit id="ea4ef6f441e7c614e804c04b6a2e41d53a3f525d" translate="yes" xml:space="preserve">
          <source>In the following example, the item objects themselves (not their itemName strings) will be included in the chosenItems array when their corresponding checkboxes are checked:</source>
          <target state="translated">В следующем примере сами объекты элементов (а не их строки itemName)будут включены в массив selectedItems при установке соответствующих флажков:</target>
        </trans-unit>
        <trans-unit id="fd533036ba8a852bee55ce9ff27ce0f5cbea1320" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want the automatic unwrapping, because you want to access the observable1/observable2 instances directly, you can read values from params.$raw. For example,</source>
          <target state="translated">В том маловероятном случае, если вам &lt;em&gt;не&lt;/em&gt; нужна автоматическая распаковка, потому что вы хотите напрямую обращаться к экземплярам observable1 / observable2, вы можете читать значения из params. $ Raw. Например,</target>
        </trans-unit>
        <trans-unit id="82f26ef92fcf3d919b5692d621d24247e24ffdf3" translate="yes" xml:space="preserve">
          <source>In the vast majority of cases, Knockout&amp;rsquo;s native templating and the foreach, if, with and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore template engine&lt;/a&gt; or &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt;, Knockout offers a way to do it.</source>
          <target state="translated">В подавляющем большинстве случаев встроенные шаблоны Knockout и foreach, if, with и другие привязки потока управления будут всем, что вам нужно для создания произвольно сложного пользовательского интерфейса. Но если вы хотите интегрироваться с внешней библиотекой шаблонов, такой как &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;механизм шаблонов Underscore&lt;/a&gt; или &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt; , Knockout предлагает способ сделать это.</target>
        </trans-unit>
        <trans-unit id="6089b197798e2998b901eb8dbbf1b20e0c170048" translate="yes" xml:space="preserve">
          <source>In this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.</source>
          <target state="translated">В этом случае все указанные узлы (и их потомки)будут клонированы и объединены в каждую копию компонента,который получает инстанцирование.</target>
        </trans-unit>
        <trans-unit id="a348c38b4b02b07c8665149add553a1e8b9d5d0e" translate="yes" xml:space="preserve">
          <source>In this case, both the required and logChange extenders would be executed against our observable.</source>
          <target state="translated">В этом случае,как требуемый,так и logChange удлинители будут выполнены против наших наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="a699872accd4a004c8e32410cc63d8c1833fccde" translate="yes" xml:space="preserve">
          <source>In this case, the object to which the component&amp;rsquo;s view is bound is the params object that you passed to the component binding. Example:</source>
          <target state="translated">В этом случае объект, к которому привязано представление компонента, является объектом params, который вы передали привязке компонента. Пример:</target>
        </trans-unit>
        <trans-unit id="c17fd19412152ec3913a0a1d358a54a8292c9681" translate="yes" xml:space="preserve">
          <source>In this case, you can&amp;rsquo;t put if on the &amp;lt;ul&amp;gt; (because then it would affect the first &amp;lt;li&amp;gt; too), and you can&amp;rsquo;t put any other container around the second &amp;lt;li&amp;gt; (because HTML doesn&amp;rsquo;t allow extra containers within &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">В этом случае вы не можете поместить if в &amp;lt;ul&amp;gt; (потому что тогда это повлияет и на первый &amp;lt;li&amp;gt;), и вы не можете поместить какой-либо другой контейнер вокруг второго &amp;lt;li&amp;gt; (потому что HTML не разрешить дополнительные контейнеры в пределах &amp;lt;ul&amp;gt; s).</target>
        </trans-unit>
        <trans-unit id="4bd55725b74476a658ad8c3ddffc52240205843b" translate="yes" xml:space="preserve">
          <source>In this example, the &amp;ldquo;Your cellphone number&amp;rdquo; text box will initially be disabled. It will be enabled only when the user checks the box labelled &amp;ldquo;I have a cellphone&amp;rdquo;.</source>
          <target state="translated">В этом примере текстовое поле &amp;laquo;Ваш номер мобильного телефона&amp;raquo; изначально будет отключено. Он будет включен только тогда, когда пользователь установит флажок &amp;laquo;У меня есть мобильный телефон&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="23b1af26f17b9406ba47b28c79e10c531b381108" translate="yes" xml:space="preserve">
          <source>In this example, the component both displays and edits an observable property called userRating on the Product view model class.</source>
          <target state="translated">В данном примере компонент как отображает,так и редактирует наблюдаемое свойство,называемое userRating на классе модели вида продукта.</target>
        </trans-unit>
        <trans-unit id="b578fdc737cd1643dadd8aea539b4c2f16e439d0" translate="yes" xml:space="preserve">
          <source>In this example, the person-template markup is used twice: once for buyer, and once for seller. Notice that the template markup is wrapped in a &amp;lt;script type=&quot;text/html&quot;&amp;gt; &amp;mdash; the dummy type attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply bindings to that markup except when it is being used as a template.</source>
          <target state="translated">В этом примере разметка шаблона человека используется дважды: один раз для покупателя и один раз для продавца. Обратите внимание, что разметка шаблона заключена в &amp;lt;script type = &quot;text / html&quot;&amp;gt; - атрибут фиктивного типа необходим, чтобы гарантировать, что разметка не выполняется как JavaScript, и Knockout не пытается применить привязки к этой разметке, кроме случаев, когда он используется как шаблон.</target>
        </trans-unit>
        <trans-unit id="4923e8cd2117852530d9802d4bbf382ff3afc82c" translate="yes" xml:space="preserve">
          <source>In this example, there isn&amp;rsquo;t anywhere to put a normal foreach binding. You can&amp;rsquo;t put it on the &amp;lt;ul&amp;gt; (because then you&amp;rsquo;d be duplicating the header item), nor can you put a further container inside the &amp;lt;ul&amp;gt; (because only &amp;lt;li&amp;gt; elements are allowed inside &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">В этом примере нет места для обычной привязки foreach. Вы не можете поместить его в &amp;lt;ul&amp;gt; (потому что тогда вы будете дублировать элемент заголовка), а также не можете поместить дополнительный контейнер внутри &amp;lt;ul&amp;gt; (потому что внутри &amp;lt;ul&amp;gt; s разрешены только элементы &amp;lt;li&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="fb736901afba0868e604845ea5c5136b0ef06755" translate="yes" xml:space="preserve">
          <source>In this live example, there&amp;rsquo;s an instantaneousValue observable that reacts immediately when you press a key. This is then wrapped inside a delayedValue computed observable that&amp;rsquo;s configured to notify only when changes stop for at least 400 milliseconds, using the notifyWhenChangesStop rate-limit method.</source>
          <target state="translated">В этом живом примере есть наблюдаемое мгновенное значение, которое немедленно реагирует на нажатие клавиши. Затем это обертывается внутри вычисляемого наблюдаемого delayedValue, который настроен на уведомление только тогда, когда изменения останавливаются не менее чем на 400 миллисекунд, с использованием метода ограничения скорости notifyWhenChangesStop.</target>
        </trans-unit>
        <trans-unit id="697eb6430df1ff767ba12b86170aabf874197762" translate="yes" xml:space="preserve">
          <source>In this scenario, the values you can read and write using selectedOptions are those objects themselves, &lt;em&gt;not&lt;/em&gt; their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.</source>
          <target state="translated">В этом сценарии значения, которые вы можете читать и записывать с помощью selectedOptions, - это сами эти объекты, а &lt;em&gt;не&lt;/em&gt; их текстовые представления. В большинстве случаев это приводит к более чистому и элегантному коду. Ваша модель представления может представить, что пользователь выбирает из массива произвольных объектов, не заботясь о том, как эти объекты отображаются на экранное представление.</target>
        </trans-unit>
        <trans-unit id="899b5b3c843785e5bdf5e9462999644c6d640741" translate="yes" xml:space="preserve">
          <source>In your viewmodel, it&amp;rsquo;s often useful to declare self (or some other variable) as an alias for this. Doing so avoids any problems with this being redefined to mean something else in event handlers or Ajax request callbacks.</source>
          <target state="translated">В вашей модели просмотра часто бывает полезно объявить self (или другую переменную) в качестве псевдонима для этого. Это позволяет избежать каких-либо проблем с переопределением этого значения в обработчиках событий или обратных вызовах Ajax-запросов.</target>
        </trans-unit>
        <trans-unit id="01d3f9dd3adc47ab7ac1b64ead3455b5e2967b39" translate="yes" xml:space="preserve">
          <source>Include the module in the list of dependencies for your view model:</source>
          <target state="translated">Включите модуль в список зависимостей для вашей модели просмотра:</target>
        </trans-unit>
        <trans-unit id="a540fcc7f8debd81035e2aedabe7eca5ef988f87" translate="yes" xml:space="preserve">
          <source>Including certain properties using &amp;ldquo;include&amp;rdquo;</source>
          <target state="translated">Включение определенных свойств с помощью &quot;включить&quot;</target>
        </trans-unit>
        <trans-unit id="51f5cfb3bf91b525954d3382e4520457debfab20" translate="yes" xml:space="preserve">
          <source>Indicating that a control-flow binding &amp;ldquo;completes&amp;rdquo; asynchronously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cbb6e3feed90f14fa1eaeab9ddfc2be5402137" translate="yes" xml:space="preserve">
          <source>Inserts nodeToInsert as a child of the real or virtual element containerElem, positioned immediately after insertAfter (where insertAfter must be a child of containerElem).</source>
          <target state="translated">Вставляет nodeToInsert в качестве дочернего элемента реального или виртуального элемента containerElem,позиционируемого сразу после insertAfter (где insertAfter должен быть дочерним элементом containerElem).</target>
        </trans-unit>
        <trans-unit id="5226f3c318b899bef48bc2eb6b90732ff9e7c110" translate="yes" xml:space="preserve">
          <source>Inserts nodeToPrepend as the first child of the real or virtual element containerElem.</source>
          <target state="translated">Вставляет nodeToPrepend в качестве первого дочернего элемента реального или виртуального контейнера элементовElem.</target>
        </trans-unit>
        <trans-unit id="0c6bbabe746e549a40b0c4c9d91c41eb15b7c78a" translate="yes" xml:space="preserve">
          <source>Instead of using submit on the form, you &lt;em&gt;could&lt;/em&gt; use click on the submit button. However, submit has the advantage that it also captures alternative ways to submit the form, such as pressing the &lt;em&gt;enter&lt;/em&gt; key while typing into a text box.</source>
          <target state="translated">Вместо использования отправки в форме вы &lt;em&gt;можете&lt;/em&gt; использовать кнопку отправки. Однако у submit есть то преимущество, что он также фиксирует альтернативные способы отправки формы, такие как нажатие клавиши &lt;em&gt;ввода&lt;/em&gt; при вводе текста в текстовое поле.</target>
        </trans-unit>
        <trans-unit id="83dd21419fd3a38dcc7db394fe1758f026c592be" translate="yes" xml:space="preserve">
          <source>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it&amp;rsquo;s still possible to incur naming collisions in your architecture. There&amp;rsquo;s also no clean way to handle dependency management without some manual effort or third party tools.</source>
          <target state="translated">Вместо этого разработчикам в настоящее время остается прибегать к вариациям шаблонов литералов модуля или объекта. Во многих из них скрипты модулей объединены в DOM с пространством имен, описываемым одним глобальным объектом, где все еще возможно столкновение имен в вашей архитектуре. Также нет чистого способа управления зависимостями без некоторых ручных усилий или сторонних инструментов.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="0ed5597c3a7b69dedb6a6d299a96c9f0d4cdda78" translate="yes" xml:space="preserve">
          <source>Is KO intended to compete with jQuery (or Prototype, etc.) or work with it?</source>
          <target state="translated">Предназначен ли КО конкурировать с jQuery (или Прототипом и т.д.)или работать с ним?</target>
        </trans-unit>
        <trans-unit id="65da43a24216ab5b6b86fc60da5f46e3f4aeba18" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t strictly necessary to dispose computeds and subscriptions that only depend on properties of the same viewmodel object, since this creates only a circular reference which JavaScript garbage collectors know how to release. However, to avoid having to remember which things need disposal, you may prefer to use pureComputed wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not.</source>
          <target state="translated">Нет строгой необходимости удалять вычисленные значения и подписки, которые зависят только от свойств одного и того же объекта модели представления, поскольку при этом создается только циклическая ссылка, которую сборщики мусора JavaScript знают, как освободить. Однако, чтобы не вспоминать, какие вещи нуждаются в удалении, вы можете предпочесть использовать pureComputed везде, где это возможно, и явно удалить все другие вычисленные / подписки, независимо от того, необходимы они технически или нет.</target>
        </trans-unit>
        <trans-unit id="2c8d88dcd3513a54272253518c0497355ab086ef" translate="yes" xml:space="preserve">
          <source>It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</source>
          <target state="translated">Сначала он проверит,присутствует ли уже ключ,и бросит исключение,если оно присутствует.Затем он будет вызывать обратные вызовы создания и обновления,если таковые имеются,для создания нового объекта.Наконец,он добавит этот объект в массив и вернет его.</target>
        </trans-unit>
        <trans-unit id="d79526c06b498ef03e22fd6acf22e655f708bfbf" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually very simple and rather lovely. The tracking algorithm goes like this:</source>
          <target state="translated">На самом деле это очень просто и довольно мило. Алгоритм отслеживания выглядит так:</target>
        </trans-unit>
        <trans-unit id="878cb611fac9777800e6495d4a84b9db45ca03ab" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that the if binding really is vital to make this code work properly. Without it, there would be an error when trying to evaluate capital.cityName in the context of &amp;ldquo;Mercury&amp;rdquo; where capital is null. In JavaScript, you&amp;rsquo;re not allowed to evaluate subproperties of null or undefined values.</source>
          <target state="translated">Важно понимать, что привязка if действительно жизненно важна для правильной работы этого кода. Без него возникла бы ошибка при попытке оценить capital.cityName в контексте &amp;laquo;Меркурия&amp;raquo;, где капитал равен нулю. В JavaScript вам не разрешено оценивать подсвойства с нулевыми или неопределенными значениями.</target>
        </trans-unit>
        <trans-unit id="e3874fb9afc15bfa8481f8f5826ec25b83ba6641" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s much easier with KO. It lets you scale up in complexity without fear of introducing inconsistencies. Just represent your items as a JavaScript array, and then use a foreach binding to transform this array into a TABLE or set of DIVs. Whenever the array changes, the UI changes to match (you don&amp;rsquo;t have to figure out how to inject new TRs or where to inject them). The rest of the UI stays in sync. For example, you can declaratively bind a SPAN to display the number of items as follows:</source>
          <target state="translated">С нокаутом намного проще. Это позволяет увеличивать сложность, не опасаясь внесения несоответствий. Просто представьте свои элементы в виде массива JavaScript, а затем используйте привязку foreach для преобразования этого массива в ТАБЛИЦУ или набор DIV. Всякий раз, когда массив изменяется, пользовательский интерфейс изменяется, чтобы соответствовать (вам не нужно выяснять, как вводить новые TR или куда их вводить). Остальная часть пользовательского интерфейса остается синхронизированной. Например, вы можете декларативно привязать SPAN для отображения количества элементов следующим образом:</target>
        </trans-unit>
        <trans-unit id="006519a934952c4254be41efd04fdc8f35b9bbc1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not mandatory</source>
          <target state="translated">Это не обязательно</target>
        </trans-unit>
        <trans-unit id="0b7ff8fbd1e3390894e542bb222f79b8c9ed9a17" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not very often that you&amp;rsquo;ll need to use named templates, but on occasion it can help to minimise duplication of markup.</source>
          <target state="translated">Не очень часто вам нужно использовать именованные шаблоны, но иногда это может помочь минимизировать дублирование разметки.</target>
        </trans-unit>
        <trans-unit id="5f7ea21297f054ffd0625db94299b6ba1fe8aaa4" translate="yes" xml:space="preserve">
          <source>JSON data</source>
          <target state="translated">данные JSON</target>
        </trans-unit>
        <trans-unit id="c63fa2ce723842121580c849293751dfa2071897" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with and using without any container element to host it. This is useful if you need to use these bindings in a place where it would not be legal to introduce a new container element just to hold the binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56018c5b9bb46e0b7d9532486fd48da666983d" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings, you can use let without any container element to host it. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fcbc8242b1e3ebc93c1cfe4363423f333e167a" translate="yes" xml:space="preserve">
          <source>Just like other control flow elements such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with without any container element to host it. This is useful if you need to use with in a place where it would not be legal to introduce a new container element just to hold the with binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="translated">Как и другие элементы потока управления, такие как &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; и &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; , вы можете использовать with без какого-либо элемента контейнера для его размещения. Это полезно, если вам нужно использовать with в месте, где было бы незаконно вводить новый элемент контейнера только для удержания привязки with. См. Документацию для &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; или &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="f64bb981f55e85e97b341a43c767424d5619a17b" translate="yes" xml:space="preserve">
          <source>Just like the built-in bindings &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, custom bindings can change the binding context for their descendant elements, or provide special properties by extending the binding context object. This is described in detail under &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;creating custom bindings that control descendant bindings&lt;/a&gt;.</source>
          <target state="translated">Как и встроенные привязки &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; и &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; , настраиваемые привязки могут изменять контекст привязки для своих дочерних элементов или предоставлять специальные свойства путем расширения объекта контекста привязки. Это подробно описано в разделе &amp;laquo; &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;Создание пользовательских привязок, управляющих привязками потомков&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f10396afd953909c4df70ba9023b9185a81cc60" translate="yes" xml:space="preserve">
          <source>KO clears the previous content and then sets the element&amp;rsquo;s content to your parameter value using jQuery&amp;rsquo;s html function or by parsing the string into HTML nodes and appending each node as a child of the element, if jQuery is not available.</source>
          <target state="translated">KO очищает предыдущее содержимое, а затем устанавливает для содержимого элемента значение вашего параметра с помощью функции jQuery html или путем анализа строки на узлы HTML и добавления каждого узла в качестве дочернего элемента элемента, если jQuery недоступен.</target>
        </trans-unit>
        <trans-unit id="69fa041d6384a6c679e26d44e244d5f32beebb78" translate="yes" xml:space="preserve">
          <source>KO notifies any subscribers about the new value of your computed observable.</source>
          <target state="translated">KO уведомляет всех подписчиков о новом значении Вашей вычисляемой наблюдаемости.</target>
        </trans-unit>
        <trans-unit id="71fb9b79738717eee4554654ca119320338369c1" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="translated">KO устанавливает отмеченное состояние элемента в соответствии со значением вашего параметра. Любое предыдущее отмеченное состояние будет перезаписано. Способ интерпретации вашего параметра зависит от того, к какому типу элемента вы привязываетесь:</target>
        </trans-unit>
        <trans-unit id="8a3df96598c4036511dc238d5a88ee9394c86f50" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s text content to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO устанавливает текстовое содержимое элемента на значение вашего параметра. Любое предыдущее значение будет перезаписано.</target>
        </trans-unit>
        <trans-unit id="e1f9d65da5ea43666bdeb72a28f9a6b37496e064" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s value property to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO устанавливает свойство значения элемента на значение вашего параметра. Любое предыдущее значение будет перезаписано.</target>
        </trans-unit>
        <trans-unit id="3bde7388020d016b48b1ca2b6ab57e2975906b8d" translate="yes" xml:space="preserve">
          <source>KO will pass exactly the same set of parameters that it passes to &lt;a href=&quot;#the-update-callback&quot;&gt;the update callback&lt;/a&gt;.</source>
          <target state="translated">KO передаст точно такой же набор параметров, что и &lt;a href=&quot;#the-update-callback&quot;&gt;обратному вызову обновления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7ac751a44f21c39e46010fe72a276f9173a2c15" translate="yes" xml:space="preserve">
          <source>KO will prefix the list of items with one that displays the text &amp;ldquo;Select an item&amp;hellip;&amp;rdquo; and has the value undefined. So, if myChosenValue holds the value undefined (which observables do by default), then the dummy option will be selected. If the optionsCaption parameter is an observable, then the text of the initial item will update as the observable&amp;rsquo;s value changes.</source>
          <target state="translated">KO добавит к списку элементов префикс, который отображает текст &amp;laquo;Выберите элемент&amp;hellip;&amp;raquo; и имеет значение undefined. Итак, если myChosenValue содержит значение undefined (что наблюдаемые делают по умолчанию), тогда будет выбран фиктивный вариант. Если параметр optionsCaption является наблюдаемым, то текст начального элемента будет обновляться по мере изменения значения наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="aa70ea5fbce8c2f9ed5def8836b676cb1d01b105" translate="yes" xml:space="preserve">
          <source>Key point: An observableArray tracks which objects are &lt;em&gt;in&lt;/em&gt; the array, &lt;em&gt;not&lt;/em&gt; the state of those objects</source>
          <target state="translated">Ключевой момент: observableArray отслеживает, какие объекты находятся &lt;em&gt;в&lt;/em&gt; массиве, а &lt;em&gt;не&lt;/em&gt; состояние этих объектов.</target>
        </trans-unit>
        <trans-unit id="65b8802912f36c09e8cad961f5924ed6360633cb" translate="yes" xml:space="preserve">
          <source>Knockout 3.5 introduced the ability to specify a custom rate-limit method by passing a function to the rateLimit extender rather than just a string. The function is called with three parameters (function, timeout, options) and must return a new, rate-limited function. Whenever the observable has a possibly new value to notify, it will call the returned function, which should then call the original function after some delay based on the rules of the custom method. For example, here is a function that implements &lt;em&gt;debounce&lt;/em&gt; but also immediately notifies the initial value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20cd00a0b3dad001fec0c192cbc11b089833bdc7" translate="yes" xml:space="preserve">
          <source>Knockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage. The most convenient way to exchange or store data is in &lt;a href=&quot;http://json.org/&quot;&gt;JSON format&lt;/a&gt; - the format that the majority of Ajax applications use today.</source>
          <target state="translated">Knockout позволяет реализовать сложную интерактивность на стороне клиента, но почти всем веб-приложениям также необходимо обмениваться данными с сервером или, по крайней мере, сериализовать данные для локального хранилища. Наиболее удобный способ обмена или хранения данных - это &lt;a href=&quot;http://json.org/&quot;&gt;формат JSON&lt;/a&gt; - формат, который сегодня используется большинством приложений Ajax.</target>
        </trans-unit>
        <trans-unit id="f229f6596fbe329e6bb64b5dce17d58c2ffbdd68" translate="yes" xml:space="preserve">
          <source>Knockout allows you to use multiple component loaders simultaneously. This is useful so that, for example, you can plug in loaders that implement different mechanisms (e.g., one might fetch templates from a backend server according to a naming convention; another might set up viewmodels using a dependency injection system) and have them work together.</source>
          <target state="translated">Нокаут позволяет использовать многокомпонентные погрузчики одновременно.Это полезно для того,чтобы,например,вы могли подключить загрузчики,которые реализуют различные механизмы (например,один может получать шаблоны с внутреннего сервера в соответствии с соглашением об именовании;другой может настраивать viewmodels с помощью системы инжекции зависимостей)и заставить их работать вместе.</target>
        </trans-unit>
        <trans-unit id="b60fb8fc7684ef97c17d8ccca6eefd233019acb9" translate="yes" xml:space="preserve">
          <source>Knockout does not call require([moduleName], ...) until your component is being instantiated. This is how components get loaded on demand, not up front.</source>
          <target state="translated">Нокаут не вызывает require([имя модуля],...)до тех пор,пока не будет инстанцирован ваш компонент.Так компоненты загружаются по требованию,а не заранее.</target>
        </trans-unit>
        <trans-unit id="6bdbad01c03ad4f569a7ab9c513b131c9c780424" translate="yes" xml:space="preserve">
          <source>Knockout doesn&amp;rsquo;t force you to use any one particular technique to load or save data. You can use whatever mechanism is a convenient fit for your chosen server-side technology. The most commonly-used mechanism is jQuery&amp;rsquo;s Ajax helper methods, such as &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt;, &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt;, and &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt;. You can fetch data from the server:</source>
          <target state="translated">Knockout не заставляет вас использовать какой-либо конкретный метод для загрузки или сохранения данных. Вы можете использовать любой механизм, который подходит для выбранной вами серверной технологии. Наиболее часто используемый механизм - это вспомогательные методы Ajax jQuery, такие как &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt; , &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt; и &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt; . Вы можете получить данные с сервера:</target>
        </trans-unit>
        <trans-unit id="f5aed4a079474df37e1a8e5472e53d73006c662b" translate="yes" xml:space="preserve">
          <source>Knockout has special support for drop-down lists (i.e., &amp;lt;select&amp;gt; elements). The value binding works in conjunction with the options binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; or for handling multi-select lists, see the documentation for &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;.</source>
          <target state="translated">Knockout имеет специальную поддержку раскрывающихся списков (например, элементов &amp;lt;select&amp;gt;). Привязка значений работает вместе с привязкой параметров, позволяя вам читать и записывать значения, которые являются произвольными объектами JavaScript, а не только строковыми значениями. Это очень полезно, если вы хотите, чтобы пользователь мог выбирать из набора объектов модели. Примеры этого см. &lt;a href=&quot;options-binding&quot;&gt;В привязке параметров,&lt;/a&gt; а для обработки списков с множественным выбором см. Документацию по &lt;a href=&quot;selectedoptions-binding&quot;&gt;привязке selectedOptions&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfbfbf7e76555709a0e8ee8ab3da25adea41602f" translate="yes" xml:space="preserve">
          <source>Knockout is a JavaScript library that helps you to create rich, responsive display and editor user interfaces with a clean underlying data model. Any time you have sections of UI that update dynamically (e.g., changing depending on the user&amp;rsquo;s actions or when an external data source changes), KO can help you implement it more simply and maintainably.</source>
          <target state="translated">Knockout - это библиотека JavaScript, которая помогает создавать многофункциональные, гибкие пользовательские интерфейсы для отображения и редактирования с чистой базовой моделью данных. Каждый раз, когда у вас есть разделы пользовательского интерфейса, которые обновляются динамически (например, меняются в зависимости от действий пользователя или когда изменяется внешний источник данных), KO может помочь вам реализовать его более просто и удобно.</target>
        </trans-unit>
        <trans-unit id="ce1aa9a9160bc65a886f29f47c527a318a8927af" translate="yes" xml:space="preserve">
          <source>Knockout is built around three core features:</source>
          <target state="translated">Нокаут построен вокруг трех основных особенностей:</target>
        </trans-unit>
        <trans-unit id="09a2d95410f39ed2247b45c19059e92620c5572c" translate="yes" xml:space="preserve">
          <source>Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model&amp;rsquo;s properties are &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.</source>
          <target state="translated">Knockout разработан, чтобы позволить вам использовать произвольные объекты JavaScript в качестве моделей представления. Пока некоторые свойства вашей модели представления являются &lt;a href=&quot;observables&quot;&gt;наблюдаемыми&lt;/a&gt; , вы можете использовать KO, чтобы привязать их к своему пользовательскому интерфейсу, и пользовательский интерфейс будет обновляться автоматически при изменении наблюдаемых свойств.</target>
        </trans-unit>
        <trans-unit id="0332512be6d6db18462a0af0288d09889035cb5f" translate="yes" xml:space="preserve">
          <source>Knockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes. In some cases, though, you may wish to add additional functionality to an observable. This might include adding additional properties to the observable or intercepting writes by placing a writable computed observable in front of the observable. Knockout extenders provide an easy and flexible way to do this type of augmentation to an observable.</source>
          <target state="translated">Нокаут-наблюдатели предоставляют основные функции,необходимые для поддержки чтения/записи значений и уведомления абонентов при изменении этого значения.В некоторых случаях,однако,вы можете захотеть добавить дополнительную функциональность к наблюдаемому.Это может включать в себя добавление дополнительных свойств к наблюдаемому или перехват записей путем размещения записываемого вычисленного значения перед наблюдаемым.Нокаут-удлинители обеспечивают простой и гибкий способ дополнения наблюдаемой записи.</target>
        </trans-unit>
        <trans-unit id="aad0f3305d675fb1b797b9228f57e9108d17c6a8" translate="yes" xml:space="preserve">
          <source>Knockout provides some advanced methods to control when the microtask queue is processed. These are useful if you want to integrate Knockout&amp;rsquo;s microtask system with another library or add support for additional environments.</source>
          <target state="translated">Knockout предоставляет некоторые расширенные методы управления обработкой очереди микрозадач. Они полезны, если вы хотите интегрировать систему микрозадач Knockout с другой библиотекой или добавить поддержку дополнительных сред.</target>
        </trans-unit>
        <trans-unit id="ca6abd5738b63edcd68975dfacaf86d8c1192d78" translate="yes" xml:space="preserve">
          <source>Knockout provides the following functions for working with virtual elements.</source>
          <target state="translated">Нокаут предоставляет следующие функции для работы с виртуальными элементами.</target>
        </trans-unit>
        <trans-unit id="2ed4d7a56d6f5a6d67ea07b3132d5ff007844b64" translate="yes" xml:space="preserve">
          <source>Knockout provides two similar events that you can use to be notified when the contents of a node have been bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef914aa2073c907e472f6d2527feb737ec2b058e" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0091a1df891fb4dfb8dfd62f26c34e55f8c10" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s content to a text node with your parameter value. Any previous content will be overwritten.</source>
          <target state="translated">Knockout устанавливает содержимое элемента в текстовый узел со значением вашего параметра. Любой предыдущий контент будет перезаписан.</target>
        </trans-unit>
        <trans-unit id="f4be7114f1815cac446415c10a81311effa02c36" translate="yes" xml:space="preserve">
          <source>Knockout tries hard to spare developers the pain of dealing with cross-browser compatiblity issues, especially those relating to older browsers! Even though custom elements provide a very modern style of web development, they still work on all commonly-encountered browsers:</source>
          <target state="translated">Knockout изо всех сил старается избавить разработчиков от боли в решении проблем кросс-браузерной совместимости,особенно тех,которые относятся к старым браузерам! Несмотря на то,что пользовательские элементы обеспечивают очень современный стиль веб-разработки,они все равно работают со всеми распространенными браузерами:</target>
        </trans-unit>
        <trans-unit id="3614b4e93dd3cdeb6c24be3fd21755de5f630cec" translate="yes" xml:space="preserve">
          <source>Knockout version 3.4.0 added support for &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;deferred updates&lt;/em&gt;&lt;/a&gt;, which works similarly to rate-limiting by making notifications and updates asynchronous. But instead of using a timed delay, deferred updates are processed as soon as possible after the current task, before yielding for I/O, reflow, or redrawing. If you are upgrading to 3.4.0 and have code that uses a short rate-limit timeout (e.g., 0 milliseconds), you could modify it to use deferred updates instead:</source>
          <target state="translated">В Knockout версии 3.4.0 добавлена ​​поддержка &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;отложенных обновлений&lt;/em&gt;&lt;/a&gt; , которая работает аналогично ограничению скорости, делая уведомления и обновления асинхронными. Но вместо использования временной задержки отложенные обновления обрабатываются как можно скорее после текущей задачи, прежде чем уступить место вводу-выводу, перекомпоновке или перерисовке. Если вы обновляетесь до 3.4.0 и имеете код, который использует короткий тайм-аут ограничения скорости (например, 0 миллисекунд), вы можете изменить его, чтобы вместо этого использовать отложенные обновления:</target>
        </trans-unit>
        <trans-unit id="bf00d058136f6ed851cf257f843756b9fbf0a3dc" translate="yes" xml:space="preserve">
          <source>Knockout will call the update callback initially when the binding is applied to an element and track any dependencies (observables/computeds) that you access. When any of these dependencies change, the update callback will be called once again. The following parameters are passed to it:</source>
          <target state="translated">Knockout вызовет обратный вызов обновления изначально,когда привязка применяется к элементу,и отследит любые зависимости (наблюдаемые/вычисленные),к которым вы обращаетесь.Когда какая-либо из этих зависимостей изменится,будет снова вызван обратный вызов обновления.Ему передаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="2eae698b690b8c1bcce8105ecab4ab66625edf99" translate="yes" xml:space="preserve">
          <source>Knockout will call your init function once for each DOM element that you use the binding on. There are two main uses for init:</source>
          <target state="translated">Нокаут вызовет функцию init один раз для каждого элемента DOM,на который вы используете привязку.Есть два основных способа использования init:</target>
        </trans-unit>
        <trans-unit id="a23739891b1f51e8af9e998ec7eca300dc988110" translate="yes" xml:space="preserve">
          <source>Knockout will create a computed observable internally in order to detect what observables the expression depends on, and will automatically dispose it when the associated element is later removed.</source>
          <target state="translated">Нокаут создаст внутренне вычисляемое наблюдаемое выражение для того,чтобы определить,от чего зависит выражение,и автоматически утилизирует его при последующем удалении ассоциированного элемента.</target>
        </trans-unit>
        <trans-unit id="8ab974d067e98d55b933807ee21cdb58029eeed8" translate="yes" xml:space="preserve">
          <source>Knockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., someProperty and doSomething in the example above) are available for binding in the component&amp;rsquo;s view.</source>
          <target state="translated">Knockout будет вызывать ваш конструктор один раз для каждого экземпляра компонента, создавая для каждого отдельный объект модели представления. Свойства полученного объекта или его цепочки прототипов (например, someProperty и doSomething в приведенном выше примере) доступны для привязки в представлении компонента.</target>
        </trans-unit>
        <trans-unit id="48c5db285f5258d37819571d4c74273c14dd139e" translate="yes" xml:space="preserve">
          <source>Knockout will prevent the use of any bindings that use &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt;, because this also would clash with the component when trying to bind its viewmodel to the injected template. Therefore if you want to use a control flow binding such as if or foreach, then you must wrap it around your custom element rather than using it directly on the custom element, e.g.,:</source>
          <target state="translated">Knockout предотвратит использование любых привязок, которые используют &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt; , потому что это также будет конфликтовать с компонентом при попытке привязать его модель представления к внедренному шаблону. Поэтому, если вы хотите использовать привязку потока управления, такую ​​как if или foreach, вы должны обернуть ее вокруг своего настраиваемого элемента, а не использовать непосредственно на настраиваемом элементе, например:</target>
        </trans-unit>
        <trans-unit id="ce5685352c45a8ccb78cdea5682fde3ead2b6d04" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/css/&quot;&gt;css&lt;/a&gt; function to set the styles, if available. This lets you take advantage of the extra compatibility features of jQuery, such as setting browser-specific prefixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409698893159f365e2fba812abf15b879db2dd76" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as change. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Нокаут будет использовать jQuery,если он присутствует,для обработки событий пользовательского интерфейса,таких как изменения.Чтобы отключить такое поведение и инструктировать Knockout всегда использовать родную обработку событий,вы можете установить следующую опцию в вашем коде перед вызовом ko.applyBindings:</target>
        </trans-unit>
        <trans-unit id="628ae63ef225d2591f558c7eb5f9fe4b46e164f9" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as click. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Нокаут будет использовать jQuery,если он присутствует,для обработки событий пользовательского интерфейса,таких как щелчок мышью.Чтобы отключить такое поведение и инструктировать Knockout всегда использовать родную обработку событий,вы можете установить следующую опцию в вашем коде перед вызовом ko.applyBindings:</target>
        </trans-unit>
        <trans-unit id="d77ef2ccc75214842d9b2c0a3d534e87e201ecce" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Нокаут будет использовать jQuery,если он присутствует,для обработки событий пользовательского интерфейса.Чтобы отключить такое поведение и инструктировать Knockout всегда использовать родную обработку событий,вы можете установить следующую опцию в вашем коде перед вызовом ko.applyBindings:</target>
        </trans-unit>
        <trans-unit id="2a463ee652f33a4ecb8721a1952f7992b0096faf" translate="yes" xml:space="preserve">
          <source>Knockout wraps internal asynchronous calls and looks for an optional ko.onError callback to execute, if an exception is encountered, before throwing the original error. This gives you the opportunity to run custom logic, such as passing the error to a logging module. Additionally, since the original call is wrapped in a try/catch, the error passed to ko.onError contains a stack property, which is not true in many browsers when handling errors using window.onerror.</source>
          <target state="translated">Нокаут обертывает внутренние асинхронные вызовы и ищет опциональный ko.onError вызов для выполнения,если встречается исключение,перед тем как бросить оригинальную ошибку.Это дает вам возможность запустить пользовательскую логику,такую как передача ошибки в модуль протоколирования.Кроме того,так как исходный вызов обернут в try/catch,ошибка,переданная в ko.onError,содержит свойство стека,что не верно во многих браузерах при работе с ошибками,использующих window.onerror.</target>
        </trans-unit>
        <trans-unit id="eaba5f2372fd360661055282561600552507d4f4" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s &lt;em&gt;control flow bindings&lt;/em&gt; (e.g., &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;) can be applied not only to regular DOM elements, but also to &amp;ldquo;virtual&amp;rdquo; DOM elements defined by a special comment-based syntax. For example:</source>
          <target state="translated">&lt;em&gt;Привязки потока управления&lt;/em&gt; Knockout (например, &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; и &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; ) могут применяться не только к обычным элементам DOM, но также к &amp;laquo;виртуальным&amp;raquo; элементам DOM, определенным с помощью специального синтаксиса на основе комментариев. Например:</target>
        </trans-unit>
        <trans-unit id="10dcefe7d15993a636613b17dda7a5e5e9fcae8a" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The peek function lets you access an observable or computed observable without creating a dependency.</source>
          <target state="translated">Автоматическое отслеживание зависимостей Knockout обычно делает именно то, что вы хотите. Но иногда вам может потребоваться контролировать, какие наблюдаемые объекты будут обновлять вашу вычисляемую наблюдаемую, особенно если вычисляемая наблюдаемая выполняет какое-то действие, например, делает запрос Ajax. Функция peek позволяет получить доступ к наблюдаемому или вычисляемому наблюдаемому без создания зависимости.</target>
        </trans-unit>
        <trans-unit id="dd482bdf1441531cfa78b4dbd9241b7e06ebb86c" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s declarative binding system provides a concise and powerful way to link data to the UI. It&amp;rsquo;s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout&amp;rsquo;s binding system.</source>
          <target state="translated">Система декларативной привязки Knockout обеспечивает краткий и эффективный способ привязки данных к пользовательскому интерфейсу. Как правило, легко и очевидно выполнить привязку к простым свойствам данных или использовать одну привязку. Для более сложных привязок это помогает лучше понять поведение и синтаксис системы привязки Knockout.</target>
        </trans-unit>
        <trans-unit id="7691338ff4b6fbe0156716cb2ed66851f5e37135" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue</source>
          <target state="translated">Очередь микрозадач Knockout</target>
        </trans-unit>
        <trans-unit id="29bf809f39e83f00213a2579389145bb353bc904" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue supports scheduling tasks to run as soon as possible while still being asynchronous, striving to schedule them to occur before yielding for I/O, reflow, or redrawing. It is used internally for &lt;a href=&quot;component-overview&quot;&gt;Knockout components&lt;/a&gt; to maintain asynchronous behavior, and for scheduling &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; for observables.</source>
          <target state="translated">Очередь микрозадач Knockout поддерживает планирование задач, которые должны выполняться как можно скорее, при этом сохраняя асинхронность, стремясь запланировать их выполнение до того, как уступить для ввода-вывода, перекомпоновки или перерисовки. Он используется внутри &lt;a href=&quot;component-overview&quot;&gt;компонентов Knockout&lt;/a&gt; для поддержки асинхронного поведения и для планирования &lt;a href=&quot;deferred-updates&quot;&gt;отложенных обновлений&lt;/a&gt; для наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="eca702ffcf354707c6d7e704262cbeb2920d80d3" translate="yes" xml:space="preserve">
          <source>Knockout.js</source>
          <target state="translated">Knockout.js</target>
        </trans-unit>
        <trans-unit id="8c7dca686f307018a9b4d98dff3ae5fb4bbceb4a" translate="yes" xml:space="preserve">
          <source>Later, when you&amp;rsquo;re asked to implement the &amp;lsquo;Delete&amp;rsquo; functionality, you don&amp;rsquo;t have to figure out what bits of the UI it has to interact with; you just make it alter the underlying data model.</source>
          <target state="translated">Позже, когда вас попросят реализовать функцию &amp;laquo;Удалить&amp;raquo;, вам не нужно будет выяснять, с какими частями пользовательского интерфейса он должен взаимодействовать; вы просто заставляете его изменять базовую модель данных.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">Узнать больше</target>
        </trans-unit>
        <trans-unit id="1f2e2bde04a28d8be8e4af5907acc2fba80505c0" translate="yes" xml:space="preserve">
          <source>Learn more about configuring and registering components with the default loader</source>
          <target state="translated">Узнать больше о настройке и регистрации компонентов в загрузчике по умолчанию</target>
        </trans-unit>
        <trans-unit id="6be1bb6cdfa52ff974724e62faceb68b7d67cb10" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a JavaScript object that looks like this:</source>
          <target state="translated">Допустим, у вас есть объект JavaScript, который выглядит так:</target>
        </trans-unit>
        <trans-unit id="94f3d8639201581d19e8cd3a9912e85ca0fa345a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update the code for randomOrder, this time using KO&amp;rsquo;s virtual element APIs:</source>
          <target state="translated">Давайте обновим код randomOrder, на этот раз используя API виртуальных элементов KO:</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="7d96c306a2bdbcd8c8b74b52fb7d8e32e3c7d783" translate="yes" xml:space="preserve">
          <source>Like components, &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;custom bindings that control descendant bindings&lt;/a&gt; can use ko.bindingEvent.subscribe to run post-processing logic. However, in order to subscribe to the descendantsComplete event, you also need to tell Knockout that your binding is involved in asynchronous notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22c0dccba3224320a8069043f5f6f3d98d749d5" translate="yes" xml:space="preserve">
          <source>Live Example 1: Forcing input to be numeric</source>
          <target state="translated">Живой пример 1:Принудительный ввод цифр</target>
        </trans-unit>
        <trans-unit id="a999d211200204fb1d5f89b2e98b09601e4ab925" translate="yes" xml:space="preserve">
          <source>Live Example 2: Adding validation to an observable</source>
          <target state="translated">Живой пример 2:Добавление валидации к наблюдаемому</target>
        </trans-unit>
        <trans-unit id="f19646932df2821a76d070d391a81a56f5b95215" translate="yes" xml:space="preserve">
          <source>Live example</source>
          <target state="translated">Живой пример</target>
        </trans-unit>
        <trans-unit id="c96856283b27b5efa4c99dbc46c686a71954647b" translate="yes" xml:space="preserve">
          <source>Live example: nested children</source>
          <target state="translated">Живой пример:вложенные дети</target>
        </trans-unit>
        <trans-unit id="ce4efabbd5fd9902131eac73e8e59cb786288b4a" translate="yes" xml:space="preserve">
          <source>Live examples are not available on DevDocs, sorry.</source>
          <target state="translated">Живые примеры недоступны на DevDocs,извините.</target>
        </trans-unit>
        <trans-unit id="e8179062abf1c808535e17f3bba054486e091bd3" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js and a ViewModel class via RequireJs</source>
          <target state="translated">Загрузка Knockout.js и класса ViewModel через RequireJs.</target>
        </trans-unit>
        <trans-unit id="7a1275f750d43f39de53842ed4dbab527886627e" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js, a Binding Handler, and a ViewModel class via RequireJs</source>
          <target state="translated">Загрузка Knockout.js,обработчика связывания и класса ViewModel через RequireJs.</target>
        </trans-unit>
        <trans-unit id="a6971a11e0a52091a5c953372bb00569922b2df7" translate="yes" xml:space="preserve">
          <source>Loading and Saving JSON data</source>
          <target state="translated">Загрузка и сохранение данных JSON</target>
        </trans-unit>
        <trans-unit id="28f44d40c76afc7d7591cf58f327b1bbe21530d4" translate="yes" xml:space="preserve">
          <source>Loading or Saving Data</source>
          <target state="translated">Загрузка или сохранение данных</target>
        </trans-unit>
        <trans-unit id="902d451cfddbf1a7bd9bf785b56f8ce391deaaca" translate="yes" xml:space="preserve">
          <source>Logically, 'major highlight': isSevere is equivalent to major: isSevere, highlight: isSevere. It&amp;rsquo;s merely a shortcut syntax if you want two or more CSS classes to be set and unset together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac600279c0db054ae2804d05146b63ba0414ceea" translate="yes" xml:space="preserve">
          <source>MVVM and View Models</source>
          <target state="translated">Модели MVVM и View</target>
        </trans-unit>
        <trans-unit id="d0132e7037dde4a1569f3f0cf422fc539613ba46" translate="yes" xml:space="preserve">
          <source>Main Parameter</source>
          <target state="translated">Главный параметр</target>
        </trans-unit>
        <trans-unit id="1b773120102a6c1a24da236928541cb48a5ec94c" translate="yes" xml:space="preserve">
          <source>Main parameter</source>
          <target state="translated">Основной параметр</target>
        </trans-unit>
        <trans-unit id="042abe727f60c8d9932534243bb81872b7416c98" translate="yes" xml:space="preserve">
          <source>Making things respond after a certain delay</source>
          <target state="translated">Заставлять вещи реагировать после определенной задержки</target>
        </trans-unit>
        <trans-unit id="c8a5870106ccf1eddcdec83e7b076fb5c8b992dd" translate="yes" xml:space="preserve">
          <source>Managing &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">Управление этим</target>
        </trans-unit>
        <trans-unit id="8f860a27c927a94a2081dcaffc79957c81d02b57" translate="yes" xml:space="preserve">
          <source>Manipulating an observableArray</source>
          <target state="translated">Манипулирование наблюдаемым ядром</target>
        </trans-unit>
        <trans-unit id="f22316e0ceeda20484d97d991e8da0112dd866d9" translate="yes" xml:space="preserve">
          <source>Manually-created &lt;strong&gt;event handlers&lt;/strong&gt; on external DOM elements, if created inside a createViewModel function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn&amp;rsquo;t) must be removed.</source>
          <target state="translated">Созданные вручную &lt;strong&gt;обработчики событий&lt;/strong&gt; на внешних элементах DOM, если они созданы внутри функции createViewModel (или даже внутри обычной модели представления компонента, хотя для соответствия шаблону MVVM вам не следует), должны быть удалены.</target>
        </trans-unit>
        <trans-unit id="588de813ea47b650faf54523ad98714b629c740e" translate="yes" xml:space="preserve">
          <source>Mapped observable array</source>
          <target state="translated">Отображение наблюдаемого массива</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="996b905af8ff85c85478f1f8432f440056372995" translate="yes" xml:space="preserve">
          <source>Mapping from multiple sources</source>
          <target state="translated">Картирование из нескольких источников</target>
        </trans-unit>
        <trans-unit id="7e632657a4c6244bb198de62ec1571b6dfbf8396" translate="yes" xml:space="preserve">
          <source>Mapping options that you specify in each call will be merged.</source>
          <target state="translated">Опции сопоставления,которые вы указываете в каждом вызове,будут объединены.</target>
        </trans-unit>
        <trans-unit id="0c19d4dee164eb75d3ed611fe2afd01eccf8b645" translate="yes" xml:space="preserve">
          <source>Microtasks</source>
          <target state="translated">Microtasks</target>
        </trans-unit>
        <trans-unit id="1ee20630e0871cafa9aed0bf7aa0013db967c5b0" translate="yes" xml:space="preserve">
          <source>Microtasks can be canceled using the &lt;em&gt;handle&lt;/em&gt; value returned from ko.tasks.schedule. If the task has already run or was previously canceled, cancel does nothing.</source>
          <target state="translated">Микрозадачи можно отменить, используя значение &lt;em&gt;дескриптора,&lt;/em&gt; возвращаемое из ko.tasks.schedule. Если задача уже была запущена или была ранее отменена, отмена ничего не делает.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="53e411847528d541c26c3c00ed9603e00cf5d49c" translate="yes" xml:space="preserve">
          <source>Modifying observables after DOM events</source>
          <target state="translated">Изменение наблюдаемых объектов после событий DOM</target>
        </trans-unit>
        <trans-unit id="148523423d67830c8f1a8a3e23b0aa52da24e903" translate="yes" xml:space="preserve">
          <source>More more detailed information, see:</source>
          <target state="translated">Более подробная информация,см:</target>
        </trans-unit>
        <trans-unit id="03e0bcfaabb4306e0ad24ddb4448860d09263fb3" translate="yes" xml:space="preserve">
          <source>More than one extender can be applied in a single call to the .extend method of an observable.</source>
          <target state="translated">Несколько расширителей могут быть применены за один вызов к методу .extension наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="0a842f6a98c04fd60847152441adf06e65c2bcdb" translate="yes" xml:space="preserve">
          <source>Most applications need to fetch data from a backend server. Since the server doesn&amp;rsquo;t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you&amp;rsquo;ve fetched from the server.</source>
          <target state="translated">Большинству приложений необходимо получать данные с внутреннего сервера. Поскольку сервер не имеет понятия наблюдаемых, он просто предоставит простой объект JavaScript (обычно сериализованный как JSON). Плагин сопоставления дает вам простой способ сопоставить этот простой объект JavaScript в модели представления с соответствующими наблюдаемыми. Это альтернатива написанию собственного кода JavaScript вручную, который создает модель представления на основе некоторых данных, полученных с сервера.</target>
        </trans-unit>
        <trans-unit id="e4d448139b3552f2ce58ee18a84ae6283ba5f3bb" translate="yes" xml:space="preserve">
          <source>Multiple component loaders may be consulted, until the first one recognises the component name and supplies a viewmodel/template. This process only takes place &lt;strong&gt;once per component type&lt;/strong&gt;, since Knockout caches the resulting definitions in memory.</source>
          <target state="translated">Можно обращаться к нескольким загрузчикам компонентов, пока первый не распознает имя компонента и не предоставит модель / шаблон представления. Этот процесс выполняется только &lt;strong&gt;один раз для каждого типа компонента&lt;/strong&gt; , поскольку Knockout кэширует полученные определения в памяти.</target>
        </trans-unit>
        <trans-unit id="6a6cd3eea908b0b2a5c411ea2342c43a36c3d759" translate="yes" xml:space="preserve">
          <source>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery&amp;rsquo;s $.getJSON or $.ajax functions):</source>
          <target state="translated">Затем вы хотите получить последние данные с сервера. Каждые 5 секунд вы можете отправлять Ajax-запрос (например, используя функции jQuery $ .getJSON или $ .ajax):</target>
        </trans-unit>
        <trans-unit id="5f490764c270257caa7816a634ad9ceb0029f602" translate="yes" xml:space="preserve">
          <source>No matter how nested the links become, the handler is always able to identify and operate on the appropriate data. Using this techinique, we can avoid the overhead of attaching handlers to each individual link and can keep the markup clean and concise.</source>
          <target state="translated">Независимо от того,насколько вложенными становятся ссылки,обработчик всегда может идентифицировать соответствующие данные и работать с ними.Используя эту технику,мы можем избежать накладных расходов,связанных с прикреплением обработчиков к каждому отдельному соединению,и сохранить разметку чистой и лаконичной.</target>
        </trans-unit>
        <trans-unit id="afa1839782d1d70ed8698b21df5705b582780b4b" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true.</source>
          <target state="translated">Небулевые значения свободно интерпретируются как булевые.Например,0 и ноль трактуются как ложные,в то время как 21 и ненулевые объекты трактуются как истинные.</target>
        </trans-unit>
        <trans-unit id="065695e32c88230ab4bdf412903d650d890a874e" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true. If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later. As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="b7e6ebe0a5573c6fa19a2a0f36cfae8a5b91c39f" translate="yes" xml:space="preserve">
          <source>None, other than the core Knockout library.</source>
          <target state="translated">Нет,кроме основной нокаут-библиотеки.</target>
        </trans-unit>
        <trans-unit id="db09b0691b02a98f1c82dcb9d3a19d0909373cf6" translate="yes" xml:space="preserve">
          <source>Normally, Knockout consults the loaders &lt;em&gt;once per component name&lt;/em&gt;, then caches the resulting definition. This ensures that large numbers of components may be instantiated very quickly. If you want to clear the cache entry for a given component, call this, and then the loaders will be consulted again the next time that component is needed.</source>
          <target state="translated">Обычно Knockout обращается к загрузчикам &lt;em&gt;один раз для каждого имени компонента&lt;/em&gt; , а затем кэширует полученное определение. Это гарантирует, что большое количество компонентов может быть создано очень быстро. Если вы хотите очистить запись кэша для данного компонента, вызовите это, и тогда загрузчики будут проконсультированы снова, когда этот компонент понадобится в следующий раз.</target>
        </trans-unit>
        <trans-unit id="eeec499c3f627d57c3576dc1e65df40411bba37d" translate="yes" xml:space="preserve">
          <source>Normally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because &lt;em&gt;sometimes it has no choice but to be asynchronous&lt;/em&gt; (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default &amp;mdash; it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.</source>
          <target state="translated">Обычно Knockout гарантирует, что загрузка компонента и, следовательно, внедрение компонента всегда завершается асинхронно, потому что &lt;em&gt;иногда у него нет другого выбора, кроме как быть асинхронным&lt;/em&gt; (например, потому что он включает запрос к серверу). Это происходит, даже если конкретный экземпляр компонента может быть введен синхронно (например, потому что определение компонента уже загружено). Эта всегда асинхронная политика является вопросом согласованности и представляет собой устоявшееся соглашение, унаследованное от других современных технологий асинхронного JavaScript, таких как AMD. Это соглашение является безопасным по умолчанию - оно уменьшает потенциальные ошибки, когда разработчик может не учитывать возможность того, что обычно асинхронный процесс иногда завершается синхронно или наоборот.</target>
        </trans-unit>
        <trans-unit id="6524854e62e38125ced06867534d8b38f18ad484" translate="yes" xml:space="preserve">
          <source>Normally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable&amp;rsquo;s updates and notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">Обычно вычисляемый наблюдаемый обновляется и немедленно уведомляет своих подписчиков, как только его зависимости изменяются. Но если вычисляемая наблюдаемая имеет много зависимостей или включает дорогостоящие обновления, вы можете повысить производительность, ограничив или отложив обновления и уведомления вычисляемой наблюдаемой. Это достигается с &lt;a href=&quot;ratelimit-observable&quot;&gt;помощью расширителя rateLimit&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="de8510f955a76aae57a6decf3b1d448a2721eab0" translate="yes" xml:space="preserve">
          <source>Normally, an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; that is changed notifies its subscribers immediately, so that any computed observables or bindings that depend on the observable are updated synchronously. The rateLimit extender, however, causes an observable to suppress and delay change notifications for a specified period of time. A rate-limited observable therefore updates dependencies asynchronously.</source>
          <target state="translated">Обычно изменяемый &lt;a href=&quot;observables&quot;&gt;наблюдаемый&lt;/a&gt; объект немедленно уведомляет своих подписчиков, так что любые вычисленные наблюдаемые объекты или привязки, которые зависят от наблюдаемого, обновляются синхронно. Однако расширитель rateLimit заставляет наблюдаемое подавлять и задерживать уведомления об изменении на определенный период времени. Таким образом, наблюдаемая с ограниченной скоростью обновляет зависимости асинхронно.</target>
        </trans-unit>
        <trans-unit id="85e4e3194fb98ff27c2137c8428ce2e4d1b258a4" translate="yes" xml:space="preserve">
          <source>Normally, an observable notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable&amp;rsquo;s change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">Обычно наблюдаемый немедленно уведомляет своих подписчиков, как только он изменяется. Но если наблюдаемое изменяется неоднократно или запускает дорогостоящие обновления, вы можете повысить производительность, ограничив или отложив уведомления об изменении наблюдаемого. Это достигается с &lt;a href=&quot;ratelimit-observable&quot;&gt;помощью расширителя rateLimit&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="971d310ac30608c092a71563e91ea63dc1528f2c" translate="yes" xml:space="preserve">
          <source>Normally, an observableArray notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">Обычно observableArray немедленно уведомляет своих подписчиков, как только он изменяется. Но если observableArray неоднократно изменяется или запускает дорогостоящие обновления, вы можете повысить производительность, ограничив или отложив уведомления об изменениях. Это достигается с &lt;a href=&quot;ratelimit-observable&quot;&gt;помощью расширителя rateLimit&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="a43fe63b87c4cb41558a04d9c42885616a56c55a" translate="yes" xml:space="preserve">
          <source>Normally, bindings that use controlsDescendantBindings will also call ko.applyBindingsToDescendants(someBindingContext, element) to apply the descendant bindings against some modified &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. For example, you could have a binding called withProperties that attaches some extra properties to the binding context that will then be available to all descendant bindings:</source>
          <target state="translated">Обычно привязки, которые используют controlsDescendantBindings, также вызывают ko.applyBindingsToDescendants (someBindingContext, element) для применения привязок потомков к некоторому измененному &lt;a href=&quot;binding-context&quot;&gt;контексту привязки&lt;/a&gt; . Например, у вас может быть привязка withProperties, которая присоединяет некоторые дополнительные свойства к контексту привязки, которые затем будут доступны для всех привязок-потомков:</target>
        </trans-unit>
        <trans-unit id="b15e1efcc6bbdd05b9bb899a299cf912de21af36" translate="yes" xml:space="preserve">
          <source>Normally, computed observables have a value that is computed from other observables and are therefore &lt;em&gt;read-only&lt;/em&gt;. What may seem surprising, then, is that it is possible to make computed observables &lt;em&gt;writable&lt;/em&gt;. You just need to supply your own callback function that does something sensible with written values.</source>
          <target state="translated">Обычно вычисляемые наблюдаемые имеют значение, которое вычисляется из других наблюдаемых, и поэтому они &lt;em&gt;доступны только для чтения&lt;/em&gt; . Что может показаться удивительным, так это то, что вычисленные наблюдаемые &lt;em&gt;объекты&lt;/em&gt; можно сделать &lt;em&gt;доступными для записи&lt;/em&gt; . Вам просто нужно предоставить свою собственную функцию обратного вызова, которая делает что-то разумное с записанными значениями.</target>
        </trans-unit>
        <trans-unit id="d425a57c002e80bcb922861fb6ad11cb4606ddb8" translate="yes" xml:space="preserve">
          <source>Normally, if you change name as follows:</source>
          <target state="translated">Обычно,если вы меняете имя следующим образом:</target>
        </trans-unit>
        <trans-unit id="ea5e697b7346a3eeff279e706b4abc4448a43fae" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the click event would bubble up to myDivHandler. However, the clickBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">Обычно в этом случае сначала вызывается myButtonHandler,а затем всплывает событие клика до myDivHandler.Однако,привязка clickBubble,которую мы добавили со значением false,не позволяет событию пройти мимо myButtonHandler.</target>
        </trans-unit>
        <trans-unit id="fc7808246a4e59ebea4927b73d56662e9805e699" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the event would bubble up to myDivHandler. However, the mouseoverBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">Обычно в этом случае сначала вызывается myButtonHandler,а затем событие всплывает до myDivHandler.Однако,привязка mouseoverBubble,которую мы добавили со значением false,не позволяет событию пройти мимо myButtonHandler.</target>
        </trans-unit>
        <trans-unit id="a70aaac2826c5ee7760b4f9bcd2d5cf62e31d0b4" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; bindings notify &amp;ldquo;completeness&amp;rdquo; even if they are bound to a null or false value and therefore clear the node&amp;rsquo;s contents instead of binding them. But if you use such a control-flow binding to delay binding until part of your viewmodel is finished initializing, it may be more appropriate to also delay the binding notifications. This could be important to delay an outer node&amp;rsquo;s descendantsComplete event. To do so, include the completeOn: &quot;render&quot; option with the binding. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00011c53827e97e83b74eeaeeb5176dcdd95e89" translate="yes" xml:space="preserve">
          <source>Normally, this is an &lt;em&gt;asynchronous&lt;/em&gt; process. It may involve requests to the server. For API consistency, Knockout by default ensures that the loading process completes as an asynchronous callback even if the component is already loaded and cached in memory. For more about this, and how to allow synchronous loading, see &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;Controlling synchronous/asynchronous loading&lt;/a&gt;.</source>
          <target state="translated">Обычно это &lt;em&gt;асинхронный&lt;/em&gt; процесс. Это может включать запросы к серверу. Для согласованности API Knockout по умолчанию гарантирует, что процесс загрузки завершается как асинхронный обратный вызов, даже если компонент уже загружен и кэширован в памяти. Дополнительные сведения об этом и о том, как разрешить синхронную загрузку, см. В разделе &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;Управление синхронной / асинхронной загрузкой&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5928082628ac47958f2a49985793c5a9cfe7a4ac" translate="yes" xml:space="preserve">
          <source>Normally, when you use the value binding on a &amp;lt;select&amp;gt; element, it means that you want the associated model value to describe which item in the &amp;lt;select&amp;gt; is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.</source>
          <target state="translated">Обычно, когда вы используете привязку значения к элементу &amp;lt;select&amp;gt;, это означает, что вы хотите, чтобы связанное значение модели описывало, какой элемент в &amp;lt;select&amp;gt; выбран. Но что произойдет, если вы установите значение модели на то, что не имеет соответствующей записи в списке? По умолчанию Knockout перезаписывает значение вашей модели, чтобы сбросить его до того, что уже выбрано в раскрывающемся списке, тем самым предотвращая рассинхронизацию модели и пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="b0d7a6b36856238f1888ea77959ac6db008365ad" translate="yes" xml:space="preserve">
          <source>Normally, when you&amp;rsquo;re using control flow bindings (foreach, with, if, etc.), there&amp;rsquo;s no need to give names to your templates: they are defined implicitly and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:</source>
          <target state="translated">Обычно, когда вы используете привязки потока управления (foreach, with, if и т.д.), нет необходимости давать имена вашим шаблонам: они определяются неявно и анонимно разметкой внутри вашего элемента DOM. Но при желании вы можете выделить шаблоны в отдельный элемент, а затем ссылаться на них по имени:</target>
        </trans-unit>
        <trans-unit id="892c7a538c26d5912a114ef4c5b4dd9cb750dea3" translate="yes" xml:space="preserve">
          <source>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, ko.observable objects are actually &lt;em&gt;functions&lt;/em&gt;.</source>
          <target state="translated">Не все браузеры поддерживают геттеры и сеттеры JavaScript (* кашляет * IE * кашляет *), поэтому для совместимости объекты ko.observable фактически являются &lt;em&gt;функциями&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5a2a88914badea0501ca78d4a26a3df5411beb0f" translate="yes" xml:space="preserve">
          <source>Note 1: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a5f5143031f243bb9a60c2b68ea23336cd99f" translate="yes" xml:space="preserve">
          <source>Note 1: Getting value updates instantly from inputs</source>
          <target state="translated">Примечание 1:Мгновенное получение обновлений значений из входов</target>
        </trans-unit>
        <trans-unit id="5fab9187a677e6b78569955d9666c1ccb6694140" translate="yes" xml:space="preserve">
          <source>Note 1: Passing a &amp;ldquo;current item&amp;rdquo; as a parameter to your handler function</source>
          <target state="translated">Примечание 1. Передача &amp;laquo;текущего элемента&amp;raquo; в качестве параметра функции обработчика</target>
        </trans-unit>
        <trans-unit id="3a814cb6ad3dec3e35271de124fcb52fc7ea8a30" translate="yes" xml:space="preserve">
          <source>Note 1: Referring to each array entry using $data</source>
          <target state="translated">Примечание 1:Ссылка на каждый элемент массива с помощью $data</target>
        </trans-unit>
        <trans-unit id="ca9ba60cb79484ae10cbb526fdec0d6b22f6191b" translate="yes" xml:space="preserve">
          <source>Note 1: Rendering a named template</source>
          <target state="translated">Примечание 1:Предоставление именованного шаблона</target>
        </trans-unit>
        <trans-unit id="8cb27abf41be27c85ca84a090a734e919e5e138f" translate="yes" xml:space="preserve">
          <source>Note 1: Selection is preserved when setting/changing options</source>
          <target state="translated">Примечание 1:Выбор сохраняется при настройке/изменении опций.</target>
        </trans-unit>
        <trans-unit id="8cab987f23a9bac56add3eebe707607f36a2ea67" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;let&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ebaabfbfb4ad642b58d8dfcc7e5c4ff9d66877" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; or &amp;ldquo;using&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ce25db4800747a44dd7be30e5487498ca714b8" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; without a container element</source>
          <target state="translated">Примечание 1. Использование &amp;laquo;with&amp;raquo; без элемента контейнера</target>
        </trans-unit>
        <trans-unit id="42e4b385f89381daa4e0c5e3ef0819aa9d2954e1" translate="yes" xml:space="preserve">
          <source>Note 1: Using functions and expressions to detemine text values</source>
          <target state="translated">Примечание 1:Использование функций и выражений для определения текстовых значений</target>
        </trans-unit>
        <trans-unit id="a1e70856ca0bef317ab669b291a07dba08a49ed6" translate="yes" xml:space="preserve">
          <source>Note 1: textInput vs value binding</source>
          <target state="translated">Примечание 1:textInput vs привязка значений</target>
        </trans-unit>
        <trans-unit id="890064c263ea4cdf85ec4df05608a767470d9dee" translate="yes" xml:space="preserve">
          <source>Note 2: About HTML encoding</source>
          <target state="translated">Примечание 2:О кодировании HTML</target>
        </trans-unit>
        <trans-unit id="44d94bff3e26ecd38bca324673da6818a6524a66" translate="yes" xml:space="preserve">
          <source>Note 2: Accessing the event object, or passing more parameters</source>
          <target state="translated">Примечание 2:Доступ к объекту событий или передача большего количества параметров.</target>
        </trans-unit>
        <trans-unit id="bc192205bb6999807250e198d100299a2633603b" translate="yes" xml:space="preserve">
          <source>Note 2: Performance considerations when using &amp;ldquo;let&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa0d7caea5eed0f78bbea6e5338469a3a2dc28c" translate="yes" xml:space="preserve">
          <source>Note 2: Post-processing the generated options</source>
          <target state="translated">Примечание 2:Постобработка сгенерированных опций</target>
        </trans-unit>
        <trans-unit id="61e119aef6a09c668ea64e8f185afb7cb5e1a1c1" translate="yes" xml:space="preserve">
          <source>Note 2: Setting styles which require a unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1677efb75559f0bfd41b60da29baf1f864a1f9" translate="yes" xml:space="preserve">
          <source>Note 2: Using $index, $parent, and other context properties</source>
          <target state="translated">Примечание 2:Использование $index,$parent и других свойств контекста</target>
        </trans-unit>
        <trans-unit id="8999863783c665a40bdd09bd691a298f8f656468" translate="yes" xml:space="preserve">
          <source>Note 2: Using the &amp;ldquo;foreach&amp;rdquo; option with a named template</source>
          <target state="translated">Примечание 2. Использование опции &amp;laquo;foreach&amp;raquo; с именованным шаблоном</target>
        </trans-unit>
        <trans-unit id="7026de456ff3382a0e236d7fac1891af4a1a5c1c" translate="yes" xml:space="preserve">
          <source>Note 2: Why are there two similar bindings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2d8c3723f8725ce919b58379e9c2909628d4ef" translate="yes" xml:space="preserve">
          <source>Note 2: Working with drop-down lists (i.e., &amp;lt;select&amp;gt; elements)</source>
          <target state="translated">Примечание 2. Работа с раскрывающимися списками (например, с элементами &amp;lt;select&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="a2c468fee63b93cfdf8f4899d1272df0051f3f42" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default action</source>
          <target state="translated">Примечание 3:Разрешение действия по умолчанию</target>
        </trans-unit>
        <trans-unit id="961ff8e09bdf3aa8b1b204afa8f0a5e5a818618c" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default click action</source>
          <target state="translated">Примечание 3:Разрешение действия по умолчанию</target>
        </trans-unit>
        <trans-unit id="0fc1a8ea173efa6a26682559149d35b58c72587a" translate="yes" xml:space="preserve">
          <source>Note 3: Enhanced functionality when jQuery is present</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e882f5d136c5c9ff8d8962c222ce417eb151f4" translate="yes" xml:space="preserve">
          <source>Note 3: Updating observable and non-observable property values</source>
          <target state="translated">Примечание 3:Обновление наблюдаемых и не наблюдаемых значений свойств</target>
        </trans-unit>
        <trans-unit id="7588edf8b51bfb005ba96690f74a34daa01047a1" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;as&amp;rdquo; to give an alias to &amp;ldquo;foreach&amp;rdquo; items</source>
          <target state="translated">Примечание 3. Использование as для присвоения псевдонима элементам foreach</target>
        </trans-unit>
        <trans-unit id="f42f724af26e21363687b0dda2ed01310ea7ab5a" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;text&amp;rdquo; without a container element</source>
          <target state="translated">Примечание 3. Использование &amp;laquo;текста&amp;raquo; без элемента-контейнера</target>
        </trans-unit>
        <trans-unit id="a3a20f1b394f93301d92f03c60d60e1549f40c99" translate="yes" xml:space="preserve">
          <source>Note 4: About an IE 6 whitespace quirk</source>
          <target state="translated">Примечание 4:О причудливой причёске пробела IE 6</target>
        </trans-unit>
        <trans-unit id="23419d68201af3e1cc15bff11daeeb0f79f2c99c" translate="yes" xml:space="preserve">
          <source>Note 4: Preventing the event from bubbling</source>
          <target state="translated">Примечание 4:Предотвращение образования пузырьков в событии</target>
        </trans-unit>
        <trans-unit id="3e526ff19533fbdea78f0e87c923669d66b13daf" translate="yes" xml:space="preserve">
          <source>Note 4: Using &amp;ldquo;afterRender&amp;rdquo;, &amp;ldquo;afterAdd&amp;rdquo;, and &amp;ldquo;beforeRemove&amp;rdquo;</source>
          <target state="translated">Примечание 4. Использование afterRender, afterAdd и beforeRemove</target>
        </trans-unit>
        <trans-unit id="2163a402155b39d7e2c760112b0647ef85484e62" translate="yes" xml:space="preserve">
          <source>Note 4: Using foreach without a container element</source>
          <target state="translated">Примечание 4:Использование форсажа без элемента контейнера</target>
        </trans-unit>
        <trans-unit id="c786ee828c774288377fdaba163a22ff298763be" translate="yes" xml:space="preserve">
          <source>Note 4: Using the value binding with the checked binding</source>
          <target state="translated">Примечание 4:Использование привязки значений с проверенной привязкой</target>
        </trans-unit>
        <trans-unit id="ea9b887209a1ac7ee930f38b5412044c510f0f34" translate="yes" xml:space="preserve">
          <source>Note 5: Dynamically choosing which template is used</source>
          <target state="translated">Примечание 5:Динамический выбор используемого шаблона</target>
        </trans-unit>
        <trans-unit id="3bff1a14c09530d5378f91032bbee6d975eeab75" translate="yes" xml:space="preserve">
          <source>Note 5: How array changes are detected and handled</source>
          <target state="translated">Замечание 5:Как обнаруживаются и обрабатываются изменения в массивах</target>
        </trans-unit>
        <trans-unit id="34f5c157ce0b3313df132dd29f97171e41483cf0" translate="yes" xml:space="preserve">
          <source>Note 5: Interaction with jQuery</source>
          <target state="translated">Примечание 5:Взаимодействие с jQuery</target>
        </trans-unit>
        <trans-unit id="7bdb9fca3db83a1d3859d688638577c6ee88ba7f" translate="yes" xml:space="preserve">
          <source>Note 6: Destroyed entries are hidden by default</source>
          <target state="translated">Примечание 6:Уничтоженные записи скрыты по умолчанию</target>
        </trans-unit>
        <trans-unit id="644fea2c743dda120843a65ecaaaaf53c3e37f54" translate="yes" xml:space="preserve">
          <source>Note 6: Hiding destroyed entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a357c555f225c8e2949ce0c275baf99efa923731" translate="yes" xml:space="preserve">
          <source>Note 6: Using jQuery.tmpl, an external string-based template engine</source>
          <target state="translated">Примечание 6:Использование jQuery.tmpl,внешнего строкового шаблонного механизма</target>
        </trans-unit>
        <trans-unit id="3b8b656336f81c4a99e466d9c14848a3f391c670" translate="yes" xml:space="preserve">
          <source>Note 7: Post-processing or animating the generated DOM elements</source>
          <target state="translated">Замечание 7:Постобработка или анимация сгенерированных элементов DOM</target>
        </trans-unit>
        <trans-unit id="d7bcd8dcb7fb8e81342016d8da6a4aa51bb7c3a9" translate="yes" xml:space="preserve">
          <source>Note 7: Using the Underscore.js template engine</source>
          <target state="translated">Примечание 7:Использование шаблонного движка Underscore.js</target>
        </trans-unit>
        <trans-unit id="cf25c2749f90cc1bc6823eee106a1d44e331c5bf" translate="yes" xml:space="preserve">
          <source>Note that any display style you&amp;rsquo;ve configured using your CSS rules will then apply (so CSS rules like x { display:table-row } work fine in conjunction with this binding).</source>
          <target state="translated">Обратите внимание, что любой стиль отображения, который вы настроили с помощью правил CSS, будет применяться (так что правила CSS, такие как x {display: table-row}, отлично работают в сочетании с этой привязкой).</target>
        </trans-unit>
        <trans-unit id="ab6b8705ccd46f28afca1a82cfbc0f5e3ac0c980" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using { notify: 'always' } causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f64d633bf252e83e6a30775ca9bae85c7feffc" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using {notify:'always'} causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="translated">Обратите внимание, что для автоматического удаления отклоненных значений из пользовательского интерфейса необходимо использовать .extend ({notify: 'always'}) для вычисляемого наблюдаемого. Без этого пользователь может ввести недопустимое значение newValue, которое при округлении дает неизменное значение valueToWrite. Затем, поскольку значение модели не будет изменяться, не будет уведомления об обновлении текстового поля в пользовательском интерфейсе. Использование {notify: 'always'} приводит к обновлению текстового поля (стиранию отклоненных значений), даже если вычисленное свойство не изменило значение.</target>
        </trans-unit>
        <trans-unit id="3928cd9c277ba72dbf69e81590702f90731185e0" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s necessary to specify viewModel: { instance: object }, and not just viewModel: object. This differentiates from the other cases below.</source>
          <target state="translated">Обратите внимание, что необходимо указать viewModel: {instance: object}, а не только viewModel: object. Это отличается от других случаев, приведенных ниже.</target>
        </trans-unit>
        <trans-unit id="fc236e1ebc6928f0c511903c41b30d3206eee445" translate="yes" xml:space="preserve">
          <source>Note that ko.toJSON accepts the same arguments as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;. For example, it can be useful to have a &amp;ldquo;live&amp;rdquo; representation of your view model data when debugging a Knockout application. To generate a nicely formatted display for this purpose, you can pass the &lt;em&gt;spaces&lt;/em&gt; argument into ko.toJSON and bind against your view model like:</source>
          <target state="translated">Обратите внимание, что ko.toJSON принимает те же аргументы, что и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; . Например, может быть полезно иметь &amp;laquo;живое&amp;raquo; представление данных вашей модели представления при отладке приложения Knockout. Чтобы создать красиво отформатированное отображение для этой цели, вы можете передать аргумент &lt;em&gt;пробелов&lt;/em&gt; в ko.toJSON и привязать его к вашей модели представления, например:</target>
        </trans-unit>
        <trans-unit id="8ed17d0a4365c067e0d0cca185b3a02627fee026" translate="yes" xml:space="preserve">
          <source>Note that only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned into each instance of the component. The container element (in this example, the &amp;lt;template&amp;gt; element), will &lt;em&gt;not&lt;/em&gt; be treated as part of the component template.</source>
          <target state="translated">Обратите внимание, что только узлы &lt;em&gt;внутри&lt;/em&gt; указанного элемента будут клонированы в каждый экземпляр компонента. Элемент контейнера (в этом примере элемент &amp;lt;template&amp;gt;) &lt;em&gt;не&lt;/em&gt; будет рассматриваться как часть шаблона компонента.</target>
        </trans-unit>
        <trans-unit id="5fd98c45b76cfffda7fb29aabbcc4105f3cac578" translate="yes" xml:space="preserve">
          <source>Note that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect &amp;ldquo;simple&amp;rdquo; movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an &amp;ldquo;delete&amp;rdquo; plus an &amp;ldquo;add&amp;rdquo; instead of a single &amp;ldquo;move&amp;rdquo;, and in that case the corresponding DOM elements will be torn down and recreated. Most developers won&amp;rsquo;t encounter this edge case, and even if you do, the end-user experience will usually be identical.</source>
          <target state="translated">Обратите внимание, что обнаружение переупорядочения не гарантируется: чтобы гарантировать быстрое выполнение алгоритма, он оптимизирован для обнаружения &amp;laquo;простых&amp;raquo; перемещений небольшого числа записей массива. Если алгоритм обнаруживает слишком много одновременных переупорядочений в сочетании с несвязанными вставками и удалениями, то для скорости он может рассматривать переупорядочивание как &amp;laquo;удаление&amp;raquo; плюс &amp;laquo;добавление&amp;raquo; вместо одного &amp;laquo;перемещения&amp;raquo;, и в этом случае соответствующий DOM элементы будут снесены и воссозданы. Большинство разработчиков не столкнутся с этим крайним случаем, и даже если вы столкнетесь с ним, взаимодействие с конечным пользователем обычно будет идентичным.</target>
        </trans-unit>
        <trans-unit id="8d4451b80b2ea7a6435a9b74cfdb3ee7699047bf" translate="yes" xml:space="preserve">
          <source>Note that the custom binding handler module does not inject anything into our ViewModel module, that is because it does not return anything. It just appends additional behavior to the knockout module.</source>
          <target state="translated">Обратите внимание,что пользовательский обработчик связывания ничего не вводит в наш модуль ViewModel,то есть потому,что он ничего не возвращает.Он просто добавляет дополнительное поведение к модулю нокаутирования.</target>
        </trans-unit>
        <trans-unit id="f85932fb55d2aff93e968e51c4da2dd6a4165c51" translate="yes" xml:space="preserve">
          <source>Note that the only difference between examples 3 and 4 is the optionsText value.</source>
          <target state="translated">Обратите внимание,что единственное различие между примерами 3 и 4-это значение опцииText.</target>
        </trans-unit>
        <trans-unit id="7c7ebe43d20e5eae9b1b095f73abef9b56607824" translate="yes" xml:space="preserve">
          <source>Note that this is not the UI itself: it doesn&amp;rsquo;t have any concept of buttons or display styles. It&amp;rsquo;s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</source>
          <target state="translated">Обратите внимание, что это не сам пользовательский интерфейс: в нем нет концепции кнопок или стилей отображения. Это также не постоянная модель данных - она ​​содержит несохраненные данные, с которыми работает пользователь. При использовании KO ваши модели представления представляют собой чистые объекты JavaScript, которые не знают HTML. Сохранение абстрактности модели представления позволяет ей оставаться простой, поэтому вы можете управлять более сложным поведением, не заблудившись.</target>
        </trans-unit>
        <trans-unit id="e87df4d38ae4cd5ed452a5004cb65d4e1e2d6c9d" translate="yes" xml:space="preserve">
          <source>Note that when KO renders a foreach binding, it automatically hides any objects marked with _destroy equal to true. So, you can have some kind of &amp;ldquo;delete&amp;rdquo; button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</source>
          <target state="translated">Обратите внимание, что когда KO визуализирует привязку foreach, он автоматически скрывает любые объекты, помеченные как _destroy равным true. Итак, у вас может быть какая-то кнопка &amp;laquo;удалить&amp;raquo;, которая вызывает метод destroy (someItem) в массиве, и это немедленно приведет к тому, что указанный элемент исчезнет из видимого пользовательского интерфейса. Позже, когда вы отправите граф объекта JSON в Rails, этот элемент также будет удален из базы данных (в то время как другие элементы массива будут вставлены или обновлены как обычно).</target>
        </trans-unit>
        <trans-unit id="e450c418845800c7f4318df4ef7374c24e1e9cb3" translate="yes" xml:space="preserve">
          <source>Note that whenever a component is removed (either because the name observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposed&lt;/a&gt;</source>
          <target state="translated">Обратите внимание , что всякий раз , когда компонент удаляется (либо потому , что имя наблюдаемого изменилось, или потому, что ограждающий поток управления связыванием удаляется весь элемент), удаленный компонент &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;расположен&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65025960631541c741b459bf73aacbde8d728d8d" translate="yes" xml:space="preserve">
          <source>Note that, typically, it&amp;rsquo;s best to perform direct DOM manipulation only through &lt;a href=&quot;custom-bindings&quot;&gt;custom bindings&lt;/a&gt; rather than acting on componentInfo.element from inside createViewModel. This leads to more modular, reusable code.</source>
          <target state="translated">Обратите внимание, что обычно лучше выполнять прямые манипуляции с DOM только через &lt;a href=&quot;custom-bindings&quot;&gt;пользовательские привязки,&lt;/a&gt; а не воздействовать на componentInfo.element изнутри createViewModel. Это приводит к более модульному и многократно используемому коду.</target>
        </trans-unit>
        <trans-unit id="2ab69f1d78a98533c1ec94379b4b6361aa3fd348" translate="yes" xml:space="preserve">
          <source>Note: &amp;ldquo;ifnot&amp;rdquo; is the same as a negated &amp;ldquo;if&amp;rdquo;</source>
          <target state="translated">Примечание. &amp;laquo;Ifnot&amp;raquo; - это то же самое, что отрицательное &amp;laquo;if&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="4d936c2871be1bf2c84824c58d0b50a0046f059e" translate="yes" xml:space="preserve">
          <source>Note: About HTML encoding</source>
          <target state="translated">Примечание:О кодировании HTML</target>
        </trans-unit>
        <trans-unit id="b3bd5be04d2a77b8fbb42b423e270ca8d27974f7" translate="yes" xml:space="preserve">
          <source>Note: Applying CSS classes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">Примечание. Применение классов CSS, имена которых не являются допустимыми именами переменных JavaScript.</target>
        </trans-unit>
        <trans-unit id="36e59391e4012e916e2efca315ab8a0ac9019825" translate="yes" xml:space="preserve">
          <source>Note: Applying attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">Примечание. Применение атрибутов, имена которых не являются допустимыми именами переменных JavaScript.</target>
        </trans-unit>
        <trans-unit id="40dbc8e3fecd759b1343c0ec1a8b8e04691b65e3" translate="yes" xml:space="preserve">
          <source>Note: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">Примечание. Применение стилей, имена которых не являются допустимыми именами переменных JavaScript.</target>
        </trans-unit>
        <trans-unit id="e4f74718bbd2f9c628b5720909d7d35fb25664a8" translate="yes" xml:space="preserve">
          <source>Note: Combining custom elements with regular bindings</source>
          <target state="translated">Примечание:Сочетание пользовательских элементов с обычными креплениями</target>
        </trans-unit>
        <trans-unit id="9e0ba81f0e79b9ea41b49ea9879be53189f0c81a" translate="yes" xml:space="preserve">
          <source>Note: Custom component loaders and custom elements</source>
          <target state="translated">Примечание:Пользовательские погрузчики компонентов и пользовательские элементы</target>
        </trans-unit>
        <trans-unit id="097a1159163b98735917888cc1f3edd2f432ff4d" translate="yes" xml:space="preserve">
          <source>Note: Custom elements and Internet Explorer 6 to 8</source>
          <target state="translated">Примечание:Пользовательские элементы и Internet Explorer от 6 до 8</target>
        </trans-unit>
        <trans-unit id="3452f7b8dfc0078e81c174fd19ab87bdb730cee7" translate="yes" xml:space="preserve">
          <source>Note: Custom elements cannot be self-closing</source>
          <target state="translated">Примечание:Пользовательские элементы не могут быть самозакрывающимися</target>
        </trans-unit>
        <trans-unit id="15b14d285bce9dc6c5d35d744705210b61bb5f03" translate="yes" xml:space="preserve">
          <source>Note: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;. For a single-select list, you can also read and write the selected option using &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt;.</source>
          <target state="translated">Примечание. Для списка с множественным выбором, чтобы установить, какие из параметров выбраны, или чтобы прочитать, какие из них выбраны, используйте &lt;a href=&quot;selectedoptions-binding&quot;&gt;привязку selectedOptions&lt;/a&gt; . Для списка с одним выбором вы также можете прочитать и записать выбранный параметр, используя &lt;a href=&quot;value-binding&quot;&gt;привязку значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea83c2531ea63cd46a3690a3c5a207b81e6a5f4" translate="yes" xml:space="preserve">
          <source>Note: For text boxes, drop-down lists, and all non-checkable form controls, use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; to read and write the element&amp;rsquo;s value, not the checked binding.</source>
          <target state="translated">Примечание. Для текстовых полей, раскрывающихся списков и всех непроверяемых элементов управления формы используйте &lt;a href=&quot;value-binding&quot;&gt;привязку значения&lt;/a&gt; для чтения и записи значения элемента, а не проверяемую привязку.</target>
        </trans-unit>
        <trans-unit id="5d17b383b870bd49e9fdcd437b821085b1249406" translate="yes" xml:space="preserve">
          <source>Note: If the user navigates to an entirely different web page, browsers do this without asking any code running in the page to clean up. So in this case no dispose functions will be invoked. This is OK because the browser will automatically release the memory used by all objects that were in use.</source>
          <target state="translated">Примечание:Если пользователь переходит на совершенно другую веб-страницу,браузеры делают это,не запрашивая никакого кода,запущенного на странице для очистки.Таким образом,в этом случае не будут вызываться никакие диспозиционные функции.Это нормально,потому что браузер автоматически освободит память,используемую всеми используемыми объектами.</target>
        </trans-unit>
        <trans-unit id="07830fa525672973fcad872d9479a00d3f0aae0b" translate="yes" xml:space="preserve">
          <source>Note: If you just want to prevent a computed observable from updating too often, see the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt;.</source>
          <target state="translated">Примечание. Если вы просто хотите предотвратить слишком &lt;a href=&quot;ratelimit-observable&quot;&gt;частое&lt;/a&gt; обновление вычисляемой наблюдаемой, см. Расширитель rateLimit .</target>
        </trans-unit>
        <trans-unit id="2a9907430c3d424ba976757e1f30ff936d301ef5" translate="yes" xml:space="preserve">
          <source>Note: If you&amp;rsquo;re working with checkboxes or radio buttons, use &lt;a href=&quot;checked-binding&quot;&gt;the checked binding&lt;/a&gt; to read and write your element&amp;rsquo;s checked state, not the value binding.</source>
          <target state="translated">Примечание. Если вы работаете с флажками или переключателями, используйте &lt;a href=&quot;checked-binding&quot;&gt;привязку&lt;/a&gt; с флажком для чтения и записи состояния проверки элемента, а не привязку значения.</target>
        </trans-unit>
        <trans-unit id="4013149ccb3f87d8ccbd0084efe996d0838d6311" translate="yes" xml:space="preserve">
          <source>Note: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;an example&lt;/a&gt; and &lt;a href=&quot;component-registration&quot;&gt;registration documentation&lt;/a&gt;.</source>
          <target state="translated">Примечание. В более реалистичных случаях вы обычно загружаете модели и шаблоны компонентов из внешних файлов, вместо того, чтобы жестко кодировать их при регистрации. См. &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;Пример&lt;/a&gt; и &lt;a href=&quot;component-registration&quot;&gt;регистрационную документацию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32f182a0b9cb163063cf0210deaf0ef0bfd93fe2" translate="yes" xml:space="preserve">
          <source>Note: Integrating with browserify</source>
          <target state="translated">Примечание:Интеграция с браузером</target>
        </trans-unit>
        <trans-unit id="f5847643b33a4979437c074b1772f4baa9785665" translate="yes" xml:space="preserve">
          <source>Note: Knockout does not guarantee that the beforeChange and change events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it&amp;rsquo;s up to you to use a subscription to capture and track it.</source>
          <target state="translated">Примечание. Knockout не гарантирует, что события beforeChange и change будут происходить парами, поскольку другие части вашего кода могут вызывать любое событие по отдельности. Если вам нужно отслеживать предыдущее значение наблюдаемого, вы должны использовать подписку для его захвата и отслеживания.</target>
        </trans-unit>
        <trans-unit id="129196d92bb0c541677b616e7f9a98c3cc7e94cf" translate="yes" xml:space="preserve">
          <source>Note: Letting the user select from arbitrary JavaScript objects</source>
          <target state="translated">Примечание:Позволяя пользователю выбирать из произвольных объектов JavaScript</target>
        </trans-unit>
        <trans-unit id="140ebf77e1d231f3e690deb8c6320dc6a123f7b1" translate="yes" xml:space="preserve">
          <source>Note: Passing markup to components</source>
          <target state="translated">Примечание:Передача разметки компонентам</target>
        </trans-unit>
        <trans-unit id="23a3c1f00b1235c3c83812b480d0211ea6db2687" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30af1206ec552873ed1d054e17b9fad1512a18" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes with a namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bd54c6d3ace6bef5b8658344fb90ff9e01f394" translate="yes" xml:space="preserve">
          <source>Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; and the &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generator-ko&lt;/a&gt; generator. Blog post coming soon.</source>
          <target state="translated">Примечание. Поскольку оптимизатор r.js очень гибкий, он имеет множество параметров и может занять некоторое время для настройки. Вы можете начать с готового примера компонентов Knockout, оптимизируемых с помощью r.js, и в этом случае см. &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; и &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;генератор generator-ko&lt;/a&gt; . Пост в блоге скоро появится.</target>
        </trans-unit>
        <trans-unit id="54b8295547dbd8dd296d604963578e9c5ba48c73" translate="yes" xml:space="preserve">
          <source>Note: Supporting virtual elements</source>
          <target state="translated">Примечание:Поддержка виртуальных элементов</target>
        </trans-unit>
        <trans-unit id="dd0ab8e16c1919532cc43e7aa1a6b879552640b4" translate="yes" xml:space="preserve">
          <source>Note: Template-only components</source>
          <target state="translated">Примечание:Компоненты только для шаблонов</target>
        </trans-unit>
        <trans-unit id="b05caaa87623573294cec899219e7deabd2359f2" translate="yes" xml:space="preserve">
          <source>Note: To control which element in a single-select drop-down list is selected, you can use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; instead.</source>
          <target state="translated">Примечание. Чтобы указать, какой элемент в раскрывающемся списке с одним выбором выбран, вместо этого можно использовать &lt;a href=&quot;value-binding&quot;&gt;привязку значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c337589312cb228d7babfb1d2ebfd714455f588c" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; and &amp;ldquo;ifnot&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccfb58e2925ffb0818561abbfa7a1e8de927a56" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; without a container element</source>
          <target state="translated">Примечание. Использование &amp;laquo;if&amp;raquo; без элемента-контейнера</target>
        </trans-unit>
        <trans-unit id="71884929340b18d767f7c056cf2d3ecb21755e40" translate="yes" xml:space="preserve">
          <source>Note: Using arbitrary JavaScript expressions</source>
          <target state="translated">Примечание:Использование произвольных выражений JavaScript</target>
        </trans-unit>
        <trans-unit id="4403ac4eff9ff864673188e035a34bcf003869af" translate="yes" xml:space="preserve">
          <source>Note: Using component without a container element</source>
          <target state="translated">Примечание:Использование компонента без элемента контейнера</target>
        </trans-unit>
        <trans-unit id="1d0bc144231da12d70fed9c1daabfaf618fbc1bf" translate="yes" xml:space="preserve">
          <source>Note: Using functions and expressions to control element visibility</source>
          <target state="translated">Примечание:Использование функций и выражений для управления видимостью элементов</target>
        </trans-unit>
        <trans-unit id="e11057c5759e08cd6106a99f6b95d00bd0ed796b" translate="yes" xml:space="preserve">
          <source>Note: Using reserved words as attribute names in older browsers</source>
          <target state="translated">Примечание:Использование зарезервированных слов в качестве названий атрибутов в старых браузерах</target>
        </trans-unit>
        <trans-unit id="b01856c6cdf3d733f8df97b227257f8bdea3947d" translate="yes" xml:space="preserve">
          <source>Note: Using the &amp;ldquo;class&amp;rdquo; and &amp;ldquo;css&amp;rdquo; bindings at the same time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f815e27b345ec1efada4bea3643d51e789c47670" translate="yes" xml:space="preserve">
          <source>Note: Why circular dependencies aren&amp;rsquo;t meaningful</source>
          <target state="translated">Примечание: почему циклические зависимости не имеют смысла</target>
        </trans-unit>
        <trans-unit id="c8a2ea7aa039e3cc85d86b844a0aed9f68c466c1" translate="yes" xml:space="preserve">
          <source>Note: ko.computedContext.getDependenciesCount() is equivalent to calling getDependenciesCount() on the computed observable itself. The reason that it also exists on ko.computedContext is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</source>
          <target state="translated">Замечание:ko.computedContext.getDependenciesCount()эквивалентен вызову getDependenciesCount()на самом наблюдаемом вычислении.Причина,по которой она также существует в ko.computedContext,заключается в том,чтобы обеспечить способ подсчета зависимостей во время первого вычисления,еще до того,как вычисленная наблюдаемая будет построена.</target>
        </trans-unit>
        <trans-unit id="102fb6d0d403a0d599dae72a7da85eadcf53fd8f" translate="yes" xml:space="preserve">
          <source>Note: you don&amp;rsquo;t actually have to provide both init &lt;em&gt;and&lt;/em&gt; update callbacks &amp;mdash; you can just provide one or the other if that&amp;rsquo;s all you need.</source>
          <target state="translated">Примечание: на самом деле вам не обязательно предоставлять оба обратных вызова для инициализации &lt;em&gt;и&lt;/em&gt; обновления - вы можете просто указать один или другой, если это все, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="e652fe47c807dd0369ac321e0b23b49fe4d6ad4e" translate="yes" xml:space="preserve">
          <source>Notice how, instead of using APIs like domElement.firstChild, we&amp;rsquo;re now using ko.virtualElements.firstChild(domOrVirtualElement). The randomOrder binding will now correctly work with virtual elements, e.g., &amp;lt;!-- ko randomOrder: true --&amp;gt;...&amp;lt;!-- /ko --&amp;gt;.</source>
          <target state="translated">Обратите внимание, что вместо использования таких API, как domElement.firstChild, мы теперь используем ko.virtualElements.firstChild (domOrVirtualElement). Привязка randomOrder теперь будет корректно работать с виртуальными элементами, например, &amp;lt;! - ko randomOrder: true -&amp;gt; ... &amp;lt;! - / ko -&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="881524b74eec619b61fa6cd558f217630d0d2032" translate="yes" xml:space="preserve">
          <source>Notice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file some/module.js could be declared as:</source>
          <target state="translated">Обратите внимание,что пара viewmodel/template не указана.Сам модуль AMD может предоставлять пару viewmodel/template,используя любой из вышеперечисленных форматов определений.Например,файл some/module.js может быть объявлен как:</target>
        </trans-unit>
        <trans-unit id="3ffaab6a02fcd20ec4acba9eb285ffb74bb339fc" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;em&gt;not&lt;/em&gt; intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;не&lt;/em&gt; предназначено для полной замены полного набора обычных API DOM. Knockout предоставляет только минимальный набор API-интерфейсов виртуальных элементов, чтобы можно было выполнять преобразования, необходимые при реализации привязок потока управления.</target>
        </trans-unit>
        <trans-unit id="d64ee77ed37778a54c73db4a866a3e17bd92900f" translate="yes" xml:space="preserve">
          <source>Notice the string value 'employee' associated with as. Now anywhere inside this foreach loop, bindings in your child templates will be able to refer to employee to access the employee object being rendered.</source>
          <target state="translated">Обратите внимание на строковое значение &quot;сотрудник&quot;,связанное с as.Теперь в любом месте внутри этого петли фораха,привязки в ваших дочерних шаблонах смогут ссылаться на сотрудника для доступа к объекту сотрудника,который визуализируется.</target>
        </trans-unit>
        <trans-unit id="e3a7345017a99ea270b44a59fd49d8ee6f486954" translate="yes" xml:space="preserve">
          <source>Now any descendant binding will be able to refer to person to access this context object. This can be especially useful in scenarios where you have nested contexts and you need to refer to something declared at a higher level in the hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839a7efc6c32176be9d0069eb8544d9601b7d394" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item that is being rendered from the people array. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ac7108123b5f245ef9f5df9d943f636924637d" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item, from the people array, that is being rendered. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="translated">Теперь в любом месте внутри этого цикла форач-цикла привязки смогут ссылаться на человека для доступа к текущему элементу массива,из массива people,который визуализируется.Это может быть особенно полезно в сценариях,где у вас есть вложенные блоки фораха,и вам нужно обратиться к элементу,объявленному на более высоком уровне в иерархии.Например:</target>
        </trans-unit>
        <trans-unit id="5673fdafd7626621793c97c3c05163e839f06fa8" translate="yes" xml:space="preserve">
          <source>Now like-or-dislike can be consumed in the same way as before, using either a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">Теперь лайки и антипатии можно использовать так же, как и раньше, используя &lt;a href=&quot;component-binding&quot;&gt;привязку компонента&lt;/a&gt; или &lt;a href=&quot;component-custom-elements&quot;&gt;настраиваемый элемент&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6480651531660c84a55576d27e9ed7d8351ebcd4" translate="yes" xml:space="preserve">
          <source>Now the component is operating, and can remain on-screen for as long as needed.</source>
          <target state="translated">Теперь компонент работает и может оставаться на экране столько,сколько потребуется.</target>
        </trans-unit>
        <trans-unit id="1ee0ffaf853c8407a424f11a481c7a0f71be59bc" translate="yes" xml:space="preserve">
          <source>Now there won&amp;rsquo;t be an error. However, it still won&amp;rsquo;t work properly, because our randomOrder binding is coded using normal DOM API calls (firstChild, appendChild, etc.) which don&amp;rsquo;t understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it&amp;rsquo;s not going to work properly!</source>
          <target state="translated">Теперь ошибки не будет. Однако он по-прежнему не будет работать должным образом, потому что наша привязка randomOrder кодируется с использованием обычных вызовов API DOM (firstChild, appendChild и т. Д.), Которые не понимают виртуальные элементы. Это причина, по которой KO требует от вас явного согласия на поддержку виртуальных элементов: если ваша настраиваемая привязка не закодирована с использованием API виртуальных элементов, она не будет работать должным образом!</target>
        </trans-unit>
        <trans-unit id="f68b7fa0902e29163231a8e1b14bcdcd84f1f8c2" translate="yes" xml:space="preserve">
          <source>Now this is registered, you can reference components with any name (without preregistering them), e.g.:</source>
          <target state="translated">Теперь это зарегистрировано,вы можете ссылаться на компоненты с любым именем (без предварительной регистрации),например:</target>
        </trans-unit>
        <trans-unit id="a9abe577afb6560e727b712ab6c0be7874d881af" translate="yes" xml:space="preserve">
          <source>Now we can push a bunch of items into the data array without worrying about causing excessive UI or computed updates. The deferred extender can be applied to any type of observable, including observable arrays and computed observables.</source>
          <target state="translated">Теперь мы можем затолкать кучу элементов в массив данных,не беспокоясь о том,что это приведет к избыточному UI или вычисленным обновлениям.Отсроченный расширитель может быть применен к любому типу наблюдаемых объектов,включая наблюдаемые массивы и вычисляемые наблюдаемые объекты.</target>
        </trans-unit>
        <trans-unit id="fda568a2d060f080b79888ad65ca98b3f5cb075b" translate="yes" xml:space="preserve">
          <source>Now you can bind click like this:</source>
          <target state="translated">Теперь вы можете связать клик вот так:</target>
        </trans-unit>
        <trans-unit id="3482f1f45804606e4ae189fe1f25ad32491bef16" translate="yes" xml:space="preserve">
          <source>Now you can bind it like this:</source>
          <target state="translated">Теперь ты можешь связать его вот так:</target>
        </trans-unit>
        <trans-unit id="40d230de5c1460b029face137aa50f89cfff29a6" translate="yes" xml:space="preserve">
          <source>Now you can both read and write the &amp;ldquo;focusedness&amp;rdquo; of an element by binding it to an observable:</source>
          <target state="translated">Теперь вы можете читать и записывать &amp;laquo;сфокусированность&amp;raquo; элемента, привязав его к наблюдаемому:</target>
        </trans-unit>
        <trans-unit id="6de72398a9643fb68b8c419f88d72e0cc3455cae" translate="yes" xml:space="preserve">
          <source>Now you can change pageIndex and pageSize as many times as you like, and the Ajax call will only happen once after you release your thread back to the JavaScript runtime.</source>
          <target state="translated">Теперь вы можете менять pageIndex и pageSize столько раз,сколько захотите,и вызов Ajax будет происходить только один раз после того,как вы выпустите поток обратно во время выполнения JavaScript.</target>
        </trans-unit>
        <trans-unit id="18f2aeef65d906e4473cfba8e914455277450ce1" translate="yes" xml:space="preserve">
          <source>Now you can include a template in your view like this:</source>
          <target state="translated">Теперь вы можете включить шаблон в свой вид таким образом:</target>
        </trans-unit>
        <trans-unit id="cdd6cfad8e975c0657b6d67e96fe52c3a48e9aa8" translate="yes" xml:space="preserve">
          <source>Now you can use this binding as follows:</source>
          <target state="translated">Теперь вы можете использовать эту привязку следующим образом:</target>
        </trans-unit>
        <trans-unit id="4c9b28edefdb5a8470622ecf317b145edc4837c3" translate="yes" xml:space="preserve">
          <source>Now you could bind UI elements to it, e.g.:</source>
          <target state="translated">Теперь ты можешь привязать к нему элементы пользовательского интерфейса,например:</target>
        </trans-unit>
        <trans-unit id="02d8cd1aeb019148b74c77705355b7163631d297" translate="yes" xml:space="preserve">
          <source>Now your binding in UI elements becomes a method call, e.g.:</source>
          <target state="translated">Теперь ваша привязка в элементах пользовательского интерфейса становится вызовом метода,например:</target>
        </trans-unit>
        <trans-unit id="f030ce6c537ab6ebb0bf1ffd14b3a4657684bade" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the data and event objects to your function literal, which are then available to be passed to your handler.</source>
          <target state="translated">Теперь KO передаст буквально данные и объекты событий в вашу функцию,которые затем будут доступны для передачи вашему обработчику.</target>
        </trans-unit>
        <trans-unit id="bd13b366a6bf0e481a78cb8415ed4850572371a6" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the event to your function literal, which is then available to be passed to your handler.</source>
          <target state="translated">Теперь КО передаст событие буквально вашей функции,которая затем будет доступна для передачи вашему обработчику.</target>
        </trans-unit>
        <trans-unit id="75b3699fea4994e40b27cf8acdc9dbd74ac8d3b7" translate="yes" xml:space="preserve">
          <source>Now, a single event handler is attached at a higher level and handles clicks against any links with the remove class. This method has the added benefit of automatically handling additional links that are dynamically added to the document (perhaps as the result of an item being added to an observableArray).</source>
          <target state="translated">Теперь один обработчик событий подключается на более высоком уровне и обработчик кликает на любые ссылки с классом удаления.Этот метод имеет дополнительное преимущество,заключающееся в автоматической обработке дополнительных ссылок,которые динамически добавляются в документ (возможно,в результате добавления элемента в наблюдаемый массив).</target>
        </trans-unit>
        <trans-unit id="bd680cea0a442ee897310989fbae69d04e84c88d" translate="yes" xml:space="preserve">
          <source>Now, acceptedNumericValue will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating acceptedNumericValue.</source>
          <target state="translated">Теперь,acceptNumericValue будет содержать только числовые значения,а любые другие введенные значения будут вызывать появление сообщения о проверке вместо обновления acceptNumericValue.</target>
        </trans-unit>
        <trans-unit id="e0f38308579b18f9d4a6971e8cbcbf8290d174a2" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say the data is updated to be without any typos:</source>
          <target state="translated">Теперь предположим, что данные обновлены без каких-либо опечаток:</target>
        </trans-unit>
        <trans-unit id="540f67e29415bf23f1b5c0759292b5c41747e4c8" translate="yes" xml:space="preserve">
          <source>Now, moving your mouse pointer on or off of the first element will invoke methods on the view model to toggle the detailsEnabled observable. The second element reacts to changes to the value of detailsEnabled by either showing or hiding itself.</source>
          <target state="translated">Теперь,перемещая указатель мыши на первый элемент или наоборот,вы будете вызывать методы на модели просмотра,чтобы переключить DetailEnabled observable.Второй элемент реагирует на изменение значения DetailEnabled,показывая или скрывая себя.</target>
        </trans-unit>
        <trans-unit id="3736efca9ddde7db65691710604802d1a6d9f093" translate="yes" xml:space="preserve">
          <source>Now, the text will switch between &amp;ldquo;expensive&amp;rdquo; and &amp;ldquo;affordable&amp;rdquo; as needed whenever price changes.</source>
          <target state="translated">Теперь текст будет переключаться между &amp;laquo;дорогим&amp;raquo; и &amp;laquo;доступным&amp;raquo; по мере необходимости при изменении цены.</target>
        </trans-unit>
        <trans-unit id="088a5e50ba0e6a14fe36eaa6f26ee4c53c1aeffe" translate="yes" xml:space="preserve">
          <source>Now, to use this component, you can reference it from any other view in your application, either using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or using a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;. Here&amp;rsquo;s a live example that uses it as a custom element:</source>
          <target state="translated">Теперь, чтобы использовать этот компонент, вы можете ссылаться на него из любого другого представления в своем приложении, используя &lt;a href=&quot;component-binding&quot;&gt;привязку компонента&lt;/a&gt; или &lt;a href=&quot;component-custom-elements&quot;&gt;пользовательский элемент&lt;/a&gt; . Вот живой пример, который использует его как настраиваемый элемент:</target>
        </trans-unit>
        <trans-unit id="4245c3b686b0a2dc1aff4f4de7c87fcd1a33a5a7" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="translated">Теперь, когда пользователь вводит новую цену, текстовое поле немедленно обновляется, чтобы показать, что оно отформатировано с использованием символа валюты и двух десятичных знаков, независимо от того, в каком формате они ввели значение. Это дает отличное взаимодействие с пользователем, потому что пользователь видит, как программное обеспечение восприняло ввод их данных как цену. Они знают, что не могут ввести более двух десятичных знаков, потому что, если они попытаются это сделать, дополнительные десятичные знаки немедленно удаляются. Точно так же они не могут вводить отрицательные значения, потому что обратный вызов записи удаляет любой знак минус.</target>
        </trans-unit>
        <trans-unit id="2f11f252395402a0b2ef2d05d00513a9da6f819b" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac3b49a89e1b1842cca9897c548ac837711b286" translate="yes" xml:space="preserve">
          <source>OK, how do you use it?</source>
          <target state="translated">Хорошо,как ты им пользуешься?</target>
        </trans-unit>
        <trans-unit id="42801dc107e69330fc6f28652e42c67848f2e3d3" translate="yes" xml:space="preserve">
          <source>OK, you&amp;rsquo;ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as &lt;em&gt;observables&lt;/em&gt;, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</source>
          <target state="translated">Хорошо, вы видели, как создать базовую модель представления и как отобразить одно из ее свойств с помощью привязки. Но одним из ключевых преимуществ KO является то, что он автоматически обновляет ваш пользовательский интерфейс при изменении модели представления. Как KO может узнать об изменении частей вашей модели представления? Ответ: вам нужно объявить свойства вашей модели как &lt;em&gt;наблюдаемые&lt;/em&gt; , потому что это специальные объекты JavaScript, которые могут уведомлять подписчиков об изменениях и могут автоматически обнаруживать зависимости.</target>
        </trans-unit>
        <trans-unit id="49ef41d692a31c86e07e70c90965e70e376a7d17" translate="yes" xml:space="preserve">
          <source>Observable Arrays</source>
          <target state="translated">Наблюдаемые массивы</target>
        </trans-unit>
        <trans-unit id="46996089e8555e78352bfb82f74492b629adadd3" translate="yes" xml:space="preserve">
          <source>Observable arrays</source>
          <target state="translated">Наблюдаемые массивы</target>
        </trans-unit>
        <trans-unit id="ae2926058ff9077b5ef1fa67cef194213c7bb29a" translate="yes" xml:space="preserve">
          <source>Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the keys mapping:</source>
          <target state="translated">Наблюдаемые массивы,генерируемые плагином отображения,дополнены несколькими функциями,которые могут использовать отображение ключей:</target>
        </trans-unit>
        <trans-unit id="8136b5b444e74956953de6d7e21de45a7208ed8b" translate="yes" xml:space="preserve">
          <source>Observables</source>
          <target state="translated">Observables</target>
        </trans-unit>
        <trans-unit id="b11d034f48ad50b05bcdbc51fb2bc638d49916bb" translate="yes" xml:space="preserve">
          <source>Observables and dependency tracking</source>
          <target state="translated">Наблюдения и отслеживание зависимостей</target>
        </trans-unit>
        <trans-unit id="621445c3740dea16b530b18f93e077809839e366" translate="yes" xml:space="preserve">
          <source>Observing only certain properties using &amp;ldquo;observe&amp;rdquo;</source>
          <target state="translated">Наблюдение только за определенными свойствами с помощью &amp;laquo;наблюдать&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="5820d44b10477929b579ab80e1dfa0b99895aa33" translate="yes" xml:space="preserve">
          <source>Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout&amp;rsquo;s core value types. You can define custom functions on any of the following types:</source>
          <target state="translated">Иногда вы можете найти возможности оптимизировать свой код, добавив новые функции к типам основных ценностей Knockout. Вы можете определить пользовательские функции для любого из следующих типов:</target>
        </trans-unit>
        <trans-unit id="31449567d7f21edc1facbf4447d941d2b4798e0a" translate="yes" xml:space="preserve">
          <source>Of course, inside the create callback you can do another call to ko.mapping.fromJS if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;:</source>
          <target state="translated">Конечно, внутри обратного вызова create вы можете сделать еще один вызов ko.mapping.fromJS, если хотите. Типичный вариант использования может быть, если вы хотите расширить исходный объект JavaScript некоторыми дополнительными &lt;a href=&quot;computedobservables&quot;&gt;вычисляемыми наблюдаемыми&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0ab11f1d7ae1b763bfdbe3807e0dd9ad83af6511" translate="yes" xml:space="preserve">
          <source>Of course, this is a lot of code at first glance, but once you&amp;rsquo;ve created your custom bindings they can very easily be reused in many places.</source>
          <target state="translated">Конечно, на первый взгляд это очень много кода, но после того, как вы создали свои пользовательские привязки, их можно очень легко использовать повторно во многих местах.</target>
        </trans-unit>
        <trans-unit id="078756006ae7a0012d20c159834f8a64afd1f3de" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) &amp;ndash; doing this puts them into a group where only one can be selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f700094b19d2adf8500f72e2a84b3d54353191" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) - doing this puts them into a group where only one can be selected.</source>
          <target state="translated">Конечно, это наиболее полезно, когда у вас есть несколько элементов переключателя, привязанных к одному свойству модели. Чтобы гарантировать, что только &lt;em&gt;одна&lt;/em&gt; из этих радиокнопок может быть отмечена в любой момент времени, вы должны установить для всех их атрибутов имени произвольное общее значение (например, значение FlavourGroup в предыдущем примере) - это помещает их в группу, где может быть выбран только один.</target>
        </trans-unit>
        <trans-unit id="c68f1c87405be42eacbbbce0c48e9cb553450844" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.1.0).</source>
          <target state="translated">Конечно,x.y.z должен быть заменен номером версии загружаемого скрипта Knockout (например,knockout-3.1.0).</target>
        </trans-unit>
        <trans-unit id="a449e9eab7822a64523bbf6509430f2bd5f4edd2" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.5.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa33e822518a764cd6aa37dbe83b7633c72e02d" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with.</source>
          <target state="translated">Конечно,вы можете произвольно гнездить любое количество креплений форачков вместе с другими креплениями контрольного потока,например,если и с ними.</target>
        </trans-unit>
        <trans-unit id="a81c8bc825594ecd549001af937392796036a625" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with and using bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f4b8ea9e954eebaa70e0a9c65d26766627d86b" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="translated">Конечно, вы можете произвольно вкладывать привязки вместе с другими привязками потока управления, такими как &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; и &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3aa665242655dd6d40a7753ba8a1bef582d3cc" translate="yes" xml:space="preserve">
          <source>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</source>
          <target state="translated">Конечно,при желании можно создать целые цепочки вычисляемых наблюдаемых объектов.Например,вы могли бы:</target>
        </trans-unit>
        <trans-unit id="3b3b30a86f9e0ac4c5bc2f098d8abb20f874f834" translate="yes" xml:space="preserve">
          <source>Of course, you don&amp;rsquo;t have to worry about releasing any event handlers created by standard Knockout bindings in your view, as KO automatically unregisters them when the elements are removed.</source>
          <target state="translated">Конечно, вам не нужно беспокоиться об освобождении любых обработчиков событий, созданных стандартными привязками Knockout в вашем представлении, поскольку KO автоматически отменяет их регистрацию при удалении элементов.</target>
        </trans-unit>
        <trans-unit id="b7bdef4ca5fa385742d68cfa6579c30b6c61548d" translate="yes" xml:space="preserve">
          <source>On this page, you&amp;rsquo;ll learn about the first of these three. But before that, let&amp;rsquo;s examine the MVVM pattern and the concept of a &lt;em&gt;view model&lt;/em&gt;.</source>
          <target state="translated">На этой странице вы узнаете о первом из этих трех. Но перед этим давайте рассмотрим шаблон MVVM и концепцию &lt;em&gt;модели представления&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1bc6631468dfada790b80fb194db5f58e531526" translate="yes" xml:space="preserve">
          <source>Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</source>
          <target state="translated">Дополнительно можно передать второй параметр,чтобы определить,в какой части документа нужно искать атрибуты привязки данных.Например,ko.applyBindings(myViewModel,document.getElementById('someElementId')).Это ограничивает активацию элемента с ID someElementId и его потомков,что полезно,если вы хотите иметь несколько моделей просмотра и ассоциировать каждую из них с различным регионом страницы.</target>
        </trans-unit>
        <trans-unit id="1765a06342825b17a9e403b215e90bde7a3b1c92" translate="yes" xml:space="preserve">
          <source>Optionally, your viewmodel class may have a dispose function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM (e.g., because the corresponding item was removed from a foreach, or an if binding has become false).</source>
          <target state="translated">В качестве опции,ваш класс Viewmodel может иметь функцию диспозиции.Если она реализована,то Knockout будет вызывать ее всякий раз,когда компонент разбирается и удаляется из DOM (например,потому что соответствующий элемент был удален из foreach,или если привязка стала ложной).</target>
        </trans-unit>
        <trans-unit id="a4e4c99b9180d995ef38e38e86d46c2c354b0131" translate="yes" xml:space="preserve">
          <source>Or if you really don&amp;rsquo;t like the hackiness of the document.createElement call, then you could use a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; for your top-level component instead of a custom element. As long as all other components are registered before your ko.applyBindings call, they can be used as custom elements on IE6-8 without futher trouble:</source>
          <target state="translated">Или, если вам действительно не нравится хакерство вызова document.createElement, вы можете использовать &lt;a href=&quot;component-binding&quot;&gt;привязку компонента&lt;/a&gt; для вашего компонента верхнего уровня вместо настраиваемого элемента. Пока все остальные компоненты зарегистрированы до вашего вызова ko.applyBindings, их можно без проблем использовать в качестве настраиваемых элементов в IE6-8:</target>
        </trans-unit>
        <trans-unit id="4c54970fdc4cfe5ce955d0d99cddf7a056c2d8f2" translate="yes" xml:space="preserve">
          <source>Or, at least call document.createElement('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements. You can ignore the result of the createElement call &amp;mdash; all that matters is that you have called it.</source>
          <target state="translated">Или, по крайней мере, вызовите document.createElement ('your-component') &lt;em&gt;до&lt;/em&gt; того, как синтаксический анализатор HTML увидит какие-либо элементы &amp;lt;your-component&amp;gt;. Вы можете игнорировать результат вызова createElement - важно только то, что вы его вызвали.</target>
        </trans-unit>
        <trans-unit id="888fa89b9dae94f674ec75254af5184f71fd7fb9" translate="yes" xml:space="preserve">
          <source>Or, if the component has no viewmodel, then the view is bound to any params you&amp;rsquo;ve supplied to the component binding.</source>
          <target state="translated">Или, если компонент не имеет модели представления, тогда представление привязано к любым параметрам, которые вы указали для привязки компонента.</target>
        </trans-unit>
        <trans-unit id="4ba0856e67eb87e7f52493db1a23ca2ca82c78f6" translate="yes" xml:space="preserve">
          <source>Or, if you don&amp;rsquo;t want to use jQuery, you can use any other mechanism for loading or saving JSON data. So, all Knockout needs to help you do is:</source>
          <target state="translated">Или, если вы не хотите использовать jQuery, вы можете использовать любой другой механизм для загрузки или сохранения данных JSON. Итак, все, что вам нужно от Knockout, это:</target>
        </trans-unit>
        <trans-unit id="f699ec4a263d96ea6e8330f504cbc76acb04a6da" translate="yes" xml:space="preserve">
          <source>Or, if you just want the plain JavaScript object graph &lt;em&gt;before&lt;/em&gt; serialization, use ko.toJS as follows:</source>
          <target state="translated">Или, если вам просто нужен простой граф объектов JavaScript &lt;em&gt;перед&lt;/em&gt; сериализацией, используйте ko.toJS следующим образом:</target>
        </trans-unit>
        <trans-unit id="0f545ea154ca17421845c1c4d49c0c277020bb7c" translate="yes" xml:space="preserve">
          <source>Other browsers, and newer versions of IE, don&amp;rsquo;t have this quirk.</source>
          <target state="translated">Другие браузеры и более новые версии IE не имеют этой особенности.</target>
        </trans-unit>
        <trans-unit id="a7d69219a1d86b1de7eaa38435a5ef6a295349c2" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="translated">Другие технологии могут зависеть от предположения, что определенные элементы имеют имена, даже если имена могут не иметь значения, когда вы используете KO. Например, в настоящее время &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;проверка jQuery&lt;/a&gt; будет проверять только элементы с именами. Чтобы использовать это с пользовательским интерфейсом Knockout, иногда необходимо применить привязку uniqueName, чтобы не запутать проверку jQuery. См. &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;Пример использования проверки jQuery с KO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1efa09ae2cb2e40a26065664566609723294929" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b76426a4b4527523a89c8447c24b37b42bba21f" translate="yes" xml:space="preserve">
          <source>Overriding the clean-up of external data</source>
          <target state="translated">Переопределение очистки внешних данных</target>
        </trans-unit>
        <trans-unit id="9c6c53d0c3ba99a8159d80012914470bb2bd02f8" translate="yes" xml:space="preserve">
          <source>Overview of AMD</source>
          <target state="translated">Обзор драмов РА</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="ee9bc64679c883d8315ef21591e760cbc38b8e61" translate="yes" xml:space="preserve">
          <source>Pass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you&amp;rsquo;re using foreach, Knockout will invoke your afterRender callback for each item added to your observable array. For example,</source>
          <target state="translated">Передайте ссылку на функцию (либо литерал функции, либо укажите имя функции в вашей модели представления), и Knockout вызовет ее сразу после визуализации или повторной визуализации вашего шаблона. Если вы используете foreach, Knockout будет вызывать ваш обратный вызов afterRender для каждого элемента, добавленного в ваш наблюдаемый массив. Например,</target>
        </trans-unit>
        <trans-unit id="2a4fc664fb015dd2b90366bae7b7c6166a290c0f" translate="yes" xml:space="preserve">
          <source>Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.</source>
          <target state="translated">Передайте массив,который вы хотите выполнить итерацию.В результате привязки для каждой записи будет выведена секция разметки.</target>
        </trans-unit>
        <trans-unit id="ac917217788ea4daf427e3524d9e686c7fae6951" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to enable the uniqueName binding, as in the preceding example.</source>
          <target state="translated">Передайте значение true (или некоторое значение,оцениваемое как true),чтобы включить привязку uniqueName,как в предыдущем примере.</target>
        </trans-unit>
        <trans-unit id="48fbf79eab4d275311cd306a9da00e04a2da8f50" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to focus the associated element. Otherwise, the associated element will be unfocused.</source>
          <target state="translated">Передайте значение true (или некоторое значение,которое оценивается как истинное),чтобы сфокусировать связанный с ним элемент.В противном случае,связанный с ним элемент будет сфокусирован.</target>
        </trans-unit>
        <trans-unit id="b9cfb6f55eaea0baeb940c302cc0775a2e4e29f0" translate="yes" xml:space="preserve">
          <source>Passing markup into components</source>
          <target state="translated">Передача разметки на компоненты</target>
        </trans-unit>
        <trans-unit id="7b31412042fa68bceb2962653f184dcb45a1c94c" translate="yes" xml:space="preserve">
          <source>Passing observable expressions</source>
          <target state="translated">Проходящие наблюдаемые выражения</target>
        </trans-unit>
        <trans-unit id="3157744f3e6488a569fb33f59900039dd87730b5" translate="yes" xml:space="preserve">
          <source>Passing parameters</source>
          <target state="translated">Параметры передачи</target>
        </trans-unit>
        <trans-unit id="52fe29993c9eadbd173dbd6bdcce3efe7de4a21e" translate="yes" xml:space="preserve">
          <source>Performance is O(1) in most cases, i.e., there&amp;rsquo;s basically no performance implication at all, because for straightforward operations, (push, splice, etc.) Knockout supplies the change log without running any difference algorithm. Knockout only falls back on an algorithm if you&amp;rsquo;ve made an arbitrary change without using a typical array mutation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c30396c874cdc27bd19277aa1a80c77188378ef" translate="yes" xml:space="preserve">
          <source>Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout&amp;rsquo;s native DOM-based templating (i.e., the foreach, if, with, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.</source>
          <target state="translated">Обратите внимание, что по состоянию на декабрь 2011 года jQuery.tmpl больше не находится в активной разработке. Мы рекомендуем использовать собственные шаблоны Knockout на основе DOM (т.е. привязки foreach, if, with и т. Д.) Вместо jQuery.tmpl или любого другого механизма шаблонов на основе строк.</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="24a0be8dab4fe687c8ad437ae1be347c7c275ab3" translate="yes" xml:space="preserve">
          <source>Prepopulating an observableArray</source>
          <target state="translated">Предварительное заселение наблюдаемого рентгеновского луча</target>
        </trans-unit>
        <trans-unit id="30d1738d650def938c652b581eb2ab8e9e23bac2" translate="yes" xml:space="preserve">
          <source>Preprocessing DOM nodes</source>
          <target state="translated">Препроцессинг DOM-узлов</target>
        </trans-unit>
        <trans-unit id="3bd28988e0d739a767c1940c87323328cfd0452d" translate="yes" xml:space="preserve">
          <source>Preprocessing Reference</source>
          <target state="translated">Ссылка на предварительную обработку</target>
        </trans-unit>
        <trans-unit id="47b4f8689a05bc9cca63e4c44017f14efdaadb92" translate="yes" xml:space="preserve">
          <source>Preprocessing binding strings</source>
          <target state="translated">Препроцессинг связывающих струн</target>
        </trans-unit>
        <trans-unit id="72734b1cb5286fcdc2e795102ddabad4a96ba527" translate="yes" xml:space="preserve">
          <source>Pretty simple, really.</source>
          <target state="translated">Довольно просто,правда.</target>
        </trans-unit>
        <trans-unit id="02097511df2d0e39c9337e94983004dd3194c3a0" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.4.0, you might need to use synchronous loading to prevent multiple DOM reflows when including many components simultaneously (such as with the foreach binding). With Knockout 3.4.0, components use Knockout&amp;rsquo;s &lt;a href=&quot;microtasks&quot;&gt;microtasks&lt;/a&gt; to ensure asynchronicity, and so will generally perform as well as synchronous loading.</source>
          <target state="translated">До Knockout 3.4.0 вам, возможно, потребуется использовать синхронную загрузку, чтобы предотвратить многократную перекомпоновку DOM при одновременном включении множества компонентов (например, с привязкой foreach). В Knockout 3.4.0 компоненты используют &lt;a href=&quot;microtasks&quot;&gt;микрозадачи&lt;/a&gt; Knockout для обеспечения асинхронности, и поэтому обычно выполняются так же хорошо, как и синхронная загрузка.</target>
        </trans-unit>
        <trans-unit id="ea02aeead6e71fc6cbe55e718e12cf9185abfa29" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.5.0, the default behavior was to hide destroyed items. To use this behavior as the default in newer versions, you can set a global option: ko.options.foreachHidesDestroyed = true. Then, if you want to show destroyed items for a specific foreach binding, you would set includeDestroyed: true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d2145824730e5c1b8fb6fa87d2dd101b9cb427" translate="yes" xml:space="preserve">
          <source>Pure computed observables</source>
          <target state="translated">Чисто вычисленные наблюдаемые</target>
        </trans-unit>
        <trans-unit id="b4ce509d140c0943b0fb6b3aa19d560a50d452fc" translate="yes" xml:space="preserve">
          <source>Pure computeds were introduced in Knockout 3.2.0. See also: &lt;a href=&quot;computed-pure&quot;&gt;more about pure computed observables&lt;/a&gt;.</source>
          <target state="translated">Чистые вычисления были представлены в Knockout 3.2.0. См. Также: &lt;a href=&quot;computed-pure&quot;&gt;больше о чистых вычисленных наблюдаемых&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="57f47271f3869d1768dcebd5706b5e412a9e5dd1" translate="yes" xml:space="preserve">
          <source>Rate-limiting observable notifications</source>
          <target state="translated">Уведомления с ограничением скорости</target>
        </trans-unit>
        <trans-unit id="fe99aebaa6323f9c1f185c4c64c2f1a0b751fa1b" translate="yes" xml:space="preserve">
          <source>Reacting to a specific observable event with &amp;ldquo;ko.when&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109ca37b53291d60621572a50045d0cd051c1b2b" translate="yes" xml:space="preserve">
          <source>Reading and writing observables</source>
          <target state="translated">Читательские и письменные заметки</target>
        </trans-unit>
        <trans-unit id="0a460971e455292dd35a366b845f6510cca16999" translate="yes" xml:space="preserve">
          <source>Reading information from an observableArray</source>
          <target state="translated">Считывание информации с наблюдаемогоArray</target>
        </trans-unit>
        <trans-unit id="10a415b94b161f38c600daa4d4bb513ecf982216" translate="yes" xml:space="preserve">
          <source>Recursive task limit</source>
          <target state="translated">Предел рекурсивной задачи</target>
        </trans-unit>
        <trans-unit id="43f5384571767bbaaa6fd7375d219904895bb1b7" translate="yes" xml:space="preserve">
          <source>Registering a callback on the disposal of an element</source>
          <target state="translated">Регистрация обратного вызова по утилизации элемента</target>
        </trans-unit>
        <trans-unit id="9a480de52dbedb53c2cf2350afee5ac13630029e" translate="yes" xml:space="preserve">
          <source>Registering components as a single AMD module</source>
          <target state="translated">Регистрация компонентов как один AMD модуль</target>
        </trans-unit>
        <trans-unit id="35b2eb936781d5e3694cfbb0f326c5c7048ea539" translate="yes" xml:space="preserve">
          <source>Registering components as a viewmodel/template pair</source>
          <target state="translated">Регистрация компонентов в качестве пары вид-модель/шаблон</target>
        </trans-unit>
        <trans-unit id="dbdca1da5454335dd25004eb3b50c8f66e895af6" translate="yes" xml:space="preserve">
          <source>Registering custom component loaders</source>
          <target state="translated">Регистрация пользовательских автопогрузчиков</target>
        </trans-unit>
        <trans-unit id="bbd0999bf6bb00d22dc5e82c04cc79930c05379a" translate="yes" xml:space="preserve">
          <source>Registering custom elements</source>
          <target state="translated">Регистрация пользовательских элементов</target>
        </trans-unit>
        <trans-unit id="1532215d29dce0afe9ba8e71d6fd4a5554bf38e2" translate="yes" xml:space="preserve">
          <source>Registering your binding</source>
          <target state="translated">Зарегистрируйте ваш обязательный</target>
        </trans-unit>
        <trans-unit id="30a362d04fc57f7bc49c1be4cc35fc032c5bc523" translate="yes" xml:space="preserve">
          <source>Registers a component. See: &lt;a href=&quot;component-registration&quot;&gt;full documentation&lt;/a&gt;.</source>
          <target state="translated">Регистрирует компонент. См .: &lt;a href=&quot;component-registration&quot;&gt;полную документацию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e806ea593f70ec532713b2e31cb54e34ae2fbb61" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (cleaning away any data associated with them to avoid memory leaks).</source>
          <target state="translated">Удаляет все дочерние узлы из реального или виртуального контейнера элементовElem (удаляет все данные,связанные с ними,чтобы избежать утечки памяти).</target>
        </trans-unit>
        <trans-unit id="55eb1f75a4466755cbf9da8ee93eb912dc9b1c70" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from arrayOfNodes as its new children.</source>
          <target state="translated">Удаляет все дочерние узлы из реального или виртуального элемента containerElem (в процессе работы очищает от них все данные,связанные с ними,чтобы избежать утечки памяти),а затем вставляет все узлы из arrayOfNodes в качестве своих новых дочерних.</target>
        </trans-unit>
        <trans-unit id="aa97aaf82420ccf3d840fd847ac4d33d6adbd799" translate="yes" xml:space="preserve">
          <source>Removes the named component from the registry. Or if no such component was registered, does nothing.</source>
          <target state="translated">Удаляет именованный компонент из реестра.Или,если такой компонент не был зарегистрирован,ничего не делает.</target>
        </trans-unit>
        <trans-unit id="0890f779408fa8ac76a438a26ba53f60dda91ecf" translate="yes" xml:space="preserve">
          <source>RequireJs Download</source>
          <target state="translated">ТребованияДжес Скачать</target>
        </trans-unit>
        <trans-unit id="00f09c861f9b24affecf1566366551a836249bc6" translate="yes" xml:space="preserve">
          <source>RequireJs can be downloaded from &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt;.</source>
          <target state="translated">RequireJs можно загрузить с &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="353d8d344e6b162e4c17b4210bea67369e7ef3b0" translate="yes" xml:space="preserve">
          <source>Returns the first child of the real or virtual element containerElem, or null if there are no children.</source>
          <target state="translated">Возвращает первый дочерний элемент реального или виртуального контейнера элементовElem,или null,если нет дочерних элементов.</target>
        </trans-unit>
        <trans-unit id="f44b98d7f68f260183d81c591bdaf943f8bbc926" translate="yes" xml:space="preserve">
          <source>Returns the sibling node that follows node in its real or virtual parent element, or null if there is no following sibling.</source>
          <target state="translated">Возвращает узел-близнец,следующий за узлом в его реальном или виртуальном родительском элементе,или null,если нет следующего брата-близнеца.</target>
        </trans-unit>
        <trans-unit id="4bb189a069efd2411fee0be779b73d0bb87f5573" translate="yes" xml:space="preserve">
          <source>Returns true if a component with the specified name is already registered; false otherwise.</source>
          <target state="translated">Возвращает true,если компонент с указанным именем уже зарегистрирован;false иначе.</target>
        </trans-unit>
        <trans-unit id="4e0da6a7855830c066dbda602feb809af4d79023" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;Note 2&lt;/a&gt; below. Note that valueAllowUnset is only applicable when using value to control selection on a &amp;lt;select&amp;gt; element. On other elements it has no effect.</source>
          <target state="translated">См. &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;Примечание 2&lt;/a&gt; ниже. Обратите внимание, что valueAllowUnset применимо только при использовании значения для управления выделением в элементе &amp;lt;select&amp;gt;. На другие элементы это не влияет.</target>
        </trans-unit>
        <trans-unit id="7a4086bf02e9470ff9beaf89243d77e8723e08b3" translate="yes" xml:space="preserve">
          <source>See Example 3 above to see how you can bind options to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects&amp;rsquo; properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called optionsText.</source>
          <target state="translated">См. Пример 3 выше, чтобы увидеть, как можно привязать параметры к массиву произвольных объектов JavaScript, а не только к строкам. В этом случае вам нужно выбрать, какое из свойств объектов должно отображаться в виде текста в раскрывающемся списке или списке с множественным выбором. Пример 3 показывает, как можно указать это имя свойства, передав дополнительный параметр с именем optionsText.</target>
        </trans-unit>
        <trans-unit id="627ede17723b7a1dcb26a936f7757623f8efd898" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;a longer list of style names and their JavaScript equivalents&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;более длинный список имен стилей и их эквивалентов в JavaScript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60845dd06d2f273308891baec64862cb1ed3b782" translate="yes" xml:space="preserve">
          <source>See later on this page for an API reference.</source>
          <target state="translated">См.далее на этой странице ссылку на API.</target>
        </trans-unit>
        <trans-unit id="bf68dcb1970e76f58db5ceb232524856770b8e5d" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;How to enable custom elements with names that don&amp;rsquo;t correspond to explicitly registered components&lt;/a&gt;</source>
          <target state="translated">См .: &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;Как включить настраиваемые элементы с именами, не соответствующими явно зарегистрированным компонентам&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95713d3429a1266b03118a0b69f2eaedb23716fe" translate="yes" xml:space="preserve">
          <source>Sequence of calls</source>
          <target state="translated">Последовательность вызовов</target>
        </trans-unit>
        <trans-unit id="f85944bee806bc0827acaf6829524bc912923c28" translate="yes" xml:space="preserve">
          <source>Setting computed observables or manual subscriptions to dispose automatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58a31297954712265cfbf6c89f922aec8df4a41" translate="yes" xml:space="preserve">
          <source>Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.</source>
          <target state="translated">Короткий синтаксис:Если вы просто указываете значение строки,KO будет интерпретировать это как идентификатор шаблона для отображения.Данные,которые он поставляет в шаблон,будут вашим текущим объектом модели.</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">Побочные эффекты</target>
        </trans-unit>
        <trans-unit id="e6ea4fd88d422a61726a7ab7fbe12390130c4662" translate="yes" xml:space="preserve">
          <source>Similar to optionsText, you can also pass an additional parameter called optionsValue to specify which of the objects&amp;rsquo; properties should be used to set the value attribute on the &amp;lt;option&amp;gt; elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the &amp;lt;option&amp;gt; element&amp;rsquo;s value attribute.</source>
          <target state="translated">Подобно optionsText, вы также можете передать дополнительный параметр с именем optionsValue, чтобы указать, какое из свойств объектов должно использоваться для установки атрибута value в элементах &amp;lt;option&amp;gt;, которые генерирует KO. Вы также можете указать функцию JavaScript для определения этого значения. Эта функция получит выбранный элемент в качестве единственного аргумента и должна вернуть строку для использования в качестве атрибута value элемента &amp;lt;option&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="2a3bedd0f29a85642c5a7d68ff7d9693c61a907d" translate="yes" xml:space="preserve">
          <source>Similarly, you can use $parent to refer to data from outside the foreach, e.g.:</source>
          <target state="translated">Аналогичным образом,вы можете использовать $parent,чтобы ссылаться на данные,полученные вне форакаса,например:</target>
        </trans-unit>
        <trans-unit id="650503158b05d9103c9329aa587f1f1317a8e97b" translate="yes" xml:space="preserve">
          <source>Simply putting an object into an observableArray doesn&amp;rsquo;t make all of that object&amp;rsquo;s properties themselves observable. Of course, you can make those properties observable if you wish, but that&amp;rsquo;s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.</source>
          <target state="translated">Простое помещение объекта в observableArray не делает сами все свойства этого объекта наблюдаемыми. Конечно, вы можете сделать эти свойства наблюдаемыми, если хотите, но это независимый выбор. ObservableArray просто отслеживает, какие объекты он содержит, и уведомляет слушателей, когда объекты добавляются или удаляются.</target>
        </trans-unit>
        <trans-unit id="abf2e06137216103f9b100bf2bc6e09236071fb4" translate="yes" xml:space="preserve">
          <source>Since Browserify is a build-time tool, it doesn&amp;rsquo;t really need any special integration with KO components, and there&amp;rsquo;s no need to implement any kind of custom component loader to work with it. You can simply use Browserify&amp;rsquo;s require statements to grab instances of your component viewmodels, then explicitly register them, e.g.:</source>
          <target state="translated">Поскольку Browserify - это инструмент времени сборки, на самом деле он не требует какой-либо специальной интеграции с компонентами KO, и нет необходимости реализовывать какой-либо пользовательский загрузчик компонентов для работы с ним. Вы можете просто использовать инструкции Browserify require, чтобы получить экземпляры моделей представления компонентов, а затем явно зарегистрировать их, например:</target>
        </trans-unit>
        <trans-unit id="010c57fd25ed1704f31800fad07288ef30d11c0d" translate="yes" xml:space="preserve">
          <source>Since Knockout processes the microtask queue until it is empty, without yielding to external events, numerous or lengthy tasks could cause the browser page to become unresponsive. Knockout prevents infinite recursion by canceling all remaining tasks if it detects a high level of recursion. For example, the following will eventually stop and throw an error:</source>
          <target state="translated">Поскольку Knockout обрабатывает очередь микрозадач до тех пор,пока она не станет пустой,не уступая внешним событиям,многочисленные или длительные задачи могут привести к тому,что страница браузера перестанет реагировать.Нокаут предотвращает бесконечную рекурсию,отменяя все оставшиеся задачи,если обнаруживается высокий уровень рекурсии.Например,следующее в конце концов остановится и выдаст ошибку:</target>
        </trans-unit>
        <trans-unit id="e12616501c65e2d78b083723430a1a67a2a4941a" translate="yes" xml:space="preserve">
          <source>Since document fragments can have multiple top-level nodes, the &lt;em&gt;entire&lt;/em&gt; document fragment (not just descendants of top-level nodes) is treated as the component template.</source>
          <target state="translated">Поскольку фрагменты документа могут иметь несколько узлов верхнего уровня, &lt;em&gt;весь&lt;/em&gt; фрагмент документа (а не только потомки узлов верхнего уровня) рассматривается как шаблон компонента.</target>
        </trans-unit>
        <trans-unit id="bd18b758f5b6eba86bebba7b461201774c396857" translate="yes" xml:space="preserve">
          <source>Since evaluating myExpr involves reading an observable (useObservable1), KO will supply the parameter to the component as a computed property.</source>
          <target state="translated">Так как оценка myExpr включает в себя чтение наблюдаемого (useObservable1),KO предоставит параметр компоненту в качестве вычисляемого свойства.</target>
        </trans-unit>
        <trans-unit id="03be85be12c780e8cd251d6eb6bc1adf4b6ad284" translate="yes" xml:space="preserve">
          <source>Since the dependency on the template is explicitly stated in the define call, this automatically works with the &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;r.js optimizer&lt;/a&gt; or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step.</source>
          <target state="translated">Поскольку зависимость от шаблона явно указывается в вызове define, это автоматически работает с &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;оптимизатором r.js&lt;/a&gt; или подобными инструментами связывания. Таким образом, весь компонент - модель представления плюс шаблон - можно тривиально включить в файл пакета на этапе сборки.</target>
        </trans-unit>
        <trans-unit id="224aadfbf82f9551d1965c5a2c5ff4d289869d3f" translate="yes" xml:space="preserve">
          <source>Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</source>
          <target state="translated">Так как свойства модели представления наблюдаются,KO будет автоматически обновлять элементы HTML всякий раз,когда эти свойства меняются.</target>
        </trans-unit>
        <trans-unit id="b6b795bc25ad13bca901cb739b9e575d5ba5241f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad2a3557f290cc16325b7dad71154f1a20332d" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value using innerText or textContent instead.</source>
          <target state="translated">Поскольку эта привязка устанавливает содержимое вашего элемента с помощью innerHTML, вы должны быть осторожны, чтобы не использовать его с ненадежными значениями модели, поскольку это может открыть возможность атаки путем внедрения сценария. Если вы не можете гарантировать, что контент безопасен для отображения (например, если он основан на вводе другого пользователя, который был сохранен в вашей базе данных), вы можете использовать &lt;a href=&quot;text-binding&quot;&gt;текстовую привязку&lt;/a&gt; , которая установит текстовое значение элемента с помощью innerText или textContent вместо этого.</target>
        </trans-unit>
        <trans-unit id="bd93df4e4321804a588bbd3af3830ed05cdb095f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your text value using a text node, it&amp;rsquo;s safe to set any string value without risking HTML or script injection. For example, if you wrote:</source>
          <target state="translated">Поскольку эта привязка устанавливает ваше текстовое значение с помощью текстового узла, можно безопасно установить любое строковое значение без риска внедрения HTML или сценария. Например, если вы написали:</target>
        </trans-unit>
        <trans-unit id="3ef8a4666dd8f23e26196f0af5791e8341741188" translate="yes" xml:space="preserve">
          <source>Since this computed is declared to be &lt;em&gt;pure&lt;/em&gt; (i.e., its evaluator does not directly modify other objects or state), Knockout can more efficiently manage its re-evaluation and memory use. Knockout will automatically suspend or release it if no other code has an active dependency on it.</source>
          <target state="translated">Поскольку это вычисленное значение объявлено &lt;em&gt;чистым&lt;/em&gt; (т. Е. Его вычислитель не изменяет напрямую другие объекты или состояние), Knockout может более эффективно управлять его повторной оценкой и использованием памяти. Knockout автоматически приостановит или освободит его, если никакой другой код не имеет активной зависимости от него.</target>
        </trans-unit>
        <trans-unit id="eec92e863ead404e06db453854298b7f7aeeb964" translate="yes" xml:space="preserve">
          <source>Skipping the binding value</source>
          <target state="translated">Пропуск значения привязки</target>
        </trans-unit>
        <trans-unit id="5a0401febcbb91e5467f60a83d13d63f45dbb325" translate="yes" xml:space="preserve">
          <source>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: &lt;strong&gt;Knockout will not restart evaluation of a computed while it is already evaluating&lt;/strong&gt;. This is very unlikely to affect your code. It&amp;rsquo;s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the deferEvaluation option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the peek function described above.</source>
          <target state="translated">Итак, что делает Knockout, если в вашем графике зависимостей есть цикл? Он позволяет избежать бесконечных циклов, применяя следующее правило: &lt;strong&gt;Knockout не будет перезапускать вычисление, пока оно уже вычисляется&lt;/strong&gt; . Маловероятно, что это повлияет на ваш код. Это актуально в двух ситуациях: когда два вычисляемых наблюдаемых зависят друг от друга (возможно, только если один или оба используют параметр deferEvaluation), или когда вычисляемое наблюдаемое записывает в другой наблюдаемый объект, от которого он имеет зависимость (напрямую или через зависимость цепь). Если вам нужно использовать один из этих шаблонов и вы хотите полностью избежать циклической зависимости, вы можете использовать функцию peek, описанную выше.</target>
        </trans-unit>
        <trans-unit id="f6f08edfde52faf5dc68f34cf119dab791fd12c1" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution.</source>
          <target state="translated">Итак, Knockout не просто обнаруживает зависимости при первом запуске оценщика - он переопределяет их каждый раз. Это означает, например, что зависимости могут изменяться динамически: зависимость A может определять, зависит ли вычисляемая наблюдаемая также от B или C. Затем она будет переоценена только при изменении A или вашего текущего выбора B или C. Вам не нужно объявлять зависимости: они определяются во время выполнения из выполнения кода.</target>
        </trans-unit>
        <trans-unit id="a1add6969e68c367f948e300f5de00d8ce1226a9" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution. If the evaluator doesn&amp;rsquo;t access any obsevables, the computed observable will have no dependencies and won&amp;rsquo;t ever need to call the evaluator function again. In that case, to save resources, the computed observable will be automatically &amp;ldquo;disposed.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6039155cfd6e7342a4bb866968884c937aafd1" translate="yes" xml:space="preserve">
          <source>So, if you would like to map a JavaScript object to this, you can pass this as the third argument:</source>
          <target state="translated">Итак,если вы хотите сопоставить объект JavaScript с этим,вы можете передать его в качестве третьего аргумента:</target>
        </trans-unit>
        <trans-unit id="3c47887016b47f8753b43bbda895cb4a52d3627b" translate="yes" xml:space="preserve">
          <source>So, ko.components.loaders is an array containing all the loaders currently enabled. By default, this array contains just one item: ko.components.defaultLoader. To add additional loaders, simply insert them into the ko.components.loaders array.</source>
          <target state="translated">Таким образом,ko.components.loaders-это массив,содержащий все загрузчики,включенные в данный момент.По умолчанию этот массив содержит только один элемент:ko.components.defaultLoader.Для добавления дополнительных загрузчиков просто вставьте их в массив ko.components.loaders.</target>
        </trans-unit>
        <trans-unit id="bcadd6a9a819e98e876d51538df845e3924045c1" translate="yes" xml:space="preserve">
          <source>So, what&amp;rsquo;s this _destroy thing all about? It&amp;rsquo;s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with _destroy set to true.</source>
          <target state="translated">Итак, что это за штука с _destroy? Это действительно интересно только разработчикам Rails. Соглашение в Rails заключается в том, что, когда вы передаете в действие граф объекта JSON, структура может автоматически преобразовать его в граф объекта ActiveRecord, а затем сохранить в вашей базе данных. Он знает, какой из объектов уже находится в вашей базе данных, и выдает правильные операторы INSERT или UPDATE. Чтобы указать фреймворку УДАЛИТЬ запись, вы просто помечаете ее с помощью _destroy, установленного на true.</target>
        </trans-unit>
        <trans-unit id="0cc17b6b6ff109ca3571a9c612acc5269c5e86c5" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using &lt;em&gt;mapping options&lt;/em&gt;. They can be specified during the ko.mapping.fromJS call. In subsequent calls you don&amp;rsquo;t need to specify them again.</source>
          <target state="translated">Иногда может потребоваться больше контроля над тем, как выполняется сопоставление. Это достигается с помощью &lt;em&gt;параметров сопоставления&lt;/em&gt; . Их можно указать во время вызова ko.mapping.fromJS. В последующих вызовах вам не нужно указывать их повторно.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
