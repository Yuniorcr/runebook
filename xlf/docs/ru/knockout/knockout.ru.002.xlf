<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="1efa8d65721b2af289c42fb7b810ae66b4f29f5d" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to control the presence/absence of a section of markup &lt;em&gt;without&lt;/em&gt; having any container element that can hold an if binding. For example, you might want to control whether a certain &amp;lt;li&amp;gt; element appears alongside siblings that always appear:</source>
          <target state="translated">Иногда вам может потребоваться контролировать наличие / отсутствие раздела разметки, &lt;em&gt;не&lt;/em&gt; имея какого-либо элемента контейнера, который может содержать привязку if. Например, вы можете контролировать, будет ли определенный элемент &amp;lt;li&amp;gt; отображаться рядом с всегда отображаемыми братьями и сестрами:</target>
        </trans-unit>
        <trans-unit id="cf0e5ef35db2f589ef3d7f23133757750ce5acc6" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to control the presence/absence of a section of markup &lt;em&gt;without&lt;/em&gt; having any container element that can hold an if or ifnot binding. For example, you might want to control whether a certain &amp;lt;li&amp;gt; element appears alongside siblings that always appear:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090d7c130eac68daf4d626886fb71b101a09b651" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to create a component that receives markup and uses it as part of its output. For example, you may want to build a &amp;ldquo;container&amp;rdquo; UI element such as a grid, list, dialog, or tab set that can receive and bind arbitrary markup inside itself.</source>
          <target state="translated">Иногда вам может понадобиться создать компонент, который получает разметку и использует ее как часть своего вывода. Например, вы можете захотеть создать &amp;laquo;контейнерный&amp;raquo; элемент пользовательского интерфейса, такой как сетка, список, диалог или набор вкладок, который может принимать и связывать внутри себя произвольную разметку.</target>
        </trans-unit>
        <trans-unit id="1450743be880bbdffbc9a1ba26bf1fd07e6f657e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to inject a component into a view without using an extra container element. You can do this using &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="translated">Иногда вам может понадобиться внедрить компонент в представление без использования дополнительного элемента контейнера. Это можно сделать с помощью &lt;em&gt;бесконтейнерного синтаксиса потока управления&lt;/em&gt; , основанного на тегах комментариев. Например,</target>
        </trans-unit>
        <trans-unit id="f112400da0855e8fa6da455e812ae3ff58f48789" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted without actually losing record of its existence. This is known as a &lt;em&gt;non-destructive delete&lt;/em&gt;. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b22fd48b43a0ffdb2cae9da6d525da9fd48f8e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a &lt;em&gt;non-destructive delete&lt;/em&gt;. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="translated">Иногда вам может потребоваться пометить запись массива как удаленную, но при этом фактически не теряя записи о ее существовании. Это называется &lt;em&gt;неразрушающим удалением&lt;/em&gt; . Подробнее о том, как это сделать, см. &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;В функции destroy на observableArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd93e9d13d7bfcfd8e5c31ed2ceac2a6c4e1754" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="translated">Иногда вам может потребоваться пометить запись массива как удаленную, но при этом фактически не теряя записи о ее существовании. Это называется неразрушающим удалением. Подробнее о том, как это сделать, см. &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;В функции destroy на observableArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a812dff6786cd406aaefba5f4c3b70873c52a6" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to set text using Knockout without including an extra element for the text binding. For example, you&amp;rsquo;re not allowed to include other elements within an option element, so the following will not work.</source>
          <target state="translated">Иногда вам может потребоваться установить текст с помощью Knockout без включения дополнительного элемента для привязки текста. Например, вам не разрешено включать другие элементы в элемент option, поэтому следующее не будет работать.</target>
        </trans-unit>
        <trans-unit id="6a4525599ef68a9fe43c6df211cccff711b57d1e" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to represent a data point on the screen in a different format than its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</source>
          <target state="translated">Иногда вам может понадобиться представить точку данных на экране в другом формате,чем ее основное хранилище.Например,вы можете захотеть хранить цену как плавающее значение,но позволить пользователю редактировать ее с помощью валютного символа и фиксированного количества знаков после запятой.Вы можете использовать записываемое вычисляемое наблюдаемое значение для представления отформатированной цены,сопоставляя входящие значения с базовым значением плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="05cfb62c148b0599a08339e0df2d05f5ef502466" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to run custom post-processing logic on the DOM elements generated by your templates. For example, if you&amp;rsquo;re using a JavaScript widgets library such as jQuery UI, you might want to intercept your templates&amp;rsquo; output so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.</source>
          <target state="translated">Иногда вам может потребоваться запустить настраиваемую логику пост-обработки для элементов DOM, созданных вашими шаблонами. Например, если вы используете библиотеку виджетов JavaScript, такую ​​как jQuery UI, вы можете захотеть перехватить вывод своих шаблонов, чтобы вы могли запускать на нем команды jQuery UI, чтобы преобразовать некоторые из визуализированных элементов в средства выбора даты, ползунки или что-нибудь еще.</target>
        </trans-unit>
        <trans-unit id="afd9a93d696cf0ee53ba71b61bf9029619eeebff" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to run custom post-processing logic on the DOM elements processed by Knockout. For example, if you&amp;rsquo;re using a JavaScript widgets library such as jQuery UI, you might want to know when a certain section of the DOM is finished binding so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48318af51d331ce8f161c28b2d8b8af865a40b57" translate="yes" xml:space="preserve">
          <source>Sometimes, rather than reacting to every change to an observable, you just need to know when the observable arrives at a specific value. This is what ko.when makes easy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a20134d13c4fa83399a61a6648dae5f5c9116e3" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not want to select any particular option by default. But a single-select drop-down list usually starts with some item selected, so how can you avoid preselecting something? The usual solution is to prefix the list of options with a special dummy option that just reads &amp;ldquo;Select an item&amp;rdquo; or &amp;ldquo;Please choose an option&amp;rdquo; or similar, and have that one selected by default.</source>
          <target state="translated">Иногда вы можете не захотеть выбирать какой-либо конкретный параметр по умолчанию. Но выпадающий список с одним выбором обычно начинается с выбранного элемента, так как же избежать предварительного выбора чего-либо? Обычное решение - поставить перед списком опций специальную фиктивную опцию, которая просто читает &amp;laquo;Выберите элемент&amp;raquo; или &amp;laquo;Пожалуйста, выберите опцию&amp;raquo; или что-то подобное, и выберите этот вариант по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a88830ac8683679b861aa2877996a238dbfdf87d" translate="yes" xml:space="preserve">
          <source>Source code: View</source>
          <target state="translated">Исходный код:Посмотреть</target>
        </trans-unit>
        <trans-unit id="6506bd5b573750d96e1b57831c62ba19272cf14f" translate="yes" xml:space="preserve">
          <source>Source code: View model</source>
          <target state="translated">Исходный код:Вид модели</target>
        </trans-unit>
        <trans-unit id="15f8a682df856004ef8f68cac3fd529a0a678f8b" translate="yes" xml:space="preserve">
          <source>Special consideration for computed observables</source>
          <target state="translated">Особое внимание уделяется расчетным наблюдениям</target>
        </trans-unit>
        <trans-unit id="4551a643a13595067fd9579e7489ebfab8a1983d" translate="yes" xml:space="preserve">
          <source>Special consideration is given if your parameter resolves to an array. In this case, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if the value matches an item in the array, and &lt;em&gt;unchecked&lt;/em&gt; if it is not contained in the array.</source>
          <target state="translated">Особое внимание уделяется, если ваш параметр разрешается в массив. В этом случае KO установит элемент для &lt;em&gt;проверки,&lt;/em&gt; если значение соответствует элементу в массиве, и &lt;em&gt;снимет &lt;/em&gt;&lt;em&gt;флажок&lt;/em&gt; , если он не содержится в массиве.</target>
        </trans-unit>
        <trans-unit id="2bcf0e18fa32879957b9099a890fa1e0dc44a296" translate="yes" xml:space="preserve">
          <source>Special consideration is given if your parameter resolves to an array. In this case, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; if its value matches an item in the array, and &lt;em&gt;unchecked&lt;/em&gt; if it is not contained in the array. The value of a checkbox is either the element&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. When the user checks or unchecks the checkbox, Knockout will add or remove its value from the array accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26666026e63743d1a82020481615fe638ff934ed" translate="yes" xml:space="preserve">
          <source>Specifying a template</source>
          <target state="translated">Указание шаблона</target>
        </trans-unit>
        <trans-unit id="2b1d7859ab19cd19f47ec6abc15db40ae61a246c" translate="yes" xml:space="preserve">
          <source>Specifying a viewmodel</source>
          <target state="translated">Указание видовой модели</target>
        </trans-unit>
        <trans-unit id="ea0e6f5e3da2da0e29f0ea90ea1b0cd98c85ba63" translate="yes" xml:space="preserve">
          <source>Specifying additional component options</source>
          <target state="translated">Указание дополнительных опций компонента</target>
        </trans-unit>
        <trans-unit id="18b4234e7c86c009699286451ef7b9d36ae43d1e" translate="yes" xml:space="preserve">
          <source>Specifying the update target</source>
          <target state="translated">Указание цели обновления</target>
        </trans-unit>
        <trans-unit id="1bcfc349547d09f30035896045c448b81206e326" translate="yes" xml:space="preserve">
          <source>Starting with Knockout 3.0, developers can define custom syntaxes by providing callbacks that rewrite DOM nodes and binding strings during the binding process.</source>
          <target state="translated">Начиная с Knockout 3.0,разработчики могут определять собственные синтаксисы,предоставляя обратные вызовы,которые перезаписывают DOM-узлы и строки привязки во время процесса привязки.</target>
        </trans-unit>
        <trans-unit id="c796aa5f2bada6792690259418192c7883d1c418" translate="yes" xml:space="preserve">
          <source>Starting with Knockout 3.0, you can specify bindings without a value, which will give the binding an undefined value. For example:</source>
          <target state="translated">Начиная с Knockout 3.0,вы можете указать привязки без значения,которое даст привязке неопределенное значение.Например:</target>
        </trans-unit>
        <trans-unit id="2693170c13c752044d965baa86ff029af25c5bd4" translate="yes" xml:space="preserve">
          <source>State-change notifications</source>
          <target state="translated">Уведомления об изменениях состояния</target>
        </trans-unit>
        <trans-unit id="be915d52c2d4abc30f8b3705c52e450a201b3997" translate="yes" xml:space="preserve">
          <source>Status of a disposed pure computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2969f3ba60c665581a9459f630df126d1688e010" translate="yes" xml:space="preserve">
          <source>Subscribing to lifecycle events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="c6f3ef32f538ba7ddc197ba2a40ed8bf1267eff0" translate="yes" xml:space="preserve">
          <source>Taking this a step further, you could also toggle an isValid flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. There&amp;rsquo;s an easier way of doing validation (explained below), but first consider the following example, which demonstrates the mechanism:</source>
          <target state="translated">Сделав еще один шаг, вы также можете переключить флаг isValid в зависимости от того, был ли последний ввод удовлетворительным, и соответственно отобразить сообщение в пользовательском интерфейсе. Есть более простой способ проверки (поясняется ниже), но сначала рассмотрим следующий пример, демонстрирующий механизм:</target>
        </trans-unit>
        <trans-unit id="bfd2f41bbe59a64109622cb800b43d5098fbef87" translate="yes" xml:space="preserve">
          <source>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there&amp;rsquo;s a better alternative. KO&amp;rsquo;s observableArray has equivalent functions of its own, and they&amp;rsquo;re more useful because:</source>
          <target state="translated">Технически вы можете использовать любую из встроенных функций массива JavaScript для работы с этим базовым массивом, но обычно есть лучшая альтернатива. ObservableArray KO имеет собственные эквивалентные функции, и они более полезны, потому что:</target>
        </trans-unit>
        <trans-unit id="e9d610e2da9960031e5fc6eb154252b9be195eaf" translate="yes" xml:space="preserve">
          <source>Templates can be specified in any of the following forms. The most commonly useful are &lt;a href=&quot;#an-existing-element-id&quot;&gt;existing element IDs&lt;/a&gt; and &lt;a href=&quot;#an-amd-module-whose-value-describes-a-template&quot;&gt;AMD modules&lt;/a&gt;.</source>
          <target state="translated">Шаблоны можно указать в любой из следующих форм. Чаще всего используются &lt;a href=&quot;#an-existing-element-id&quot;&gt;существующие идентификаторы элементов&lt;/a&gt; и &lt;a href=&quot;#an-amd-module-whose-value-describes-a-template&quot;&gt;модули AMD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="200be3445e2bde1ede81d4c95d33bd1076a8277f" translate="yes" xml:space="preserve">
          <source>Templating</source>
          <target state="translated">Templating</target>
        </trans-unit>
        <trans-unit id="d0044a6eb26a5c396986a0204048b9d5e5baf64c" translate="yes" xml:space="preserve">
          <source>That does it! Now, your view will display as if you&amp;rsquo;d written the following HTML:</source>
          <target state="translated">Вот и все! Теперь ваше представление будет отображаться так, как будто вы написали следующий HTML:</target>
        </trans-unit>
        <trans-unit id="02e149eee4340af4ceec19232b911078d7192e9a" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because the options binding tries to be independent of the value binding (which controls selection for a single-select list) and the selectedOptions binding (which controls selection for a multi-select list).</source>
          <target state="translated">Это связано с тем, что привязка параметров пытается быть независимой от привязки значения (которая управляет выбором для списка с одним выбором) и привязки selectedOptions (которая управляет выбором для списка с множественным выбором).</target>
        </trans-unit>
        <trans-unit id="e674558ecc1081e9c1295665f7df128dafb8d87b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it! You don&amp;rsquo;t have to write code to update it; it updates on its own when the myItems array changes. Similarly, to make the &amp;lsquo;Add&amp;rsquo; button enable or disable depending on the number of items, just write:</source>
          <target state="translated">Это оно! Вам не нужно писать код для его обновления; он обновляется сам по себе при изменении массива myItems. Точно так же, чтобы включить или отключить кнопку &amp;laquo;Добавить&amp;raquo; в зависимости от количества элементов, просто напишите:</target>
        </trans-unit>
        <trans-unit id="667657cfbe0d82dea6d00158cadde1d15d9e504d" translate="yes" xml:space="preserve">
          <source>The &quot;attr&quot; binding</source>
          <target state="translated">Аттр&quot; переплет</target>
        </trans-unit>
        <trans-unit id="81fe0aefcb8907e65d4f80424d8b82ba6529ef05" translate="yes" xml:space="preserve">
          <source>The &quot;checked&quot; binding</source>
          <target state="translated">Проверенный&quot; переплет</target>
        </trans-unit>
        <trans-unit id="836a82bfe72ef112581f47a7fba0da6ed84bd80c" translate="yes" xml:space="preserve">
          <source>The &quot;class&quot; and &quot;css&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729792440e88ab1975faa8b1ae741d3568a9e80f" translate="yes" xml:space="preserve">
          <source>The &quot;click&quot; binding</source>
          <target state="translated">Щелчковая&quot; привязка</target>
        </trans-unit>
        <trans-unit id="87f9daf36f2cbfcb9347bc8d5a2a9ac913f55ee0" translate="yes" xml:space="preserve">
          <source>The &quot;component&quot; binding</source>
          <target state="translated">Обязательный &quot;компонентный&quot; переплет</target>
        </trans-unit>
        <trans-unit id="268bdcaa2d0957c8d0391d4c4e143f349a3a0908" translate="yes" xml:space="preserve">
          <source>The &quot;css&quot; binding</source>
          <target state="translated">Переплет &quot;css&quot;</target>
        </trans-unit>
        <trans-unit id="aa22ef1d97b1be4a810e3f5260ca2fd7b9c4b9cc" translate="yes" xml:space="preserve">
          <source>The &quot;disable&quot; binding</source>
          <target state="translated">Отключаемый&quot; переплет</target>
        </trans-unit>
        <trans-unit id="1546e74f5d1b76eda2b5dc5a99f2d04abc3904df" translate="yes" xml:space="preserve">
          <source>The &quot;enable&quot; and &quot;disable&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041e1100c69440c690c0a77bb60251bbe60aa13d" translate="yes" xml:space="preserve">
          <source>The &quot;enable&quot; binding</source>
          <target state="translated">Переплет &quot;разрешающий&quot;.</target>
        </trans-unit>
        <trans-unit id="8b081740d1fb26b2947fc54f2be8290dd6b4f171" translate="yes" xml:space="preserve">
          <source>The &quot;event&quot; binding</source>
          <target state="translated">Обязательный характер &quot;события&quot;</target>
        </trans-unit>
        <trans-unit id="aeb9266b69cb94e4efef8e8ec8245bac4441f5fb" translate="yes" xml:space="preserve">
          <source>The &quot;foreach&quot; binding</source>
          <target state="translated">Переплет &quot;форач&quot;</target>
        </trans-unit>
        <trans-unit id="387e6548a4d36e8f21807318bf235e14d2cabd7e" translate="yes" xml:space="preserve">
          <source>The &quot;hasFocus&quot; binding</source>
          <target state="translated">Привязка &quot;hasFocus&quot;</target>
        </trans-unit>
        <trans-unit id="b3bd7e57ef15a3a444a9a54af1c145628250ace9" translate="yes" xml:space="preserve">
          <source>The &quot;html&quot; binding</source>
          <target state="translated">Переплет &quot;html&quot;</target>
        </trans-unit>
        <trans-unit id="ce5aed7a9b37c6426140743870d4fa729ae280bd" translate="yes" xml:space="preserve">
          <source>The &quot;if&quot; and &quot;ifnot&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a22f402c1cb22df5a11c1cf759eb4fcb7755fd" translate="yes" xml:space="preserve">
          <source>The &quot;if&quot; binding</source>
          <target state="translated">Переплет &quot;если&quot;.</target>
        </trans-unit>
        <trans-unit id="6e058224b266f791dfd293b2509c3657b73c91ee" translate="yes" xml:space="preserve">
          <source>The &quot;ifnot&quot; binding</source>
          <target state="translated">Переплет &quot;ifnot&quot;</target>
        </trans-unit>
        <trans-unit id="d33b99cd025d1ef1a00d7820955adff6b091a4f6" translate="yes" xml:space="preserve">
          <source>The &quot;let&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ecb831b753a1b99237c2da228b61981e524a2c" translate="yes" xml:space="preserve">
          <source>The &quot;options&quot; binding</source>
          <target state="translated">Опционная&quot; привязка</target>
        </trans-unit>
        <trans-unit id="998f0ccdcc6e82328f9f4ecba0c9325b97e976df" translate="yes" xml:space="preserve">
          <source>The &quot;selectedOptions&quot; binding</source>
          <target state="translated">Привязка &quot;selectedOptions&quot;</target>
        </trans-unit>
        <trans-unit id="7b0ad502b61055bf3d6312ebedf00afcf36c21e2" translate="yes" xml:space="preserve">
          <source>The &quot;style&quot; binding</source>
          <target state="translated">Стильный&quot; переплет</target>
        </trans-unit>
        <trans-unit id="012a650b218ca98273aeac430939dd9445632dd3" translate="yes" xml:space="preserve">
          <source>The &quot;submit&quot; binding</source>
          <target state="translated">Обязательство &quot;представить&quot;</target>
        </trans-unit>
        <trans-unit id="7e48a0247d14aa0d9c333491f221626e25bc43fb" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; binding</source>
          <target state="translated">Шаблон&quot; переплета</target>
        </trans-unit>
        <trans-unit id="2d856ef4864767a8e9b7d18ca94745b74199eb43" translate="yes" xml:space="preserve">
          <source>The &quot;text&quot; binding</source>
          <target state="translated">Текстовый&quot; переплет</target>
        </trans-unit>
        <trans-unit id="60b50b0405f6a55d057311d3ce77ae607e221184" translate="yes" xml:space="preserve">
          <source>The &quot;textInput&quot; binding</source>
          <target state="translated">Привязка &quot;textInput&quot;</target>
        </trans-unit>
        <trans-unit id="cf70dcaafb5eeb11cd70e48b42ab8792299341fb" translate="yes" xml:space="preserve">
          <source>The &quot;uniqueName&quot; binding</source>
          <target state="translated">Переплет с &quot;уникальным именем&quot;</target>
        </trans-unit>
        <trans-unit id="abff06e6a46c514b00a9d69ebda1678fe9b61252" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; binding</source>
          <target state="translated">Привязка &quot;стоимости&quot;</target>
        </trans-unit>
        <trans-unit id="dcec70cee11113c3fce39cd44d46e81d4ff35f55" translate="yes" xml:space="preserve">
          <source>The &quot;visible&quot; and &quot;hidden&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9926725b31c6326f65c499ed6e2d7c6ef89cb6" translate="yes" xml:space="preserve">
          <source>The &quot;visible&quot; binding</source>
          <target state="translated">&quot;видимый&quot; переплет</target>
        </trans-unit>
        <trans-unit id="99662caaf1c265b5d5f4b8647c0390162f2951ee" translate="yes" xml:space="preserve">
          <source>The &quot;with&quot; and &quot;using&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2695c31457d8ecf209fdcde945ae4b7e6b35704" translate="yes" xml:space="preserve">
          <source>The &quot;with&quot; binding</source>
          <target state="translated">С&quot; связыванием</target>
        </trans-unit>
        <trans-unit id="d0172068eae28b7598208322680a72ead20dc040" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;init&amp;rdquo; callback</source>
          <target state="translated">Обратный вызов init</target>
        </trans-unit>
        <trans-unit id="88bffd25f7f08d8f696284fca0cd9e9a510a5a82" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;update&amp;rdquo; callback</source>
          <target state="translated">Обратный вызов &amp;laquo;update&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="a7b56425c510dea26081ff5f361028be5d697e8c" translate="yes" xml:space="preserve">
          <source>The &amp;lt;!-- ko --&amp;gt; and &amp;lt;!-- /ko --&amp;gt; comments act as start/end markers, defining a &amp;ldquo;virtual element&amp;rdquo; that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</source>
          <target state="translated">Комментарии &amp;lt;! - ko -&amp;gt; и &amp;lt;! - / ko -&amp;gt; действуют как маркеры начала / конца, определяя &amp;laquo;виртуальный элемент&amp;raquo;, содержащий разметку внутри. Knockout понимает этот синтаксис виртуального элемента и выполняет привязку, как если бы у вас был реальный контейнерный элемент.</target>
        </trans-unit>
        <trans-unit id="66447128a53fc158d2a378583ff58d8cb3b7f44b" translate="yes" xml:space="preserve">
          <source>The &amp;lt;!--ko--&amp;gt; and &amp;lt;!--/ko--&amp;gt; comments act as start/end markers, defining a &amp;ldquo;virtual element&amp;rdquo; that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</source>
          <target state="translated">Комментарии &amp;lt;! - ko -&amp;gt; и &amp;lt;! - / ko -&amp;gt; действуют как маркеры начала / конца, определяя &amp;laquo;виртуальный элемент&amp;raquo;, содержащий разметку внутри. Knockout понимает этот синтаксис виртуального элемента и выполняет привязку, как если бы у вас был реальный контейнерный элемент.</target>
        </trans-unit>
        <trans-unit id="f6c987f2e30b59a61bf82010bd82466cbad8bfa5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;checked-binding&quot;&gt;checked&lt;/a&gt; binding should be used to bind a view model property against the value of a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or radio button (&amp;lt;input type='radio'&amp;gt;). If you do include the value binding with the checked binding on one of these elements, then the value binding acts similarly to the &lt;a href=&quot;checked-binding#checkedValue&quot;&gt;checkedValue&lt;/a&gt; option that can be used with the checked binding and will control the value that is used for updating your view model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0fa3ec409d116219327c807820e685d0a681ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;checked-binding&quot;&gt;checked&lt;/a&gt; binding should be used to bind a view model property against the value of a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or radio button (&amp;lt;input type='radio'&amp;gt;). If you do include the value binding with the checked binding on one of these elements, then the value binding will simply act like the &lt;a href=&quot;checked-binding#checkedValue&quot;&gt;checkedValue&lt;/a&gt; option that can be used with the checked binding and will control the value that is used for updating your view model.</source>
          <target state="translated">&lt;a href=&quot;checked-binding&quot;&gt;Проверяется&lt;/a&gt; связывание должна быть использовано , чтобы связать свойство вида модели против стоимости CheckBox (&amp;lt;входного типа = &amp;laquo;флажок&amp;raquo;&amp;gt;) или переключатель (&amp;lt;входного типа = &amp;laquo;радио&amp;raquo;&amp;gt;). Если вы действительно включаете привязку значения с проверенной привязкой к одному из этих элементов, тогда привязка значения будет просто действовать как параметр &lt;a href=&quot;checked-binding#checkedValue&quot;&gt;checkedValue,&lt;/a&gt; который можно использовать с проверенной привязкой, и будет контролировать значение, которое используется для обновления вашей модели представления.</target>
        </trans-unit>
        <trans-unit id="063f48d562135b75491eebc35abcf6a8aa221482" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore.js template engine&lt;/a&gt; by default uses ERB-style delimiters (&amp;lt;%= ... %&amp;gt;). Here&amp;rsquo;s how the preceding example&amp;rsquo;s template might look with Underscore:</source>
          <target state="translated">Механизм &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;шаблонов Underscore.js&lt;/a&gt; по умолчанию использует разделители в стиле ERB (&amp;lt;% = ...%&amp;gt;). Вот как может выглядеть шаблон из предыдущего примера с Underscore:</target>
        </trans-unit>
        <trans-unit id="ef92cc17f05a45263dfe218714287940c12a0b66" translate="yes" xml:space="preserve">
          <source>The added array element</source>
          <target state="translated">Добавленный элемент массива</target>
        </trans-unit>
        <trans-unit id="b57088d36db63605ea20966d4f6ddfdc3a240418" translate="yes" xml:space="preserve">
          <source>The arrays ignore and include still work as normal. The array copy can be used for efficiency to copy array or object properties including children. If an array or object property is not specified in copy or observe then it is recursively mapped:</source>
          <target state="translated">Массивы игнорируются и продолжают работать как обычно.Копия массива может быть использована для эффективного копирования свойств массива или объекта,включая дочерние.Если свойство массива или объекта не указано в копировании или наблюдении,то оно рекурсивно отображается:</target>
        </trans-unit>
        <trans-unit id="5dadf6a7255eba492271ccb4eccaf63b41dfa7f2" translate="yes" xml:space="preserve">
          <source>The as option allows you set an alias for the new context object. Although you can refer to the object using the $data &lt;a href=&quot;binding-context&quot;&gt;context variable&lt;/a&gt;, it may be useful to give it a more descriptive name using the as option like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75481e65bcc1f59ce58a2b7a269a6702607e56a" translate="yes" xml:space="preserve">
          <source>The as option also provides a corresponding &lt;em&gt;index&lt;/em&gt; value. For example, if you set as: 'category', you can access the index of the current item using categoryIndex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d35e492a8cbdf9e668e45561d2ef1328ef7965" translate="yes" xml:space="preserve">
          <source>The attr binding can be used to set attributes that include a namespace, such as xlink:href:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b6946f4dee7b5d349c61c577e42283624be620" translate="yes" xml:space="preserve">
          <source>The attr binding provides a generic way to set the value of any attribute for the associated DOM element. This is useful, for example, when you need to set the title attribute of an element, the src of an img tag, or the href of a link based on values in your view model, with the attribute value being updated automatically whenever the corresponding model property changes.</source>
          <target state="translated">Привязка attr обеспечивает общий способ установки значения любого атрибута для ассоциированного DOM-элемента.Это полезно,например,когда необходимо установить атрибут заголовка элемента,src тега img,или href ссылки на основе значений в вашей видовой модели,при этом значение атрибута будет обновляться автоматически при изменении соответствующего свойства модели.</target>
        </trans-unit>
        <trans-unit id="a9e9d47bf7dc24b389ee0d6af7ed88fcf6a222e2" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;name&lt;/em&gt; should generally match a registered binding (either built-in or &lt;a href=&quot;custom-bindings&quot;&gt;custom&lt;/a&gt;) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn&amp;rsquo;t appear to work, first check that the name is correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef329ec6555c9ead7be23ed4a0362089a23da81" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;name&lt;/em&gt; should generally match a registered binding handler (either built-in or &lt;a href=&quot;custom-bindings&quot;&gt;custom&lt;/a&gt;) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn&amp;rsquo;t appear to work, first check that the name is correct.</source>
          <target state="translated">Связывание &lt;em&gt;имени&lt;/em&gt; в принципе должны соответствовать зарегистрированному связывания обработчика (либо встроенный или &lt;a href=&quot;custom-bindings&quot;&gt;обычаем&lt;/a&gt; ) или быть параметром для другого связывания. Если имя не соответствует ни одному из них, Knockout проигнорирует его (без ошибок или предупреждений). Поэтому, если привязка не работает, сначала проверьте правильность имени.</target>
        </trans-unit>
        <trans-unit id="652f2f5c9f8a12eb6ee21fee9ad6a56c07e3be9d" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;value&lt;/em&gt; can be a single &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals&quot;&gt;value, variable, or literal&lt;/a&gt; or almost any valid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators&quot;&gt;JavaScript expression&lt;/a&gt;. Here are examples of various binding values:</source>
          <target state="translated">Связывание &lt;em&gt;значение&lt;/em&gt; может быть одно &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals&quot;&gt;значение, переменная или литерал&lt;/a&gt; или почти любое допустимое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators&quot;&gt;выражение JavaScript&lt;/a&gt; . Вот примеры различных значений привязки:</target>
        </trans-unit>
        <trans-unit id="00c2e2c23df54cb959bb9b3e5e3e3ebc75348a46" translate="yes" xml:space="preserve">
          <source>The built-in default component loader, ko.components.defaultLoader, is based around a central &amp;ldquo;registry&amp;rdquo; of component definitions. It relies on you explicitly registering a configuration for each component before you can use that component.</source>
          <target state="translated">Встроенный загрузчик компонентов по умолчанию, ko.components.defaultLoader, основан на центральном &amp;laquo;реестре&amp;raquo; определений компонентов. Он полагается на вашу явную регистрацию конфигурации для каждого компонента, прежде чем вы сможете использовать этот компонент.</target>
        </trans-unit>
        <trans-unit id="5ecaba43f1e6c01df489f88d37a9335daaf77792" translate="yes" xml:space="preserve">
          <source>The change log just gives you the items that actually changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d971840dc40d1d830c39a6836f76bdcbe10df112" translate="yes" xml:space="preserve">
          <source>The checked binding links a checkable form control &amp;mdash; i.e., a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or a radio button (&amp;lt;input type='radio'&amp;gt;) &amp;mdash; with a property on your view model.</source>
          <target state="translated">Проверенная привязка связывает проверяемый элемент управления формы - то есть флажок (&amp;lt;input type = 'checkbox'&amp;gt;) или переключатель (&amp;lt;input type = 'radio'&amp;gt;) - со свойством в вашей модели представления.</target>
        </trans-unit>
        <trans-unit id="c50da3ddf514bf7abf386398a139720b01486c05" translate="yes" xml:space="preserve">
          <source>The class and css bindings add or remove one or more named CSS classes to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cda63d43cbee5c35bb13029131bdfe0150f240" translate="yes" xml:space="preserve">
          <source>The click binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is clicked. This is most commonly used with elements like button, input, and a, but actually works with any visible DOM element.</source>
          <target state="translated">Привязка кликов добавляет обработчик события,так что выбранная вами функция JavaScript будет вызвана при щелчке по соответствующему элементу DOM.Это наиболее часто используется с такими элементами,как кнопка,ввод и a,но на самом деле работает с любым видимым элементом DOM.</target>
        </trans-unit>
        <trans-unit id="315af6b13a3b050b2e8e589958153d689f7c75e4" translate="yes" xml:space="preserve">
          <source>The component &lt;strong&gt;name&lt;/strong&gt; can be any nonempty string. It&amp;rsquo;s recommended, but not mandatory, to use lowercase dash-separated strings (such as your-component-name) so that the component name is valid to use as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt; (such as &amp;lt;your-component-name&amp;gt;).</source>
          <target state="translated">Компонент &lt;strong&gt;имя&lt;/strong&gt; может быть любой непустой строкой. Рекомендуется, но не обязательно, использовать строки, разделенные дефисом в нижнем регистре (например, имя-компонента), чтобы имя компонента можно было использовать в качестве &lt;a href=&quot;component-custom-elements&quot;&gt;настраиваемого элемента&lt;/a&gt; (например, &amp;lt;имя-компонента&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="d8ee1b6f8e527013cbe31220266cd96f28da0019" translate="yes" xml:space="preserve">
          <source>The component binding injects a specified &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; into an element, and optionally passes parameters to it.</source>
          <target state="translated">Привязка компонента вводит указанный &lt;a href=&quot;component-overview&quot;&gt;компонент&lt;/a&gt; в элемент и при необходимости передает ему параметры.</target>
        </trans-unit>
        <trans-unit id="4d5135a132a3ef368448c56cda2be61f2f6fc1c6" translate="yes" xml:space="preserve">
          <source>The component can then choose to use the supplied DOM nodes as part of its output however it wishes, such as by using template: { nodes: $componentTemplateNodes } on any element in the component&amp;rsquo;s template.</source>
          <target state="translated">Затем компонент может выбрать использование предоставленных узлов DOM как часть своего вывода по своему усмотрению, например, используя template: {nodes: $ componentTemplateNodes} для любого элемента в шаблоне компонента.</target>
        </trans-unit>
        <trans-unit id="35f46804718d8f0a271608004b91334bb085b20e" translate="yes" xml:space="preserve">
          <source>The componentInfo.templateNodes array is useful if you want to build a component that accepts arbitrary markup to influence its output (for example, a grid, list, dialog, or tab set that injects supplied markup into itself). For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="translated">Массив componentInfo.templateNodes полезен, если вы хотите создать компонент, который принимает произвольную разметку, чтобы влиять на свой вывод (например, сетку, список, диалог или набор вкладок, которые вводят предоставленную разметку в себя). Полный пример см. В разделе &amp;laquo; &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;Передача разметки в компоненты&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1c8df0fe7dc76501e3c6d96810962786f87bc2a" translate="yes" xml:space="preserve">
          <source>The copy array you specify in the mapping options is combined with the default copy array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="translated">Массив копий,который вы указываете в опциях отображения,комбинируется с массивом копий по умолчанию,который по умолчанию пуст.Вы можете управлять этим массивом по умолчанию следующим образом:</target>
        </trans-unit>
        <trans-unit id="932d9cd639f9a34ea0a379bb562c58e1459a2f51" translate="yes" xml:space="preserve">
          <source>The css binding adds or removes one or more named CSS classes to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative.</source>
          <target state="translated">Привязка css добавляет или удаляет один или несколько CSS классов к связанному элементу DOM.Это полезно,например,для выделения некоторого значения красным цветом,если оно становится отрицательным.</target>
        </trans-unit>
        <trans-unit id="1bca18c0eecebb94630002d080cd4f3ec6dd0351" translate="yes" xml:space="preserve">
          <source>The data item against which it is bound, or undefined for the caption element</source>
          <target state="translated">Элемент данных,к которому он привязан,или неопределенный для элемента подписи</target>
        </trans-unit>
        <trans-unit id="108f5df83762dc6213fdc4d63d42ffa6220b8746" translate="yes" xml:space="preserve">
          <source>The data item against which they are being bound</source>
          <target state="translated">Элемент данных,к которому они привязаны</target>
        </trans-unit>
        <trans-unit id="e02fc5ece743a7fd3262031255398c42b17ef54c" translate="yes" xml:space="preserve">
          <source>The data-bind attribute isn&amp;rsquo;t native to HTML, though it is perfectly OK (it&amp;rsquo;s strictly compliant in HTML 5, and causes no problems with HTML 4 even though a validator will point out that it&amp;rsquo;s an unrecognized attribute). But since the browser doesn&amp;rsquo;t know what it means, you need to activate Knockout to make it take effect.</source>
          <target state="translated">Атрибут data-bind не является родным для HTML, хотя он совершенно нормален (он строго соответствует HTML 5 и не вызывает проблем с HTML 4, хотя валидатор укажет, что это нераспознанный атрибут). Но поскольку браузер не знает, что это значит, вам нужно активировать Knockout, чтобы он вступил в силу.</target>
        </trans-unit>
        <trans-unit id="c2e3559e993c827d22c705e31984a570c621dea7" translate="yes" xml:space="preserve">
          <source>The data-bind syntax</source>
          <target state="translated">Синтаксис привязки данных</target>
        </trans-unit>
        <trans-unit id="6b8cf9fefc50c1a7501beecc036ff2dcc8fd4c33" translate="yes" xml:space="preserve">
          <source>The default behavior of the as option is to add a name for the current item while still also binding the contents to the item. But you may prefer keep the context unchanged and only set the name of the current item. This latter behavior will probably be the default in a future version of Knockout. To turn it on for a specific binding, set the noChildContext option to true. When this option is used along with as, all access to the array items must be through the given name, and $data will remain set to the outer viewmodel. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4353b85d2b9cd5e10fec344428d87770e27c1d9b" translate="yes" xml:space="preserve">
          <source>The default behavior of the as option is to set a name for the provided object while still also binding the contents to the object. But you may prefer to keep the context unchanged and only set the name of the object. This latter behavior will probably be the default in a future version of Knockout. To turn it on for a specific binding, set the noChildContext option to true. When this option is used along with as, all access to the object must be through the given name, and $data will remain set to the outer viewmodel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366e4820449d60904ec50a029f22f31fe805c045" translate="yes" xml:space="preserve">
          <source>The default component loader</source>
          <target state="translated">Компонентный загрузчик по умолчанию</target>
        </trans-unit>
        <trans-unit id="ce7b599739744a48558fac0535eb69108e550ffd" translate="yes" xml:space="preserve">
          <source>The default component loader supplies viewmodels/templates based on &lt;a href=&quot;component-registration&quot;&gt;what you have registered&lt;/a&gt;. If applicable, this is the phase where it requests any specified AMD modules from your AMD loader.</source>
          <target state="translated">Загрузчик компонентов по умолчанию предоставляет модели просмотра / шаблоны на основе &lt;a href=&quot;component-registration&quot;&gt;того, что вы зарегистрировали&lt;/a&gt; . Если возможно, это этап, на котором он запрашивает любые указанные модули AMD у вашего загрузчика AMD.</target>
        </trans-unit>
        <trans-unit id="09732649e70687aaf1c33ff6ca19f79f252c6c8b" translate="yes" xml:space="preserve">
          <source>The default component loader will call this function on any registered loaders that declare it, to convert the template part of a component configuration into an array of DOM nodes. The nodes are then cached and cloned for each instance of the component.</source>
          <target state="translated">Загрузчик компонентов по умолчанию вызовет эту функцию у любого зарегистрированного загрузчика,который объявит ее,для преобразования шаблонной части конфигурации компонента в массив DOM-узлов.Затем узлы кэшируются и клонируются для каждого экземпляра компонента.</target>
        </trans-unit>
        <trans-unit id="19ccce60a7742e398540647ff9062227dfd855b0" translate="yes" xml:space="preserve">
          <source>The default component loader will call this function on any registered loaders that declare it, to convert the viewModel part of a component configuration into a createViewModel factory function. The function is then cached and called for each new instance of the component that needs a viewmodel.</source>
          <target state="translated">Загрузчик компонентов по умолчанию вызовет эту функцию у любого зарегистрированного загрузчика,который объявит ее,для преобразования части ViewModel конфигурации компонента в заводскую функцию createViewModel.Затем функция кэшируется и вызывается для каждого нового экземпляра компонента,которому нужна ViewModel.</target>
        </trans-unit>
        <trans-unit id="15dd6f7b5fcf81a774da95adae457614aaac160f" translate="yes" xml:space="preserve">
          <source>The default loader itself has a loadTemplate function that resolves a range of template configuration formats into DOM arrays.</source>
          <target state="translated">Сам загрузчик по умолчанию имеет функцию loadTemplate,которая разрешает ряд форматов конфигурации шаблонов в DOM-массивах.</target>
        </trans-unit>
        <trans-unit id="ead01d1120c6a1f313be5641ab191d173c3b1ccd" translate="yes" xml:space="preserve">
          <source>The default loader itself has a loadViewModel function that resolves a range of viewmodel configuration formats into createViewModel functions.</source>
          <target state="translated">Сам загрузчик по умолчанию имеет функцию loadViewModel,которая разрешает ряд форматов конфигурации Viewmodel в функции createViewModel.</target>
        </trans-unit>
        <trans-unit id="7897f3dd77b93db3f4074ec350ef4f1d3045faba" translate="yes" xml:space="preserve">
          <source>The default rate-limit method is different from the throttle algorithm. To match the throttle behavior, use the notifyWhenChangesStop method.</source>
          <target state="translated">Метод ограничения скорости по умолчанию отличается от алгоритма дросселирования.Для соответствия поведения дросселя используйте метод notifyWhenChangesStop.</target>
        </trans-unit>
        <trans-unit id="0e8110ec26b3e497db5167ef4c25bc7261c68f9a" translate="yes" xml:space="preserve">
          <source>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of &amp;lsquo;person&amp;rsquo; objects by last name, you could write myObservableArray.sort(function (left, right) { return left.lastName == right.lastName ? 0 : (left.lastName &amp;lt; right.lastName ? -1 : 1) })</source>
          <target state="translated">По умолчанию используется сортировка по алфавиту, но при желании можно передать функцию для управления сортировкой массива. Ваша функция должна принимать любые два объекта из массива и возвращать отрицательное значение, если первый аргумент меньше, положительное значение, если второй меньше, или ноль, чтобы рассматривать их как равные. Например, чтобы отсортировать массив объектов 'person' по фамилии, вы можете написать myObservableArray.sort (function (left, right) {return left.lastName == right.lastName? 0: (left.lastName &amp;lt;right.lastName ? -1: 1)})</target>
        </trans-unit>
        <trans-unit id="59e06d0e5380901498a48d94a08b531cbe978874" translate="yes" xml:space="preserve">
          <source>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of &amp;lsquo;person&amp;rsquo; objects by last name, you could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d097cb656bd9314287c368f7b582f51a1afa06" translate="yes" xml:space="preserve">
          <source>The destroy and destroyAll functions are mainly intended as a convenience for developers using Ruby on Rails:</source>
          <target state="translated">Функции destroy и destroyAll в основном предназначены для удобства разработчиков,использующих Ruby on Rails:</target>
        </trans-unit>
        <trans-unit id="2dc38377602a5bf251c9ac8f8c358c2b61a483de" translate="yes" xml:space="preserve">
          <source>The disable binding causes the associated DOM element to be disabled only when the parameter value is true. This is useful with form elements like input, select, and textarea.</source>
          <target state="translated">Отключение привязки приводит к тому,что соответствующий элемент флэш-памяти отключается только в том случае,если значение параметра истинно.Это полезно для таких элементов формы,как input,select и textarea.</target>
        </trans-unit>
        <trans-unit id="034a88a2a8e70f61d5f53b00afb344cce6b30f2a" translate="yes" xml:space="preserve">
          <source>The element you attach a component binding to may contain further markup. For example,</source>
          <target state="translated">Элемент,к которому прикрепляется привязка компонента,может содержать дополнительную разметку.Например,</target>
        </trans-unit>
        <trans-unit id="e3c15f42cf7a0908e29bc9f6fc045acec85c8dec" translate="yes" xml:space="preserve">
          <source>The enable binding causes the associated DOM element to be enabled only when the parameter value is true. This is useful with form elements like input, select, and textarea.</source>
          <target state="translated">Привязка разблокировки приводит к тому,что соответствующий элемент DOM включается только в том случае,если значение параметра равно true.Это полезно для таких элементов формы,как input,select и textarea.</target>
        </trans-unit>
        <trans-unit id="e51effe7f29b8c6485f6a0c6d2c659126917abb4" translate="yes" xml:space="preserve">
          <source>The enable binding causes the associated DOM element to be enabled when its parameter value is true. The disable binding works oppositely, causing the associated DOM element to be disabled when its value is true. These bindings are useful with form elements like input, select, and textarea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3a188f4389ae5361ef1aab713ad2e218776c5b" translate="yes" xml:space="preserve">
          <source>The event binding allows you to add an event handler for a specified event so that your chosen JavaScript function will be invoked when that event is triggered for the associated DOM element. This can be used to bind to any event, such as keypress, mouseover or mouseout.</source>
          <target state="translated">Привязка событий позволяет добавить обработчик события для указанного события таким образом,что выбранная вами функция JavaScript будет вызвана при срабатывании этого события для ассоциированного DOM-элемента.Это может быть использовано для привязки к любому событию,например,нажатию клавиши,наведению или наведению мыши.</target>
        </trans-unit>
        <trans-unit id="8c7fc29a628f445ae71ce6574a8f431c83b56907" translate="yes" xml:space="preserve">
          <source>The expression you wish to evaluate. For the if binding, if it evaluates to true (or a true-ish value), the contained markup will be present in the document, and any data-bind attributes on it will be applied; if your expression evaluates to false, the contained markup will be removed from your document without first applying any bindings to it. For the ifnot binding, the behavior is reversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bb1049202e2fc471d173b4114d739d41bd5d4a" translate="yes" xml:space="preserve">
          <source>The expression you wish to evaluate. If it evaluates to true (or a true-ish value), the contained markup will be present in the document, and any data-bind attributes on it will be applied. If your expression evaluates to false, the contained markup will be removed from your document without first applying any bindings to it.</source>
          <target state="translated">Выражение,которое вы хотите оценить.Если оно оценивает значение true (или true-ish),то содержащаяся в нем разметка будет присутствовать в документе,и к нему будут применены любые привязанные к данным атрибуты.Если ваше выражение оценивается как ложное,содержащаяся разметка будет удалена из документа без применения к нему каких-либо привязок.</target>
        </trans-unit>
        <trans-unit id="08b6e9421ee0e5a90e98af3344e9a07e58b28e79" translate="yes" xml:space="preserve">
          <source>The first parameter says what view model object you want to use with the declarative bindings it activates</source>
          <target state="translated">Первый параметр говорит о том,какой объект просмотра модели вы хотите использовать с декларативными привязками,которые он активирует</target>
        </trans-unit>
        <trans-unit id="b90ab49c50c0b034f2f0166f20a5588123515faf" translate="yes" xml:space="preserve">
          <source>The first time Knockout needs to construct a component with a given name, it:</source>
          <target state="translated">В первый раз Knockout нужно построить компонент с заданным именем,это:</target>
        </trans-unit>
        <trans-unit id="49abc06d3a5bd2396f32cea388b57547fd21ef1f" translate="yes" xml:space="preserve">
          <source>The following custom loader will take care of loading templates configured with a fromUrl value:</source>
          <target state="translated">Следующий пользовательский загрузчик позаботится о загрузке шаблонов,сконфигурированных со значением fromUrl:</target>
        </trans-unit>
        <trans-unit id="3995f6c348f83c5d5d2c8c0c8d7c7c7dfb7c996e" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to construct and work with computed observables.</source>
          <target state="translated">Следующая документация описывает,как построить и работать с вычисленными наблюдаемыми параметрами.</target>
        </trans-unit>
        <trans-unit id="0271855925638e4b40f25932438e098db254cb45" translate="yes" xml:space="preserve">
          <source>The following example shows that, if your array is observable, then the UI will be kept in sync with changes to that array.</source>
          <target state="translated">Следующий пример показывает,что если ваш массив наблюдаемый,то пользовательский интерфейс будет синхронизирован с изменениями в этом массиве.</target>
        </trans-unit>
        <trans-unit id="9b0edc57c644719ae6f6c9285db552bc68ee184f" translate="yes" xml:space="preserve">
          <source>The following functions read and write the default component loader&amp;rsquo;s registry:</source>
          <target state="translated">Следующие функции читают и записывают реестр загрузчика компонентов по умолчанию:</target>
        </trans-unit>
        <trans-unit id="c0549b512d611b4d61feda0a2b865a4445c3979c" translate="yes" xml:space="preserve">
          <source>The following functions work across the complete list of registered component loaders (not only the default loader):</source>
          <target state="translated">Следующие функции работают в полном списке зарегистрированных загрузчиков компонентов (а не только загрузчика по умолчанию):</target>
        </trans-unit>
        <trans-unit id="5e0d8a79330b00d1238373a646441103eff02bac" translate="yes" xml:space="preserve">
          <source>The following is a contrived example to demonstrate the ability of deferred updates to eliminate UI updates of intermediate values and how this can improve performance.</source>
          <target state="translated">Ниже приведен надуманный пример для демонстрации возможности отложенных обновлений для устранения обновлений промежуточных значений интерфейса и того,как это может улучшить производительность.</target>
        </trans-unit>
        <trans-unit id="3c11fe6c92bb9852e1a3441bd3a5eaa04a0bf79f" translate="yes" xml:space="preserve">
          <source>The following live example shows how you could use this:</source>
          <target state="translated">Следующий живой пример показывает,как вы могли бы использовать это:</target>
        </trans-unit>
        <trans-unit id="fbe9e5e7430435e030bf8f72ddf5fd35ac54309f" translate="yes" xml:space="preserve">
          <source>The following markup:</source>
          <target state="translated">Следующая разметка:</target>
        </trans-unit>
        <trans-unit id="9a36c23f779b16430f2a073c5b148d24516e2493" translate="yes" xml:space="preserve">
          <source>The following model represents data that you could render as a paged grid:</source>
          <target state="translated">Следующая модель представляет данные,которые можно отобразить в виде сетки страниц:</target>
        </trans-unit>
        <trans-unit id="b0852ae4081a5c612640e5df5209e727eefc9387" translate="yes" xml:space="preserve">
          <source>The following special variables are also available in bindings, but are not part of the binding context object:</source>
          <target state="translated">Следующие специальные переменные также доступны в привязках,но не являются частью контекстного объекта привязки:</target>
        </trans-unit>
        <trans-unit id="8f6eeb12ba06f0cf2cb646fe6069b9cdfdf92aea" translate="yes" xml:space="preserve">
          <source>The foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</source>
          <target state="translated">Привязка фораха дублирует участок разметки для каждого элемента массива и привязывает каждую копию этой разметки к соответствующему элементу массива.Это особенно полезно при отрисовке списков или таблиц.</target>
        </trans-unit>
        <trans-unit id="9050b1bc9f4409b41e99062ebff1d7799e7e99bd" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s click event.</source>
          <target state="translated">Функция, которую вы хотите привязать к событию щелчка элемента.</target>
        </trans-unit>
        <trans-unit id="a9c17e8675f71dfc3ebda72d93dbff1f7d1f9956" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s submit event.</source>
          <target state="translated">Функция, которую вы хотите привязать к событию отправки элемента.</target>
        </trans-unit>
        <trans-unit id="8f7a07f601445346a49b60b0d4248c64175eae01" translate="yes" xml:space="preserve">
          <source>The hasFocus binding links a DOM element&amp;rsquo;s focus state with a viewmodel property. It is a two-way binding, so:</source>
          <target state="translated">Привязка hasFocus связывает состояние фокуса элемента DOM со свойством viewmodel. Это двусторонняя привязка, поэтому:</target>
        </trans-unit>
        <trans-unit id="6b84448b778b60f9904ec346700cdf0d607944c3" translate="yes" xml:space="preserve">
          <source>The hidden binding works oppositely&amp;mdash;when the parameter is true, it hides the element by setting the display style to none; and when the parameter is false, it removes the display style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ab416911dfc8b9849c830b007486b93d0e2ffb" translate="yes" xml:space="preserve">
          <source>The html binding causes the associated DOM element to display the HTML specified by your parameter.</source>
          <target state="translated">Привязка html заставляет соответствующий элемент DOM отображать HTML,указанный вашим параметром.</target>
        </trans-unit>
        <trans-unit id="2d7f5cb6c1b083bcb208b0a402a5e11e8bc45313" translate="yes" xml:space="preserve">
          <source>The if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string).</source>
          <target state="translated">Если привязка приводит к появлению в документе раздела разметки (и к применению атрибутов привязки данных),то только в том случае,если указанное выражение вычисляется как true (или как значение true-ish,например,ненулевой объект или непустая строка).</target>
        </trans-unit>
        <trans-unit id="d6048125b8510f2371496031c443eb75903bc261" translate="yes" xml:space="preserve">
          <source>The ifnot binding is exactly the same as &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;, except that it inverts the result of whatever expression you pass to it. For more details, see documentation for &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;.</source>
          <target state="translated">Привязка ifnot точно такая же, как &lt;a href=&quot;if-binding&quot;&gt;привязка if&lt;/a&gt; , за исключением того, что она инвертирует результат любого выражения, которое вы ему передали. Дополнительные сведения см. В документации по &lt;a href=&quot;if-binding&quot;&gt;привязке if&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b925afaf6c73db524fb09147c998457d671b804" translate="yes" xml:space="preserve">
          <source>The ifnot binding works just like the if binding, except that it inverts the result of whatever expression you pass to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7044aff700ff62379c0951bf28dff3be7f0d55a6" translate="yes" xml:space="preserve">
          <source>The ignore array you specify in the mapping options is combined with the default ignore array. You can manipulate this default array like this:</source>
          <target state="translated">Массив игнорирования,который вы указываете в опциях отображения,комбинируется с массивом игнорирования по умолчанию.Вы можете управлять этим массивом по умолчанию следующим образом:</target>
        </trans-unit>
        <trans-unit id="5eeaae6307cf68ec3980cc78a92bb6a6591a6d9f" translate="yes" xml:space="preserve">
          <source>The include array you specify in the mapping options is combined with the default include array, which by default only contains _destroy. You can manipulate this default array like this:</source>
          <target state="translated">Указанный в настройках отображения массив include совмещен с массивом include по умолчанию,который по умолчанию содержит только _destroy.Вы можете управлять этим массивом по умолчанию следующим образом:</target>
        </trans-unit>
        <trans-unit id="b87740eb29c4e7b2de0e2d39f19f6cdb894afeb0" translate="yes" xml:space="preserve">
          <source>The index of the added array element</source>
          <target state="translated">Индекс добавленного элемента массива</target>
        </trans-unit>
        <trans-unit id="153c8a10482991a921027e17eb883d2bb702edb1" translate="yes" xml:space="preserve">
          <source>The index of the moved array element</source>
          <target state="translated">Индекс перемещенного элемента массива</target>
        </trans-unit>
        <trans-unit id="29a08ceacbce3d40e8f8be71109fda7e68478a29" translate="yes" xml:space="preserve">
          <source>The index of the removed array element</source>
          <target state="translated">Индекс удаленного элемента массива</target>
        </trans-unit>
        <trans-unit id="fb09d7316d9032eb6b50bdd38607e85a620a8ae9" translate="yes" xml:space="preserve">
          <source>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</source>
          <target state="translated">Функция indexOf возвращает индекс первого элемента массива,который равен вашему параметру.Например,myObservableArray.indexOf('Blah')вернёт нулевой индекс первого элемента массива,равного Bla,или значение -1,если совпадающего значения не найдено.</target>
        </trans-unit>
        <trans-unit id="69e9515a5f943cb16af4deed10ea470bb0ce01de" translate="yes" xml:space="preserve">
          <source>The inserted option element</source>
          <target state="translated">Вставленный опциональный элемент</target>
        </trans-unit>
        <trans-unit id="43d7b19d929050c04ef482f3719e22f56037aa52" translate="yes" xml:space="preserve">
          <source>The ko.ignoreDependencies function is available for scenarios where you want to execute code within a computed that should not contribute to that computed&amp;rsquo;s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.</source>
          <target state="translated">Функция ko.ignoreDependencies доступна для сценариев, в которых вы хотите выполнить код в вычисляемом, который не должен влиять на зависимости этого вычисляемого. Это часто полезно в настраиваемой привязке, когда вы хотите вызвать код, который может обращаться к наблюдаемым объектам, но вы не хотите повторно запускать привязку на основе изменений в этих наблюдаемых объектах.</target>
        </trans-unit>
        <trans-unit id="3b92b8d8bfa83e3158ebd9c44c77b03f552f6932" translate="yes" xml:space="preserve">
          <source>The let binding lets you set custom &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; properties that you can then reference in the bindings of all descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a260672088501d559448f92a0ce6366e87aebb" translate="yes" xml:space="preserve">
          <source>The main advantages of subscribing to changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057f946e0fbc4388b4cadbdea03e0218892b3f30" translate="yes" xml:space="preserve">
          <source>The main reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e70afc86097fdbd770f7db83c02acc1eb5189b8" translate="yes" xml:space="preserve">
          <source>The mapped observable array also exposes a mappedCreate function:</source>
          <target state="translated">Отображение наблюдаемого массива также обнажает функцию mappedCreate:</target>
        </trans-unit>
        <trans-unit id="aa853229a04ee061c08286d3f3f9d23ede4d8580" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts any of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bf44e52d770989f5c1e8f38818ebe340c1c206" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts the following values:</source>
          <target state="translated">Опция метода управляет при пожаре уведомлений и принимает следующие значения:</target>
        </trans-unit>
        <trans-unit id="746cbdd45a1a4b3b4493f7c5d3603dfd8515ae49" translate="yes" xml:space="preserve">
          <source>The moved array element</source>
          <target state="translated">Перемещенный элемент массива</target>
        </trans-unit>
        <trans-unit id="a4d37fddd3510152eb42158703c05ddb3d9aef39" translate="yes" xml:space="preserve">
          <source>The object that you want to use as the context for binding descendant elements.</source>
          <target state="translated">Объект,который вы хотите использовать в качестве контекста для привязки элементов-потомков.</target>
        </trans-unit>
        <trans-unit id="cf7c2b7cc23dbce0f5f5998ff2b85f43ee703917" translate="yes" xml:space="preserve">
          <source>The observe array you specify in the mapping options is combined with the default observe array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="translated">Массив наблюдений,который вы указываете в опциях отображения,комбинируется с массивом наблюдений по умолчанию,который по умолчанию пуст.Вы можете манипулировать этим массивом по умолчанию следующим образом:</target>
        </trans-unit>
        <trans-unit id="40607abcaf26d4c21ed2b1d2dda932e347adb699" translate="yes" xml:space="preserve">
          <source>The only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="translated">Единственная причина использовать ifnot вместо отрицательного if-это дело вкуса:многие разработчики считают,что это выглядит аккуратнее.</target>
        </trans-unit>
        <trans-unit id="6dd503e19f27964041b8e7f04ad17561a372b88b" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your create callback is a JavaScript object containing:</source>
          <target state="translated">Аргумент опций,поставляемый для вашего обратного вызова-это объект JavaScript,содержащий:</target>
        </trans-unit>
        <trans-unit id="acc3ee61c9b4ee99cc1a57fa897a3b346a227831" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your update callback is a JavaScript object containing:</source>
          <target state="translated">Аргумент опций,поставляемый для обратного вызова обновления,содержит объект JavaScript:</target>
        </trans-unit>
        <trans-unit id="3f54901ff390f831f573f9eb13f6386cf4f2454e" translate="yes" xml:space="preserve">
          <source>The options binding controls what options should appear in a drop-down list (i.e., a &amp;lt;select&amp;gt; element) or multi-select list (e.g., &amp;lt;select size='6'&amp;gt;). This binding cannot be used with anything other than &amp;lt;select&amp;gt; elements.</source>
          <target state="translated">Связывание параметров определяет, какие параметры должны отображаться в раскрывающемся списке (например, в элементе &amp;lt;select&amp;gt;) или в списке с множественным выбором (например, &amp;lt;select size = '6'&amp;gt;). Эта привязка не может использоваться ни с чем, кроме элементов &amp;lt;select&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="162c8d94929e2437460193ade4632f67b6acd841" translate="yes" xml:space="preserve">
          <source>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</source>
          <target state="translated">Другая хитрость заключается в том,что декларативные привязки просто реализуются в виде вычисляемых наблюдений.Таким образом,если связка считывает значение наблюдаемого,то эта связка становится зависимой от наблюдаемого,что приводит к переоценке этой связки при изменении наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="1e4ab2afdfa512feba70d54157853368ea9af9fa" translate="yes" xml:space="preserve">
          <source>The parameter value should be a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, the binding will update the classes whenever the value changes, removing any previously added classes and adding the class or classes from new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c6da254c285296a2484119e3b32c7ea72d4244" translate="yes" xml:space="preserve">
          <source>The preceding view model code demonstrates the &lt;em&gt;single parameter syntax&lt;/em&gt; for initializing computed observables. See the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt; for the full list of available options.</source>
          <target state="translated">Предыдущий код модели представления демонстрирует &lt;em&gt;синтаксис&lt;/em&gt; с &lt;em&gt;одним параметром&lt;/em&gt; для инициализации вычисленных наблюдаемых. См. Полный список доступных опций в &lt;a href=&quot;computed-reference&quot;&gt;справочнике&lt;/a&gt; по вычисляемым наблюдаемым .</target>
        </trans-unit>
        <trans-unit id="1eba8a376d4e1fe3d6273f564007f1679bed7333" translate="yes" xml:space="preserve">
          <source>The problem is that this will cause &lt;em&gt;two&lt;/em&gt; Ajax requests: the first one will start when you update pageSize, and the second one will start immediately afterwards when you update pageIndex. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</source>
          <target state="translated">Проблема в том, что это вызовет &lt;em&gt;два&lt;/em&gt; запроса Ajax: первый запускается при обновлении pageSize, а второй запускается сразу после обновления pageIndex. Это бесполезная трата полосы пропускания и ресурсов сервера, а также источник непредсказуемых условий гонки.</target>
        </trans-unit>
        <trans-unit id="b522befc4330a68fe68cf46705ab6afd4d8d2cc9" translate="yes" xml:space="preserve">
          <source>The provided callback will be run whenever the event is notified, &lt;em&gt;except if the node is empty&lt;/em&gt;. For the childrenComplete event, the function is called with two parameters, an array of child nodes and the child view model. The descendantsComplete callback function is called with just the parent node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cce1f32edc965597a382d568819abb832a7fd0" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="translated">Самый быстрый и интересный способ начать работу - это проработать &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;интерактивные руководства&lt;/a&gt; . После того, как вы освоите основы, изучите &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;живые примеры,&lt;/a&gt; а затем примените их в своем собственном проекте.</target>
        </trans-unit>
        <trans-unit id="30c858124194194531fae54788b9b3bfb9b8913c" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;https://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea006c24537a65a2ba624708630c7fc651c4642e" translate="yes" xml:space="preserve">
          <source>The rateLimit extender can be applied to any type of observable, including &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt; and &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;. The main use cases for rate-limiting are:</source>
          <target state="translated">Расширитель rateLimit может применяться к любому типу наблюдаемого, включая &lt;a href=&quot;observablearrays&quot;&gt;массивы наблюдаемых&lt;/a&gt; и &lt;a href=&quot;computedobservables&quot;&gt;вычисляемые наблюдаемые&lt;/a&gt; . Основные варианты использования ограничения скорости:</target>
        </trans-unit>
        <trans-unit id="b7fb3e0a025185b71bc07f0984aae74db606ff1f" translate="yes" xml:space="preserve">
          <source>The reason you shouldn&amp;rsquo;t use a &lt;em&gt;pure&lt;/em&gt; computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it&amp;rsquo;s important for the evaluator to always run when dependencies change, use a &lt;a href=&quot;computedobservables&quot;&gt;regular computed&lt;/a&gt; instead.</source>
          <target state="translated">Причина, по которой вы не должны использовать &lt;em&gt;чистое&lt;/em&gt; вычисление, если оценщик имеет важные побочные эффекты, заключается просто в том, что оценщик не будет запускаться, если вычисляемый не имеет активных подписчиков (и поэтому находится в спящем режиме). Если важно, чтобы оценщик всегда запускался при изменении зависимостей, используйте вместо этого &lt;a href=&quot;computedobservables&quot;&gt;обычные вычисления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43b68b7f8a261dc6fd71424b790107e7bba36eec" translate="yes" xml:space="preserve">
          <source>The removed array element</source>
          <target state="translated">Удаленный элемент массива</target>
        </trans-unit>
        <trans-unit id="2b8edfced12b2275ac8a80e2f1255222d87df6ce" translate="yes" xml:space="preserve">
          <source>The rest of this page describes observableArray&amp;rsquo;s functions for reading and writing array information.</source>
          <target state="translated">Остальная часть этой страницы описывает функции observableArray для чтения и записи информации о массивах.</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">Результат будет:</target>
        </trans-unit>
        <trans-unit id="c8738ad7d358e2c69d84d24c2be85c7b85214872" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</source>
          <target state="translated">Возвращаемый объект AMD-модуля может быть в любой из форм,разрешенных для видо-моделей.Таким образом,это может быть функция конструктора,например:</target>
        </trans-unit>
        <trans-unit id="f55dc67e0ec57a14fa41387c5f86cbfbf87a4bdb" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js&amp;rsquo;s text plugin&lt;/a&gt;:</source>
          <target state="translated">Возвращаемый объект модуля AMD может быть в любой из форм, разрешенных для моделей просмотра. Таким образом, это может быть строка разметки, например, полученная с помощью &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;текстового плагина require.js&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="97f1dd160bf2d7329f218a8a066037037fd32f5a" translate="yes" xml:space="preserve">
          <source>The second parameter to ko.computed (the bit where we passed this in the above example) defines the value of this when evaluating the computed observable. Without passing it in, it would not have been possible to refer to this.firstName() or this.lastName(). Experienced JavaScript coders will regard this as obvious, but if you&amp;rsquo;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for this, but JavaScript does, because its functions themselves aren&amp;rsquo;t part of any object by default.)</source>
          <target state="translated">Второй параметр ko.computed (бит, в который мы передали this в приведенном выше примере) определяет значение this при оценке вычисляемой наблюдаемой. Без его передачи было бы невозможно сослаться на this.firstName () или this.lastName (). Опытные кодеры JavaScript сочтут это очевидным, но если вы все еще знакомитесь с JavaScript, это может показаться странным. (Такие языки, как C # и Java, никогда не ожидают, что программист установит для этого значение, но JavaScript делает это, потому что его функции сами по себе не являются частью какого-либо объекта по умолчанию.)</target>
        </trans-unit>
        <trans-unit id="276174d892c3bad296aa46c527585e258f34f083" translate="yes" xml:space="preserve">
          <source>The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a &amp;lt;select&amp;gt; element and the options binding.</source>
          <target state="translated">Привязка selectedOptions контролирует, какие элементы в списке с множественным выбором выбраны в данный момент. Это предназначено для использования в сочетании с элементом &amp;lt;select&amp;gt; и привязкой параметров.</target>
        </trans-unit>
        <trans-unit id="8e064f117111b091febd6324a44a5d55fdf3a4a8" translate="yes" xml:space="preserve">
          <source>The server might return JSON data similar to the following:</source>
          <target state="translated">Сервер может возвращать JSON данные,аналогичные приведенным ниже:</target>
        </trans-unit>
        <trans-unit id="4b0df9758bfbf2068ff3ee480efe9e6ed9e4ab1a" translate="yes" xml:space="preserve">
          <source>The shorthand value can also be observable. In this case, if it changes, the component binding will &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;dispose&lt;/a&gt; the old component instance, and inject the newly-referenced component. Example:</source>
          <target state="translated">Сокращенное значение также можно наблюдать. В этом случае, если он изменится, привязка компонента &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;удалит&lt;/a&gt; старый экземпляр компонента и внедрит новый компонент, на который имеется ссылка. Пример:</target>
        </trans-unit>
        <trans-unit id="049fd86ea4cbaee495bc01813f2e795073b4e49c" translate="yes" xml:space="preserve">
          <source>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</source>
          <target state="translated">Функция среза является наблюдаемымArray-эквивалентом родной функции среза JavaScript (т.е.возвращает записи вашего массива из заданного стартового индекса до заданного конечного индекса).Вызов myObservableArray.slice(...)эквивалентен вызову того же метода на базовом массиве (т.е.myObservableArray().slice(...)).</target>
        </trans-unit>
        <trans-unit id="51256b6bbeb757b7a3e53c454df3877ec1922f40" translate="yes" xml:space="preserve">
          <source>The standard method of defining a &lt;em&gt;pure&lt;/em&gt; computed observable is to use ko.pureComputed:</source>
          <target state="translated">Стандартный метод определения &lt;em&gt;чисто&lt;/em&gt; вычисляемой наблюдаемой - использовать ko.pureComputed:</target>
        </trans-unit>
        <trans-unit id="47dbc61c148aa218c24d0f4919a72baba631be9b" translate="yes" xml:space="preserve">
          <source>The style binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.</source>
          <target state="translated">Привязка стилей добавляет или удаляет одно или несколько значений стилей к соответствующему элементу DOM.Это полезно,например,для выделения некоторого значения красным цветом,если оно становится отрицательным,или для установки ширины бара в соответствии с изменяющимся числовым значением.</target>
        </trans-unit>
        <trans-unit id="1ef276a741bad031dcded61f8068495eb09f16a8" translate="yes" xml:space="preserve">
          <source>The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on form elements.</source>
          <target state="translated">Привязка submit добавляет обработчик события,так что выбранная вами функция JavaScript будет вызвана при отправке связанного элемента DOM.Обычно вы хотите использовать это только для элементов формы.</target>
        </trans-unit>
        <trans-unit id="f2b3c41c3803b6fdf7bb3dcb97584e848e98e1cc" translate="yes" xml:space="preserve">
          <source>The subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is &quot;change&quot;) is the name of the event to receive notification for.</source>
          <target state="translated">Функция подписки принимает три параметра:обратный вызов-это функция,которая вызывается всякий раз,когда происходит оповещение,цель (необязательно)определяет значение этого в функции обратного вызова,а событие (необязательно;по умолчанию-&quot;изменение&quot;)-это название события,для которого нужно получить оповещение.</target>
        </trans-unit>
        <trans-unit id="016b4f1bb0fd10e4b91ab01327aa8086f3b0e070" translate="yes" xml:space="preserve">
          <source>The subscribe function is how many parts of KO work internally. Most of the time you don&amp;rsquo;t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</source>
          <target state="translated">Функция подписки определяет, сколько частей KO работает внутри компании. В большинстве случаев вам не нужно это использовать, потому что встроенные привязки и система шаблонов заботятся об управлении подписками.</target>
        </trans-unit>
        <trans-unit id="046a68fc34463623e0087f15d2cbe37f0a99e3bf" translate="yes" xml:space="preserve">
          <source>The syntax is more convenient. To call KO&amp;rsquo;s push method, just write myObservableArray.push(...). This is slightly nicer than calling the underlying array&amp;rsquo;s push method by writing myObservableArray().push(...).</source>
          <target state="translated">Синтаксис удобнее. Чтобы вызвать метод KO push, просто напишите myObservableArray.push (...). Это немного лучше, чем вызов метода push базового массива путем записи myObservableArray (). Push (...).</target>
        </trans-unit>
        <trans-unit id="bd48513a1e40433618e2382185d34142f3816b64" translate="yes" xml:space="preserve">
          <source>The template binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</source>
          <target state="translated">Привязка шаблона заполняет ассоциированный элемент DOM с результатами отрисовки шаблона.Шаблоны-это простой и удобный способ построения сложных структур пользовательского интерфейса-возможно,с повторяющимися или вложенными блоками-в зависимости от данных вашей модели представления.</target>
        </trans-unit>
        <trans-unit id="ca419c4cef8d81280ee9a194d266426d67669957" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or { element: &quot;someId&quot; } or a custom format such as { loadFromUrl: &quot;someUrl.html&quot; }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ef5b8434eccb8c5846957e191b2353bcb8c255" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or {element:&quot;someId&quot;} or a custom format such as {loadFromUrl:&quot;someUrl.html&quot;}.</source>
          <target state="translated">Значение templateConfig-это просто свойство шаблона любого объекта componentConfig.Например,оно может содержать &quot;некоторую разметку&quot; или {element:&quot;someId&quot;},или пользовательский формат,такой как {loadFromUrl:&quot;someUrl.html&quot;}.</target>
        </trans-unit>
        <trans-unit id="c0cfb1138db7edd7758273fad1e4a3a38ac65bd9" translate="yes" xml:space="preserve">
          <source>The text binding causes the associated DOM element to display the text value of your parameter.</source>
          <target state="translated">Привязка текста заставляет соответствующий элемент DOM отображать текстовое значение вашего параметра.</target>
        </trans-unit>
        <trans-unit id="583c97cdc5485ae99a9042d6a2aa5ca3bd365673" translate="yes" xml:space="preserve">
          <source>The textInput binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.</source>
          <target state="translated">Привязка textInput специально разработана для работы с широким спектром причуд браузера,чтобы обеспечить последовательное и немедленное обновление модели даже в ответ на необычные методы ввода текста.</target>
        </trans-unit>
        <trans-unit id="98c7d7411d6cd38a5fa10c5e758660c706e016b3" translate="yes" xml:space="preserve">
          <source>The textInput binding links a text box (&amp;lt;input&amp;gt;) or text area (&amp;lt;textarea&amp;gt;) with a viewmodel property, providing two-way updates between the viewmodel property and the element&amp;rsquo;s value. Unlike the value binding, textInput provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.</source>
          <target state="translated">Привязка textInput связывает текстовое поле (&amp;lt;input&amp;gt;) или текстовую область (&amp;lt;textarea&amp;gt;) со свойством viewmodel, обеспечивая двусторонние обновления между свойством viewmodel и значением элемента. В отличие от привязки значений, textInput обеспечивает мгновенные обновления из DOM для всех типов пользовательского ввода, включая автозаполнение, перетаскивание и события буфера обмена.</target>
        </trans-unit>
        <trans-unit id="c97b5f8151ffd9c3cb4b842df2c6ab37add94e04" translate="yes" xml:space="preserve">
          <source>The uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.</source>
          <target state="translated">Привязка uniqueName гарантирует,что связанный элемент DOM имеет непустой атрибут имени.Если у DOM-элемента не было атрибута имени,то эта привязка дает ему единицу и устанавливает его в некоторое уникальное значение строки.</target>
        </trans-unit>
        <trans-unit id="ffad5e24eda165b5281cd7898585addd3dd621b6" translate="yes" xml:space="preserve">
          <source>The using binding was introduced in Knockout 3.5 as a replacement for with when re-rendering descendant elements isn&amp;rsquo;t desired. Because using re-evaluates descendant bindings instead of re-rendering, each descendant binding will include an additional dependency on the using context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad9163f8b350f9acb1cee05eb1ef6108edde552" translate="yes" xml:space="preserve">
          <source>The value binding links the associated DOM element&amp;rsquo;s value with a property on your view model. This is typically useful with form elements such as &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; and &amp;lt;textarea&amp;gt;.</source>
          <target state="translated">Привязка значения связывает значение связанного элемента DOM со свойством в вашей модели представления. Обычно это полезно с такими элементами формы, как &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; и &amp;lt;textarea&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="9387180a42aa7a17b48448a72d7472f68cb9f230" translate="yes" xml:space="preserve">
          <source>The value of the computed observable shouldn&amp;rsquo;t vary based on the number of evaluations or other &amp;ldquo;hidden&amp;rdquo; information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.</source>
          <target state="translated">Значение вычисляемой наблюдаемой не должно изменяться в зависимости от количества оценок или другой &amp;laquo;скрытой&amp;raquo; информации. Его значение должно основываться исключительно на значениях других наблюдаемых в приложении, которые для определения чистой функции считаются ее параметрами.</target>
        </trans-unit>
        <trans-unit id="14eb51c71508d408d23b29aa7938c5e57a2a7c2e" translate="yes" xml:space="preserve">
          <source>The value you assign should be an array (or observable array). The &amp;lt;select&amp;gt; element will then display one item for each item in your array.</source>
          <target state="translated">Присваиваемое значение должно быть массивом (или наблюдаемым массивом). Затем элемент &amp;lt;select&amp;gt; отобразит по одному элементу для каждого элемента в вашем массиве.</target>
        </trans-unit>
        <trans-unit id="36f23cd9c77e7cb60fe52409d6584a0d06a1e402" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as { myViewModelType: 'Something', options: {} }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe79d0c6fc554a50ffe91a6318c3a95369cb8cac" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as {myViewModelType:'Something',options:{}}.</source>
          <target state="translated">Значение viewModelConfig-это просто свойство viewModel из любого объекта componentConfig.Например,это может быть функция конструктора,или пользовательский формат,такой как {myViewModelType:'Something',options:{}}.</target>
        </trans-unit>
        <trans-unit id="9d1d5f92e2fbae1ac4a6228b675e79f83cfdcae3" translate="yes" xml:space="preserve">
          <source>The visible and hidden bindings cause the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff29c13e73c111a3106d90b4abd24a7404d96b9c" translate="yes" xml:space="preserve">
          <source>The visible binding causes the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="translated">Видимая привязка приводит к тому,что связанный с ним элемент DOM становится скрытым или видимым в соответствии со значением,которое вы передаете в привязке.</target>
        </trans-unit>
        <trans-unit id="3dcca4073da45812cd05022db33c86a1c7087f8e" translate="yes" xml:space="preserve">
          <source>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That&amp;rsquo;s what many of KO&amp;rsquo;s built-in bindings do internally. So, when you wrote data-bind=&quot;text: personName&quot;, the text binding registered itself to be notified when personName changes (assuming it&amp;rsquo;s an observable value, which it is now).</source>
          <target state="translated">Весь смысл наблюдаемых в том, что их можно наблюдать, то есть другой код может сказать, что он хочет получать уведомления об изменениях. Это то, что делают многие встроенные привязки KO внутри. Итак, когда вы написали data-bind = &quot;text: personName&quot;, привязка текста зарегистрировалась, чтобы получать уведомление при изменении personName (при условии, что это наблюдаемое значение, каковым сейчас является).</target>
        </trans-unit>
        <trans-unit id="3f1f6f9b20e9fb3bb3210dbf3af9429326222e27" translate="yes" xml:space="preserve">
          <source>The with and using bindings create a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object. (The differences between these binding are described below under &lt;a href=&quot;#parameters&quot;&gt;Parameters&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08840010b83b1dfd4295b6784268bddb1bef073c" translate="yes" xml:space="preserve">
          <source>The with binding creates a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object.</source>
          <target state="translated">Привязка with создает новый &lt;a href=&quot;binding-context&quot;&gt;контекст привязки&lt;/a&gt; , так что дочерние элементы связываются в контексте указанного объекта.</target>
        </trans-unit>
        <trans-unit id="524ea84b41e8a5893953b0074485b90cf1eff52f" translate="yes" xml:space="preserve">
          <source>The with binding will dynamically add or remove descendant elements depending on whether the associated value is null/undefined or not</source>
          <target state="translated">Привязка будет динамически добавлять или удалять элементы-потомки в зависимости от того,является ли соответствующее значение нулевым/неопределенным или нет.</target>
        </trans-unit>
        <trans-unit id="7e032d672f4e300f7eeb1bbf7504868ad1577af8" translate="yes" xml:space="preserve">
          <source>Then, with this componentConfig object, calls each of the registered loaders&amp;rsquo; loadComponent functions in turn, until the first one supplies a non-null template/createViewModel pair.</source>
          <target state="translated">Затем с помощью этого объекта componentConfig по очереди вызывает каждую из зарегистрированных функций загрузчика loadComponent, пока первая не предоставит ненулевую пару шаблон / createViewModel.</target>
        </trans-unit>
        <trans-unit id="af5fd56709b842c37eecfef0bd5fee58c13743cd" translate="yes" xml:space="preserve">
          <source>Then, you can use jQuery.tmpl syntax in your templates. For example,</source>
          <target state="translated">Затем,вы можете использовать синтаксис jQuery.tmpl в своих шаблонах.Например,</target>
        </trans-unit>
        <trans-unit id="1da7ec95f9f3bd6c9bcf839432044e2340b7b515" translate="yes" xml:space="preserve">
          <source>Then, your custom function will become available on all values of that type created from that point onwards.</source>
          <target state="translated">Затем,ваша пользовательская функция станет доступной для всех значений этого типа,созданных с этого момента.</target>
        </trans-unit>
        <trans-unit id="ef90eaff20a0b48ba01c7718ddb2303b2510f1e6" translate="yes" xml:space="preserve">
          <source>There are a few different methods to subscribe to these events depending on how and in which context you want to be notified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd22bd8141f2da85ed82fbfb3975c4c5b8fe254b" translate="yes" xml:space="preserve">
          <source>There are two main ways of using templates:</source>
          <target state="translated">Существует два основных способа использования шаблонов:</target>
        </trans-unit>
        <trans-unit id="88cee14671dcbec805136df550f741e76f165562" translate="yes" xml:space="preserve">
          <source>There are two ways to use the component binding:</source>
          <target state="translated">Существует два способа использования привязки компонентов:</target>
        </trans-unit>
        <trans-unit id="624acfe0a4456c96d3f7eb19804d2c53591e62dd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a popular convention that avoids the need to track this altogether: if your viewmodel&amp;rsquo;s constructor copies a reference to this into a different variable (traditionally called self), you can then use self throughout your viewmodel and don&amp;rsquo;t have to worry about it being redefined to refer to something else. For example:</source>
          <target state="translated">Существует популярное соглашение, которое позволяет полностью избежать необходимости отслеживать это: если конструктор вашей модели просмотра копирует ссылку на this в другую переменную (традиционно называемую self), вы можете затем использовать self во всей своей модели просмотра и не беспокоиться о том, что это переопределено для обозначения чего-то другого. Например:</target>
        </trans-unit>
        <trans-unit id="6450a2048f4541541638ab826b4b88f938c3d11d" translate="yes" xml:space="preserve">
          <source>These bindings differ in how they deal with a value of null or undefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9ab8b7fe51fd19f340b30884a7d3b54127cb49" translate="yes" xml:space="preserve">
          <source>These events will generally be notified even if a node is empty. If the node&amp;rsquo;s contents are re-rendered, such as by a control-flow binding like &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;, these events will be notified again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d3a6cc255f075aee8c59ce311e982c597bc606" translate="yes" xml:space="preserve">
          <source>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it&amp;rsquo;s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object&amp;rsquo;s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</source>
          <target state="translated">Эти примеры показывают, что значением может быть любое выражение JavaScript. Подходит даже запятая, если она заключена в фигурные скобки, скобки или круглые скобки. Если значение является литералом объекта, имена свойств объекта должны быть допустимыми идентификаторами JavaScript или заключены в кавычки. Если значение привязки является недопустимым выражением или ссылается на неизвестную переменную, Knockout выдаст ошибку и прекратит обработку привязок.</target>
        </trans-unit>
        <trans-unit id="1f3eb587b2006b4e40fc88eeb1c957f9aa6b49ff" translate="yes" xml:space="preserve">
          <source>These facilities are typically useful only in advanced scenarios, for example when your computed observable&amp;rsquo;s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</source>
          <target state="translated">Эти средства обычно полезны только в расширенных сценариях, например, когда основной целью вычисляемого наблюдаемого является запуск некоторого побочного эффекта во время его оценщика, и вы хотите выполнить некоторую логику настройки только во время первого запуска или только если он имеет как минимум одна зависимость (и, следовательно, может быть переоценена в будущем). Большинству вычисляемых свойств не нужно заботиться о том, оценивались ли они раньше или сколько у них зависимостей.</target>
        </trans-unit>
        <trans-unit id="07ffcc399a3f0a54ad9c2648a23eb7d7ec9c57ef" translate="yes" xml:space="preserve">
          <source>These helper functions can be used in event handlers that are attached unobtrusively using something like jQuery&amp;rsquo;s bind or click. The above function could be attached to each link with a remove class like:</source>
          <target state="translated">Эти вспомогательные функции можно использовать в обработчиках событий, которые ненавязчиво подключаются с помощью чего-то вроде привязки или щелчка jQuery. Вышеупомянутая функция может быть прикреплена к каждой ссылке с помощью класса удаления, например:</target>
        </trans-unit>
        <trans-unit id="8797502eb386f1c824a0aa629bcaa04c161fe178" translate="yes" xml:space="preserve">
          <source>They are functionally equivalent to the regular ko.observableArray functions, but can do things based on the key of the object. For example, this would work:</source>
          <target state="translated">Они функционально эквивалентны обычным функциям ko.observableArray,но могут делать вещи на основе ключа объекта.Например,это сработает:</target>
        </trans-unit>
        <trans-unit id="18962a789df3d7447e4daeeed751e58a433346fb" translate="yes" xml:space="preserve">
          <source>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn&amp;rsquo;t work on IE 8 or earlier, but KO&amp;rsquo;s indexOf works everywhere.)</source>
          <target state="translated">Они работают во всех целевых браузерах. (Например, встроенная функция JavaScript indexOf не работает в IE 8 или более ранних версиях, но indexOf KO работает везде.)</target>
        </trans-unit>
        <trans-unit id="b23e367c7cba12e6cfcd6e2cb9f9d24753504d55" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;special list&amp;rdquo; example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog&amp;rsquo;s heading and borders) wrapped around arbitrary supplied markup.</source>
          <target state="translated">Этот пример &amp;laquo;специального списка&amp;raquo; не делает ничего, кроме вставки заголовка над каждым элементом списка. Но тот же метод можно использовать для создания сложных сеток, диалогов, наборов вкладок и т. Д., Поскольку все, что требуется для таких элементов пользовательского интерфейса, - это общая разметка пользовательского интерфейса (например, для определения заголовка и границ сетки или диалогового окна), обернутых вокруг произвольных поставленная разметка.</target>
        </trans-unit>
        <trans-unit id="5fac83af14640609f6eb7dbff17d1de27fd0b429" translate="yes" xml:space="preserve">
          <source>This ability is especially useful when paired with &lt;a href=&quot;binding-preprocessing&quot;&gt;binding preprocessing&lt;/a&gt;, which can assign a default value for a binding.</source>
          <target state="translated">Эта возможность особенно полезна в сочетании с &lt;a href=&quot;binding-preprocessing&quot;&gt;предварительной обработкой привязки&lt;/a&gt; , которая может присвоить привязке значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bcf4fe4f919e5f9a307b9e9f04eda05c1f8836ad" translate="yes" xml:space="preserve">
          <source>This allows for a very modern, &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt;-like way to organize your code, while retaining support for even very old browsers (see &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;custom elements and IE 6 to 8&lt;/a&gt;).</source>
          <target state="translated">Это позволяет использовать очень современный способ организации кода , &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;подобный WebComponents&lt;/a&gt; , при сохранении поддержки даже для очень старых браузеров (см. &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;Пользовательские элементы и IE 6-8&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1eb5e5d48d4ea01bc727416a9600946df475abd7" translate="yes" xml:space="preserve">
          <source>This automatically creates observable properties for each of the properties on data. Then, every time you receive new data from the server, you can update all the properties on viewModel in one step by calling the ko.mapping.fromJS function again:</source>
          <target state="translated">Это автоматически создает наблюдаемые свойства для каждого из свойств на данных.Затем,каждый раз,когда вы получаете новые данные с сервера,вы можете обновить все свойства на viewModel за один шаг,снова вызвав функцию ko.mapping.fromJS:</target>
        </trans-unit>
        <trans-unit id="50dfddf19ae9e5c9f7164b96b3b17f0f1a097c05" translate="yes" xml:space="preserve">
          <source>This contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using ko.toJSON as follows:</source>
          <target state="translated">Она содержит сочетание обсерваторий,вычисляемых обсерваторий,обсерваторных массивов и простых значений.Вы можете преобразовать его в JSON строку,подходящую для отправки на сервер,используя ko.toJSON следующим образом:</target>
        </trans-unit>
        <trans-unit id="6e7f5312e7a860e5c84608a61ebd0ff4a1fe6f16" translate="yes" xml:space="preserve">
          <source>This double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (params.myExpr) to unwrap its value for you. That is, the component can read params.myExpr() to get the value of whichever observable has been selected (observable1 or observable2), without the need for double-unwrapping.</source>
          <target state="translated">Это двойное обертывание было бы уродливо,неудобно и неожиданно,поэтому Knockout автоматически настраивает сгенерированное вычислительное свойство (params.myExpr),чтобы развернуть его значение для вас.То есть компонент может считывать params.myExpr(),чтобы получить значение любой наблюдаемой области (наблюдаемой1 или наблюдаемой2),без необходимости двойного распаковывания.</target>
        </trans-unit>
        <trans-unit id="835c1c20db465de114b6ecf00cf935dce609fbad" translate="yes" xml:space="preserve">
          <source>This easy to do: just add an additional parameter with name optionsCaption, with its value being a string to display. For example:</source>
          <target state="translated">Это легко сделать:просто добавьте дополнительный параметр с именем optionsCaption,значение которого будет отображаться в виде строки.Например:</target>
        </trans-unit>
        <trans-unit id="0f6f4ddca2613356e2726599ab4684e2eaa1b28b" translate="yes" xml:space="preserve">
          <source>This example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.</source>
          <target state="translated">В этом примере создается расширитель,позволяющий помечать наблюдаемый объект по мере необходимости.Вместо того,чтобы возвращать новый объект,этот расширитель просто добавляет дополнительные суб-наблюдаемые к существующему наблюдаемому.Так как наблюдаемые-это функции,они могут на самом деле иметь свои собственные свойства.Однако,когда модель представления преобразуется в JSON,суб-наблюдаемые будут удалены,и мы просто останемся со значением нашей фактической наблюдаемой.Это хороший способ добавить дополнительную функциональность,которая актуальна только для пользовательского интерфейса и не нуждается в отправке обратно на сервер.</target>
        </trans-unit>
        <trans-unit id="65ecaa594cf97a786d25b11561c62fb053ea502c" translate="yes" xml:space="preserve">
          <source>This example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.</source>
          <target state="translated">В этом примере создается экстендер,который заставляет записывать в наблюдаемом виде округленные до настраиваемого уровня точности цифры.В этом случае расширитель вернет новый наблюдаемый объект,который будет находиться перед реальными наблюдаемыми перехватывающими записями.</target>
        </trans-unit>
        <trans-unit id="7bc47da371a683aaa1120d6ec7b6e5389241143d" translate="yes" xml:space="preserve">
          <source>This example declares a component, and then injects two instances of it into a view. See the source code below.</source>
          <target state="translated">Этот пример объявляет компонент,а затем вводит два его экземпляра в представление.См.исходный код ниже.</target>
        </trans-unit>
        <trans-unit id="579304ee7faef55eabaa909aa4e1dc99ece5d462" translate="yes" xml:space="preserve">
          <source>This example shows &amp;ldquo;add&amp;rdquo; and &amp;ldquo;remove&amp;rdquo; links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link.</source>
          <target state="translated">В этом примере показаны ссылки &amp;laquo;добавить&amp;raquo; и &amp;laquo;удалить&amp;raquo; на нескольких уровнях родителей и потомков с одним обработчиком, ненавязчиво прикрепленным для каждого типа ссылки.</target>
        </trans-unit>
        <trans-unit id="e7d030e3401c09158dec61fedd6b90ab7f45ab5c" translate="yes" xml:space="preserve">
          <source>This example shows that the if binding can dynamically add and remove sections of markup as observable values change.</source>
          <target state="translated">Этот пример показывает,что если привязка может динамически добавлять и удалять участки разметки при изменении наблюдаемых значений.</target>
        </trans-unit>
        <trans-unit id="969c85da8be854a1b6c00abcfd3856c63f7a00ff" translate="yes" xml:space="preserve">
          <source>This example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.</source>
          <target state="translated">В этом примере просто отображается сообщение,если в текстовом поле в настоящее время есть фокус,и используется кнопка,показывающая,что вы можете вызвать фокус программно.</target>
        </trans-unit>
        <trans-unit id="d2a7a601d44439dd914189703f94ab3cea4924d9" translate="yes" xml:space="preserve">
          <source>This example uses foreach to produce a read-only table with a row for each array entry.</source>
          <target state="translated">Этот пример использует foreach для создания таблицы только для чтения со строкой для каждого элемента массива.</target>
        </trans-unit>
        <trans-unit id="d0a6677ca47c0e8f5d5df08e50b25d599f696a47" translate="yes" xml:space="preserve">
          <source>This functionality applies to errors in the following contexts:</source>
          <target state="translated">Эта функциональность применима к ошибкам в следующих контекстах:</target>
        </trans-unit>
        <trans-unit id="da0d1aeda4e842abb4270aaff5c44f9cf5e0cbec" translate="yes" xml:space="preserve">
          <source>This gives the same result as embedding an anonymous template directly inside the element to which you use foreach, i.e.:</source>
          <target state="translated">Это дает тот же результат,что и встраивание анонимного шаблона непосредственно внутри элемента,для которого вы используете форекс,т.е:</target>
        </trans-unit>
        <trans-unit id="41e844da340b97cc893e368b759205db3d2224b9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object { id : 1, name : 'Alicw' } does not equal { id : 1, name : 'Alice' } it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66096e1d294700a561ed7c38d1667f6e3e659ad9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object {id:1,name:'Alicw'} does not equal {id:1,name:'Alice'} it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="translated">Это происходит потому, что по умолчанию подключаемый модуль сопоставления просто сравнивает два объекта в массиве. И поскольку в JavaScript объект {id: 1, name: 'Alicw'} не равен {id: 1, name: 'Alice'}, он думает, что &lt;em&gt;весь&lt;/em&gt; дочерний элемент должен быть удален и заменен новым.</target>
        </trans-unit>
        <trans-unit id="e2d595e57fa825c7d94c939731588cee9344439f" translate="yes" xml:space="preserve">
          <source>This has exactly the same result, without requiring the priceRating computed observable.</source>
          <target state="translated">Это дает точно такой же результат,не требуя вычисления priceRating,который можно наблюдать.</target>
        </trans-unit>
        <trans-unit id="3077765de26211664ba2efe22cb2b9cd04fb4caa" translate="yes" xml:space="preserve">
          <source>This interactive example demonstrates that:</source>
          <target state="translated">Этот интерактивный пример демонстрирует это:</target>
        </trans-unit>
        <trans-unit id="5643babfcf6893a24373debdbe07dfee55a51dd1" translate="yes" xml:space="preserve">
          <source>This is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;ignore any self-closing slashes&lt;/a&gt; (except on a small number of special &amp;ldquo;foreign elements&amp;rdquo;, which are hardcoded into the parser). HTML is not the same as XML.</source>
          <target state="translated">Это ограничение спецификации HTML и выходит за рамки того, что может контролировать Knockout. Анализаторы HTML, следуя спецификации HTML, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;игнорируют любые самозакрывающиеся косые черты&lt;/a&gt; (за исключением небольшого количества специальных &amp;laquo;посторонних элементов&amp;raquo;, которые жестко запрограммированы в анализаторе). HTML - это не то же самое, что XML.</target>
        </trans-unit>
        <trans-unit id="f78bc1ff46d4250e923789d55c729bf459efb257" translate="yes" xml:space="preserve">
          <source>This is an array representing all of the parent view models:</source>
          <target state="translated">Это массив,представляющий все модели родительского вида:</target>
        </trans-unit>
        <trans-unit id="74000dd6220d8d962de61f08d4444c669e765e23" translate="yes" xml:space="preserve">
          <source>This is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.</source>
          <target state="translated">Так можно передавать свойства от родительской модели представления дочернему компоненту.Если сами свойства наблюдаемы,то родительская видовая модель сможет наблюдать и реагировать на любые новые значения,вставляемые в них дочерним компонентом.</target>
        </trans-unit>
        <trans-unit id="6a2bb49027f1ab6742f350a8ffba17b3b3c61fdd" translate="yes" xml:space="preserve">
          <source>This is mainly useful if you have multiple levels of nested foreach blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here&amp;rsquo;s a complete example, showing how season can be referenced while rendering a month:</source>
          <target state="translated">Это в основном полезно, если у вас есть несколько уровней вложенных блоков foreach, потому что это дает вам однозначный способ ссылаться на любой именованный элемент, объявленный на более высоком уровне иерархии. Вот полный пример, показывающий, как можно ссылаться на сезон при визуализации месяца:</target>
        </trans-unit>
        <trans-unit id="8cfd1c39aecebfca1259dc459499bea32121ecc1" translate="yes" xml:space="preserve">
          <source>This is mainly useful when you&amp;rsquo;re fetching the markup from somewhere programmatically (e.g., &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD - see below&lt;/a&gt;), or as a build system output that packages components for distribution, since it&amp;rsquo;s not very convenient to manually edit HTML as a JavaScript string literal.</source>
          <target state="translated">Это в основном полезно, когда вы извлекаете разметку откуда-то программно (например, &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD - см. Ниже&lt;/a&gt; ) или в качестве вывода системы сборки, которая упаковывает компоненты для распространения, поскольку вручную редактировать HTML как строковый литерал JavaScript не очень удобно.</target>
        </trans-unit>
        <trans-unit id="456a8a825127f0754a6b3c29d2b3b6a2b87ce4f4" translate="yes" xml:space="preserve">
          <source>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</source>
          <target state="translated">Это элемент DOM-объект (для виртуальных элементов это будет комментарий DOM-объект)текущей привязки.Это может быть полезно,если для привязки необходим доступ к атрибуту текущего элемента.Пример:</target>
        </trans-unit>
        <trans-unit id="a03a71e0074cf075a1a1081583cac59ac61756fe" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="translated">Это полная противоположность примеру &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; в том, что здесь нельзя редактировать имя и фамилию, но можно редактировать объединенное полное имя.</target>
        </trans-unit>
        <trans-unit id="e3a2757d58a0119bd192fdc042c0cb6c3f74c81a" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;https://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173aba90415cf038a5ca44929194616b39af11e1" translate="yes" xml:space="preserve">
          <source>This is the main view model object in the root context, i.e., the topmost parent context. It&amp;rsquo;s usually the object that was passed to ko.applyBindings. It is equivalent to $parents[$parents.length - 1].</source>
          <target state="translated">Это основной объект модели представления в корневом контексте, то есть самый верхний родительский контекст. Обычно это объект, переданный в ko.applyBindings. Эквивалентен $ parent [$ parent.length - 1].</target>
        </trans-unit>
        <trans-unit id="6240fa458446de4cb8e845cb681191b4719f6c7d" translate="yes" xml:space="preserve">
          <source>This is the mirror image of the enable binding. For more information, see &lt;a href=&quot;enable-binding&quot;&gt;documentation for the enable binding&lt;/a&gt;, because disable works in exactly the same way except that it negates whatever parameter you pass to it.</source>
          <target state="translated">Это зеркальное отображение разрешающей привязки. Для получения дополнительной информации см. &lt;a href=&quot;enable-binding&quot;&gt;Документацию по привязке enable&lt;/a&gt; , потому что disable работает точно так же, за исключением того, что отменяет любой параметр, который вы ему передаете.</target>
        </trans-unit>
        <trans-unit id="29889de6133ca2a7946ef92ef09c7a021e5d70d0" translate="yes" xml:space="preserve">
          <source>This is the raw view model value in the current context. Usually this will be the same as $data, but if the view model provided to Knockout is wrapped in an observable, $data will be the unwrapped view model, and $rawData will be the observable itself.</source>
          <target state="translated">Это необработанное значение модели представления в текущем контексте.Обычно это будет то же самое,что и $data,но если модель представления,предоставленная в Knockout,будет обернута в наблюдаемое,$data будет моделью необернутого представления,а $rawData будет самой наблюдаемой.</target>
        </trans-unit>
        <trans-unit id="aaaecc06d2965d5100af141ea778d358bd106f1b" translate="yes" xml:space="preserve">
          <source>This is the view model object in the current context. In the root context, $data and $root are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a with: person binding, $data will be set to person). $data is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:</source>
          <target state="translated">Это объект модели представления в текущем контексте.В корневом контексте $data и $root эквивалентны.Внутри вложенного контекста привязки этот параметр будет установлен в текущий элемент данных (например,внутри объекта с:person binding,$data будет установлен в person).$data полезен,когда вы хотите сослаться на саму вьюмодель,а не на свойство вьюмодели.Пример:</target>
        </trans-unit>
        <trans-unit id="1425847fb23b8c40942166dc9b9ab9eb5c03913c" translate="yes" xml:space="preserve">
          <source>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</source>
          <target state="translated">Это объект модели представления в родительском контексте,тот,который имитируется вне текущего контекста.В корневом контексте он неопределен.Пример:</target>
        </trans-unit>
        <trans-unit id="0a75f1ff617db05b67a63f53671406646513047f" translate="yes" xml:space="preserve">
          <source>This is the zero-based index of the current array entry being rendered by a foreach binding. Unlike the other binding context properties, $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">Это нулевой индекс текущей записи массива,выводимой при привязке к foreach.В отличие от других свойств контекста привязки,$index является наблюдаемым и обновляется всякий раз,когда меняется индекс элемента (например,если элементы добавляются в массив или удаляются из него).</target>
        </trans-unit>
        <trans-unit id="c4b96d23cc0b80a5d0c6fab427a1e7b9868d5d79" translate="yes" xml:space="preserve">
          <source>This is useful if you want to build components that represent &amp;ldquo;container&amp;rdquo; UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;a complete example for custom elements&lt;/a&gt;, which also works without custom elements using the syntax shown above.</source>
          <target state="translated">Это полезно, если вы хотите создать компоненты, представляющие &amp;laquo;контейнерные&amp;raquo; элементы пользовательского интерфейса, такие как сетки, списки, диалоговые окна или наборы вкладок, которые должны вводить и связывать произвольную разметку в общую структуру. См. &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;Полный пример настраиваемых элементов&lt;/a&gt; , который также работает без настраиваемых элементов с использованием синтаксиса, показанного выше.</target>
        </trans-unit>
        <trans-unit id="5ba543ff4dde01f5c7ccc4e0eadd6fedd604bb14" translate="yes" xml:space="preserve">
          <source>This is useful if you&amp;rsquo;re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.</source>
          <target state="translated">Это полезно, если вы создаете сложные формы, в которых редактируемые элементы отображаются динамически, и вы хотите контролировать, где пользователь должен начать вводить текст или реагировать на расположение курсора.</target>
        </trans-unit>
        <trans-unit id="0fa03a3f15a0e8fbad9cff23f1c0c40a68b4b25f" translate="yes" xml:space="preserve">
          <source>This is useful, for example, if a component&amp;rsquo;s template includes one or more foreach blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.</source>
          <target state="translated">Это полезно, например, если шаблон компонента включает в себя один или несколько блоков foreach, в которых вы хотите ссылаться на какое-либо свойство или функцию в модели представления компонента, а не на текущий элемент данных.</target>
        </trans-unit>
        <trans-unit id="599fc1798895695cf0148c049103421a0f316ffe" translate="yes" xml:space="preserve">
          <source>This is very simple and elegant (and it&amp;rsquo;s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to GridViewModel that changes both pageIndex and pageSize:</source>
          <target state="translated">Это очень просто и элегантно (и тривиально добавить еще больше наблюдаемых параметров запроса, которые также автоматически запускают обновление всякий раз, когда они меняются), но существует потенциальная проблема эффективности. Предположим, вы добавляете в GridViewModel следующую функцию, которая изменяет и pageIndex, и pageSize:</target>
        </trans-unit>
        <trans-unit id="9117d0ab32efbb0c3350f9f8bac13fc40074e4e2" translate="yes" xml:space="preserve">
          <source>This means that if giftWrap was defined with the initial state false (i.e., giftWrap: ko.observable(false)) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</source>
          <target state="translated">Это означает,что если giftWrap был определен с первоначальным состоянием false (т.е.giftWrap:ko.observable(false)),то связанная с ним DIV будет сначала скрыта,а затем будет скользить,когда пользователь позже поставит галочку.</target>
        </trans-unit>
        <trans-unit id="6a8c9ee94416efc36e3d0b09cb54b5b894dd20f1" translate="yes" xml:space="preserve">
          <source>This one is trickier. The expression itself, when evaluated, reads an observable. That observable&amp;rsquo;s value could change over time, so the expression result could change over time.</source>
          <target state="translated">Этот сложнее. Само выражение при вычислении читает наблюдаемое. Значение этой наблюдаемой может меняться со временем, поэтому результат выражения может меняться со временем.</target>
        </trans-unit>
        <trans-unit id="764cca70bf6bc3478b2f5d9c5e14adb25a24ed61" translate="yes" xml:space="preserve">
          <source>This pattern is beneficial for large applications, because it &lt;strong&gt;simplifies development&lt;/strong&gt; through clear organization and encapsulation, and helps to &lt;strong&gt;improve runtime performance&lt;/strong&gt; by incrementally loading your application code and templates as needed.</source>
          <target state="translated">Этот шаблон полезен для больших приложений, поскольку он &lt;strong&gt;упрощает разработку за&lt;/strong&gt; счет четкой организации и инкапсуляции, а также помогает &lt;strong&gt;повысить производительность времени выполнения за&lt;/strong&gt; счет постепенной загрузки кода приложения и шаблонов по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="c49ec8a2f8904ae806b7933742cc5c46416eb94c" translate="yes" xml:space="preserve">
          <source>This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs &lt;em&gt;every time a component is instantiated&lt;/em&gt; and performance would be unacceptable if it involved waiting for network requests.</source>
          <target state="translated">Эта фаза всегда завершается синхронно (конструкторы и фабричные функции не могут быть асинхронными), поскольку она происходит &lt;em&gt;каждый раз при создании экземпляра компонента,&lt;/em&gt; и производительность была бы неприемлемой, если бы она включала ожидание сетевых запросов.</target>
        </trans-unit>
        <trans-unit id="7cd17e2e83be7a02ac954b0879cc442249587320" translate="yes" xml:space="preserve">
          <source>This refers to the binding context object at the parent level. This is different from $parent, which refers to the &lt;em&gt;data&lt;/em&gt; (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer foreach item from an inner context (usage: $parentContext.$index). This is undefined in the root context.</source>
          <target state="translated">Это относится к объекту контекста привязки на родительском уровне. Это отличается от $ parent, который относится к &lt;em&gt;данным&lt;/em&gt; (а не к контексту привязки) на родительском уровне. Это полезно, например, если вам нужно получить доступ к значению индекса внешнего элемента foreach из внутреннего контекста (использование: $ parentContext. $ Index). Это не определено в корневом контексте.</target>
        </trans-unit>
        <trans-unit id="06c6933149d42721a432ae0308df0854c322572c" translate="yes" xml:space="preserve">
          <source>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</source>
          <target state="translated">Это относится к текущему контекстному объекту привязки.Это может быть полезно,если вы хотите получить доступ к свойствам контекста,когда они также могут существовать в модели представления,или если вы хотите передать контекстный объект вспомогательной функции в вашей модели представления.</target>
        </trans-unit>
        <trans-unit id="f387b998e8ac7a29ae76937857a5182d84c0d6a8" translate="yes" xml:space="preserve">
          <source>This returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.</source>
          <target state="translated">Это возвращает новое вычисленное значение,которое обеспечивает отфильтрованное представление массива,оставляя исходный массив без изменений.Поскольку отфильтрованный массив является наблюдаемым,он будет пересматриваться всякий раз,когда изменяется базовый массив.</target>
        </trans-unit>
        <trans-unit id="e779749b0336c95080fa9bf6da2b3b0f50a52bf9" translate="yes" xml:space="preserve">
          <source>This should be a very unusual scenario, so normally you will not need to work with $raw.</source>
          <target state="translated">Это должен быть очень необычный сценарий,поэтому,как правило,вам не придется работать с $raw.</target>
        </trans-unit>
        <trans-unit id="01da6ff51ae4d2c3c90a4030485a45aed896a7b0" translate="yes" xml:space="preserve">
          <source>This should be an array (or an observable array). KO sets the element&amp;rsquo;s selected options to match the contents of the array. Any previous selection state will be overwritten.</source>
          <target state="translated">Это должен быть массив (или наблюдаемый массив). KO устанавливает выбранные параметры элемента в соответствии с содержимым массива. Любое предыдущее состояние выбора будет перезаписано.</target>
        </trans-unit>
        <trans-unit id="88bbbc0277944375aa46b38dfa45e9ab615c5899" translate="yes" xml:space="preserve">
          <source>This simple logChange extender subscribes to the observable and uses the console to write any changes along with a configurable message.</source>
          <target state="translated">Этот простой расширитель logChange подписывается на наблюдаемое и использует консоль для записи любых изменений вместе с настраиваемым сообщением.</target>
        </trans-unit>
        <trans-unit id="c93d03a0497f4b6a9cf5527ffc5543496c0874f0" translate="yes" xml:space="preserve">
          <source>This technique is also possible when using components &lt;em&gt;without&lt;/em&gt; custom elements, i.e., &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;passing markup when using the component binding directly&lt;/a&gt;.</source>
          <target state="translated">Этот метод также возможен при использовании компонентов &lt;em&gt;без&lt;/em&gt; настраиваемых элементов, т. &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;Е. Передача разметки при непосредственном использовании привязки компонента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="256c845485dd4d340fc02fc1d45ab4dd11c131f5" translate="yes" xml:space="preserve">
          <source>This updated withProperties binding could now be used in a nested way, with each level of nesting able to access the parent level via $parentContext:</source>
          <target state="translated">Обновленная привязка с помощью функции Properties теперь может использоваться во вложенном виде,при этом каждый уровень вложенности может получить доступ к родительскому уровню через $parentContext:</target>
        </trans-unit>
        <trans-unit id="8d002804da1ead8e6117a2574e37ec65f769d881" translate="yes" xml:space="preserve">
          <source>This uses the &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify plugin&lt;/a&gt; to automatically inline the .html file, so you would need to build the script file using a command similar to:</source>
          <target state="translated">При этом используется &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;подключаемый модуль brfs Browserify&lt;/a&gt; для автоматического встраивания файла .html, поэтому вам нужно будет создать файл сценария с помощью команды, подобной следующей:</target>
        </trans-unit>
        <trans-unit id="e7012cd7733550a283d385731119658ec9bb44e4" translate="yes" xml:space="preserve">
          <source>This way, every time the mapping plugin checks an item in the children array, it will only look at the id property to determine if an object was completely replaced or merely needs updating.</source>
          <target state="translated">Таким образом,каждый раз,когда плагин mapping проверяет элемент в дочернем массиве,он будет только смотреть на свойство id,чтобы определить,был ли объект полностью заменен или просто нуждается в обновлении.</target>
        </trans-unit>
        <trans-unit id="a8568ff1255174753fee15506ea5b939e7eba400" translate="yes" xml:space="preserve">
          <source>This will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the &lt;a href=&quot;#implementation&quot;&gt;browser&amp;rsquo;s microtask&lt;/a&gt; support if possible. This ensures that the first task and subsequent tasks behave similarly.</source>
          <target state="translated">Это добавит предоставленную функцию обратного вызова в очередь микрозадач. Knockout включает в себя быструю очередь задач, которая выполняет задачи в порядке FIFO, пока очередь не станет пустой. Когда запланирована первая задача, Knockout будет планировать событие &lt;a href=&quot;#implementation&quot;&gt;сброса, используя&lt;/a&gt; поддержку микрозадач браузера, если это возможно. Это гарантирует, что первая задача и последующие задачи ведут себя одинаково.</target>
        </trans-unit>
        <trans-unit id="89fe8682d00eb2da96a5709d31b9029ffbcfc05d" translate="yes" xml:space="preserve">
          <source>This will alert Grahamfoo!.</source>
          <target state="translated">Это предупредит Грэмфу!</target>
        </trans-unit>
        <trans-unit id="1e9d83f540d0f759264a50c1deaee9fadbc1b907" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive, otherwise it will apply the profitWarning CSS class.</source>
          <target state="translated">При этом будет применен класс CSS profitPositive,если текущее значениеProfit положительное,в противном случае будет применен класс profitWarning CSS.</target>
        </trans-unit>
        <trans-unit id="6d682cf2301f953dbc0cbb0bf8b714c7ce4cac31" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive; otherwise it will apply the profitWarning CSS class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87913830792a93e929c5041e49a1ac864f3534e" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitWarning whenever the currentProfit value dips below zero, and remove that class whenever it goes above zero.</source>
          <target state="translated">Это будет применяться CSS класс profitWarning всякий раз,когда текущее значениеProfit опускается ниже нуля,и удалять этот класс всякий раз,когда он опускается выше нуля.</target>
        </trans-unit>
        <trans-unit id="18e90989c33e17d16d78799aa4ba01332cd092cc" translate="yes" xml:space="preserve">
          <source>This will be the &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; instance declared on the parent viewmodel as myObservable. It is not a wrapper &amp;mdash; it&amp;rsquo;s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.</source>
          <target state="translated">Это будет экземпляр &lt;a href=&quot;observables&quot;&gt;ko.observable,&lt;/a&gt; объявленный в родительской модели просмотра как myObservable. Это не оболочка - это фактически тот же экземпляр, на который ссылается родительский объект. Поэтому, если дочерняя модель просмотра записывает в этот наблюдаемый объект, родительская модель просмотра получит это изменение.</target>
        </trans-unit>
        <trans-unit id="2f67007f4b1a32d450aaea3739ae4efc22153a68" translate="yes" xml:space="preserve">
          <source>This will be the numeric value 2. It will not be an observable or computed value, since there are no observables involved.</source>
          <target state="translated">Это будет числовое значение 2.Это не будет наблюдаемым или вычисленным значением,так как никаких наблюдаемых величин не существует.</target>
        </trans-unit>
        <trans-unit id="1c5ede0dd1910b9dd5251dfa29559d2f0637ba62" translate="yes" xml:space="preserve">
          <source>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the _destroy property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an ko.observableArray. See the &amp;ldquo;Advanced Usage&amp;rdquo; section for more details on how to configure this.</source>
          <target state="translated">Это создаст неотмеченный объект, содержащий только свойства сопоставленного объекта, которые были частью вашего исходного JS-объекта. Другими словами, любые свойства или функции, которые вы вручную добавили в свою модель представления, игнорируются. По умолчанию единственным исключением из этого правила является свойство _destroy, которое также будет отображено обратно, поскольку это свойство может генерировать Knockout, когда вы уничтожаете элемент из ko.observableArray. См. Раздел &amp;laquo;Расширенное использование&amp;raquo; для получения дополнительных сведений о том, как это настроить.</target>
        </trans-unit>
        <trans-unit id="9c3e13ac9f2224e44e42edef86d37eab2fe74fad" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s href attribute to year-end.html and the element&amp;rsquo;s title attribute to Report including final year-end statistics.</source>
          <target state="translated">При этом для атрибута href элемента будет установлено значение year-end.html, а для атрибута title элемента - &amp;laquo;Отчет&amp;raquo;, включая итоговую статистику на конец года.</target>
        </trans-unit>
        <trans-unit id="b1010c547f79842589b0e311d7876305e18791c1" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s style.color property to red whenever the currentProfit value dips below zero, and to black whenever it goes above zero.</source>
          <target state="translated">Это установит свойство style.color элемента в красный цвет, когда значение currentProfit опускается ниже нуля, и в черный, когда оно становится выше нуля.</target>
        </trans-unit>
        <trans-unit id="3b1cd0e6a2217c74948bf4211011886cf75676fa" translate="yes" xml:space="preserve">
          <source>This works because {{each ...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c0ebf1e1a352368a835454316aec61a6b25f3d" translate="yes" xml:space="preserve">
          <source>This works because {{each...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="translated">Это работает, потому что {{each ...}} и $ {...} являются синтаксисами jQuery.tmpl. Более того, вложить шаблоны тривиально: поскольку вы можете использовать атрибуты привязки данных изнутри шаблона, вы можете просто поместить data-bind = &quot;template: ...&quot; внутри шаблона, чтобы отобразить вложенный.</target>
        </trans-unit>
        <trans-unit id="4fdac77a92e4befc847d03ccedc3c0f29ee5e341" translate="yes" xml:space="preserve">
          <source>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</source>
          <target state="translated">Это хорошо работает с обычными элементами DOM.Следующие элементы будут перетасованы в случайном порядке:</target>
        </trans-unit>
        <trans-unit id="6cea06b68ab89e21eb2eb393da04144cdf69163b" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'category', &lt;em&gt;not&lt;/em&gt; as: category), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">Совет: не забудьте передать значение &lt;em&gt;строкового литерала&lt;/em&gt; как (например, как: 'category', а &lt;em&gt;не&lt;/em&gt; как: category), потому что вы даете имя для новой переменной, а не читаете значение уже существующей переменной.</target>
        </trans-unit>
        <trans-unit id="d8500f75dd4919cdb81ed364100516eb992fda0f" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'season', &lt;em&gt;not&lt;/em&gt; as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">Совет: не забудьте передать значение &lt;em&gt;строкового литерала&lt;/em&gt; в as (например, as: 'season', а &lt;em&gt;не&lt;/em&gt; as: season), потому что вы даете имя новой переменной, а не читаете значение переменной, которая уже существует.</target>
        </trans-unit>
        <trans-unit id="4e7109024dd6bcf80fd3c4071c74f0ccac474646" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;read&lt;/strong&gt; the observable&amp;rsquo;s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.</source>
          <target state="translated">Чтобы &lt;strong&gt;прочитать&lt;/strong&gt; текущее значение наблюдаемого, просто вызовите наблюдаемый без параметров. В этом примере myViewModel.personName () вернет &amp;laquo;Боб&amp;raquo;, а myViewModel.personAge () вернет 123.</target>
        </trans-unit>
        <trans-unit id="1603a0143d3999d60952c967221acb25e519b499" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;write&lt;/strong&gt; a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.</source>
          <target state="translated">Чтобы &lt;strong&gt;записать&lt;/strong&gt; новое значение в наблюдаемый, вызовите наблюдаемый и передайте новое значение в качестве параметра. Например, вызов myViewModel.personName ('Mary') изменит значение имени на 'Mary'.</target>
        </trans-unit>
        <trans-unit id="8c1dd52f53359b8999172932067a959e30b50bb9" translate="yes" xml:space="preserve">
          <source>To activate Knockout, add the following line to a &amp;lt;script&amp;gt; block:</source>
          <target state="translated">Чтобы активировать Knockout, добавьте следующую строку в блок &amp;lt;script&amp;gt;:</target>
        </trans-unit>
        <trans-unit id="4bedfacc43fa04424dc2037d1ad45179e728cf82" translate="yes" xml:space="preserve">
          <source>To attach a custom function, add it to one of the following extensibility points:</source>
          <target state="translated">Чтобы прикрепить пользовательскую функцию,добавьте ее к одной из следующих точек расширения:</target>
        </trans-unit>
        <trans-unit id="266ba5487281979f5f750daeadee12340bd8ff01" translate="yes" xml:space="preserve">
          <source>To be notified in a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt;, you can register a callback function within the component&amp;rsquo;s createViewModel method. Be sure to dispose the subscription within your component&amp;rsquo;s dispose function as well, since a component may be disposed and re-created on the same element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7153140a8c0457153388555a5a5e74ad80e0326" translate="yes" xml:space="preserve">
          <source>To be notified in your view model, bind your callback function to the event through the node&amp;rsquo;s data-bind. Pass a function reference (either a function literal or the name of a function on your view model), and Knockout will invoke it when that event is notified. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc34fc8c1a8f61015e6ccf19b6048b726ab8b730" translate="yes" xml:space="preserve">
          <source>To check if a property is observable, computed, etc., use the following set of functions:</source>
          <target state="translated">Для проверки наблюдаемости,вычисления и т.д.свойств используйте следующий набор функций:</target>
        </trans-unit>
        <trans-unit id="a6ca1b4a2f54eff18a5d64c54c19bfbc24f36608" translate="yes" xml:space="preserve">
          <source>To create a view model via the mapping plugin, replace the creation of viewModel in the code above with the ko.mapping.fromJS function:</source>
          <target state="translated">Чтобы создать модель представления через плагин mapping,замените создание ViewModel в коде выше на функцию ko.mapping.fromJS:</target>
        </trans-unit>
        <trans-unit id="9bca32773ffd1de2e683926bbbc0399c4ce35c07" translate="yes" xml:space="preserve">
          <source>To create a view model with KO, just declare any JavaScript object. For example,</source>
          <target state="translated">Чтобы создать модель представления с помощью KO,просто объявите любой объект JavaScript.Например,</target>
        </trans-unit>
        <trans-unit id="4d72b444e4e76be69a061cb2a516752a354ce7c2" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b10cf91ed48dc2161202d3dbba9996462cd34" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler:</source>
          <target state="translated">Для этого к обработчику связывания следует прикрепить функцию препроцессинга:</target>
        </trans-unit>
        <trans-unit id="b6f315d7429f0172c8d46409834c17cc33ad391f" translate="yes" xml:space="preserve">
          <source>To do this, define a preprocessNode function on your binding provider:</source>
          <target state="translated">Для этого определите функцию preprocessNode на вашем провайдере привязки:</target>
        </trans-unit>
        <trans-unit id="474f546cba1324754eedaae0ff4ea7e4b00b8b61" translate="yes" xml:space="preserve">
          <source>To do this, simply return { controlsDescendantBindings: true } from your binding&amp;rsquo;s init function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2f9db2683d5e7dd55d32347c60ef3b9fd17aa7" translate="yes" xml:space="preserve">
          <source>To do this, simply return {controlsDescendantBindings:true} from your binding&amp;rsquo;s init function.</source>
          <target state="translated">Для этого просто верните {controlsDescendantBindings: true} из функции инициализации привязки.</target>
        </trans-unit>
        <trans-unit id="0d02d6d0b98e8e4132512edf37abb131f03195b9" translate="yes" xml:space="preserve">
          <source>To ensure that the child component can react to changes in the expression value, Knockout &lt;strong&gt;automatically upgrades this parameter to a computed property&lt;/strong&gt;. So, the child component will be able to read params.observableExpression() to get the current value, or use params.observableExpression.subscribe(...), etc.</source>
          <target state="translated">Чтобы дочерний компонент мог реагировать на изменения значения выражения, Knockout &lt;strong&gt;автоматически обновляет этот параметр до вычисляемого свойства&lt;/strong&gt; . Таким образом, дочерний компонент сможет читать params.observableExpression (), чтобы получить текущее значение, или использовать params.observableExpression.subscribe (...) и т. Д.</target>
        </trans-unit>
        <trans-unit id="b4a8d0a19e57da9771491cbbe8f1040202f3913f" translate="yes" xml:space="preserve">
          <source>To ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender:</source>
          <target state="translated">Чтобы гарантировать,что абоненты всегда будут уведомлены об обновлении,даже если значение равнозначно,вы будете использовать расширитель уведомлений:</target>
        </trans-unit>
        <trans-unit id="a230b2caaad8521494456ece11667c71eb8c9cab" translate="yes" xml:space="preserve">
          <source>To get started, here&amp;rsquo;s a custom binding that randomises the order of DOM nodes:</source>
          <target state="translated">Для начала вот настраиваемая привязка, которая рандомизирует порядок узлов DOM:</target>
        </trans-unit>
        <trans-unit id="7e12f7ef2adfbd28b0327ae040b9449ce8ae8c4a" translate="yes" xml:space="preserve">
          <source>To get started, you can register a component using ko.components.register (technically, registration is optional, but it&amp;rsquo;s the easiest way to get started). A component definition specifies a viewModel and template. For example:</source>
          <target state="translated">Для начала вы можете зарегистрировать компонент с помощью ko.components.register (технически регистрация не является обязательной, но это самый простой способ начать). В определении компонента указываются модель представления и шаблон. Например:</target>
        </trans-unit>
        <trans-unit id="34c9f670f8df2e29349796ad5b0233f8c05eff2a" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="translated">Чтобы справиться с этим, вы можете использовать &lt;em&gt;синтаксис потока управления без контейнера&lt;/em&gt; , который основан на тегах комментариев. Например,</target>
        </trans-unit>
        <trans-unit id="d18572193a45491f5f82b42ce11142e475501e50" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless syntax&lt;/em&gt;, which is based on comment tags.</source>
          <target state="translated">Чтобы справиться с этим, вы можете использовать &lt;em&gt;синтаксис без контейнера&lt;/em&gt; , основанный на тегах комментариев.</target>
        </trans-unit>
        <trans-unit id="344aafcd8749ab67bed4212faedd867ef9944e6c" translate="yes" xml:space="preserve">
          <source>To implement a naming convention, your custom component loader only needs to implement getConfig. For example:</source>
          <target state="translated">Для реализации соглашения об именовании,ваш пользовательский загрузчик компонентов должен только реализовать getConfig.Например:</target>
        </trans-unit>
        <trans-unit id="1e3b53d1cbf555a90afd50c492b3f2aa86042a55" translate="yes" xml:space="preserve">
          <source>To make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:</source>
          <target state="translated">Чтобы упростить сериализацию данных модели представления,включая наблюдаемые и т.п.,Knockout включает в себя две вспомогательные функции:</target>
        </trans-unit>
        <trans-unit id="a16e4b410b776f2eb11f1b98050f24b8ce7df16f" translate="yes" xml:space="preserve">
          <source>To register a binding, add it as a subproperty of ko.bindingHandlers:</source>
          <target state="translated">Чтобы зарегистрировать связывание,добавьте его в качестве под-свойства ko.bindingHandlers:</target>
        </trans-unit>
        <trans-unit id="9a050d6aedfdbef27779228a105257ebafded91d" translate="yes" xml:space="preserve">
          <source>To register a function to run when a node is removed, you can call ko.utils.domNodeDisposal.addDisposeCallback(node, callback). As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the destroy method of the widget:</source>
          <target state="translated">Для регистрации функции,которая будет выполняться при удалении узла,можно вызвать ko.utils.domNodeDisposal.addDisposeCallback(node,callback).В качестве примера,предположим,что вы создаёте пользовательскую привязку для инстанцирования виджета.Когда элемент с привязкой удален,можно вызвать метод уничтожения виджета:</target>
        </trans-unit>
        <trans-unit id="628e530a0cb918fd2a0dc463a561ba3eb6ded4c1" translate="yes" xml:space="preserve">
          <source>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</source>
          <target state="translated">Для регистрации любых обработчиков событий,чтобы,например,когда пользователь кликает или изменяет элемент DOM,можно было изменять состояние связанного наблюдаемого элемента</target>
        </trans-unit>
        <trans-unit id="e971fd083a8eb6c18b73f34e2fcf3c1be214c7ef" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="translated">Чтобы увидеть, как можно привязать observableArray к пользовательскому интерфейсу и позволить пользователю изменять его, см. &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;Пример простого списка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92ad28c02d4910b0d510a9bd45377e509f33c2cd" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;https://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095a567dfb57127d79567d4bc52abc97f60ac311" translate="yes" xml:space="preserve">
          <source>To see this take effect, here&amp;rsquo;s a sample usage:</source>
          <target state="translated">Чтобы увидеть, как это вступит в силу, вот пример использования:</target>
        </trans-unit>
        <trans-unit id="3ae1228ed42dd51e2a79a4933915655e8327da14" translate="yes" xml:space="preserve">
          <source>To set any initial state for the DOM element</source>
          <target state="translated">Для установки любого начального состояния для DOM-элемента</target>
        </trans-unit>
        <trans-unit id="9f816fffe2f0c1ef4a2672aecdb14944095d7a12" translate="yes" xml:space="preserve">
          <source>To solve this, you can specify which key the mapping plugin should use to determine if an object is new or old. You would set it up like this:</source>
          <target state="translated">Для решения этой проблемы можно указать,какой ключ должен использовать плагин mapping,чтобы определить,является ли объект новым или старым.Вы можете настроить его таким образом:</target>
        </trans-unit>
        <trans-unit id="d875d374a5b560ee2a9072eedb09b31f34d14b2b" translate="yes" xml:space="preserve">
          <source>To summarise: KO doesn&amp;rsquo;t compete with jQuery or similar low-level DOM APIs. KO provides a complementary, high-level way to link a data model to a UI. KO itself doesn&amp;rsquo;t depend on jQuery, but you can certainly use jQuery at the same time, and indeed that&amp;rsquo;s often useful if you want things like animated transitions.</source>
          <target state="translated">Подводя итог: KO не конкурирует с jQuery или аналогичными низкоуровневыми DOM API. KO предоставляет дополнительный высокоуровневый способ связать модель данных с пользовательским интерфейсом. Сам KO не зависит от jQuery, но вы, безусловно, можете одновременно использовать jQuery, и это действительно часто бывает полезно, если вам нужны такие вещи, как анимированные переходы.</target>
        </trans-unit>
        <trans-unit id="64c8953197898f78eeca558500a49ab49daef233" translate="yes" xml:space="preserve">
          <source>To supply a configuration, call callback(componentConfig), where componentConfig is any object that can be understood by the loadComponent function on your loader or any other loader. The default loader simply supplies whatever object was registered using ko.components.register.</source>
          <target state="translated">Чтобы предоставить конфигурацию,вызовите callback(componentConfig),где componentConfig-это любой объект,который может быть понятен функцией loadComponent на вашем загрузчике или любом другом загрузчике.Загрузчик по умолчанию просто предоставляет любой объект,зарегистрированный с помощью ko.components.register.</target>
        </trans-unit>
        <trans-unit id="19095264c8ed4472bafe7730a63b6cf4ef5c336b" translate="yes" xml:space="preserve">
          <source>To supply a createViewModel function, call callback(yourCreateViewModelFunction). The createViewModel function must accept parameters (params, componentInfo) and must synchronously return a new viewmodel instance each time it is called.</source>
          <target state="translated">Для предоставления функции createViewModel вызовите функцию calllback(yourCreateViewModelFunction).Функция createViewModel должна принимать параметры (параметры,componentInfo)и должна синхронно возвращать новый экземпляр Viewmodel каждый раз при вызове.</target>
        </trans-unit>
        <trans-unit id="1b5f93798c8c651e942c21326f558b5aa4d8d7c6" translate="yes" xml:space="preserve">
          <source>To supply a viewmodel/template pair, call callback(result), where result is an object with the following properties:</source>
          <target state="translated">Для предоставления пары viewmodel/template,вызовите callback(result),где результатом является объект со следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="4ead5da5921414482244d25f573f52e9a5b955e8" translate="yes" xml:space="preserve">
          <source>To supply an array of DOM nodes, call callback(domNodeArray).</source>
          <target state="translated">Для обеспечения массива DOM-узлов позвоните в callback(domNodeArray).</target>
        </trans-unit>
        <trans-unit id="1724664ad5c98bc91fe046f856ef3cda6f3d6e51" translate="yes" xml:space="preserve">
          <source>To supply parameters to the component, pass an object with the following properties:</source>
          <target state="translated">Для подачи параметров на компонент передайте объект со следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="478bbd64e518e9b998ff4a6cab53605b1ae49ad6" translate="yes" xml:space="preserve">
          <source>To write values to &lt;strong&gt;multiple observable properties&lt;/strong&gt; on a model object, you can use &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' &lt;em&gt;and&lt;/em&gt; the age value to 50.</source>
          <target state="translated">Чтобы записать значения в &lt;strong&gt;несколько наблюдаемых свойств&lt;/strong&gt; объекта модели, вы можете использовать &lt;em&gt;синтаксис цепочки&lt;/em&gt; . Например, myViewModel.personName ('Mary'). PersonAge (50) изменит значение имени на &amp;laquo;Мэри&amp;raquo;, &lt;em&gt;а&lt;/em&gt; значение возраста - на 50.</target>
        </trans-unit>
        <trans-unit id="aafe7d418233e4542cf2fcd1a4855d69c306f6ec" translate="yes" xml:space="preserve">
          <source>Tracking array changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5865922af306bd8ae540e6e29d90f3c0fc25a0" translate="yes" xml:space="preserve">
          <source>Triggering UI-level validation using a library such as &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt;, using code similar to the following snippet: if ($(formElement).valid()) { /* do something */ }.</source>
          <target state="translated">Запуск проверки на уровне пользовательского интерфейса с помощью библиотеки, такой как &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt; , с использованием кода, подобного следующему фрагменту: if ($ (formElement) .valid ()) {/ * сделать что-нибудь * /}.</target>
        </trans-unit>
        <trans-unit id="0969eb5b711519c18e0b6f0a6871c28056b8ba40" translate="yes" xml:space="preserve">
          <source>Try it out:</source>
          <target state="translated">Попробуй:</target>
        </trans-unit>
        <trans-unit id="4d46d56fedff8d9d8e85c637f94cca6486220b3d" translate="yes" xml:space="preserve">
          <source>Try it:</source>
          <target state="translated">Попробуй:</target>
        </trans-unit>
        <trans-unit id="eaf9d5be1a5edee29dc70627d1391050d53eaeb0" translate="yes" xml:space="preserve">
          <source>Two points to note about this example:</source>
          <target state="translated">Обратите внимание на этот пример:</target>
        </trans-unit>
        <trans-unit id="9142247f90c4a68927ee8f397af8554e56a791cf" translate="yes" xml:space="preserve">
          <source>Two things have happened here: name was changed from Scot to Scott and children[0].name was changed from Alicw to the typo-free Alice. You can update viewModel based on this new data:</source>
          <target state="translated">Две вещи случились здесь:имя было изменено от Шотландии к Шотландии и дети[0].имя было изменено от Алисы к Алисе без опечаток.Вы можете обновить viewModel на основе этих новых данных:</target>
        </trans-unit>
        <trans-unit id="4ec6595c029c891202be0000bd3de833e1a37085" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render.</source>
          <target state="translated">Обычно это полезно,когда значения в вашей модели представления на самом деле являются строками HTML разметки,которые вы хотите отрисовать.</target>
        </trans-unit>
        <trans-unit id="a45dab66b5b0fb7b4755a5854f26fe1fcf88c6ca" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render. If you know your view model value is plain text, use the more efficient &lt;a href=&quot;text-binding&quot;&gt;text binding&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44eb7cfce780337ba99afe9286699b6ff8a45d7" translate="yes" xml:space="preserve">
          <source>Typically this is useful with elements like &amp;lt;span&amp;gt; or &amp;lt;em&amp;gt; that traditionally display text, but technically you can use it with any element.</source>
          <target state="translated">Обычно это полезно с такими элементами, как &amp;lt;span&amp;gt; или &amp;lt;em&amp;gt;, которые обычно отображают текст, но технически вы можете использовать его с любым элементом.</target>
        </trans-unit>
        <trans-unit id="fe23c3213b817a535e503650eb3aed5e4ffa688e" translate="yes" xml:space="preserve">
          <source>Typically you&amp;rsquo;d only want to use optionsValue as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you&amp;rsquo;re repeatedly getting a list of &amp;ldquo;car&amp;rdquo; objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set optionsValue to &quot;carId&quot; or whatever unique identifier each &amp;ldquo;car&amp;rdquo; object has, otherwise KO won&amp;rsquo;t necessarily know which of the previous &amp;ldquo;car&amp;rdquo; objects corresponds to which of the new ones.</source>
          <target state="translated">Обычно вы хотите использовать optionsValue только как способ гарантировать, что KO может правильно сохранить выбор при обновлении набора доступных параметров. Например, если вы постоянно получаете список объектов &amp;laquo;автомобиль&amp;raquo; через вызовы Ajax и хотите убедиться, что выбранный автомобиль сохранен, вам может потребоваться установить для optionsValue значение &amp;laquo;carId&amp;raquo; или любой другой уникальный идентификатор, который имеет каждый объект &amp;laquo;автомобиль&amp;raquo;. , иначе KO не обязательно будет знать, какой из предыдущих объектов &amp;laquo;автомобиль&amp;raquo; соответствует какому из новых.</target>
        </trans-unit>
        <trans-unit id="48d4528c74c77bb144c5416d7e9ba854d62bff55" translate="yes" xml:space="preserve">
          <source>Uniquely identifying objects using &amp;ldquo;keys&amp;rdquo;</source>
          <target state="translated">Однозначная идентификация объектов с помощью &amp;laquo;ключей&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="035deff1cdf7cc31acdb9702441a6e450f6d339e" translate="yes" xml:space="preserve">
          <source>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn&amp;rsquo;t provide developers with the means to import such modules of code in a clean, organized manner. It&amp;rsquo;s one of the concerns with specifications that haven&amp;rsquo;t required great thought until more recent years where the need for more organized JavaScript applications became apparent.</source>
          <target state="translated">Однако, в отличие от некоторых более традиционных языков программирования, текущая итерация JavaScript (ECMA-262) не предоставляет разработчикам средств для импорта таких модулей кода в чистом и организованном виде. Это одна из проблем со спецификациями, которая не требовала особого внимания до тех пор, пока в последние годы не стала очевидной потребность в более организованных приложениях JavaScript.</target>
        </trans-unit>
        <trans-unit id="28ef317e90976436c53e6fd9743c3a6007ec616a" translate="yes" xml:space="preserve">
          <source>Unmapping</source>
          <target state="translated">Unmapping</target>
        </trans-unit>
        <trans-unit id="00b5fe370c80c9fd15a6c4aaf4ed7a457fabe3fe" translate="yes" xml:space="preserve">
          <source>Updating View Model Data using JSON</source>
          <target state="translated">Обновление данных модели представления с помощью JSON</target>
        </trans-unit>
        <trans-unit id="882404f2cec0fb17f2287042b3e7158d2e826690" translate="yes" xml:space="preserve">
          <source>Use clearInterval(handle) to stop them, otherwise your viewmodel might be held in memory.</source>
          <target state="translated">Используйте clearInterval(handle),чтобы остановить их,в противном случае ваша viewmodel может храниться в памяти.</target>
        </trans-unit>
        <trans-unit id="a36cf2b849979ba4930b9f37292d09e3fcaa008a" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;as&amp;rdquo; without creating a child context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18b7da089633a2ca0b4636635f86dba16e5da93" translate="yes" xml:space="preserve">
          <source>Using a computed observable</source>
          <target state="translated">Используя вычисляемый наблюдаемый</target>
        </trans-unit>
        <trans-unit id="acf1fb7bc54bfd69e0f891d41bdd8354fa0c478f" translate="yes" xml:space="preserve">
          <source>Using a computed observable to run a callback based on multiple observables.</source>
          <target state="translated">Использование вычисляемого наблюдаемого для выполнения обратного вызова на основе нескольких наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="translated">Использование пользовательских элементов</target>
        </trans-unit>
        <trans-unit id="7461986ee1f28f48b4bff59743d52212ae099805" translate="yes" xml:space="preserve">
          <source>Using deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the &lt;a href=&quot;microtasks&quot;&gt;Knockout microtask queue&lt;/a&gt;. This may sound very similar to &lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limiting&lt;/a&gt;, which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here&amp;rsquo;s how notification scheduling differs between the standard, deferred, and rate-limited modes:</source>
          <target state="translated">Использование отложенных обновлений гарантирует, что вычисляемые наблюдаемые и привязки обновляются только после того, как их зависимости станут стабильными. Даже если наблюдаемое может проходить через несколько промежуточных значений, только последнее значение используется для обновления его зависимостей. Чтобы облегчить это, все уведомления становятся асинхронными и планируются с использованием &lt;a href=&quot;microtasks&quot;&gt;очереди микрозадач Knockout&lt;/a&gt; . Это может звучать очень похоже на &lt;a href=&quot;ratelimit-observable&quot;&gt;ограничение скорости&lt;/a&gt; , которое также помогает предотвратить дополнительные уведомления, но отложенные обновления могут обеспечить эти преимущества для всего приложения без добавления задержек. Вот чем отличается планирование уведомлений между стандартным, отложенным и ограниченным по скорости режимами:</target>
        </trans-unit>
        <trans-unit id="d22dae89d982b72d6b6d2ac79e0ca3abf367c0e3" translate="yes" xml:space="preserve">
          <source>Using deferred updates for specific observables</source>
          <target state="translated">Использование отложенных обновлений для конкретных наблюдаемых объектов</target>
        </trans-unit>
        <trans-unit id="82500147d6fe068e5f3eac3c33aa845f26a5b095" translate="yes" xml:space="preserve">
          <source>Using extenders to augment observables</source>
          <target state="translated">Использование удлинителей для дополнения наблюдаемых объектов</target>
        </trans-unit>
        <trans-unit id="50d3aa10da781d57d5fb5f9b37232d95022250cb" translate="yes" xml:space="preserve">
          <source>Using the component binding</source>
          <target state="translated">Использование привязки компонентов</target>
        </trans-unit>
        <trans-unit id="4fdbe03b68d1b5f0b1e0b8df84af814851a7626f" translate="yes" xml:space="preserve">
          <source>Using the computed context</source>
          <target state="translated">Использование вычисленного контекста</target>
        </trans-unit>
        <trans-unit id="36cfba518908dc7ac80815a581dbac4dbfe3d45f" translate="yes" xml:space="preserve">
          <source>Using unobtrusive event handlers</source>
          <target state="translated">Использование ненавязчивых обработчиков событий</target>
        </trans-unit>
        <trans-unit id="2a98028d793eefede53201a64728cbb7a99bc8be" translate="yes" xml:space="preserve">
          <source>Using valueAllowUnset with &amp;lt;select&amp;gt; elements</source>
          <target state="translated">Использование valueAllowUnset с элементами &amp;lt;select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a2fccbf4307cd999a23c6d6d0c8c15cd45251e9e" translate="yes" xml:space="preserve">
          <source>Viewmodels can be specified in any of the following forms:</source>
          <target state="translated">Вьюмодели могут быть указаны в любой из следующих форм:</target>
        </trans-unit>
        <trans-unit id="67410bb1c50d4c83c27173e0489e96f063272dc6" translate="yes" xml:space="preserve">
          <source>Virtual Element APIs</source>
          <target state="translated">Виртуальные API элементов</target>
        </trans-unit>
        <trans-unit id="e406729e158e24dd87b8e698dcec51dd531fa16b" translate="yes" xml:space="preserve">
          <source>Virtual elements</source>
          <target state="translated">Виртуальные элементы</target>
        </trans-unit>
        <trans-unit id="350a4fbd76ca00bce2ade90d8477e5ed8a1a52e4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve borrowed the term from &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt; because this feature is generally only applicable for computed observables whose evaluator is a &lt;em&gt;pure function&lt;/em&gt; as follows:</source>
          <target state="translated">Мы позаимствовали этот термин из &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;чистых функций,&lt;/a&gt; потому что эта функция обычно применима только для вычисляемых наблюдаемых, вычислитель которых является &lt;em&gt;чистой функцией,&lt;/em&gt; как показано ниже:</target>
        </trans-unit>
        <trans-unit id="35a6b726c72e0d5b8bef238a8458f1acc64e5a41" translate="yes" xml:space="preserve">
          <source>What if you&amp;rsquo;ve got an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; for firstName, and another for lastName, and you want to display the full name? That&amp;rsquo;s where &lt;em&gt;computed observables&lt;/em&gt; come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</source>
          <target state="translated">Что, если у вас есть &lt;a href=&quot;observables&quot;&gt;наблюдаемый&lt;/a&gt; объект для firstName и другой для lastName, и вы хотите отобразить полное имя? Вот тут-то и &lt;em&gt;пригодятся вычисленные наблюдаемые&lt;/em&gt; - это функции, которые зависят от одного или нескольких других наблюдаемых и будут автоматически обновляться при изменении любой из этих зависимостей.</target>
        </trans-unit>
        <trans-unit id="d0955f26cb60a2b7c19f0ff4510ffa1f1f8a847e" translate="yes" xml:space="preserve">
          <source>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</source>
          <target state="translated">На практике,как правило,наиболее полезно создавать AMD модули,которые имеют встроенные классы Viewmodel и явно принимают AMD зависимости от внешних файлов шаблонов.</target>
        </trans-unit>
        <trans-unit id="d0746929aa2438a6c079c324161ceff7bcbb2cda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;not&lt;/em&gt; to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">Когда &lt;em&gt;не&lt;/em&gt; следует использовать &lt;em&gt;чисто&lt;/em&gt; вычисляемую наблюдаемую</target>
        </trans-unit>
        <trans-unit id="93b6c9e2cbc279de2e5c3e0969a9438b76e2aa2e" translate="yes" xml:space="preserve">
          <source>When Knockout renders a foreach binding with the parameter includeDestroyed: false set, it will hide any objects marked with _destroy equal to true. So, you can have some kind of &amp;ldquo;delete&amp;rdquo; button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e688d2a76e0cc347828e115ec7ca0f7f8f898a8d" translate="yes" xml:space="preserve">
          <source>When a component binding injects a component,</source>
          <target state="translated">Когда связующее звено впрыскивает компонент,</target>
        </trans-unit>
        <trans-unit id="49718b2901f95c68a1922d6b2983c5beec56f4c3" translate="yes" xml:space="preserve">
          <source>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that a computed observable&amp;rsquo;s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</source>
          <target state="translated">Когда вычисляемый наблюдаемый возвращает примитивное значение (число, строку, логическое значение или ноль), зависимости наблюдаемого обычно уведомляются, только если значение действительно изменилось. Однако можно использовать встроенный &lt;a href=&quot;extenders&quot;&gt;расширитель&lt;/a&gt; уведомлений, чтобы гарантировать, что подписчики вычисляемого наблюдаемого всегда уведомляются об обновлении, даже если значение такое же. Вы применили бы расширитель следующим образом:</target>
        </trans-unit>
        <trans-unit id="e830112947080dad24b739108f8a4da674f8a04f" translate="yes" xml:space="preserve">
          <source>When applied to a computed observable, the deferred extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just &lt;em&gt;one&lt;/em&gt; re-evaluation of the computed observable. For example:</source>
          <target state="translated">При применении к вычисляемой наблюдаемой, отложенный расширитель также избегает избыточной оценки вычисленной функции. Использование отложенных обновлений гарантирует, что любая последовательность изменений зависимостей в текущей задаче вызовет только &lt;em&gt;одну&lt;/em&gt; повторную оценку вычисляемой наблюдаемой. Например:</target>
        </trans-unit>
        <trans-unit id="240548473b5b8fba3f48d06580b1747a636e1733" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,</source>
          <target state="translated">При вызове обработчика Knockout предоставит текущее значение модели в качестве первого параметра. Это особенно полезно, если вы визуализируете некоторый пользовательский интерфейс для каждого элемента в коллекции и вам нужно знать, к какому элементу относится событие. Например,</target>
        </trans-unit>
        <trans-unit id="69391a30effde287dee34eb73d855395d87ce5a9" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item&amp;rsquo;s UI was clicked. For example,</source>
          <target state="translated">При вызове обработчика Knockout предоставит текущее значение модели в качестве первого параметра. Это особенно полезно, если вы визуализируете пользовательский интерфейс для каждого элемента в коллекции, и вам нужно знать, пользовательский интерфейс какого элемента был нажат. Например,</target>
        </trans-unit>
        <trans-unit id="fbadbc1c18a2eb0a89cdf0f66ab67f3c68470882" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained &lt;a href=&quot;#how-things-are-mapped&quot;&gt;above&lt;/a&gt;. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &amp;ldquo;copy&amp;rdquo; array:</source>
          <target state="translated">При преобразовании модели представления обратно в объект JS плагин сопоставления по умолчанию создает наблюдаемые объекты на основе правил, описанных &lt;a href=&quot;#how-things-are-mapped&quot;&gt;выше&lt;/a&gt; . Если вы хотите заставить плагин сопоставления просто копировать свойство вместо того, чтобы делать его наблюдаемым, добавьте его имя в массив &amp;laquo;copy&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="34bc7212872348445dd0f0e3cd8734701a523ffe" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated _destroy property even if it was not part of your original object. However, you can choose to customize this array:</source>
          <target state="translated">При преобразовании вашей модели представления обратно в JS объект,по умолчанию плагин отображения будет включать только те свойства,которые были частью вашей оригинальной модели представления,за исключением того,что он также будет включать сгенерированное Knockout свойство _destroy,даже если оно не было частью вашего оригинального объекта.Однако,вы можете выбрать настройку этого массива:</target>
        </trans-unit>
        <trans-unit id="34c7ddb2d85f70c9b78ff4ca6c7fb87b8a5a8a76" translate="yes" xml:space="preserve">
          <source>When items are re-ordered, as shown in the last example above, you will also get &lt;em&gt;moved&lt;/em&gt; information. You can choose to ignore the &lt;em&gt;moved&lt;/em&gt; information and just interpret it as the original Alpha being deleted and a different Alpha being added to the array&amp;rsquo;s end. Or you can recognize that the &lt;em&gt;moved&lt;/em&gt; information tells you that you can think of the &lt;em&gt;added&lt;/em&gt; and &lt;em&gt;deleted&lt;/em&gt; values being the same item that just changes position (by matching up the indexes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17cbd8252177d3eecb0c97f654d8e466d16f693" translate="yes" xml:space="preserve">
          <source>When nesting foreach templates, it&amp;rsquo;s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to $parent or other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables in your bindings.</source>
          <target state="translated">При вложении шаблонов foreach часто бывает полезно ссылаться на элементы на более высоких уровнях иерархии. Один из способов сделать это - обратиться к $ parent или другим переменным &lt;a href=&quot;binding-context&quot;&gt;контекста привязки&lt;/a&gt; в ваших привязках.</target>
        </trans-unit>
        <trans-unit id="0447c91d2a396145a22645b117ae8a779d972c73" translate="yes" xml:space="preserve">
          <source>When presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to true it will select all items, and when set to false it will deselect them.</source>
          <target state="translated">Представляя пользователю список выбираемых элементов,часто бывает полезно включить метод выбора или отмены выбора всех элементов.Это может быть представлено достаточно интуитивно,с помощью булевого значения,которое показывает,все ли элементы выбраны.При установке значения в true он будет выбирать все элементы,а при установке значения в false-снимать выделение.</target>
        </trans-unit>
        <trans-unit id="fa06a171ee457055a05faa668013d2f40356d7d1" translate="yes" xml:space="preserve">
          <source>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&amp;rsquo;s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:</source>
          <target state="translated">При удалении элемента Knockout запускает логику для очистки любых данных, связанных с элементом. В рамках этой логики Knockout вызывает метод cleanData jQuery, если jQuery загружен на вашу страницу. В сложных сценариях вы можете запретить или настроить способ удаления этих данных в вашем приложении. Knockout предоставляет функцию ko.utils.domNodeDisposal.cleanExternalData (node), которую можно переопределить для поддержки настраиваемой логики. Например, чтобы предотвратить вызов cleanData, можно использовать пустую функцию для замены стандартной реализации cleanExternalData:</target>
        </trans-unit>
        <trans-unit id="0d673da0804e0a4a38175c4dafe9330c0b8fbb10" translate="yes" xml:space="preserve">
          <source>When the computed observable is only used in your UI</source>
          <target state="translated">Когда вычисляемый наблюдаемый используется только в вашем пользовательском интерфейсе.</target>
        </trans-unit>
        <trans-unit id="db6fb44d7f7d1f10f432541accee58dc638af22b" translate="yes" xml:space="preserve">
          <source>When the default loader&amp;rsquo;s loadComponent runs, it simultaneously:</source>
          <target state="translated">Когда запускается loadComponent загрузчика по умолчанию, он одновременно:</target>
        </trans-unit>
        <trans-unit id="1aa25dca397cfdaf6f58c0b5c990ffd248e032ba" translate="yes" xml:space="preserve">
          <source>When the deferUpdates option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;work around these issues&lt;/a&gt;).</source>
          <target state="translated">Когда опция deferUpdates включена, все наблюдаемые, вычисляемые наблюдаемые и привязки будут настроены на использование отложенных обновлений и уведомлений. Включение этой функции в начале создания приложения на основе Knockout означает, что вам не нужно беспокоиться об обходе проблемы промежуточного значения, и это может способствовать более чистому, чисто реактивному дизайну. Но вам следует проявлять осторожность при включении отложенных обновлений для существующего приложения, потому что это нарушит код, который зависит от синхронных обновлений или уведомления о промежуточных значениях (хотя вы можете &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;обойти эти проблемы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14350d5d7b6cb62c7f2e96ed3335bddec0681969" translate="yes" xml:space="preserve">
          <source>When the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers&amp;rsquo;s own microtask capabilities. In modern browsers, it will use a &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM mutation observer&lt;/a&gt;, and in older versions of Internet Explorer, it will use a &amp;lt;script&amp;gt; onreadystatechange event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using setTimeout.</source>
          <target state="translated">Когда запланирована первая задача (изначально и после завершения предыдущего события сброса), Knockout планирует событие сброса для обработки очереди микрозадач. Если возможно, он попытается использовать собственные возможности микрозадач браузеров. В современных браузерах он будет использовать &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;наблюдатель мутаций DOM&lt;/a&gt; , а в старых версиях Internet Explorer он будет использовать событие &amp;lt;script&amp;gt; onreadystatechange. Эти методы позволяют ему начать обработку очереди перед любой перекомпоновкой или перерисовкой. В других браузерах он вернется к использованию setTimeout.</target>
        </trans-unit>
        <trans-unit id="b4c02d5563dd9c10af0804c769590634547b5a72" translate="yes" xml:space="preserve">
          <source>When the options binding changes the set of options in your &amp;lt;select&amp;gt; element, KO will leave the user&amp;rsquo;s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you&amp;rsquo;ve removed one or more of those options).</source>
          <target state="translated">Когда привязка параметров изменяет набор параметров в вашем элементе &amp;lt;select&amp;gt;, KO оставит выбор пользователя без изменений, где это возможно. Таким образом, для раскрывающегося списка с одним выбором по-прежнему будет выбрано ранее выбранное значение параметра, а для списка с несколькими вариантами выбора все ранее выбранные значения параметров по-прежнему будут выбраны (если, конечно, вы не удалили один или несколько из этих вариантов).</target>
        </trans-unit>
        <trans-unit id="d3b21cd263e89b964e6c3850344e09506b5dcfe3" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="translated">Когда параметр разрешается в &lt;strong&gt;значение, подобное false&lt;/strong&gt; (например, логическое значение false, или числовое значение 0, или null, или undefined), привязка устанавливает для yourElement.style.display значение none, в результате чего он скрывается. Это имеет приоритет над любым стилем отображения, который вы определили с помощью CSS.</target>
        </trans-unit>
        <trans-unit id="486a4906c8e802b0c506137554408d59db04e832" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the visible binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424933b4a587b12800d5037b620d089e1310bebf" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="translated">Когда параметр разрешается в &lt;strong&gt;истинное значение&lt;/strong&gt; (например, логическое значение true или ненулевой объект или массив), привязка удаляет значение yourElement.style.display, в результате чего оно становится видимым.</target>
        </trans-unit>
        <trans-unit id="fc7bf8fa30e9cc8653a4d8b4f189e36ca8bb5a36" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the visible binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5648040a47d72bcccb395b1f9a5a715c4f582e4" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, KO will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="translated">Когда пользователь изменит,какая радио кнопка выбрана,KO установит свойство модели равным значению выбранной радио кнопки.В предыдущем примере,нажатие на радиокнопку со значением=&quot;вишенка&quot; установит viewModel.spamFlavor равным &quot;вишенке&quot;.</target>
        </trans-unit>
        <trans-unit id="03e179ef7606802f89ca3b95e7468e850b02c502" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, Knockout will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af87db2ce5d35d81a05adcc1a10b76bb7ceb65d5" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will add or remove the value from the array accordingly.</source>
          <target state="translated">Когда пользователь ставит или снимает флажок,KO будет добавлять или удалять значение из массива соответственно.</target>
        </trans-unit>
        <trans-unit id="7ed7961c716e1412d259d37491a6eb0f3e216a42" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will set your model property to true or false accordingly.</source>
          <target state="translated">Когда пользователь ставит или снимает флажок,KO установит ваше свойство модели соответственно true или false.</target>
        </trans-unit>
        <trans-unit id="a975d33ef8135e1f85ea96cb074a21a12a6b1e5a" translate="yes" xml:space="preserve">
          <source>When the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.</source>
          <target state="translated">Когда пользователь проверяет соответствующие формы управления,это обновляет значение на вашей модели просмотра.Аналогичным образом,при обновлении значения в вашей модели представления,проверяется или снимается флажок с элемента управления формой на экране.</target>
        </trans-unit>
        <trans-unit id="c0803213f1274b2a55d9b91b874c4a9d488ed496" translate="yes" xml:space="preserve">
          <source>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</source>
          <target state="translated">Когда пользователь редактирует значение в соответствующей форме управления,он обновляет значение на вашей модели просмотра.Аналогичным образом,когда вы обновляете значение в модели представления,оно обновляет значение элемента управления формы на экране.</target>
        </trans-unit>
        <trans-unit id="f0189caf134a5f34340d62bfc5c510d298e95ca3" translate="yes" xml:space="preserve">
          <source>When the user manually focuses or unfocuses the element, your value will be set to true or false accordingly.</source>
          <target state="translated">Когда пользователь вручную фокусирует или расфокусирует элемент,ваше значение будет установлено в true или false соответственно.</target>
        </trans-unit>
        <trans-unit id="98cfccafa8cf961040d59d473116f98c49c5beb7" translate="yes" xml:space="preserve">
          <source>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it&amp;rsquo;s an &lt;em&gt;observable&lt;/em&gt; array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It&amp;rsquo;s a 2-way binding.</source>
          <target state="translated">Когда пользователь выбирает или отменяет выбор элемента в списке множественного выбора, это добавляет или удаляет соответствующее значение в массив в вашей модели представления. Точно так же, если предположить, что это &lt;em&gt;наблюдаемый&lt;/em&gt; массив в вашей модели представления, тогда всякий раз, когда вы добавляете или удаляете (например, с помощью push или splice) элементы в этот массив, соответствующие элементы в пользовательском интерфейсе становятся выбранными или отмененными. Это двусторонняя привязка.</target>
        </trans-unit>
        <trans-unit id="0074731e38b2821484d16af4acc4755105ba6332" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.</source>
          <target state="translated">Когда значение любого наблюдаемого является примитивным (число,строка,булевое или нулевое),зависимые наблюдаемого по умолчанию уведомляются только в том случае,если оно установлено в значение,фактически отличное от предыдущего.Таким образом,примитивные отложенные наблюдаемые уведомляются только тогда,когда их значение на самом деле отличается в конце текущей задачи.Другими словами,если примитивное значение отложенной наблюдаемой изменяется на новое значение,а затем изменяется обратно на исходное,то уведомления не будет.</target>
        </trans-unit>
        <trans-unit id="73a77795bd66e1cb3b16bdd68e57f5a159e05b77" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.</source>
          <target state="translated">Когда значение любого наблюдаемого является примитивным (число,строка,булевое или нулевое),зависимые наблюдаемого по умолчанию уведомляются только в том случае,если оно установлено в значение,фактически отличное от предыдущего.Таким образом,обсерватории с ограниченной скоростью с примитивным значением уведомляются только тогда,когда их значение на самом деле отличается в конце периода таймаута.Другими словами,если наблюдаемый параметр с ограничением по скорости с примитивным значением изменен на новое значение,а затем изменен обратно на исходное значение до окончания периода таймаута,то уведомления не будут выдаваться.</target>
        </trans-unit>
        <trans-unit id="09e87bae7a7069eae757161892afd1feaa3f86ad" translate="yes" xml:space="preserve">
          <source>When to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">Когда использовать &lt;em&gt;чисто&lt;/em&gt; вычисляемую наблюдаемую</target>
        </trans-unit>
        <trans-unit id="0d9cb52535c85c16c1cd6054161d9b5a42c19b24" translate="yes" xml:space="preserve">
          <source>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</source>
          <target state="translated">При использовании KO,ваше представление-это просто HTML документ с декларативной привязкой,чтобы связать его с моделью представления.Кроме того,вы можете использовать шаблоны,которые генерируют HTML,используя данные из вашей модели представления.</target>
        </trans-unit>
        <trans-unit id="233388c234469b332e4372d743016356bcc6ddb1" translate="yes" xml:space="preserve">
          <source>When using rateLimit:</source>
          <target state="translated">При использовании ограничения скорости:</target>
        </trans-unit>
        <trans-unit id="cdd38baa0a09da7b54c34c1c8c1440db8b27182f" translate="yes" xml:space="preserve">
          <source>When we say an application is modular, we generally mean it&amp;rsquo;s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</source>
          <target state="translated">Когда мы говорим, что приложение является модульным, мы обычно имеем в виду, что оно состоит из набора сильно разделенных, отдельных частей функциональности, хранящихся в модулях. Как вы, вероятно, знаете, слабая связь упрощает обслуживание приложений за счет удаления зависимостей, где это возможно. Когда это реализовано эффективно, довольно легко увидеть, как изменения в одной части системы могут повлиять на другую.</target>
        </trans-unit>
        <trans-unit id="6e729fad8dd8395be4b5dee56db32c21c2e12be4" translate="yes" xml:space="preserve">
          <source>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that an observable&amp;rsquo;s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</source>
          <target state="translated">При записи в наблюдаемый объект, содержащий примитивное значение (число, строку, логическое значение или ноль), зависимости наблюдаемого обычно уведомляются только в том случае, если значение действительно изменилось. Тем не менее, можно использовать встроенный &lt;a href=&quot;extenders&quot;&gt;расширитель&lt;/a&gt; уведомлений, чтобы гарантировать, что подписчики наблюдаемого всегда уведомляются о записи, даже если значение такое же. Вы применили бы расширитель к наблюдаемому так:</target>
        </trans-unit>
        <trans-unit id="72a073d3684319f9171f7c76ed59be1b723f8be1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;add&lt;/strong&gt; array entries, foreach will render new copies of your template and insert them into the existing DOM</source>
          <target state="translated">Когда вы &lt;strong&gt;добавляете&lt;/strong&gt; записи массива, foreach будет отображать новые копии вашего шаблона и вставлять их в существующую DOM.</target>
        </trans-unit>
        <trans-unit id="fac1b26f280d61f56ca4bfb78786061572d31924" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;delete&lt;/strong&gt; array entries, foreach will simply remove the corresponding DOM elements</source>
          <target state="translated">Когда вы &lt;strong&gt;удаляете&lt;/strong&gt; записи массива, foreach просто удаляет соответствующие элементы DOM.</target>
        </trans-unit>
        <trans-unit id="74f4836dcc40687d501d0a60aca7bfa37c93bc31" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;reorder&lt;/strong&gt; array entries (retaining the same object instances), foreach will typically just move the corresponding DOM elements into their new position</source>
          <target state="translated">Когда вы &lt;strong&gt;меняете порядок&lt;/strong&gt; записей массива (сохраняя те же экземпляры объектов), foreach обычно просто перемещает соответствующие элементы DOM в их новую позицию.</target>
        </trans-unit>
        <trans-unit id="5e24e098b9af5a56adbd90dc77567f135eceb3a7" translate="yes" xml:space="preserve">
          <source>When you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That&amp;rsquo;s how changes to the view model automatically propagate to the view.</source>
          <target state="translated">Когда вы меняете значение имени на &amp;laquo;Мэри&amp;raquo;, вызывая myViewModel.personName (&amp;laquo;Мэри&amp;raquo;), текстовая привязка автоматически обновляет текстовое содержимое связанного элемента DOM. Вот как изменения в модели представления автоматически распространяются на представление.</target>
        </trans-unit>
        <trans-unit id="7b233d0df811d63859dad5c6f37d404b45b3fb25" translate="yes" xml:space="preserve">
          <source>When you load a viewmodel or template via require declarations, e.g.,</source>
          <target state="translated">Когда вы загружаете вид-модель или шаблон с помощью обязательных деклараций,например</target>
        </trans-unit>
        <trans-unit id="cd8c8cbbd6da1bb5e72e94c4fe56cd77a45a9d91" translate="yes" xml:space="preserve">
          <source>When you modify the contents of your model array (by adding, moving, or deleting its entries), the foreach binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</source>
          <target state="translated">Когда вы изменяете содержимое массива модели (добавляя,перемещая или удаляя его записи),привязка foreach использует эффективный алгоритм дифференциации,чтобы выяснить,что изменилось,и затем может обновить DOM для соответствия.Это означает,что он может обрабатывать произвольные комбинации симулятивных изменений.</target>
        </trans-unit>
        <trans-unit id="c3c82ab350bb2f560fd3b83e7250551b12fe5380" translate="yes" xml:space="preserve">
          <source>When you use the submit binding on a form, Knockout will prevent the browser&amp;rsquo;s default submit action for that form. In other words, the browser will call your handler function but will &lt;em&gt;not&lt;/em&gt; submit the form to the server. This is a useful default because when you use the submit binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the form as an interface to your view model, not as a regular HTML form. If you &lt;em&gt;do&lt;/em&gt; want to let the form submit like a normal HTML form, just return true from your submit handler.</source>
          <target state="translated">Когда вы используете привязку отправки в форме, Knockout предотвратит действие отправки браузера по умолчанию для этой формы. Другими словами, браузер вызовет вашу функцию-обработчик, но &lt;em&gt;не&lt;/em&gt; отправит форму на сервер. Это полезный вариант по умолчанию, потому что, когда вы используете привязку отправки, это обычно связано с тем, что вы используете форму как интерфейс для своей модели представления, а не как обычную HTML-форму. Если вы &lt;em&gt;действительно&lt;/em&gt; хотите, чтобы форма отправлялась как обычная HTML-форма, просто верните true из обработчика отправки.</target>
        </trans-unit>
        <trans-unit id="5099e034c651dd974110c8f683aaf6e9c35ee49c" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;any&lt;/em&gt; change subscribers, it is awake and &lt;strong&gt;&lt;em&gt;listening&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;listening&lt;/em&gt; state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in &lt;a href=&quot;computed-dependency-tracking&quot;&gt;how dependency tracking works&lt;/a&gt;.</source>
          <target state="translated">Всякий раз, когда у него есть &lt;em&gt;какие-либо&lt;/em&gt; подписчики изменений, он бодрствует и &lt;strong&gt;&lt;em&gt;слушает&lt;/em&gt;&lt;/strong&gt; . При входе в состояние &lt;em&gt;прослушивания&lt;/em&gt; он сразу же подписывается на любые зависимости. В этом состоянии он работает так же, как обычный вычисляемый наблюдаемый, как описано в &lt;a href=&quot;computed-dependency-tracking&quot;&gt;том, как работает отслеживание зависимостей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="027a73abac754e236b9d5e7c8cff74895b7e243f" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;no&lt;/em&gt; change subscribers, it is &lt;strong&gt;&lt;em&gt;sleeping&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;sleeping&lt;/em&gt; state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable&amp;rsquo;s value is read while it is &lt;em&gt;sleeping&lt;/em&gt;, it is automatically re-evaluated if any of its dependencies have changed.</source>
          <target state="translated">Когда у него &lt;em&gt;нет&lt;/em&gt; подписчиков на изменение, он &lt;strong&gt;&lt;em&gt;спит&lt;/em&gt;&lt;/strong&gt; . При переходе в состояние &lt;em&gt;сна&lt;/em&gt; он удаляет все подписки на свои зависимости. В этом состоянии он не будет подписываться на какие-либо наблюдаемые объекты, к которым осуществляется доступ в функции оценщика (хотя и отслеживает их). Если значение вычисляемого наблюдаемого считывается во время &lt;em&gt;сна&lt;/em&gt; , оно автоматически переоценивается, если какая-либо из его зависимостей изменилась.</target>
        </trans-unit>
        <trans-unit id="c6f248d3a9bf144743685335ebbb7395f73f3d22" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the change event), but you can also trigger updates based on other events by using the valueUpdate parameter described below.</source>
          <target state="translated">Всякий раз,когда пользователь редактирует значение в соответствующей форме управления,KO будет обновлять свойство на вашей модели просмотра.KO всегда будет пытаться обновить вашу модель представления,когда значение было изменено и пользователь переносит фокус на другой DOM-узел (т.е.на событие изменения),но вы также можете инициировать обновления,основанные на других событиях,используя параметр valueUpdate,описанный ниже.</target>
        </trans-unit>
        <trans-unit id="e5c65dd94ea67e2fad51961211d1569eac9051c0" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.</source>
          <target state="translated">Всякий раз,когда пользователь редактирует значение в соответствующей форме управления,KO будет обновлять свойство на вашей модели просмотра.KO всегда будет пытаться обновить вашу модель представления,когда значение было изменено пользователем или любыми событиями DOM.</target>
        </trans-unit>
        <trans-unit id="b90ce04fb0166e97a8840e6753fa79876c4f03da" translate="yes" xml:space="preserve">
          <source>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</source>
          <target state="translated">Всякий раз,когда вы объявляете вычисленное наблюдаемое,KO немедленно вызывает свою функцию вычислителя,чтобы получить его начальное значение.</target>
        </trans-unit>
        <trans-unit id="1709d61d9bf5080cbac0848f20d050481e016f8d" translate="yes" xml:space="preserve">
          <source>Whenever you inject a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;, Knockout fetches that component&amp;rsquo;s template and viewmodel using one or more &lt;em&gt;component loaders&lt;/em&gt;. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.</source>
          <target state="translated">Каждый раз, когда вы вводите &lt;a href=&quot;component-overview&quot;&gt;компонент&lt;/a&gt; с помощью &lt;a href=&quot;component-binding&quot;&gt;привязки компонента&lt;/a&gt; или &lt;a href=&quot;component-custom-elements&quot;&gt;настраиваемого элемента&lt;/a&gt; , Knockout извлекает шаблон и модель этого компонента с помощью одного или нескольких &lt;em&gt;загрузчиков компонентов&lt;/em&gt; . Задача загрузчика компонентов - асинхронно предоставить пару шаблон / модель представления для любого заданного имени компонента.</target>
        </trans-unit>
        <trans-unit id="7c9368d85e06a808f77b28f4f80f37db962b0bef" translate="yes" xml:space="preserve">
          <source>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</source>
          <target state="translated">Независимо от того,является ли параметр наблюдаемым массивом или нет,KO будет определять,когда пользователь выбирает или снимает выделение с элемента в списке с несколькими вариантами выбора,и будет обновлять массив для соответствия.Таким образом,вы можете прочитать,какой из параметров выбран.</target>
        </trans-unit>
        <trans-unit id="ff7601f5aa5d98b7725bc5ff59a4afe66d02b8ee" translate="yes" xml:space="preserve">
          <source>While result2 will be:</source>
          <target state="translated">В то время как результат2 будет:</target>
        </trans-unit>
        <trans-unit id="deedac358e26a9b41a5c69e270deca1435272118" translate="yes" xml:space="preserve">
          <source>While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</source>
          <target state="translated">Во время работы функции вычислителя KO устанавливает подписку на любые наблюдаемые объекты (включая другие вычисляемые наблюдаемые объекты),которые вычислитель считывает.Обратный вызов по подписке приводит к повторному запуску вычислителя,перенося весь процесс на шаг 1 (удаление всех старых подписок,которые больше не применимы).</target>
        </trans-unit>
        <trans-unit id="96bfb27bf17fe0044cc0631c47cb88836e206732" translate="yes" xml:space="preserve">
          <source>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</source>
          <target state="translated">В то время как родные решения этих проблем будут приходить в ES Harmony,хорошая новость заключается в том,что написание модульного JavaScript никогда не было проще,и вы можете начать делать это уже сегодня.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5e0dfd97e23e633bf46dddf5920fffb9c6f7b27f" translate="yes" xml:space="preserve">
          <source>Why &amp;ldquo;pure&amp;rdquo;?</source>
          <target state="translated">Почему &amp;laquo;чистый&amp;raquo;?</target>
        </trans-unit>
        <trans-unit id="3713912b140d1bc73909fbeb997ac04de7b22784" translate="yes" xml:space="preserve">
          <source>Why not just put a click handler on the submit button?</source>
          <target state="translated">Почему бы просто не поставить обработчик клика на кнопку отправки?</target>
        </trans-unit>
        <trans-unit id="d9388a16fe8139626304808559f7f5bbed3b2319" translate="yes" xml:space="preserve">
          <source>With binding preprocessing, developers can define custom syntaxes by providing callbacks that rewrite DOM nodes and binding strings during the binding process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c21e0bb780f4445b10d04fb402764ba77e9803b" translate="yes" xml:space="preserve">
          <source>Without the completeOn option, myPostProcessingLogic will be called even if resultData is not set intitially. With the option set as above, myPostProcessingLogic will only be called once resultData is set to a true-like value, and the contents of that node are rendered and bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9c00dce5a6b8f081befac104650345017434f1" translate="yes" xml:space="preserve">
          <source>Working with JSON strings</source>
          <target state="translated">Работа с JSON-строками</target>
        </trans-unit>
        <trans-unit id="3d63791dc040b8cd0707dc196c19e179ce90bb55" translate="yes" xml:space="preserve">
          <source>Writable computed observables</source>
          <target state="translated">Письменные вычисляемые наблюдаемые</target>
        </trans-unit>
        <trans-unit id="e5c7527fc9cce64616a1be5b3da7d5aeedc2fcd8" translate="yes" xml:space="preserve">
          <source>Writable computed observables are a powerful feature with a wide range of possible uses.</source>
          <target state="translated">Перезаписываемые вычисляемые наблюдаемые объекты являются мощной функцией с широким спектром возможного использования.</target>
        </trans-unit>
        <trans-unit id="91aa11ff1c1ba1f14720abfd6158e9094fb52d2a" translate="yes" xml:space="preserve">
          <source>You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your loadComponent function understands them.</source>
          <target state="translated">Вы не ограничиваетесь поставкой объектов конфигурации в любом стандартном формате.Вы можете поставлять произвольные объекты до тех пор,пока Ваша функция loadComponent их понимает.</target>
        </trans-unit>
        <trans-unit id="ee01c6f1c55a18105ff17707a47b82bb6d92c0a0" translate="yes" xml:space="preserve">
          <source>You can also customize how an object is updated by specifying an update callback. It will receive the object it is trying to update and an options object which is identical to the one used by the create callback. You should return the updated value.</source>
          <target state="translated">Вы также можете настроить способ обновления объекта,указав обратный вызов обновления.Он получит объект,который пытается обновить,и объект опций,идентичный тому,который используется при создании обратного вызова.Вы должны вернуть обновленное значение.</target>
        </trans-unit>
        <trans-unit id="3d880f5ee3e205f53c33334d9f482d9e5a03043e" translate="yes" xml:space="preserve">
          <source>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:</source>
          <target state="translated">При желании можно также прекратить подписку:сначала захватить возвращаемое значение в качестве переменной,а затем вызвать ее функцию распоряжения,например:</target>
        </trans-unit>
        <trans-unit id="43f66180a0db996f97c6c83a8137770d9b5159f5" translate="yes" xml:space="preserve">
          <source>You can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.</source>
          <target state="translated">В качестве значения параметра можно также использовать функцию JavaScript или произвольное выражение JavaScript.Если вы это сделаете,KO запустит вашу функцию/оценит ваше выражение и воспользуется результатом,чтобы определить,нужно ли скрывать элемент.</target>
        </trans-unit>
        <trans-unit id="e50756d8b024dc4f5ab0d1482650d8b221903759" translate="yes" xml:space="preserve">
          <source>You can also use the value binding with a &amp;lt;select&amp;gt; element that does not use the options binding. In this case, you can choose to specify your &amp;lt;option&amp;gt; elements in markup or build them using the foreach or template bindings. You can even nest options within &amp;lt;optgroup&amp;gt; elements and Knockout will set the selected value appropriately.</source>
          <target state="translated">Вы также можете использовать привязку значения с элементом &amp;lt;select&amp;gt;, который не использует привязку параметров. В этом случае вы можете указать элементы &amp;lt;option&amp;gt; в разметке или создать их с помощью привязок foreach или шаблонов. Вы даже можете вкладывать параметры в элементы &amp;lt;optgroup&amp;gt;, и Knockout установит выбранное значение соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="443d155ae980ce22546521692e114b8091b7dca0" translate="yes" xml:space="preserve">
          <source>You can bind either event using ko.bindingEvent.subscribe, but importantly for components, which are asynchronous by default, the descendantsComplete event will wait for all child components to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bd87c7ad551c644aec3e46f44aa15771ecde5d" translate="yes" xml:space="preserve">
          <source>You can combine multiple JS objects in one viewmodel by applying multiple ko.mapping.fromJS calls, e.g.:</source>
          <target state="translated">Вы можете комбинировать несколько JS-объектов в одной Viewmodel,применяя несколько ko.mapping.fromJS вызовов,например:</target>
        </trans-unit>
        <trans-unit id="052f12c0432421aa4b5f276ed7c52cb3ffd99104" translate="yes" xml:space="preserve">
          <source>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery&amp;rsquo;s $ function&lt;/a&gt;.</source>
          <target state="translated">Вы можете поместить блок скрипта внизу вашего HTML-документа или вы можете поместить его вверху и обернуть содержимое в обработчик, готовый к работе с DOM, такой как &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;функция $ jQuery&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dba98508f19715d131036a3aa6e81ae5ae8188c" translate="yes" xml:space="preserve">
          <source>You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:</source>
          <target state="translated">Вы даже можете установить несколько CSS классов,основанных на одном и том же условии,обернув имена в кавычки типа:</target>
        </trans-unit>
        <trans-unit id="1ec2e8dcbd91bae1eafeddc57bddc053e1571e0f" translate="yes" xml:space="preserve">
          <source>You can find a good list of reserved words on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;Mozilla&amp;rsquo;s MDN page here&lt;/a&gt;.</source>
          <target state="translated">Вы можете найти хороший список зарезервированных слов на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;странице Mozilla MDN здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="904b621173f2d4b30a15643fddcc0af2f1534b33" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cfbf0de916a9a332d3fb80ff672ea022cb01b5" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding handler (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding handler&lt;/a&gt;).</source>
          <target state="translated">Вы можете подключиться к логике Knockout для интерпретации атрибутов привязки данных, предоставив &lt;em&gt;препроцессор привязки&lt;/em&gt; для определенного обработчика привязки (например, щелчка, видимого или любого &lt;a href=&quot;custom-bindings&quot;&gt;настраиваемого обработчика привязки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="87fac0243102cb0636d3c50436c06c35c6bc14b1" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for traversing the DOM by providing a &lt;em&gt;node preprocessor&lt;/em&gt;. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;).</source>
          <target state="translated">Вы можете подключиться к логике Knockout для обхода DOM, предоставив &lt;em&gt;препроцессор узла&lt;/em&gt; . Это функция, которую Knockout вызывает один раз для каждого узла DOM, по которому он проходит, как при первом связывании пользовательского интерфейса, так и позже, когда вводятся новые поддеревья DOM (например, через &lt;a href=&quot;foreach-binding&quot;&gt;привязку foreach&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="90e55ee316113a7d87000ded1fefd296bd68ce62" translate="yes" xml:space="preserve">
          <source>You can manually dispose a computed observable by calling its dispose function, which clears all subscriptions to its dependencies. It is also automatically disposed if its evaluator function doesn&amp;rsquo;t access any observables. Although you can continue to access the most recent value of a disposed computed observable, its evaluator function will not be run again. Additionally, a disposed &lt;em&gt;pure&lt;/em&gt; computed observables is neither awake nor asleep, and does not notify state-change events. To determine if a computed observable is disposed, call myComputed.isActive().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c6da9d3b1f66034b47e8dd672b13081d17170" translate="yes" xml:space="preserve">
          <source>You can map this to a view model without any problems:</source>
          <target state="translated">Вы можете сопоставить это с моделью просмотра без каких-либо проблем:</target>
        </trans-unit>
        <trans-unit id="689af8b06e2b8d5ff8ae217915b9eefe6ba45a38" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing click: someObject.someFunction.</source>
          <target state="translated">Вы можете ссылаться на любую функцию JavaScript - она ​​не обязательно должна быть функцией в вашей модели представления. Вы можете ссылаться на функцию любого объекта, написав click: someObject.someFunction.</target>
        </trans-unit>
        <trans-unit id="ef0d5d305918c213b70064faeb270cf5be19cc1a" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing event { mouseover: someObject.someFunction }.</source>
          <target state="translated">Вы можете ссылаться на любую функцию JavaScript - она ​​не обязательно должна быть функцией в вашей модели представления. Вы можете ссылаться на функцию любого объекта, написав event {mouseover: someObject.someFunction}.</target>
        </trans-unit>
        <trans-unit id="d7731e4275a6724a076a102c99873fd04d12377b" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing submit: someObject.someFunction.</source>
          <target state="translated">Вы можете ссылаться на любую функцию JavaScript - она ​​не обязательно должна быть функцией в вашей модели представления. Вы можете ссылаться на функцию любого объекта, написав submit: someObject.someFunction.</target>
        </trans-unit>
        <trans-unit id="a3bf8a9a01529e6b883f85d2f5580c56462d82cd" translate="yes" xml:space="preserve">
          <source>You can register a component as follows:</source>
          <target state="translated">Вы можете зарегистрировать компонент следующим образом:</target>
        </trans-unit>
        <trans-unit id="dc66fcbdb568796cafb3b258bf02626926a8c07f" translate="yes" xml:space="preserve">
          <source>You can set multiple CSS classes at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">Вы можете установить несколько CSS классов одновременно.Например,если ваша модель представления имеет свойство isSevere,</target>
        </trans-unit>
        <trans-unit id="ee756fc2ba7ca22b5831bf756c710f284d654159" translate="yes" xml:space="preserve">
          <source>You can set multiple style values at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">Вы можете установить несколько значений стилей одновременно.Например,если ваша модель представления имеет свойство isSevere,</target>
        </trans-unit>
        <trans-unit id="3dba377f14bffba8a5efad9ec37fc825bce450e7" translate="yes" xml:space="preserve">
          <source>You can then create a very simple &lt;em&gt;view&lt;/em&gt; of this view model using a declarative binding. For example, the following markup displays the personName value:</source>
          <target state="translated">Затем вы можете создать очень простое &lt;em&gt;представление&lt;/em&gt; этой модели представления, используя декларативную привязку. Например, следующая разметка отображает значение personName:</target>
        </trans-unit>
        <trans-unit id="9f862efa038e8d26e7af75e8f1448e315ace30bd" translate="yes" xml:space="preserve">
          <source>You can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.fullName('Joe Smith').age(50).</source>
          <target state="translated">Вы можете использовать записываемый вычисляемый наблюдаемый объект точно так же, как обычный наблюдаемый, с вашей собственной пользовательской логикой, перехватывающей все операции чтения и записи. Как и наблюдаемые объекты, вы можете записывать значения в несколько наблюдаемых или вычисляемых наблюдаемых свойств объекта модели, используя &lt;em&gt;синтаксис цепочки&lt;/em&gt; . Например, myViewModel.fullName ('Joe Smith'). Age (50).</target>
        </trans-unit>
        <trans-unit id="cc3db9cdadd161e89137b6c1f8b5ea73932af31f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;pure&lt;/em&gt; feature for any computed observable that follows the &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;pure function&lt;/em&gt; guidelines&lt;/a&gt;. You&amp;rsquo;ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using &lt;em&gt;pure&lt;/em&gt; computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.</source>
          <target state="translated">Вы можете использовать &lt;em&gt;чистую&lt;/em&gt; функцию для любой вычисляемой наблюдаемой, которая следует &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;правилам &lt;/a&gt;&lt;em&gt;чистой функции&lt;/em&gt; . Однако наибольшую выгоду вы увидите, когда он будет применен к проектам приложений, которые включают модели постоянных представлений, которые используются и совместно используются временными представлениями и моделями представлений. Использование &lt;em&gt;чистых&lt;/em&gt; вычисленных наблюдаемых в модели постоянного представления обеспечивает повышение производительности вычислений. Использование их в моделях временных представлений обеспечивает преимущества управления памятью.</target>
        </trans-unit>
        <trans-unit id="445598a09e09ab27b378c79e9f86d7333d1962c6" translate="yes" xml:space="preserve">
          <source>You can use the init callback as a place to register an event handler that will cause changes to the associated observable. For example,</source>
          <target state="translated">Вы можете использовать обратный вызов init как место для регистрации обработчика событий,который будет вызывать изменения в связанном наблюдаемом.Например,</target>
        </trans-unit>
        <trans-unit id="c9980038705a45b71f8dc2def98206cccd1f4d42" translate="yes" xml:space="preserve">
          <source>You can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.</source>
          <target state="translated">Вы можете использовать эту технику,если,например,хотите контролировать,какое подмножество зарегистрированных компонентов может быть использовано в качестве пользовательских элементов.</target>
        </trans-unit>
        <trans-unit id="661a6f45bdafd50b10c85ee0a3c036fc7df926c5" translate="yes" xml:space="preserve">
          <source>You could bind this view model to some HTML elements as follows:</source>
          <target state="translated">Вы можете связать эту модель представления с некоторыми элементами HTML следующим образом:</target>
        </trans-unit>
        <trans-unit id="c1d471328860434648aa8fa03313f486aae8251e" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to change the view at all - the same data-bind syntax will keep working. The difference is that it&amp;rsquo;s now capable of detecting changes, and when it does, it will update the view automatically.</source>
          <target state="translated">Вам вообще не нужно менять представление - тот же синтаксис привязки данных будет работать. Разница в том, что теперь он способен обнаруживать изменения, и когда это происходит, он автоматически обновляет представление.</target>
        </trans-unit>
        <trans-unit id="17a973a03dcc80b13d7dbe90df99ac6b1793924e" translate="yes" xml:space="preserve">
          <source>You might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party &amp;ldquo;loader&amp;rdquo; library to fetch component viewmodels or templates from external locations.</source>
          <target state="translated">Вы можете реализовать пользовательский загрузчик компонентов, если хотите использовать соглашения об именах, а не явную регистрацию для загрузки компонентов. Или, если вы хотите использовать стороннюю библиотеку &amp;laquo;загрузчика&amp;raquo; для получения моделей представления компонентов или шаблонов из внешних источников.</target>
        </trans-unit>
        <trans-unit id="fee233d9fef0eab27974da7495e7c970d76709ab" translate="yes" xml:space="preserve">
          <source>You must use dispose to release any resources that aren&amp;rsquo;t inherently garbage-collectable. For example:</source>
          <target state="translated">Вы должны использовать dispose для освобождения любых ресурсов, которые по своей сути не подлежат сборке мусора. Например:</target>
        </trans-unit>
        <trans-unit id="2d43cca43db2b101cb12f2e4c94e2a371e5bd69f" translate="yes" xml:space="preserve">
          <source>You must write &amp;lt;my-custom-element&amp;gt;&amp;lt;/my-custom-element&amp;gt;, and &lt;strong&gt;not&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.</source>
          <target state="translated">Вы должны написать &amp;lt;my-custom-element&amp;gt; &amp;lt;/my-custom-element&amp;gt;, а &lt;strong&gt;не&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. В противном случае ваш настраиваемый элемент не будет закрыт, и последующие элементы будут анализироваться как дочерние элементы.</target>
        </trans-unit>
        <trans-unit id="d9251d769ce5e182a494a279bea207eec0172927" translate="yes" xml:space="preserve">
          <source>You only need two files for the component - a viewmodel (path/my-component.js) and a template (path/my-component.html) - which is a very natural arrangement during development.</source>
          <target state="translated">Для компонента нужно всего два файла-viewmodel (path/my-component.js)и шаблон (path/my-component.html),что очень естественно в процессе разработки.</target>
        </trans-unit>
        <trans-unit id="a29664b58fa5bfc4804c4fec44e01829983a68be" translate="yes" xml:space="preserve">
          <source>You should not use the &lt;em&gt;pure&lt;/em&gt; feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:</source>
          <target state="translated">Вы не должны использовать &lt;em&gt;чистую&lt;/em&gt; функцию для вычисляемой наблюдаемой, которая предназначена для выполнения действия при изменении ее зависимостей. Примеры включают:</target>
        </trans-unit>
        <trans-unit id="7273cd1f360253be372b4b6ac72a1c8b27685344" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names are your CSS classes and their values evaluate to true or false according to whether the class should currently be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350964aafaead15e0f900fd5cb4610606ba71f2c" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.</source>
          <target state="translated">Вы должны передать объект JavaScript,в котором имена свойств соответствуют именам атрибутов,а значения соответствуют значениям атрибутов,которые вы хотите применить.</target>
        </trans-unit>
        <trans-unit id="b0ebd1ec7d9cfc0718391b658886d523d78de173" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.</source>
          <target state="translated">Вы должны передать объект JavaScript,в котором имена свойств соответствуют именам событий,а значения соответствуют функциям,которые вы хотите привязать к событию.</target>
        </trans-unit>
        <trans-unit id="6e10e77115395251f2707e5c49667eb3dc1b1e89" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.</source>
          <target state="translated">Вы должны передать объект JavaScript,в котором имена свойств соответствуют именам стилей,а значения соответствуют значениям стилей,которые вы хотите применить.</target>
        </trans-unit>
        <trans-unit id="f2431741ff9d62f8125af6f5b235418b67c42a31" translate="yes" xml:space="preserve">
          <source>You should supply an array (or observable array). For each item, KO will add an &amp;lt;option&amp;gt; to the associated &amp;lt;select&amp;gt; node. Any previous options will be removed.</source>
          <target state="translated">Вы должны предоставить массив (или наблюдаемый массив). Для каждого элемента KO добавит &amp;lt;option&amp;gt; к соответствующему узлу &amp;lt;select&amp;gt;. Все предыдущие параметры будут удалены.</target>
        </trans-unit>
        <trans-unit id="b1f309b2b779d610009271c39ee65e9c095e6b65" translate="yes" xml:space="preserve">
          <source>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</source>
          <target state="translated">Вы хотите отобразить текущее серверное время и количество пользователей на вашей веб-странице.Вы можете представить эту информацию,используя следующую модель представления:</target>
        </trans-unit>
        <trans-unit id="ab0462be804f0902ece6db1caf383668c565a43e" translate="yes" xml:space="preserve">
          <source>You won&amp;rsquo;t need to use this often. It&amp;rsquo;s only useful in a few rare cases, e.g.:</source>
          <target state="translated">Вам не придется часто использовать это. Это полезно только в нескольких редких случаях, например:</target>
        </trans-unit>
        <trans-unit id="136d45b744ad9e632284ca13aec225df9d9d766f" translate="yes" xml:space="preserve">
          <source>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</source>
          <target state="translated">Вы должны будете сделать это для каждой переменной,которую вы хотите отобразить на вашей странице.Если Ваши структуры данных становятся более сложными (например,они содержат детей или массивы),это становится очень громоздким для ручной обработки.Что плагин mapping позволяет вам сделать,так это создать отображение от обычного JavaScript объекта (или JSON структуры)к наблюдаемой модели представления.</target>
        </trans-unit>
        <trans-unit id="f9c1cd6deaf34424cd7538a83dcd4251f9037aed" translate="yes" xml:space="preserve">
          <source>You would use this extender by calling the extend function of an observable and passing an object that contains a logChange property.</source>
          <target state="translated">Вы будете использовать этот расширитель,вызывая функцию расширения наблюдаемого и передавая объект,содержащий свойство logChange.</target>
        </trans-unit>
        <trans-unit id="6c472940368ffb2c6f5ef7385d23da07c065fb9d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to referencing variables - you can reference arbitrary expressions to control an element&amp;rsquo;s enabledness. For example,</source>
          <target state="translated">Вы не ограничены ссылками на переменные - вы можете ссылаться на произвольные выражения для управления активностью элемента. Например,</target>
        </trans-unit>
        <trans-unit id="fa251b979a6c1805f4ab439f863653eaa0839791" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using &amp;lt;template&amp;gt; elements, but these are convenient (on browsers that support them) since they don&amp;rsquo;t get rendered on their own. Any other element type works too.</source>
          <target state="translated">Вы не ограничены использованием элементов &amp;lt;template&amp;gt;, но они удобны (в браузерах, которые их поддерживают), поскольку они не обрабатываются сами по себе. Любой другой тип элемента тоже работает.</target>
        </trans-unit>
        <trans-unit id="2cf0cf7d70766bca9a0f4aed278bfa9447202bcb" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using the built-in bindings like click, value, and so on &amp;mdash; you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</source>
          <target state="translated">Вы не ограничены использованием встроенных привязок, таких как щелчок, значение и т. Д. - вы можете создавать свои собственные. Это то, как контролировать взаимодействие наблюдаемых с элементами DOM, и дает вам большую гибкость для инкапсуляции сложных поведений простым для повторного использования способом.</target>
        </trans-unit>
        <trans-unit id="e47fc623d74756db24366a5c57ef4b49ba356887" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve already seen how to use update so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</source>
          <target state="translated">Вы уже видели, как использовать update, чтобы при изменении наблюдаемого вы могли обновить связанный элемент DOM. А как же события в обратном направлении? Когда пользователь выполняет какое-либо действие с элементом DOM, вы можете обновить связанный наблюдаемый объект.</target>
        </trans-unit>
        <trans-unit id="e674f60b3e3f970884c28a49f2eace45a0bc8f3b" translate="yes" xml:space="preserve">
          <source>Your function can also accept a third parameter, an object that includes any additional parameters passed to the rateLimit extender.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be6289caef2ba7111850de2b50105c34b7ea767" translate="yes" xml:space="preserve">
          <source>Your preprocess function must return the new string value to be parsed and passed to the binding, or return undefined to remove the binding.</source>
          <target state="translated">Ваша функция препроцессирования должна возвращать новое значение строки для разбора и передачи в привязку,или возвращать неопределенное для удаления привязки.</target>
        </trans-unit>
        <trans-unit id="feacdda40c5240dc38595a9dd2636c7cd727afa1" translate="yes" xml:space="preserve">
          <source>Your view models &lt;em&gt;are&lt;/em&gt; JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (a native function in modern browsers), or the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won&amp;rsquo;t always serialize cleanly without additional work on your behalf.</source>
          <target state="translated">Ваши модели &lt;em&gt;представления являются&lt;/em&gt; объектами JavaScript, поэтому в некотором смысле вы можете просто сериализовать их как JSON с помощью любого стандартного сериализатора JSON, такого как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (встроенная функция в современных браузерах) или библиотеки &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; . Однако ваши модели представления, вероятно, содержат наблюдаемые, вычисляемые наблюдаемые и наблюдаемые массивы, которые реализованы как функции JavaScript и поэтому не всегда будут сериализованы чисто без дополнительной работы от вашего имени.</target>
        </trans-unit>
        <trans-unit id="39cb2f1192f456b678052badfe6dfbc807f31fd4" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;computed observable&lt;/strong&gt; called selectedItems that returns an array of item objects corresponding to the selected indexes</source>
          <target state="translated">&lt;strong&gt;вычисляемый наблюдаемый&lt;/strong&gt; объект с именем selectedItems, который возвращает массив объектов элементов, соответствующих выбранным индексам</target>
        </trans-unit>
        <trans-unit id="c304f8e7203b72eac14ca40325fc8fce86a3be08" translate="yes" xml:space="preserve">
          <source>addBinding: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, name and value. For example, inside your preprocess function, call addBinding('visible', 'acceptsTerms()'); to make Knockout behave as if the element had a visible: acceptsTerms() binding on it.</source>
          <target state="translated">addBinding:функция обратного вызова,которую вы можете опционально использовать для вставки другой привязки к текущему элементу.Для этого требуется два параметра,имя и значение.Например,внутри вашей препроцессорной функции вызов addBinding('visible','acceptsTerms()');чтобы заставить Knockout вести себя так,как если бы элемент был видимым:acceptTerms()привязка к нему.</target>
        </trans-unit>
        <trans-unit id="ca84e4058eedaa99100e4d5459ba5d30f2c5b8ab" translate="yes" xml:space="preserve">
          <source>afterAdd &amp;mdash; is like afterRender, except it is invoked only when new entries are added to your array (and &lt;em&gt;not&lt;/em&gt; when foreach first iterates over your array&amp;rsquo;s initial contents). A common use for afterAdd is to call a method such as jQuery&amp;rsquo;s $(domNode).fadeIn() so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterAdd - похож на afterRender, за исключением того, что он вызывается только тогда, когда в ваш массив добавляются новые записи (а &lt;em&gt;не&lt;/em&gt; когда foreach сначала выполняет итерацию по начальному содержимому вашего массива). Обычно afterAdd используется для вызова такого метода, как $ (domNode) .fadeIn () из jQuery, чтобы вы получали анимированные переходы при добавлении элементов. Knockout предоставит вашему обратному вызову следующие параметры:</target>
        </trans-unit>
        <trans-unit id="5875d6886a7574f1c5c1b075f6971a15d98841a2" translate="yes" xml:space="preserve">
          <source>afterMove &amp;mdash; is invoked after an array item has changed position in the array, and after foreach has updated the DOM to match. Note that afterMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterMove - вызывается после того, как элемент массива изменил позицию в массиве, и после того, как foreach обновил DOM для соответствия. Обратите внимание, что afterMove применяется ко всем элементам массива, индексы которых изменились, поэтому, если вы вставляете новый элемент в начало массива, то обратный вызов (если он указан) срабатывает для всех других элементов, поскольку их позиция в индексе увеличилась на единицу. Knockout предоставит вашему обратному вызову следующие параметры:</target>
        </trans-unit>
        <trans-unit id="ebb1a50ce7bb74ee728f2eee95c47b413f5bd53d" translate="yes" xml:space="preserve">
          <source>afterRender &amp;mdash; is invoked each time the foreach block is duplicated and inserted into the document, both when foreach first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterRender - вызывается каждый раз, когда блок foreach дублируется и вставляется в документ, как при первой инициализации foreach, так и при добавлении новых записей в связанный массив позже. Knockout предоставит вашему обратному вызову следующие параметры:</target>
        </trans-unit>
        <trans-unit id="e5870134ecf0c0be5c68beda1e34f16544cda8dc" translate="yes" xml:space="preserve">
          <source>afterRender, afterAdd, or beforeRemove &amp;mdash; callback functions to be invoked against the rendered DOM elements - see &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;Note 4&lt;/a&gt;</source>
          <target state="translated">afterRender, afterAdd или beforeRemove - функции обратного вызова, которые будут вызываться для визуализированных элементов DOM - см. &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;примечание 4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b90203ff7ecbf7871ddb8178bb79cea83c9713d2" translate="yes" xml:space="preserve">
          <source>allBindings &amp;mdash; A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn&amp;rsquo;t exist); or allBindings.has('name') to determine if the name binding is present for the current element.</source>
          <target state="translated">allBindings - объект JavaScript, который можно использовать для доступа ко всем значениям модели, привязанным к этому элементу DOM. Вызовите allBindings.get ('name'), чтобы получить значение привязки имени (возвращает undefined, если привязка не существует); или allBindings.has ('name'), чтобы определить, присутствует ли привязка имени для текущего элемента.</target>
        </trans-unit>
        <trans-unit id="0e42813294fc8d28f3ca0881b6187457d3cc1b1f" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;observable&lt;/strong&gt; called items representing a set of items</source>
          <target state="translated">Н. &lt;strong&gt;наблюдаемые&lt;/strong&gt; называемые пункты , представляющие собой набор элементов</target>
        </trans-unit>
        <trans-unit id="bc46cf26656d742bd5335bdf9b52eddf49a88381" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;computed observable&lt;/strong&gt; that returns true or false depending on whether any of selectedItems has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</source>
          <target state="translated">другая &lt;strong&gt;вычисляемая наблюдаемая,&lt;/strong&gt; которая возвращает истину или ложь в зависимости от того, имеет ли какой-либо из selectedItems какое-либо свойство (например, новый или несохраненный). Некоторые элементы пользовательского интерфейса, такие как кнопка, могут быть включены или отключены в зависимости от этого значения.</target>
        </trans-unit>
        <trans-unit id="b76c357ba02c535d132081781d20a66952d6dcc1" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;observable&lt;/strong&gt; called selectedIndexes storing which item indexes have been &amp;lsquo;selected&amp;rsquo; by the user</source>
          <target state="translated">другой &lt;strong&gt;наблюдаемый&lt;/strong&gt; объект, называемый selectedIndexes, хранящий, какие индексы элементов были &amp;laquo;выбраны&amp;raquo; пользователем</target>
        </trans-unit>
        <trans-unit id="df211ccdd94a63e0bcb9e6ae427a249484a49d60" translate="yes" xml:space="preserve">
          <source>as</source>
          <target state="translated">as</target>
        </trans-unit>
        <trans-unit id="bd21690b8380b0841426a885d83cab1ab8325f45" translate="yes" xml:space="preserve">
          <source>as &amp;mdash; when used in conjunction with foreach, defines an alias for each item being rendered - see &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Note 3&lt;/a&gt; for details.</source>
          <target state="translated">as - при использовании вместе с foreach определяет псевдоним для каждого отображаемого элемента - см. &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Примечание 3&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="fe82d73a4cd0fd638c5b4b7c43ff1f46fdf88ddf" translate="yes" xml:space="preserve">
          <source>asleep &amp;mdash; Whevener the computed observable enters the &lt;em&gt;sleeping&lt;/em&gt; state, it notifies an asleep event with a value of undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9500f82291e43e9cc92d2055245a5a38e892ea" translate="yes" xml:space="preserve">
          <source>asynchronous updates made as part of the textInput and value binding</source>
          <target state="translated">асинхронные обновления,выполненные в составе textInput и привязки значений</target>
        </trans-unit>
        <trans-unit id="90c55536df6492005a02b302ee99abb278abe315" translate="yes" xml:space="preserve">
          <source>attr binding</source>
          <target state="translated">аттр-связка</target>
        </trans-unit>
        <trans-unit id="4d1df76ffa98addd696f0868b465b5a5ac6051c9" translate="yes" xml:space="preserve">
          <source>awake &amp;mdash; Whenever the computed observable enters the &lt;em&gt;listening&lt;/em&gt; state, it notifies an awake event using its current value. (The awake event also applies to normal computed observables created with the deferEvaluation option.) You won&amp;rsquo;t normally need to know about the internal state of your observables. But since the internal state can correspond to whether the observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5e3f66d7b1824f9fbcb9556a10b1149c3b377c" translate="yes" xml:space="preserve">
          <source>beforeMove &amp;mdash; is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that beforeMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use beforeMove to store the original screen coordinates of the affected elements so that you can animate their movements in the afterMove callback. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeMove - вызывается, когда элемент массива изменил положение в массиве, но до того, как соответствующие узлы DOM были перемещены. Обратите внимание, что beforeMove применяется ко всем элементам массива, индексы которых изменились, поэтому, если вы вставляете новый элемент в начало массива, то обратный вызов (если он указан) будет срабатывать для всех других элементов, поскольку их позиция индекса увеличилась на единицу. Вы можете использовать beforeMove для хранения исходных экранных координат затронутых элементов, чтобы вы могли анимировать их движения в обратном вызове afterMove. Knockout предоставит вашему обратному вызову следующие параметры:</target>
        </trans-unit>
        <trans-unit id="3992daaa62b44af106b3c47484f57555aa0b6bb5" translate="yes" xml:space="preserve">
          <source>beforeRemove &amp;mdash; is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a beforeRemove callback, then &lt;em&gt;it becomes your responsibility to remove the DOM nodes&lt;/em&gt;. The obvious use case here is calling something like jQuery&amp;rsquo;s $(domNode).fadeOut() to animate the removal of the corresponding DOM nodes &amp;mdash; in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeRemove - вызывается, когда элемент массива был удален, но до удаления соответствующих узлов DOM. Если вы укажете обратный вызов beforeRemove, тогда &lt;em&gt;вы обязаны удалить узлы DOM&lt;/em&gt; . Очевидным вариантом использования здесь является вызов чего-то вроде jQuery $ (domNode) .fadeOut () для анимации удаления соответствующих узлов DOM - в этом случае Knockout не может знать, как скоро разрешено физически удалить узлы DOM (кто знает, как долго ваша анимация займет?), так что их удаление зависит от вас. Knockout предоставит вашему обратному вызову следующие параметры:</target>
        </trans-unit>
        <trans-unit id="2eb4c0b60f525fd135163b1ae9de765428f744e2" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="translated">bindingContext - объект, который содержит &lt;a href=&quot;binding-context&quot;&gt;контекст привязки,&lt;/a&gt; доступный для привязок этого элемента. Этот объект включает специальные свойства, включая $ parent, $ parent и $ root, которые могут использоваться для доступа к данным, связанным с предками этого контекста.</target>
        </trans-unit>
        <trans-unit id="46540f2415ab34cc44a0a28cf94dc516343761db" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;http://knockoutjs.com/documentation/binding-context.html&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381b31a682de37484b9fd0f593135748a0b77c19" translate="yes" xml:space="preserve">
          <source>checked binding</source>
          <target state="translated">проверенный переплёт</target>
        </trans-unit>
        <trans-unit id="312ab7ec76efbca4142c1e1bc45818dbfbbc12d3" translate="yes" xml:space="preserve">
          <source>childrenComplete &amp;mdash; This event is notified &lt;strong&gt;synchronously&lt;/strong&gt; once the child nodes (and all synchronously loaded descendants) have been bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178f138000896f2d7e388a6b20ae521a0f454c9a" translate="yes" xml:space="preserve">
          <source>click binding</source>
          <target state="translated">связывание кликом</target>
        </trans-unit>
        <trans-unit id="4a22520e4829f157bb92c323abde36645d85a42d" translate="yes" xml:space="preserve">
          <source>component binding</source>
          <target state="translated">связывание компонентов</target>
        </trans-unit>
        <trans-unit id="74588c318ed3e1373d32a16c8b82217c6a9e2c33" translate="yes" xml:space="preserve">
          <source>component loading of a cached component when not configured for &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;synchronous loading&lt;/a&gt;</source>
          <target state="translated">загрузка компонента кэшированного компонента, когда он не настроен для &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;синхронной загрузки&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="47c42e798ee874e6cfcd86804e9bec622c1878b5" translate="yes" xml:space="preserve">
          <source>createViewModel(params, componentInfo) - &lt;strong&gt;Optional.&lt;/strong&gt; A function that will later be called to supply a viewmodel object for each instance of this component</source>
          <target state="translated">createViewModel (params, componentInfo) - &lt;strong&gt;Необязательно. &lt;/strong&gt;Функция, которая позже будет вызываться для предоставления объекта модели представления для каждого экземпляра этого компонента.</target>
        </trans-unit>
        <trans-unit id="df7b59f08733d6664f20aa71e5e0386fdb0dd586" translate="yes" xml:space="preserve">
          <source>css binding</source>
          <target state="translated">связывание шахт</target>
        </trans-unit>
        <trans-unit id="26be54a22383463c792c869319f96dd9c12860d2" translate="yes" xml:space="preserve">
          <source>data &amp;mdash; an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.</source>
          <target state="translated">data - объект, предоставляемый в качестве данных для рендеринга шаблона. Если вы опустите этот параметр, KO будет искать параметр foreach или будет использовать ваш текущий объект модели.</target>
        </trans-unit>
        <trans-unit id="2ace213c7cef8b5a242680b74c316a32b95cb054" translate="yes" xml:space="preserve">
          <source>data-bind syntax</source>
          <target state="translated">синтаксис передачи данных</target>
        </trans-unit>
        <trans-unit id="34bb93443083edc26cd67b3c2dc4fe14c3dbe694" translate="yes" xml:space="preserve">
          <source>data: The JavaScript object containing the data for this child</source>
          <target state="translated">данные:Объект JavaScript,содержащий данные для этого ребенка.</target>
        </trans-unit>
        <trans-unit id="37d53aab95d0d1b492e4799d7924de18059840ba" translate="yes" xml:space="preserve">
          <source>deferEvaluation &amp;mdash; Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</source>
          <target state="translated">deferEvaluation - необязательно. Если эта опция истинна, то значение вычисляемой наблюдаемой не будет оцениваться до тех пор, пока что-то не попытается получить доступ к ее значению или не подпишется на нее вручную. По умолчанию значение вычисляемого наблюдаемого определяется сразу во время создания.</target>
        </trans-unit>
        <trans-unit id="50483074a00f34742adc3cf6acea848d89daee7d" translate="yes" xml:space="preserve">
          <source>descendantsComplete &amp;mdash; This event is notified after all descendant nodes have been bound, even if those nodes were loaded and bound &lt;strong&gt;asynchronously&lt;/strong&gt;. If all descendant nodes are bound synchronously, this event is notified right after childrenComplete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fa8509278c6cb3f2826b8ba5d48e406bb348d7" translate="yes" xml:space="preserve">
          <source>destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</source>
          <target state="translated">destroy и destroyAll (Примечание:Обычно относится только к разработчикам Ruby on Rails)</target>
        </trans-unit>
        <trans-unit id="53a4c6ac425d3063b86bc1ab2c792b870176f0d5" translate="yes" xml:space="preserve">
          <source>destroy( function (someItem) { return someItem.age &amp;lt; 18; } ) &amp;mdash; Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</source>
          <target state="translated">destroy (function (someItem) {return someItem.age &amp;lt;18;}) - Находит любые объекты в массиве, чье свойство age меньше 18, и дает этим объектам специальное свойство _destroy со значением true.</target>
        </trans-unit>
        <trans-unit id="096f0b56c9676c58652a45daacde73ceec0b98f6" translate="yes" xml:space="preserve">
          <source>destroy( someItem ) &amp;mdash; Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroy (someItem) - находит в массиве любые объекты, равные someItem, и дает им специальное свойство _destroy со значением true.</target>
        </trans-unit>
        <trans-unit id="fad302ca93de39a8152dfd801b6995ae49e76427" translate="yes" xml:space="preserve">
          <source>destroyAll( ['Chad', 132, undefined] ) &amp;mdash; Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroyAll (['Chad', 132, undefined]) - находит любые объекты в массиве, которые равны 'Chad', 123 или undefined, и присваивает им специальное свойство _destroy со значением true.</target>
        </trans-unit>
        <trans-unit id="0c040eb253b450db9af8ba7d1cc4c4ceed51a12c" translate="yes" xml:space="preserve">
          <source>destroyAll() &amp;mdash; Gives a special property called _destroy with value true to all objects in the array.</source>
          <target state="translated">destroyAll () - предоставляет специальное свойство _destroy со значением true для всех объектов в массиве.</target>
        </trans-unit>
        <trans-unit id="d92388626bd61574908cf24a5d84d7ffe24cba8a" translate="yes" xml:space="preserve">
          <source>disable binding</source>
          <target state="translated">инвалидный переплёт</target>
        </trans-unit>
        <trans-unit id="04f99f5aa32d4e1d11f627b6330ddd81b87c9a84" translate="yes" xml:space="preserve">
          <source>dispose() &amp;mdash; Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won&amp;rsquo;t be cleaned.</source>
          <target state="translated">dispose () - вручную удаляет вычисляемую наблюдаемую, очищая все подписки на зависимости. Эта функция полезна, если вы хотите остановить обновление вычисляемого наблюдаемого объекта или хотите очистить память для вычисляемого наблюдаемого объекта, который имеет зависимости от наблюдаемых объектов, которые не будут очищены.</target>
        </trans-unit>
        <trans-unit id="02ed7cabc21681b07d4278e4c14c20d3a17e8b0b" translate="yes" xml:space="preserve">
          <source>disposeWhen &amp;mdash; Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</source>
          <target state="translated">disposeWhen - Необязательно. Если задано, эта функция выполняется перед каждой повторной оценкой, чтобы определить, следует ли удалить вычисленную наблюдаемую. Истинный результат запустит удаление вычисленной наблюдаемой.</target>
        </trans-unit>
        <trans-unit id="248f5cb9e1c627a7396078c4ffb6961606c2969b" translate="yes" xml:space="preserve">
          <source>disposeWhenNodeIsRemoved &amp;mdash; Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</source>
          <target state="translated">disposeWhenNodeIsRemoved - Необязательно. Если задано, удаление вычисленного наблюдаемого будет инициировано, когда указанный узел DOM будет удален KO. Эта функция используется для удаления вычисляемых наблюдаемых, используемых в привязках, когда узлы удаляются привязками шаблона и потока управления.</target>
        </trans-unit>
        <trans-unit id="ee8eb5a2c228591905a3602312f95d5295c4df85" translate="yes" xml:space="preserve">
          <source>element &amp;mdash; The DOM element involved in this binding</source>
          <target state="translated">element - элемент DOM, участвующий в этой привязке</target>
        </trans-unit>
        <trans-unit id="4859f3f9258067e95015c5768146fc6fdd7df0af" translate="yes" xml:space="preserve">
          <source>enable binding</source>
          <target state="translated">принудительная привязка</target>
        </trans-unit>
        <trans-unit id="a254fc2b2604547861a201222e9abc1f8f487b17" translate="yes" xml:space="preserve">
          <source>evaluator &amp;mdash; A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">оценщик - функция, которая используется для оценки текущего значения вычисляемого наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="09016bc9005f501c49350459275e5548a714be1d" translate="yes" xml:space="preserve">
          <source>event binding</source>
          <target state="translated">привязка к событиям</target>
        </trans-unit>
        <trans-unit id="c3a2e9f3820a8e92022c44f759eb5cbd25a9a0ad" translate="yes" xml:space="preserve">
          <source>event handlers added by ko.utils.registerEventHandler including those bound by the event and click bindings</source>
          <target state="translated">обработчики событий,добавленные ko.utils.registerEventHandler,в том числе привязанные к событию и щелчки по привязкам</target>
        </trans-unit>
        <trans-unit id="441a9b8c6e5fb83a5d5904e2015cace1348719af" translate="yes" xml:space="preserve">
          <source>extend(extenders) &amp;mdash; Applies the given &lt;a href=&quot;extenders&quot;&gt;extenders&lt;/a&gt; to the computed observable.</source>
          <target state="translated">extend (extenders) - применяет указанные &lt;a href=&quot;extenders&quot;&gt;расширители&lt;/a&gt; к вычисляемому наблюдаемому.</target>
        </trans-unit>
        <trans-unit id="cd71042eef75a46bae679bea017b7d3dfcc8efba" translate="yes" xml:space="preserve">
          <source>foreach &amp;mdash; instructs KO to render the template in &amp;ldquo;foreach&amp;rdquo; mode - see &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Note 2&lt;/a&gt; for details.</source>
          <target state="translated">foreach - инструктирует KO визуализировать шаблон в режиме &amp;laquo;foreach&amp;raquo; - см. &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Примечание 2&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="23b634a4c77edfd882e83d6831db243e019ba4a5" translate="yes" xml:space="preserve">
          <source>foreach binding</source>
          <target state="translated">связывание передней части</target>
        </trans-unit>
        <trans-unit id="05900663008f6a8d4c17b3c024b26ac955efa734" translate="yes" xml:space="preserve">
          <source>getConfig(name, callback)</source>
          <target state="translated">getConfig(имя,обратный вызов)</target>
        </trans-unit>
        <trans-unit id="b4c4660644d77f70fe1a9cee3ca63cac55a0dc9f" translate="yes" xml:space="preserve">
          <source>getDependencies() &amp;mdash; Returns an array of the current dependencies of the computed observable. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cbd9a0bc9e935ac585a0fd1e9cef0b854a0878" translate="yes" xml:space="preserve">
          <source>getDependencies() &amp;mdash; Returns an array of the dependencies of the computed observable detected so far during the current evaluation. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c490db1820ff63fc6b9af3cb9e098588f2dbf1da" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the current number of dependencies of the computed observable.</source>
          <target state="translated">getDependenciesCount () - возвращает текущее количество зависимостей вычисляемой наблюдаемой.</target>
        </trans-unit>
        <trans-unit id="84b6a1fc96c1619898d42781f47554a1b5f0de39" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the number of dependencies of the computed observable detected so far during the current evaluation.</source>
          <target state="translated">getDependenciesCount () - возвращает количество зависимостей вычисляемого наблюдаемого, обнаруженных на данный момент во время текущей оценки.</target>
        </trans-unit>
        <trans-unit id="92edb1e30abbee2fdc76356e034a41321e09a327" translate="yes" xml:space="preserve">
          <source>getSubscriptionsCount( [event] ) &amp;mdash; Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like &quot;change&quot;) to return just the count of subscriptions for that event.</source>
          <target state="translated">getSubscriptionsCount ([событие]) - возвращает текущее количество подписок (из других вычисленных наблюдаемых или ручных подписок) вычисляемого наблюдаемого. При желании можно передать имя события (например, &amp;laquo;изменение&amp;raquo;), чтобы получить только количество подписок для этого события.</target>
        </trans-unit>
        <trans-unit id="e94c9d2e11930e54a96635c7830349bc8bbc5fc1" translate="yes" xml:space="preserve">
          <source>hasFocus binding</source>
          <target state="translated">связывание hasFocus</target>
        </trans-unit>
        <trans-unit id="78501003a54e9c53d78d928bcf94cf00a9b15734" translate="yes" xml:space="preserve">
          <source>html binding</source>
          <target state="translated">связывание html</target>
        </trans-unit>
        <trans-unit id="5767293ed1ea5a45170adafe80d616753ab89d4e" translate="yes" xml:space="preserve">
          <source>if &amp;mdash; if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</source>
          <target state="translated">if - если этот параметр предоставлен, шаблон будет отображаться только в том случае, если указанное выражение оценивается как истинное (или истинное значение). Это может быть полезно для предотвращения привязки нулевого наблюдаемого к шаблону до его заполнения.</target>
        </trans-unit>
        <trans-unit id="f8a7ee59b7f626d3e0bbf6283344f28bfd576098" translate="yes" xml:space="preserve">
          <source>if (and ifnot) play a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible (and hidden) bindings&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied&amp;mdash;the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8595778a42da105c7c0cd044962a90ff2d28f8c7" translate="yes" xml:space="preserve">
          <source>if binding</source>
          <target state="translated">в случае обязательного характера</target>
        </trans-unit>
        <trans-unit id="703e05e02465cf23455e0519cadf7b85a6baeca8" translate="yes" xml:space="preserve">
          <source>if plays a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible binding&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied - the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="translated">if играет &lt;a href=&quot;visible-binding&quot;&gt;ту&lt;/a&gt; же роль, что и видимая привязка . Разница в том, что при использовании visible содержащаяся разметка всегда остается в DOM и всегда имеет свои атрибуты привязки данных - видимая привязка просто использует CSS для переключения видимости элемента контейнера. Однако привязка if физически добавляет или удаляет разметку, содержащуюся в вашей модели DOM, и применяет привязки к потомкам только в том случае, если выражение истинно.</target>
        </trans-unit>
        <trans-unit id="369832115815305bb53a2b29db05f53365aa632e" translate="yes" xml:space="preserve">
          <source>ifnot binding</source>
          <target state="translated">если не обязательный</target>
        </trans-unit>
        <trans-unit id="a35568315c1ca43522c11c18e4a77538f03287b9" translate="yes" xml:space="preserve">
          <source>indexOf</source>
          <target state="translated">indexOf</target>
        </trans-unit>
        <trans-unit id="16c8e78fdbe507804a784e42208f919531155c8d" translate="yes" xml:space="preserve">
          <source>isActive() &amp;mdash; Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</source>
          <target state="translated">isActive () - Возвращает, может ли вычисляемая наблюдаемая обновляться в будущем. Вычисляемая наблюдаемая неактивна, если у нее нет зависимостей.</target>
        </trans-unit>
        <trans-unit id="213f712732355425bb5676b74b023984157a1fc1" translate="yes" xml:space="preserve">
          <source>isInitial() &amp;mdash; A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For &lt;em&gt;pure&lt;/em&gt; computed observables, isInitial() is always undefined.</source>
          <target state="translated">isInitial () - функция, которая возвращает true, если вызывается во время первой оценки текущего вычисляемого наблюдаемого, или false в противном случае. Для &lt;em&gt;чисто&lt;/em&gt; вычисленных наблюдаемых isInitial () всегда не определено.</target>
        </trans-unit>
        <trans-unit id="87aad0bc78c46e535fc5dc0237fb0a38695c78b2" translate="yes" xml:space="preserve">
          <source>ko.bindingHandlers.&amp;lt;name&amp;gt;.preprocess(value, name, addBindingCallback)</source>
          <target state="translated">ko.bindingHandlers. &amp;lt;имя&amp;gt; .preprocess (значение, имя, addBindingCallback)</target>
        </trans-unit>
        <trans-unit id="3c1d83117feab81eede2624f7c5f8381d8978da6" translate="yes" xml:space="preserve">
          <source>ko.bindingProvider.instance.preprocessNode(node)</source>
          <target state="translated">ko.bindingProvider.instance.preprocessNode(node)</target>
        </trans-unit>
        <trans-unit id="055225b66db9860a7fdc32f9d0f603bb832d0cfd" translate="yes" xml:space="preserve">
          <source>ko.components.clearCachedDefinition(name)</source>
          <target state="translated">ko.components.clearCachedDefinition(name)</target>
        </trans-unit>
        <trans-unit id="7a279b97657226354a93afb2f4ea4220ffc22e79" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.getConfig(name, callback)</source>
          <target state="translated">ko.components.defaultLoader.getConfig(имя,обратный вызов)</target>
        </trans-unit>
        <trans-unit id="2459bd18ae1dc7e03d2b20bfd3bf5cb59b715afa" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadComponent(name, componentConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadComponent(имя,componentConfig,обратный звонок)</target>
        </trans-unit>
        <trans-unit id="16b20060cf28c63034230aa98ea10ad5f2365b12" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadTemplate(имя,templateConfig,обратный вызов)</target>
        </trans-unit>
        <trans-unit id="21a38533dd3c756e30cf34b8f8ccca46fa822259" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadViewModel (имя,видModelConfig,обратный вызов)</target>
        </trans-unit>
        <trans-unit id="329d6b1d29362063e6c26807624b008e42dc8a23" translate="yes" xml:space="preserve">
          <source>ko.components.get(name, callback)</source>
          <target state="translated">ko.components.get(name,callback)</target>
        </trans-unit>
        <trans-unit id="807267b5ea3ed18c0e6c441d7bbb7266de4efac9" translate="yes" xml:space="preserve">
          <source>ko.components.isRegistered(name)</source>
          <target state="translated">ko.components.isRegistered(name)</target>
        </trans-unit>
        <trans-unit id="465f62f6b74979963d9063914c13f8f93854ea91" translate="yes" xml:space="preserve">
          <source>ko.components.register(name, configuration)</source>
          <target state="translated">ko.components.register(имя,конфигурация)</target>
        </trans-unit>
        <trans-unit id="aa5bff0c09be54c216270b110f420a227104f8f0" translate="yes" xml:space="preserve">
          <source>ko.components.unregister(name)</source>
          <target state="translated">ko.components.unregister(name)</target>
        </trans-unit>
        <trans-unit id="eb0d870a4e6ad5b29fe16fcf4f027a7e968ff00b" translate="yes" xml:space="preserve">
          <source>ko.computed properties continue to receive notifications from their dependencies until explicitly disposed.</source>
          <target state="translated">ko.calculated properties продолжают получать уведомления от своих зависимостей до тех пор,пока не будут явно ликвидированы.</target>
        </trans-unit>
        <trans-unit id="9e8f7511dca3b06e70c9faf4aba9d6016334a4e6" translate="yes" xml:space="preserve">
          <source>ko.computed( evaluator [, targetObject, options] ) &amp;mdash; This form supports the most common case of creating a computed observable.</source>
          <target state="translated">ko.computed (оценщик [, targetObject, options]) - эта форма поддерживает наиболее распространенный случай создания вычисляемого наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="b00774478c790a957ea39251a6fb67eafd152ac0" translate="yes" xml:space="preserve">
          <source>ko.computed( options ) &amp;mdash; This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</source>
          <target state="translated">ko.computed (options) - эта форма с одним параметром для создания вычисляемого наблюдаемого принимает объект JavaScript с любым из следующих свойств.</target>
        </trans-unit>
        <trans-unit id="f1c20d087a46710430ae7e74a8957062cb722070" translate="yes" xml:space="preserve">
          <source>ko.computed.fn</source>
          <target state="translated">ko.computed.fn</target>
        </trans-unit>
        <trans-unit id="d26d19c3de9ae466805a8d659a3c953c8c1d0530" translate="yes" xml:space="preserve">
          <source>ko.contextFor(element) - returns the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; that was available to the DOM element.</source>
          <target state="translated">ko.contextFor (element) - возвращает весь &lt;a href=&quot;binding-context&quot;&gt;контекст привязки,&lt;/a&gt; который был доступен элементу DOM.</target>
        </trans-unit>
        <trans-unit id="06265ae214e4c7ed0b5122f8c519271d97fbfb8c" translate="yes" xml:space="preserve">
          <source>ko.dataFor(element) - returns the data that was available for binding against the element</source>
          <target state="translated">ko.dataFor(элемент)-возвращает данные,которые были доступны для привязки к элементу</target>
        </trans-unit>
        <trans-unit id="e5ab92cfd76820bc882d2a512801533d3821d30a" translate="yes" xml:space="preserve">
          <source>ko.isComputed &amp;mdash; returns true for all computed observables.</source>
          <target state="translated">ko.isComputed - возвращает истину для всех вычисленных наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="ba0a8c1361fd16fa684b1945bb04a31e37a75289" translate="yes" xml:space="preserve">
          <source>ko.isObservable &amp;mdash; returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable - возвращает true для наблюдаемых, наблюдаемых массивов и всех вычисляемых наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="2d026a183086e8ab18f0fea90633d888febdc550" translate="yes" xml:space="preserve">
          <source>ko.isObservable - returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable-возвращает true для наблюдаемых,наблюдаемых массивов и всех вычисляемых наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="33e63cd27e89b9898ebb8e10b0f17a0934ea8e48" translate="yes" xml:space="preserve">
          <source>ko.isPureComputed &amp;mdash; returns true for &lt;em&gt;pure&lt;/em&gt; computed observables.</source>
          <target state="translated">ko.isPureComputed - возвращает истину для &lt;em&gt;чисто&lt;/em&gt; вычисленных наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="0c4edd7fa41dfb49e265401fb4e953fe2f59d5fb" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable &amp;mdash; returns true for observables, observable arrays, and &lt;em&gt;writable&lt;/em&gt; computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable - возвращает true для наблюдаемых объектов, наблюдаемых массивов и &lt;em&gt;доступных для записи&lt;/em&gt; вычисляемых наблюдаемых объектов (также имеет псевдоним ko.isWriteableObservable).</target>
        </trans-unit>
        <trans-unit id="754ea921da81e0b6e8a76f19d21a38b2fd6b07b5" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable - returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable-возвращает true для наблюдаемых,наблюдаемых массивов и записываемых вычисляемых наблюдаемых (также псевдоним ko.isWriteableObservable).</target>
        </trans-unit>
        <trans-unit id="e289a906e88ca4290e5d991a93f7c57b8c4684a6" translate="yes" xml:space="preserve">
          <source>ko.observable.fn</source>
          <target state="translated">ko.observable.fn</target>
        </trans-unit>
        <trans-unit id="dc9c8ae3fe7bb15035ebcb2f7a2ce4c354d592de" translate="yes" xml:space="preserve">
          <source>ko.observableArray.fn</source>
          <target state="translated">ko.observableArray.fn</target>
        </trans-unit>
        <trans-unit id="a6f5f5f281a8736bda725dd28aa8d5c4848f7ea9" translate="yes" xml:space="preserve">
          <source>ko.onError</source>
          <target state="translated">ko.onError</target>
        </trans-unit>
        <trans-unit id="106eda8827c7f9a29315d41770f83ea9dfec979e" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( evaluator [, targetObject] ) &amp;mdash; Constructs a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt; using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn&amp;rsquo;t accept an options parameter.</source>
          <target state="translated">ko.pureComputed (оценщик [, targetObject]) - конструирует &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;чисто&lt;/em&gt; вычисляемую наблюдаемую&lt;/a&gt; с использованием данной функции оценщика и необязательного объекта для использования для этого. В отличие от ko.computed, этот метод не принимает параметр options.</target>
        </trans-unit>
        <trans-unit id="7562774ba1edf2db877045ee696268509d532ef8" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( options ) &amp;mdash; Constructs a &lt;em&gt;pure&lt;/em&gt; computed observable using an options object. This accepts the read, write, and owner options described above.</source>
          <target state="translated">ko.pureComputed (options) - создает &lt;em&gt;чисто&lt;/em&gt; вычисляемую наблюдаемую с использованием объекта параметров. Это принимает параметры чтения, записи и владельца, описанные выше.</target>
        </trans-unit>
        <trans-unit id="ee34b3491247fbedc6018f48a7b0649bf286403f" translate="yes" xml:space="preserve">
          <source>ko.subscribable.fn</source>
          <target state="translated">ko.subscribable.fn</target>
        </trans-unit>
        <trans-unit id="15a6aefd0151368becbda1d0ee853e26ef3e063b" translate="yes" xml:space="preserve">
          <source>ko.tasks.runEarly() &amp;mdash; Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously.</source>
          <target state="translated">ko.tasks.runEarly () - вызовите этот метод, чтобы немедленно обработать текущую очередь микрозадач по запросу, пока она не станет пустой. Помимо интеграции библиотеки, вы можете использовать этот метод, если у вас есть код, который планирует ряд задач, но затем должен обрабатывать эффекты этих задач синхронно.</target>
        </trans-unit>
        <trans-unit id="faa0c0987272811d4ff86131601c71626df34cea" translate="yes" xml:space="preserve">
          <source>ko.tasks.scheduler &amp;mdash; Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use process.nextTick for the flush event: ko.tasks.scheduler = process.nextTick;.</source>
          <target state="translated">ko.tasks.scheduler - переопределите этот метод, чтобы переопределить или расширить способ планирования события Knockout для обработки и очистки очереди. Knockout вызывает этот метод при планировании первой задачи, поэтому он должен запланировать событие и немедленно вернуться. Например, если ваше приложение работает в Node.js, вы можете предпочесть использовать process.nextTick для события сброса: ko.tasks.scheduler = process.nextTick ;.</target>
        </trans-unit>
        <trans-unit id="72f6e7831d1df86bc87ee07643b98cbfaffdbb89" translate="yes" xml:space="preserve">
          <source>ko.toJS &amp;mdash; this clones your view model&amp;rsquo;s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts</source>
          <target state="translated">ko.toJS - это клонирует граф объектов вашей модели представления, заменяя для каждого наблюдаемого текущее значение этого наблюдаемого, поэтому вы получаете простую копию, которая содержит только ваши данные и никаких артефактов, связанных с Knockout</target>
        </trans-unit>
        <trans-unit id="8f921b7a45abcec43b02a6601d9bdc280d40c78e" translate="yes" xml:space="preserve">
          <source>ko.toJSON &amp;mdash; this produces a JSON string representing your view model&amp;rsquo;s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser&amp;rsquo;s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library.</source>
          <target state="translated">ko.toJSON - создает строку JSON, представляющую данные вашей модели представления. Внутри он просто вызывает ko.toJS в вашей модели представления, а затем использует собственный сериализатор JSON браузера для результата. Примечание: чтобы это работало в старых браузерах, в которых нет собственного сериализатора JSON (например, IE 7 или более ранней &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;версии&lt;/a&gt; ), вы также должны ссылаться на библиотеку json2.js .</target>
        </trans-unit>
        <trans-unit id="738a8193c3e783c17d50280b2acff5c17c5363ce" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.allowedBindings</source>
          <target state="translated">ko.virtualElements.allowedBindings</target>
        </trans-unit>
        <trans-unit id="3fc144ac6a03bb72f185dbc31fd3e60209cdccfc" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.emptyNode(containerElem)</source>
          <target state="translated">ko.virtualElements.emptyNode(containerElem)</target>
        </trans-unit>
        <trans-unit id="16cb1a0760097250c1d6a57cda17df82d6a63922" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.firstChild(containerElem)</source>
          <target state="translated">ko.virtualElements.firstChild(containerElem)</target>
        </trans-unit>
        <trans-unit id="06073de57d46544971ccb6059851d47ea1ab2fec" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)</source>
          <target state="translated">ko.virtualElements.insertAfter(containerElem,nodeToInsert,insertAfter)</target>
        </trans-unit>
        <trans-unit id="f0630dc3ec6d4f13606bdea53863015c2cb27263" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.nextSibling(node)</source>
          <target state="translated">ko.virtualElements.nextSibling(node)</target>
        </trans-unit>
        <trans-unit id="fe4347781b95d863c9d53b169d5a53b5a49663ac" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.prepend(containerElem, nodeToPrepend)</source>
          <target state="translated">ko.virtualElements.prepend(containerElem,nodeToPrepend)</target>
        </trans-unit>
        <trans-unit id="e6c8f2823abd2f761611dc1d03bd6be1f6b71b8e" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)</source>
          <target state="translated">ko.virtualElements.setDomNodeChildren(containerElem,arrayOfNodes)</target>
        </trans-unit>
        <trans-unit id="ae33d3da7690605630d3b5ed0a0e56ec1697cf89" translate="yes" xml:space="preserve">
          <source>ko.when can also be called with just the predicate function. In that case, it returns a Promise that will be resolved with the predicate result once the predicate returns a true-ish value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cee4d4c787cee1d4b2b9866ab7a9b69e7a5057b" translate="yes" xml:space="preserve">
          <source>ko.when waits until the first function (predicate) returns true or a true-ish value, at which time it runs the second function (callback), passing the predicate result. You can optionally pass in a third parameter (context) that defines the value of this for the predicate and callback functions. ko.when returns a subscription object that you can use the cancel the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b7dfcb52da6b0ba4650716e4ca43082f5feafd" translate="yes" xml:space="preserve">
          <source>loadComponent(name, componentConfig, callback)</source>
          <target state="translated">loadComponent(имя,componentConfig,обратный вызов)</target>
        </trans-unit>
        <trans-unit id="62e20634e40fa347d5ad134f972b15f2c990a759" translate="yes" xml:space="preserve">
          <source>loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">loadTemplate(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="41fe8394a06084fc87259bbd05c6e913daa937d7" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, templateConfig, callback)</source>
          <target state="translated">loadViewModel(имя,шаблонConfig,обратный вызов)</target>
        </trans-unit>
        <trans-unit id="1f9c1aeab0274b6b6348b52a68972d4ea5726e3b" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, viewModelConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7080dbc7436a18db36408fd6a408608eee003c46" translate="yes" xml:space="preserve">
          <source>mappedDestroy</source>
          <target state="translated">mappedDestroy</target>
        </trans-unit>
        <trans-unit id="5136c37aaef9493efe3b449744ba2f34d4cdcc8b" translate="yes" xml:space="preserve">
          <source>mappedDestroyAll</source>
          <target state="translated">mappedDestroyAll</target>
        </trans-unit>
        <trans-unit id="99002c7fb8b1dacc2772e98e37f191c8d33a1256" translate="yes" xml:space="preserve">
          <source>mappedIndexOf</source>
          <target state="translated">mappedIndexOf</target>
        </trans-unit>
        <trans-unit id="14d1111fd891b47dbe5304a5bf26024c52b381cc" translate="yes" xml:space="preserve">
          <source>mappedRemove</source>
          <target state="translated">mappedRemove</target>
        </trans-unit>
        <trans-unit id="2dca0f36f8e0c0920d22300deffb28e503aeabf5" translate="yes" xml:space="preserve">
          <source>mappedRemoveAll</source>
          <target state="translated">mappedRemoveAll</target>
        </trans-unit>
        <trans-unit id="8615a2284a082e7284f964e699021504000797a2" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the ID of an element that contains the template you wish to render - see &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Note 5&lt;/a&gt; for how to vary this programmatically.</source>
          <target state="translated">name - идентификатор элемента, который содержит шаблон, который вы хотите отобразить - см. &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Примечание 5,&lt;/a&gt; чтобы узнать, как изменить это программно.</target>
        </trans-unit>
        <trans-unit id="43ae5c03a40af9e524c7f17000f40eab0946953c" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the name of the component to inject. Again, this can be observable.</source>
          <target state="translated">name - имя компонента для внедрения. Опять же, это можно наблюдать.</target>
        </trans-unit>
        <trans-unit id="153b716a1c705fc7b577a6d6cc8234a6909f9cc0" translate="yes" xml:space="preserve">
          <source>name: the name of the binding (e.g., for yourBinding: 1 + 1, the name is &quot;yourBinding&quot; as a string).</source>
          <target state="translated">имя:имя переплета (например,для Вашего переплета:1+1,имя &quot;Ваш переплет&quot; в виде строки).</target>
        </trans-unit>
        <trans-unit id="f5b834e53d7ae92556a516cf6fed5206f4bf3cd5" translate="yes" xml:space="preserve">
          <source>noChildContext</source>
          <target state="translated">noChildContext</target>
        </trans-unit>
        <trans-unit id="fd9f9671fef2600dc7d9a2e2f6ac58059c2cf1e5" translate="yes" xml:space="preserve">
          <source>nodes &amp;mdash; directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.</source>
          <target state="translated">узлы - напрямую передают массив узлов DOM для использования в качестве шаблона. Это должен быть ненаблюдаемый массив, и обратите внимание, что элементы будут удалены из их текущего родителя, если он у них есть. Этот параметр игнорируется, если вы также передали непустое значение для имени.</target>
        </trans-unit>
        <trans-unit id="ade2fb9bb0e21209a2280976a96721a3984afaaa" translate="yes" xml:space="preserve">
          <source>notifyAtFixedRate &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="translated">notifyAtFixedRate - &lt;strong&gt;значение по умолчанию, если не указано иное&lt;/strong&gt; . Уведомление происходит по истечении указанного периода времени с момента первого изменения наблюдаемого (либо изначально, либо с момента предыдущего уведомления).</target>
        </trans-unit>
        <trans-unit id="bfc6c7b444c24d6b64a8361cd00dc9091107de87" translate="yes" xml:space="preserve">
          <source>notifyWhenChangesStop &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="translated">notifyWhenChangesStop - уведомление происходит после того, как в наблюдаемый объект не произошло никаких изменений в течение указанного периода времени. Каждый раз, когда наблюдаемое изменяется, этот таймер сбрасывается, поэтому уведомления не могут происходить, если наблюдаемое постоянно изменяется чаще, чем период тайм-аута.</target>
        </trans-unit>
        <trans-unit id="7cf7948331269132eb18cd16d74bca7c9656a62e" translate="yes" xml:space="preserve">
          <source>observable: If the property is an observable, this will be set to the actual observable</source>
          <target state="translated">наблюдаемый:Если это свойство является наблюдаемым,то оно будет установлено в фактическое наблюдаемое значение.</target>
        </trans-unit>
        <trans-unit id="3a12abbdbb90d2aa3b8a8824637963734fe18f32" translate="yes" xml:space="preserve">
          <source>observableArray adds some more useful methods that aren&amp;rsquo;t found on JavaScript arrays by default:</source>
          <target state="translated">observableArray добавляет еще несколько полезных методов, которые по умолчанию отсутствуют в массивах JavaScript:</target>
        </trans-unit>
        <trans-unit id="c136e98248f5a0b1e7844aac2ff24bd91872be37" translate="yes" xml:space="preserve">
          <source>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</source>
          <target state="translated">ObsableArray раскрывает знакомый набор функций для модификации содержимого массива и оповещения слушателей.</target>
        </trans-unit>
        <trans-unit id="d313002d790cf1264f49478e1a7e27592448f033" translate="yes" xml:space="preserve">
          <source>observableExpression</source>
          <target state="translated">observableExpression</target>
        </trans-unit>
        <trans-unit id="6ae20630c651e48135794f920e43f6369bd29f8f" translate="yes" xml:space="preserve">
          <source>options &amp;mdash; An object with further properties for the computed observable. See the full list below.</source>
          <target state="translated">options - объект с дополнительными свойствами для вычисляемого наблюдаемого. См. Полный список ниже.</target>
        </trans-unit>
        <trans-unit id="f6f3cb718d8232f8095093bcd8b8ef4c1e83a310" translate="yes" xml:space="preserve">
          <source>options binding</source>
          <target state="translated">связывание опций</target>
        </trans-unit>
        <trans-unit id="c200e46257cc25ebc5150d82eb3ee07b6e38447d" translate="yes" xml:space="preserve">
          <source>optionsAfterRender</source>
          <target state="translated">optionsAfterRender</target>
        </trans-unit>
        <trans-unit id="924bed9ee85f51893b937580ab61c608cdc93818" translate="yes" xml:space="preserve">
          <source>optionsCaption</source>
          <target state="translated">optionsCaption</target>
        </trans-unit>
        <trans-unit id="9dfa9e0a9830d2655b73d8d8deb5640b800c4037" translate="yes" xml:space="preserve">
          <source>optionsIncludeDestroyed</source>
          <target state="translated">optionsIncludeDestroyed</target>
        </trans-unit>
        <trans-unit id="8ae7670102147644c6634d485af1c1fc8805ccfb" translate="yes" xml:space="preserve">
          <source>optionsText</source>
          <target state="translated">optionsText</target>
        </trans-unit>
        <trans-unit id="0d2c0213a91bd297d264f544b41793b3cded6023" translate="yes" xml:space="preserve">
          <source>optionsValue</source>
          <target state="translated">optionsValue</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="98d78190e1c18c8409cc555525dba84fa833eb6e" translate="yes" xml:space="preserve">
          <source>owner &amp;mdash; Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.</source>
          <target state="translated">владелец - Необязательно. Если задано, определяет значение this всякий раз, когда KO вызывает ваши обратные вызовы чтения или записи.</target>
        </trans-unit>
        <trans-unit id="a07e95b0cdb77798a52385e0291f03fa5a033510" translate="yes" xml:space="preserve">
          <source>params &amp;mdash; an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component&amp;rsquo;s viewmodel constructor.</source>
          <target state="translated">params - объект, который будет передан компоненту. Обычно это объект &amp;laquo;ключ-значение&amp;raquo;, содержащий несколько параметров, и обычно он принимается конструктором модели представления компонента.</target>
        </trans-unit>
        <trans-unit id="29fca18badf74bcc82a52bdd8ab473f35ada2a92" translate="yes" xml:space="preserve">
          <source>parent: The parent object or array to which this child belongs</source>
          <target state="translated">родительский:родительский объект или массив,к которому этот дочерний элемент принадлежит</target>
        </trans-unit>
        <trans-unit id="84e2aa7296151d313a34b5208e6160b57faaf939" translate="yes" xml:space="preserve">
          <source>peek() &amp;mdash; Returns the current value of the computed observable without creating a dependency (see the section on &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;).</source>
          <target state="translated">peek () - возвращает текущее значение вычисляемого наблюдаемого без создания зависимости (см. раздел о &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7eff74c13ae15cbc418dcf740fe5df3ce50f2c51" translate="yes" xml:space="preserve">
          <source>pop() &amp;mdash; Removes the last value from the array and returns it.</source>
          <target state="translated">pop () - удаляет последнее значение из массива и возвращает его.</target>
        </trans-unit>
        <trans-unit id="1ca69cbe02c25699e6ece62ec814d7791c4911c3" translate="yes" xml:space="preserve">
          <source>pop, push, shift, unshift, reverse, sort, splice</source>
          <target state="translated">Pop,push,shift,unshift,reverse,sort,splice</target>
        </trans-unit>
        <trans-unit id="416e762665dd122de1e192dd764a4872244dd057" translate="yes" xml:space="preserve">
          <source>preprocessing</source>
          <target state="translated">preprocessing</target>
        </trans-unit>
        <trans-unit id="4a6b2f0003c223ed4373d59b9044c43a3b0ec52d" translate="yes" xml:space="preserve">
          <source>pure &amp;mdash; Optional. If this option is true, the computed observable will be set up as a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt;. This option is an alternative to the ko.pureComputed constructor.</source>
          <target state="translated">чистый - Необязательно. Если эта опция истинна, вычисляемая наблюдаемая будет установлена ​​как &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;чисто&lt;/em&gt; вычисляемая наблюдаемая&lt;/a&gt; . Этот вариант является альтернативой конструктору ko.pureComputed.</target>
        </trans-unit>
        <trans-unit id="8f36b390db7ad00f023d03c9a8e1cd34da7cea23" translate="yes" xml:space="preserve">
          <source>push( value ) &amp;mdash; Adds a new item to the end of array.</source>
          <target state="translated">push (value) - добавляет новый элемент в конец массива.</target>
        </trans-unit>
        <trans-unit id="e21048ba125aebf005126df579aa7d684aaa1216" translate="yes" xml:space="preserve">
          <source>rateLimit supports two parameter formats:</source>
          <target state="translated">rateLimit поддерживает два формата параметров:</target>
        </trans-unit>
        <trans-unit id="4139be45f16ffa0fe5e84f6cade922de5f51c46f" translate="yes" xml:space="preserve">
          <source>read &amp;mdash; Required. A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">читать - Обязательно. Функция, которая используется для оценки текущего значения вычисляемого наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="e718caf79a7fe0cf6a87d95cc2a7797870e5f1cc" translate="yes" xml:space="preserve">
          <source>remove and removeAll</source>
          <target state="translated">удалять и сниматьВсе</target>
        </trans-unit>
        <trans-unit id="96d8e0f211ec9e71e2ecd7b8f3e6fa85b82a0938" translate="yes" xml:space="preserve">
          <source>remove( function (item) { return item.age &amp;lt; 18; } ) &amp;mdash; Removes all values whose age property is less than 18, and returns them as an array.</source>
          <target state="translated">remove (function (item) {return item.age &amp;lt;18;}) - удаляет все значения, свойство age которых меньше 18, и возвращает их в виде массива.</target>
        </trans-unit>
        <trans-unit id="8cb74b9b1b5503e58de979117dcb56a32521b991" translate="yes" xml:space="preserve">
          <source>remove( someItem ) &amp;mdash; Removes all values that equal someItem and returns them as an array.</source>
          <target state="translated">remove (someItem) - удаляет все значения, равные someItem, и возвращает их в виде массива.</target>
        </trans-unit>
        <trans-unit id="5d5ddbae3af08573d9f04a58584e212e1b3b6b7e" translate="yes" xml:space="preserve">
          <source>removeAll( ['Chad', 132, undefined] ) &amp;mdash; Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</source>
          <target state="translated">removeAll (['Chad', 132, undefined]) - удаляет все значения, которые равны 'Chad', 123 или undefined, и возвращает их в виде массива.</target>
        </trans-unit>
        <trans-unit id="cc7eba478a0fbf207e7ee5a77ca70f0bbffef7c8" translate="yes" xml:space="preserve">
          <source>removeAll() &amp;mdash; Removes all values and returns them as an array.</source>
          <target state="translated">removeAll () - удаляет все значения и возвращает их в виде массива.</target>
        </trans-unit>
        <trans-unit id="a3c46952e7fa1e806af3072725a0a18fe8a7a8d2" translate="yes" xml:space="preserve">
          <source>replace( oldItem, newItem ) &amp;mdash; Replaces the first value that equals oldItem with newItem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240cc955cee05a65ec8631352200efd2449f3e17" translate="yes" xml:space="preserve">
          <source>replace, remove and removeAll</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0478604d4aea96fd3a393109a2b1037b3e927fd" translate="yes" xml:space="preserve">
          <source>reverse() &amp;mdash; Reverses the order of the array and returns the observableArray (not the underlying array).</source>
          <target state="translated">reverse () - меняет порядок массива на обратный и возвращает observableArray (не базовый массив).</target>
        </trans-unit>
        <trans-unit id="c221784f0945c6f78a753619cc5ddf314594c065" translate="yes" xml:space="preserve">
          <source>reversed() &amp;mdash; Returns a reversed &lt;strong&gt;copy&lt;/strong&gt; of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f2d78389675b86fdc3ff8aa20480298ed96edf" translate="yes" xml:space="preserve">
          <source>scripts/appViewModel.js</source>
          <target state="translated">scripts/appViewModel.js</target>
        </trans-unit>
        <trans-unit id="3d86e3a05ce2d4beabae39286b9e1f21797e0cc4" translate="yes" xml:space="preserve">
          <source>scripts/init.js</source>
          <target state="translated">scripts/init.js</target>
        </trans-unit>
        <trans-unit id="8ca245bc231e1ea924af9ce333849af65afcced1" translate="yes" xml:space="preserve">
          <source>selectedOptions</source>
          <target state="translated">selectedOptions</target>
        </trans-unit>
        <trans-unit id="0cc4bc27e43d8c540c56bb29619529b32d7e1d78" translate="yes" xml:space="preserve">
          <source>selectedOptions binding</source>
          <target state="translated">selectOptions привязка опционов</target>
        </trans-unit>
        <trans-unit id="c1de595d71ffb6e5bfd55b59347f3a99defa5aa3" translate="yes" xml:space="preserve">
          <source>setInterval callbacks will continue to fire until explicitly cleared.</source>
          <target state="translated">setInterval callbacks будут продолжать срабатывать до тех пор,пока не будут явно очищены.</target>
        </trans-unit>
        <trans-unit id="0e0977525af7bb738c2d7f294371eb114a5f9172" translate="yes" xml:space="preserve">
          <source>shift() &amp;mdash; Removes the first value from the array and returns it.</source>
          <target state="translated">shift () - удаляет первое значение из массива и возвращает его.</target>
        </trans-unit>
        <trans-unit id="88fbb170c082bb72bb147471c70547512b13611a" translate="yes" xml:space="preserve">
          <source>simpleExpression</source>
          <target state="translated">simpleExpression</target>
        </trans-unit>
        <trans-unit id="88f11ced9c5850c42b7ad4f6655dbd9d58dbd3c2" translate="yes" xml:space="preserve">
          <source>simpleObservable</source>
          <target state="translated">simpleObservable</target>
        </trans-unit>
        <trans-unit id="0a5228e66df38e2f27ca61b901edf86f7ef97fb8" translate="yes" xml:space="preserve">
          <source>slice</source>
          <target state="translated">slice</target>
        </trans-unit>
        <trans-unit id="56ab5e4c42113718cabb807a70d36218e826aaf4" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray.</source>
          <target state="translated">sort () - сортирует содержимое массива и возвращает observableArray.</target>
        </trans-unit>
        <trans-unit id="02dfee61ca9f2a129d89bd0f0818fbde5bd7aea7" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray. The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. See the example under sorted below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7434a175cdd232131e04992fb56ac2855b98e7ec" translate="yes" xml:space="preserve">
          <source>sorted and reversed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7feaeaf39776332d680a2cd5ff36dccfebdd345d" translate="yes" xml:space="preserve">
          <source>sorted() &amp;mdash; Returns a sorted &lt;strong&gt;copy&lt;/strong&gt; of the array. This is preferable to sort if you want to leave the observable array in its original order but need to display it in a specific order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08689664c7819b1ab9daec145c9c6a25661021b" translate="yes" xml:space="preserve">
          <source>spectate &amp;mdash; Whenever the computed observable &lt;strong&gt;records&lt;/strong&gt; a change to its value, even while sleeping, it notifies a spectate event with the new value. (The spectate event applies to any type of observable but is generally most useful for pure computed observables.) This event allows you to track the current value of the observable without affecting its sleeping/waking state. Also note that when using rate-limiting or deferred updates, the &amp;ldquo;spectated&amp;rdquo; values might include intermediate values that aren&amp;rsquo;t captured by change notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b90ae0a8b7cade6771bd136b879de650e1c97a" translate="yes" xml:space="preserve">
          <source>splice() &amp;mdash; Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</source>
          <target state="translated">splice () - удаляет и возвращает заданное количество элементов, начиная с заданного индекса. Например, myObservableArray.splice (1, 3) удаляет три элемента, начиная с позиции индекса 1 (т. Е. 2-й, 3-й и 4-й элементы), и возвращает их в виде массива.</target>
        </trans-unit>
        <trans-unit id="6253e860960f6bbaedffe4b667c89e216110d409" translate="yes" xml:space="preserve">
          <source>style binding</source>
          <target state="translated">стилевой переплёт</target>
        </trans-unit>
        <trans-unit id="8779e91de4557c0e390ed1fb33b2e709310a78a8" translate="yes" xml:space="preserve">
          <source>submit binding</source>
          <target state="translated">обязательность представления</target>
        </trans-unit>
        <trans-unit id="820fbe076d0fd7d9855c3332a110247db7d06ef6" translate="yes" xml:space="preserve">
          <source>subscribe( callback [,callbackTarget, event] ) &amp;mdash; Registers a &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;manual subscription&lt;/a&gt; to be notified of changes to the computed observable.</source>
          <target state="translated">subscribe (callback [, callbackTarget, event]) - регистрирует &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;ручную подписку,&lt;/a&gt; чтобы получать уведомления об изменениях в вычисляемой наблюдаемой.</target>
        </trans-unit>
        <trans-unit id="dafd82441d770fee53da532cf0cc778383385fe6" translate="yes" xml:space="preserve">
          <source>targetObject &amp;mdash; If given, defines the value of this whenever KO invokes your callback functions. See the section on &lt;a href=&quot;computedobservables#managing-this&quot;&gt;managing this&lt;/a&gt; for more information.</source>
          <target state="translated">targetObject - если задано, определяет значение this всякий раз, когда KO вызывает ваши функции обратного вызова. См. Раздел об &lt;a href=&quot;computedobservables#managing-this&quot;&gt;управлении этим&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3c94ad78a19fe31d36596c68497f86eec7b1c3d9" translate="yes" xml:space="preserve">
          <source>template - &lt;strong&gt;Required.&lt;/strong&gt; An array of DOM nodes</source>
          <target state="translated">шаблон - &lt;strong&gt;обязательно. &lt;/strong&gt;Массив узлов DOM</target>
        </trans-unit>
        <trans-unit id="253d1a2eda05db9287d0590f7c3d7acab99953a0" translate="yes" xml:space="preserve">
          <source>template binding</source>
          <target state="translated">привязка шаблона</target>
        </trans-unit>
        <trans-unit id="6e4853d9a9512e127ea4b62e7f52af33fc271c3f" translate="yes" xml:space="preserve">
          <source>template is required, and can take any of &lt;a href=&quot;#specifying-a-template&quot;&gt;the template formats described below&lt;/a&gt;.</source>
          <target state="translated">шаблон является обязательным и может принимать любой из &lt;a href=&quot;#specifying-a-template&quot;&gt;форматов шаблонов, описанных ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da65429399cce754285fdbcec2552149cb86a956" translate="yes" xml:space="preserve">
          <source>text binding</source>
          <target state="translated">связывание текста</target>
        </trans-unit>
        <trans-unit id="adf56df0f3eb83ef4e28a07bf6ef6a5225f02b82" translate="yes" xml:space="preserve">
          <source>textInput binding</source>
          <target state="translated">текстовая привязка</target>
        </trans-unit>
        <trans-unit id="b2b2c593b67fd9c750a7b4dc7bc74905c48586e7" translate="yes" xml:space="preserve">
          <source>uniqueName binding</source>
          <target state="translated">связывание уникальных имен</target>
        </trans-unit>
        <trans-unit id="c16c416b43e2a2e26766a7d93713d6642892d606" translate="yes" xml:space="preserve">
          <source>unshift( value ) &amp;mdash; Inserts a new item at the beginning of the array.</source>
          <target state="translated">unshift (значение) - вставляет новый элемент в начало массива.</target>
        </trans-unit>
        <trans-unit id="69376c529d40f826b3d0595aee8c136c0af54867" translate="yes" xml:space="preserve">
          <source>value binding</source>
          <target state="translated">привязка стоимости</target>
        </trans-unit>
        <trans-unit id="e7253474b4d3ffd33c594b51d8119d43a0bb6bba" translate="yes" xml:space="preserve">
          <source>value, by default, only updates your model when the user moves focus out of the text box. textInput updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don&amp;rsquo;t necessarily raise any focus change events).</source>
          <target state="translated">value по умолчанию обновляет вашу модель только тогда, когда пользователь перемещает фокус из текстового поля. textInput немедленно обновляет вашу модель при каждом нажатии клавиши или другом механизме ввода текста (например, вырезании или перетаскивании текста, которые не обязательно вызывают какие-либо события изменения фокуса).</target>
        </trans-unit>
        <trans-unit id="0315000a3f53e1c0a46b78819975a5d6ad678ede" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string).</source>
          <target state="translated">value:синтаксис,связанный со значением привязки до того,как Knockout попытается его разобрать (например,для вашегоBinding:1+1,связанное с ним значение &quot;1+1&quot; в виде строки).</target>
        </trans-unit>
        <trans-unit id="c0028d499648445b972232716f7a0d90be688c64" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string). If the binding was given without a value, this will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6bf64e230167a81d331f0e53be657f29268a03" translate="yes" xml:space="preserve">
          <source>valueAccessor &amp;mdash; A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value.</source>
          <target state="translated">valueAccessor - функция JavaScript, которую можно вызвать для получения текущего свойства модели, участвующего в этой привязке. Вызовите это без передачи каких-либо параметров (например, вызовите valueAccessor ()), чтобы получить текущее значение свойства модели. Чтобы легко принимать как наблюдаемые, так и простые значения, вызовите ko.unwrap для возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="09d6bee9bf5ab035edcf3bdb1c2d3ca252cab50d" translate="yes" xml:space="preserve">
          <source>valueAllowUnset</source>
          <target state="translated">valueAllowUnset</target>
        </trans-unit>
        <trans-unit id="3b9eeb08f6cc0027bfae1d6ae33f6eec82fa4980" translate="yes" xml:space="preserve">
          <source>valueUpdate</source>
          <target state="translated">valueUpdate</target>
        </trans-unit>
        <trans-unit id="85d24d98408f285817ccc63b116e75becf9bfb63" translate="yes" xml:space="preserve">
          <source>viewModel &amp;mdash; This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.</source>
          <target state="translated">viewModel - этот параметр устарел в Knockout 3.x. Вместо этого используйте bindingContext. $ Data или bindingContext. $ RawData для доступа к модели представления.</target>
        </trans-unit>
        <trans-unit id="7d9112700ef264af454bd57cf55fc6e70b23ecbc" translate="yes" xml:space="preserve">
          <source>viewModel is optional, and can take any of &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;the viewModel formats described below&lt;/a&gt;.</source>
          <target state="translated">viewModel является необязательным и может принимать любой из &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;форматов viewModel, описанных ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7eea042fe202adb1f0ad66ed57626d9b9dcd238a" translate="yes" xml:space="preserve">
          <source>visible binding</source>
          <target state="translated">видимый переплёт</target>
        </trans-unit>
        <trans-unit id="012cd28b54d4dcfd92ef8c4dccc2bb3476547a20" translate="yes" xml:space="preserve">
          <source>with binding</source>
          <target state="translated">с обязательным условием</target>
        </trans-unit>
        <trans-unit id="342fd4ebade4bf72ed7582148a5b0cdbca608bfe" translate="yes" xml:space="preserve">
          <source>write &amp;mdash; Optional. If given, makes the computed observable &lt;em&gt;writable&lt;/em&gt;. This is a function that receives values that other code is trying to write to your computed observable. It&amp;rsquo;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</source>
          <target state="translated">написать - Необязательно. Если задано, делает вычисляемую наблюдаемую &lt;em&gt;доступной для записи&lt;/em&gt; . Это функция, которая получает значения, которые другой код пытается записать в вычисляемую наблюдаемую. Вы должны предоставить настраиваемую логику для обработки входящих значений, обычно путем записи значений в некоторые базовые наблюдаемые объекты.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
