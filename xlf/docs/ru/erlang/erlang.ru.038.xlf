<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="269d02430fd6e138cda2800d0af71fa652dd1cf5" translate="yes" xml:space="preserve">
          <source>The ability to globally register names is a central concept in the programming of distributed Erlang systems. In this module, the equivalent of the &lt;code&gt;register/2&lt;/code&gt; and &lt;code&gt;whereis/1&lt;/code&gt; BIFs (for local name registration) are provided, but for a network of Erlang nodes. A registered name is an alias for a process identifier (pid). The global name server monitors globally registered pids. If a process terminates, the name is also globally unregistered.</source>
          <target state="translated">Возможность глобальной регистрации имен - центральная концепция в программировании распределенных систем Erlang. В этом модуле предоставляется эквивалент &lt;code&gt;register/2&lt;/code&gt; и &lt;code&gt;whereis/1&lt;/code&gt; (для регистрации локального имени), но для сети узлов Erlang. Зарегистрированное имя - это псевдоним для идентификатора процесса (pid). Глобальный сервер имен отслеживает глобально зарегистрированные pid. Если процесс завершается, имя также глобально не регистрируется.</target>
        </trans-unit>
        <trans-unit id="2cc8577a293410d9b2b2308f91ef8c7aeb7972a3" translate="yes" xml:space="preserve">
          <source>The ability to have nested transaction with identical semantics as top-level transaction makes it easier to write library functions that manipulate &lt;code&gt;Mnesia&lt;/code&gt; tables.</source>
          <target state="translated">Возможность иметь вложенную транзакцию с семантикой, идентичной транзакции верхнего уровня, упрощает написание библиотечных функций, управляющих таблицами &lt;code&gt;Mnesia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3f3d904255147f868f9a9b898334b0ed05f68e" translate="yes" xml:space="preserve">
          <source>The ability to prepare several modules in parallel is not currently used as almost all code loading is serialized by the code_server process. The BIF interface is however prepared for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a04008ab968f22c43827dcb1f3ef8218af459a" translate="yes" xml:space="preserve">
          <source>The ability to reconfigure the system without stopping or suspending it.</source>
          <target state="translated">Возможность перенастройки системы без ее остановки или приостановки.</target>
        </trans-unit>
        <trans-unit id="129e9c30a42ceaac73e62bd0dcc82cdd40af7c03" translate="yes" xml:space="preserve">
          <source>The above commands give a bit more information than the exact answers, but adequate information when manually searching for answers to these questions.</source>
          <target state="translated">Вышеприведенные команды дают немного больше информации,чем точные ответы,но адекватную информацию при ручном поиске ответов на эти вопросы.</target>
        </trans-unit>
        <trans-unit id="f248f43bea4cac68bcba54c041edea09e4c2df08" translate="yes" xml:space="preserve">
          <source>The above described implementation more or less minimizes the comunication needed before we can increment the global counter. The amount of communication in the system due to the thread progress functionality however also depend on the frequency with which managed threads call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt;. Today each scheduler thread calls &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; more or less each time an Erlang process is scheduled out. One way of further reducing communication due to the thread progress functionality is to only call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; every second, or third time an Erlang process is scheduled out, or even less frequently than that. However, by doing updates of thread progress less frequently all operations depending on the thread progress functionality will also take a longer time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa2af3e34f5b33ee6c40efa2f89e63edd11857b" translate="yes" xml:space="preserve">
          <source>The above describes how it works if the configuration parameter &lt;code&gt;&lt;a href=&quot;#memsup_improved_system_memory_data&quot;&gt;memsup_improved_system_memory_data&lt;/a&gt;&lt;/code&gt; has been set to &lt;code&gt;false&lt;/code&gt; which currently also is the default behavior. If the configuration parameter is set to &lt;code&gt;true&lt;/code&gt; the behavior is slightly changed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b0784fdfa3b2b86ccd9506530ebe25156cc75c" translate="yes" xml:space="preserve">
          <source>The above domains are used for logs originating from Erlang/OTP. D1 specifies that the log event comes from Erlang/OTP in general, and D2 indicates that the log event is a so called &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутые домены используются для журналов, происходящих из Erlang / OTP. D1 указывает, что событие журнала исходит из Erlang / OTP в целом, а D2 указывает, что событие журнала является так называемым &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ad528c9654cb6b91e6a15396b85e360c22694a9" translate="yes" xml:space="preserve">
          <source>The above function specification uses multiple occurrences of the same type variable. That provides more type information than the following function specification, where the type variables are missing:</source>
          <target state="translated">В приведенной выше спецификации функции используется несколько вхождений одной и той же переменной типа.Это дает больше информации о типе,чем следующая спецификация функции,в которой переменные типа отсутствуют:</target>
        </trans-unit>
        <trans-unit id="6b3999c12af345ea4567453a651d6ad765544220" translate="yes" xml:space="preserve">
          <source>The above line will create a &lt;code&gt;TAGS&lt;/code&gt; file covering all the Erlang source files in the current directory, and in the subdirectories below.</source>
          <target state="translated">Вышеупомянутая строка создаст файл &lt;code&gt;TAGS&lt;/code&gt; , охватывающий все исходные файлы Erlang в текущем каталоге и в подкаталогах ниже.</target>
        </trans-unit>
        <trans-unit id="e341eaf056f6757aa8744bf39e8ccfa82e2460c2" translate="yes" xml:space="preserve">
          <source>The above problem can also be solved as follows:</source>
          <target state="translated">Вышеуказанная проблема также может быть решена следующим образом:</target>
        </trans-unit>
        <trans-unit id="492aee09cf585dc36dd1c47f1f73ebd941b86f64" translate="yes" xml:space="preserve">
          <source>The above publications can be found at &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутые публикации можно найти на &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90d7bded58b14f2f3322b876d40236b0a107f3e" translate="yes" xml:space="preserve">
          <source>The above publications can be found at &lt;code&gt;&lt;a href=&quot;https://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbb531e49f3781328d131d1418c3fc6c34074de" translate="yes" xml:space="preserve">
          <source>The above requirements makes the private task data structure a rather complex data structure. It has a queue of unprocessed tasks, and a busy queue. The busy queue contains blocked tasks corresponding to &lt;code&gt;command&lt;/code&gt; signals, and tasks with dependencies to such tasks. The busy queue is accompanied by a table over blocked tasks based on sender with a references into last task in the busy queue from a specific sender. This since we need check for dependencies when new tasks are processed in the queue of unprocessed tasks. When a new task is processed that needs to be blocked it isn't enqueued at the end of the busy queue, but instead directly after the last task with the same sender. This in order to easily be able to detect when we have tasks that no longer have any dependencies to tasks corresponding to &lt;code&gt;command&lt;/code&gt; signals which should be moved out of the busy queue. When the port executes, it switches between processing tasks from the busy queue, and processing directly from the unprocessed queue based on its busy state. When processing directly from the unprocessed queue it might, of course, have to move a task into the busy queue instead of executing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1f97ecba7e65750e03299b0da63791177dd464" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt; Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425de3e4a3c3f31918aace8062226e8cca18ed8a" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Приведенное выше возвращаемое значение и вывод после вызова &lt;code&gt;release_handler:install_release/1&lt;/code&gt; означает, что &lt;code&gt;release_handler&lt;/code&gt; перезапустил узел, используя &lt;code&gt;heart&lt;/code&gt; . Это всегда выполняется, если обновление связано с изменением приложений ERTS, Kernel, STDLIB или SASL. Для получения дополнительной информации см. &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7341074eb758fc408da665455635aa8abe3e6546" translate="yes" xml:space="preserve">
          <source>The above sequence did only describe adding a new breakpoint. We do basically the same sequence to update the settings of an existing breakpoint except step 2,3 and 6 can be skipped as it has already been done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d29da5725e5abb5aa97c7b81d06a71c4261fa3" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of memory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782b35684c4c327f6b3806c4707f7ff71cfb9ed8" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of mmeory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="translated">Вышеупомянутый слоган - одна из наиболее частых причин прекращения работы Erlang. По неизвестным причинам системе времени выполнения Erlang не удалось выделить память для использования. Когда это происходит, создается аварийный дамп, содержащий информацию о состоянии системы, когда в ней закончилась память. Используйте &lt;code&gt;crashdump_viewer&lt;/code&gt; , чтобы получить представление об используемой памяти. Ищите процессы с большими кучами или множеством сообщений, большими таблицами ets и т. Д.</target>
        </trans-unit>
        <trans-unit id="a934d4536371eb6354c38319c0a6fa99eadfdfc1" translate="yes" xml:space="preserve">
          <source>The absence of warnings does not mean that there are no remaining errors in the code.</source>
          <target state="translated">Отсутствие предупреждений не означает,что в коде не осталось ошибок.</target>
        </trans-unit>
        <trans-unit id="52e22f3960de9276ce93c1885ad7150854270f91" translate="yes" xml:space="preserve">
          <source>The absolute path of directory &lt;code&gt;chat_server/ebin&lt;/code&gt; is here passed to the code server. This is essential because relative paths are stored by the code server as relative, and &lt;code&gt;Common Test&lt;/code&gt; changes the current working directory of ERTS during the test run.</source>
          <target state="translated">Здесь серверу кода передается абсолютный путь к каталогу &lt;code&gt;chat_server/ebin&lt;/code&gt; . Это важно, потому что относительные пути сохраняются сервером кода как относительные, а &lt;code&gt;Common Test&lt;/code&gt; изменяет текущий рабочий каталог ERTS во время выполнения теста.</target>
        </trans-unit>
        <trans-unit id="30fdf1cb46294b863f8e4eaed5259c72435c637c" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt; erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt; erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5539aa6980c3b1d4dc664f3e80f8e7768512fe3a" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="translated">Абсолютный момент времени, по истечении которого таймер установлен, должен находиться в интервале &lt;code&gt;[&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; . Если указано относительное время, значение &lt;code&gt;Time&lt;/code&gt; не может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="e18029dc4fbc0a03d56e79bb7184953e3744a063" translate="yes" xml:space="preserve">
          <source>The abstract layer (defined in &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;) is nicely structured and the node types are context-independent. The layer makes it possible to transparently attach source-code comments and user annotations to nodes of the tree. Using the abstract layer makes applications less sensitive to changes in the &lt;code&gt;erl_parse(3)&lt;/code&gt; data structures, only requiring the &lt;code&gt;erl_syntax&lt;/code&gt; module to be up-to-date.</source>
          <target state="translated">Абстрактный уровень (определенный в &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; ) хорошо структурирован, а типы узлов не зависят от контекста. Слой позволяет прозрачно прикреплять комментарии исходного кода и пользовательские аннотации к узлам дерева. Использование абстрактного уровня делает приложения менее чувствительными к изменениям в структурах данных &lt;code&gt;erl_parse(3)&lt;/code&gt; , требуя только &lt;code&gt;erl_syntax&lt;/code&gt; модуля erl_syntax .</target>
        </trans-unit>
        <trans-unit id="56d4f99e44e9cb3cc0a8743c790ec2277cddaac6" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebbf813506aec9cb5b7febd24547c187a92185e" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Принятый сокет наследует параметры, установленные для &lt;code&gt;ListenSocket&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c1f48a70d3a03fcd08b9ecaf840df566c82062" translate="yes" xml:space="preserve">
          <source>The ack_action() is either:</source>
          <target state="translated">И функция ack_action()тоже:</target>
        </trans-unit>
        <trans-unit id="4df5499b046a3caa5c00b3bf34cda3b59c95dee6" translate="yes" xml:space="preserve">
          <source>The ack_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">Аргументом функции ack_data()является термин Erlang,возвращаемый handle_trans_request/3.</target>
        </trans-unit>
        <trans-unit id="573fc48700bb83712fa26ae3db5f4a997f5bdf7a" translate="yes" xml:space="preserve">
          <source>The action to take when the Erlang emulator stops unexpectedly. Default is to ignore.</source>
          <target state="translated">Действие,которое необходимо предпринять,когда эмулятор Эрланга неожиданно останавливается.По умолчанию-игнорировать.</target>
        </trans-unit>
        <trans-unit id="0321983ca2ab7b420ed8780bad63ee4e244c660a" translate="yes" xml:space="preserve">
          <source>The actual behavior of compiled match specifications when recreated from external format has changed and may change in future releases, but this interface remains for backward compatibility. See &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fdcbc6206b95ef9655638b626a5128e3d5dc2c" translate="yes" xml:space="preserve">
          <source>The actual encoded messages have been collected in one directory per encoding type, containing one file per encoded message.</source>
          <target state="translated">Реальные закодированные сообщения собраны в одной директории на каждый тип кодировки,содержащей по одному файлу на каждое закодированное сообщение.</target>
        </trans-unit>
        <trans-unit id="1c694608beedd90d5cb7943b28c1a84362940fa0" translate="yes" xml:space="preserve">
          <source>The actual encryption or decryption is done by &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fed2c92bea1fa55e85c9f8695c1f69a2c7262b" translate="yes" xml:space="preserve">
          <source>The actual implementation of instructions are also defined in &lt;code&gt;.tab&lt;/code&gt; files processed by &lt;strong&gt;beam_makeops&lt;/strong&gt;. For practical reasons, instruction definitions are stored in several files, at the time of writing in the following files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf119f15e4a3e4c9e43ba3da03845ee142277be" translate="yes" xml:space="preserve">
          <source>The actual message returned by the RPC server is a 2-tuple &lt;code&gt;{rex,Reply}&lt;/code&gt;. If you use &lt;code&gt;erl_rpc_from()&lt;/code&gt; in your code, this is the message you will need to parse. If you use &lt;code&gt;erl_rpc()&lt;/code&gt;, the tuple itself is parsed for you, and the message returned to your program is the Erlang term containing &lt;code&gt;Reply&lt;/code&gt; only. Replies to RPC requests are always &lt;code&gt;ERL_SEND&lt;/code&gt; messages.</source>
          <target state="translated">Фактическое сообщение, возвращаемое сервером RPC, представляет собой кортеж из двух частей &lt;code&gt;{rex,Reply}&lt;/code&gt; . Если вы используете в своем коде &lt;code&gt;erl_rpc_from()&lt;/code&gt; , это сообщение вам нужно будет проанализировать. Если вы используете &lt;code&gt;erl_rpc()&lt;/code&gt; , сам кортеж анализируется для вас, и сообщение, возвращаемое вашей программе, является термином Erlang, содержащим только &lt;code&gt;Reply&lt;/code&gt; . Ответы на запросы RPC всегда &lt;code&gt;ERL_SEND&lt;/code&gt; сообщениями ERL_SEND .</target>
        </trans-unit>
        <trans-unit id="3f712073d78ceb80ba4691c57506456b575aeca2" translate="yes" xml:space="preserve">
          <source>The actual number of fragments</source>
          <target state="translated">Фактическое количество фрагментов</target>
        </trans-unit>
        <trans-unit id="605930eb2c9eb4fbbdc869cc2d2017c67143a7b6" translate="yes" xml:space="preserve">
          <source>The actual padding is performed by &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4322cef184ec5aecf9faa18423df4ee550bc1ca0" translate="yes" xml:space="preserve">
          <source>The actual supervision of execution times is in itself a CPU intensive activity. A message is written on the trace file for every function call that is made by the profiled code.</source>
          <target state="translated">Фактический контроль времени исполнения сам по себе является интенсивной процессорной деятельностью.Для каждого вызова функции,который производится по профилированному коду,в файле трассировки записывается сообщение.</target>
        </trans-unit>
        <trans-unit id="d6518471a4a1665322d5954e6611844bc734d8cd" translate="yes" xml:space="preserve">
          <source>The actual supported algorithms and features depends on their availability in the actual libcrypto used. See the &lt;code&gt;crypto (App)&lt;/code&gt; about dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a53d335d6385335f1d9907f4b8a879470a71f4" translate="yes" xml:space="preserve">
          <source>The actual supported named curves could be checked by examining the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(curves)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3571545f798bc55c8050de98e521a38384a9d2" translate="yes" xml:space="preserve">
          <source>The actual timer time.</source>
          <target state="translated">Фактическое время таймера.</target>
        </trans-unit>
        <trans-unit id="27345ee3cabb8f446fd8fd55e223fda324b5bab0" translate="yes" xml:space="preserve">
          <source>The actual value is the quoted atom &lt;code&gt;'NULL'&lt;/code&gt;.</source>
          <target state="translated">Фактическое значение - это атом &lt;code&gt;'NULL'&lt;/code&gt; в кавычках .</target>
        </trans-unit>
        <trans-unit id="c72f4263f7e8c1e5785af3ae16a212b694d638c6" translate="yes" xml:space="preserve">
          <source>The address and port of the other end of the connection.</source>
          <target state="translated">Адрес и порт другого конца соединения.</target>
        </trans-unit>
        <trans-unit id="5ae3afdabf8d69b7f030903f34729a4d0a97bc17" translate="yes" xml:space="preserve">
          <source>The address must be the IP address and cannot be the hostname.</source>
          <target state="translated">Адрес должен быть IP-адресом и не может быть именем хоста.</target>
        </trans-unit>
        <trans-unit id="45c66a6604fd97ae44d5625424f5836d3c3179c8" translate="yes" xml:space="preserve">
          <source>The address of the fun's code when HiPE is enabled.</source>
          <target state="translated">Адрес кода веселья,когда HiPE включен.</target>
        </trans-unit>
        <trans-unit id="7ddf5f9487a859a28b6ed4d37dd3d9bebe9f2f6a" translate="yes" xml:space="preserve">
          <source>The address of the fun's code.</source>
          <target state="translated">Адрес кода веселья.</target>
        </trans-unit>
        <trans-unit id="7e8bf572fd0f0bc243c5923805f5fb20ef2fe37e" translate="yes" xml:space="preserve">
          <source>The address specified in &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; overwrites the primary peer address</source>
          <target state="translated">Адрес, указанный в &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; , перезаписывает адрес основного партнера.</target>
        </trans-unit>
        <trans-unit id="ba449fc5f30a23d575fa4c4396e275fa504dce46" translate="yes" xml:space="preserve">
          <source>The adjustment of system time could have been made smother than using a time warp approach, but we think that would be a bad choice. As we can express and measure time that is not connected to calendar time by the use of Erlang monotonic time, it is better to expose the change in Erlang system time immediately. This as the Erlang applications executing on the system can react on the change in system time as soon as possible. This is also more or less exactly how most operating systems handle this (OS monotonic time and OS system time). By adjusting system time smoothly, we would just hide the fact that system time changed and make it harder for the Erlang applications to react to the change in a sensible way.</source>
          <target state="translated">Корректировка системного времени могла бы быть сделана глубже,чем использование подхода на основе искривления времени,но мы думаем,что это было бы плохим выбором.Так как мы можем выразить и измерить время,которое не связано с календарным временем с помощью монотонного времени Эрланга,то лучше сразу же разоблачить изменение системного времени Эрланга.Так как приложения на Эрланге,выполняемые в системе,могут реагировать на изменение системного времени как можно быстрее.Это также более или менее точно,как большинство операционных систем справляются с этим (монотонное время ОС и системное время ОС).Плавно регулируя системное время,мы просто скрываем тот факт,что системное время изменилось,и усложняем для приложений на Эрланге реакцию на изменение разумным образом.</target>
        </trans-unit>
        <trans-unit id="5f9472dc1436a5862ca0454404828318f9e56d1f" translate="yes" xml:space="preserve">
          <source>The advantage of using an extensible (agent/manager) toolkit is to remove details such as type-checking, access rights, Protocol Data Unit (PDU), encoding, decoding, and trap distribution from the programmer, who only has to write the instrumentation functions, which implement the MIBs. The &lt;code&gt;get-next&lt;/code&gt; function only has to be implemented for tables, and not for every variable in the global naming tree. This information can be deduced from the ASN.1 file.</source>
          <target state="translated">Преимущество использования расширяемого инструментария (агент / менеджер) заключается в удалении таких деталей, как проверка типов, права доступа, блок данных протокола (PDU), кодирование, декодирование и распределение ловушек, от программиста, которому нужно только написать инструментарий функции, реализующие MIB. Функция &lt;code&gt;get-next&lt;/code&gt; должна быть реализована только для таблиц, а не для каждой переменной в глобальном дереве имен. Эта информация может быть получена из файла ASN.1.</target>
        </trans-unit>
        <trans-unit id="9fe8e4ddaca688413966f57d082a8c9a7e076fe3" translate="yes" xml:space="preserve">
          <source>The advantages of separating the table coordinator from the SNMP tool are:</source>
          <target state="translated">Преимущества отделения координатора таблицы от инструмента SNMP заключаются в следующем:</target>
        </trans-unit>
        <trans-unit id="1e3ed41d7fd39c63d6b7f432ea91d01107779b41" translate="yes" xml:space="preserve">
          <source>The affected tables are write-locked during the restoration. However, regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</source>
          <target state="translated">Пораженные таблицы блокируются во время восстановления.Однако,независимо от вызванных этим конфликтов блокировок,приложения могут продолжать выполнять свою работу во время восстановления.Восстановление осуществляется как одна единственная транзакция.</target>
        </trans-unit>
        <trans-unit id="eeb577e64047dee54287b4297431d9c8f5676c03" translate="yes" xml:space="preserve">
          <source>The age is defined in milliseconds.</source>
          <target state="translated">Возраст определяется в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="e7020aa85de45cdbfd0f6571b7cc03a6fded1bbd" translate="yes" xml:space="preserve">
          <source>The agent and manager uses (application) configuration parameters to find out where these directories are located. The parameters should be defined in an Erlang system configuration file. The following configuration parameters are defined for the SNMP application:</source>
          <target state="translated">Агент и менеджер используют параметры конфигурации (приложения),чтобы выяснить,где находятся эти каталоги.Параметры должны быть определены в конфигурационном файле системы Erlang.Для приложения SNMP определены следующие параметры конфигурации:</target>
        </trans-unit>
        <trans-unit id="532498afa1ab407c6e18b6c76c06f1a8f9021335" translate="yes" xml:space="preserve">
          <source>The agent can be configured to be multi-threaded, to process one incoming request at a time, or to have a request limit enabled (this can be used for load control or to limit the effect of DoS attacks). If it is multi-threaded, read requests (&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and &lt;code&gt;get-bulk&lt;/code&gt;) and traps are processed in parallel with each other and &lt;code&gt;set&lt;/code&gt; requests. However, all &lt;code&gt;set&lt;/code&gt; requests are serialized, which means that if the agent is waiting for the application to complete a complicated write operation, it will not process any new write requests until this operation is finished. It processes read requests and sends traps, concurrently. The reason for not handle write requests in parallel is that a complex locking mechanism would be needed even in the simplest cases. Even with the scheme described above, the user must be careful not to violate that the &lt;code&gt;set&lt;/code&gt; requests are atoms. If this is hard to do, do not use the multi-threaded feature.</source>
          <target state="translated">Агент может быть настроен для работы в многопоточном режиме, для обработки одного входящего запроса за раз или для включения ограничения количества запросов (это можно использовать для управления нагрузкой или для ограничения эффекта DoS-атак). Если он многопоточный, запросы на чтение ( &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;get-next&lt;/code&gt; и &lt;code&gt;get-bulk&lt;/code&gt; ) и ловушки обрабатываются параллельно друг другу и &lt;code&gt;set&lt;/code&gt; запросы. Однако все &lt;code&gt;set&lt;/code&gt; запросы сериализуются, что означает, что если агент ожидает, пока приложение завершит сложную операцию записи, он не будет обрабатывать новые запросы на запись, пока эта операция не будет завершена. Он одновременно обрабатывает запросы на чтение и отправляет прерывания. Причина, по которой запросы на запись не обрабатываются параллельно, заключается в том, что даже в простейших случаях потребуется сложный механизм блокировки. Даже при описанной выше схеме пользователь должен быть осторожен, чтобы не нарушить, что &lt;code&gt;set&lt;/code&gt; запросы являются атомами. Если это сложно сделать, не используйте многопоточную функцию.</target>
        </trans-unit>
        <trans-unit id="1765275ae72c3c73846eb96f701861af075a2ade" translate="yes" xml:space="preserve">
          <source>The agent can both perform and respond to discovery.</source>
          <target state="translated">Агент может как выполнять,так и реагировать на обнаружение.</target>
        </trans-unit>
        <trans-unit id="5fab26e9897ff23218adb34fca8afc8ac6df806b" translate="yes" xml:space="preserve">
          <source>The agent can spontaneously send a notification, for example, an alarm, to the manager.</source>
          <target state="translated">Агент может спонтанно отправить уведомление,например,сигнал тревоги,менеджеру.</target>
        </trans-unit>
        <trans-unit id="d42efd7983ea3f540eeeb3f75427cd0a119a5f44" translate="yes" xml:space="preserve">
          <source>The agent communication is established through a UNIX domain socket. By default, the socket path will be fetched from the &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; enviroment variable, which is the default socket path in the agent implementation of &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf64ed3192e387b8159a9466a237d0fb9dbdb4e" translate="yes" xml:space="preserve">
          <source>The agent communication is established through a UNIX domain socket. By default, the socket path will be fetched from the &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; enviroment variable, which is the default socket path in the agent implementation of &lt;code&gt;&lt;a href=&quot;https://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e6c01b1d22bf1009d4f112f5ef241f146f87bc" translate="yes" xml:space="preserve">
          <source>The agent does not check complex ranges specified for INTEGER objects. In these cases it just checks that the value lies within the minimum and maximum values specified. For example, if the range is specified as &lt;code&gt;1..10 | 12..20&lt;/code&gt; the agent would let 11 through, but not 0 or 21. The instrumentation functions must check the complex ranges itself.</source>
          <target state="translated">Агент не проверяет сложные диапазоны, указанные для объектов INTEGER. В этих случаях он просто проверяет, находится ли значение в пределах указанного минимального и максимального значений. Например, если диапазон указан как &lt;code&gt;1..10 | 12..20&lt;/code&gt; агент пропустит 11, но не 0 или 21. Инструментальные функции должны сами проверять сложные диапазоны.</target>
        </trans-unit>
        <trans-unit id="821394aba5a85ee9b738eccc0b641e5e87f98f1d" translate="yes" xml:space="preserve">
          <source>The agent information should be stored in a file called &lt;code&gt;agent.conf&lt;/code&gt;.</source>
          <target state="translated">Информация об агенте должна храниться в файле с именем &lt;code&gt;agent.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d5c2b0ecab378b92db71d78b459615c0be2b937" translate="yes" xml:space="preserve">
          <source>The agent is an entity that executes within a &lt;strong&gt;Network Element (NE)&lt;/strong&gt;. In OTP, the NE can be a distributed system, meaning that the distributed system is managed as one entity. Of course, the agent can be configured to be able to run on one of several nodes, making it a distributed OTP application.</source>
          <target state="translated">Агент - это объект, который выполняется в &lt;strong&gt;сетевом элементе (NE)&lt;/strong&gt; . В OTP NE может быть распределенной системой, что означает, что распределенная система управляется как один объект. Конечно, агент можно настроить для работы на одном из нескольких узлов, что делает его распределенным приложением OTP.</target>
        </trans-unit>
        <trans-unit id="b3d395baa2a805befd96447c7ba7e7fb38c483ae" translate="yes" xml:space="preserve">
          <source>The agent is configured with the configuration tool, using default suggestions for everything but the manager node.</source>
          <target state="translated">Агент настраивается с помощью инструмента конфигурации,используя предложения по умолчанию для всего,кроме узла менеджера.</target>
        </trans-unit>
        <trans-unit id="bafc8c1a76725000dfff5c337a6c7efd569cd586" translate="yes" xml:space="preserve">
          <source>The agent is highly fault tolerant. If the manager gets an unexpected response from the agent, it is possible that some instrumentation function has returned an erroneous value. The agent will not crash even if the instrumentation does. It should be noted that if an instrumentation function enters an infinite loop, the agent will also be blocked forever. The supervisor ,or the application, specifies how to restart the agent.</source>
          <target state="translated">Агент очень отказоустойчив.Если менеджер получает неожиданный ответ от агента,возможно,что какая-то функция КИП вернула ошибочное значение.Агент не откажет,даже если это сделает приборная панель.Следует отметить,что если функция контрольно-измерительных приборов входит в бесконечный цикл,то агент также будет заблокирован навсегда.Супервайзер,или приложение,указывает,как перезапустить агента.</target>
        </trans-unit>
        <trans-unit id="2c7ad18cc20a9d278d188273b0ceb93f154abb8c" translate="yes" xml:space="preserve">
          <source>The agent receives a request and maps it to calls to one or more instrumentation functions. These functions perform operations on the resources to implement the semantics associated with the MO.</source>
          <target state="translated">Агент получает запрос и сопоставляет его с вызовами одной или нескольких приборостроительных функций.Эти функции выполняют операции с ресурсами для реализации семантики,связанной с МО.</target>
        </trans-unit>
        <trans-unit id="5394a28e8aa26b89d2b8f393dd3cca2d7c380d89" translate="yes" xml:space="preserve">
          <source>The agent responds to discovery autonomously, without interaction by the user.</source>
          <target state="translated">Агент реагирует на обнаружение автономно,без взаимодействия с пользователем.</target>
        </trans-unit>
        <trans-unit id="ebd412ca77c13dc418b2ee47def2c221adc4c0fa" translate="yes" xml:space="preserve">
          <source>The agent started is called &lt;code&gt;snmp_master_agent&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; to load MIBs into the agent.</source>
          <target state="translated">&lt;code&gt;snmp_master_agent&lt;/code&gt; агент называется snmp_master_agent . Используйте &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; для загрузки MIB в агент.</target>
        </trans-unit>
        <trans-unit id="35fefa07539d964d08302d135b6a045a731feaec" translate="yes" xml:space="preserve">
          <source>The agent stores the values in an internal volatile database, which is based on the standard module &lt;code&gt;ets&lt;/code&gt;. However, it is possible to let the MIB compiler generate functions which use an internal, persistent database, or the Mnesia DBMS. Refer to the Mnesia User Guide and the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for more information.</source>
          <target state="translated">Агент хранит значения во внутренней энергозависимой базе данных, которая основана на стандартном модуле &lt;code&gt;ets&lt;/code&gt; . Однако можно позволить компилятору MIB генерировать функции, которые используют внутреннюю постоянную базу данных или СУБД Mnesia. Дополнительные сведения см. В Руководстве пользователя Mnesia и Справочном руководстве, раздел SNMP, модуль &lt;code&gt;snmp_generic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88cd9d752952f90596dc3746023ba01fb085191a" translate="yes" xml:space="preserve">
          <source>The agent will never generate the &lt;code&gt;wrongEncoding&lt;/code&gt; error. If a variable binding is erroneous encoded, the &lt;code&gt;asn1ParseError&lt;/code&gt; counter will be incremented.</source>
          <target state="translated">Агент никогда не сгенерирует ошибку &lt;code&gt;wrongEncoding&lt;/code&gt; . Если привязка переменной закодирована ошибочно, счетчик &lt;code&gt;asn1ParseError&lt;/code&gt; будет увеличен.</target>
        </trans-unit>
        <trans-unit id="31dc2849b5514caeb8ae4f58e7cc8579c0d02b0d" translate="yes" xml:space="preserve">
          <source>The alarm handler is part of the SASL application.</source>
          <target state="translated">Обработчик сигналов тревоги является частью приложения SASL.</target>
        </trans-unit>
        <trans-unit id="f225b02b835111c249a55da204c91a4c1ca4bd60" translate="yes" xml:space="preserve">
          <source>The alarm handler process is a &lt;code&gt;gen_event&lt;/code&gt; event manager process that receives alarms in the system. This process is not intended to be a complete alarm handler. It defines a place to which alarms can be sent. One simple event handler is installed in the alarm handler at startup, but users are encouraged to write and install their own handlers.</source>
          <target state="translated">Процесс обработчика сигналов тревоги - это &lt;code&gt;gen_event&lt;/code&gt; менеджера событий gen_event, который получает сигналы тревоги в системе. Этот процесс не предназначен для полной обработки аварийных сигналов. Он определяет место, куда могут быть отправлены сигналы тревоги. При запуске в обработчике алармов устанавливается один простой обработчик событий, но пользователям рекомендуется писать и устанавливать свои собственные обработчики.</target>
        </trans-unit>
        <trans-unit id="9a1c34ac82f222f7bf20fdb60c9c70070554269a" translate="yes" xml:space="preserve">
          <source>The alarms are cleared automatically when the alarm cause is no longer valid.</source>
          <target state="translated">Сигналы тревоги автоматически сбрасываются,когда причина тревоги перестает действовать.</target>
        </trans-unit>
        <trans-unit id="986d3b30b24eb7709dfdc0693fd6abc2a7ec4e8c" translate="yes" xml:space="preserve">
          <source>The algorithm for updating &lt;code&gt;Serial&lt;/code&gt; can be described as follows:</source>
          <target state="translated">Алгоритм обновления &lt;code&gt;Serial&lt;/code&gt; можно описать следующим образом:</target>
        </trans-unit>
        <trans-unit id="4dd9a185b05bfc6c5aca5b3488aeb8d588a949ea" translate="yes" xml:space="preserve">
          <source>The algorithm for wich the fun should implement the special matching rules</source>
          <target state="translated">Алгоритм,для которого веселье должно реализовывать специальные правила соответствия</target>
        </trans-unit>
        <trans-unit id="7bb19b504df5c1a9303c7a6f511b1fc2dc8c9766" translate="yes" xml:space="preserve">
          <source>The algorithm in &lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands.</source>
          <target state="translated">Алгоритм в &lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; - md5, чтобы быть совместимым со старыми командами ssh-keygen. Строка из второго варианта предваряется именем алгоритма в верхнем регистре, как в новых командах ssh-keygen.</target>
        </trans-unit>
        <trans-unit id="b2f989a67b5ca0281a96030c126b7a3d77ef6b31" translate="yes" xml:space="preserve">
          <source>The algorithm is a modification of the version attributed to Richard A. O'Keefe in the standard Prolog library.</source>
          <target state="translated">Алгоритм является модификацией версии,приписываемой Ричарду А.О'Кифу в стандартной библиотеке Пролога.</target>
        </trans-unit>
        <trans-unit id="7f680b0d6e8d6f4e75e82db44978468dc45a6e99" translate="yes" xml:space="preserve">
          <source>The algorithm is the same as for send above.</source>
          <target state="translated">Алгоритм такой же,как и для отправки выше.</target>
        </trans-unit>
        <trans-unit id="230091aa46aa0a9b37e9fd8c10519ddfe76dd814" translate="yes" xml:space="preserve">
          <source>The algorithm that is used to draw a graph with as few crossed links as possible is called force graph. A force graph consists of nodes and directed links between nodes. Each node is associated with a repulsive force that pushes nodes away from each other. This force can be adjusted with the left slider or with the mouse wheel. Each link is associated with an attractive force that pulls the nodes nearer to each other. This force can be adjusted with the right slider. If this force becomes too strong, the graph will be unstable. The third parameter that can be adjusted is the length of the links. It is adjusted with the middle slider.</source>
          <target state="translated">Алгоритм,который используется для построения графика с как можно меньшим количеством перекрестных связей,называется силовым графиком.Граф силы состоит из вершин и направленных связей между вершинами.Каждая вершина связана с отталкивающей силой,отталкивающей вершины друг от друга.Эту силу можно регулировать с помощью левого ползунка или колесика мыши.Каждое звено связано с притягательной силой,подталкивающей узлы ближе друг к другу.Это усилие можно регулировать с помощью правого ползунка.Если эта сила станет слишком сильной,график будет нестабильным.Третий параметр,который можно регулировать,-это длина звеньев.Он настраивается ползунком посередине.</target>
        </trans-unit>
        <trans-unit id="e0be3089ed3cdab42290e47bafffab640f5507bb" translate="yes" xml:space="preserve">
          <source>The algorithms should be in the preferred order. Selected signature algorithm can restrict which hash functions that may be selected. Default support for {md5, rsa} removed in ssl-8.0</source>
          <target state="translated">Алгоритмы должны быть в предпочтительном порядке.Выбранный алгоритм подписи может ограничить,какие хэш-функции могут быть выбраны.Поддержка по умолчанию для {md5,rsa}удалена в ssl-8.0.</target>
        </trans-unit>
        <trans-unit id="51bb3389ce8effbbb1e7082b3ae1de9569a30494" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Алгоритмы, указанные в этом параметре, будут приниматься сервером при согласовании алгоритма подписи, введенном в TLS-1.2. Алгоритмы также будут предложены клиенту, если будет запрошен сертификат клиента. Подробнее см. &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e6804a383e502432af39ff151c1928a9f75f02" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#type-client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2fe8210e9b69a3cc07735de1a6330b93954baa" translate="yes" xml:space="preserve">
          <source>The algoritm for modifications works like this:</source>
          <target state="translated">Алгоритм модификации работает вот так:</target>
        </trans-unit>
        <trans-unit id="24adcb7d68961d8f0a870550a960cd9eb67c1117" translate="yes" xml:space="preserve">
          <source>The allocator instance that created a carrier &lt;strong&gt;owns&lt;/strong&gt; it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653b6f4757ea27c31c0c448ccd9f5fac52d31c8d" translate="yes" xml:space="preserve">
          <source>The allocator instance that created a carrier is called its &lt;strong&gt;owner&lt;/strong&gt;. Ownership never changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d1f0815a6d444af90bd4312ec8e5903fa532a8" translate="yes" xml:space="preserve">
          <source>The allocator instance that has the responsibility to perform deallocations in a carrier is called its &lt;strong&gt;employer&lt;/strong&gt;. The employer may also perform allocations if the carrier is not in the pool. Employment may change when a carrier is fetched from or inserted into the pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecacc86ad4cc59e19da91bbb213a08cf8976a29a" translate="yes" xml:space="preserve">
          <source>The allocator instance that uses a carrier &lt;strong&gt;employs&lt;/strong&gt; it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10574335a609a1059aa012db0f86b9ea475e61d4" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Defaults to all &lt;code&gt;alloc_util&lt;/code&gt; allocators.</source>
          <target state="translated">Типы распределителей, в которых будет выполняться поиск. По умолчанию для всех распределителей &lt;code&gt;alloc_util&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7aaf2a06a430d8ee61ee710cc5151971b25f4ab" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Note that blocks can move freely between allocator types, so restricting the search to certain allocators may return unexpected types (e.g. process heaps when searching binary_alloc), or hide blocks that were migrated out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12057feba7f44e75f727b96980ea9629634e93c" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt; mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ed9195c9091feda9cc03849f91a3d0e1313381" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="translated">Допустимый &lt;code&gt;AccessMode&lt;/code&gt; для таблицы может быть определен как &lt;code&gt;read_only&lt;/code&gt; или &lt;code&gt;read_write&lt;/code&gt; . Его можно переключить с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; во время выполнения. Таблицы &lt;code&gt;read_only&lt;/code&gt; и &lt;code&gt;local_content&lt;/code&gt; всегда загружаются локально, так как нет необходимости копировать таблицу с других узлов. Другие таблицы в основном загружаются удаленно из активных реплик на других узлах, если таблица уже загружена туда или если запущенная &lt;code&gt;Mnesia&lt;/code&gt; решила загрузить таблицу уже туда.</target>
        </trans-unit>
        <trans-unit id="c9cd2b75bdb0d580c661ccb5efbc7ebe47d4aa8f" translate="yes" xml:space="preserve">
          <source>The allowed range is 1..256. Defaults to 1 for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt;, and to 8 for &lt;code&gt;binary&lt;/code&gt;. No unit specifier must be given for the types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;.</source>
          <target state="translated">Допустимый диапазон - 1..256. По умолчанию 1 для &lt;code&gt;integer&lt;/code&gt; , чисел с &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;bitstring&lt;/code&gt; и 8 для &lt;code&gt;binary&lt;/code&gt; . Для типов &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; и &lt;code&gt;utf32&lt;/code&gt; нельзя указывать спецификатор единиц .</target>
        </trans-unit>
        <trans-unit id="ad89fe4bac55bef5e612143241645e3f39f837c7" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;Operation&lt;/code&gt; are:</source>
          <target state="translated">Допустимые значения для &lt;code&gt;Operation&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91eabbe1745620d58dbabfc6b149c475cb3f775e" translate="yes" xml:space="preserve">
          <source>The amount of dirty CPU schedulers is limited by the amount of normal schedulers in order to limit the effect on processes executing on ordinary schedulers. If the amount of dirty CPU schedulers was allowed to be unlimited, dirty CPU bound jobs would potentially starve normal jobs.</source>
          <target state="translated">Количество грязных процессорных планировщиков ограничено количеством обычных планировщиков,чтобы ограничить влияние на процессы,выполняемые на обычных планировщиках.Если бы количество грязных процессорных планировщиков было разрешено неограниченно,грязные процессорные задания,привязанные к процессору,потенциально морили бы нормальные задания.</target>
        </trans-unit>
        <trans-unit id="27a9761aa8b41fe03707985ac819ffa2294674b4" translate="yes" xml:space="preserve">
          <source>The amount of dirty IO schedulers is not limited by the amount of normal schedulers &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt;. This since only I/O bound work is expected to execute on dirty I/O schedulers. If the user should schedule CPU bound jobs on dirty I/O schedulers, these jobs might starve ordinary jobs executing on ordinary schedulers.</source>
          <target state="translated">Количество грязных планировщиков ввода-вывода не ограничивается количеством обычных планировщиков, &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt; . Это связано с тем, что на грязных планировщиках ввода-вывода ожидается выполнение только операций ввода-вывода. Если пользователь должен запланировать задания с привязкой к ЦП в грязных планировщиках ввода-вывода, эти задания могут привести к тому, что обычные задания не будут выполняться в обычных планировщиках.</target>
        </trans-unit>
        <trans-unit id="664e7e56a2225929620ef872c0ebcd0c6fb9c4c1" translate="yes" xml:space="preserve">
          <source>The amount of free memory available to the Erlang emulator for allocation.</source>
          <target state="translated">Количество свободной памяти,доступной эмулятору Erlang для выделения.</target>
        </trans-unit>
        <trans-unit id="856f5380158f6d7ba56eebb6ae41011bd9432d40" translate="yes" xml:space="preserve">
          <source>The amount of memory available to the whole operating system. This may well be equal to &lt;code&gt;total_memory&lt;/code&gt; but not necessarily.</source>
          <target state="translated">Объем памяти, доступный для всей операционной системы. Это вполне может быть равно &lt;code&gt;total_memory&lt;/code&gt; , но не обязательно.</target>
        </trans-unit>
        <trans-unit id="177a7f5e407b489cea8a1c26cd218274ba08f36c" translate="yes" xml:space="preserve">
          <source>The amount of memory the system has available for disk swap.</source>
          <target state="translated">Объем памяти,доступный системе для подкачки дисков.</target>
        </trans-unit>
        <trans-unit id="7656a9402d240df34705d7b544f4dff29a5abe83" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for cached files read from disk.</source>
          <target state="translated">Количество памяти,используемое системой для кэширования файлов,считываемых с диска.</target>
        </trans-unit>
        <trans-unit id="eee7cda7742ee86ae7d191faad9371151f0ebd25" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for temporary storing raw disk blocks.</source>
          <target state="translated">Объем памяти,используемый системой для временного хранения блоков необработанного диска.</target>
        </trans-unit>
        <trans-unit id="1082b666267c1d0a05f9d3fc735ec44903b5cce2" translate="yes" xml:space="preserve">
          <source>The amount of time that passes between a signal is sent and the arrival of the signal at the destination is unspecified but positive. If the receiver has terminated, the signal does not arrive, but it can trigger another signal. For example, a link signal sent to a non-existing process triggers an exit signal, which is sent back to where the link signal originated from. When communicating over the distribution, signals can be lost if the distribution channel goes down.</source>
          <target state="translated">Количество времени,которое проходит между отправкой сигнала и прибытием сигнала в пункт назначения,не определено,но положительное.Если приемник прекратил работу,сигнал не поступает,но может включить другой сигнал.Например,сигнал связи,отправленный несуществующему процессу,вызывает сигнал выхода,который отправляется обратно туда,откуда исходил сигнал связи.При общении по распределению сигналы могут быть потеряны,если канал распределения пойдет вниз.</target>
        </trans-unit>
        <trans-unit id="4519c04c3df5357f9581cfbf162358aa5fec4d97" translate="yes" xml:space="preserve">
          <source>The amount of total amount of memory the system has available for disk swap.</source>
          <target state="translated">Общий объем памяти,доступный системе для подкачки дисков.</target>
        </trans-unit>
        <trans-unit id="acb741068fefaff7489583de212a734f3e2cfa94" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap, in words. This information is usually useless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784b5a2e886a3960b27831ea309171f77ba1c2b8" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap. This information is usually useless.</source>
          <target state="translated">Количество неиспользованной памяти на каждой куче.Эта информация обычно бесполезна.</target>
        </trans-unit>
        <trans-unit id="eaa8449008b96acfc6b47fd80ac7ade7e1100e51" translate="yes" xml:space="preserve">
          <source>The analysis result can either be for all modules, or for one module. In either case a call count limit can be given to filter out the functions with a call count below the limit. The all modules analysis does &lt;strong&gt;not&lt;/strong&gt; contain the module &lt;code&gt;cprof&lt;/code&gt; itself, it can only be analysed by specifying it as a single module to analyse.</source>
          <target state="translated">Результат анализа может быть как для всех модулей, так и для одного модуля. В любом случае может быть задано ограничение на количество вызовов, чтобы отфильтровать функции с количеством вызовов ниже лимита. Анализ всех модулей &lt;strong&gt;не&lt;/strong&gt; содержит самого модуля &lt;code&gt;cprof&lt;/code&gt; , его можно проанализировать, только указав его как отдельный модуль для анализа.</target>
        </trans-unit>
        <trans-unit id="665b53498dfc4b5081b2898303b46c4e6c1e3b19" translate="yes" xml:space="preserve">
          <source>The analysis starts from an empty PLT and creates a new one from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. This option only works for BEAM files. To override the default PLT location, use &lt;code&gt;--plt&lt;/code&gt; or &lt;code&gt;--output_plt&lt;/code&gt;.</source>
          <target state="translated">Анализ начинается с пустого PLT и создается новый из файлов, указанных с помощью &lt;code&gt;-c&lt;/code&gt; и &lt;code&gt;-r&lt;/code&gt; . Эта опция работает только для файлов BEAM. Чтобы изменить расположение PLT по умолчанию, используйте &lt;code&gt;--plt&lt;/code&gt; или &lt;code&gt;--output_plt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a17bc48533ec6b4b1d93aa9a618a8199d8ee18c" translate="yes" xml:space="preserve">
          <source>The ancillary data &lt;code&gt;AncData&lt;/code&gt; contains options that for this single message override the default options for the socket, an operation that may not be supported on all platforms, and if so return &lt;code&gt;{error, einval}&lt;/code&gt;. Using more than one of an ancillary data item type may also not be supported. &lt;code&gt;AncData =:= []&lt;/code&gt; is always supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdcf511f2d0831631f6fdd22a140605914418760" translate="yes" xml:space="preserve">
          <source>The answer to the request is encoded to a UDP Protocol Data Unit (PDU).</source>
          <target state="translated">Ответ на запрос закодирован в блоке данных протокола UDP (PDU).</target>
        </trans-unit>
        <trans-unit id="2bf1e9025d3f661f3470ed7afc4906eb1f7fc756" translate="yes" xml:space="preserve">
          <source>The answers are found by evaluating the qualifiers from left to right, backtracking when some filter returns &lt;code&gt;false&lt;/code&gt;, or collecting the template when all filters return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Ответы можно найти путем оценки квалификаторов слева направо, отслеживания с возвратом, когда какой-либо фильтр возвращает &lt;code&gt;false&lt;/code&gt; , или сбора шаблона, когда все фильтры возвращают &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f318a6ba118898a63239c22ec72006a08d5ca687" translate="yes" xml:space="preserve">
          <source>The application can be specified by its name &lt;code&gt;Application&lt;/code&gt;. In this case, the application controller searches the code path for the application resource file &lt;code&gt;Application.app&lt;/code&gt; and loads the specification it contains.</source>
          <target state="translated">Приложение можно указать по имени &lt;code&gt;Application&lt;/code&gt; . В этом случае контроллер приложения ищет путь кода для файла ресурсов &lt;code&gt;Application.app&lt;/code&gt; и загружает содержащуюся в нем спецификацию.</target>
        </trans-unit>
        <trans-unit id="620c94d66204ee923841db86e6b7d75bbdd11ef8" translate="yes" xml:space="preserve">
          <source>The application concept applies both to program structure (processes) and directory structure (modules).</source>
          <target state="translated">Концепция применения относится как к структуре (процессам)программы,так и к структуре каталогов (модулям).</target>
        </trans-unit>
        <trans-unit id="f58d25a7007e6f3798c0b59bdfac842192b77950" translate="yes" xml:space="preserve">
          <source>The application controller automatically loads any included applications when loading a primary application, but does not start them. Instead, the top supervisor of the included application must be started by a supervisor in the including application.</source>
          <target state="translated">При загрузке основного приложения контроллер приложений автоматически загружает все включенные приложения,но не запускает их.Вместо этого старший администратор включенного приложения должен быть запущен старшим администратором включенного приложения.</target>
        </trans-unit>
        <trans-unit id="98f6f34774d04811ed29ee462b6732dccb9d0043" translate="yes" xml:space="preserve">
          <source>The application controller checks the value of the application specification key &lt;code&gt;applications&lt;/code&gt;, to ensure that all applications needed to be started before this application are running. Otherwise, &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; is returned, where &lt;code&gt;App&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">Контроллер приложения проверяет значение ключевых приложений спецификации &lt;code&gt;applications&lt;/code&gt; , чтобы убедиться, что все приложения необходимо запустить перед запуском этого приложения. В противном случае возвращается &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; , где &lt;code&gt;App&lt;/code&gt; - это имя отсутствующего приложения.</target>
        </trans-unit>
        <trans-unit id="f3a71b2d510c249b1ef4dc36fecf08094449baa7" translate="yes" xml:space="preserve">
          <source>The application controller creates an application master for the application</source>
          <target state="translated">Прикладной контроллер создает для приложения ведущее устройство.</target>
        </trans-unit>
        <trans-unit id="83a95923e1f732ae145bb3e38ddb63679bc6a37a" translate="yes" xml:space="preserve">
          <source>The application controller then creates an &lt;strong&gt;application master&lt;/strong&gt; for the application. The application master becomes the group leader of all the processes in the application. I/O is forwarded to the previous group leader, though, this is just a way to identify processes that belong to the application. Used for example to find itself from any process, or, reciprocally, to kill them all when it terminates.</source>
          <target state="translated">Затем контроллер приложения создает &lt;strong&gt;мастер приложения&lt;/strong&gt; для приложения. Мастер приложения становится лидером группы всех процессов в приложении. Ввод-вывод перенаправляется предыдущему лидеру группы, однако это просто способ идентифицировать процессы, принадлежащие приложению. Используется, например, для поиска себя из любого процесса или, наоборот, для уничтожения их всех, когда он завершается.</target>
        </trans-unit>
        <trans-unit id="cb0f6ae5fb0c8a7581cb9e8e067ef2f56d1995bb" translate="yes" xml:space="preserve">
          <source>The application dependencies can be checked using the Erlang shell. Application dependencies are verified among installed applications by &lt;code&gt;otp_patch_apply&lt;/code&gt;, but these are not necessarily those actually loaded. By calling &lt;code&gt;system_information:sanity_check()&lt;/code&gt; one can validate dependencies among applications actually loaded.</source>
          <target state="translated">Зависимости приложения можно проверить с помощью оболочки Erlang. Зависимости приложений проверяются среди установленных приложений с помощью &lt;code&gt;otp_patch_apply&lt;/code&gt; , но они не обязательно действительно загружены. Позвонив &lt;code&gt;system_information:sanity_check()&lt;/code&gt; можно проверить зависимости между приложениями на самом деле загружено.</target>
        </trans-unit>
        <trans-unit id="bb62df0e58b18cc0a3dd6823066bbe7bee60e95d" translate="yes" xml:space="preserve">
          <source>The application is started at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. The application is started as usual. That is, an application master is created and calls the application callback function:</source>
          <target state="translated">Приложение запускается на первом рабочем узле, который указан в списке узлов в параметре &lt;code&gt;distributed&lt;/code&gt; конфигурации. Приложение запускается как обычно. То есть создается мастер приложения, который вызывает функцию обратного вызова приложения:</target>
        </trans-unit>
        <trans-unit id="89049fedc72f84958aace187301d7f02b79550e8" translate="yes" xml:space="preserve">
          <source>The application is started by the application master calling:</source>
          <target state="translated">Приложение запускается по вызову ведущего устройства:</target>
        </trans-unit>
        <trans-unit id="bfedb4900bc06eb3b379ebe1429d3cb0e9392954" translate="yes" xml:space="preserve">
          <source>The application is started the normal way at the new node, that is, by the application master calling:</source>
          <target state="translated">На новом узле приложение запускается обычным способом,то есть вызовом ведущего приложения:</target>
        </trans-unit>
        <trans-unit id="10822e972b13555d1eff4f5137f6287954df0861" translate="yes" xml:space="preserve">
          <source>The application master calls &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; to start the top supervisor.</source>
          <target state="translated">Мастер приложения вызывает &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; чтобы запустить главный супервизор.</target>
        </trans-unit>
        <trans-unit id="e29776b842b696055e58002f88fb65232061b2ab" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;Module:start/2&lt;/code&gt; as defined by the application specification key &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">Мастер приложения запускает приложение, вызывая функцию обратного вызова приложения &lt;code&gt;Module:start/2&lt;/code&gt; , как определено &lt;code&gt;mod&lt;/code&gt; ключа спецификации приложения .</target>
        </trans-unit>
        <trans-unit id="8cabb4f62fd98a4ff2c6678b3ed5fdfd959999a1" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;start/2&lt;/code&gt; in the module, and with the start argument, defined by the &lt;code&gt;mod&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">Мастер приложения запускает приложение, вызывая функцию обратного вызова приложения &lt;code&gt;start/2&lt;/code&gt; в модуле и с аргументом start, определяемым ключом &lt;code&gt;mod&lt;/code&gt; в файле &lt;code&gt;.app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13734b250f5eb9d546b03086cf7b41b4dea34d6f" translate="yes" xml:space="preserve">
          <source>The application master stops the application by telling the top supervisor to shut down. The top supervisor tells all its child processes to shut down, and so on; the entire tree is terminated in reversed start order. The application master then calls the application callback function &lt;code&gt;stop/1&lt;/code&gt; in the module defined by the &lt;code&gt;mod&lt;/code&gt; key.</source>
          <target state="translated">Мастер приложения останавливает приложение, сообщая главному супервизору о завершении работы. Верхний супервизор сообщает всем своим дочерним процессам о завершении работы и так далее; все дерево завершается в обратном порядке начала. Затем мастер приложения вызывает функцию обратного вызова приложения &lt;code&gt;stop/1&lt;/code&gt; в модуле, определенном клавишей &lt;code&gt;mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b526c8807809b1d1a78677dccccf183dc7531782" translate="yes" xml:space="preserve">
          <source>The application master then calls &lt;code&gt;Module:start/2&lt;/code&gt; for the primary application, followed by calls to &lt;code&gt;Module:start_phase/3&lt;/code&gt; for each start phase (as defined for the primary application), both for the primary application and for each of its included applications, for which the start phase is defined.</source>
          <target state="translated">Затем мастер приложения вызывает &lt;code&gt;Module:start/2&lt;/code&gt; для основного приложения, а затем вызывает &lt;code&gt;Module:start_phase/3&lt;/code&gt; для каждой фазы запуска (как определено для основного приложения), как для основного приложения, так и для каждого из включенных в него приложений, для которого определена начальная фаза.</target>
        </trans-unit>
        <trans-unit id="a163c20a5a18b97757a743989413cf19c582f80f" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R10B or later.</source>
          <target state="translated">Для работы приложения требуется Erlang/OTP версия R10B или более поздняя.</target>
        </trans-unit>
        <trans-unit id="47de7b9f1554880fd51a51ad6a1c134e4bb1c43b" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13B02 or later.</source>
          <target state="translated">Для работы приложения требуется версия R13B02 Erlang/OTP или более поздняя.</target>
        </trans-unit>
        <trans-unit id="04c072f323859be092a04c77c0d3a8f3932431a9" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13BB or later. If you use the old &lt;code&gt;GS&lt;/code&gt; based GUI it does suffice with R7B.</source>
          <target state="translated">Для приложения требуется Erlang / OTP версии R13BB или более поздней. Если вы используете старый графический интерфейс на базе &lt;code&gt;GS&lt;/code&gt; , этого будет достаточно с R7B.</target>
        </trans-unit>
        <trans-unit id="705f938ebc82f5cfe9e917670d636ce442e4f982" translate="yes" xml:space="preserve">
          <source>The application resource file is to be called &lt;code&gt;Application.app&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in directory &lt;code&gt;ebin&lt;/code&gt; for the application.</source>
          <target state="translated">Файл ресурсов приложения должен называться &lt;code&gt;Application.app&lt;/code&gt; , где &lt;code&gt;Application&lt;/code&gt; - это имя приложения. Файл должен находиться в каталоге &lt;code&gt;ebin&lt;/code&gt; приложения.</target>
        </trans-unit>
        <trans-unit id="8095bda3db4836c710654adeb79de3919a1733c3" translate="yes" xml:space="preserve">
          <source>The application settings page is rather incomplete.</source>
          <target state="translated">Страница настроек приложения является довольно неполной.</target>
        </trans-unit>
        <trans-unit id="a30b190dbffeb37d7579aa94007cbfaeb029e782" translate="yes" xml:space="preserve">
          <source>The application specification can also be specified directly as a tuple &lt;code&gt;AppSpec&lt;/code&gt;, having the format and contents as described in &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Спецификацию приложения также можно указать непосредственно как кортеж &lt;code&gt;AppSpec&lt;/code&gt; , имеющий формат и содержимое, как описано в &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae0f5edbfbc9e079896bc2aadb1ec402b1e46966" translate="yes" xml:space="preserve">
          <source>The application upgrade file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in the &lt;code&gt;ebin&lt;/code&gt; directory for the application.</source>
          <target state="translated">Файл обновления приложения должен называться &lt;code&gt;Application.appup&lt;/code&gt; , где &lt;code&gt;Application&lt;/code&gt; - это имя приложения. Файл должен находиться в каталоге &lt;code&gt;ebin&lt;/code&gt; приложения.</target>
        </trans-unit>
        <trans-unit id="01be2b299856c125d638a3713ccfbcb4f60476f7" translate="yes" xml:space="preserve">
          <source>The application version of the SSL application.</source>
          <target state="translated">Версия приложения SSL.</target>
        </trans-unit>
        <trans-unit id="73e6b27f7140dc43719697a589e7dc915f9cffa1" translate="yes" xml:space="preserve">
          <source>The application window is started by double clicking on an application name. The application window consists of four pages (tabs):</source>
          <target state="translated">Окно приложения запускается двойным щелчком на имени приложения.Окно приложения состоит из четырех страниц (вкладок):</target>
        </trans-unit>
        <trans-unit id="c8077f9793de81202aa1676c65a0451a20a5cbbb" translate="yes" xml:space="preserve">
          <source>The application-neutral representation of an AVP. Primarily intended for use by relay applications that need to handle arbitrary Diameter applications. A service implementing a specific Diameter application (for which it configures a dictionary) can manipulate values of type &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Независимое от приложения представление AVP. В первую очередь предназначен для использования приложениями ретрансляции, которым необходимо обрабатывать произвольные приложения Diameter. Служба, реализующая конкретное приложение Diameter (для которого он настраивает словарь), может вместо этого манипулировать значениями типа &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e81712f8fd17dfa5b0951414305dbd11e0bfbc67" translate="yes" xml:space="preserve">
          <source>The applications are sorted according to the dependencies between the applications. Where there are no dependencies, the order in the &lt;code&gt;.rel&lt;/code&gt; file is kept.</source>
          <target state="translated">Приложения отсортированы по зависимости между приложениями. При отсутствии зависимостей порядок в файле &lt;code&gt;.rel&lt;/code&gt; сохраняется.</target>
        </trans-unit>
        <trans-unit id="82097ff09c0ae197dc0287ade0a7e0d61d1b24de" translate="yes" xml:space="preserve">
          <source>The applied function called &lt;code&gt;exit(ExitReason)&lt;/code&gt; and did not catch this exception. The exit reason &lt;code&gt;ExitReason&lt;/code&gt; equals the argument passed to &lt;code&gt;exit/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58807661154d4de0263adc44bf6decafbe204083" translate="yes" xml:space="preserve">
          <source>The applied function called &lt;code&gt;throw(Value)&lt;/code&gt; and did not catch this exception. The exception reason &lt;code&gt;Value&lt;/code&gt; equals the argument passed to &lt;code&gt;throw/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85353072338b2dbf168feea1aabc66961c7a142d" translate="yes" xml:space="preserve">
          <source>The archive must be closed with &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Архив нужно закрыть с помощью &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd634904a6b19656df55ba94518706b87469aeb9" translate="yes" xml:space="preserve">
          <source>The archive size is limited to 2 GB (32 bits).</source>
          <target state="translated">Размер архива ограничен 2 Гб (32 бита).</target>
        </trans-unit>
        <trans-unit id="cd12ca75aaea91ed2a310f36dcea8f4976e41af5" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;DefaultAgentConfig&lt;/code&gt; is used as default values when this user register agents.</source>
          <target state="translated">Аргумент &lt;code&gt;DefaultAgentConfig&lt;/code&gt; используется в качестве значений по умолчанию, когда этот пользователь регистрирует агентов.</target>
        </trans-unit>
        <trans-unit id="69004e83d19b67fea82f2e443fe9acacd301728c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Extra&lt;/code&gt; is just an opaque data structure passed to the user via the callback functions in the &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt;. Note however that if &lt;code&gt;Extra&lt;/code&gt; has the value &lt;code&gt;extra_undefined&lt;/code&gt; the argument will be ignored (same as if &lt;code&gt;process_received_message/4&lt;/code&gt; had been called). See the documentation for the behaviour of the callback module, &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt;, for more info.</source>
          <target state="translated">Аргумент &lt;code&gt;Extra&lt;/code&gt; - это просто непрозрачная структура данных, переданная пользователю через функции &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt; . Однако обратите внимание, что если &lt;code&gt;Extra&lt;/code&gt; имеет значение &lt;code&gt;extra_undefined&lt;/code&gt; , аргумент будет проигнорирован (так же, как если бы был вызван &lt;code&gt;process_received_message/4&lt;/code&gt; ). См. Документацию о поведении модуля обратного вызова, &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt; , для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f459c21deb16ca0d8a2238ea1bb013af1aa40900" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to read for future connections.</source>
          <target state="translated">Аргумент &lt;code&gt;Listen&lt;/code&gt; - это дескриптор, первоначально переданный из обратного вызова &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; . Аргумент &lt;code&gt;Opts&lt;/code&gt; - это список параметров, которые следует прочитать для будущих подключений.</target>
        </trans-unit>
        <trans-unit id="debf3f82b456b10623118b0f8614068c9ab5fae7" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to set on future connections.</source>
          <target state="translated">Аргумент &lt;code&gt;Listen&lt;/code&gt; - это дескриптор, первоначально переданный из обратного вызова &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; . Аргумент &lt;code&gt;Opts&lt;/code&gt; - это список параметров, которые необходимо установить для будущих подключений.</target>
        </trans-unit>
        <trans-unit id="6f649282c95c4ff27efd3a1061e1c2bdcdf508eb" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Opaque&lt;/code&gt; is forwarded to the backup module. It returns &lt;code&gt;{atomic, TabList}&lt;/code&gt; if successful, or the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt; if there is an error. &lt;code&gt;TabList&lt;/code&gt; is a list of the restored tables. Tables that are restored are write-locked during the restore operation. However, regardless of any lock conflict caused by this, applications can continue to do their work during the restore operation.</source>
          <target state="translated">Аргумент &lt;code&gt;Opaque&lt;/code&gt; передается модулю резервного копирования. Он возвращает &lt;code&gt;{atomic, TabList}&lt;/code&gt; случае успеха или кортеж &lt;code&gt;{aborted, Reason}&lt;/code&gt; случае ошибки. &lt;code&gt;TabList&lt;/code&gt; - это список восстановленных таблиц. Во время операции восстановления восстанавливаемые таблицы блокируются от записи. Однако, независимо от конфликта блокировок, вызванного этим, приложения могут продолжать выполнять свою работу во время операции восстановления.</target>
        </trans-unit>
        <trans-unit id="dfff5e2db73b8f539cd9908f48d194bda191ddfc" translate="yes" xml:space="preserve">
          <source>The argument can also be a list of modules or filenames, in which case the function tries to interpret each module as specified earlier. The function then always returns &lt;code&gt;ok&lt;/code&gt;, but prints some information to &lt;code&gt;stdout&lt;/code&gt; if a module cannot be interpreted.</source>
          <target state="translated">Аргументом также может быть список модулей или имен файлов, и в этом случае функция пытается интерпретировать каждый модуль, как указано ранее. Затем функция всегда возвращает &lt;code&gt;ok&lt;/code&gt; , но выводит некоторую информацию в стандартный &lt;code&gt;stdout&lt;/code&gt; если модуль не может быть интерпретирован.</target>
        </trans-unit>
        <trans-unit id="f72a488906a1bc4231e746b4ff7b4a8e45eb6fc3" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt;, where the precision is the number of digits written. The default precision is 6 and it cannot be &amp;lt; 2.</source>
          <target state="translated">Аргументом является число с плавающей точкой, которое записывается как &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt; , где точность - это количество записанных цифр. По умолчанию точность равна 6 и не может быть &amp;lt;2.</target>
        </trans-unit>
        <trans-unit id="93d3f166ed7f071a0cf8c5e27837f3a0c6681247" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]ddd.ddd&lt;/code&gt;, where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be &amp;lt; 1.</source>
          <target state="translated">Аргументом является число с плавающей запятой, которое записывается как &lt;code&gt;[-]ddd.ddd&lt;/code&gt; , где точность - это количество цифр после десятичной точки. По умолчанию точность равна 6, и она не может быть &amp;lt;1.</target>
        </trans-unit>
        <trans-unit id="049df39b974433b181b76b3894315e239a3ad777" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;f&lt;/code&gt;, if it is &amp;gt;= 0.1 and &amp;lt; 10000.0. Otherwise, it is written in the &lt;code&gt;e&lt;/code&gt; format. The precision is the number of significant digits. It defaults to 6 and is not to be &amp;lt; 2. If the absolute value of the float does not allow it to be written in the &lt;code&gt;f&lt;/code&gt; format with the desired number of significant digits, it is also written in the &lt;code&gt;e&lt;/code&gt; format.</source>
          <target state="translated">Аргумент - это число с плавающей запятой, которое записывается как &lt;code&gt;f&lt;/code&gt; , если оно&amp;gt; = 0,1 и &amp;lt;10000,0. В противном случае он записывается в формате &lt;code&gt;e&lt;/code&gt; . Точность - это количество значащих цифр. По умолчанию оно равно 6 и не должно быть &amp;lt;2. Если абсолютное значение числа с плавающей запятой не позволяет записать его в формате &lt;code&gt;f&lt;/code&gt; с желаемым количеством значащих цифр, оно также записывается в формате &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd2ce2991cd1ed1c5544565d4bc9f56a7a9da522" translate="yes" xml:space="preserve">
          <source>The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example:</source>
          <target state="translated">Аргументом является число,которое интерпретируется как ASCII код.Точность-это количество распечатанных символов и значение по умолчанию ширины поля,которое,в свою очередь,по умолчанию равно 1.Пример:</target>
        </trans-unit>
        <trans-unit id="41417c1b36d7d073dd070139b59528225284b877" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;init_per_suite&lt;/code&gt; is &lt;code&gt;Config&lt;/code&gt;, that is, the same key-value list of runtime configuration data that each test case takes as input argument. &lt;code&gt;init_per_suite&lt;/code&gt; can modify this parameter with information that the test cases need. The possibly modified &lt;code&gt;Config&lt;/code&gt; list is the return value of the function.</source>
          <target state="translated">Аргументом для &lt;code&gt;init_per_suite&lt;/code&gt; является &lt;code&gt;Config&lt;/code&gt; , то есть тот же список значений ключа данных конфигурации времени выполнения, который каждый тестовый пример принимает в качестве входного аргумента. &lt;code&gt;init_per_suite&lt;/code&gt; может изменять этот параметр, добавляя информацию, необходимую для тестовых случаев. Возможно измененный список &lt;code&gt;Config&lt;/code&gt; - это возвращаемое значение функции.</target>
        </trans-unit>
        <trans-unit id="19116289e2a06f46f52b99e7a354d07e181d8263" translate="yes" xml:space="preserve">
          <source>The argument type change is from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">Тип аргумента меняется со знакового на беззнаковый.Это может привести к проблемам,например,к условиям завершения цикла или к ошибкам,если повсеместно изменять только типы.</target>
        </trans-unit>
        <trans-unit id="518f1110847b76edf7686b0d43ca29a942986a62" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;{local, error_man}&lt;/code&gt; specifies the name. The event manager is then locally registered as &lt;code&gt;error_man&lt;/code&gt;.</source>
          <target state="translated">Аргумент &lt;code&gt;{local, error_man}&lt;/code&gt; указывает имя. Затем диспетчер событий локально регистрируется как &lt;code&gt;error_man&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0afbf43c606253c8ecf1c39998b54bbb8fa67440" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;FormatArgs&lt;/code&gt; in &lt;code&gt;ct:log/print/pal&lt;/code&gt; are always passed on to the STDLIB function &lt;code&gt;io:format/3&lt;/code&gt; (For details, see the &lt;code&gt;io&lt;/code&gt; manual page).</source>
          <target state="translated">Аргументы &lt;code&gt;Format&lt;/code&gt; и &lt;code&gt;FormatArgs&lt;/code&gt; в &lt;code&gt;ct:log/print/pal&lt;/code&gt; всегда передаются функции STDLIB &lt;code&gt;io:format/3&lt;/code&gt; (подробности см. На странице руководства &lt;code&gt;io&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad2c02ade68b15ea95b904a33d006adc1b1cf304" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SnmpInfo&lt;/code&gt; relates in the following way:</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; аргументов и &lt;code&gt;SnmpInfo&lt;/code&gt; связаны следующим образом:</target>
        </trans-unit>
        <trans-unit id="c80eb8b8ff0c248539e0d4f345648274f59f93c8" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt; filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b287b1ceba326e901144e95b8db2f9f2999be1d" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt;filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="translated">Аргументы не раскрываются оболочкой до того, как они будут переданы исполняемому файлу. В частности, это означает, что расширение файла с подстановочными знаками не происходит. Чтобы расширить подстановочные знаки для аргументов, используйте &lt;code&gt;filelib:wildcard/1&lt;/code&gt; . Обратите внимание, что даже если программа является сценарием оболочки Unix, а это означает, что оболочка в конечном итоге вызывается, раскрытие подстановочных знаков не происходит, и сценарий предоставляется с нетронутыми аргументами. В Windows расширение подстановочных знаков всегда зависит от самой программы, поэтому это не проблема.</target>
        </trans-unit>
        <trans-unit id="522ee4260f97c142662210e82bcb713e534c2aad" translate="yes" xml:space="preserve">
          <source>The arguments can be divided into &lt;strong&gt;emulator flags&lt;/strong&gt;, &lt;strong&gt;flags&lt;/strong&gt;, and &lt;strong&gt;plain arguments&lt;/strong&gt;:</source>
          <target state="translated">Аргументы можно разделить на &lt;strong&gt;флаги эмулятора&lt;/strong&gt; , &lt;strong&gt;флаги&lt;/strong&gt; и &lt;strong&gt;простые аргументы&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f6ed9ef38109b234ba45603e287f33458c0a6ac4" translate="yes" xml:space="preserve">
          <source>The arguments can be of different data types. The following order is defined:</source>
          <target state="translated">Аргументы могут быть разных типов данных.Определяется следующий порядок:</target>
        </trans-unit>
        <trans-unit id="c8d0f8904d643db2998fe9360557663dfc7593df" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;system_monitor/2&lt;/code&gt; specifies how all system monitoring on the node should be done, not how it should be changed. This means only one process at a time (&lt;code&gt;MonitorPid&lt;/code&gt;) can be the receiver of system monitor messages. Also, the way to clear a specific monitor option is to not include it in the list &lt;code&gt;Options&lt;/code&gt;. All system monitoring will, however, be cleared if the process identified by &lt;code&gt;MonitorPid&lt;/code&gt; terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa892e870535324db1c0ec38851cc864f132069" translate="yes" xml:space="preserve">
          <source>The arguments:</source>
          <target state="translated">Аргументы:</target>
        </trans-unit>
        <trans-unit id="a8a87576167815553ae803598fc43fec00d99fc0" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) for the current function.</source>
          <target state="translated">Совокупность (количество аргументов)для текущей функции.</target>
        </trans-unit>
        <trans-unit id="f4a92fd68167fdb3dffdde93bfe14f1434196818" translate="yes" xml:space="preserve">
          <source>The arity of the function implementing the fun.</source>
          <target state="translated">Артистичность функции,реализующей веселье.</target>
        </trans-unit>
        <trans-unit id="2e0c7ead6f817b15595de5c93baf2426dbf01b86" translate="yes" xml:space="preserve">
          <source>The arity of the function must match the number of arguments, else a compilation error occurs.</source>
          <target state="translated">Массив функции должен соответствовать количеству аргументов,иначе произойдет ошибка компиляции.</target>
        </trans-unit>
        <trans-unit id="a567fbfc0f0119591979c89645ce71555342bc2e" translate="yes" xml:space="preserve">
          <source>The array length, that is, the function arity. &lt;code&gt;argv[N-1]&lt;/code&gt; thus denotes the Nth argument to the NIF. Notice that the argument &lt;code&gt;argc&lt;/code&gt; allows for the same C function to implement several Erlang functions with different arity (but probably with the same name).</source>
          <target state="translated">Длина массива, то есть арность функции. Таким образом, &lt;code&gt;argv[N-1]&lt;/code&gt; обозначает N-й аргумент NIF. Обратите внимание, что аргумент &lt;code&gt;argc&lt;/code&gt; позволяет одной и той же функции C реализовывать несколько функций Erlang с разной арностью (но, вероятно, с одним и тем же именем).</target>
        </trans-unit>
        <trans-unit id="415f03b07c8ba3c8c05edaadd6e77c05a2cd0868" translate="yes" xml:space="preserve">
          <source>The array never shrinks automatically. If an index &lt;code&gt;I&lt;/code&gt; has been used to set an entry successfully, all indices in the range [0,&lt;code&gt;I&lt;/code&gt;] stay accessible unless the array size is explicitly changed by calling &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Массив никогда не сжимается автоматически. Если индекс &lt;code&gt;I&lt;/code&gt; был использован для успешной установки записи, все индексы в диапазоне [0, &lt;code&gt;I&lt;/code&gt; ] останутся доступными, если размер массива не будет явно изменен путем вызова &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41821fc2a208b561d81f20833df1e2cf397cd22d" translate="yes" xml:space="preserve">
          <source>The associated code contains &lt;code&gt;pseudo variables&lt;/code&gt;&lt;code&gt;'$1'&lt;/code&gt;, &lt;code&gt;'$2'&lt;/code&gt;, &lt;code&gt;'$3'&lt;/code&gt;, etc. which refer to (are bound to) the values associated previously by the parser with the symbols of the right hand side of the rule. When these symbols are terminal categories, the values are token tuples of the input string (see above).</source>
          <target state="translated">Соответствующий код содержит &lt;code&gt;pseudo variables&lt;/code&gt; &lt;code&gt;'$1'&lt;/code&gt; , &lt;code&gt;'$2'&lt;/code&gt; , &lt;code&gt;'$3'&lt;/code&gt; и т. Д., Которые относятся к значениям, ранее связанным анализатором с символами правой части правила (привязаны к ним). Когда эти символы являются терминальными категориями, значения представляют собой лексические кортежи входной строки (см. Выше).</target>
        </trans-unit>
        <trans-unit id="3898cfb8a11a62ffe2fdba8be9357512d68bb196" translate="yes" xml:space="preserve">
          <source>The associated code may not only be used to build structures associated with phrases, but may also be used for syntactic and semantic tests, printout actions (for example for tracing), etc. during the parsing process. Since tokens contain positional (line number) information, it is possible to produce error messages which contain line numbers. If there is no associated code after the right hand side of the rule, the value &lt;code&gt;'$undefined'&lt;/code&gt; is associated with the phrase.</source>
          <target state="translated">Связанный код может использоваться не только для построения структур, связанных с фразами, но также может использоваться для синтаксических и семантических тестов, действий по распечатке (например, для отслеживания) и т. Д. В процессе синтаксического анализа. Поскольку токены содержат позиционную информацию (номер строки), можно создавать сообщения об ошибках, содержащие номера строк. Если после правой части правила нет связанного кода, с фразой связывается значение &lt;code&gt;'$undefined'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ece07e37195ede709e7f03b9006e9af2c0f25d9" translate="yes" xml:space="preserve">
          <source>The association between carrier pool and allocator is very loose. The associations are more or less only there to get names for the amount of carrier pools needed and names of carrier pools that can be easily identified by the &lt;code&gt;:&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6e33dc105b7762f1d530b48ab29c546fd13258" translate="yes" xml:space="preserve">
          <source>The association cannot be established (&lt;code&gt;connect/*&lt;/code&gt; failure).</source>
          <target state="translated">Связь не может быть установлена ​​( &lt;code&gt;connect/*&lt;/code&gt; сбой).</target>
        </trans-unit>
        <trans-unit id="ef9716ac7174f55cae16eacb1845e6a71402ef24" translate="yes" xml:space="preserve">
          <source>The association file &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; for the real implementation looks as follows:</source>
          <target state="translated">Файл ассоциации &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; для реальной реализации выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="81d1ef649b0dc2cac7a3f4619510067970a6fd77" translate="yes" xml:space="preserve">
          <source>The association file, which contains the names of instrumentation functions for the MIB, should have the suffix &lt;code&gt;.funcs&lt;/code&gt;. If the compiler does not find the association file, it gives a warning message and uses default instrumentation functions. (See &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; for more details).</source>
          <target state="translated">Файл ассоциации, содержащий имена инструментальных функций для MIB, должен иметь суффикс &lt;code&gt;.funcs&lt;/code&gt; . Если компилятор не находит файл ассоциации, он выдает предупреждающее сообщение и использует инструментальные функции по умолчанию. (Подробнее см. &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; по умолчанию ).</target>
        </trans-unit>
        <trans-unit id="9e61865049f08d1e62a4b88bd1b23185c90eb9da" translate="yes" xml:space="preserve">
          <source>The asymetric encryption algorithm used in the server's private-public host key pair. Examples include the well-known RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; and elliptic curve &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt;.</source>
          <target state="translated">Алгоритм асимметричного шифрования, используемый в паре закрытых и открытых ключей хоста сервера. Примеры включают хорошо известный RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; и эллиптическую кривую &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e53d0f60e0c53dc5f649aa03a42efcad9929a69" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b06000d023218a0553695852ada6423beef957" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Размер пула асинхронных потоков можно установить с помощью аргумента командной строки &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; . Если пул асинхронных потоков недоступен, вызов выполняется синхронно в потоке, вызывающем &lt;code&gt;driver_async&lt;/code&gt; . Текущее количество асинхронных потоков в пуле асинхронных потоков можно получить через &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d949b17e0550064c4ba8e06402f035e12b3129f" translate="yes" xml:space="preserve">
          <source>The asynchronous API for drivers is complicated. First, the work must be prepared. In the example, this is done in &lt;code&gt;output&lt;/code&gt;. We could have used &lt;code&gt;control&lt;/code&gt;, but we want some variation in the examples. In our driver, we allocate a structure that contains anything that is needed for the asynchronous task to do the work. This is done in the main emulator thread. Then the asynchronous function is called from a driver thread, separate from the main emulator thread. Notice that the driver functions are not re-entrant, so they are not to be used. Finally, after the function is completed, the driver callback &lt;code&gt;ready_async&lt;/code&gt; is called from the main emulator thread, this is where we return the result to Erlang. (We cannot return the result from within the asynchronous function, as we cannot call the driver functions.)</source>
          <target state="translated">Асинхронный API для драйверов сложен. Во-первых, работа должна быть подготовлена. В примере это делается на &lt;code&gt;output&lt;/code&gt; . Мы могли бы использовать &lt;code&gt;control&lt;/code&gt; , но нам нужны вариации в примерах. В нашем драйвере мы выделяем структуру, которая содержит все, что необходимо асинхронной задаче для выполнения работы. Это делается в основном потоке эмулятора. Затем асинхронная функция вызывается из потока драйвера, отдельно от основного потока эмулятора. Обратите внимание, что функции драйвера не реентерабельны, поэтому их нельзя использовать. Наконец, после того, как функция завершена, обратный вызов драйвера &lt;code&gt;ready_async&lt;/code&gt; вызывается из основного потока эмулятора, здесь мы возвращаем результат в Erlang. (Мы не можем вернуть результат из асинхронной функции, так как мы не можем вызывать функции драйвера.)</target>
        </trans-unit>
        <trans-unit id="fb8f8a1d61eec151d7bbdbad482f3278e892dcab" translate="yes" xml:space="preserve">
          <source>The asynchronous request &lt;code&gt;free(Ch)&lt;/code&gt; is implemented using &lt;code&gt;gen_server:cast/2&lt;/code&gt;:</source>
          <target state="translated">Асинхронный запрос &lt;code&gt;free(Ch)&lt;/code&gt; реализуется с помощью &lt;code&gt;gen_server:cast/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="13cb8db4869505cfe3b89f4b66cbde4b8e730e2a" translate="yes" xml:space="preserve">
          <source>The asynchronous version of the driver is in the sample files &lt;code&gt;pg_async.c&lt;/code&gt; and &lt;code&gt;pg_asyng.erl&lt;/code&gt;.</source>
          <target state="translated">Асинхронная версия драйвера находится в файлах &lt;code&gt;pg_async.c&lt;/code&gt; и &lt;code&gt;pg_asyng.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95ad31c862f53147c29592fd7356527c9ffced30" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Behaviour&lt;/code&gt; gives the name of the behaviour, which can be a user-defined behaviour or one of the following OTP standard behaviours:</source>
          <target state="translated">Atom &lt;code&gt;Behaviour&lt;/code&gt; дает имя поведения, которое может быть определенным пользователем поведением или одним из следующих стандартных поведений OTP:</target>
        </trans-unit>
        <trans-unit id="8b6c48f50dc1798aeaec7a743fffe7be10b28e3a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Name&lt;/code&gt; is the table name. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and many processes can share one table.</source>
          <target state="translated">Атом &lt;code&gt;Name&lt;/code&gt; это имя таблицы. Имя таблицы должно быть указано во всех последующих операциях с таблицей. Имя может использоваться и другими процессами, и многие процессы могут совместно использовать одну таблицу.</target>
        </trans-unit>
        <trans-unit id="c510ba5b1215726673e2f72d3059e72c9e136b36" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;activity&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;activity&lt;/code&gt; атома</target>
        </trans-unit>
        <trans-unit id="9710032c39f79ee3070e26173f96829389498bd7" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;finished&lt;/code&gt; is sent to &quot;pong&quot; (causing it to terminate as described above) and &quot;ping finished&quot; is written to the output. &quot;Ping&quot; then terminates as it has nothing left to do.</source>
          <target state="translated">Атом &lt;code&gt;finished&lt;/code&gt; отправляется в &amp;laquo;понг&amp;raquo; (заставляя его прекратить , как описано выше) , и &amp;laquo;пинг закончил&amp;raquo; записывается на выход. Затем &quot;Ping&quot; завершается, так как ему больше нечего делать.</target>
        </trans-unit>
        <trans-unit id="d82cb2c455d0963906d4919213af14bc97a0dc7e" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;hibernate&lt;/code&gt; in the action list on the last line when entering the &lt;code&gt;{open,_}&lt;/code&gt; state is the only change. If any event arrives in the &lt;code&gt;{open,_},&lt;/code&gt; state, we do not bother to rehibernate, so the server stays awake after any event.</source>
          <target state="translated">Единственное изменение - переход атома в &lt;code&gt;hibernate&lt;/code&gt; в списке действий в последней строке при переходе в состояние &lt;code&gt;{open,_}&lt;/code&gt; . Если какое-либо событие прибывает в состояние &lt;code&gt;{open,_},&lt;/code&gt; мы не беспокоимся о повторной гибернации, поэтому сервер остается активным после любого события.</target>
        </trans-unit>
        <trans-unit id="356f9715c2aad0ed355593e69081e1f8b8476d8f" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending&lt;/code&gt;, which means that a monitor is to be created whenever a load operation is delayed,</source>
          <target state="translated">&lt;code&gt;pending&lt;/code&gt; атома , что означает, что монитор должен создаваться всякий раз, когда операция загрузки задерживается,</target>
        </trans-unit>
        <trans-unit id="161e6641a902cec6d4ca9159bb2b569a7ff90c0a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending_driver&lt;/code&gt;, in which a monitor is created whenever the operation is delayed because of open ports to an otherwise unused driver.</source>
          <target state="translated">Атом &lt;code&gt;pending_driver&lt;/code&gt; , в котором монитор создается всякий раз, когда операция откладывается из-за открытых портов для неиспользуемого драйвера.</target>
        </trans-unit>
        <trans-unit id="4d60a51c643f2a02e17349df9085c521ad7bd0aa" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;system&lt;/code&gt;</source>
          <target state="translated">Атомная &lt;code&gt;system&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42969bfd0b03becb2a706b91287d2fd18b7a8038" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Атом &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c920e9113121f0b04e27b3e131485fc54743c" translate="yes" xml:space="preserve">
          <source>The atomicity and the isolation properties of &lt;code&gt;Mnesia&lt;/code&gt; are lost.</source>
          <target state="translated">Атомарность и изоляционные свойства &lt;code&gt;Mnesia&lt;/code&gt; утрачены.</target>
        </trans-unit>
        <trans-unit id="1f8c1bd67e98ea142e16fbd8328c31a4abe8ce1c" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">Атомы &lt;code&gt;big&lt;/code&gt; и &lt;code&gt;little&lt;/code&gt; обозначают кодирование с прямым или обратным порядком байтов.</target>
        </trans-unit>
        <trans-unit id="eec0aca30bfb32af191c5b7f63bda050342a54ff" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;send&lt;/code&gt;, &lt;code&gt;'receive'&lt;/code&gt;, and &lt;code&gt;timeout&lt;/code&gt; for sends and receives (&lt;code&gt;'receive'&lt;/code&gt; when a message is received and &lt;code&gt;timeout&lt;/code&gt; when a receive times out)</source>
          <target state="translated">Атомы &lt;code&gt;send&lt;/code&gt; , &lt;code&gt;'receive'&lt;/code&gt; и &lt;code&gt;timeout&lt;/code&gt; для отправки и получения ( &lt;code&gt;'receive'&lt;/code&gt; когда сообщение получено, и &lt;code&gt;timeout&lt;/code&gt; когда время ожидания истекает)</target>
        </trans-unit>
        <trans-unit id="d6808e92018a30d64fa086f0dfa84d2f8448d1ef" translate="yes" xml:space="preserve">
          <source>The attribute OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">Атомы атрибута OID name и соответствующие им типы значений выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="c9f3b18eb4341c86b8c0684826dff3c42219fcc2" translate="yes" xml:space="preserve">
          <source>The author can choose to put many or few tests into each test case. Some things to keep in mind follows:</source>
          <target state="translated">Автор может выбрать много или мало тестов в каждом конкретном случае.Некоторые вещи следует иметь в виду:</target>
        </trans-unit>
        <trans-unit id="badc70f1a60a87b4c3438b8a7de6f4c78b5a65bc" translate="yes" xml:space="preserve">
          <source>The auto save interval. The table is flushed to disk whenever not accessed for this amount of time.</source>
          <target state="translated">Интервал автоматического сохранения.Таблица стирается на диск всякий раз,когда к ней нет доступа в течение этого периода времени.</target>
        </trans-unit>
        <trans-unit id="c039d5fb00e0ef90ed0ae37b0f2d061a360a486a" translate="yes" xml:space="preserve">
          <source>The autostart feature requires more data to be stored on traced nodes. By default, the data is stored automatically to the file named &quot;ttb_autostart.bin&quot; in the currect working directory (cwd) of the traced node. Users can change this behaviour (that is, on diskless nodes) by specifying their own module to handle autostart data storage and retrieval (&lt;code&gt;ttb_autostart_module&lt;/code&gt; environment variable of &lt;code&gt;runtime_tools&lt;/code&gt;). For information about the API, see module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;. The following example shows the default handler:</source>
          <target state="translated">Функция автозапуска требует, чтобы на отслеживаемых узлах хранилось больше данных. По умолчанию данные автоматически сохраняются в файле с именем &amp;laquo;ttb_autostart.bin&amp;raquo; в текущем рабочем каталоге (cwd) отслеживаемого узла. Пользователи могут изменить это поведение (то есть, на бездисковых узлах), указав свой собственный модуль для хранения ручки автозапуска данных и извлечения ( &lt;code&gt;ttb_autostart_module&lt;/code&gt; среды переменной &lt;code&gt;runtime_tools&lt;/code&gt; ). Для получения информации об API см. Модуль &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; . В следующем примере показан обработчик по умолчанию:</target>
        </trans-unit>
        <trans-unit id="ec0674516ee9bb18698545632ddcef7eb77a1e62" translate="yes" xml:space="preserve">
          <source>The available OID names are as follows:</source>
          <target state="translated">Доступные OID-именования выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="270053ab9a2cdd71b431ca1b29230d0131168ac8" translate="yes" xml:space="preserve">
          <source>The available configuration options are as follows:</source>
          <target state="translated">Доступные варианты конфигурации представлены ниже:</target>
        </trans-unit>
        <trans-unit id="5ffd517ca47007c093bb8a7cefdb756ebfdced63" translate="yes" xml:space="preserve">
          <source>The available configuration properties are as follows:</source>
          <target state="translated">Доступные свойства конфигурации представлены ниже:</target>
        </trans-unit>
        <trans-unit id="0d5fbe85b0c98fe746cb7e16c8187e2dfc18521e" translate="yes" xml:space="preserve">
          <source>The average run-time for the schedulers. This is the average amount of time the schedulers did not sleep.</source>
          <target state="translated">Среднее время работы планировщиков.Это среднее время,в течение которого планировщики не спали.</target>
        </trans-unit>
        <trans-unit id="aaf853276797e4d431ffd98c86f3b72f5161ab87" translate="yes" xml:space="preserve">
          <source>The average time spent collecting data in the threads. This should be close to the time which data was collected.</source>
          <target state="translated">Среднее время,затраченное на сбор данных в потоках.Это должно быть близко к времени,в течение которого собирались данные.</target>
        </trans-unit>
        <trans-unit id="70cab81b62df4bb768ae5b9f87b1769a35f91166" translate="yes" xml:space="preserve">
          <source>The backslash character has many uses. First, if it is followed by a character that is not a number or a letter, it takes away any special meaning that a character can have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">Символ обратного слеша имеет много применений.Во-первых,если за ним следует символ,не являющийся цифрой или буквой,он отнимает любое особое значение,которое может иметь символ.Такое использование обратного слеша в качестве экранирующего символа применяется как внутри,так и вне классов символов.</target>
        </trans-unit>
        <trans-unit id="dbe5fe5807b426b9440606cd7c73c539d1bcdeff" translate="yes" xml:space="preserve">
          <source>The backup data is divided into two sections. The first section contains information related to the schema. All schema-related items are tuples where the first field equals the atom schema. The second section is the record section. Schema records cannot be mixed with other records and all schema records must be located first in the backup.</source>
          <target state="translated">Резервные данные разделены на две секции.Первый раздел содержит информацию,относящуюся к схеме.Все элементы,связанные со схемой,являются кортежами,где первое поле равно схеме атома.Второй раздел-раздел записи.Схематические записи нельзя смешивать с другими записями,и все записи схемы должны быть расположены первыми в резервной копии.</target>
        </trans-unit>
        <trans-unit id="5cb61dbbe8949ce8224db389cdf36c3f301c26b1" translate="yes" xml:space="preserve">
          <source>The base AVPs are defined in the common dictionary provided by diameter. There are common dictionaries for both RFC 3588 and RFC 6733 since the latter made changes to both syntax and semantics.</source>
          <target state="translated">Базовые АВП определяются в общем словаре,предоставляемом по диаметру.Существуют общие словари как для RFC 3588,так и для RFC 6733,так как в последнем были внесены изменения как в синтаксис,так и в семантику.</target>
        </trans-unit>
        <trans-unit id="37b6dd9b192c11e194c06eb99987679081a97762" translate="yes" xml:space="preserve">
          <source>The base name of the compiled file</source>
          <target state="translated">Базовое имя скомпилированного файла</target>
        </trans-unit>
        <trans-unit id="d6fbdeb4864f0e11b719e81c27b780c593542153" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt; deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13db919a8612a7a4080781ff054af866565ed391" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">Логарифм размера окна по основанию два (размер буфера истории). Он должен находиться в диапазоне от 8 до 15. Чем больше значение, тем лучше сжатие за счет использования памяти. По умолчанию 15, если используется &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; . Отрицательное значение &lt;code&gt;WindowBits&lt;/code&gt; подавляет заголовок zlib (и контрольную сумму) из потока. Обратите внимание, что в источнике zlib это упоминается только как недокументированная функция.</target>
        </trans-unit>
        <trans-unit id="8818564f19c5c56bd354986044623c1ba1d3d72f" translate="yes" xml:space="preserve">
          <source>The basic concept is that of a &lt;strong&gt;MIB view&lt;/strong&gt;. An MIB view is a subset of all the objects implemented by an agent. A manager has access to a certain MIB view, depending on which security parameters are used, in which context the request is made, and which type of request is made.</source>
          <target state="translated">Основная концепция - это представление &lt;strong&gt;MIB&lt;/strong&gt; . Представление MIB - это подмножество всех объектов, реализованных агентом. Менеджер имеет доступ к определенному представлению MIB, в зависимости от того, какие параметры безопасности используются, в каком контексте сделан запрос и какой тип запроса сделан.</target>
        </trans-unit>
        <trans-unit id="4956ca9b4e8f3cd207abf9624e243d3cdb794f4d" translate="yes" xml:space="preserve">
          <source>The basic idea of syntax highlighting is to make the structure of a program clearer. For example, the highlighting will make it easier to spot simple bugs. Have not you ever written a variable in lower-case only? With syntax highlighting a variable will colored while atoms will be shown with the normal text color.</source>
          <target state="translated">Основная идея подсветки синтаксиса заключается в том,чтобы сделать структуру программы более понятной.Например,подсветка облегчит обнаружение простых ошибок.Вы когда-нибудь записывали переменную только в нижнем регистре? При подсветке синтаксиса переменная будет окрашиваться,в то время как атомы будут отображаться обычным цветом текста.</target>
        </trans-unit>
        <trans-unit id="5ad538ab434ab340ba09c1c90fc3a4a6dea30af6" translate="yes" xml:space="preserve">
          <source>The basic idea with exclusive decode is to specify which parts of the message you want to exclude from being decoded. These parts remain encoded and are returned in the value structure as binaries. They can be decoded in turn by passing them to a certain &lt;code&gt;decode_part/2&lt;/code&gt; function. The performance gain is high for large messages. You can do an exclusive decode and later one or more decodes of the parts, or a second complete decode instead of two or more complete decodes.</source>
          <target state="translated">Основная идея эксклюзивного декодирования - указать, какие части сообщения вы хотите исключить из декодирования. Эти части остаются закодированными и возвращаются в структуре значений как двоичные файлы. Их можно декодировать по очереди, передав их определенной функции &lt;code&gt;decode_part/2&lt;/code&gt; . Прирост производительности высок для больших сообщений. Вы можете выполнить эксклюзивное декодирование, а затем один или несколько декодеров частей или второе полное декодирование вместо двух или более полных декодирований.</target>
        </trans-unit>
        <trans-unit id="d34b055b96b341faab090f12091572854579bc39" translate="yes" xml:space="preserve">
          <source>The basic ideas from the original protocol still hold. The I/O server and client communicate with one single, rather simplistic protocol and no server state is ever present in the client. Any I/O server can be used together with any client code, and the client code does not need to be aware of the I/O device that the I/O server communicates with.</source>
          <target state="translated">Основные идеи из оригинального протокола все еще остаются в силе.Сервер ввода/вывода и клиент взаимодействуют с одним достаточно простым протоколом,и состояние сервера никогда не присутствует в клиенте.Любой сервер ввода/вывода может использоваться вместе с любым клиентским кодом,и клиентскому коду не нужно знать об устройстве ввода/вывода,с которым взаимодействует сервер ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="06f35fc40ac6c0c6f620803908f2d0ce6893c711" translate="yes" xml:space="preserve">
          <source>The basic message file</source>
          <target state="translated">Файл основного сообщения</target>
        </trans-unit>
        <trans-unit id="7b96cdbd69bdcaed6a11b07691044f3fc504705b" translate="yes" xml:space="preserve">
          <source>The behavior if a file specified in &lt;code&gt;sys.config&lt;/code&gt; does not exist, or is erroneous, is backwards compatible. Starting the runtime system will fail. Installing a new release version will not fail, but an error message is returned and the erroneous file is ignored.</source>
          <target state="translated">Поведение, если файл, указанный в &lt;code&gt;sys.config&lt;/code&gt; , не существует или является ошибочным, имеет обратную совместимость. Запустить систему выполнения не удастся. Установка новой версии выпуска не завершится ошибкой, но возвращается сообщение об ошибке, а ошибочный файл игнорируется.</target>
        </trans-unit>
        <trans-unit id="a86acb8a0f20fdc979242a6b86b6e670d328548d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any process performs a write operation on the table while traversing the table with the function &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; This is because &lt;code&gt;write&lt;/code&gt; operations on a &lt;code&gt;Mnesia&lt;/code&gt; table can lead to internal reorganizations of the table itself. This is an implementation detail, but remember that the dirty functions are low-level functions.</source>
          <target state="translated">Поведение не определено, если какой-либо процесс выполняет операцию записи в таблице при обходе таблицы с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; . Это связано с тем, что операции &lt;code&gt;write&lt;/code&gt; в таблице &lt;code&gt;Mnesia&lt;/code&gt; могут привести к внутренней реорганизации самой таблицы. Это деталь реализации, но помните, что грязные функции - это низкоуровневые функции.</target>
        </trans-unit>
        <trans-unit id="1a796a85b7d7280f632e4dcbf6b4a44abe35956e" translate="yes" xml:space="preserve">
          <source>The behavior of (*PRUNE:NAME) is the not the same as (*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">Поведение (*PRUNE:NAME)отличается от поведения (*MARK:NAME)(*PRUNE).Оно похоже на (*MARK:NAME)в том,что имя запоминается для передачи обратно вызывающему абоненту.Однако,(*SKIP:NAME)ищет только имена,заданные с помощью (*MARK).</target>
        </trans-unit>
        <trans-unit id="47227c0747ba0b82f4e36ef4aee5b965307890ad" translate="yes" xml:space="preserve">
          <source>The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">Поведение (*THEN:NAME)отличается от поведения (*MARK:NAME)(*THEN).Оно похоже на (*MARK:NAME)в том,что имя запоминается для передачи обратно вызывающему абоненту.Однако,(*SKIP:NAME)ищет только имена,заданные с помощью (*MARK).</target>
        </trans-unit>
        <trans-unit id="e44b071bcc39a063eb56d16dfbf4c6bb36987d8b" translate="yes" xml:space="preserve">
          <source>The behavior of a socket with this option set to &lt;code&gt;true&lt;/code&gt; is the only portable one. The original idea when IPv6 was new of using IPv6 for all traffic is now not recommended by FreeBSD (you can use &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; to override the recommended system default value), forbidden by OpenBSD (the supported GENERIC kernel), and impossible on Windows (which has separate IPv4 and IPv6 protocol stacks). Most Linux distros still have a system default value of &lt;code&gt;false&lt;/code&gt;. This policy shift among operating systems to separate IPv6 from IPv4 traffic has evolved, as it gradually proved hard and complicated to get a dual stack implementation correct and secure.</source>
          <target state="translated">Поведение сокета с этим параметром, установленным в значение &lt;code&gt;true&lt;/code&gt; , является единственным переносимым. Первоначальная идея, когда IPv6 была новой, использовать IPv6 для всего трафика, теперь не рекомендуется FreeBSD (вы можете использовать &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; для переопределения рекомендуемого системного значения по умолчанию), запрещена OpenBSD (поддерживаемое ядро ​​GENERIC) и невозможна на Windows (в которой есть отдельные стеки протоколов IPv4 и IPv6). Большинство дистрибутивов Linux по-прежнему имеют системное значение по умолчанию &lt;code&gt;false&lt;/code&gt; . Этот сдвиг в политике операционных систем для отделения IPv6 от трафика IPv4 эволюционировал, поскольку постепенно оказалось трудным и сложным получить правильную и безопасную реализацию двойного стека.</target>
        </trans-unit>
        <trans-unit id="1a4c4b510c91839af2b2d840f0dd22a548ca7548" translate="yes" xml:space="preserve">
          <source>The behavior of dot regarding newlines can be changed. If option &lt;code&gt;dotall&lt;/code&gt; is set, a dot matches any character, without exception. If the two-character sequence CRLF is present in the subject string, it takes two dots to match it.</source>
          <target state="translated">Поведение точки относительно новой строки можно изменить. Если установлен параметр &lt;code&gt;dotall&lt;/code&gt; , точка соответствует любому символу без исключения. Если в строке темы присутствует двухсимвольная последовательность CRLF, для ее сопоставления требуются две точки.</target>
        </trans-unit>
        <trans-unit id="7965ee081ee817356aeac4f791276c29588e7325" translate="yes" xml:space="preserve">
          <source>The behavior of shell escape can be changed by the STDLIB application variable &lt;code&gt;shell_esc&lt;/code&gt;. The value of the variable can be either &lt;code&gt;jcl&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt;) or &lt;code&gt;abort&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt;). The first option sets &lt;code&gt;^G&lt;/code&gt; to activate &lt;code&gt;JCL&lt;/code&gt; mode (which is also default behavior). The latter sets &lt;code&gt;^G&lt;/code&gt; to terminate the current shell and start a new one. &lt;code&gt;JCL&lt;/code&gt; mode cannot be invoked when &lt;code&gt;shell_esc&lt;/code&gt; is set to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">Поведение экранирования оболочки можно изменить с помощью переменной приложения &lt;code&gt;shell_esc&lt;/code&gt; . Значение переменной может быть либо &lt;code&gt;jcl&lt;/code&gt; ( &lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt; ), либо &lt;code&gt;abort&lt;/code&gt; ( &lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt; ). Первый параметр устанавливает &lt;code&gt;^G&lt;/code&gt; для активации режима &lt;code&gt;JCL&lt;/code&gt; (что также является поведением по умолчанию). Последний устанавливает &lt;code&gt;^G&lt;/code&gt; для завершения текущей оболочки и запуска новой. Режим &lt;code&gt;JCL&lt;/code&gt; не может быть &lt;code&gt;shell_esc&lt;/code&gt; когда shell_esc установлен на &lt;code&gt;abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f28c17be27978977c1d4772358e7a511e0dfa71" translate="yes" xml:space="preserve">
          <source>The behavior of these verbs in repeated groups, assertions, and in subpatterns called as subroutines (whether or not recursively) is described below.</source>
          <target state="translated">Поведение этих глаголов в повторяющихся группах,утверждениях и в подмасказках,называемых подпрограммами (рекурсивно или нет),описано ниже.</target>
        </trans-unit>
        <trans-unit id="b5f409290159e0122d24e0b32bc792ec356f3f9c" translate="yes" xml:space="preserve">
          <source>The behavior of this function changed radically in &lt;code&gt;Common Test&lt;/code&gt; 1.6.2. To keep some backwards compatability, it is still possible to do:</source>
          <target state="translated">Поведение этой функции радикально изменилось в &lt;code&gt;Common Test&lt;/code&gt; 1.6.2. Чтобы сохранить некоторую обратную совместимость, все еще можно сделать:</target>
        </trans-unit>
        <trans-unit id="3cecdaf7589f62bdef0c740b1516c756288d9c79" translate="yes" xml:space="preserve">
          <source>The behavior of this function is undefined if the table is written on while being traversed. The function &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to ensure that no transaction-protected writes are performed during the iteration.</source>
          <target state="translated">Поведение этой функции не определено, если таблица записывается во время обхода. Функцию &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; можно использовать, чтобы гарантировать, что во время итерации не будут выполняться записи, защищенные транзакциями.</target>
        </trans-unit>
        <trans-unit id="0ad444f7fffcddf3e1072340ed21b0cb1ac9f4b6" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of posponed messages and other metadata. It receives all process messages, handles the system messages, and calls the callback module with machine specific events.</source>
          <target state="translated">Механизм поведения удерживает состояние машины,данные сервера,ссылки на таймер,очередь отложенных сообщений и другие метаданные.Он получает все сообщения процесса,обрабатывает системные сообщения и вызывает модуль обратного вызова с определенными для машины событиями.</target>
        </trans-unit>
        <trans-unit id="81091c06f62b758fa79bf459317221a8b60aa4f7" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of postponed messages and other metadata. It receives all process messages, handles the system messages, and calls the &lt;strong&gt;callback module&lt;/strong&gt; with machine specific events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0880fce4c0b15834624e11a3dadca1d45ea29226" translate="yes" xml:space="preserve">
          <source>The behaviour module is part of Erlang/OTP. To implement a process such as a supervisor, the user only has to implement the callback module which is to export a pre-defined set of functions, the &lt;strong&gt;callback functions&lt;/strong&gt;.</source>
          <target state="translated">Модуль поведения является частью Erlang / OTP. Чтобы реализовать такой процесс, как супервизор, пользователю нужно только реализовать модуль обратного вызова, который должен экспортировать заранее определенный набор функций, &lt;strong&gt;функции обратного вызова&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f12a9631818d9d069082f70af478c5b6e70157" translate="yes" xml:space="preserve">
          <source>The benchmarks were run on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62e2973e3a88e1a9aafc89e21ac3f85591af54e" translate="yes" xml:space="preserve">
          <source>The benchmarks were run on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers. On a machine with more communication overhead and/or larger amount of logical processors the speedups are expected to be even larger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e8c63ca2b59778b1c251bfe4d9af4a1c121cce" translate="yes" xml:space="preserve">
          <source>The benefit of this is that Megaco handles the starting, holding and the supervision of the driver and port.</source>
          <target state="translated">Преимуществом этого является то,что Megaco управляет стартом,удержанием и наблюдением за водителем и портом.</target>
        </trans-unit>
        <trans-unit id="1929daa6d9f07ef87baa0d2108c05731636b180d" translate="yes" xml:space="preserve">
          <source>The best place is in the &lt;code&gt;sys.config&lt;/code&gt; system configuration file of the release.</source>
          <target state="translated">Лучшее место - в системном файле конфигурации &lt;code&gt;sys.config&lt;/code&gt; выпуска.</target>
        </trans-unit>
        <trans-unit id="d72c83f4147d145bc84c3d37b05a70b520d273ab" translate="yes" xml:space="preserve">
          <source>The binaries do not contain whole bytes (bit strings).</source>
          <target state="translated">Двоичные файлы не содержат целых байтов (битовых строк).</target>
        </trans-unit>
        <trans-unit id="2c99eedcea168087b25493bcc8656037a8c03177" translate="yes" xml:space="preserve">
          <source>The binary boot script file &lt;code&gt;Name.boot&lt;/code&gt; is generated from the boot script file &lt;code&gt;Name.script&lt;/code&gt;, using the function &lt;code&gt;systools:script2boot(File)&lt;/code&gt;.</source>
          <target state="translated">Бинарный файл сценария загрузки &lt;code&gt;Name.boot&lt;/code&gt; создается из файла сценария загрузки &lt;code&gt;Name.script&lt;/code&gt; с помощью функции &lt;code&gt;systools:script2boot(File)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c63a3b170852a27feb1e79f6999b69d62a7625a7" translate="yes" xml:space="preserve">
          <source>The binary boot script renamed to &lt;code&gt;start.boot&lt;/code&gt;</source>
          <target state="translated">Бинарный загрузочный скрипт переименован в &lt;code&gt;start.boot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdaeab197086e91b2d818626cc54633ed2fa6700" translate="yes" xml:space="preserve">
          <source>The binary executable file must be owned by root, have &lt;code&gt;rwsr-xr-x&lt;/code&gt; file privileges, in particular the &lt;code&gt;setuid&lt;/code&gt; bit of the user must be set.</source>
          <target state="translated">Бинарный исполняемый файл должен принадлежать пользователю root, иметь файловые привилегии &lt;code&gt;rwsr-xr-x&lt;/code&gt; , в частности должен быть установлен бит &lt;code&gt;setuid&lt;/code&gt; пользователя.</target>
        </trans-unit>
        <trans-unit id="9f05ddacf84bb36fa321e41835d584b6e76e30a8" translate="yes" xml:space="preserve">
          <source>The binary heap works as a large object space for binary terms that are greater than 64 bytes (from now on called off-heap binaries). The binary heap is &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counted&lt;/a&gt;&lt;/code&gt; and a pointer to the off-heap binary is stored on the process heap. To keep track of when to decrement the reference counter of the off-heap binary, a linked list (the MSO - mark and sweep object list) containing funs and externals as well as off-heap binaries is woven through the heap. After a garbage collection is done, the &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2299&quot;&gt;MSO list is swept&lt;/a&gt;&lt;/code&gt; and any off-heap binary that does not have a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2325&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; written into the header words has its reference &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2344-L2367&quot;&gt;decremented and is potentially freed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fa7003833fa581d83179258571e8a367f39ad2" translate="yes" xml:space="preserve">
          <source>The binary object can be referenced by any number of ProcBins from any number of processes. The object contains a reference counter to keep track of the number of references, so that it can be removed when the last reference disappears.</source>
          <target state="translated">На бинарный объект может ссылаться любое количество ProcBins из любого количества процессов.Объект содержит счетчик ссылок для отслеживания количества ссылок,чтобы его можно было удалить,когда исчезнет последняя ссылка.</target>
        </trans-unit>
        <trans-unit id="127151f66b51ac3efe997eb464906c3d0948c0d1" translate="yes" xml:space="preserve">
          <source>The binary object itself, stored outside all process heaps</source>
          <target state="translated">Сам бинарный объект,сохраненный за пределами всех кучи процессов.</target>
        </trans-unit>
        <trans-unit id="4cf0fde8a2120eccfe9fdc8a249b8de5265ff4ee" translate="yes" xml:space="preserve">
          <source>The binary output file produced by the compiler is read by the agent at MIB load time (see the figure &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt;). The instrumentation is ordinary Erlang code which is loaded explicitly or automatically the first time it is called.</source>
          <target state="translated">Двоичный выходной файл, созданный компилятором, считывается агентом во время загрузки MIB (см. Рисунок &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt; ). Инструментарий - это обычный код Erlang, который загружается явно или автоматически при первом вызове.</target>
        </trans-unit>
        <trans-unit id="d082c75a002a09432e39d447b940479e08b9f5e4" translate="yes" xml:space="preserve">
          <source>The bit syntax contains types for handling binary data in the three main encodings. The types are named &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;. The &lt;code&gt;utf16&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; types can be in a big-endian or a little-endian variant:</source>
          <target state="translated">Битовый синтаксис содержит типы для обработки двоичных данных в трех основных кодировках. Типы называются &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; и &lt;code&gt;utf32&lt;/code&gt; . В &lt;code&gt;utf16&lt;/code&gt; и &lt;code&gt;utf32&lt;/code&gt; типов могут быть в обратном порядке байт или небольшой обратный порядком байт варианта:</target>
        </trans-unit>
        <trans-unit id="7305cb0adee2541b623171c05bf3f3d1ecacd9f6" translate="yes" xml:space="preserve">
          <source>The body of the fun is used to construct the resulting value. When selecting from tables, one usually construct a suiting term here, using ordinary Erlang term construction, like tuple parentheses, list brackets, and variables matched out in the head, possibly with the occasional constant. Whatever expressions are allowed in guards are also allowed here, but no special functions exist except &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;bindings&lt;/code&gt; (see further down), which returns the whole matched object and all known variable bindings, respectively.</source>
          <target state="translated">Тело забавы используется для построения результирующего значения. При выборе из таблиц здесь обычно создают подходящий термин, используя обычную конструкцию терминов Эрланга, такую ​​как скобки кортежа, скобки списка и переменные, сопоставленные в заголовке, возможно, с случайной константой. Здесь также разрешены любые выражения, разрешенные в охранниках, но не существует никаких специальных функций, кроме &lt;code&gt;object&lt;/code&gt; и &lt;code&gt;bindings&lt;/code&gt; (см. Ниже), которые возвращают весь согласованный объект и все известные привязки переменных соответственно.</target>
        </trans-unit>
        <trans-unit id="e9fdf4a0d35c62b0782bd25eb4544517276991d8" translate="yes" xml:space="preserve">
          <source>The boolean value true specifies that the server will agree to reuse sessions. Setting it to false will result in an empty session table, that is no sessions will be reused. See also option &lt;code&gt;&lt;a href=&quot;#type-server_reuse_session&quot;&gt;reuse_session&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ca0de7223fe258efb581336c1e0197d5d0edd2" translate="yes" xml:space="preserve">
          <source>The boot script included in a release package must be generated from the same &lt;code&gt;.rel&lt;/code&gt; file as the release package itself.</source>
          <target state="translated">Сценарий загрузки, включенный в пакет выпуска, должен быть сгенерирован из того же файла &lt;code&gt;.rel&lt;/code&gt; , что и сам пакет выпуска.</target>
        </trans-unit>
        <trans-unit id="ddcf162c693f295280c787fbd8290adee7c45ca3" translate="yes" xml:space="preserve">
          <source>The boot script is stored in a file with extension &lt;code&gt;.script&lt;/code&gt;. The file has the following syntax:</source>
          <target state="translated">Сценарий загрузки хранится в файле с расширением &lt;code&gt;.script&lt;/code&gt; . Файл имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="41a09207a22769c0574e34261e0d72dca94a1cd1" translate="yes" xml:space="preserve">
          <source>The branches of an &lt;code&gt;if&lt;/code&gt;-expression are scanned sequentially until a guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; that evaluates to true is found. Then the corresponding &lt;code&gt;Body&lt;/code&gt; (sequence of expressions separated by ',') is evaluated.</source>
          <target state="translated">Ветви выражения &lt;code&gt;if&lt;/code&gt; сканируются последовательно до тех пор, пока не будет &lt;code&gt;GuardSeq&lt;/code&gt; защитная последовательность GuardSeq, которая оценивается как истина. Затем оценивается соответствующее &lt;code&gt;Body&lt;/code&gt; (последовательность выражений, разделенных символом &quot;,&quot;).</target>
        </trans-unit>
        <trans-unit id="c635f7fb465fc59e43a777e3d06741481d050b03" translate="yes" xml:space="preserve">
          <source>The browser must run as a separate OS process, otherwise VTS hangs.</source>
          <target state="translated">Браузер должен работать как отдельная операционная система,в противном случае VTS зависает.</target>
        </trans-unit>
        <trans-unit id="1acf68389c692a738d63487b4a06a4e7162935c1" translate="yes" xml:space="preserve">
          <source>The buffer pointed to by &lt;code&gt;v&lt;/code&gt; must be large enough to hold the return data, that is, it must be a pointer to one of &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt;, or &lt;code&gt;void*&lt;/code&gt;, respectively.</source>
          <target state="translated">Буфер, на который указывает &lt;code&gt;v&lt;/code&gt; , должен быть достаточно большим, чтобы содержать возвращаемые данные, то есть он должен быть указателем на одно из &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;char*&lt;/code&gt; или &lt;code&gt;void*&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="eaa6a3f621852e6e7b5c05f1f4dfe807f43eee5b" translate="yes" xml:space="preserve">
          <source>The build system, including cross compilation configuration variables used, may be subject to non backward compatible changes without prior notice. Current cross build system has been tested when cross compiling some Linux/GNU systems, but has only been partly tested for more esoteric platforms. The VxWorks example file is highly dependent on our environment and is here more or less only for internal use.</source>
          <target state="translated">Система сборки,включая используемые переменные конфигурации перекрестной компиляции,может быть подвержена изменениям,не совместимым с обратной связью,без предварительного уведомления.Текущая система кросс-компиляции была протестирована при кросс-компиляции некоторых Linux/GNU систем,но была протестирована только частично для более эзотерических платформ.Файл примера VxWorks сильно зависит от нашего окружения и здесь более или менее предназначен только для внутреннего использования.</target>
        </trans-unit>
        <trans-unit id="6fef17f4398287d703d6c8738ea77d284a4abce3" translate="yes" xml:space="preserve">
          <source>The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like &lt;code&gt;crypto:rand_seed/0&lt;/code&gt;.</source>
          <target state="translated">Алгоритмы встроенного генератора случайных чисел не являются криптостойкими. Если требуется криптостойкий генератор случайных чисел, используйте что-то вроде &lt;code&gt;crypto:rand_seed/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="067acc920ec0fee7fa628aac8051ca95ed671e0c" translate="yes" xml:space="preserve">
          <source>The busy message queue feature can be disabled either by setting the &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver, or by calling this function with &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; as a limit (either low or high). When this feature has been disabled, it cannot be enabled again. When reading the limits, both are &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; if this feature has been disabled.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt; очереди сообщений о занятости можно отключить, установив флаг &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; ERL_DRV_FLAG_NO_BUSY_MSGQ в &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; используемом драйвером, или вызвав эту функцию с &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; в качестве ограничения (низкого или высокого). Когда эта функция отключена, ее нельзя будет снова включить. При чтении пределов оба значения &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; , если эта функция отключена.</target>
        </trans-unit>
        <trans-unit id="33650cf8255f90c21ac81005064a8fbf5483e732" translate="yes" xml:space="preserve">
          <source>The button takes you to the code coverage overview page. If you have successfully performed a detailed coverage analysis, links to each individual module coverage page are found here.</source>
          <target state="translated">Кнопка переводит Вас на страницу обзора покрытия кода.В случае успешного проведения детального анализа покрытия,здесь Вы найдете ссылки на каждую страницу покрытия отдельного модуля.</target>
        </trans-unit>
        <trans-unit id="709ea736382b67af3f9c144683016c97550b6e99" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a code point in the invalid Unicode range.</source>
          <target state="translated">Байты декодируются в точку кода в некорректном диапазоне Юникода.</target>
        </trans-unit>
        <trans-unit id="276396b4a984d3ef578929de68a65d7f15a4afbf" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a too large number.</source>
          <target state="translated">Байты декодируются в слишком большое число.</target>
        </trans-unit>
        <trans-unit id="9be93d248e619868f8b04b5a5303526269804682" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt; crypto app's &lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953ab7ba3d595c2a841438d3ab4f4c182fb2eff6" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt;crypto app's&lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">Размер кеша можно изменить со значения по умолчанию с помощью параметра конфигурации &lt;code&gt;crypto app's&lt;/code&gt; &lt;code&gt;rand_cache_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba971c6589524e2b87b07ee118d11ab2b5ec5e2" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:call(Node, Module, Function, Args)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:call(Node, Module, Function, Args, infinity)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ca6b0dafdc23056fe13a565a84397b1490c9ec" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:call(Node,Fun)&lt;/code&gt; is the same as the call &lt;code&gt;erpc:call(Node,Fun,infinity)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5af71d5240d81c230e56c0fedb791afdbf3e003" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args, infinity)&lt;/code&gt;. These calls are also equivalent to calling &lt;code&gt;my_multicall(Nodes, Module, Function, Args)&lt;/code&gt; if one disregard performance and failure behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b9b9d99c8ecce8485a4983dcd83e4894a6b989" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:multicall(Nodes,Fun)&lt;/code&gt; is the same as the call &lt;code&gt;erpc:multicall(Nodes,Fun, infinity)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d0b458c6aae29c39ad3c25a6af2742eb4013be" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:receive_response(RequestId)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:receive_response(RequestId, infinity)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a152c6617bd51e1fb2b711ebf4373faae6094d4" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:wait_response(RequestId)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:wait_response(RequestId, 0)&lt;/code&gt;. That is, poll for a response message to a &lt;code&gt;call&lt;/code&gt; request previously made by the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f53eb411418a4e5fc2e2575c742546457d6c88" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_event:wait_response(gen_event:send_request(EventMgrRef,Handler,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_event:call(EventMgrRef,Handler,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d937cd40cd03a99573acdf02ba260b024e4d3ab" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_server:wait_response(gen_server:send_request(ServerRef,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_server:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff8030a297aeb35ab5d6884ca11e4edf2e73f36" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_statem:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e019f9fcd17a687470aea637478863f5e134cb3" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;module_info(Key)&lt;/code&gt;, where &lt;code&gt;Key&lt;/code&gt; is an atom, returns a single piece of information about the module.</source>
          <target state="translated">Вызов &lt;code&gt;module_info(Key)&lt;/code&gt; , где &lt;code&gt;Key&lt;/code&gt; - атом, возвращает единичную информацию о модуле.</target>
        </trans-unit>
        <trans-unit id="a72f41bd0ef1a660b71b19854f4a2f611d367c22" translate="yes" xml:space="preserve">
          <source>The call can also fail, for example, if the &lt;code&gt;gen_statem&lt;/code&gt; dies before or during this function call.</source>
          <target state="translated">Вызов также может завершиться неудачно, например, если &lt;code&gt;gen_statem&lt;/code&gt; умирает до или во время этого вызова функции.</target>
        </trans-unit>
        <trans-unit id="8367b12b1eaff6fc40fd96b320d7987c710ba242" translate="yes" xml:space="preserve">
          <source>The call can fail for many reasons, including time-out and the called &lt;code&gt;gen_server&lt;/code&gt; process dying before or during the call.</source>
          <target state="translated">Вызов может завершиться ошибкой по многим причинам, включая тайм-аут и завершение вызываемого процесса &lt;code&gt;gen_server&lt;/code&gt; до или во время вызова.</target>
        </trans-unit>
        <trans-unit id="4739e34ca18c32d95d687955ecad4a46982e910c" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are paused at their current count.</source>
          <target state="translated">Счетчики вызовов для всех соответствующих функций,у которых есть точки останова счета вызовов,приостанавливаются при их текущем количестве.</target>
        </trans-unit>
        <trans-unit id="52c5d88794b3b9c10b033bc03376b7dc1bc55692" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are set to zero and running.</source>
          <target state="translated">Счетчики вызовов для всех соответствующих функций,у которых есть точки останова счетчика вызовов,установлены на ноль и работают.</target>
        </trans-unit>
        <trans-unit id="fcd429bca91d28345133d5ddfc12f2039568c7e0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">Вызов завершается ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;Map1&lt;/code&gt; не является картой, или с исключением &lt;code&gt;{badkey,Key}&lt;/code&gt; , если с &lt;code&gt;Key&lt;/code&gt; не связано никакого значения .</target>
        </trans-unit>
        <trans-unit id="a765e0cc7b8afeedc4b406e029455c41a2e05717" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">Вызов завершается ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;Map1&lt;/code&gt; не является картой.</target>
        </trans-unit>
        <trans-unit id="3bcc437b0d2af2e5401d95afab2b22b04d0cd309" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; or &lt;code&gt;Map2&lt;/code&gt; is not a map.</source>
          <target state="translated">Вызов завершается ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;Map1&lt;/code&gt; или &lt;code&gt;Map2&lt;/code&gt; не являются картой.</target>
        </trans-unit>
        <trans-unit id="e5f8317a62b38be81b80524eaf41aa4ccce539a0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">Вызов завершается ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;Map&lt;/code&gt; не является картой, или с исключением &lt;code&gt;{badkey,Key}&lt;/code&gt; , если с &lt;code&gt;Key&lt;/code&gt; не связано значение .</target>
        </trans-unit>
        <trans-unit id="7b3d448e3253ce8fb6ba525c95cf4c520a4dd69a" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map.</source>
          <target state="translated">Вызов завершается ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;Map&lt;/code&gt; не является картой.</target>
        </trans-unit>
        <trans-unit id="16f4ecacaaaef2b7ebc1761887fc6a38ffe0b906" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">Вызов завершается ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;MapOrIter&lt;/code&gt; не является картой или допустимым итератором, или с &lt;code&gt;badarg&lt;/code&gt; , если &lt;code&gt;Fun&lt;/code&gt; не является функцией арности 2.</target>
        </trans-unit>
        <trans-unit id="12f759a8b6547e05c46e411430a759d92783001f" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 3.</source>
          <target state="translated">Вызов завершается ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;MapOrIter&lt;/code&gt; не является картой или допустимым итератором, или с &lt;code&gt;badarg&lt;/code&gt; , если &lt;code&gt;Fun&lt;/code&gt; не является функцией арности 3.</target>
        </trans-unit>
        <trans-unit id="ac940292242acb2f76654b1a0d7f61a1dafc1f65" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Pred&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">Вызов завершается с &lt;code&gt;{badmap,Map}&lt;/code&gt; исключением , если &lt;code&gt;MapOrIter&lt;/code&gt; не карта или действительный итератор, или с &lt;code&gt;badarg&lt;/code&gt; , если &lt;code&gt;Pred&lt;/code&gt; не является функцией арности 2.</target>
        </trans-unit>
        <trans-unit id="2892cf3454075f0053d7bd91a8d8a1dd21669320" translate="yes" xml:space="preserve">
          <source>The call format may be different if a customized prologue file has been included when generating the parser instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt;.</source>
          <target state="translated">Формат вызова может быть другим, если при создании анализатора был включен настраиваемый файл пролога вместо файла по умолчанию &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e8198892cee32a7b8526bf6bc65cdd83e83fc69" translate="yes" xml:space="preserve">
          <source>The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4:</source>
          <target state="translated">Вызов дает следующий результат,так как первая явно захваченная подмаска-&quot;(abcd)&quot;,совпадающая с &quot;abcd&quot; в субъекте,в (нулевой)позиции 3,длиной 4:</target>
        </trans-unit>
        <trans-unit id="daf666a091f35efff4124fee9f5b0c58cdf83623" translate="yes" xml:space="preserve">
          <source>The call is wrapped in a case statement and will be evaluated only if &lt;code&gt;Level&lt;/code&gt; is equal to or below the configured log level.</source>
          <target state="translated">Вызов заключен в оператор case и будет оцениваться только в том случае, если &lt;code&gt;Level&lt;/code&gt; равен или ниже настроенного уровня журнала.</target>
        </trans-unit>
        <trans-unit id="de78c6fd6e7546e57186f359788dd6c58cc04ff8" translate="yes" xml:space="preserve">
          <source>The call of this function will trigger the callback function UserMod:handle_connect/2 to be invoked. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">Вызов этой функции вызовет функцию обратного вызова UserMod:handle_connect/2.Дополнительную информацию об аргументах обратного вызова смотрите в модуле megaco_user.</target>
        </trans-unit>
        <trans-unit id="f6eff7cd52eb9afdfc9d628f7416b2b3d981918c" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;io:format/2&lt;/code&gt; will never be executed, but a return address will still be pushed to the stack each time &lt;code&gt;loop/0&lt;/code&gt; is called recursively. The correct tail-recursive version of the function looks as follows:</source>
          <target state="translated">Вызов &lt;code&gt;io:format/2&lt;/code&gt; никогда не будет выполнен, но адрес возврата все равно будет помещаться в стек каждый раз, когда &lt;code&gt;loop/0&lt;/code&gt; вызывается рекурсивно. Правильная хвостовая рекурсивная версия функции выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="69e4234e48da562de4b3fe66e96e15cc38ad9a57" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; must be made &lt;strong&gt;directly&lt;/strong&gt; from the Erlang code of the module that the NIF library belongs to. It returns either &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; if loading fails. &lt;code&gt;Reason&lt;/code&gt; is one of the following atoms while &lt;code&gt;Text&lt;/code&gt; is a human readable string that can give more information about the failure:</source>
          <target state="translated">Вызов &lt;code&gt;load_nif/2&lt;/code&gt; должен производиться &lt;strong&gt;непосредственно&lt;/strong&gt; из кода Erlang модуля, которому принадлежит библиотека NIF. Он возвращает либо &lt;code&gt;ok&lt;/code&gt; , либо &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; , если загрузка не удалась. &lt;code&gt;Reason&lt;/code&gt; - это один из следующих атомов, а &lt;code&gt;Text&lt;/code&gt; - это удобочитаемая строка, которая может предоставить дополнительную информацию о сбое:</target>
        </trans-unit>
        <trans-unit id="65c74848bb8184c1160ce5aeb1b1f12389a01cd3" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; was made from the old code of a module that has been upgraded; this is not allowed.</source>
          <target state="translated">Вызов &lt;code&gt;load_nif/2&lt;/code&gt; был сделан из старого кода модуля, который был обновлен; это не допускается.</target>
        </trans-unit>
        <trans-unit id="9645f8ce41967acca4649554ceab30271d3386df" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;return_trace&lt;/code&gt; results in a trace message when the function returns. It applies only to the specific function call triggering the match specification (and matching the head/guards of the match specification). This is by far the most common call in the body of a &lt;code&gt;dbg&lt;/code&gt; match specification.</source>
          <target state="translated">Вызов &lt;code&gt;return_trace&lt;/code&gt; приводит к сообщению трассировки, когда функция возвращается. Это применимо только к конкретному вызову функции, запускающему спецификацию соответствия (и совпадающему с заголовком / защитой спецификации соответствия). Это, безусловно, самый распространенный вызов в теле спецификации соответствия &lt;code&gt;dbg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92d19c83ca0b80ba803b67a868b3108e7fb7711b" translate="yes" xml:space="preserve">
          <source>The call to the analyze function must be as follows:</source>
          <target state="translated">Вызов функции анализа должен быть следующим:</target>
        </trans-unit>
        <trans-unit id="55e6d7779dabe02d283cfb249b485592e929b71e" translate="yes" xml:space="preserve">
          <source>The call will fail with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">Вызов завершится ошибкой с исключением &lt;code&gt;{badmap,Map}&lt;/code&gt; , если &lt;code&gt;Map1&lt;/code&gt; не является картой.</target>
        </trans-unit>
        <trans-unit id="fa1f952e3b1c0797c615bedda4b65ed54a10a69e" translate="yes" xml:space="preserve">
          <source>The call will return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the check. The caller do not need to handle the matching rules in the rfc. The matching will proceed as:</source>
          <target state="translated">Вызов вернет &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; зависимости от проверки. Вызывающей стороне не нужно обрабатывать правила сопоставления в RFC. Сопоставление будет происходить следующим образом:</target>
        </trans-unit>
        <trans-unit id="104de9fe47518d4f0de85d87c6a5c1db2f88d084" translate="yes" xml:space="preserve">
          <source>The call:</source>
          <target state="translated">Звонок:</target>
        </trans-unit>
        <trans-unit id="1514747db293879c8ce291ed88a8dae74c64014f" translate="yes" xml:space="preserve">
          <source>The callback function UserMod:handle_trans_reply/4 is invoked when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">Функция обратного вызова UserMod:handle_trans_reply/4 вызывается,когда приходит ответ,когда таймер запроса в конце концов таймаут или когда невыполненные запросы явно отменяются.Дополнительную информацию об аргументах обратного вызова смотрите в модуле megaco_user.</target>
        </trans-unit>
        <trans-unit id="e40447571e80d72283361f5ca0d8dcdb93fefaa2" translate="yes" xml:space="preserve">
          <source>The callback function handling the &lt;code&gt;stop&lt;/code&gt; request returns a tuple &lt;code&gt;{stop,normal,State1}&lt;/code&gt;, where &lt;code&gt;normal&lt;/code&gt; specifies that it is a normal termination and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;. This causes the &lt;code&gt;gen_server&lt;/code&gt; to call &lt;code&gt;terminate(normal, State1)&lt;/code&gt; and then it terminates gracefully.</source>
          <target state="translated">Функция обратного вызова, обрабатывающая запрос &lt;code&gt;stop&lt;/code&gt; возвращает кортеж &lt;code&gt;{stop,normal,State1}&lt;/code&gt; , где &lt;code&gt;normal&lt;/code&gt; указывает, что это нормальное завершение, а &lt;code&gt;State1&lt;/code&gt; - это новое значение для состояния &lt;code&gt;gen_server&lt;/code&gt; . Это заставляет &lt;code&gt;gen_server&lt;/code&gt; вызывать &lt;code&gt;terminate(normal, State1)&lt;/code&gt; а затем корректно завершается.</target>
        </trans-unit>
        <trans-unit id="728b1d3be49a797310af6aa94681789dfdda4be1" translate="yes" xml:space="preserve">
          <source>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors and so on. The function is not invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. However, it is invoked if the functions fail (crash).</source>
          <target state="translated">Ожидается,что функция обратного вызова очистит используемые ресурсы после прерванной передачи файлов,например,закроет открытые дескрипторы файлов и так далее.Функция не вызывается,если какая-либо из других функций обратного вызова возвращает ошибку,так как ожидается,что они уже очистили необходимые ресурсы.Однако она вызывается,если функции не работают (аварийно завершаются).</target>
        </trans-unit>
        <trans-unit id="109919e956ac7fc9c9c7ca8c3328e95855910a87" translate="yes" xml:space="preserve">
          <source>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</source>
          <target state="translated">Функция обратного вызова,как ожидается,закроет файл,когда будет найден последний файл.При возникновении ошибки функция обратного вызова,как ожидается,будет очищать после прерванной передачи файла,например,закрывать открытые дескрипторы файлов и т.д.В обоих случаях больше не будет вызовов ни одной из функций обратного вызова.</target>
        </trans-unit>
        <trans-unit id="84bacd9fc6215821a0c57cf0a99b64819b895b8b" translate="yes" xml:space="preserve">
          <source>The callback function is to be defined as follows:</source>
          <target state="translated">Функция обратного вызова должна быть определена следующим образом:</target>
        </trans-unit>
        <trans-unit id="898a8e55f83f4732a3d9a1c55861f5556e256a82" translate="yes" xml:space="preserve">
          <source>The callback function itself did the updates.</source>
          <target state="translated">Обновления производились самой функцией обратного вызова.</target>
        </trans-unit>
        <trans-unit id="1d90b6e19e5f31bc52641082a2d815396c2a8af1" translate="yes" xml:space="preserve">
          <source>The callback function to use. &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; are atoms and &lt;code&gt;Args&lt;/code&gt; is a list of terms. When an OS message &lt;code&gt;Msg&lt;/code&gt; is received, this function is called as &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt;.</source>
          <target state="translated">Используемая функция обратного вызова. &lt;code&gt;Module&lt;/code&gt; и &lt;code&gt;Function&lt;/code&gt; - это атомы, а &lt;code&gt;Args&lt;/code&gt; - это список терминов. Когда получено сообщение ОС &lt;code&gt;Msg&lt;/code&gt; , эта функция вызывается как &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf66fa0dd7df5d0912660af5ccc84e8028f914a6" translate="yes" xml:space="preserve">
          <source>The callback function works as described in &lt;code&gt;os_sup(3)&lt;/code&gt;.</source>
          <target state="translated">Функция обратного вызова работает, как описано в &lt;code&gt;os_sup(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ea45999ad4acd01ff35ccee071d905b456a15b2" translate="yes" xml:space="preserve">
          <source>The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt).</source>
          <target state="translated">Функции обратного вызова не могут быть использованы для разрешения или запрещения выполнения функций,вызываемых из скомпилированного кода (только функции,вызываемые из выражений,введенных в командной строке оболочки).</target>
        </trans-unit>
        <trans-unit id="96dd8e426598dea1368d28980aebceed3f1b20a0" translate="yes" xml:space="preserve">
          <source>The callback functions of the module can be specified either directly by the exported function &lt;code&gt;behaviour_info/1&lt;/code&gt;:</source>
          <target state="translated">Функции обратного вызова модуля могут быть указаны либо непосредственно экспортированной функцией &lt;code&gt;behaviour_info/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c0541a4b27e58b4de7bee93e3d77a109876a92d" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test &lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54dd23c9ceb4245139e54c85cd25b72ecec0fba9" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="translated">Функции обратного вызова, которые будут реализованы набором тестов, перечислены в модуле &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; . Они также описаны более подробно далее в этом Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="85791b6dc548416b6612b724000cfadda018f22a" translate="yes" xml:space="preserve">
          <source>The callback interface is based on that the user sends a fun with the correct signature to the parser.</source>
          <target state="translated">Интерфейс обратного вызова основан на том,что пользователь посылает развлечение с правильной подписью парсеру.</target>
        </trans-unit>
        <trans-unit id="59e965f4c45d1fd48637f0634a7fe7cb62c0c3bd" translate="yes" xml:space="preserve">
          <source>The callback interface of the transport module contains several functions. Some of which are mandatory while others are only optional:</source>
          <target state="translated">Интерфейс обратного вызова транспортного модуля содержит несколько функций.Некоторые из них являются обязательными,в то время как другие-только необязательными:</target>
        </trans-unit>
        <trans-unit id="cd251fb009bc0977864cd404e86e72a74db2ce5c" translate="yes" xml:space="preserve">
          <source>The callback is made by a middleman process, hence the file transfer is not affected by the code in the progress callback function. If the callback crashes, this is detected by the FTP connection process, which then prints an info-report and goes on as if the progress option was set to &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">Обратный вызов выполняется посредником, поэтому на передачу файла не влияет код функции обратного вызова выполнения. Если обратный вызов дает сбой, это обнаруживается процессом FTP-соединения, который затем распечатывает информационный отчет и продолжает работу, как если бы параметр выполнения был установлен на &lt;code&gt;ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8e4051d9662c60ffac0c38b92a0a52ef07de6ce" translate="yes" xml:space="preserve">
          <source>The callback mode &lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="translated">Режим обратного вызова &lt;code&gt;handle_event_function&lt;/code&gt; позволяет использовать неатомное состояние, как описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; , например, термин сложного состояния, такой как кортеж.</target>
        </trans-unit>
        <trans-unit id="b9074f752748f19027b380bf6c6083917557b4d1" translate="yes" xml:space="preserve">
          <source>The callback mode is selected at server start and may be changed with a code upgrade/downgrade.</source>
          <target state="translated">Режим обратного вызова выбирается при запуске сервера и может быть изменен при обновлении/откате кода.</target>
        </trans-unit>
        <trans-unit id="a1b667b206213a5b84a8db86f75c2c72599f104c" translate="yes" xml:space="preserve">
          <source>The callback mode is selected by implementing a mandatory callback function &lt;code&gt;Module:callback_mode()&lt;/code&gt; that returns one of the callback modes.</source>
          <target state="translated">Режим обратного вызова выбирается путем реализации обязательной функции обратного вызова &lt;code&gt;Module:callback_mode()&lt;/code&gt; которая возвращает один из режимов обратного вызова.</target>
        </trans-unit>
        <trans-unit id="1bae742a256a71cd7955e770e21832abee7463ec" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt; rewrite from &lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead6e2ff311fd428d1dc6968b3919ecff631ec58" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">Модель (-ы) обратного вызова для &lt;code&gt;gen_statem&lt;/code&gt; отличается от модели для &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; , но все еще довольно легко &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_fsm&lt;/code&gt; на &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd40cbe96a6a7878da940a8badb97c6c9caeb25" translate="yes" xml:space="preserve">
          <source>The callback module contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the callback module with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="translated">Модуль обратного вызова содержит функции, реализующие конечный автомат. Когда происходит событие, &lt;code&gt;gen_statem&lt;/code&gt; поведения gen_statem вызывает функцию в модуле обратного вызова с событием, текущим состоянием и данными сервера. Эта функция выполняет действия для этого события и возвращает новое состояние и данные сервера, а также действия, которые должен выполнить механизм поведения.</target>
        </trans-unit>
        <trans-unit id="abbecd682f4918a42592a94b71742e36915e1bab" translate="yes" xml:space="preserve">
          <source>The callback module does not have to access real &lt;code&gt;Mnesia&lt;/code&gt; tables, it is free to do whatever it wants as long as the callback interface is fulfilled.</source>
          <target state="translated">Модуль обратного вызова не должен обращаться к реальным таблицам &lt;code&gt;Mnesia&lt;/code&gt; , он может делать все, что захочет, пока выполняется интерфейс обратного вызова.</target>
        </trans-unit>
        <trans-unit id="8eb2d562d838a71a4ba446f4da81f7701d757f5f" translate="yes" xml:space="preserve">
          <source>The callback module for a supervisor starting the server from &lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; can look as follows:</source>
          <target state="translated">Модуль обратного вызова для супервизора, &lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; сервер из gen_server Behavior, может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="517a681e26aeb83ed7549fbd52cdab0059ff31b1" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to a file can look as follows:</source>
          <target state="translated">Модуль обратного вызова обработчика событий для записи сообщений об ошибках в файл может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="c7722a0fd22c0aced7aea92994c66dc97a4d0fdd" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to the terminal can look as follows:</source>
          <target state="translated">Модуль обратного вызова обработчика событий для записи сообщений об ошибках в терминал может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="344a5e28ddcbac85a390899bb7eafc0bb7e415bf" translate="yes" xml:space="preserve">
          <source>The callback module implementing the handler is responsible for checking the correctness of configuration strings.</source>
          <target state="translated">Модуль обратного вызова,реализующий обработчик,отвечает за проверку корректности строк конфигурации.</target>
        </trans-unit>
        <trans-unit id="97f313867ce48aba95bd9c378dbac9f612a9aacd" translate="yes" xml:space="preserve">
          <source>The callback module is used to check that the provided public key is one of the user's pre-stored. In case of the default callback module, the files &lt;code&gt;authorized_keys&lt;/code&gt; and &lt;code&gt;authorized_keys2&lt;/code&gt; are searched in a directory found in the following order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0838bae2efd3e8ec52bba36939ac5379dcb0f2" translate="yes" xml:space="preserve">
          <source>The callback module must implement the &lt;code&gt;tftp&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Модуль обратного вызова должен реализовывать поведение &lt;code&gt;tftp&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c16c7638772ec54a79c0e6462748feea41441fe" translate="yes" xml:space="preserve">
          <source>The callback module of the socket.</source>
          <target state="translated">Модуль обратного вызова розетки.</target>
        </trans-unit>
        <trans-unit id="8b2bd7c81f3fa7abf6044482ee91de57b2f57d61" translate="yes" xml:space="preserve">
          <source>The callback will be removed if the system reboots.</source>
          <target state="translated">Обратный вызов будет удален,если система перезагрузится.</target>
        </trans-unit>
        <trans-unit id="1a547d0b36068b79f0e702e418ab428ce5c3cc09" translate="yes" xml:space="preserve">
          <source>The called function &lt;code&gt;throw&lt;/code&gt;s a term that does &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;{'EXIT',_}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f852af73e27bcafb08e2076230e176b0693da4a5" translate="yes" xml:space="preserve">
          <source>The called function &lt;code&gt;throws&lt;/code&gt; a term that matches &lt;code&gt;{'EXIT', _}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352f667fc05f32e342942fb39e336eda11373186" translate="yes" xml:space="preserve">
          <source>The called function fails with an &lt;code&gt;error&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86af8fc0d6dc4ec61f07ecb92e7902186c04bb2" translate="yes" xml:space="preserve">
          <source>The called function fails with an &lt;code&gt;exit&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6c226767131f116119f4a068f6de4330aaa924" translate="yes" xml:space="preserve">
          <source>The called function returns a term that matches &lt;code&gt;{'EXIT', _}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa82d7675b5e6bd93834e8fd74a124b66bdd5d8" translate="yes" xml:space="preserve">
          <source>The called function returns normally with a term that does &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;{'EXIT',_}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cc105f61cd981bcf32511925e36d658bc51fff" translate="yes" xml:space="preserve">
          <source>The called hook function is to return a (possibly deep) list of characters. Function &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; is useful in a hook.</source>
          <target state="translated">Вызываемая функция ловушки должна возвращать (возможно, глубокий) список символов. Функция &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; полезна в хуке.</target>
        </trans-unit>
        <trans-unit id="dd19dd71cdd2bc7e1309239a2dc9ab10df17269d" translate="yes" xml:space="preserve">
          <source>The caller (of the discovery function) will make the needed updates later.</source>
          <target state="translated">Звонящий (из функции обнаружения)сделает необходимые обновления позже.</target>
        </trans-unit>
        <trans-unit id="524e0413b79c29af01dbca40fc74eeea51a2d73c" translate="yes" xml:space="preserve">
          <source>The caller can now make another call to the recv function and now expect data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be52289a60f89b006753632d58c58744da7ef87" translate="yes" xml:space="preserve">
          <source>The caller can then make another call to the recv function and now expect data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ead89ef805808ff104ff5c388ca47931019854a" translate="yes" xml:space="preserve">
          <source>The caller can use own extraction and matching rules. This is done with the two options &lt;code&gt;fqdn_fun&lt;/code&gt; and &lt;code&gt;match_fun&lt;/code&gt;.</source>
          <target state="translated">Вызывающий может использовать собственные правила извлечения и сопоставления. Это делается с помощью двух опций &lt;code&gt;fqdn_fun&lt;/code&gt; и &lt;code&gt;match_fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7fc9c78e44578fd025d978ee708e79b0fa261e4" translate="yes" xml:space="preserve">
          <source>The caller is now displayed in the &quot;additional message&quot; part of the trace output, and the following is displayed after a while:</source>
          <target state="translated">Теперь вызывающий абонент отображается в части &quot;дополнительное сообщение&quot; выхода трассировки,а через некоторое время на дисплее отображается следующее:</target>
        </trans-unit>
        <trans-unit id="c55c238696091394e0bd56b82b698a5c47bb3d12" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can set a limit on the number of times the internal match() function is called and on the maximum depth of recursive calls. These facilities are provided to catch runaway matches that are provoked by patterns with huge matching trees (a typical example is a pattern with nested unlimited repeats) and to avoid running out of system stack by too much recursion. When one of these limits is reached, &lt;code&gt;pcre_exec()&lt;/code&gt; gives an error return. The limits can also be set by items at the start of the pattern of the following forms:</source>
          <target state="translated">Вызывающий &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; может установить ограничение на количество вызовов внутренней функции match () и максимальную глубину рекурсивных вызовов. Эти средства предназначены для обнаружения случайных совпадений, которые вызваны шаблонами с огромными деревьями совпадений (типичным примером является шаблон с вложенными неограниченными повторами) и во избежание выхода из системного стека из-за слишком большой рекурсии. Когда достигается один из этих пределов, &lt;code&gt;pcre_exec()&lt;/code&gt; возвращает ошибку. Лимиты также могут быть установлены элементами в начале шаблона следующих форм:</target>
        </trans-unit>
        <trans-unit id="f03c64f9f710de5955e68843c690db2e8c0fc8ca" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;driver_create_port&lt;/code&gt; is allowed to manipulate the newly created port when &lt;code&gt;driver_create_port&lt;/code&gt; has returned. When &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; is used, the creating port is only allowed to manipulate the newly created port until the current driver callback, which was called by the emulator, returns.</source>
          <target state="translated">Вызывающему &lt;code&gt;driver_create_port&lt;/code&gt; разрешено манипулировать вновь созданным портом, когда &lt;code&gt;driver_create_port&lt;/code&gt; возвращается. Когда используется &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; , создаваемому порту разрешается управлять только что созданным портом до тех пор, пока не вернется текущий обратный вызов драйвера, который был вызван эмулятором.</target>
        </trans-unit>
        <trans-unit id="621fc2d91134d4db21b3517ae8ac3625fde2ce09" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">Вызывающий эту функцию является представителем &lt;code&gt;net_kernel&lt;/code&gt; (это может быть или не быть процессом, зарегистрированным как &lt;code&gt;net_kernel&lt;/code&gt; ) и в этом документе обозначен как &lt;code&gt;Kernel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80825902e9ea39352717e07e7e143bd52944e894" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;. When a connection has been accepted by the acceptor process, it needs to inform &lt;code&gt;Kernel&lt;/code&gt; about the accepted connection. This is done by passing a message on the form:</source>
          <target state="translated">Вызывающий эту функцию является представителем &lt;code&gt;net_kernel&lt;/code&gt; (это может быть или не быть процессом, зарегистрированным как &lt;code&gt;net_kernel&lt;/code&gt; ) и в этом документе обозначен как &lt;code&gt;Kernel&lt;/code&gt; . Когда соединение было принято принимающим процессом, он должен сообщить &lt;code&gt;Kernel&lt;/code&gt; о принятом соединении. Это делается путем передачи сообщения в форме:</target>
        </trans-unit>
        <trans-unit id="17dc5e2470f7e3eb401d50cfc358de49382160b2" translate="yes" xml:space="preserve">
          <source>The calling NIF must use the return value of &lt;code&gt;enif_schedule_nif&lt;/code&gt; as its own return value.</source>
          <target state="translated">Вызывающий NIF должен использовать возвращаемое значение &lt;code&gt;enif_schedule_nif&lt;/code&gt; как собственное возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="b39ce61a3bf5f9ff14b9a7cd2356d7e2ed9376ab" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is aborted and &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Вызывающий процесс не приостанавливается, если порт занят, вместо этого команда порта прерывается и возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0ba9d7309f260b173565ca438b3eeea1bd4473" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629c5b3b630ae0172907db307b7e38fd8b753106" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызывающий процесс не приостанавливается, если порт занят, вместо этого принудительно выполняется команда порта. Вызов завершается ошибкой с исключением &lt;code&gt;notsup&lt;/code&gt; , если драйвер порта не поддерживает это. Для получения дополнительной информации см. Флаг драйвера &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a1251fc069f821f07a282196dbe91995966e598" translate="yes" xml:space="preserve">
          <source>The calling process subscribes or unsubscribes to node status change messages. A &lt;code&gt;nodeup&lt;/code&gt; message is delivered to all subscribing processes when a new node is connected, and a &lt;code&gt;nodedown&lt;/code&gt; message is delivered when a node is disconnected.</source>
          <target state="translated">Вызывающий процесс подписывается или отменяет подписку на сообщения об изменении статуса узла. &lt;code&gt;nodeup&lt;/code&gt; сообщение доставляются все подписавшиеся процессы , когда новый узел подключен и &lt;code&gt;nodedown&lt;/code&gt; сообщение будет доставлено , когда узел отключен.</target>
        </trans-unit>
        <trans-unit id="3fd0eba81e7afeb40af7403b8df7ac0d5fe56351" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, &lt;code&gt;application&lt;/code&gt; configuration must be matched by corresponding &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; configuration, of *-Application-Id AVPs in particular.</source>
          <target state="translated">Возможности, объявленные узлом, должны соответствовать его настроенным приложениям. В частности, конфигурация &lt;code&gt;application&lt;/code&gt; должна соответствовать соответствующей конфигурации feature &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; , в частности AVP * -Application-Id.</target>
        </trans-unit>
        <trans-unit id="9f7b2ec0f22afdbc01fa422caed0e98c532f9b08" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, setting &lt;code&gt;applications&lt;/code&gt; on a transport typically implies having to set matching *-Application-Id AVPs in a &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; tuple.</source>
          <target state="translated">Возможности, объявленные узлом, должны соответствовать его настроенным приложениям. В частности, установка &lt;code&gt;applications&lt;/code&gt; на транспорт обычно подразумевает необходимость установки соответствующих AVP * -Application-Id в кортеже &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172ff57f871dcdd5d0b54942cc29dbee89bb8d9d" translate="yes" xml:space="preserve">
          <source>The capture tuple is built up as follows:</source>
          <target state="translated">Захватный кортеж построен следующим образом:</target>
        </trans-unit>
        <trans-unit id="734624d49a0e505e194d0a3e203f3707e0a9ce89" translate="yes" xml:space="preserve">
          <source>The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below.</source>
          <target state="translated">Случай усеченного UTF рассматривается специально,см.ниже параграф о неполных двоичных файлах.</target>
        </trans-unit>
        <trans-unit id="bf787b1c131df12f5b5608740bbea97ec8c5c67e" translate="yes" xml:space="preserve">
          <source>The cases are executed in a sequence as described in section &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; in section Dependencies Between Test Cases and Suites.</source>
          <target state="translated">Кейсы выполняются в последовательности, описанной в разделе &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; раздела Зависимости между тестовыми наборами и наборами.</target>
        </trans-unit>
        <trans-unit id="a67cf4e28458acef6485593f3479b26ebbee2e4f" translate="yes" xml:space="preserve">
          <source>The cases in the group are executed in random order.</source>
          <target state="translated">Случаи в группе выполняются в случайном порядке.</target>
        </trans-unit>
        <trans-unit id="79326758fa4216db5c43f358f0c9d48cf3066915" translate="yes" xml:space="preserve">
          <source>The center area of the main window contains the information tabs. Each tab displays information about a specific item or a list of items. Select a tab by clicking the tab title.</source>
          <target state="translated">В центральной области главного окна расположены информационные вкладки.На каждой вкладке отображается информация о конкретном товаре или список товаров.Выберите вкладку,щелкнув по ее заголовку.</target>
        </trans-unit>
        <trans-unit id="2e333bd4d7da78b5f5a1e212afc4f6afc672a38c" translate="yes" xml:space="preserve">
          <source>The certificate MUST allow the key to be used for signing with a signature scheme indicated in the client's &quot;signature_algorithms&quot;/&quot;signature_algorithms_cert&quot; extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b65e59eb08b76012cdc739d366b164e936d686" translate="yes" xml:space="preserve">
          <source>The certificate type MUST be X.509v3, unless explicitly negotiated otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136170ec67e23d4bdc746cf64630b0fc4f944a3d" translate="yes" xml:space="preserve">
          <source>The certificates MUST be signed using an acceptable signature algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4592ee81cac18e24ff040ed72913569d66a68da6" translate="yes" xml:space="preserve">
          <source>The certificates attributes are valid.</source>
          <target state="translated">Атрибуты сертификатов действительны.</target>
        </trans-unit>
        <trans-unit id="a7eaa8135e803f2fb327a77633a52bb48c129b5b" translate="yes" xml:space="preserve">
          <source>The chain consisted only of one self-signed certificate.</source>
          <target state="translated">Цепь состояла только из одного самоподписанного сертификата.</target>
        </trans-unit>
        <trans-unit id="0e0a9851e387d6b9bd8489d5d8385b78fdd1efbf" translate="yes" xml:space="preserve">
          <source>The change is permanent, as long as the log is not deleted. That means, the log size is remembered across reboots.</source>
          <target state="translated">Изменение является постоянным до тех пор,пока журнал не будет удален.Это означает,что размер лога запоминается при перезагрузках.</target>
        </trans-unit>
        <trans-unit id="209a620344bc5ac686ada38b14f368934eb2469b" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">Изменение вступит в силу после следующей проверки дискового пространства и не сохраняется. То есть в случае перезапуска процесса это значение забывается и будет использоваться значение по умолчанию. См. &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="7324d42150f9730491b8b6dcf07acbe2a4287488" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">Изменение вступит в силу после следующей проверки памяти и не является постоянным. То есть в случае перезапуска процесса это значение забывается и будет использоваться значение по умолчанию. См. &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="8308604a253081056bdf717b82fcf33a719c92f1" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">Изменение вступит в силу во время следующей проверки дискового пространства и не сохраняется. То есть в случае перезапуска процесса это значение забывается и будет использоваться значение по умолчанию. См. &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="d9ee001de4f9c2acc5f959f9da7fbe9021fe19db" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next periodic memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">Изменение вступит в силу во время следующей периодической проверки памяти и не является постоянным. То есть в случае перезапуска процесса это значение забывается и будет использоваться значение по умолчанию. См. &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="48592559cdd27064407e93ea03790b5d39d21da9" translate="yes" xml:space="preserve">
          <source>The change will take effect for the next memory check and is non-persistent. That is, in the case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">Изменение вступит в силу при следующей проверке памяти и не является постоянным. То есть в случае перезапуска процесса это значение забывается и будет использоваться значение по умолчанию. См. &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="8a55eac8fba728a49ba83a1ba16426f587e19122" translate="yes" xml:space="preserve">
          <source>The changes do not affect existing child processes. For example, changing the start function only specifies how the child process is to be restarted, if needed later on.</source>
          <target state="translated">Изменения не влияют на существующие детские процессы.Например,изменение функции запуска только определяет,как дочерний процесс должен быть перезапущен,если это необходимо позже.</target>
        </trans-unit>
        <trans-unit id="17ef826dd60e0b23be9ebb72e959e4616f5a6f10" translate="yes" xml:space="preserve">
          <source>The channel behavior sends a close message to the other side, if such a message has not already been sent. Then it terminates the channel with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Поведение канала отправляет сообщение о закрытии на другую сторону, если такое сообщение еще не было отправлено. Затем он завершает канал по &lt;code&gt;normal&lt;/code&gt; причине .</target>
        </trans-unit>
        <trans-unit id="2d0641d9544e5c0fe01329a75590e893fef99690" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Advanced Agent Topics&lt;/strong&gt; describes the more advanced agent related features of the SNMP development tool. The following topics are covered:</source>
          <target state="translated">В главе &amp;laquo; &lt;strong&gt;Темы для расширенных агентов&amp;raquo;&lt;/strong&gt; описываются более продвинутые функции средства разработки SNMP, связанные с агентом. Рассмотрены следующие темы:</target>
        </trans-unit>
        <trans-unit id="2e272ab9ddbed68131c16ba5014e291dc03d4f2d" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Audit Trail Log&lt;/strong&gt; describes the audit trail logging.</source>
          <target state="translated">В главе &lt;strong&gt;Журнал контрольного журнала&lt;/strong&gt; описывается ведение журнала контрольного журнала.</target>
        </trans-unit>
        <trans-unit id="3f08decf0e83874ab43a9d84e18e36f372618712" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Running the application&lt;/strong&gt; describes how the application is configured and started. The topics include:</source>
          <target state="translated">Глава &amp;laquo; &lt;strong&gt;Запуск приложения&amp;raquo;&lt;/strong&gt; описывает, как приложение настраивается и запускается. Темы включают:</target>
        </trans-unit>
        <trans-unit id="72b08f124553e2dc5540039b611421ca2a1cb7f5" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;The MIB Compiler&lt;/strong&gt; describes the MIB compiler and contains the following topics:</source>
          <target state="translated">Глава &lt;strong&gt;Компилятор MIB&lt;/strong&gt; описывает компилятор MIB и содержит следующие темы:</target>
        </trans-unit>
        <trans-unit id="d2d9fc11f8e7828565eb35f14517412a40b0d378" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;?&lt;/code&gt; can be added to the end of an operand to indicate that the operand will not be used every time the instruction is executed. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb91809478ddb72a376ffa2ae9889076265397b" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;C&lt;/code&gt; determines the type of control sequence to be used. It is the only required field. All of &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, &lt;code&gt;Pad&lt;/code&gt;, and &lt;code&gt;Mod&lt;/code&gt; are optional. For example, to use a &lt;code&gt;#&lt;/code&gt; for &lt;code&gt;Pad&lt;/code&gt; but use the default values for &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;, you can write &lt;code&gt;~..#C&lt;/code&gt;.</source>
          <target state="translated">Символ &lt;code&gt;C&lt;/code&gt; определяет тип используемой управляющей последовательности. Это единственное обязательное поле. Все &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; , &lt;code&gt;Pad&lt;/code&gt; и &lt;code&gt;Mod&lt;/code&gt; не являются обязательными. Например, чтобы использовать &lt;code&gt;#&lt;/code&gt; для &lt;code&gt;Pad&lt;/code&gt; , но использовать значения по умолчанию для &lt;code&gt;F&lt;/code&gt; и &lt;code&gt;P&lt;/code&gt; , вы можете написать &lt;code&gt;~..#C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d64a4036522ec8f78050362f7b7c36c9cac056c3" translate="yes" xml:space="preserve">
          <source>The character encoding used in strings and atoms. The only supported encoding is &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; for ISO Latin-1 (8-bit ASCII).</source>
          <target state="translated">Кодировка символов, используемая в строках и атомах. Единственная поддерживаемая кодировка - &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; для ISO Latin-1 (8-битный ASCII).</target>
        </trans-unit>
        <trans-unit id="9d193b1def3415cd7c10a5af19c4d201098e3350" translate="yes" xml:space="preserve">
          <source>The character encodings used for atoms. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; represents 7-bit ASCII. Latin-1 and UTF-8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters are valid Latin-1 and UTF-8 characters. ASCII and Latin-1 both represent each character by one byte. An UTF-8 character can consist of 1-4 bytes. Notice that these constants are bit-flags and can be combined with bitwise OR.</source>
          <target state="translated">Кодировки символов, используемые для атомов. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; представляет собой 7-битный ASCII. Latin-1 и UTF-8 - это разные расширения 7-битного ASCII. Все 7-битные символы ASCII являются допустимыми символами Latin-1 и UTF-8. И ASCII, и Latin-1 представляют каждый символ одним байтом. Символ UTF-8 может состоять из 1&amp;ndash;4 байтов. Обратите внимание, что эти константы являются битовыми флагами и могут быть объединены с помощью побитового ИЛИ.</target>
        </trans-unit>
        <trans-unit id="5bce2007ce7233de084f6c74cc17834bdadef1f7" translate="yes" xml:space="preserve">
          <source>The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V, \w, and \W can appear in a character class, and add the characters that they match to the class. For example, [\dABCDEF] matches any hexadecimal digit. In UTF modes, option &lt;code&gt;ucp&lt;/code&gt; affects the meanings of \d, \s, \w and their uppercase partners, just as it does when they appear outside a character class, as described in section &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; earlier. The escape sequence \b has a different meaning inside a character class; it matches the backspace character. The sequences \B, \N, \R, and \X are not special inside a character class. Like any other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and &quot;X&quot;.</source>
          <target state="translated">Управляющие последовательности символов \ d, \ D, \ h, \ H, \ p, \ P, \ s, \ S, \ v, \ V, \ w и \ W могут появляться в классе символов и добавлять персонажи, которые они соответствуют классу. Например, [\ dABCDEF] соответствует любой шестнадцатеричной цифре. В режимах UTF опция &lt;code&gt;ucp&lt;/code&gt; влияет на значения \ d, \ s, \ w и их партнеров в верхнем регистре, точно так же, как это происходит, когда они появляются вне класса символов, как описано ранее в разделе &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; . Управляющая последовательность \ b имеет другое значение внутри класса символов; он соответствует символу возврата. Последовательности \ B, \ N, \ R и \ X не являются специальными внутри класса символов. Как и любые другие нераспознанные escape-последовательности, они рассматриваются как буквальные символы &amp;laquo;B&amp;raquo;, &amp;laquo;N&amp;raquo;, &amp;laquo;R&amp;raquo; и &amp;laquo;X&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="89f86657075f7d2532ecb276650adc58a9119d7f" translate="yes" xml:space="preserve">
          <source>The character used as time designator, that is, the date and time separator. The default is &lt;code&gt;$T&lt;/code&gt;.</source>
          <target state="translated">Символ, используемый в качестве указателя времени, то есть разделитель даты и времени. По умолчанию &lt;code&gt;$T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d9d6c64abc51b03bd1675467e660789635b1bd" translate="yes" xml:space="preserve">
          <source>The characters in the line terminated by a line feed (or end of file). If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O device supports Unicode).</source>
          <target state="translated">Символы в строке завершаются переводом строки (или концом файла). Если устройство ввода-вывода поддерживает Unicode, данные могут представлять кодовые точки&amp;gt; 255 ( диапазон &lt;code&gt;latin1&lt;/code&gt; ). Если сервер ввода-вывода настроен на доставку двоичных файлов, они кодируются в UTF-8 (независимо от того, поддерживает ли устройство ввода-вывода Unicode).</target>
        </trans-unit>
        <trans-unit id="56bc68334532732a987644276bf7e27ba2ed6340" translate="yes" xml:space="preserve">
          <source>The characters in the name (if specified as a list) can only be &amp;gt; 255 if the Erlang virtual machine is started in Unicode filename translation mode. Otherwise the name of the executable is limited to the ISO Latin-1 character set.</source>
          <target state="translated">Количество символов в имени (если указано в виде списка) может быть&amp;gt; 255, только если виртуальная машина Erlang запущена в режиме преобразования имени файла Unicode. В противном случае имя исполняемого файла ограничено набором символов ISO Latin-1.</target>
        </trans-unit>
        <trans-unit id="4c340bb094927d6516a270b8c7260c59f1b0e9ac" translate="yes" xml:space="preserve">
          <source>The check for calls to undefined functions is an example of a predefined analysis, probably the most useful one. Other examples are the analyses that find unused local functions, or functions that call some given functions. See the &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; functions for a complete list of predefined analyses.</source>
          <target state="translated">Проверка вызовов неопределенных функций - это пример предопределенного анализа, вероятно, наиболее полезного. Другими примерами являются анализы, которые находят неиспользуемые локальные функции или функции, вызывающие определенные функции. См. Полный список предопределенных анализов в функциях &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5e1916c5d50a9c907628d5b592b7e3e35726d5e" translate="yes" xml:space="preserve">
          <source>The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This can occur when nodes go down or when a replica is deleted. Checkpoints are also deactivated with this function. &lt;code&gt;Name&lt;/code&gt; is the name of an active checkpoint.</source>
          <target state="translated">Контрольная точка автоматически деактивируется, если к некоторым из задействованных таблиц не прикреплен фиксатор. Это может произойти, когда узлы выходят из строя или когда реплика удаляется. Контрольные точки также отключаются с помощью этой функции. &lt;code&gt;Name&lt;/code&gt; - это имя активной контрольной точки.</target>
        </trans-unit>
        <trans-unit id="d9393d9861ac13bac497a84046277f971838af74" translate="yes" xml:space="preserve">
          <source>The checks performed before the boot script is generated can be extended with some cross reference checks by specifying option &lt;code&gt;exref&lt;/code&gt;. These checks are performed with the Xref tool. All applications, or the applications specified with &lt;code&gt;{exref,[App]}&lt;/code&gt;, are checked by Xref and warnings are issued for calls to undefined functions.</source>
          <target state="translated">Проверки, выполняемые перед созданием загрузочного скрипта, могут быть расширены некоторыми проверками перекрестных ссылок, указав параметр &lt;code&gt;exref&lt;/code&gt; . Эти проверки выполняются с помощью инструмента Xref. Все приложения или приложения, указанные с помощью &lt;code&gt;{exref,[App]}&lt;/code&gt; , проверяются с помощью Xref, и для вызовов неопределенных функций выдаются предупреждения.</target>
        </trans-unit>
        <trans-unit id="b71574456dfb07437b35ad062527dd44aa7aea5a" translate="yes" xml:space="preserve">
          <source>The child specification for a stopped child process is deleted with the following call:</source>
          <target state="translated">Спецификация дочернего процесса для остановленного дочернего процесса удаляется следующим вызовом:</target>
        </trans-unit>
        <trans-unit id="67c92024750696ea3d3e50b512e7251afc6c23fc" translate="yes" xml:space="preserve">
          <source>The children of a supervisor are defined as a list of &lt;strong&gt;child specifications&lt;/strong&gt;. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</source>
          <target state="translated">Потомки супервизора определяются как список &lt;strong&gt;дочерних спецификаций&lt;/strong&gt; . При запуске супервизора дочерние процессы запускаются слева направо в соответствии с этим списком. Когда супервизор завершает свою работу, он сначала завершает свои дочерние процессы в обратном порядке запуска, справа налево.</target>
        </trans-unit>
        <trans-unit id="51bde16b1e029fca3eb55c7bba60557bdc4ece36" translate="yes" xml:space="preserve">
          <source>The choice between stateful or stateless depends on the server requirements as the session tickets are opaque for the clients. Generally, stateful tickets are smaller and the server can guarantee that tickets are only used once. Stateless tickets contain additional data, require less storage on the server side, but they offer different guarantees against anti-replay. See also &lt;code&gt; Anti-Replay Protection in TLS 1.3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814de93894ad7aadf116db8d46dcb0a1a2f6a6fc" translate="yes" xml:space="preserve">
          <source>The choice of configuration alters the location and load order of the tables. The alternatives are as follows:</source>
          <target state="translated">Выбор конфигурации изменяет расположение и порядок загрузки таблиц.Альтернативные варианты выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="545828e5805f31f0b4dc4f2a83912e6bb6d32eb0" translate="yes" xml:space="preserve">
          <source>The choice of using a chunk or the filesystem is completely up to the language or library. In both cases, the documentation can be added or removed at any moment by stripping the &lt;code&gt;Docs&lt;/code&gt; chunk or by removing the doc/chunks directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfaabaea33a1559baea30876e0db48c230aa2c6c" translate="yes" xml:space="preserve">
          <source>The chosen solution is instead for tracing to use the technique of replication applied on the data structures for breakpoints. Two generations of breakpoints are kept and indentified by index of 0 and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e209681f18120979ec8cf62515a80ebbdd5369" translate="yes" xml:space="preserve">
          <source>The chunk size used by the Erlang fallback to send data. If using the fallback, set this to a value that comfortably fits in the systems memory. Default is 20 MB.</source>
          <target state="translated">Размер фрагмента,используемый Erlang fallback для отправки данных.Если используется fallback,установите это значение в значение,которое удобно помещается в системной памяти.По умолчанию 20 Мб.</target>
        </trans-unit>
        <trans-unit id="80fc5d4e3e9d8bfc9a8f58b63d628ca694feebf8" translate="yes" xml:space="preserve">
          <source>The ciphers &lt;code&gt;aes_cbc&lt;/code&gt;, &lt;code&gt;aes_cfb8&lt;/code&gt;, &lt;code&gt;aes_cfb128&lt;/code&gt;, &lt;code&gt;aes_ctr&lt;/code&gt;, &lt;code&gt;aes_ecb&lt;/code&gt;, &lt;code&gt;aes_gcm&lt;/code&gt; and &lt;code&gt;aes_ccm&lt;/code&gt; has no keylength in the &lt;code&gt;Type&lt;/code&gt; as opposed to for example &lt;code&gt;aes_128_ctr&lt;/code&gt;. They adapt to the length of the key provided in the encrypt and decrypt function. Therefor it is impossible to return a valid keylength in the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffd1151a2b3988ada1265de3c714b941ea9eba2" translate="yes" xml:space="preserve">
          <source>The ciphers are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b290d8f7cbf9ebc957458f968fe0fad53d55bb94" translate="yes" xml:space="preserve">
          <source>The circumflex and dollar metacharacters are zero-width assertions. That is, they test for a particular condition to be true without consuming any characters from the subject string.</source>
          <target state="translated">Циркумфлексные и долларовые мета-символы-это утверждения нулевой ширины.То есть они проверяют,что определенное условие является истинным,не потребляя никаких символов из предметной строки.</target>
        </trans-unit>
        <trans-unit id="5669e2ea35917008527e37b5ca4d88fc5112fe65" translate="yes" xml:space="preserve">
          <source>The classic edit-compile-bugfix cycle for Erlang is to edit the source file in an editor, save it to a file and switch to an Erlang shell. In the shell the compilation command is given. Should the compilation fail you have to bring out the editor and locate the correct line.</source>
          <target state="translated">Классический цикл редактирования-компиляции-отладки для Erlang заключается в редактировании исходного файла в редакторе,сохранении его в файл и переключении на оболочку Erlang.В оболочке дается команда компиляции.Если компиляция не удаётся,необходимо вывести редактор и найти нужную строку.</target>
        </trans-unit>
        <trans-unit id="fadd4266630fc260a3b4ea69de0cd9a6f41365a8" translate="yes" xml:space="preserve">
          <source>The classification of &lt;code&gt;cached_memory&lt;/code&gt; is changed. Also memory marked as reclaimable in the kernel slab allocator will be added to the value presented as &lt;code&gt;cached_memory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b037a6b9c798a6a67eb72fefb14eec4bbb6f1f1d" translate="yes" xml:space="preserve">
          <source>The client automatically retrieves the information from the new URI and returns that as the result, instead of a 30X-result code.</source>
          <target state="translated">Клиент автоматически извлекает информацию из нового URI и возвращает ее в результате,вместо 30X-результатного кода.</target>
        </trans-unit>
        <trans-unit id="1fbe84685ac1a559531b7c36291fb36841fab94a" translate="yes" xml:space="preserve">
          <source>The client can be stopped using &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; or &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt;.</source>
          <target state="translated">Клиент может быть остановлен с помощью &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; или &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="569ccd940c4f6a817b12bba1b1067ae1a9656ffb" translate="yes" xml:space="preserve">
          <source>The client can choose to accept some path evaluation errors, for example, a web browser can ask the user whether to accept an unknown CA root certificate. The server, if it requests a certificate, does however not accept any path validation errors. It is configurable if the server is to accept or reject an &quot;empty&quot; certificate as response to a certificate request.</source>
          <target state="translated">Клиент может принять некоторые ошибки оценки путей,например,веб-браузер может спросить пользователя,принимать ли неизвестный корневой сертификат CA.Однако сервер,если он запрашивает сертификат,не принимает никаких ошибок проверки пути.Его можно настроить,если сервер должен принять или отклонить &quot;пустой&quot; сертификат в качестве ответа на запрос сертификата.</target>
        </trans-unit>
        <trans-unit id="1e096fcf12a451f0d8ba37109ec7b8520e84ee7a" translate="yes" xml:space="preserve">
          <source>The client checks that the host that presented the public key also possesses the private key of the key-pair. That check is part of the SSH protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b412fb6f7f703ee2ef8dff66ba99951cf7089b" translate="yes" xml:space="preserve">
          <source>The client is any Erlang process wishing to read or write data from/to the I/O device.</source>
          <target state="translated">Клиентом является любой процесс Erlang,желающий прочитать или записать данные с/на устройство ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="c1f2e8007b5292b585147076187f8ae466cd3c94" translate="yes" xml:space="preserve">
          <source>The client processes has done some illegal operation.</source>
          <target state="translated">Клиентские процессы совершили какую-то незаконную операцию.</target>
        </trans-unit>
        <trans-unit id="9a26517024410b148cd294e33b877a64e550bcc2" translate="yes" xml:space="preserve">
          <source>The client remote username (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Имя удаленного пользователя клиента ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="356415a70bf38190d536fb632c94227dca734486" translate="yes" xml:space="preserve">
          <source>The client remote username (&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41327174b5c9bc729859a7f6bf3b5c175db7b9d0" translate="yes" xml:space="preserve">
          <source>The client sends an &lt;code&gt;io_request&lt;/code&gt; tuple to the I/O server and the server eventually sends a corresponding &lt;code&gt;io_reply&lt;/code&gt; tuple.</source>
          <target state="translated">Клиент отправляет кортеж &lt;code&gt;io_request&lt;/code&gt; серверу ввода-вывода, а сервер в конечном итоге отправляет соответствующий кортеж &lt;code&gt;io_reply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f8f061d93662344f07374622d9a9f5570dc6915" translate="yes" xml:space="preserve">
          <source>The client sends the message to the server by:</source>
          <target state="translated">Клиент отправляет сообщение на сервер:</target>
        </trans-unit>
        <trans-unit id="072bdecf1b9485830f32e0b9aaa2f2cd201b4643" translate="yes" xml:space="preserve">
          <source>The client supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">Клиент поддерживает IPv6 до тех пор,пока это делают основные механизмы.</target>
        </trans-unit>
        <trans-unit id="f39527c54a4e7962b71c62198072191bb4f4c11d" translate="yes" xml:space="preserve">
          <source>The client will send a signature_algorithms_cert extension (ClientHello), if TLS version 1.3 or later is used, and the signature_algs_cert option is explicitly specified. By default, only the signature_algs extension is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5795d28810329b4419d272a646663a21aa527543" translate="yes" xml:space="preserve">
          <source>The client-server model is characterized by a central server and an arbitrary number of clients. The client-server model is used for resource management operations, where several different clients want to share a common resource. The server is responsible for managing this resource.</source>
          <target state="translated">Клиент-серверная модель характеризуется центральным сервером и произвольным количеством клиентов.Клиент-серверная модель используется для операций управления ресурсами,когда несколько различных клиентов хотят иметь общий ресурс.Сервер отвечает за управление этим ресурсом.</target>
        </trans-unit>
        <trans-unit id="b8d268ee82b336a5c95688dda8482335e48cf69d" translate="yes" xml:space="preserve">
          <source>The clients ip address.</source>
          <target state="translated">ip-адрес клиента.</target>
        </trans-unit>
        <trans-unit id="a98219544eb3eff51a663b1a744e3bf13062abc6" translate="yes" xml:space="preserve">
          <source>The clock starts ticking when the request is sent.</source>
          <target state="translated">Часы начинают тикать при отправке запроса.</target>
        </trans-unit>
        <trans-unit id="be435ecc0cf1fa1a9c98c5cd0695f7dfa36eec57" translate="yes" xml:space="preserve">
          <source>The clone of the SSL application must enable the use of the SSL code in such an early bootstage as needed to set up the distribution. However, this makes it impossible to soft upgrade the SSL application.</source>
          <target state="translated">Клон SSL-приложения должен позволять использование SSL-кода в таких ранних загрузках,которые необходимы для настройки дистрибутива.Однако это делает невозможным мягкое обновление SSL-приложения.</target>
        </trans-unit>
        <trans-unit id="d756129312a76f266001381d64eeed8865f4919a" translate="yes" xml:space="preserve">
          <source>The code for a module can exist in two variants in a system: &lt;strong&gt;current code&lt;/strong&gt; and &lt;strong&gt;old code&lt;/strong&gt;. When a module is loaded into the system for the first time, the module code becomes 'current' and the global &lt;strong&gt;export table&lt;/strong&gt; is updated with references to all functions exported from the module.</source>
          <target state="translated">Код для модуля может существовать в системе в двух вариантах: &lt;strong&gt;текущий код&lt;/strong&gt; и &lt;strong&gt;старый код&lt;/strong&gt; . Когда модуль загружается в систему в первый раз, код модуля становится &amp;laquo;текущим&amp;raquo;, а глобальная &lt;strong&gt;таблица экспорта&lt;/strong&gt; обновляется ссылками на все функции, экспортированные из модуля.</target>
        </trans-unit>
        <trans-unit id="e2397fc7367abe891aaddea1acfb84a0e33bbb71" translate="yes" xml:space="preserve">
          <source>The code for the server can be rewritten into a generic part &lt;code&gt;server.erl&lt;/code&gt;:</source>
          <target state="translated">Код для сервера можно переписать в общую часть &lt;code&gt;server.erl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e4cf743be10d1f78796a8520fbbc62b88613fb4" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;error_handler&lt;/code&gt; is complex. Do not change it without fully understanding the interaction between the error handler, the &lt;code&gt;init&lt;/code&gt; process of the code server, and the I/O mechanism of the code.</source>
          <target state="translated">Код в &lt;code&gt;error_handler&lt;/code&gt; сложный. Не изменяйте его без полного понимания взаимодействия между обработчиком ошибок, процессом &lt;code&gt;init&lt;/code&gt; сервера кода и механизмом ввода-вывода кода.</target>
        </trans-unit>
        <trans-unit id="90cb7656e2a78a30cae10868a6acccf8aa88d091" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;server&lt;/code&gt; can be reused to build many different servers.</source>
          <target state="translated">Код на &lt;code&gt;server&lt;/code&gt; можно повторно использовать для создания множества различных серверов.</target>
        </trans-unit>
        <trans-unit id="04225ffb5d1e2cd3c54d5a022ccc010d6c271db5" translate="yes" xml:space="preserve">
          <source>The code is available in &lt;code&gt;pg_sync.c&lt;/code&gt; in the &lt;code&gt;sample&lt;/code&gt; directory of &lt;code&gt;erts&lt;/code&gt;.</source>
          <target state="translated">Код доступен в &lt;code&gt;pg_sync.c&lt;/code&gt; в &lt;code&gt;sample&lt;/code&gt; директории &lt;code&gt;erts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9264957f8945993653ce298e5c1234e15d08f23" translate="yes" xml:space="preserve">
          <source>The code is explained in the next sections.</source>
          <target state="translated">Код объясняется в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="0e3333c77c7ae219d3009900b602e3b49e21c916" translate="yes" xml:space="preserve">
          <source>The code is straightforward: all communication between Erlang and the driver is done with &lt;code&gt;port_control/3&lt;/code&gt;, and the driver returns data back using the &lt;code&gt;rbuf&lt;/code&gt;.</source>
          <target state="translated">Код прост: вся связь между Erlang и драйвером осуществляется с помощью &lt;code&gt;port_control/3&lt;/code&gt; , а драйвер возвращает данные с помощью &lt;code&gt;rbuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f043529a1b5d337526e7bf30093ae19b9989356b" translate="yes" xml:space="preserve">
          <source>The code must return:</source>
          <target state="translated">Код должен вернуться:</target>
        </trans-unit>
        <trans-unit id="507745f725c946f3bb38fa59ee9580fa6d304cd3" translate="yes" xml:space="preserve">
          <source>The code of a module can exist in two variants in a system: &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;. When a module is loaded into the system for the first time, the code becomes 'current'. If then a new instance of the module is loaded, the code of the previous instance becomes 'old' and the new instance becomes 'current'.</source>
          <target state="translated">Код модуля может существовать в системе в двух вариантах: &lt;strong&gt;текущий&lt;/strong&gt; и &lt;strong&gt;старый&lt;/strong&gt; . Когда модуль загружается в систему впервые, код становится &amp;laquo;текущим&amp;raquo;. Если затем загружается новый экземпляр модуля, код предыдущего экземпляра становится &amp;laquo;старым&amp;raquo;, а новый экземпляр становится &amp;laquo;текущим&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="922b2eb4a931c1204aa3e51a063d0b9c833303d1" translate="yes" xml:space="preserve">
          <source>The code path can be extended by using the command-line flags &lt;code&gt;-pa Directories&lt;/code&gt; and &lt;code&gt;-pz Directories&lt;/code&gt;. These add &lt;code&gt;Directories&lt;/code&gt; to the head or the end of the code path, respectively. Example:</source>
          <target state="translated">Путь к коду можно расширить с помощью флагов командной строки &lt;code&gt;-pa Directories&lt;/code&gt; и &lt;code&gt;-pz Directories&lt;/code&gt; . Они добавляют &lt;code&gt;Directories&lt;/code&gt; в начало или конец пути кода соответственно. Пример:</target>
        </trans-unit>
        <trans-unit id="9688469fe16d88facce2f69f4687ce1df4ec41a4" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt; System Principles &lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f2de033652fb4852b04d98599da41645cd5418" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt;System Principles&lt;/code&gt;.</source>
          <target state="translated">Сервер кода загружает код в соответствии со стратегией загрузки кода, которая может быть &lt;strong&gt;интерактивной&lt;/strong&gt; (по умолчанию) или &lt;strong&gt;встроенной&lt;/strong&gt; . В интерактивном режиме код ищется в &lt;strong&gt;пути кода&lt;/strong&gt; и загружается при первом обращении. Во встроенном режиме код загружается при запуске в соответствии со &lt;strong&gt;сценарием загрузки&lt;/strong&gt; . Это описано в &lt;code&gt;System Principles&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c79fc2d0738d58b971f65c1fecd5a663cbf7ff9" translate="yes" xml:space="preserve">
          <source>The code server module &lt;code&gt;code&lt;/code&gt; contains a number of functions for modifying and checking the search path, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">Код модуля сервера &lt;code&gt;code&lt;/code&gt; содержит ряд функций для изменения и проверки пути поиска, см. Справочную страницу &lt;code&gt;code(3)&lt;/code&gt; в ядре.</target>
        </trans-unit>
        <trans-unit id="33c6dc6ea8623b6f6923c8e2b31c4332f8ba122e" translate="yes" xml:space="preserve">
          <source>The code server uses &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; to find the directory of the current (latest) version of Kernel, and then the subdirectory &lt;code&gt;include&lt;/code&gt; is searched for the file &lt;code&gt;file.hrl&lt;/code&gt;.</source>
          <target state="translated">Сервер кода использует &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; чтобы найти каталог с текущей (последней) версией ядра, а затем в подкаталоге &lt;code&gt;include&lt;/code&gt; выполняется поиск файла &lt;code&gt;file.hrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="705518a26a45215c147f7cfa28bbb3c76f850d6e" translate="yes" xml:space="preserve">
          <source>The code server uses module &lt;code&gt;erl_prim_loader&lt;/code&gt; in ERTS (possibly through &lt;code&gt;erl_boot_server&lt;/code&gt;) to read code files from archives. However, the functions in &lt;code&gt;erl_prim_loader&lt;/code&gt; can also be used by other applications to read files from archives. For example, the call &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; would list the contents of a directory inside an archive. See &lt;code&gt;erl_prim_loader(3)&lt;/code&gt;.</source>
          <target state="translated">Сервер кода использует модуль &lt;code&gt;erl_prim_loader&lt;/code&gt; в ERTS (возможно, через &lt;code&gt;erl_boot_server&lt;/code&gt; ) для чтения файлов кода из архивов. Однако функции в &lt;code&gt;erl_prim_loader&lt;/code&gt; также могут использоваться другими приложениями для чтения файлов из архивов. Например, вызов &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; перечислит содержимое каталога внутри архива. См. &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b81d555b71a144677a82f4345434092ac25f42ef" translate="yes" xml:space="preserve">
          <source>The code that creates a process that runs this tracer function and sets that process as the system tracer can look like this:</source>
          <target state="translated">Код,создающий процесс,который выполняет эту функцию трассировки и устанавливает этот процесс в качестве системного трассировщика,может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="01443bf8a10ddd3106bef27d3577d522575836f5" translate="yes" xml:space="preserve">
          <source>The code that executes inside the activity can consist of a series of table manipulation functions, which are performed in an &lt;code&gt;AccessContext&lt;/code&gt;. Currently, the following access contexts are supported:</source>
          <target state="translated">Код, выполняемый внутри действия, может состоять из серии функций управления таблицами, которые выполняются в &lt;code&gt;AccessContext&lt;/code&gt; . В настоящее время поддерживаются следующие контексты доступа:</target>
        </trans-unit>
        <trans-unit id="84b1eccbd4506c4d8f052231d9e0606cf91a8b80" translate="yes" xml:space="preserve">
          <source>The code that executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is terminated and the function &lt;code&gt;transaction/1&lt;/code&gt; returns the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;.</source>
          <target state="translated">Код, выполняемый внутри транзакции, может состоять из серии функций управления таблицами. Если что-то пойдет не так внутри транзакции в результате ошибки пользователя или недоступности определенной таблицы, вся транзакция завершается, а функция &lt;code&gt;transaction/1&lt;/code&gt; возвращает кортеж &lt;code&gt;{aborted, Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0cdd80f24fdd34e8443becb251df980268f8ee4" translate="yes" xml:space="preserve">
          <source>The code uses the &lt;code&gt;OTP_RELEASE&lt;/code&gt; macro to conditionally select code depending on release.</source>
          <target state="translated">Код использует макрос &lt;code&gt;OTP_RELEASE&lt;/code&gt; для условного выбора кода в зависимости от выпуска.</target>
        </trans-unit>
        <trans-unit id="30306274860dd65567cf17418a71525ff9fb2984" translate="yes" xml:space="preserve">
          <source>The code write permission &quot;lock&quot; seized in step 1 is the same as used by code loading. This will ensure that only one process at a time can stage new trace settings but it will also prevent concurrent code loading and make sure we see a consistent view of the beam code during the entire sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9b7b5c18b986e4dcb6724716523fe3e0859402" translate="yes" xml:space="preserve">
          <source>The codec name is the name of the codec with which all messages in the &lt;code&gt;message_list()&lt;/code&gt; has been encoded.</source>
          <target state="translated">Имя кодека - это имя кодека, с помощью которого были закодированы все сообщения в &lt;code&gt;message_list()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95a66f00b0729fc83f03c227254f16b97fe36011" translate="yes" xml:space="preserve">
          <source>The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="translated">Коды называются &lt;code&gt;SSH_FX_*&lt;/code&gt; , которые преобразуются в нижний регистр звездочки. Например, код ошибки &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; приведет к тому, что &lt;code&gt;reason()&lt;/code&gt; будет &lt;code&gt;no_such_file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17206be2c27dcf13c38e698754daddf2e853496a" translate="yes" xml:space="preserve">
          <source>The collector collects trace events and keeps them ordered by their timestamp. The timestamp may either reflect the time when the actual trace data was generated (trace_ts) or when the trace data was transformed into an event record (event_ts). If the time stamp is missing in the trace data (missing timestamp option to erlang:trace/4) the trace_ts will be set to the event_ts.</source>
          <target state="translated">Коллекционер собирает следовые события и упорядочивает их по временным меткам.Метка времени может отражать либо время,когда были сгенерированы фактические данные трассы (trace_ts),либо время,когда данные трассы были преобразованы в запись события (event_ts).Если метка времени в данных трассы отсутствует (опция пропущенная метка времени erlang:trace/4),то trace_ts будет установлена на event_ts.</target>
        </trans-unit>
        <trans-unit id="351503ceae71d258dda945d06961ceabf3006742" translate="yes" xml:space="preserve">
          <source>The collector has a built-in dictionary service. Any term may be stored as value in the dictionary and bound to a unique key. When new values are inserted with an existing key, the new values will overwrite the existing ones. Processes may subscribe on dictionary updates by using {subscriber, pid()} as dictionary key. All dictionary updates will be propagated to the subscriber processes matching the pattern {{subscriber, '_'}, '_'} where the first '_' is interpreted as a pid().</source>
          <target state="translated">Коллектор имеет встроенную словарную службу.Любой термин может быть сохранен в качестве значения в словаре и привязан к уникальному ключу.При вставке новых значений существующим ключом новые значения будут перезаписывать существующие.Процессы могут подписываться на обновления словаря,используя {подписчик,pid()}в качестве ключа словаря.Все обновления словаря будут распространяться на процессы подписчика,соответствующие шаблону {{subscriber,'_'},'_'},где первая '_' интерпретируется как pid().</target>
        </trans-unit>
        <trans-unit id="aa24630865ec2d27852697992e86dceb8f652e0b" translate="yes" xml:space="preserve">
          <source>The column where the token begins.</source>
          <target state="translated">Колонка,где начинается жетон.</target>
        </trans-unit>
        <trans-unit id="630fd19e25bb44d0c633fc41e9f2c893976f1cf6" translate="yes" xml:space="preserve">
          <source>The columns are: CNT - the number of times the function has been called, ACC - the time spent in the function including called functions, and OWN - the time spent in the function not including called functions.</source>
          <target state="translated">Колонны:CNT-количество вызовов функции,ACC-время,проведенное в функции,включая вызовы функций,и OWN-время,проведенное в функции,не включая вызовы функций.</target>
        </trans-unit>
        <trans-unit id="dba186e396734b41173da2352f4bdf8aa2299d12" translate="yes" xml:space="preserve">
          <source>The combined size of message buffers associated with the process.</source>
          <target state="translated">Общий размер буферов сообщений,связанных с процессом.</target>
        </trans-unit>
        <trans-unit id="cd9eaf4fbf041c4980649b3adc6f08d99e41387b" translate="yes" xml:space="preserve">
          <source>The command for starting the emulator. Defaults to &lt;code&gt;erl&lt;/code&gt; in the same directory as the &lt;code&gt;erlc&lt;/code&gt; program itself, or, if it does not exist, &lt;code&gt;erl&lt;/code&gt; in any of the directories specified in environment variable &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">Команда для запуска эмулятора. По умолчанию &lt;code&gt;erl&lt;/code&gt; находится в том же каталоге, что и &lt;code&gt;erlc&lt;/code&gt; программа erlc , или, если он не существует, &lt;code&gt;erl&lt;/code&gt; в любом из каталогов, указанных в переменной среды &lt;code&gt;PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb6501b3dc9f9f189fcbf95012d0127834e2f9cf" translate="yes" xml:space="preserve">
          <source>The command routine takes three parameters; the handle returned for the port by &lt;code&gt;uds_start&lt;/code&gt;, which is a pointer to the internal port structure, the data buffer, and the length of the data buffer. The buffer is the data sent from Erlang (a list of bytes) converted to an C array (of bytes).</source>
          <target state="translated">Командная программа принимает три параметра; дескриптор порта, &lt;code&gt;uds_start&lt;/code&gt; , который является указателем на внутреннюю структуру порта, буфер данных и длину буфера данных. Буфер - это данные, отправленные из Erlang (список байтов), преобразованные в массив C (байтов).</target>
        </trans-unit>
        <trans-unit id="aefc7b65db056c9f7f1b6802b3b0d8045a51356b" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the SSL/TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="translated">Аргумент командной строки для указания параметров SSL / TLS называется &lt;code&gt;-ssl_dist_opt&lt;/code&gt; , за ним должны следовать пары параметров SSL и их значения. Аргумент &lt;code&gt;-ssl_dist_opt&lt;/code&gt; может повторяться любое количество раз.</target>
        </trans-unit>
        <trans-unit id="feabeafa48780ef513e8f91d43f78fb2ecb53e4a" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef15ee0f0b965418b78c604ce208be1ebb9ac987" translate="yes" xml:space="preserve">
          <source>The command-line flag &lt;code&gt;-init_debug&lt;/code&gt; makes the &lt;code&gt;init&lt;/code&gt; process write some debug information while interpreting the boot script:</source>
          <target state="translated">Флаг командной строки &lt;code&gt;-init_debug&lt;/code&gt; заставляет процесс &lt;code&gt;init&lt;/code&gt; записывать некоторую отладочную информацию при интерпретации сценария загрузки:</target>
        </trans-unit>
        <trans-unit id="b095d3532fdf5b6b34b9ca43172bd2a70ed42870" translate="yes" xml:space="preserve">
          <source>The commands below are the built-in shell commands that are always available. In most system the commands listed in the &lt;code&gt;&lt;a href=&quot;c&quot;&gt;c(3)&lt;/a&gt;&lt;/code&gt; module are also available in the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c50b8e09545158899f6b79057dc3ebb405cca8" translate="yes" xml:space="preserve">
          <source>The comment for &lt;code&gt;driver_output_binary&lt;/code&gt; also applies for &lt;code&gt;driver_outputv&lt;/code&gt;.</source>
          <target state="translated">Комментарий для &lt;code&gt;driver_output_binary&lt;/code&gt; также применяется для &lt;code&gt;driver_outputv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1280084aa272a9d5d8e48fb9a3f8a4bc2a35a205" translate="yes" xml:space="preserve">
          <source>The comment for the file in the zip archive</source>
          <target state="translated">Комментарий к файлу в zip-архиве</target>
        </trans-unit>
        <trans-unit id="576cdebf96e8a6e4c9f5687b31e5fae369f7ae54" translate="yes" xml:space="preserve">
          <source>The common I/O protocol has been present in OTP since the beginning, but has been undocumented and has also evolved over the years. In an addendum to Robert Virding's rationale, the original I/O protocol is described. This section describes the current I/O protocol.</source>
          <target state="translated">Общий протокол ввода/вывода присутствовал в OTP с самого начала,но не был документирован и также развивался на протяжении многих лет.В дополнении к обоснованию Роберта Вирдинга (Robert Virding)описывается исходный протокол ввода/вывода.В этом разделе описывается текущий протокол ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="615ef8c10dad53dc0e37ab3cc2865c03f16fe578" translate="yes" xml:space="preserve">
          <source>The communication protocol between sub-agents is the normal message passing which is used in distributed Erlang systems. This implies that sub-agent communication is very efficient compared to SMUX, DPI, AgentX, and similar protocols.</source>
          <target state="translated">Протокол связи между субагентами-это обычная передача сообщений,которая используется в распределенных системах Erlang.Это означает,что связь между субагентами очень эффективна по сравнению с SMUX,DPI,AgentX и аналогичными протоколами.</target>
        </trans-unit>
        <trans-unit id="95e038ffe06742bd9a3eacaa7f1ab1768afde277" translate="yes" xml:space="preserve">
          <source>The community information should be stored in a file called &lt;code&gt;community.conf&lt;/code&gt;. It must be present if the agent is configured for SNMPv1 or SNMPv2c.</source>
          <target state="translated">Информация о сообществе должна храниться в файле с именем &lt;code&gt;community.conf&lt;/code&gt; . Он должен присутствовать, если агент настроен для SNMPv1 или SNMPv2c.</target>
        </trans-unit>
        <trans-unit id="ae1b5318f7be646ee745ed8d6cfbf8aaace9d57c" translate="yes" xml:space="preserve">
          <source>The compilation option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the compiler to have the abstract code stored in the &lt;code&gt;abstract_code&lt;/code&gt; chunk in the Beam file (for debugging purposes).</source>
          <target state="translated">Параметр компиляции &lt;code&gt;debug_info&lt;/code&gt; может быть указан для компилятора, чтобы абстрактный код сохранялся в блоке &lt;code&gt;abstract_code&lt;/code&gt; в файле Beam (для целей отладки).</target>
        </trans-unit>
        <trans-unit id="63df141c1104124fe397af774c48987f851c9c8e" translate="yes" xml:space="preserve">
          <source>The compile server can be used to potentially speed up the build of multi-file projects by avoiding to start an Erlang system for each file to compile. Whether it will speed up the build depends on the nature of the project and the build machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992839cad735d18aaa4ef05287e210db80780266" translate="yes" xml:space="preserve">
          <source>The compile time of the emulator running the originating node</source>
          <target state="translated">Время компиляции эмулятора,на котором запущен исходный узел.</target>
        </trans-unit>
        <trans-unit id="77923285d15f6d1638ca1085b0ea9ec5d8971d25" translate="yes" xml:space="preserve">
          <source>The compiled files of the imported MIBs must be present in the current directory, or a directory in the current path. The path is supplied with the &lt;code&gt;{i, Path}&lt;/code&gt; option, for example:</source>
          <target state="translated">Скомпилированные файлы импортированных MIB должны присутствовать в текущем каталоге или в каталоге по текущему пути. Путь предоставляется с параметром &lt;code&gt;{i, Path}&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="6fb2caaa7af06a5fa0ebe6a620c35148002139db" translate="yes" xml:space="preserve">
          <source>The compiler also understands that assigning to '_' means that the value will not used. Therefore, the code in the following example will also be optimized:</source>
          <target state="translated">Компилятор также понимает,что присвоение '_' означает,что значение не будет использоваться.Поэтому код в следующем примере также будет оптимизирован:</target>
        </trans-unit>
        <trans-unit id="a0aa4f7feea676dc9f8b66e36fffc1af3c1c40f5" translate="yes" xml:space="preserve">
          <source>The compiler and other compile-time functions can also be started from the Erlang shell. Here follows a brief description of the primary functions. For a complete description of each function, see module &lt;code&gt;asn1ct&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Компилятор и другие функции времени компиляции также можно запустить из оболочки Erlang. Далее следует краткое описание основных функций. Полное описание каждой функции см. В модуле &lt;code&gt;asn1ct&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt; по ASN.1 .</target>
        </trans-unit>
        <trans-unit id="dd83f86086df5c8234f8a9ae71fc626e0a86c59a" translate="yes" xml:space="preserve">
          <source>The compiler automatically inserts the two special, exported functions into each module:</source>
          <target state="translated">Компилятор автоматически вставляет две специальные экспортируемые функции в каждый модуль:</target>
        </trans-unit>
        <trans-unit id="0aa023f79e7e9fc3b1f355a1f8fb5632ee1a7886" translate="yes" xml:space="preserve">
          <source>The compiler can also be accessed from the OS prompt, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">К компилятору также можно получить доступ из командной строки ОС, см. Страницу справочника &lt;code&gt;erl(1)&lt;/code&gt; в ERTS.</target>
        </trans-unit>
        <trans-unit id="dcd47ca4ce5f90e9af16a0a668c0506b2926c5f4" translate="yes" xml:space="preserve">
          <source>The compiler can also inline various list manipulation functions from the module &lt;code&gt;list&lt;/code&gt; in STDLIB.</source>
          <target state="translated">Компилятор также может встроить различные функции управления списком из &lt;code&gt;list&lt;/code&gt; модулей в STDLIB.</target>
        </trans-unit>
        <trans-unit id="246aeec2b67ad60a1d79d7bfcb202381eb810d23" translate="yes" xml:space="preserve">
          <source>The compiler can do function inlining within an Erlang module. Inlining means that a call to a function is replaced with the function body with the arguments replaced with the actual values. The semantics are preserved, except if exceptions are generated in the inlined code. Exceptions are reported as occurring in the function the body was inlined into. Also, &lt;code&gt;function_clause&lt;/code&gt; exceptions are converted to similar &lt;code&gt;case_clause&lt;/code&gt; exceptions.</source>
          <target state="translated">Компилятор может выполнять встраивание функций в модуль Erlang. Встраивание означает, что вызов функции заменяется телом функции, а аргументы заменяются фактическими значениями. Семантика сохраняется, за исключением случаев, когда во встроенном коде генерируются исключения. Об исключениях сообщается, что они происходят в функции, в которую было встроено тело. Кроме того, исключения &lt;code&gt;function_clause&lt;/code&gt; преобразуются в аналогичные исключения &lt;code&gt;case_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba61e82e2483a5192ba41d5a737c2246810798a9" translate="yes" xml:space="preserve">
          <source>The compiler can only do this optimization if it knows that the match context will not be shared. If it would be shared, the functional properties (also called referential transparency) of Erlang would break.</source>
          <target state="translated">Компилятор может провести эту оптимизацию только в том случае,если знает,что контекст совпадения не будет общим.Если бы он был общим,то функциональные свойства (также называемые референтной прозрачностью)Erlang сломались бы.</target>
        </trans-unit>
        <trans-unit id="df9982300695d7d925cce5cf1cdd61f21ef202d8" translate="yes" xml:space="preserve">
          <source>The compiler does not warn for expressions that it does not attempt to optimize. For example, the compiler tries to evaluate &lt;code&gt;1/0&lt;/code&gt;, detects that it will cause an exception, and emits a warning. However, the compiler is silent about the similar expression, &lt;code&gt;X/0&lt;/code&gt;, because of the variable in it. Thus, the compiler does not even try to evaluate and therefore it emits no warnings.</source>
          <target state="translated">Компилятор не предупреждает о выражениях, которые он не пытается оптимизировать. Например, компилятор пытается оценить &lt;code&gt;1/0&lt;/code&gt; , обнаруживает, что это вызовет исключение, и выдает предупреждение. Однако компилятор ничего не говорит о подобном выражении &lt;code&gt;X/0&lt;/code&gt; из-за переменной в нем. Таким образом, компилятор даже не пытается выполнить оценку и, следовательно, не выдает никаких предупреждений.</target>
        </trans-unit>
        <trans-unit id="326ce5bdd2edeffbb0eff29680c2a35b2a0c7613" translate="yes" xml:space="preserve">
          <source>The compiler figures out if a variable is unused. The same code is generated for each of the following functions:</source>
          <target state="translated">Компилятор выясняет,не используется ли переменная.Один и тот же код генерируется для каждой из следующих функций:</target>
        </trans-unit>
        <trans-unit id="736c83a9c909e8b6995b93aa5a592a8cfd21644b" translate="yes" xml:space="preserve">
          <source>The compiler generates a &lt;code&gt;decode_part/2&lt;/code&gt; function when exclusive decode is chosen. This function decodes the parts that were left undecoded during the exclusive decode.</source>
          <target state="translated">Компилятор генерирует функцию &lt;code&gt;decode_part/2&lt;/code&gt; , если выбрано эксклюзивное декодирование. Эта функция декодирует части, которые не были закодированы во время эксклюзивного декодирования.</target>
        </trans-unit>
        <trans-unit id="e4f37f01f0c640d21fe0c086a15f5624a101666e" translate="yes" xml:space="preserve">
          <source>The compiler generates the following files:</source>
          <target state="translated">Компилятор генерирует следующие файлы:</target>
        </trans-unit>
        <trans-unit id="8ae89eb6c8e241efda8fbeedb553bd086502de6d" translate="yes" xml:space="preserve">
          <source>The compiler handles the &lt;code&gt;IMPORT&lt;/code&gt; statement. It is important to import the compiled file and not the ASN.1 (source) file. A MIB must be recompiled to make changes visible to other MIBs importing it.</source>
          <target state="translated">Компилятор обрабатывает оператор &lt;code&gt;IMPORT&lt;/code&gt; . Важно импортировать скомпилированный файл, а не файл ASN.1 (исходный). MIB необходимо перекомпилировать, чтобы изменения были видны другим MIB, импортирующим ее.</target>
        </trans-unit>
        <trans-unit id="ef890ca9c7e8253725d98c0071846009690a22a4" translate="yes" xml:space="preserve">
          <source>The compiler internally rewrites the latter code into the former.</source>
          <target state="translated">Компилятор внутренне переписывает второй код на первый.</target>
        </trans-unit>
        <trans-unit id="1f2b065f3c16869915d5310d49119f53343cacb9" translate="yes" xml:space="preserve">
          <source>The compiler is located in the module &lt;code&gt;compile&lt;/code&gt; (see the &lt;code&gt;compile(3)&lt;/code&gt; manual page in Compiler).</source>
          <target state="translated">Компилятор находится в модуле &lt;code&gt;compile&lt;/code&gt; (см. &lt;code&gt;compile(3)&lt;/code&gt; страницу compile (3) в Compiler).</target>
        </trans-unit>
        <trans-unit id="a6b51b2ed2bc7f46e25bc64dda5c32ec191ce10a" translate="yes" xml:space="preserve">
          <source>The compiler is started by &lt;code&gt;asn1ct:compile/1&lt;/code&gt; with default options, or &lt;code&gt;asn1ct:compile/2&lt;/code&gt; if explicit options are given.</source>
          <target state="translated">Компилятор запускается с помощью &lt;code&gt;asn1ct:compile/1&lt;/code&gt; с параметрами по умолчанию или &lt;code&gt;asn1ct:compile/2&lt;/code&gt; , если указаны явные параметры.</target>
        </trans-unit>
        <trans-unit id="7898d48c7095ef7080834ae1df25bb02756bfa73" translate="yes" xml:space="preserve">
          <source>The compiler parses the SMI file and associates each table or variable with an instrumentation function (see the figure &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt;). The actual instrumentation functions are not needed at MIB compile time, only their names.</source>
          <target state="translated">Компилятор анализирует файл SMI и связывает каждую таблицу или переменную с инструментальной функцией (см. Рисунок &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt; ). Фактические инструментальные функции не нужны во время компиляции MIB, только их имена.</target>
        </trans-unit>
        <trans-unit id="29ced82347a929ec3d64773bda03ab575e2ebdf7" translate="yes" xml:space="preserve">
          <source>The compiler removes building of sub binaries in the second and third clauses, and it adds an instruction to the first clause that converts &lt;code&gt;Buffer&lt;/code&gt; from a match context to a sub binary (or do nothing if &lt;code&gt;Buffer&lt;/code&gt; is a binary already).</source>
          <target state="translated">Компилятор удаляет построение дочерних двоичных файлов во втором и третьем предложениях и добавляет инструкцию к первому предложению, которая преобразует &lt;code&gt;Buffer&lt;/code&gt; из контекста совпадения во вспомогательный двоичный файл (или ничего не делает, если &lt;code&gt;Buffer&lt;/code&gt; уже является двоичным).</target>
        </trans-unit>
        <trans-unit id="3e19fdc6630343c3d28603ee64052ea9f7070d01" translate="yes" xml:space="preserve">
          <source>The compiler returns the object code in a binary instead of creating an object file. If successful, the compiler returns &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt;.</source>
          <target state="translated">Компилятор возвращает объектный код в двоичном формате вместо создания объектного файла. В случае успеха компилятор возвращает &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c32c93e25c9ed677dd8b2dc76e27b04c3f91ef2" translate="yes" xml:space="preserve">
          <source>The compiler tries to avoid generating code that creates a sub binary, only to shortly afterwards create a new match context and discard the sub binary. Instead of creating a sub binary, the match context is kept.</source>
          <target state="translated">Компилятор пытается избежать генерации кода,который создает поддвоичный файл,только чтобы вскоре после этого создать новый контекст соответствия и отбросить поддвоичный файл.Вместо создания подбинарного файла,контекст соответствия сохраняется.</target>
        </trans-unit>
        <trans-unit id="93271cc943214ad52c731246bc1c6f5f502dc5df" translate="yes" xml:space="preserve">
          <source>The compiler understands the module attribute &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; and issues warnings about missing callback functions, for example:</source>
          <target state="translated">Компилятор понимает атрибут модуля &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; и выдает предупреждения об отсутствующих функциях обратного вызова, например:</target>
        </trans-unit>
        <trans-unit id="b4e5de69deb63fd9f8e518572799240cd4dbb515" translate="yes" xml:space="preserve">
          <source>The compiler will compress the generated object code, which can be useful for embedded systems.</source>
          <target state="translated">Компилятор сжимает сгенерированный объектный код,что может быть полезно для встраиваемых систем.</target>
        </trans-unit>
        <trans-unit id="9f6ca4a1bcb2bb18eb6fa6ea91946375fe8b63fd" translate="yes" xml:space="preserve">
          <source>The compiler will emit informational warnings about binary matching optimizations (both successful and unsuccessful). For more information, see the section about &lt;code&gt;bin_opt_info&lt;/code&gt; in the Efficiency Guide.</source>
          <target state="translated">Компилятор выдаст информационные предупреждения об оптимизациях двоичного сопоставления (как успешных, так и неудачных). Для получения дополнительной информации смотрите раздел о &lt;code&gt;bin_opt_info&lt;/code&gt; в эффективности Guide.</target>
        </trans-unit>
        <trans-unit id="272c69253881a0e58a00b19dd140c32886a5264d" translate="yes" xml:space="preserve">
          <source>The compiler will generate code similar to this:</source>
          <target state="translated">Компилятор сгенерирует подобный код:</target>
        </trans-unit>
        <trans-unit id="a11970730484c5ef03d8b57a7d8f1200a3e88258" translate="yes" xml:space="preserve">
          <source>The complement message, from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, is only sent if node &lt;code&gt;A&lt;/code&gt; initially sent an old name message and received back a new challenge message from node &lt;code&gt;B&lt;/code&gt;. It contains complementary information missing in the initial old name message from node &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22d63ebef153d116952bd4b9cdc3d70b1deac48" translate="yes" xml:space="preserve">
          <source>The complete build environment is required while running &lt;code&gt;otp_patch_apply&lt;/code&gt;.</source>
          <target state="translated">Полная среда сборки требуется при запуске &lt;code&gt;otp_patch_apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="991eb99483640f8d2cb258dac8893f15f032e622" translate="yes" xml:space="preserve">
          <source>The complete content of the history buffer can be written to a configuration file by calling &lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt;. Selected entries from the history can be written by calling &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt;, where &lt;code&gt;NumList&lt;/code&gt; is a list of integers pointing out the history entries to write. Moreover, the history buffer is always dumped to &lt;code&gt;ttb_last_config&lt;/code&gt; when &lt;code&gt;ttb:stop/0,1&lt;/code&gt; is called.</source>
          <target state="translated">Полное содержимое буфера истории можно записать в файл конфигурации, вызвав &lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt; . Выбранные записи из истории можно записать, вызвав &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt; , где &lt;code&gt;NumList&lt;/code&gt; - это список целых чисел, указывающих записи истории для записи. Более того, буфер истории всегда &lt;code&gt;ttb_last_config&lt;/code&gt; в ttb_last_config при &lt;code&gt;ttb:stop/0,1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06275c17581f810fa4579c2f0ccfc4b29d12ac2f" translate="yes" xml:space="preserve">
          <source>The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.</source>
          <target state="translated">Полное совпадение шаблона всегда дает первое возвращаемое значение в списке,а остальные подшаблоны добавляются в порядке их появления в регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="3a13431e36ebb44eb9fa84700a106f85f4b1ac47" translate="yes" xml:space="preserve">
          <source>The complete path to the Erlang emulator. Never use the &lt;code&gt;werl&lt;/code&gt; program for this. Defaults to the &lt;code&gt;erl.exe&lt;/code&gt; in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. When release handling is used, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">Полный путь к эмулятору Erlang. Никогда не используйте для этого программу &lt;code&gt;werl&lt;/code&gt; . По умолчанию &lt;code&gt;erl.exe&lt;/code&gt; находится в том же каталоге, что и &lt;code&gt;erlsrv.exe&lt;/code&gt; . Когда используется обработка выпуска, это должно быть установлено в программе, подобной &lt;code&gt;start_erl.exe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b9e994208ced53dcfba8c8850e25b0dd795cc2c" translate="yes" xml:space="preserve">
          <source>The complete specification for the bit syntax appears in the &lt;code&gt;Reference Manual&lt;/code&gt;.</source>
          <target state="translated">Полная спецификация битового синтаксиса представлена ​​в &lt;code&gt;Reference Manual&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b9f520763856efe6e5a044f5a2e1ee496c05b06" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;A -- B&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;. That is, it becomes very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists.</source>
          <target state="translated">Сложность &lt;code&gt;A -- B&lt;/code&gt; пропорциональна &lt;code&gt;length(A)*length(B)&lt;/code&gt; . То есть он становится очень медленным, если и &lt;code&gt;A&lt;/code&gt; , и &lt;code&gt;B&lt;/code&gt; являются длинными списками.</target>
        </trans-unit>
        <trans-unit id="fab2bbfeb9763c6bdcd0f510a645aceccf277fc7" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;lists:subtract(A, B)&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;, meaning that it is very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists. (If both lists are long, it is a much better choice to use ordered lists and &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сложность &lt;code&gt;lists:subtract(A, B)&lt;/code&gt; пропорционально &lt;code&gt;length(A)*length(B)&lt;/code&gt; , что означает, что это очень медленно, если и &lt;code&gt;A&lt;/code&gt; , и &lt;code&gt;B&lt;/code&gt; являются длинными списками. (Если оба списка длинные, гораздо лучше использовать упорядоченные списки и &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fc7384b856b0bd8d7f49596a4fe364f88395e2b" translate="yes" xml:space="preserve">
          <source>The complexity on set operations is bounded by either &lt;strong&gt;O(|S|)&lt;/strong&gt; or &lt;strong&gt;O(|T| * log(|S|))&lt;/strong&gt;, where S is the largest given set, depending on which is fastest for any particular function call. For operating on sets of almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For sets of very different sizes, however, this solution can be arbitrarily much faster; in practical cases, often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time, building up a large set (&amp;gt; 100-200 elements), and repeatedly testing for membership in the current set.</source>
          <target state="translated">Сложность операций над множеством ограничена либо &lt;strong&gt;O (| S |),&lt;/strong&gt; либо &lt;strong&gt;O (| T | * log (| S |))&lt;/strong&gt; , где S - наибольшее заданное множество, в зависимости от того, какое из них является самым быстрым для любого конкретного вызова функции. Для работы с наборами почти одинакового размера эта реализация примерно в 3 раза медленнее, чем использование наборов упорядоченных списков напрямую. Однако для наборов очень разных размеров это решение может быть произвольно намного быстрее; в практических случаях часто 10-100 раз. Эта реализация особенно подходит для накопления элементов по несколько за раз, создания большого набора (&amp;gt; 100-200 элементов) и многократного тестирования на членство в текущем наборе.</target>
        </trans-unit>
        <trans-unit id="1f0db048fd959939f98a5ab5ffcb76b17f2161e3" translate="yes" xml:space="preserve">
          <source>The component &lt;code&gt;b&lt;/code&gt; is treated as an original component when encoding a message. In this case, as it is not an optional element, it must be encoded.</source>
          <target state="translated">При кодировании сообщения компонент &lt;code&gt;b&lt;/code&gt; рассматривается как исходный компонент. В этом случае, поскольку это необязательный элемент, он должен быть закодирован.</target>
        </trans-unit>
        <trans-unit id="95df5a7aa19b0879416444bcc5ff1ff82e16895f" translate="yes" xml:space="preserve">
          <source>The compressed term format is as follows:</source>
          <target state="translated">Формат сжатых терминов следующий:</target>
        </trans-unit>
        <trans-unit id="3b034a8ca7cf564d2716f7d145e9bf7ce76cd7cc" translate="yes" xml:space="preserve">
          <source>The compression algorithm none (= no compression) is removed so compression is enforced</source>
          <target state="translated">Алгоритм сжатия не удаляется (=нет сжатия),поэтому сжатие выполняется.</target>
        </trans-unit>
        <trans-unit id="1b5cdfaea7fccd1b20390cb4e9325498d3da1b59" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f5418f59d5bf2e56046767d3d15b2e506ac3c4" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Компрессор и декомпрессор должны использовать один и тот же словарь (см. &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c9ba98b827fef9b660205799a125d38d037fa2c" translate="yes" xml:space="preserve">
          <source>The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is &lt;code&gt;DBL_MIN&lt;/code&gt;, which is 2.0^(-1022).</source>
          <target state="translated">Концепция подразумевает, что вероятность получить ровно ноль чрезвычайно мала; настолько низкий, что эта функция фактически гарантированно никогда не вернет ноль. Наименьшее число, которое он может вернуть, - это &lt;code&gt;DBL_MIN&lt;/code&gt; , равное 2,0 ^ (- 1022).</target>
        </trans-unit>
        <trans-unit id="943911384cb6e7518951f5974b91a80146819bfa" translate="yes" xml:space="preserve">
          <source>The concept of &quot;raw filenames&quot; can be used to handle wrongly encoded filenames if one enables Unicode filename translation (&lt;code&gt;+fnu&lt;/code&gt;) on platforms where this is not the default.</source>
          <target state="translated">Концепция &amp;laquo;сырых имен файлов&amp;raquo; может использоваться для обработки неправильно закодированных имен файлов, если &lt;code&gt;+fnu&lt;/code&gt; перевод имени файла в Unicode ( + fnu ) на платформах, где это не используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a5e9df0f0bca9d8678a66d1bcb07dea7aeeb1bd0" translate="yes" xml:space="preserve">
          <source>The concept of subtyping can be applied to integers and to other ASN.1 types. The details of subtyping are not explained here; for more information, see X.680. Various syntaxes are allowed when defining a type as an integer:</source>
          <target state="translated">Понятие подтипирования может быть применено к целым числам и к другим типам ASN.1.Подробности подтипирования здесь не объясняются;более подробную информацию см.в X.680.Допускаются различные синтаксисы при определении типа как целого числа:</target>
        </trans-unit>
        <trans-unit id="9ea91819bf64e3ece43df4e073d660a0ac1fb62c" translate="yes" xml:space="preserve">
          <source>The conceptual repository for management information is called the Management Information Base (MIB). It does not hold any data, merely a definition of what data can be accessed. A definition of an MIB is a description of a collection of managed objects.</source>
          <target state="translated">Концептуальный репозиторий управленческой информации называется База управленческой информации (БУИ).В ней не содержится никаких данных,а только определение того,к каким данным можно получить доступ.Определение MIB-это описание коллекции управляемых объектов.</target>
        </trans-unit>
        <trans-unit id="100c3255ddc27fa6383db8b2a42e843f2130c476" translate="yes" xml:space="preserve">
          <source>The condition can be inverted by using &lt;code&gt;%unless&lt;/code&gt; instead of &lt;code&gt;%if&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0f7f9a82dfed01500e86c2a2936e52983cbea0" translate="yes" xml:space="preserve">
          <source>The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. That is, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative, otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</source>
          <target state="translated">Условием является положительное бланковое утверждение,совпадающее с необязательной последовательностью небуквенных букв,за которыми следует буква.То есть оно проверяет наличие хотя бы одной буквы в субъекте.Если буква найдена,субъект сопоставляется с первым вариантом,в противном случае она сопоставляется со вторым.Этот образец совпадает со строками в одной из двух форм dd-aa-dd или dd-dd-dd,где aaa-буквы,а dd-цифры.</target>
        </trans-unit>
        <trans-unit id="2bb2d4ddfb9fd4340f3bf62302b4368f672d1819" translate="yes" xml:space="preserve">
          <source>The condition is specified by the user as a module name &lt;code&gt;CModule&lt;/code&gt; and a function name &lt;code&gt;CFunction&lt;/code&gt;. When a process reaches the breakpoint, &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; is evaluated. If and only if this function call returns &lt;code&gt;true&lt;/code&gt;, the process stops. If the function call returns &lt;code&gt;false&lt;/code&gt;, the breakpoint is silently ignored.</source>
          <target state="translated">Условие указывается пользователем как имя модуля &lt;code&gt;CModule&lt;/code&gt; и имя функции &lt;code&gt;CFunction&lt;/code&gt; . Когда процесс достигает точки останова, &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; . Если и только если этот вызов функции возвращает &lt;code&gt;true&lt;/code&gt; , процесс останавливается. Если вызов функции возвращает &lt;code&gt;false&lt;/code&gt; , точка останова игнорируется.</target>
        </trans-unit>
        <trans-unit id="f7986bbea85397da9d57d44bc07228d7fb46c1a2" translate="yes" xml:space="preserve">
          <source>The conditional test is performed by calling &lt;code&gt;Module:Name(Bindings)&lt;/code&gt;, where &lt;code&gt;Bindings&lt;/code&gt; is the current variable bindings. The function must return &lt;code&gt;true&lt;/code&gt; (break) or &lt;code&gt;false&lt;/code&gt; (do not break). To retrieve the value of a variable &lt;code&gt;Var&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Условный тест выполняется путем вызова &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; , где &lt;code&gt;Bindings&lt;/code&gt; - это текущие привязки переменных. Функция должна возвращать &lt;code&gt;true&lt;/code&gt; (разрыв) или &lt;code&gt;false&lt;/code&gt; (не прерывание). Чтобы получить значение переменной &lt;code&gt;Var&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e22cdbb695181f6db56e9e8f9255cb87d1e5c71" translate="yes" xml:space="preserve">
          <source>The conditions for the range request are not fulfilled. The response must not be treated as a range request, instead it must be treated as an ordinary get request.</source>
          <target state="translated">Условия запроса диапазона не выполняются.Ответ не должен рассматриваться как запрос диапазона,вместо этого он должен рассматриваться как обычный запрос на получение.</target>
        </trans-unit>
        <trans-unit id="d2a1a0885cb8c3972db243784463cc998671043e" translate="yes" xml:space="preserve">
          <source>The config file &lt;code&gt;ex3.config&lt;/code&gt; has the contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7d9b54f9813dcda9a518f9cbb3355ce28a2103" translate="yes" xml:space="preserve">
          <source>The config file directives stored as key-value tuples in an ETS table. Depicted &lt;code&gt;config_db()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">Директивы конфигурационного файла хранятся в виде кортежей ключ-значение в таблице ETS. Изображен &lt;code&gt;config_db()&lt;/code&gt; в объявлениях типов функций.</target>
        </trans-unit>
        <trans-unit id="1c180f4dced667f5747360888d336f97b780f3ef" translate="yes" xml:space="preserve">
          <source>The configuration can be changed during runtime. This is done with the functions &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Конфигурацию можно изменить во время выполнения. Это делается с помощью функций &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c0742cfd72a2d898508fa85616b5365c6647a68" translate="yes" xml:space="preserve">
          <source>The configuration created by &lt;code&gt;erts_alloc_config&lt;/code&gt; may perform bad, ever horrible, for runtime scenarios that are very different from the ones saved when creating the configuration. You are, therefore, advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the applications run when the configuration was made are changed, or if the load on the applications have changed since the configuration was made. You are also advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the Erlang runtime system used is changed.</source>
          <target state="translated">Конфигурация, созданная &lt;code&gt;erts_alloc_config&lt;/code&gt; , может работать плохо, даже ужасно для сценариев выполнения, которые сильно отличаются от тех, которые были сохранены при создании конфигурации. Поэтому вам рекомендуется повторно запустить &lt;code&gt;erts_alloc_config&lt;/code&gt; , если приложения, запущенные во время выполнения конфигурации, были изменены, или если нагрузка на приложения изменилась с момента создания конфигурации. Также рекомендуется повторно запустить &lt;code&gt;erts_alloc_config&lt;/code&gt; , если используемая система времени выполнения Erlang была изменена.</target>
        </trans-unit>
        <trans-unit id="1470d083b0e1db8406286192bd8eb1c282c6bd47" translate="yes" xml:space="preserve">
          <source>The configuration data that can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85fc09c0359e30e0ac0453b4dd29606f3be0cecc" translate="yes" xml:space="preserve">
          <source>The configuration file is to be called &lt;code&gt;Name.config&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is any name.</source>
          <target state="translated">Файл конфигурации должен называться &lt;code&gt;Name.config&lt;/code&gt; , где &lt;code&gt;Name&lt;/code&gt; - любое имя.</target>
        </trans-unit>
        <trans-unit id="2e343dc41431506d1bab7a8f1ff51c6eab8fb28a" translate="yes" xml:space="preserve">
          <source>The configuration file must be as for &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Файл конфигурации должен быть таким же, как для &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea2779e1cbd9f4e936b9d22bec123fd3a929a25" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;community.conf&lt;/code&gt;.</source>
          <target state="translated">Читаемый файл конфигурации: &lt;code&gt;community.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c155b3574ab962c920c1adb90ff1fbf8e4d0be7" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;context.conf&lt;/code&gt;.</source>
          <target state="translated">Читаемый файл конфигурации: &lt;code&gt;context.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f94cc61e31a7b0de35c335106254d680dc12d2e8" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;notify.conf&lt;/code&gt; файл конфигурации: notify.conf .</target>
        </trans-unit>
        <trans-unit id="8a287de08efb6a6960170e4a56df71f4fd0b681e" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">Читаемый файл конфигурации: &lt;code&gt;standard.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edf952b8d588b0a93a4ac1f9d47f9ec65e928fc4" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;usm.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;usm.conf&lt;/code&gt; файл конфигурации: usm.conf .</target>
        </trans-unit>
        <trans-unit id="2ac382ba3d28511c043e21b8f905a371edc5d62a" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vacm.conf&lt;/code&gt; файл конфигурации: vacm.conf .</target>
        </trans-unit>
        <trans-unit id="b3706f3f0276351526850c287f3491578e144daa" translate="yes" xml:space="preserve">
          <source>The configuration files are described in the SNMP User's Manual.</source>
          <target state="translated">Файлы конфигурации описаны в руководстве пользователя SNMP.</target>
        </trans-unit>
        <trans-unit id="d6aaee960bcbac0afc5716e7f7102e83e8360020" translate="yes" xml:space="preserve">
          <source>The configuration files is to have &lt;code&gt;rw-r--r--&lt;/code&gt; file privileges and be owned by root.</source>
          <target state="translated">Файлы конфигурации должны иметь права доступа к файлам &lt;code&gt;rw-r--r--&lt;/code&gt; и принадлежать пользователю root.</target>
        </trans-unit>
        <trans-unit id="7d385331a206f67eef31fa2a51c3328ec0a6039b" translate="yes" xml:space="preserve">
          <source>The configuration files read are: &lt;code&gt;target_addr.conf&lt;/code&gt; and &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target_addr.conf&lt;/code&gt; файлы конфигурации: target_addr.conf и &lt;code&gt;target_params.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="042a7891933367b39b8962f8cd2c79595dff050a" translate="yes" xml:space="preserve">
          <source>The configuration for a handler is a map with the following keys:</source>
          <target state="translated">Конфигурация обработчика представляет собой карту со следующими ключами:</target>
        </trans-unit>
        <trans-unit id="3a5cc2ceb258634736594f44cf8266aeb733951f" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3) &lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1a1fcfff199b6a1287871c07c285d5f0e37425" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="translated">Конфигурация для встроенных обработчиков описана на &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; руководства logger_std_h (3) и &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bec465458a3428115fd8e864e0c74437e5202fb" translate="yes" xml:space="preserve">
          <source>The configuration functions &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; execute, like test cases, on dedicated Erlang processes.</source>
          <target state="translated">Функции конфигурации &lt;code&gt;init_per_suite&lt;/code&gt; и &lt;code&gt;end_per_suite&lt;/code&gt; выполняются, как и тестовые примеры, в выделенных процессах Erlang.</target>
        </trans-unit>
        <trans-unit id="ca028bc56c7a5d8a6feb5fb00bb7ad713784158b" translate="yes" xml:space="preserve">
          <source>The configuration functions are optional. The following example is a test suite without configuration functions, including one simple test case, to check that module &lt;code&gt;mymod&lt;/code&gt; exists (that is, can be successfully loaded by the code server):</source>
          <target state="translated">Функции конфигурации не являются обязательными. Следующий пример представляет собой набор тестов без функций конфигурации, включая один простой тестовый пример, чтобы проверить, существует ли модуль &lt;code&gt;mymod&lt;/code&gt; (то есть может быть успешно загружен сервером кода):</target>
        </trans-unit>
        <trans-unit id="b7ecabb96142aae8632b3c398a0652fea4462151" translate="yes" xml:space="preserve">
          <source>The configuration is created based on information about a number of runtime scenarios. It is obviously impossible to foresee every runtime scenario that can occur. The important scenarios are those that cause maximum or minimum load on specific memory allocators. Load in this context is total size of memory blocks allocated.</source>
          <target state="translated">Конфигурация создается на основе информации о ряде сценариев выполнения.Очевидно,что невозможно предугадать каждый сценарий выполнения,который может произойти.Важными сценариями являются те,которые вызывают максимальную или минимальную нагрузку на определенные аллокаторы памяти.Загрузка в этом контексте является общим размером выделенных блоков памяти.</target>
        </trans-unit>
        <trans-unit id="a090830d0bfa6e8b71055c052afa6781c7336637" translate="yes" xml:space="preserve">
          <source>The configuration of a &lt;code&gt;Mnesia&lt;/code&gt; system is described in a schema. The schema is a special table that includes information such as the table names and the storage type of each table (that is, whether a table is to be stored in RAM, on disc, or on both, as well as its location).</source>
          <target state="translated">Конфигурация системы &lt;code&gt;Mnesia&lt;/code&gt; описана в схеме. Схема представляет собой специальную таблицу, которая включает в себя такую ​​информацию, как имена таблиц и тип хранения каждой таблицы (то есть, должна ли таблица храниться в ОЗУ, на диске или на обоих, а также ее местоположение).</target>
        </trans-unit>
        <trans-unit id="eb15a8828aadb5793353d2caed482552687928f9" translate="yes" xml:space="preserve">
          <source>The configuration of how the documentation should be rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c07741d4c4f9e44d0dbd305d096f7efb62fc4f" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fec7a20842abcc0261e4b0c9e02b04cf3308e0" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list. For backwards compatibility, a configuration file using apache-style configuration directives is supported.</source>
          <target state="translated">Конфигурация сервера предоставляется в виде списка свойств Erlang.Для обратной совместимости поддерживается конфигурационный файл,использующий конфигурационные директивы в стиле apache.</target>
        </trans-unit>
        <trans-unit id="42a81cb11873a89bc4dc7fee0b14edc95426ecba" translate="yes" xml:space="preserve">
          <source>The configuration option &lt;code&gt;filter_default&lt;/code&gt; specifies the behaviour if all filter functions return &lt;code&gt;ignore&lt;/code&gt;, or if no filters exist. &lt;code&gt;filter_default&lt;/code&gt; is by default set to &lt;code&gt;log&lt;/code&gt;, meaning that if all existing filters ignore a log event, Logger forwards the event to the handler callback. If &lt;code&gt;filter_default&lt;/code&gt; is set to &lt;code&gt;stop&lt;/code&gt;, Logger discards such events.</source>
          <target state="translated">Параметр конфигурации &lt;code&gt;filter_default&lt;/code&gt; определяет поведение, если все функции фильтра возвращают значение &lt;code&gt;ignore&lt;/code&gt; или если фильтры не существуют. &lt;code&gt;filter_default&lt;/code&gt; по умолчанию имеет значение &lt;code&gt;log&lt;/code&gt; , что означает, что если все существующие фильтры игнорируют событие журнала, Logger перенаправляет событие в обратный вызов обработчика. Если для &lt;code&gt;filter_default&lt;/code&gt; задано значение &lt;code&gt;stop&lt;/code&gt; , Logger отклоняет такие события.</target>
        </trans-unit>
        <trans-unit id="7cbcc3590c5b004952bd57c5ea409bb2cbc75510" translate="yes" xml:space="preserve">
          <source>The configuration parameter does not exist.</source>
          <target state="translated">Конфигурационный параметр не существует.</target>
        </trans-unit>
        <trans-unit id="81a4addb98ae9327dd483e9ad9426add086cb215" translate="yes" xml:space="preserve">
          <source>The configuration produced by &lt;code&gt;erts_alloc_config&lt;/code&gt; may need to be manually adjusted as already stated. Do not modify the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;; instead, put your modifications in another file and load this file after the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. That is, put the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads your modification file later on the command-line than the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. If a memory allocation parameter appear multiple times, the last version of will be used, i.e., you can override parameters in the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. Doing it this way simplifies things when you want to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">Конфигурация, созданная &lt;code&gt;erts_alloc_config&lt;/code&gt; , может нуждаться в ручной настройке, как уже было сказано. Не изменяйте файл, созданный &lt;code&gt;erts_alloc_config&lt;/code&gt; ; вместо этого поместите свои изменения в другой файл и загрузите этот файл после файла, созданного &lt;code&gt;erts_alloc_config&lt;/code&gt; . То есть &lt;code&gt;-args_file FileName&lt;/code&gt; аргумент -args_file FileName, который считывает ваш файл модификации позже, в командной строке, чем аргумент &lt;code&gt;-args_file FileName&lt;/code&gt; , который считывает файл конфигурации, созданный &lt;code&gt;erts_alloc_config&lt;/code&gt; . Если параметр выделения памяти появляется несколько раз, будет использоваться последняя версия, т.е. вы можете переопределить параметры в файле конфигурации, созданном &lt;code&gt;erts_alloc_config&lt;/code&gt; , Это упрощает работу, когда вы хотите повторно запустить &lt;code&gt;erts_alloc_config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213a1cc6b8684b6f32c379587c37729fd6c0d583" translate="yes" xml:space="preserve">
          <source>The configuration string for this driver can be &lt;code&gt;config_server&lt;/code&gt;, if the &lt;code&gt;config_server.erl&lt;/code&gt; module that follows is compiled and exists in the code path during test execution:</source>
          <target state="translated">&lt;code&gt;config_server&lt;/code&gt; конфигурации для этого драйвера может быть config_server , если &lt;code&gt;config_server.erl&lt;/code&gt; модуль config_server.erl скомпилирован и существует в пути кода во время выполнения теста:</target>
        </trans-unit>
        <trans-unit id="d419157999767488a1c56645c3a2365b2bbbcd93" translate="yes" xml:space="preserve">
          <source>The configuration term for &lt;code&gt;logger_formatter&lt;/code&gt; is a &lt;code&gt;map&lt;/code&gt;, and the following keys can be set as configuration parameters:</source>
          <target state="translated">Термин конфигурации для &lt;code&gt;logger_formatter&lt;/code&gt; - это &lt;code&gt;map&lt;/code&gt; , и следующие ключи могут быть установлены в качестве параметров конфигурации:</target>
        </trans-unit>
        <trans-unit id="712ad0cc82e1a88f726b7f711e243ab197e28193" translate="yes" xml:space="preserve">
          <source>The configure script allows you to customize a number of parameters; type &lt;code&gt;./configure --help&lt;/code&gt; or &lt;code&gt;./configure --help=recursive&lt;/code&gt; for details. &lt;code&gt;./configure --help=recursive&lt;/code&gt; will give help for all &lt;code&gt;configure&lt;/code&gt; scripts in all applications.</source>
          <target state="translated">Сценарий настройки позволяет настраивать ряд параметров; введите &lt;code&gt;./configure --help&lt;/code&gt; или &lt;code&gt;./configure --help=recursive&lt;/code&gt; для получения подробной информации. &lt;code&gt;./configure --help=recursive&lt;/code&gt; предоставит справку по всем сценариям &lt;code&gt;configure&lt;/code&gt; во всех приложениях.</target>
        </trans-unit>
        <trans-unit id="f871702162e9fe05aae1c9e32504517869931c15" translate="yes" xml:space="preserve">
          <source>The configure script is created by the GNU autoconf utility, which checks for system specific features and then creates a number of makefiles.</source>
          <target state="translated">Сценарий конфигурации создаётся утилитой GNU autoconf,которая проверяет специфические для системы возможности,а затем создаёт ряд makefile.</target>
        </trans-unit>
        <trans-unit id="7d4bba926aeb3883bfbd6d00a31923bc874078ac" translate="yes" xml:space="preserve">
          <source>The configure should be skipped and all tests should hopefully pass. For more details about how to use ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt;</source>
          <target state="translated">Конфигурацию следует пропустить и все тесты должны пройти успешно. Для получения дополнительных сведений о том, как использовать ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f6521bf4e434f67b356b39a99c1ade02b2e892c" translate="yes" xml:space="preserve">
          <source>The connect is done in two steps: first an internal &lt;code&gt;connection setup&lt;/code&gt; and then by calling the user &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; callback function. The first step could result in an error with &lt;code&gt;Reason = connect_reason()&lt;/code&gt; and the second an error with &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt;:</source>
          <target state="translated">Подключение выполняется в два этапа: сначала устанавливается внутреннее &lt;code&gt;connection setup&lt;/code&gt; а затем путем вызова пользовательской функции обратного вызова &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; . Первый шаг может привести к ошибке с &lt;code&gt;Reason = connect_reason()&lt;/code&gt; а второй - к ошибке с &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="371ea327d46ab20111d8dd7bba591b3794f31f48" translate="yes" xml:space="preserve">
          <source>The connection attempt can be traced by setting a trace level by either using &lt;code&gt;ei_set_tracelevel&lt;/code&gt; or by setting environment variable &lt;code&gt;EI_TRACELEVEL&lt;/code&gt;. The trace levels have the following messages:</source>
          <target state="translated">Попытку подключения можно отследить, установив уровень трассировки с помощью &lt;code&gt;ei_set_tracelevel&lt;/code&gt; или установив переменную среды &lt;code&gt;EI_TRACELEVEL&lt;/code&gt; . На уровнях трассировки отображаются следующие сообщения:</target>
        </trans-unit>
        <trans-unit id="cef16d7f5ec818bdeac2287eb2c52b738775d9e3" translate="yes" xml:space="preserve">
          <source>The connection created to the EPMD must be kept as long as the node is a distributed node. When the connection is closed, the node is automatically unregistered from the EPMD.</source>
          <target state="translated">Созданное соединение с EPMD должно сохраняться до тех пор,пока узел является распределенным.Когда соединение закрыто,узел автоматически не регистрируется в EPMD.</target>
        </trans-unit>
        <trans-unit id="5cbfa81fe3ccd8a5c63ea407c66f04845f8cea33" translate="yes" xml:space="preserve">
          <source>The connection is already encrypted. The connection is not affected.</source>
          <target state="translated">Соединение уже зашифровано.Соединение не затронуто.</target>
        </trans-unit>
        <trans-unit id="759c06525846f46120048a080c3029be1ff31bcc" translate="yes" xml:space="preserve">
          <source>The connection is associated with the process that created it and can only be accessed through it. The reason for this is to preserve the semantics of result sets and transactions when select_count/[2,3] is called or auto_commit is turned off. Attempts to use the connection from another process will fail. This will not effect the connection. On the other hand, if the client process dies the connection will be terminated.</source>
          <target state="translated">Соединение связано с процессом,который его создал,и доступ к нему возможен только через него.Причина этого-сохранение семантики результирующих множеств и транзакций при вызове select_count/[2,3]или отключении auto_commit.Попытки использовать соединение из другого процесса будут безуспешными.Это не повлияет на соединение.С другой стороны,если клиентский процесс умирает,соединение будет прервано.</target>
        </trans-unit>
        <trans-unit id="6bd0a40ef6e388c1101ec314a27b945374892947" translate="yes" xml:space="preserve">
          <source>The connection is disallowed for some (unspecified) security reason.</source>
          <target state="translated">Соединение запрещено по какой-то (неуказанной)причине безопасности.</target>
        </trans-unit>
        <trans-unit id="f988842124188a5fc24f10cf75663bb95aaa98aa" translate="yes" xml:space="preserve">
          <source>The connection setup failed (after &lt;code&gt;nodeup&lt;/code&gt; messages were sent).</source>
          <target state="translated">Не удалось установить соединение (после &lt;code&gt;nodeup&lt;/code&gt; сообщений nodeup ).</target>
        </trans-unit>
        <trans-unit id="2c2c09cbaff852e46a92c401a3052832960adf16" translate="yes" xml:space="preserve">
          <source>The connection state.</source>
          <target state="translated">Состояние связи.</target>
        </trans-unit>
        <trans-unit id="21a557db3cf2f1855e12dfec5d40959655ffd926" translate="yes" xml:space="preserve">
          <source>The connection string is to be a connection string for postgres.</source>
          <target state="translated">Строка соединения должна быть строкой соединения для postgres.</target>
        </trans-unit>
        <trans-unit id="ab4adb70f93fe4eb3a4bc1933285abc2bb9e86ea" translate="yes" xml:space="preserve">
          <source>The connection to &lt;code&gt;Node&lt;/code&gt; was lost or could not be established. The function may or may not be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577ebba31469c1b19a854e051f7d7bcd77b95482" translate="yes" xml:space="preserve">
          <source>The connection was closed.</source>
          <target state="translated">Соединение было закрыто.</target>
        </trans-unit>
        <trans-unit id="f85b0a947aa3ee4eeec0e9164d045d949bc237ff" translate="yes" xml:space="preserve">
          <source>The connection was disconnected (forced from the current node).</source>
          <target state="translated">Соединение было отключено (принудительно от текущего узла).</target>
        </trans-unit>
        <trans-unit id="faa62673d542db68465d9b4076b4c1a13a9c2ef7" translate="yes" xml:space="preserve">
          <source>The consistency property ensures that a transaction always leaves the DBMS in a consistent state. For example, &lt;code&gt;Mnesia&lt;/code&gt; ensures that no inconsistencies occur if Erlang, &lt;code&gt;Mnesia&lt;/code&gt;, or the computer crashes while a write operation is in progress.</source>
          <target state="translated">Свойство согласованности гарантирует, что транзакция всегда покидает СУБД в согласованном состоянии. Например, &lt;code&gt;Mnesia&lt;/code&gt; гарантирует отсутствие несоответствий при сбое Erlang, &lt;code&gt;Mnesia&lt;/code&gt; или компьютера во время выполнения операции записи.</target>
        </trans-unit>
        <trans-unit id="1ddfddbb8f225dd73ee75750b50447169433b54f" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; has value 50 (see &lt;code&gt;ct.hrl&lt;/code&gt;). At this level, all standard I/O gets printed. If a lower verbosity level is set, standard I/O printouts are ignored. Verbosity level 0 effectively turns all logging off (except from printouts made by &lt;code&gt;Common Test&lt;/code&gt; itself).</source>
          <target state="translated">Константа &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; имеет значение 50 (см. &lt;code&gt;ct.hrl&lt;/code&gt; ). На этом уровне распечатываются все стандартные операции ввода-вывода. Если установлен более низкий уровень детализации, стандартные распечатки ввода-вывода игнорируются. Уровень детализации 0 эффективно отключает все выходы из системы (кроме распечаток, сделанных самим &lt;code&gt;Common Test&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="44db6a31ddf9435698ec11cd4e92a6b9b7ad2879" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;u$is_bif&lt;/code&gt; will test whether the given operand refers to a BIF. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f1224d66b802b926b2e31ecb1f284682edfb00" translate="yes" xml:space="preserve">
          <source>The construction &lt;code&gt;??Arg&lt;/code&gt;, where &lt;code&gt;Arg&lt;/code&gt; is a macro argument, is expanded to a string containing the tokens of the argument. This is similar to the &lt;code&gt;#arg&lt;/code&gt; stringifying construction in C.</source>
          <target state="translated">Конструкция &lt;code&gt;??Arg&lt;/code&gt; , где &lt;code&gt;Arg&lt;/code&gt; - аргумент макроса, расширяется до строки, содержащей токены аргумента. Это похоже на конструкцию &lt;code&gt;#arg&lt;/code&gt; в C.</target>
        </trans-unit>
        <trans-unit id="e122203f3d8b9817a2ea30ffb99c064337701c17" translate="yes" xml:space="preserve">
          <source>The content and meaning of these messages do not need to be interpreted by the process. Instead the following function is to be called:</source>
          <target state="translated">Содержание и смысл этих сообщений не нуждаются в интерпретации процесса.Вместо этого должна быть вызвана следующая функция:</target>
        </trans-unit>
        <trans-unit id="968fd451ababe1d06f33d9607e5b522cbdd869a3" translate="yes" xml:space="preserve">
          <source>The content of these variables are added to the end of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Содержимое этих переменных добавляется в конец командной строки для &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c18af4769f57f2942d42a8aca949de1aac0af981" translate="yes" xml:space="preserve">
          <source>The content of this file is &lt;strong&gt;only&lt;/strong&gt; valid if the system has been built with 'socket' (esock) support, which is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b69fb0bdc6287d140f1bf18649d3746425bdf1" translate="yes" xml:space="preserve">
          <source>The content of this variable is added to the beginning of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Содержимое этой переменной добавляется в начало командной строки для &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a245ccccd6f901e15ebc8675d831502211bf76e" translate="yes" xml:space="preserve">
          <source>The content-length of the document transferred.</source>
          <target state="translated">Длина передаваемого документа.</target>
        </trans-unit>
        <trans-unit id="a88162e7d9c808763714e1548a612b2fffddbc1c" translate="yes" xml:space="preserve">
          <source>The contents can be any term but in order to simplify post processing of the traced events, a plain list of {Key, Value} tuples is preferred.</source>
          <target state="translated">Содержимое может быть любым,но для упрощения постобработки отслеживаемых событий предпочтительнее использовать простой список кортежей {Key,Value}.</target>
        </trans-unit>
        <trans-unit id="40ce0e904e227f1f1d80e3e97a8e2fc6da1aa9d8" translate="yes" xml:space="preserve">
          <source>The contents of a &lt;code&gt;Mnesia&lt;/code&gt; table are read into the registry.</source>
          <target state="translated">Содержимое таблицы &lt;code&gt;Mnesia&lt;/code&gt; считывается в реестр.</target>
        </trans-unit>
        <trans-unit id="63f1bf049157e992729a0f1938f590c49c434454" translate="yes" xml:space="preserve">
          <source>The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are many top-level alternatives, they do not all have to have the same fixed length. Thus, the following is permitted:</source>
          <target state="translated">Содержание утверждения lookbehind ограничено таким образом,что все совпадающие строки должны иметь фиксированную длину.Однако,если есть много альтернатив верхнего уровня,то не все они должны иметь одинаковую фиксированную длину.Таким образом,допускается следующее:</target>
        </trans-unit>
        <trans-unit id="b15d542467bd5d0c49c3d5fddfb0a1dc700a2884" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file &lt;code&gt;ch_app.app&lt;/code&gt; for a supervision tree application like &lt;code&gt;ch_app&lt;/code&gt; looks as follows:</source>
          <target state="translated">Содержимое минимального &lt;code&gt;.app&lt;/code&gt; файла &lt;code&gt;ch_app.app&lt;/code&gt; для приложения дерева надзора &lt;code&gt;ch_app&lt;/code&gt; выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="639b540a4a0d636d1f2615d8325b2b0b321bfb43" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file for a library application &lt;code&gt;libapp&lt;/code&gt; looks as follows:</source>
          <target state="translated">Содержимое минимального файла &lt;code&gt;.app&lt;/code&gt; для библиотечного приложения &lt;code&gt;libapp&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="19e5034ffd4ea4853bdf97e8c08d5113058028a3" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3ce5ee568b5e2c08421124a730a9db183b8eb2" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="translated">Резервное копирование содержимого реестра может быть выполнено в &lt;code&gt;Mnesia&lt;/code&gt; на &amp;laquo;соседнем&amp;raquo; узле Erlang. Вы должны предоставить открытое соединение с узлом Erlang (см. &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; ). Кроме того, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 или новее должна быть запущена на узле Erlang до начала резервного копирования:</target>
        </trans-unit>
        <trans-unit id="3b51f4efadaec6a78fd43d4f67f7894facdff63a" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3123b00654d44c25109223170c4027e9b8ae5329" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Содержимое &lt;code&gt;iovec&lt;/code&gt; действительно до возврата из вызываемой функции nif. Если &lt;code&gt;iovec&lt;/code&gt; должен быть допустимым после возврата из вызова nif, можно вызвать эту функцию с окружением &lt;code&gt;NULL&lt;/code&gt; . Если окружение не задано, &lt;code&gt;iovec&lt;/code&gt; владеет данными в векторе, и он должен быть явно освобожден с помощью &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da4fbdeab301fdc5a2057978a62de987cbe0d76f" translate="yes" xml:space="preserve">
          <source>The contents of the configuration file can either be fetched from the history or specified directly as a list of &lt;code&gt;{Mod,Func,Args}&lt;/code&gt;.</source>
          <target state="translated">Содержимое файла конфигурации можно либо извлечь из истории, либо указать напрямую в виде списка &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1edda41fc99de03ce1cd51669b6fb86e783cb0c4" translate="yes" xml:space="preserve">
          <source>The contents of the source file is displayed in the &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Содержимое исходного файла отображается в окне &amp;laquo; &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8b2dc86a62154fcfa0997ece50bee44a97b77c" translate="yes" xml:space="preserve">
          <source>The context information should be stored in a file called &lt;code&gt;context.conf&lt;/code&gt;. The default context &lt;code&gt;&quot;&quot;&lt;/code&gt; need not be present.</source>
          <target state="translated">Информация о контексте должна храниться в файле с именем &lt;code&gt;context.conf&lt;/code&gt; . Контекст по умолчанию &lt;code&gt;&quot;&quot;&lt;/code&gt; присутствовать не обязательно.</target>
        </trans-unit>
        <trans-unit id="5e9be9c755c53e0d2a6b371cd0fc254f9029ad4a" translate="yes" xml:space="preserve">
          <source>The continuation of a sequence of fragmented messages looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66a3e2b8c6b44620e15f4c494d018a17436828d" translate="yes" xml:space="preserve">
          <source>The continuation of the first call to the re-entrant input functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding and Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">Продолжение первого вызова реентерабельных функций ввода должно быть &lt;code&gt;[]&lt;/code&gt; . Полное описание того, как работает схема реентерабельного ввода, см. В Armstrong, Virding and Williams: &amp;laquo;Concurrent Programming in Erlang&amp;raquo;, Глава 13.</target>
        </trans-unit>
        <trans-unit id="bd08931a87a0bff5df1d5b202657eaee82a9ec50" translate="yes" xml:space="preserve">
          <source>The continuation pointer, that is, the return address for the current call. Usually useless for other than runtime system developers. This can be followed by the function into which the CP points, which is the function calling the current function.</source>
          <target state="translated">Указатель продолжения,то есть адрес возврата для текущего вызова.Обычно бесполезен для других разработчиков,кроме разработчиков исполнительных систем.За этим может последовать функция,в которую указывает CP,то есть функция,вызывающая текущую функцию.</target>
        </trans-unit>
        <trans-unit id="ea909336d43c335fbcba40445c38198c897e80b9" translate="yes" xml:space="preserve">
          <source>The contracts specified with &lt;code&gt;-callback&lt;/code&gt; attributes in behaviour modules can be further refined by adding &lt;code&gt;-spec&lt;/code&gt; attributes in callback modules. This can be useful as &lt;code&gt;-callback&lt;/code&gt; contracts are usually generic. The same callback module with contracts for the callbacks:</source>
          <target state="translated">Контракты, указанные с &lt;code&gt;-callback&lt;/code&gt; атрибутов -callback в модулях поведения, могут быть дополнительно уточнены путем добавления атрибутов &lt;code&gt;-spec&lt;/code&gt; в модули обратного вызова. Это может быть полезно, поскольку контракты &lt;code&gt;-callback&lt;/code&gt; обычно являются общими. Тот же модуль обратного вызова с контрактами на обратные вызовы:</target>
        </trans-unit>
        <trans-unit id="3e6798c48093d78537c9e8593283bd4708fcad75" translate="yes" xml:space="preserve">
          <source>The control codes that we have defined are as follows:</source>
          <target state="translated">Контрольные коды,которые мы определили,следующие:</target>
        </trans-unit>
        <trans-unit id="7099cc27d42d7b0589281942854b91087bea547b" translate="yes" xml:space="preserve">
          <source>The control interface gets a buffer to return its value in, but is free to allocate its own buffer if the provided one is too small. The &lt;code&gt;uds_control&lt;/code&gt; code is as follows:</source>
          <target state="translated">Интерфейс управления получает буфер для возврата его значения, но может выделить свой собственный буфер, если предоставленный слишком мал. Код &lt;code&gt;uds_control&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="8a434b940ea607f47b9b9c9664fa9c1e4002f5da" translate="yes" xml:space="preserve">
          <source>The convention is that all modules implementing some web server functionality has the name &lt;code&gt;mod_*&lt;/code&gt;. When configuring the web server, an appropriate selection of these modules is to be present in the module directive. Notice that there are some interaction dependencies to take into account, so the order of the modules cannot be random.</source>
          <target state="translated">По соглашению все модули, реализующие некоторые функции веб-сервера, имеют имя &lt;code&gt;mod_*&lt;/code&gt; . При настройке веб-сервера соответствующий выбор этих модулей должен присутствовать в директиве модуля. Обратите внимание на то, что необходимо учитывать некоторые зависимости взаимодействия, поэтому порядок модулей не может быть случайным.</target>
        </trans-unit>
        <trans-unit id="dcdf44cdd25837172eef411728f5162a4d169998" translate="yes" xml:space="preserve">
          <source>The cookie can also be specified as a list with a single atom element.</source>
          <target state="translated">Файл cookie также может быть указан как список с одним элементом атома.</target>
        </trans-unit>
        <trans-unit id="0bba610bff46dca728cdd7bc764ef95f9fb34e4c" translate="yes" xml:space="preserve">
          <source>The cookie extension has two main purposes. It allows the server to force the client to demonstrate reachability at their apparent network address (thus providing a measure of DoS protection). This is primarily useful for non-connection-oriented transports. It also allows to offload the server's state to the client. The cookie extension is enabled by default as it is a mandatory extension in RFC8446.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59a7d0400e25bda45d94942c1696b67b821c833" translate="yes" xml:space="preserve">
          <source>The cookie on the client node is set to &lt;code&gt;Cookie&lt;/code&gt; for this &lt;code&gt;rpc&lt;/code&gt; operation (used to match the server node cookie).</source>
          <target state="translated">Для этого файла cookie на клиентском узле устанавливается значение &lt;code&gt;Cookie&lt;/code&gt; для этой операции &lt;code&gt;rpc&lt;/code&gt; (используется для сопоставления cookie узла сервера).</target>
        </trans-unit>
        <trans-unit id="6205a4b626543ee584a8b3de17a0bb2edfe3da9f" translate="yes" xml:space="preserve">
          <source>The cookies are never sent in cleartext and the handshake procedure expects the client (called &lt;code&gt;A&lt;/code&gt;) to be the first one to prove that it can generate a sufficient digest. The digest is generated with the MD5 message digest algorithm and the challenges are expected to be random numbers.</source>
          <target state="translated">Файлы cookie никогда не отправляются в открытом виде, и процедура подтверждения ожидает, что клиент (называемый &lt;code&gt;A&lt;/code&gt; ) первым докажет, что он может создать достаточный дайджест. Дайджест генерируется с помощью алгоритма дайджеста сообщения MD5, и ожидается, что вызовы будут случайными числами.</target>
        </trans-unit>
        <trans-unit id="2ecaa6909338c5156841fd64226c00c498a1c90e" translate="yes" xml:space="preserve">
          <source>The cookies are text strings that can be viewed as passwords.</source>
          <target state="translated">Файлы cookie представляют собой текстовые строки,которые могут быть просмотрены как пароли.</target>
        </trans-unit>
        <trans-unit id="1a8ed05dd2354fe2176cfcf5ee50be7c3c648bcb" translate="yes" xml:space="preserve">
          <source>The core applications ERTS, Kernel, STDLIB, and SASL never allow real soft upgrade, but require the Erlang emulator to be restarted. This is indicated to the &lt;code&gt;release_handler&lt;/code&gt; by the upgrade instruction &lt;code&gt;restart_new_emulator&lt;/code&gt;. This instruction is always the very first instruction executed, and it restarts the emulator with the new versions of the above mentioned core applications and the old versions of all other applications. When the node is back up, all other upgrade instructions are executed, making sure each application is finally running its new version.</source>
          <target state="translated">Основные приложения ERTS, Kernel, STDLIB и SASL никогда не допускают реального программного обновления, но требуют перезапуска эмулятора Erlang. Об этом сообщает &lt;code&gt;release_handler&lt;/code&gt; инструкция обновления &lt;code&gt;restart_new_emulator&lt;/code&gt; . Эта инструкция всегда выполняется самой первой, и она перезапускает эмулятор с новыми версиями вышеупомянутых основных приложений и старыми версиями всех других приложений. При резервном копировании узла выполняются все остальные инструкции по обновлению, чтобы каждое приложение наконец запускало свою новую версию.</target>
        </trans-unit>
        <trans-unit id="0fa547ec967437cac7e726eba19268112eb4cac1" translate="yes" xml:space="preserve">
          <source>The correct way to write this example is as follows:</source>
          <target state="translated">Правильный способ написания этого примера следующий:</target>
        </trans-unit>
        <trans-unit id="ff048cb1599c9ae21644f42bc221284ba85f60d6" translate="yes" xml:space="preserve">
          <source>The correctness of each application is checked as follows:</source>
          <target state="translated">Корректность каждого приложения проверяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="551bede0ac40e7793c4662c9c5f268e49a7cfe5a" translate="yes" xml:space="preserve">
          <source>The correctness of time values.</source>
          <target state="translated">Правильность временных значений.</target>
        </trans-unit>
        <trans-unit id="b2a787c3a6b18144a9dd01cea8e8539d0c49480c" translate="yes" xml:space="preserve">
          <source>The corresponding Erlang assignments:</source>
          <target state="translated">Соответствующие задания Эрланга:</target>
        </trans-unit>
        <trans-unit id="f464085c70da2d1c15ec4fc3d649680a6fc01752" translate="yes" xml:space="preserve">
          <source>The corresponding Mnesia table is specified as follows:</source>
          <target state="translated">Соответствующая таблица Мнезии указана ниже:</target>
        </trans-unit>
        <trans-unit id="355cfe7dcddd0f236158f7c90d39becfb4d1ea88" translate="yes" xml:space="preserve">
          <source>The corresponding SNMP table would have three columns: &lt;code&gt;department&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;telno&lt;/code&gt;.</source>
          <target state="translated">Соответствующая таблица SNMP будет иметь три столбца: &lt;code&gt;department&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;telno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba81bc06294c512d15b4e936f20c56b7b7af738" translate="yes" xml:space="preserve">
          <source>The corresponding library callback was unsuccessful.</source>
          <target state="translated">Соответствующий обратный вызов библиотеки был неудачным.</target>
        </trans-unit>
        <trans-unit id="3ed401667a17ba645dc4af42fafc330362e9b09e" translate="yes" xml:space="preserve">
          <source>The corresponding process or port is traced. The process or port may be a remote process or port (on another Erlang node). The node must be in the list of traced nodes (see &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Отслеживается соответствующий процесс или порт. Процесс или порт может быть удаленным процессом или портом (на другом узле Erlang). Узел должен быть в списке отслеживаемых узлов (см. &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7fb4487b624fe2c0e433c8d91bb58ba0e2b99b60" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpCommunityTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">Соответствующая таблица - &lt;code&gt;snmpCommunityTable&lt;/code&gt; в SNMP-COMMUNITY-MIB.</target>
        </trans-unit>
        <trans-unit id="536e0673fdce81c6dcbd3b335e2956e57d01fa8e" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpNotifyTable&lt;/code&gt; in the SNMP-NOTIFICATION-MIB.</source>
          <target state="translated">Соответствующая таблица - &lt;code&gt;snmpNotifyTable&lt;/code&gt; в SNMP-NOTIFICATION-MIB.</target>
        </trans-unit>
        <trans-unit id="6418aba8dde22da1e13b2bb9b3980fe5619feec0" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; in the SNMP-TARGET-MIB.</source>
          <target state="translated">Соответствующая таблица - &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; в SNMP-TARGET-MIB.</target>
        </trans-unit>
        <trans-unit id="ffadaae2726db08a3b84abd6faf037b185f11f98" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;usmUserTable&lt;/code&gt; in the SNMP-USER-BASED-SM-MIB.</source>
          <target state="translated">Соответствующая таблица - &lt;code&gt;usmUserTable&lt;/code&gt; в SNMP-USER-BASED-SM-MIB.</target>
        </trans-unit>
        <trans-unit id="7dfdea70a637914fff122f7c22e23e4ca4a56c8f" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; in the SNMP-TARGET-MIB and &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">Соответствующие таблицы: &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; в SNMP-TARGET-MIB и &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; в SNMP-COMMUNITY-MIB.</target>
        </trans-unit>
        <trans-unit id="12ecd355d2a9f8a115a05cf588ffb85e072514b8" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;, &lt;code&gt;vacmAccessTable&lt;/code&gt; and &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; in the SNMP-VIEW-BASED-ACM-MIB.</source>
          <target state="translated">Соответствующими таблицами являются &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; , &lt;code&gt;vacmAccessTable&lt;/code&gt; и &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; в SNMP-VIEW-BASED-ACM-MIB.</target>
        </trans-unit>
        <trans-unit id="09299475ac2ec70dc802979c73301c27a76fa68a" translate="yes" xml:space="preserve">
          <source>The corresponding values were as follows:</source>
          <target state="translated">Соответствующие значения были следующими:</target>
        </trans-unit>
        <trans-unit id="270bee1ebec250d3d9f95f9db65ee55f7e7e584a" translate="yes" xml:space="preserve">
          <source>The cost is substantial: every returned answer is stored in an ETS table. Before returning an answer, it is looked up in the ETS table to check if it has already been returned. Without the &lt;code&gt;unique&lt;/code&gt; option, all answers to &lt;code&gt;QH1&lt;/code&gt; would be returned followed by all answers to &lt;code&gt;QH2&lt;/code&gt;. The &lt;code&gt;unique&lt;/code&gt; option keeps the order between the remaining answers.</source>
          <target state="translated">Стоимость значительная: каждый возвращенный ответ хранится в таблице ETS. Перед возвратом ответа он просматривается в таблице ETS, чтобы проверить, был ли он уже возвращен. Без &lt;code&gt;unique&lt;/code&gt; варианта, все ответы на &lt;code&gt;QH1&lt;/code&gt; будут возвращены следуют все ответы на &lt;code&gt;QH2&lt;/code&gt; . &lt;code&gt;unique&lt;/code&gt; вариант сохраняет порядок между остальными ответами.</target>
        </trans-unit>
        <trans-unit id="949377933f7f31ae27260e61d2614522203d38cb" translate="yes" xml:space="preserve">
          <source>The counter is per listening port. Thus, if two daemons are started, one with &lt;code&gt;{max_sessions,N}&lt;/code&gt; and the other with &lt;code&gt;{max_sessions,M}&lt;/code&gt;, in total &lt;code&gt;N+M&lt;/code&gt; connections are accepted for the whole &lt;code&gt;ssh&lt;/code&gt; application.</source>
          <target state="translated">Счетчик рассчитан на каждый порт прослушивания. Таким образом, если запущены два демона, один с &lt;code&gt;{max_sessions,N}&lt;/code&gt; , а другой с &lt;code&gt;{max_sessions,M}&lt;/code&gt; , в общей сложности будет принято &lt;code&gt;N+M&lt;/code&gt; соединений для всего приложения &lt;code&gt;ssh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672049e9dcd3a0014488ab809e18dd017dc67fc3" translate="yes" xml:space="preserve">
          <source>The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating.</source>
          <target state="translated">В отчете о дорожно-транспортном происшествии содержится ранее сохраненная информация,такая как предки и первоначальная функция,причина прекращения,а также информация о других процессах,которые прекращаются в результате прекращения этого процесса.</target>
        </trans-unit>
        <trans-unit id="e9528cde8205383b9d47742f84a963524c2a4c48" translate="yes" xml:space="preserve">
          <source>The crashed node is distributed but has no references to other nodes.</source>
          <target state="translated">Раздавленный узел распределен,но не имеет ссылок на другие узлы.</target>
        </trans-unit>
        <trans-unit id="7beaf4ed3a100b4464262b486f549894f0ca1c0e" translate="yes" xml:space="preserve">
          <source>The crashed node is not distributed.</source>
          <target state="translated">Разрушенный узел не распределен.</target>
        </trans-unit>
        <trans-unit id="ce14bb9518e3053298709463f31e4be173e33cd1" translate="yes" xml:space="preserve">
          <source>The created digraph has the same type as &lt;code&gt;Digraph&lt;/code&gt;. All vertices and edges have the default &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Созданный орграф имеет тот же тип, что и &lt;code&gt;Digraph&lt;/code&gt; . Все вершины и ребра имеют &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt; по умолчанию &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c87493c7d1e0ec2480a156b7c0c0a9bef2ce5f3" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">Созданный процесс должен предоставлять обратные вызовы и другую информацию, необходимую для рукопожатия, в записи &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; и вызывать &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; с этой записью.</target>
        </trans-unit>
        <trans-unit id="e43aa2bf5d37514d385457e53e7dee018f509f4d" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">Созданный процесс должен предоставлять обратные вызовы и другую информацию, необходимую для рукопожатия, в записи &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; и вызывать &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; с этой записью.</target>
        </trans-unit>
        <trans-unit id="c10988c8597611573efffc7c6d796d8de4ec9158" translate="yes" xml:space="preserve">
          <source>The created supervisor process calls &lt;code&gt;Module:init/1&lt;/code&gt; to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, &lt;code&gt;start_link/2,3&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned and all child processes have been started.</source>
          <target state="translated">Созданный процесс супервизора вызывает &lt;code&gt;Module:init/1&lt;/code&gt; , чтобы узнать о стратегии перезапуска, максимальной интенсивности перезапуска и дочерних процессах. Чтобы гарантировать синхронизированную процедуру запуска, &lt;code&gt;start_link/2,3&lt;/code&gt; не возвращается, пока &lt;code&gt;Module:init/1&lt;/code&gt; не вернется и все дочерние процессы не будут запущены.</target>
        </trans-unit>
        <trans-unit id="524da289676a51a69540a11b458a8fd944a7b7d9" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39edf1d66d588998727b714263ec502579dd9e7b" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="translated">Созданный поток завершается либо при возврате &lt;code&gt;func&lt;/code&gt; либо при &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; значение потока либо возвращается из &lt;code&gt;func&lt;/code&gt; , либо передается в качестве аргумента в erl_drv_thread_exit . Драйвер, создающий поток, отвечает за присоединение к потоку через &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; перед выгрузкой драйвера. &amp;laquo;Отсоединенные&amp;raquo; потоки не могут быть созданы, то есть потоки, которые не нужно объединять.</target>
        </trans-unit>
        <trans-unit id="2caf2e3a9d3cd22055ea221541023c0a7f9e5f06" translate="yes" xml:space="preserve">
          <source>The creation number for a listen socket, which is calculated as (the value found in the lock-file + 1) rem 4. This creation value is also written back into the lock file, so that the next invocation of the emulator finds our value in the file.</source>
          <target state="translated">Номер создания для прослушивающего сокета,который вычисляется как (значение,найденное в файле блокировки+1)rem 4.Это значение создания также записывается обратно в файл блокировки,так что следующий вызов эмулятора находит наше значение в файле.</target>
        </trans-unit>
        <trans-unit id="adcdb05ae9295c817de82d7381820b023af67f91" translate="yes" xml:space="preserve">
          <source>The creation number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Номер создания в pid &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f64ba9b5d10763eb9a59dc112c16b79857dd73" translate="yes" xml:space="preserve">
          <source>The creation number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Номер создания в порту &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50c7d8a3f3ea2d88f57c174b641c9f8441bf8c61" translate="yes" xml:space="preserve">
          <source>The creation number in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Число создания в иом &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1597c6b33ee04607a4ecaec944fa0178d3d2dc29" translate="yes" xml:space="preserve">
          <source>The creation of the specification for a target system is performed in two steps. In the first step a complete specification is generated. It will likely contain much more files than you are interested in in your customized target system. In the second step the specification will be filtered according to your filters. There you have the ability to specify filters per application as well as system wide filters. You can also select a &lt;code&gt;profile&lt;/code&gt; for your system. Depending on the &lt;code&gt;profile&lt;/code&gt;, different default filters will be used. There are three different profiles to choose from: &lt;code&gt;development&lt;/code&gt;, &lt;code&gt;embedded&lt;/code&gt; and &lt;code&gt;standalone&lt;/code&gt;. &lt;code&gt;development&lt;/code&gt; is default. The parameters that are affected by the &lt;code&gt;profile&lt;/code&gt; are: &lt;code&gt;incl_sys_filters&lt;/code&gt;, &lt;code&gt;excl_sys_filters&lt;/code&gt;, &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;.</source>
          <target state="translated">Создание спецификации целевой системы выполняется в два этапа. На первом этапе создается полная спецификация. Скорее всего, он будет содержать гораздо больше файлов, чем вас интересует ваша настроенная целевая система. На втором этапе спецификация будет отфильтрована в соответствии с вашими фильтрами. Там у вас есть возможность указать фильтры для каждого приложения, а также фильтры для всей системы. Вы также можете выбрать &lt;code&gt;profile&lt;/code&gt; для своей системы. В зависимости от &lt;code&gt;profile&lt;/code&gt; будут использоваться разные фильтры по умолчанию. На выбор предлагается три разных профиля: &lt;code&gt;development&lt;/code&gt; , &lt;code&gt;embedded&lt;/code&gt; и &lt;code&gt;standalone&lt;/code&gt; . &lt;code&gt;development&lt;/code&gt; по умолчанию. Параметры, на которые влияет &lt;code&gt;profile&lt;/code&gt; : &lt;code&gt;incl_sys_filters&lt;/code&gt; , &lt;code&gt;excl_sys_filters&lt;/code&gt; , &lt;code&gt;incl_app_filters&lt;/code&gt; и &lt;code&gt;excl_app_filters&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0455f1d04df5058ea9aa40b1a076812ef2243c2" translate="yes" xml:space="preserve">
          <source>The creation time for the dump</source>
          <target state="translated">Время создания свалки</target>
        </trans-unit>
        <trans-unit id="65280108d9a3568933bcafdbf482cccdf0bd7634" translate="yes" xml:space="preserve">
          <source>The cross cover mechanism allows cover analysis of modules across multiple tests. It is useful if some code, for example, a library module, is used by many different tests and the accumulated cover result is desirable.</source>
          <target state="translated">Механизм перекрестного покрытия позволяет проводить анализ модулей по нескольким тестам.Он полезен,если некоторый код,например,модуль библиотеки,используется многими различными тестами и желателен накопленный результат покрытия.</target>
        </trans-unit>
        <trans-unit id="b20f15741df0176d3ffd68b64d6a68cc69323d01" translate="yes" xml:space="preserve">
          <source>The crypto application supports using OpenSSL in FIPS mode. In this scenario only the validated algorithms provided by the Object Module are accessible, other algorithms usually available in OpenSSL (like md5) or implemented in the Erlang code (like SRP) are disabled.</source>
          <target state="translated">Криптографическое приложение поддерживает использование OpenSSL в режиме FIPS.В этом сценарии доступны только проверенные алгоритмы,предоставляемые объектным модулем,другие алгоритмы,обычно доступные в OpenSSL (например,md5)или реализованные в коде Erlang (например,SRP),отключены.</target>
        </trans-unit>
        <trans-unit id="67aa64b8718cdca92f0e4f9624ec881b790bb44a" translate="yes" xml:space="preserve">
          <source>The cryptolib OTP is linked with, usally the one the OS uses, probably OpenSSL,</source>
          <target state="translated">Криптолибный OTP связан с тем,который используется операционной системой,вероятно,OpenSSL,</target>
        </trans-unit>
        <trans-unit id="492e509e88f1a8adb3eb77ab3f838d0078ce68f0" translate="yes" xml:space="preserve">
          <source>The current URI implementation provides support for producing and consuming standard URIs. The API is not meant to be directly exposed in a Web browser's address bar where users can basically enter free text. Application designers shall implement proper heuristics to map the input into a parsable URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0da38521cbe8e331fa3581916f1bfca4dc26d7" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send a &quot;demonitor signal&quot; to the monitored entity and ignore any future results of the monitor.</source>
          <target state="translated">Текущее поведение можно рассматривать как две комбинированные операции:асинхронно посылать &quot;демонический сигнал&quot; на контролируемую сущность и игнорировать любые будущие результаты монитора.</target>
        </trans-unit>
        <trans-unit id="3c2e4d473b72e94c41373ad9e09ba22c294ebb64" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send an &quot;unlink signal&quot; to the linked entity and ignore any future results of the link.</source>
          <target state="translated">Текущее поведение можно рассматривать как две комбинированные операции:асинхронно посылать сигнал &quot;unlink signal&quot; на подключенную сущность и игнорировать любые будущие результаты соединения.</target>
        </trans-unit>
        <trans-unit id="d5b1d2a40e48d00196c6b21b7ac5dc93cf3228c9" translate="yes" xml:space="preserve">
          <source>The current function of the process. These fields do not always exist.</source>
          <target state="translated">Текущая функция процесса.Эти поля существуют не всегда.</target>
        </trans-unit>
        <trans-unit id="976f361d5fa6f84f4966eb0b28babd0491898a1f" translate="yes" xml:space="preserve">
          <source>The current implementation assumes the requests to the same host, port combination will use the same socket options.</source>
          <target state="translated">Текущая реализация предполагает запросы к одному и тому же хосту,комбинация портов будет использовать одни и те же опции сокета.</target>
        </trans-unit>
        <trans-unit id="01444d008abb77ac03ebfb5697a017f621eb7172" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;erts_alloc_config&lt;/code&gt; concentrate on configuration of multi-block carriers. Information gathered when a runtime scenario is saved is mainly current and maximum use of multi-block carriers. If a parameter that change the use of multi-block carriers is changed, a previously generated configuration is invalid and &lt;code&gt;erts_alloc_config&lt;/code&gt; needs to be run again. It is mainly the single block carrier threshold that effects the use of multi-block carriers, but other single-block carrier parameters might as well. If another value of a single block carrier parameter than the default is desired, use the desired value when running &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">Текущая реализация &lt;code&gt;erts_alloc_config&lt;/code&gt; сосредоточена на настройке многоблочных носителей. Информация, собранная при сохранении сценария выполнения, в основном представляет собой текущее и максимальное использование многоблочных носителей. Если параметр, который изменяет использование многоблочных несущих, изменяется, ранее сгенерированная конфигурация недействительна и &lt;code&gt;erts_alloc_config&lt;/code&gt; необходимо запустить снова. В основном порог одиночной блочной несущей влияет на использование многоблочных несущих, но другие параметры одноблочной несущей также могут. Если требуется другое значение параметра несущей одного блока, чем значение по умолчанию, используйте желаемое значение при запуске &lt;code&gt;erts_alloc_config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b881e02c8b7eb97ec891648e528239530b927d31" translate="yes" xml:space="preserve">
          <source>The current implementation of Erlang does not care if the connection to the EPMD is broken.</source>
          <target state="translated">Текущая реализация Erlang не заботится о том,чтобы соединение с EPMD было прервано.</target>
        </trans-unit>
        <trans-unit id="5aa015243755c53ad9ba52e113a6e0dd6e7a2f3a" translate="yes" xml:space="preserve">
          <source>The current implementation of persistent terms uses the literal &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;allocator&lt;/a&gt;&lt;/code&gt; also used for literals (constant terms) in BEAM code. By default, 1 GB of virtual address space is reserved for literals in BEAM code and persistent terms. The amount of virtual address space reserved for literals can be changed by using the &lt;code&gt;&lt;a href=&quot;erts_alloc#MIscs&quot;&gt;+MIscs option&lt;/a&gt;&lt;/code&gt; when starting the emulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc5fcd6f03a44ee0e92fb43ab0fad65cf1d2c29" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port program written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906db1d57b72f269a5be2b6efa0e34d3a4f40e71" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port programm written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="translated">Текущая реализация порождает программу порта,написанную на C,которая использует фактический драйвер ODBC.По умолчанию таймаут 5000 мс для этой программы порта для подключения к приложению ODBC Эрланга.Этот таймаут может быть изменен установкой переменной окружения 'port_timeout' с количеством миллисекунд для приложения ODBC.Например [{odbc,[{port_timeout,60000}]}]установить значение 60 секунд.</target>
        </trans-unit>
        <trans-unit id="a66939d304da82c348947adb4cca67a3063533ce" translate="yes" xml:space="preserve">
          <source>The current implementation uses a pair of Bloom filters to implement the last two mechanisms. Bloom filters are fast, memory-efficient, probabilistic data structures that can tell if an element may be in a set or if it is definitely not in the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d365424f69367126413adcf57829b464b5f9add" translate="yes" xml:space="preserve">
          <source>The current instruction pointer. This is only of interest for runtime system developers. The function into which the program counter points is the current function of the process.</source>
          <target state="translated">Текущий указатель на инструкцию.Это представляет интерес только для разработчиков runtime-систем.Функция,в которую указывает счетчик программы,является текущей функцией процесса.</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="translated">Номер текущей линии.</target>
        </trans-unit>
        <trans-unit id="67653b4ba83e7d00b28af91f8d3fe0dae7dfae29" translate="yes" xml:space="preserve">
          <source>The current local working directory (compare &lt;code&gt;lpwd/1&lt;/code&gt;) is set to the value reported by &lt;code&gt;file:get_cwd/1&lt;/code&gt;, the wanted local directory.</source>
          <target state="translated">Для текущего локального рабочего каталога (сравните &lt;code&gt;lpwd/1&lt;/code&gt; ) установлено значение, указанное в &lt;code&gt;file:get_cwd/1&lt;/code&gt; , желаемый локальный каталог.</target>
        </trans-unit>
        <trans-unit id="0bd1444e43ba871d9585120022333d4590131f8a" translate="yes" xml:space="preserve">
          <source>The current options are:</source>
          <target state="translated">Текущие варианты:</target>
        </trans-unit>
        <trans-unit id="5616c509d6bccb6c79f91ec22fce5ea75deae243" translate="yes" xml:space="preserve">
          <source>The current position of the file after the operation is undefined for &lt;code&gt;raw&lt;/code&gt; mode and unchanged for &lt;code&gt;ram&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b93308e4fc131191ae4908faed86620396f4d9" translate="yes" xml:space="preserve">
          <source>The current position of the file is undefined after the operation.</source>
          <target state="translated">Текущее положение файла после операции не определено.</target>
        </trans-unit>
        <trans-unit id="a23e8329113f0ad4178af5cd91d27561b0a29cbd" translate="yes" xml:space="preserve">
          <source>The current reference count after the decrement has been performed is returned.</source>
          <target state="translated">Возвращается текущий счетчик ссылок после выполнения декремента.</target>
        </trans-unit>
        <trans-unit id="24502690d2f3bb086d825806372b93e14c48a509" translate="yes" xml:space="preserve">
          <source>The current reference count after the increment has been performed is returned.</source>
          <target state="translated">После выполнения инкремента возвращается текущий счетчик опорных значений.</target>
        </trans-unit>
        <trans-unit id="9fd7feb388311de9e1a9de0daaa94dc63a945932" translate="yes" xml:space="preserve">
          <source>The current status of the &lt;code&gt;init&lt;/code&gt; process can be inspected. During system startup (initialization), &lt;code&gt;InternalStatus&lt;/code&gt; is &lt;code&gt;starting&lt;/code&gt;, and &lt;code&gt;ProvidedStatus&lt;/code&gt; indicates how far the boot script has been interpreted. Each &lt;code&gt;{progress, Info}&lt;/code&gt; term interpreted in the boot script affects &lt;code&gt;ProvidedStatus&lt;/code&gt;, that is, &lt;code&gt;ProvidedStatus&lt;/code&gt; gets the value of &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">Текущий статус процесса &lt;code&gt;init&lt;/code&gt; можно проверить. Во время запуска системы (инициализация), &lt;code&gt;InternalStatus&lt;/code&gt; является &lt;code&gt;starting&lt;/code&gt; и &lt;code&gt;ProvidedStatus&lt;/code&gt; показывает , насколько загрузочный скрипт был интерпретирован. Каждый термин &lt;code&gt;{progress, Info}&lt;/code&gt; интерпретируемый в сценарии загрузки, влияет на &lt;code&gt;ProvidedStatus&lt;/code&gt; , то есть &lt;code&gt;ProvidedStatus&lt;/code&gt; получает значение &lt;code&gt;Info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b80e18839956d4be32e5bd88643c826f791ac807" translate="yes" xml:space="preserve">
          <source>The current status, one of the following:</source>
          <target state="translated">Текущее состояние,одно из следующих:</target>
        </trans-unit>
        <trans-unit id="c7113183a7426c44fe409b00b899d8a41fc5814b" translate="yes" xml:space="preserve">
          <source>The current system access to the file.</source>
          <target state="translated">Текущий доступ системы к файлу.</target>
        </trans-unit>
        <trans-unit id="8ada96b90a0d9236a710ef755016c1b7cca9e74d" translate="yes" xml:space="preserve">
          <source>The current token of a process is set in one of the following two ways:</source>
          <target state="translated">Текущий токен процесса устанавливается одним из следующих двух способов:</target>
        </trans-unit>
        <trans-unit id="283b878d1d463389e9688a4d3aa6791beee18572" translate="yes" xml:space="preserve">
          <source>The current type/state of the port, which can be one of the values declared above.</source>
          <target state="translated">Текущий тип/состояние порта,которое может быть одним из значений,объявленных выше.</target>
        </trans-unit>
        <trans-unit id="d59825d9fb6ddec0b7e1b9ca60e8a4611098dbe2" translate="yes" xml:space="preserve">
          <source>The current version of &lt;code&gt;Mnesia&lt;/code&gt; does not require that the name of the table is the same as the record name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Текущая версия &lt;code&gt;Mnesia&lt;/code&gt; не требует, чтобы имя таблицы совпадало с именем записи, см. &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8c67d44d5188c140bb3bee7f987dfb33d7ef9f83" translate="yes" xml:space="preserve">
          <source>The current working directory</source>
          <target state="translated">Текущая рабочая директория</target>
        </trans-unit>
        <trans-unit id="76bbefce7d446f03b26631d5bb9ced8525a0f785" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This is to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d4a882ed6c30c03ae65ca2d8cd5ad27f2a5741" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="translated">Текущий рабочий каталог &lt;code&gt;&quot;.&quot;&lt;/code&gt; , не включается в путь кода при запуске компилятора. Это позволяет избежать загрузки файлов Beam из текущего рабочего каталога, которые потенциально могут конфликтовать с компилятором или системой Erlang / OTP, используемой компилятором.</target>
        </trans-unit>
        <trans-unit id="2fa5b9ac3977e02e3cf7d97b73ce85358c04959d" translate="yes" xml:space="preserve">
          <source>The currently executing process (that is, the sender) is not alive.</source>
          <target state="translated">Выполняемый в настоящее время процесс (т.е.отправитель)не жив.</target>
        </trans-unit>
        <trans-unit id="953e09eadeb4be83fa11df49bf70c92f526cc8f1" translate="yes" xml:space="preserve">
          <source>The daemon is started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; if the node is to be distributed and no running instance is present. If automatically launched environment variables must be used to change the behavior of the daemon; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Демон запускается автоматически с помощью команды &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; если узел должен быть распределен, а запущенный экземпляр отсутствует. Если запускается автоматически, переменные среды должны использоваться для изменения поведения демона; см. раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d21e1220084b94119a9a3ad063df2a21e482723" translate="yes" xml:space="preserve">
          <source>The data bytes of the AVP.</source>
          <target state="translated">Байты данных AVP.</target>
        </trans-unit>
        <trans-unit id="f18388ef7ec4c10925540637ae1909f34a929370" translate="yes" xml:space="preserve">
          <source>The data contains errors.</source>
          <target state="translated">Данные содержат ошибки.</target>
        </trans-unit>
        <trans-unit id="078b2a841f3b60a68b21c7cb12cdb8e09a9dd362" translate="yes" xml:space="preserve">
          <source>The data delivery order can be relaxed by disabling features that require strict ordering. This is done by passing the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record used when setting up the connection. When relaxed ordering is used, only the order of signals with the same sender/receiver pair has to be preserved. However, note that disabling the features that require strict ordering may have a negative impact on performance, throughput, and/or latency.</source>
          <target state="translated">Порядок доставки данных можно уменьшить, отключив функции, требующие строгого упорядочивания. Это делается путем передачи &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; , возвращаемые &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; поле &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; записи , используемые при настройке соединения. При использовании ослабленного упорядочивания необходимо сохранять только порядок сигналов с одной и той же парой отправитель / получатель. Однако обратите внимание, что отключение функций, требующих строгого упорядочивания, может отрицательно сказаться на производительности, пропускной способности и / или задержке.</target>
        </trans-unit>
        <trans-unit id="f7a26a04ef322bb19505a5c1dc8d45f5e01e5f3f" translate="yes" xml:space="preserve">
          <source>The data formats defined in sections 4.2 (&quot;Basic AVP Data Formats&quot;) and 4.3 (&quot;Derived AVP Data Formats&quot;) of RFC 6733 are encoded as values of the types defined here. Values are passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; in a request record when sending a request, returned in a resulting answer record and passed to a &lt;code&gt;handle_request/3&lt;/code&gt; callback upon reception of an incoming request.</source>
          <target state="translated">Форматы данных, определенные в разделах 4.2 (&amp;laquo;Основные форматы данных AVP&amp;raquo;) и 4.3 (&amp;laquo;Производные форматы данных AVP&amp;raquo;) RFC 6733, кодируются как значения типов, определенных здесь. Значения передаются в &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; в записи запроса при отправке запроса, возвращаются в результирующей записи ответа и передаются в &lt;code&gt;handle_request/3&lt;/code&gt; вызов handle_request / 3 при получении входящего запроса.</target>
        </trans-unit>
        <trans-unit id="fdf833224017bb981586f311e5704bede95ecd92" translate="yes" xml:space="preserve">
          <source>The data in the boot script, fetched from the new application resource file &lt;code&gt;App.app&lt;/code&gt;</source>
          <target state="translated">Данные в сценарии загрузки, извлеченные из нового файла ресурсов приложения &lt;code&gt;App.app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf8c73b58d26cdb1cd37eb82749dddb7b4d25b8e" translate="yes" xml:space="preserve">
          <source>The data in the header is sent as a list and the binary as an Erlang binary in the tail of the list.</source>
          <target state="translated">Данные в заголовке отправляются в виде списка,а двоичный файл-в виде двоичного файла Erlang в хвосте списка.</target>
        </trans-unit>
        <trans-unit id="fe96a6cdbbb26d9c1b8c04531c8c51ed5ebb111d" translate="yes" xml:space="preserve">
          <source>The data is at &lt;code&gt;p&lt;/code&gt;. The length of the bit string is &lt;code&gt;nbits&lt;/code&gt; bits. The first &lt;code&gt;bitoffs&lt;/code&gt; bits of the data at &lt;code&gt;p&lt;/code&gt; are unused. The first byte which is part of the bit string is &lt;code&gt;p[bitoffs/8]&lt;/code&gt;. The &lt;code&gt;bitoffs%8&lt;/code&gt; most significant bits of the first byte &lt;code&gt;p[bitoffs/8]&lt;/code&gt; are unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8a427227bcde27fb34708c1f8037df0476db96" translate="yes" xml:space="preserve">
          <source>The data is queued in the port owner process' message queue. Notice that this does not yield to the emulator (as the driver and the emulator run in the same thread).</source>
          <target state="translated">Данные ставятся в очередь в очереди сообщений процесса владельца порта.Обратите внимание,что это не уступает эмулятору (так как драйвер и эмулятор работают в одном потоке).</target>
        </trans-unit>
        <trans-unit id="5209f4c8cd33cb9b06c7cafb6cfe1d7ba8e19dd5" translate="yes" xml:space="preserve">
          <source>The data is thus at &lt;code&gt;buf[*index]&lt;/code&gt; when an &lt;code&gt;ei&lt;/code&gt; function is called.</source>
          <target state="translated">Таким образом, данные находятся в &lt;code&gt;buf[*index]&lt;/code&gt; когда вызывается функция &lt;code&gt;ei&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a0aaa71e50e0fe09624f658b5194caa4fc82ffa" translate="yes" xml:space="preserve">
          <source>The data model employed by &lt;code&gt;Mnesia&lt;/code&gt; is an extended relational data model. Data is organized as a set of tables and relations between different data records can be modeled as more tables describing the relationships. Each table contains instances of Erlang records. The records are represented as Erlang tuples.</source>
          <target state="translated">Модель данных, используемая &lt;code&gt;Mnesia&lt;/code&gt; , представляет собой расширенную реляционную модель данных. Данные организованы в виде набора таблиц, и отношения между различными записями данных можно смоделировать в виде большего количества таблиц, описывающих эти отношения. Каждая таблица содержит экземпляры записей Erlang. Записи представлены в виде кортежей Erlang.</target>
        </trans-unit>
        <trans-unit id="bcffc5bb38e63b17337f4be90db30aa76b246a80" translate="yes" xml:space="preserve">
          <source>The data produced by the lock counters will give an estimate on how well the runtime system will behave from a parallelizable view point for the scenarios tested. This tool was mainly developed to help Erlang runtime developers iron out potential and generic bottlenecks.</source>
          <target state="translated">Данные,полученные счетчиками блокировок,дадут оценку того,насколько хорошо будет вести себя исполнительная система с параллельной точки зрения для тестируемых сценариев.Этот инструмент был в основном разработан,чтобы помочь разработчикам Erlang runtime сгладить потенциальные и общие узкие места.</target>
        </trans-unit>
        <trans-unit id="2d27f50b0cd05524a7fd478c731d913e31e93736" translate="yes" xml:space="preserve">
          <source>The data representing a queue as used by this module is to be regarded as opaque by other modules. Any code assuming knowledge of the format is running on thin ice.</source>
          <target state="translated">Данные,представляющие очередь в том виде,в каком они используются этим модулем,должны рассматриваться другими модулями как непрозрачные.Любой код,предполагающий знание формата,выполняется на тонком льду.</target>
        </trans-unit>
        <trans-unit id="53c6baece120e0ea5f4f690528bc1b24d8b68a2f" translate="yes" xml:space="preserve">
          <source>The data structure referring to this single linked list cover two cache lines. One cache line containing information about the head of the list, and one cache line containing information about the tail of the list. This in order to reduce cache line ping ponging of this data structure. The head of the list will only be manipulated by the thread owning the allocator instance, and the tail will be manipulated by other threads inserting deallocation jobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966785b6ae629e19c8bed0b0d3e6ef6f991ec06e" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; in event &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Данные, которые поставляются с &lt;code&gt;Reason&lt;/code&gt; ,имеют тот же формат, что и &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; в событии &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt; . Подробнее см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; &amp;raquo; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="bb604c10fe966845cdde71367a93dbf6cc929795" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as events &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Данные, которые поставляются с &lt;code&gt;Reason&lt;/code&gt; ,имеют тот же формат, что и события &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; . Подробнее см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="3ae9537a2b782dfe6dcee8743658b21ed9b0301d" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt;, is represented as the following erlang record:</source>
          <target state="translated">Тип данных &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt; представлен в виде следующей записи erlang:</target>
        </trans-unit>
        <trans-unit id="feae33cf3d811c301bdaf1550728e179af863677" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;'Validity'&lt;/code&gt;, &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, and &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; are represented as the following Erlang records:</source>
          <target state="translated">Типы данных &lt;code&gt;'Validity'&lt;/code&gt; , &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; и &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; представлены в виде следующих записей Erlang:</target>
        </trans-unit>
        <trans-unit id="93bf041facbb4e82a9e8c285ac8447b2c8201746" translate="yes" xml:space="preserve">
          <source>The database can also become inconsistent if configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; is used or if &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; is used.</source>
          <target state="translated">База данных также может стать несогласованной, если используется параметр конфигурации &lt;code&gt;max_wait_for_decision&lt;/code&gt; или если используется &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="264b842db8bf0ed81b261f12d4ee28f9ed7af246" translate="yes" xml:space="preserve">
          <source>The database can be reconfigured, and tables can be moved between nodes. These operations do not affect the user programs.</source>
          <target state="translated">БД может быть переконфигурирована,а таблицы можно перемещать между узлами.Эти операции не влияют на пользовательские программы.</target>
        </trans-unit>
        <trans-unit id="7c3e27d69c9e2bbfe084964b4ba1a3ee0b761dd5" translate="yes" xml:space="preserve">
          <source>The database model is as follows:</source>
          <target state="translated">Модель базы данных выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="4b5b0c5d2b259e474f8fd1130e7a9869d03ac6fb" translate="yes" xml:space="preserve">
          <source>The date and time when the process was started.</source>
          <target state="translated">Дата и время начала процесса.</target>
        </trans-unit>
        <trans-unit id="fe8362a1d9af54200a42df54d2c52d6145175ad5" translate="yes" xml:space="preserve">
          <source>The debug enabled runtime system features lock violation checking, assert checking and various sanity checks to help a developer ensure correctness. Some of these features can be enabled on a normal beam using appropriate configure options.</source>
          <target state="translated">Отладочная система включает в себя проверку на нарушение блокировки,проверку утверждений и различные проверки вменяемости,чтобы помочь разработчику убедиться в корректности работы.Некоторые из этих функций могут быть включены на обычном луче с помощью соответствующих опций конфигурации.</target>
        </trans-unit>
        <trans-unit id="c6dd12423efe39c011d13a41f3ecdda00e9c96f5" translate="yes" xml:space="preserve">
          <source>The debug information can also be removed from BEAM files using &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt;, and/or &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Отладочную информацию также можно удалить из файлов BEAM с помощью &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt; и / или &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fcf3b68d8f8e511e6ff9331d892546d1029cbf5" translate="yes" xml:space="preserve">
          <source>The debug information can be encrypted to keep the source code secret, but still be able to use tools such as Debugger or Xref.</source>
          <target state="translated">Отладочную информацию можно зашифровать,чтобы сохранить исходный код в тайне,но при этом использовать такие инструменты,как Debugger или Xref.</target>
        </trans-unit>
        <trans-unit id="7fcc7761d46f20ec162261ce0e8d0b6a28d90fe6" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; is set by calling the function &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Level&lt;/code&gt;is one of the following:</source>
          <target state="translated">Уровень отладки &lt;code&gt;Mnesia&lt;/code&gt; устанавливается путем вызова функции &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt; , где &lt;code&gt;Level&lt;/code&gt; является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="8f1bdc53b01108885cce2234b4e2d9b39baa8b28" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; itself is also an application parameter, making it possible to start an Erlang system to turn on &lt;code&gt;Mnesia&lt;/code&gt; debug in the initial startup phase by using the following code:</source>
          <target state="translated">Уровень отладки самой &lt;code&gt;Mnesia&lt;/code&gt; также является параметром приложения, что позволяет запустить систему Erlang для включения отладки &lt;code&gt;Mnesia&lt;/code&gt; на начальном этапе запуска с помощью следующего кода:</target>
        </trans-unit>
        <trans-unit id="15f3b5f9fa804bcf46e507eb72dd7777e9dc6ab9" translate="yes" xml:space="preserve">
          <source>The decode and encode functions use a buffer and an index into the buffer, which points at the point where to encode and decode. The index is updated to point right after the term encoded/decoded. No checking is done whether the term fits in the buffer or not. If encoding goes outside the buffer, the program can crash.</source>
          <target state="translated">Функции декодирования и декодирования используют буфер и индекс в буфере,который указывает на место кодирования и декодирования.Индекс обновляется до точки сразу после срока кодирования/декодирования.Не производится проверка того,умещается ли термин в буфере или нет.Если кодировка выходит за пределы буфера,программа может аварийно завершить свою работу.</target>
        </trans-unit>
        <trans-unit id="bb7a0f41f8f9cd301571e70dc3544c6857e6778d" translate="yes" xml:space="preserve">
          <source>The decode functions return a record as result when decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; or a &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">Функции декодирования возвращают запись как результат при декодировании &lt;code&gt;SEQUENCE&lt;/code&gt; или &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cef0dcfb934889d6cf431e5ebf6fd74edf18c281" translate="yes" xml:space="preserve">
          <source>The decoded value of an AVP. Will be &lt;code&gt;undefined&lt;/code&gt; on decode if the data bytes could not be decoded, the AVP is unknown, or if the &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;. The type of a decoded value is as document in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Декодированное значение AVP. Будет &lt;code&gt;undefined&lt;/code&gt; на декодировании , если байты данных не может быть декодирован, AVP неизвестна, или если &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; не является &lt;code&gt;none&lt;/code&gt; . Тип декодированного значения - как документ в &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dd25b2c0dae34a4ccb0be97da547058ad3ae8fb" translate="yes" xml:space="preserve">
          <source>The decoder returns an atom if the value corresponds to a symbol in the &lt;code&gt;Named Number List&lt;/code&gt;.</source>
          <target state="translated">Декодер возвращает атом, если значение соответствует символу в &lt;code&gt;Named Number List&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c388aad8aed6c9f2fdd03a9ff95a76e605fea9f6" translate="yes" xml:space="preserve">
          <source>The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). If locale-specific matching is taking place, the list of space characters may be different; there may be fewer or more of them. &quot;Space&quot; used to be different to \s, which did not include VT, for Perl compatibility. However, Perl changed at release 5.18, and PCRE followed at release 8.34. &quot;Space&quot; and \s now match the same set of characters.</source>
          <target state="translated">Символами &quot;пробел&quot; по умолчанию являются HT (9),LF (10),VT (11),FF (12),CR (13)и пробел (32).Если происходит локальное совпадение,список символов пробела может отличаться;их может быть меньше или больше.&quot;Пробел&quot; раньше отличался от \s,который не включал VT,для совместимости с Perl.Однако,Perl изменился в версии 5.18,а PCRE последовал в версии 8.34.&quot;Пробел&quot; и \s теперь соответствуют одному и тому же набору символов.</target>
        </trans-unit>
        <trans-unit id="c59d65c8568f18df7ae19973d7555f547a715db3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Collector Filter&lt;/code&gt; converts the raw Erlang trace data format into &lt;code&gt;Event Records&lt;/code&gt;. If you want to perform this differently you can of course write your own &lt;code&gt;Collector Filter&lt;/code&gt; from scratch. But it may probably save you some efforts if you first apply the default filter in &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; before you apply your own conversions of its output.</source>
          <target state="translated">&lt;code&gt;Collector Filter&lt;/code&gt; умолчанию преобразует необработанный формат данных трассировки Erlang в записи &lt;code&gt;Event Records&lt;/code&gt; . Если вы хотите сделать это по-другому, вы, конечно, можете написать свой собственный &lt;code&gt;Collector Filter&lt;/code&gt; с нуля. Но это, вероятно, может сэкономить вам некоторые усилия, если вы сначала примените фильтр по умолчанию в &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; , прежде чем применять свои собственные преобразования его вывода.</target>
        </trans-unit>
        <trans-unit id="c57652a6dee935467cebeeed4f3fb7d6f7116fee" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Size&lt;/code&gt; depends on the type. For integer it is 8. For float it is 64. For binary it is all of the binary. In matching, this default value is only valid for the last element. All other binary elements in matching must have a size specification.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; по умолчанию зависит от типа. Для целых чисел это 8. Для чисел с плавающей запятой это 64. Для двоичных чисел это все двоичные. При сопоставлении это значение по умолчанию действительно только для последнего элемента. Все остальные двоичные элементы в сопоставлении должны иметь спецификацию размера.</target>
        </trans-unit>
        <trans-unit id="4dbb7545b0f004e8ef75d97150f80d5c45826ac3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;StatisticsSpec&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7491f9d8e8f98f36325638513ac80bfc97bc47c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt; +hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1c0b4c022d0f07743e56c51911904bc53375f9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Флаг процесса &lt;code&gt;message_queue_data&lt;/code&gt; по умолчанию определяется аргументом командной строки &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="572022a6b410479721a7992c7362b7aaff7907d4" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used and the result is returned to the client.</source>
          <target state="translated">По умолчанию используется вычислитель Erlang и результат возвращается клиенту.</target>
        </trans-unit>
        <trans-unit id="eac2ba828452672a63c684b8e844a11cc19d5eee" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used both for exec and shell requests. The result is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fd0465cd657366b4590ae0f113c518fee5324c" translate="yes" xml:space="preserve">
          <source>The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode code point for the character.</source>
          <target state="translated">По умолчанию кодировка Юникода в Erlang находится в двоичной кодировке UTF-8,которая также является форматом,в котором встроенные функции и библиотеки в OTP ожидают найти двоичные данные Юникода.В списках данные в кодировке Юникод кодируются как целые числа,каждое целое число представляет один символ и кодируется просто как точка кода Юникода для этого символа.</target>
        </trans-unit>
        <trans-unit id="49cebb251d6b0aa1500584bc73027335bd0baea3" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116+). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="translated">Алгоритм по умолчанию - &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116 +). Если требуется конкретный алгоритм, всегда используйте &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; для инициализации состояния.</target>
        </trans-unit>
        <trans-unit id="2258a0b4b5ba55503b1e33ac02535a01630a7012" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exsss&lt;/code&gt; (Xorshift116**). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt; seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb49c55e11d37a2c7f97be97bd91839e01e102b" translate="yes" xml:space="preserve">
          <source>The default behaviour in the two other cases (that is, abnormal exit) above is to:</source>
          <target state="translated">Поведение по умолчанию в двух других случаях (т.е.ненормальный выход)выше:</target>
        </trans-unit>
        <trans-unit id="9aad933f8a23be0b8f60b2f0009c014495bcab97" translate="yes" xml:space="preserve">
          <source>The default behaviour is ignore the message. To get a printout for each message with &lt;code&gt;AlwaysDisplay = true&lt;/code&gt;, use for example &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</source>
          <target state="translated">По умолчанию сообщение игнорируется. Чтобы получить распечатку для каждого сообщения с &lt;code&gt;AlwaysDisplay = true&lt;/code&gt; , используйте, например, &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cc443fe9633fb1a0335c43045efe1e002d6805e" translate="yes" xml:space="preserve">
          <source>The default behaviour is to create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">По умолчанию в текущем каталоге создается файл с именем &lt;code&gt;TAGS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26ca635941f675c5f6767b6598533eaee0bb0c9a" translate="yes" xml:space="preserve">
          <source>The default behaviour of a process that receives a normal exit is to ignore the signal.</source>
          <target state="translated">Поведение процесса,получающего нормальный выход,по умолчанию заключается в игнорировании сигнала.</target>
        </trans-unit>
        <trans-unit id="47755f34cfe7e278db6d7efc977a211082ce5135" translate="yes" xml:space="preserve">
          <source>The default behaviour when a process receives an exit signal with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, is to terminate and in turn emit exit signals with the same exit reason to its linked processes. An exit signal with reason &lt;code&gt;normal&lt;/code&gt; is ignored.</source>
          <target state="translated">Поведение по умолчанию, когда процесс получает сигнал выхода с причиной выхода, отличной от &lt;code&gt;normal&lt;/code&gt; , заключается в завершении и, в свою очередь, подаче сигналов выхода с той же причиной выхода для связанных процессов. Сигнал выхода с &lt;code&gt;normal&lt;/code&gt; причиной игнорируется.</target>
        </trans-unit>
        <trans-unit id="9d70ec5c7098a4e4d6ce579440d90f6d0f1a9b44" translate="yes" xml:space="preserve">
          <source>The default boot file is &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt;, but in this case we need to specify a boot file from our target structure, typically &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt;. This is done with the &lt;code&gt;-boot&lt;/code&gt; command line option to &lt;code&gt;erl&lt;/code&gt;</source>
          <target state="translated">Загрузочный файл по умолчанию - &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt; , но в этом случае нам нужно указать загрузочный файл из нашей целевой структуры, обычно &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt; . Это делается с помощью &lt;code&gt;-boot&lt;/code&gt; командной строки -boot для &lt;code&gt;erl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8deb6cfc40b154f0f3bc4c292fe3c4c01bead83c" translate="yes" xml:space="preserve">
          <source>The default callback module &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt;, has the following features:</source>
          <target state="translated">Модуль обратного вызова по умолчанию &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt; имеет следующие особенности:</target>
        </trans-unit>
        <trans-unit id="1389307405e87741972dcfbd8f36d70ed4c7e741" translate="yes" xml:space="preserve">
          <source>The default discovery handler will require additional actions by the caller and the discovery will not work if the security-level is higher then &lt;code&gt;noAuthNoPriv&lt;/code&gt;.</source>
          <target state="translated">Обработчик обнаружения по умолчанию потребует дополнительных действий со стороны вызывающего объекта, и обнаружение не будет работать, если уровень безопасности выше, чем &lt;code&gt;noAuthNoPriv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d22df62b6d0da804bdfcd33682ee76feb0f23fda" translate="yes" xml:space="preserve">
          <source>The default encoding for Erlang source files is changed from Latin-1 to UTF-8 since Erlang/OTP 17.0.</source>
          <target state="translated">Для исходных файлов Erlang кодировка по умолчанию изменена с Latin-1 на UTF-8,начиная с Erlang/OTP 17.0.</target>
        </trans-unit>
        <trans-unit id="28a5f2f414a2bcb3dd11d72abe5185c72fab49c5" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt; Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e3252c03a4fb54a27bf1c1fdc312100673449d" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt;Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="translated">Кодировка по умолчанию для сервера ввода-вывода для &lt;code&gt;standard_io&lt;/code&gt; - &lt;code&gt;latin1&lt;/code&gt; , поскольку сценарий выполняется в неинтерактивном терминале (см. Раздел &amp;laquo; &lt;code&gt;Summary of Options&lt;/code&gt; ) в Руководстве пользователя STDLIB.</target>
        </trans-unit>
        <trans-unit id="5fc4ad3abb12599963d8f41201b9099f8a6fadc8" translate="yes" xml:space="preserve">
          <source>The default encoding. Bytes supplied to the file, that is, &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; are written &quot;as is&quot; on the file. Likewise, bytes read from the file, that is, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; are returned &quot;as is&quot;. If module &lt;code&gt;io(3)&lt;/code&gt; is used for writing, the file can only cope with Unicode characters up to code point 255 (the ISO Latin-1 range).</source>
          <target state="translated">Кодировка по умолчанию. Байты, передаваемые в файл, то есть &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; , записываются в файл &amp;laquo;как есть&amp;raquo;. Точно так же байты, прочитанные из файла, то есть &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; , возвращаются &amp;laquo;как есть&amp;raquo;. Если для записи используется модуль &lt;code&gt;io(3)&lt;/code&gt; , файл может обрабатывать символы Unicode только до кодовой точки 255 (диапазон ISO Latin-1).</target>
        </trans-unit>
        <trans-unit id="d6c8c72f780ad73f25b213fdc25585528f17513b" translate="yes" xml:space="preserve">
          <source>The default endianness is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">По умолчанию порядок байтов &lt;code&gt;big&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d83550f92d20198e2acab3ad30ef01b3a3ff2580" translate="yes" xml:space="preserve">
          <source>The default fallback behaviour. Template funs should end with:</source>
          <target state="translated">Поведение при падении по умолчанию.Шаблонные забавы должны заканчиваться:</target>
        </trans-unit>
        <trans-unit id="c9d9ffa8dde369b6838c3b5a3754294ebeb88aaa" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; cannot handle an object of type &lt;code&gt;NetworkAddress&lt;/code&gt; as INDEX (SNMPv1 only!). Use &lt;code&gt;IpAddress&lt;/code&gt; instead.</source>
          <target state="translated">Функции по умолчанию и &lt;code&gt;snmp_generic&lt;/code&gt; не могут обрабатывать объект типа &lt;code&gt;NetworkAddress&lt;/code&gt; как INDEX (только для SNMPv1!). &lt;code&gt;IpAddress&lt;/code&gt; этого используйте IpAddress .</target>
        </trans-unit>
        <trans-unit id="4cd3d1fa535e347fbd4b38228c48e00bf23af7b2" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; do not check the range of each OCTET in textual conventions derived from OCTET STRING, e.g. &lt;code&gt;DisplayString&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. This must be checked in an overloaded &lt;code&gt;is_set_ok&lt;/code&gt; function.</source>
          <target state="translated">Функции по умолчанию и &lt;code&gt;snmp_generic&lt;/code&gt; не проверяют диапазон каждого OCTET в текстовых соглашениях, полученных из OCTET STRING, например &lt;code&gt;DisplayString&lt;/code&gt; и &lt;code&gt;DateAndTime&lt;/code&gt; . Это необходимо проверить в перегруженной функции &lt;code&gt;is_set_ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb7a8decc5695c83a52d57741dd6546a270063e4" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt; logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt; logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ec2b0bf3246052db6872a9a89f490a6940711d" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="translated">Обработчики по умолчанию, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; , имеют механизм защиты от перегрузки, который позволяет обработчикам выжить и оставаться отзывчивыми в периоды высокой нагрузки (когда необходимо обрабатывать огромное количество входящих запросов журнала). Механизм работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="fef3702dc90f570ebd9028951e47041a3eec62af" translate="yes" xml:space="preserve">
          <source>The default initial heap size of 233 words is quite conservative to support Erlang systems with hundreds of thousands or even millions of processes. The garbage collector grows and shrinks the heap as needed.</source>
          <target state="translated">Начальный размер кучи по умолчанию,составляющий 233 слова,достаточно консервативен для поддержки систем Erlang с сотнями тысяч или даже миллионами процессов.Сборщик мусора растет и при необходимости сокращает кучу.</target>
        </trans-unit>
        <trans-unit id="028f1e913dc597e5f47465aa0038982d46d84b7c" translate="yes" xml:space="preserve">
          <source>The default instrumentation allows the application on the manager side to be developed and tested simultaneously with the agent. As soon as the ASN.1 file is completed, let the MIB compiler generate a default implementation and develop the management application from this.</source>
          <target state="translated">Приборы по умолчанию позволяют разрабатывать и тестировать приложение на стороне менеджера одновременно с агентом.Как только файл ASN.1 будет завершен,пусть компилятор MIB сгенерирует реализацию по умолчанию и разработает на ее основе приложение управления.</target>
        </trans-unit>
        <trans-unit id="2bcdc2b092cf0144876d346105d3638a289ddc47" translate="yes" xml:space="preserve">
          <source>The default instrumentation functions are defined in the module &lt;code&gt;snmp_generic&lt;/code&gt;. Refer to the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for details.</source>
          <target state="translated">Инструментальные функции по умолчанию определены в модуле &lt;code&gt;snmp_generic&lt;/code&gt; . Подробности см. В Справочном руководстве, раздел SNMP, модуль &lt;code&gt;snmp_generic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f9d2c2e9dd957fcc3258b4a7c7be3758f84afc" translate="yes" xml:space="preserve">
          <source>The default is 30 seconds.</source>
          <target state="translated">По умолчанию 30 секунд.</target>
        </trans-unit>
        <trans-unit id="697dc028cf7853b692477e62b3b0ccd825e45fa0" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;integer&lt;/code&gt;. &lt;code&gt;bytes&lt;/code&gt; is a shorthand for &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;bits&lt;/code&gt; is a shorthand for &lt;code&gt;bitstring&lt;/code&gt;. See below for more information about the &lt;code&gt;utf&lt;/code&gt; types.</source>
          <target state="translated">По умолчанию - &lt;code&gt;integer&lt;/code&gt; . &lt;code&gt;bytes&lt;/code&gt; - это сокращение от &lt;code&gt;binary&lt;/code&gt; а &lt;code&gt;bits&lt;/code&gt; - это сокращение от &lt;code&gt;bitstring&lt;/code&gt; . См. Ниже дополнительную информацию о типах &lt;code&gt;utf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f0b6dd22860df8373214ee0633cf82a9776e5cd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;binary_alloc&lt;/code&gt; and &lt;code&gt;driver_alloc&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; for the other allocator types.</source>
          <target state="translated">По умолчанию &lt;code&gt;true&lt;/code&gt; для &lt;code&gt;binary_alloc&lt;/code&gt; и &lt;code&gt;driver_alloc&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; для других типов распределителей.</target>
        </trans-unit>
        <trans-unit id="9996cd482af4c98f3ef5c52e911a0d51db398668" translate="yes" xml:space="preserve">
          <source>The default is the process named &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c6037b1efc7d6b42e5368b46d0f3b99b3ee991" translate="yes" xml:space="preserve">
          <source>The default is to return a sequence of QLCs in a block, but if option &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; is specified, one single QLC is returned.</source>
          <target state="translated">По умолчанию возвращается последовательность QLC в блоке, но если указан параметр &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; , возвращается один единственный QLC.</target>
        </trans-unit>
        <trans-unit id="b873bd22585e6e628d3df8c1732fa1e4731a1722" translate="yes" xml:space="preserve">
          <source>The default is to return a string, but if option &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; is specified, abstract code is returned instead. In the abstract code, port identifiers, references, and pids are represented by strings.</source>
          <target state="translated">По умолчанию возвращается строка, но если указан параметр &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; , вместо этого возвращается абстрактный код. В абстрактном коде идентификаторы портов, ссылки и идентификаторы портов представлены строками.</target>
        </trans-unit>
        <trans-unit id="6b16165d91c06ae4aeb2706afc9b7a0ac50cd9da" translate="yes" xml:space="preserve">
          <source>The default is to return all elements in lists, but if option &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; is specified, only a limited number of elements are returned.</source>
          <target state="translated">По умолчанию возвращаются все элементы в списках, но если &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; опция {n_elements, NElements}, возвращается только ограниченное количество элементов.</target>
        </trans-unit>
        <trans-unit id="cc7b0f890d901ebd92c482f0beb121398b160a73" translate="yes" xml:space="preserve">
          <source>The default is to show all parts of objects and match specifications, but if option &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; is specified, parts of terms below a certain depth are replaced by &lt;code&gt;'...'&lt;/code&gt;.</source>
          <target state="translated">По умолчанию отображаются все части объектов и соответствуют спецификациям, но если указана опция &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; , части терминов ниже определенной глубины заменяются на &lt;code&gt;'...'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d031478aad7c792d83bd41e0b1d60d3346429273" translate="yes" xml:space="preserve">
          <source>The default is to sort terms in ascending order, but that can be changed by value &lt;code&gt;descending&lt;/code&gt; or by specifying an ordering function &lt;code&gt;Fun&lt;/code&gt;. An ordering function is antisymmetric, transitive, and total. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; is to return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; comes before &lt;code&gt;B&lt;/code&gt; in the ordering, otherwise &lt;code&gt;false&lt;/code&gt;. An example of a typical ordering function is less than or equal to, &lt;code&gt;=&amp;lt;/2&lt;/code&gt;. Using an ordering function slows down the sort considerably. Functions &lt;code&gt;keysort&lt;/code&gt;, &lt;code&gt;keymerge&lt;/code&gt; and &lt;code&gt;keycheck&lt;/code&gt; do not accept ordering functions.</source>
          <target state="translated">По умолчанию термины сортируются в порядке возрастания, но это можно изменить по &lt;code&gt;descending&lt;/code&gt; значения или указав функцию сортировки &lt;code&gt;Fun&lt;/code&gt; . Функция упорядочивания бывает антисимметричной, транзитивной и полной. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; должен вернуть &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;A&lt;/code&gt; стоит перед &lt;code&gt;B&lt;/code&gt; в порядке, иначе &lt;code&gt;false&lt;/code&gt; . Пример типичной функции упорядочивания меньше или равен, &lt;code&gt;=&amp;lt;/2&lt;/code&gt; . Использование функции упорядочивания значительно замедляет сортировку. Функции &lt;code&gt;keysort&lt;/code&gt; , &lt;code&gt;keymerge&lt;/code&gt; и &lt;code&gt;keycheck&lt;/code&gt; не поддерживают функции упорядочивания.</target>
        </trans-unit>
        <trans-unit id="388c1ebba36e81e6d83c9829202075488730e57f" translate="yes" xml:space="preserve">
          <source>The default list is fetched from the &lt;code&gt;public_key&lt;/code&gt; application.</source>
          <target state="translated">Список по умолчанию &lt;code&gt;public_key&lt;/code&gt; приложения public_key .</target>
        </trans-unit>
        <trans-unit id="6b3871f80aaa305c511a84fd9b3f91462dfdba6b" translate="yes" xml:space="preserve">
          <source>The default logging behavior of &lt;code&gt;ct_telnet&lt;/code&gt; is to print information about performed operations, commands, and their corresponding results to the test case HTML log. The following is not printed to the HTML log: text strings sent from the Telnet server that are not explicitly received by a &lt;code&gt;ct_telnet&lt;/code&gt; function, such as &lt;code&gt;expect/3&lt;/code&gt;. However, &lt;code&gt;ct_telnet&lt;/code&gt; can be configured to use a special purpose event handler, implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;, for logging &lt;strong&gt;all&lt;/strong&gt; Telnet traffic. To use this handler, install a &lt;code&gt;Common Test&lt;/code&gt; hook named &lt;code&gt;cth_conn_log&lt;/code&gt;. Example (using the test suite information function):</source>
          <target state="translated">По умолчанию &lt;code&gt;ct_telnet&lt;/code&gt; ведет журнал, выводя информацию о выполненных операциях, командах и их соответствующих результатах в HTML-журнал тестового примера. В журнал HTML не &lt;code&gt;ct_telnet&lt;/code&gt; следующее: текстовые строки, отправленные с сервера Telnet, которые не были явно получены функцией ct_telnet , например, &lt;code&gt;expect/3&lt;/code&gt; . Однако &lt;code&gt;ct_telnet&lt;/code&gt; можно настроить для использования специального обработчика событий, реализованного в &lt;code&gt;ct_conn_log_h&lt;/code&gt; , для регистрации &lt;strong&gt;всего&lt;/strong&gt; трафика Telnet. Чтобы использовать этот обработчик, установите перехватчик &lt;code&gt;Common Test&lt;/code&gt; с именем &lt;code&gt;cth_conn_log&lt;/code&gt; . Пример (с использованием информационной функции набора тестов):</target>
        </trans-unit>
        <trans-unit id="2de8d81b3d3a2e14473bb755a7b9ea4746cd308a" translate="yes" xml:space="preserve">
          <source>The default matching handles dns_id and uri_id. In an uri_id the value is tested for equality with a value from the &lt;code&gt;Subject Alternate Name&lt;/code&gt;. If som other kind of matching is needed, use the &lt;code&gt;match_fun&lt;/code&gt; option.</source>
          <target state="translated">Соответствие по умолчанию обрабатывает dns_id и uri_id. В uri_id значение проверяется на равенство со значением из &lt;code&gt;Subject Alternate Name&lt;/code&gt; . Если требуется какой-либо другой вид сопоставления, используйте параметр &lt;code&gt;match_fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84111fd78857c9aae8ea5220ba7612eb708e45fa" translate="yes" xml:space="preserve">
          <source>The default matching transformes the ascii values in strings to lowercase before comparing. The &lt;code&gt;match_fun&lt;/code&gt; is however called without any transfomation applied to the strings. The reason is to enable the user to do unforseen handling of the strings where the original format is needed.</source>
          <target state="translated">Соответствие по умолчанию преобразует значения ascii в строках в нижний регистр перед сравнением. Однако &lt;code&gt;match_fun&lt;/code&gt; вызывается без применения каких-либо преобразований к строкам. Причина в том, чтобы позволить пользователю выполнять непредвиденную обработку строк, где требуется исходный формат.</target>
        </trans-unit>
        <trans-unit id="aa2a84cd90225c7ed3bdea62cdca292d4a45b475" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows and MacOS X enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">Режим по умолчанию зависит от операционной системы. Windows и MacOS X обеспечивают согласованное кодирование имени файла, поэтому виртуальная машина использует режим &lt;code&gt;utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a989c78863dde3eb5b7dac6806181cf8315faf2c" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows, MacOS X and Android enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953f88f92bc1b24efaf4cf45547f40d0e648b131" translate="yes" xml:space="preserve">
          <source>The default object arity is smaller than &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt; объекта по умолчанию меньше, чем &amp;lt;keypos&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="4de77215568172d7d29aabd76eae88688d23f0d0" translate="yes" xml:space="preserve">
          <source>The default options of the &lt;code&gt;erlsrv&lt;/code&gt; program are not sufficient for release handling. The machine started by &lt;code&gt;erlsrv&lt;/code&gt; is be specified as the &lt;code&gt;start_erl&lt;/code&gt; program and the arguments are to contain &lt;code&gt;++&lt;/code&gt; followed by the desired options.</source>
          <target state="translated">&lt;code&gt;erlsrv&lt;/code&gt; программы erlsrv по умолчанию недостаточны для обработки выпуска. Машина, запущенная &lt;code&gt;erlsrv&lt;/code&gt; , указывается как программа &lt;code&gt;start_erl&lt;/code&gt; , а аргументы должны содержать &lt;code&gt;++&lt;/code&gt; , за которым следуют желаемые параметры.</target>
        </trans-unit>
        <trans-unit id="848dbed2df3f8df742ee9905b38e3696149b703a" translate="yes" xml:space="preserve">
          <source>The default password checking is with the list in the &lt;code&gt;&lt;a href=&quot;ssh#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; option in the SSH daemon. It could be replaced with a &lt;code&gt;&lt;a href=&quot;ssh#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; plugin. The arity four variant (&lt;code&gt;&lt;a href=&quot;ssh#type-pwdfun_4&quot;&gt;pwdfun_4()&lt;/a&gt;&lt;/code&gt;) can also be used for introducing delays after failed password checking attempts. Here is a simple example of such a pwdfun:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1094b520cae2a88d55d90efc05453766135ad7" translate="yes" xml:space="preserve">
          <source>The default set of groups is listed in &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt;. This file may be regenerated like this:</source>
          <target state="translated">Набор групп по умолчанию указан в &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt; . Этот файл можно регенерировать следующим образом:</target>
        </trans-unit>
        <trans-unit id="1a4dcf8371d190ef2c9a9faf32cf8b7eef5d4104" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt; prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c212e9694a3fd892d150f01a66f923860ff2fc9" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">Функция приглашения оболочки по умолчанию отображает имя узла (если узел может быть частью распределенной системы) и текущий номер команды. Пользователь может настроить функцию приглашения, вызвав &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; или установив параметр конфигурации приложения &lt;code&gt;shell_prompt_func&lt;/code&gt; для приложения STDLIB.</target>
        </trans-unit>
        <trans-unit id="00b63ca80d11da692b5651bc33e43d076e3793c3" translate="yes" xml:space="preserve">
          <source>The default signedness is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">По умолчанию подпись &lt;code&gt;unsigned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff776579e06c4767b62b9f485e782cd999a09f7a" translate="yes" xml:space="preserve">
          <source>The default simple handler is called &lt;code&gt;alarm_handler&lt;/code&gt; and it can be exchanged by calling &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; as &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt;. &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; is called. For more details, see &lt;code&gt;gen_event(3)&lt;/code&gt; in STDLIB.</source>
          <target state="translated">Простой обработчик по умолчанию называется &lt;code&gt;alarm_handler&lt;/code&gt; , и его можно заменить, вызвав &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; как &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt; . &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; . Для получения дополнительных сведений см. &lt;code&gt;gen_event(3)&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="edd4ef6f5a1e3a142885438b41744f5b5b26e5b7" translate="yes" xml:space="preserve">
          <source>The default socket options are &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt;.</source>
          <target state="translated">Параметры сокета по умолчанию: &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0a75358d0df669ac13a835e5ee193bd00512b1" translate="yes" xml:space="preserve">
          <source>The default standard handler, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, can be replaced by a disk_log handler at startup of the Kernel application. See an example of this below.</source>
          <target state="translated">Стандартный обработчик по умолчанию, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; , может быть заменен обработчиком disk_log при запуске приложения ядра. См. Пример ниже.</target>
        </trans-unit>
        <trans-unit id="56e59dc663ec3168b6b7eec38a9c17da04f70aec" translate="yes" xml:space="preserve">
          <source>The default start option &lt;code&gt;{dir,Cwd}&lt;/code&gt; (to run all suites in the current working directory) is used if the function is called with an empty list of options.</source>
          <target state="translated">Параметр запуска по умолчанию &lt;code&gt;{dir,Cwd}&lt;/code&gt; (для запуска всех наборов в текущем рабочем каталоге) используется, если функция вызывается с пустым списком параметров.</target>
        </trans-unit>
        <trans-unit id="8472d25153570bd73936053aa35b2f0053ff73f8" translate="yes" xml:space="preserve">
          <source>The default time limit for a test case is 30 minutes, unless a &lt;code&gt;timetrap&lt;/code&gt; is specified either by the suite-, group-, or test case information function. The timetrap time-out value defined by &lt;code&gt;suite/0&lt;/code&gt; is the value that is used for each test case in the suite (and for the configuration functions &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, and &lt;code&gt;end_per_group/2&lt;/code&gt;). A timetrap value defined by &lt;code&gt;group(GroupName)&lt;/code&gt; overrides one defined by &lt;code&gt;suite()&lt;/code&gt; and is used for each test case in group &lt;code&gt;GroupName&lt;/code&gt;, and any of its subgroups. If a timetrap value is defined by &lt;code&gt;group/1&lt;/code&gt; for a subgroup, it overrides that of its higher level groups. Timetrap values set by individual test cases (by the test case information function) override both group- and suite- level timetraps.</source>
          <target state="translated">По умолчанию ограничение по времени для тестового примера составляет 30 минут, если &lt;code&gt;timetrap&lt;/code&gt; не указана функцией информации набора, группы или тестового примера. Значение тайм-аута временной ловушки, определяемое &lt;code&gt;suite/0&lt;/code&gt; является значением, которое используется для каждого тестового примера в наборе (и для функций конфигурации &lt;code&gt;init_per_suite/1&lt;/code&gt; , &lt;code&gt;end_per_suite/1&lt;/code&gt; , &lt;code&gt;init_per_group/2&lt;/code&gt; и &lt;code&gt;end_per_group/2&lt;/code&gt; ). Значение временной ловушки, определенное &lt;code&gt;group(GroupName)&lt;/code&gt; переопределяет значение, определенное функцией &lt;code&gt;suite()&lt;/code&gt; и используется для каждого тестового примера в группе &lt;code&gt;GroupName&lt;/code&gt; и любой из ее подгрупп. Если значение временной ловушки определяется &lt;code&gt;group/1&lt;/code&gt; для подгруппы он имеет приоритет над группами более высокого уровня. Значения временных ловушек, установленные отдельными тестовыми примерами (функцией информации тестовых примеров), имеют приоритет над временными ловушками как на уровне группы, так и на уровне набора.</target>
        </trans-unit>
        <trans-unit id="b52b358a5f5402f0ac26ce2f8003f427f7c57d17" translate="yes" xml:space="preserve">
          <source>The default time-out is 5000 ms, unless otherwise specified. &lt;code&gt;timeout&lt;/code&gt; defines the time to wait for the process to respond to a request. If the process does not respond, the function evaluates &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt;.</source>
          <target state="translated">Тайм-аут по умолчанию составляет 5000 мс, если не указано иное. &lt;code&gt;timeout&lt;/code&gt; определяет время ожидания ответа процесса на запрос. Если процесс не отвечает, функция оценивает &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51ff8e06cc37d3f5fbc8359b214e014cbb5552d4" translate="yes" xml:space="preserve">
          <source>The default timeout is infinity</source>
          <target state="translated">По умолчанию таймаут-это бесконечность</target>
        </trans-unit>
        <trans-unit id="517719740380d1d0fe303f5c01cd73d6a4f1b6a9" translate="yes" xml:space="preserve">
          <source>The default type (and currently the only type) of crypto algorithm is &lt;code&gt;des3_cbc&lt;/code&gt;, three rounds of DES. The key string is scrambled using &lt;code&gt;erlang:md5/1&lt;/code&gt; to generate the keys used for &lt;code&gt;des3_cbc&lt;/code&gt;.</source>
          <target state="translated">Тип по умолчанию (и в настоящее время единственный) криптоалгоритма - &lt;code&gt;des3_cbc&lt;/code&gt; , три раунда DES. Строка ключей &lt;code&gt;des3_cbc&lt;/code&gt; с помощью &lt;code&gt;erlang:md5/1&lt;/code&gt; для генерации ключей, используемых для des3_cbc .</target>
        </trans-unit>
        <trans-unit id="545949e03721db9053ce25eb33d2946d85caf9f1" translate="yes" xml:space="preserve">
          <source>The default type for a segment is integer. The default type does not depend on the value, even if the value is a literal. For example, the default type in &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; is integer, not float.</source>
          <target state="translated">Тип по умолчанию для сегмента - целое число. Тип по умолчанию не зависит от значения, даже если значение является буквальным. Например, тип по умолчанию в &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; - это целое число, а не с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="9c04943ccaa1784066dde4b82fadc56a0e22b6e6" translate="yes" xml:space="preserve">
          <source>The default unit depends on the the type. For &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt; it is 1. For binary it is 8.</source>
          <target state="translated">Единица измерения по умолчанию зависит от типа. Для &lt;code&gt;integer&lt;/code&gt; , чисел с &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;bitstring&lt;/code&gt; это 1. Для двоичных чисел это 8.</target>
        </trans-unit>
        <trans-unit id="55a938cf0dbdbfb06f3894ab3968c86b760e35c4" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Timeout&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;. If &lt;code&gt;Timeout&lt;/code&gt; is specified and no connection is accepted within the given time, &lt;code&gt;{error, timeout}&lt;/code&gt; is returned.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;Timeout&lt;/code&gt; - &lt;code&gt;infinity&lt;/code&gt; . Если &lt;code&gt;Timeout&lt;/code&gt; указан и соединение не принимается в течение заданного времени, &lt;code&gt;{error, timeout}&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="06729acf2bd67efa6a3b5f8c86f4f2fa259ed112" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;Type&lt;/code&gt; является &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79b49abd7127b03f5d3f046367a7810a9be6e9ef" translate="yes" xml:space="preserve">
          <source>The default value for both the limits is 10,000,000 in the Erlang VM. Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for Erlang is compiled in such a way that the match function never does recursion on the C stack.</source>
          <target state="translated">Значение по умолчанию для обоих лимитов составляет 10,000,000 в VM Erlang.Обратите внимание,что лимит рекурсии не влияет на глубину стека ВМ,так как PCRE для Erlang скомпилирован таким образом,что функция соответствия никогда не делает рекурсию на стеке C.</target>
        </trans-unit>
        <trans-unit id="2a019fd353ccc57a4984f8ab73e895be35e2ceca" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;code&gt;template&lt;/code&gt; configuration parameter depends on the value of the &lt;code&gt;single_line&lt;/code&gt; and &lt;code&gt;legacy_header&lt;/code&gt; configuration parameters as follows.</source>
          <target state="translated">Значение по умолчанию для параметра конфигурации &lt;code&gt;template&lt;/code&gt; зависит от значения параметров конфигурации &lt;code&gt;single_line&lt;/code&gt; и &lt;code&gt;legacy_header&lt;/code&gt; следующим образом.</target>
        </trans-unit>
        <trans-unit id="0bf6d99215a41e23b30022357e71e9041cbda827" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;0&lt;/code&gt;, which means that there is no upper limit. If supplied, the number of filenames returned to the SFTP client per &lt;code&gt;READDIR&lt;/code&gt; request is limited to at most the given value.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;0&lt;/code&gt; , что означает отсутствие верхнего предела. Если указано, количество имен файлов, возвращаемых клиенту SFTP на запрос &lt;code&gt;READDIR&lt;/code&gt; , ограничивается максимально заданным значением.</target>
        </trans-unit>
        <trans-unit id="8eb871dd540b5e77da06600e181f72827240ed7e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;262144&lt;/code&gt;</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;262144&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9199a189c47e6bb7d92e1a9dbf9ee3c0844e971b" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;{0,infinity}&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;{0,infinity}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4282a5ade1b153ec0ef3ef75770c03f967209ae" translate="yes" xml:space="preserve">
          <source>The default value is as required by RFC 3539: changing it results in non-standard behaviour that should only be used to simulate misbehaving nodes during test.</source>
          <target state="translated">Значение по умолчанию соответствует требованиям RFC 3539:изменение этого значения приводит к нестандартному поведению,которое должно использоваться только для моделирования неправильного поведения узлов во время тестирования.</target>
        </trans-unit>
        <trans-unit id="18ca71fb6a22d28ebdfdacf9ed5fe354e1ec6ffe" translate="yes" xml:space="preserve">
          <source>The default value is the &lt;code&gt;public_key&lt;/code&gt; entry in the list returned by &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию - это запись &lt;code&gt;public_key&lt;/code&gt; в списке, возвращаемом &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2af35d2902848146372b486ac1179095a26eda1a" translate="yes" xml:space="preserve">
          <source>The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created.</source>
          <target state="translated">Значение по умолчанию используется в качестве значения неинициализированных записей и не может быть изменено после создания массива.</target>
        </trans-unit>
        <trans-unit id="b459379a9db26d1ded876c98cb594522408f4fb6" translate="yes" xml:space="preserve">
          <source>The default value is: &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Значение по умолчанию: &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f42ce984a7a7881db87f25a990a361103af516d" translate="yes" xml:space="preserve">
          <source>The default value of USERDIR is &lt;code&gt;/home/&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#LOCALUSER&quot;&gt;LOCALUSER&lt;/a&gt;&lt;/code&gt;&lt;code&gt;/.ssh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243fb9da1068fdc22926720a51604f4646125511" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;.</source>
          <target state="translated">Значение этой опции по умолчанию - &lt;code&gt;{ssh_file, []}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4850f9a420695e6f6e424866c3013c9d0bdbd2e3" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;. See also the manpage of &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c469af55771eecab0c4f9a0edd001fdb31022bb8" translate="yes" xml:space="preserve">
          <source>The default value of this option shall provide the above mentioned security guarantees and it shall be reasonable for most applications (~353 TB).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d73b09c02067144770d80033f5560b2a2552422" translate="yes" xml:space="preserve">
          <source>The default value reflects the fact that a transport module for a stream-oriented transport like TCP may not be able to recover from a message length error since such a transport must use the Message Length header to divide the incoming byte stream into individual Diameter messages. An invalid length leaves it with no reliable way to rediscover message boundaries, which may result in the failure of subsequent messages. See &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; for the behaviour of that module.</source>
          <target state="translated">Значение по умолчанию отражает тот факт, что транспортный модуль для потокового транспорта, такого как TCP, может быть не в состоянии восстановиться после ошибки длины сообщения, поскольку такой транспорт должен использовать заголовок длины сообщения для разделения входящего потока байтов на отдельные сообщения Diameter. Недопустимая длина лишает его надежного способа повторно обнаружить границы сообщения, что может привести к сбою последующих сообщений. См. &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; чтобы узнать о поведении этого модуля.</target>
        </trans-unit>
        <trans-unit id="296cd192efc745b8c34964c030037a92790a5853" translate="yes" xml:space="preserve">
          <source>The default value used is normally &lt;code&gt;65536&lt;/code&gt;. However, if the runtime system is able to determine maximum amount of file descriptors that it is allowed to open and this value is larger than &lt;code&gt;65536&lt;/code&gt;, the chosen value will increased to a value larger or equal to the maximum amount of file descriptors that can be opened.</source>
          <target state="translated">Обычно используется значение по умолчанию &lt;code&gt;65536&lt;/code&gt; . Однако, если исполняющая система способна определить максимальное количество файловых дескрипторов, которые ей разрешено открывать, и это значение больше &lt;code&gt;65536&lt;/code&gt; , выбранное значение будет увеличено до значения, большего или равного максимальному количеству файловых дескрипторов, которое может быть открыт.</target>
        </trans-unit>
        <trans-unit id="5e3d6bd0706de8063989ab67ca84fec01864e172" translate="yes" xml:space="preserve">
          <source>The default values are 1 restart per 5 seconds. This was chosen to be safe for most systems, even with deep supervision hierarchies, but you will probably want to tune the settings for your particular use case.</source>
          <target state="translated">Значения по умолчанию-1 перезапуск в 5 секунд.Это было выбрано,чтобы быть безопасным для большинства систем,даже с глубокой иерархией контроля,но вы,вероятно,захотите настроить параметры для вашего конкретного случая использования.</target>
        </trans-unit>
        <trans-unit id="a4e004a8abd563009ef32e5cba1400cabe8dffcb" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;connect&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_connect_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На значения по умолчанию для параметров, указанных для &lt;code&gt;connect&lt;/code&gt; может влиять параметр конфигурации ядра &lt;code&gt;inet_default_connect_options&lt;/code&gt; . Подробнее см. &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40a15125494e475b38c160cdf12b36e7e3d1c3f9" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;listen&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_listen_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На значения по умолчанию для параметров, указанных для &lt;code&gt;listen&lt;/code&gt; может влиять параметр конфигурации ядра &lt;code&gt;inet_default_listen_options&lt;/code&gt; . Подробнее см. &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50fa0bf131c13c670fdcc5fdce169d626f359cef" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;originating&lt;/code&gt; discovery options are:</source>
          <target state="translated">Значения по умолчанию для параметров &lt;code&gt;originating&lt;/code&gt; обнаружения:</target>
        </trans-unit>
        <trans-unit id="9cb324b22317eaf8bd729f045fc4512eed8d2afc" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;terminating&lt;/code&gt; discovery options are:</source>
          <target state="translated">Значения по умолчанию для параметров &lt;code&gt;terminating&lt;/code&gt; обнаружения:</target>
        </trans-unit>
        <trans-unit id="8b5bd661368c7d8e299861344ca3c98352edac6c" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt;. But the send options above, may explicitly be overridden.</source>
          <target state="translated">Значения по умолчанию для параметров отправки получаются с помощью &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt; . Но параметры отправки, указанные выше, могут быть явно отменены.</target>
        </trans-unit>
        <trans-unit id="b0aa1b655582755f5f4811f0eab7ca8a5d9f4319" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by megaco:conn_info(ConnHandle, Item). But the send options above, may explicitly be overridden.</source>
          <target state="translated">Значения опций отправки по умолчанию получены megaco:conn_info(ConnHandle,Item).Но приведенные выше параметры отправки могут быть явно переопределены.</target>
        </trans-unit>
        <trans-unit id="2ebf5b11205a5dd9778e91c6bfcc585a8fc51478" translate="yes" xml:space="preserve">
          <source>The default verbosity is &lt;code&gt;1&lt;/code&gt;. Verbosity &lt;code&gt;0&lt;/code&gt; can also be selected by option &lt;code&gt;nowarn_format&lt;/code&gt;.</source>
          <target state="translated">Уровень детализации по умолчанию - &lt;code&gt;1&lt;/code&gt; . Уровень детализации &lt;code&gt;0&lt;/code&gt; также можно выбрать с помощью опции &lt;code&gt;nowarn_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8f7ea1b49fdcb48ab2c2517d37ecba5139e4ff8" translate="yes" xml:space="preserve">
          <source>The default when a connection is established between two nodes, is to immediately connect all other visible nodes as well. This way, there is always a fully connected network. If there are nodes with different cookies, this method can be inappropriate and the command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; must be set, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">По умолчанию, когда соединение устанавливается между двумя узлами, также немедленно подключаются все остальные видимые узлы. Таким образом, всегда есть полностью подключенная сеть. Если есть узлы с разными файлами cookie, этот метод может быть неподходящим, и должен быть установлен флаг командной строки &lt;code&gt;-connect_all false&lt;/code&gt; , см. Страницу справочника &lt;code&gt;erl(1)&lt;/code&gt; в ERTS.</target>
        </trans-unit>
        <trans-unit id="3cf210e7ecc7b461b7955d0d98ee29107a5a6b0b" translate="yes" xml:space="preserve">
          <source>The default. Only characters in the ISO Latin-1 range can be considered printable. This means that a character with a code point &amp;gt; 255 is never considered printable and that lists containing such characters are displayed as lists of integers rather than text strings by tools.</source>
          <target state="translated">По умолчанию. Только символы из диапазона ISO Latin-1 могут считаться печатаемыми. Это означает, что символ с кодовой точкой&amp;gt; 255 никогда не считается пригодным для печати и что списки, содержащие такие символы, отображаются инструментами как списки целых чисел, а не текстовые строки.</target>
        </trans-unit>
        <trans-unit id="46e506cdb258a82f462a7f2164d0f42a9f2072f8" translate="yes" xml:space="preserve">
          <source>The defaults are &lt;code&gt;Low = 4096&lt;/code&gt; and &lt;code&gt;High = 8192&lt;/code&gt; unless the driver itself does modifications of these values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e29513f39a50cabbc123316e69281febedaa0e1c" translate="yes" xml:space="preserve">
          <source>The defaults are &lt;code&gt;Low = 4096&lt;/code&gt; and &lt;code&gt;High = 8192&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11fa3688f9aa1dc5e88e515adb5d88b7a205fe35" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;ErlMessage&lt;/code&gt; has changed since earlier versions of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">Определение &lt;code&gt;ErlMessage&lt;/code&gt; изменилось по сравнению с более ранними версиями &lt;code&gt;Erl_Interface&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fdae1ac6fb499a05429a1e07e8362960f5b8b56" translate="yes" xml:space="preserve">
          <source>The definition of a busy scheduler is when it is not idle and is not scheduling (selecting) a process or port, that is:</source>
          <target state="translated">Определение занятого планировщика-это когда он не простаивает и не планирует (не выбирает)процесс или порт,то есть:</target>
        </trans-unit>
        <trans-unit id="82ba3b05846ab652707aa41300a0f8920d31d2e5" translate="yes" xml:space="preserve">
          <source>The degree to which the service allows multiple transport connections to the same peer, as identified by its Origin-Host at capabilities exchange.</source>
          <target state="translated">Степень,до которой сервис позволяет несколько транспортных соединений к одному и тому же равноправному партнеру,как это определено его Origin-Host при обмене возможностями.</target>
        </trans-unit>
        <trans-unit id="1d3a7346db37c7fe972c4b73fbfa32235de91911" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt; erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995215813ca9fa0e2bcd7a40357169c4691820c6" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="translated">Доставка сообщений трассировки (сгенерированных &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;seq_trace(3)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt; ) смещена на временной шкале по сравнению с другими событиями в системе. Если вы знаете, что &lt;code&gt;Tracee&lt;/code&gt; прошел некоторую конкретную точку в своем выполнении, и вы хотите знать, когда хотя бы все сообщения трассировки, соответствующие событиям до этого момента, достигли трассировщика, используйте &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef74e5139b7ce6e4f98a4baef24c6182968b430c" translate="yes" xml:space="preserve">
          <source>The dependecies are created as a side effect to the normal compilation process. This means that the object file will also be produced. This option override the &lt;code&gt;makedep&lt;/code&gt; option.</source>
          <target state="translated">Зависимости создаются как побочный эффект нормального процесса компиляции. Это означает, что объектный файл также будет создан. Эта опция отменяет опцию &lt;code&gt;makedep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1ab3d1ea275bdf26541729c8fac923c58fe1c95" translate="yes" xml:space="preserve">
          <source>The dependency graph windows are launched from the file menu in the system window. The graph depicts all included and derived applications/modules and their dependencies.</source>
          <target state="translated">Окна графиков зависимостей запускаются из файлового меню в системном окне.На графике отображаются все включенные и производные приложения/модули и их зависимости.</target>
        </trans-unit>
        <trans-unit id="2a97d6fbaa7c8cc7934aab7b5d9a9bb87b6b518f" translate="yes" xml:space="preserve">
          <source>The described durability feature does not entirely apply to situations where &lt;code&gt;Mnesia&lt;/code&gt; is configured as a &quot;pure&quot; primary memory database.</source>
          <target state="translated">Описанная функция устойчивости не полностью применима к ситуациям, когда &lt;code&gt;Mnesia&lt;/code&gt; настроена как &amp;laquo;чистая&amp;raquo; база данных первичной памяти.</target>
        </trans-unit>
        <trans-unit id="c5fd3c33ad96d6f9da0b92a6b9de73850c0f031c" translate="yes" xml:space="preserve">
          <source>The described syntax can also be used in test specifications to change group properties at the time of execution, without having to edit the test suite. For more information, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">Описанный синтаксис также может использоваться в спецификациях тестов для изменения свойств группы во время выполнения без необходимости редактировать набор тестов. Для получения дополнительной информации см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; в разделе &amp;laquo;Выполнение тестов и анализ результатов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="086c0b30f28f757ab34cbfdd1e7d1db76083baee" translate="yes" xml:space="preserve">
          <source>The description is based on &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt;, which is not to be further updated.</source>
          <target state="translated">Описание основано на &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt; , которая не подлежит дальнейшему обновлению.</target>
        </trans-unit>
        <trans-unit id="b29537c79e1bc001111fcb298cafeaf2c947455f" translate="yes" xml:space="preserve">
          <source>The descriptions of the options uses the &lt;code&gt;Erlang Type Language&lt;/code&gt; with explaining text.</source>
          <target state="translated">В описании параметров используется язык &lt;code&gt;Erlang Type Language&lt;/code&gt; с поясняющим текстом.</target>
        </trans-unit>
        <trans-unit id="ccde6c91194772388df62e195ba8cf52e9380085" translate="yes" xml:space="preserve">
          <source>The design choice between two or three generations of code access structures is a trade-off between memory consumption and code loading latency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a17206933877eeb5bf9c5379a4ed51695a5147" translate="yes" xml:space="preserve">
          <source>The destination of these log events was configured by &lt;code&gt;SASL configuration parameters&lt;/code&gt;.</source>
          <target state="translated">Место назначения этих событий журнала было &lt;code&gt;SASL configuration parameters&lt;/code&gt; конфигурации SASL .</target>
        </trans-unit>
        <trans-unit id="1700577536e62effc25b554cb01dfedd3d5fe8bb" translate="yes" xml:space="preserve">
          <source>The details of finding other nodes (that is, talking to &lt;code&gt;epmd&lt;/code&gt; or something similar)</source>
          <target state="translated">Детали поиска других узлов (то есть разговор с &lt;code&gt;epmd&lt;/code&gt; или что-то подобное)</target>
        </trans-unit>
        <trans-unit id="8904690d17dfc4476f5a61b68a154f7e139b04e4" translate="yes" xml:space="preserve">
          <source>The development package of OpenSSL including the header files are needed as well as the binary command program &lt;code&gt;openssl&lt;/code&gt;. At least version 0.9.8 of OpenSSL is required. Read more and download from &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Необходим пакет разработки OpenSSL, включая файлы заголовков, а также программа двоичных команд &lt;code&gt;openssl&lt;/code&gt; . Требуется OpenSSL как минимум версии 0.9.8. Узнайте больше и загрузите с &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf2560910fa01e8730459d4ee545ef91e117611a" translate="yes" xml:space="preserve">
          <source>The development package of OpenSSL including the header files are needed as well as the binary command program &lt;code&gt;openssl&lt;/code&gt;. At least version 0.9.8 of OpenSSL is required. Read more and download from &lt;code&gt;&lt;a href=&quot;https://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d180f092b7b3bd940337d54bfa93d4b66eb9f08" translate="yes" xml:space="preserve">
          <source>The diameter application includes five dictionary modules corresponding to applications defined in section 2.4 of RFC 6733: &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; and &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; for the Diameter Common Messages application with application identifier 0, &lt;code&gt;diameter_gen_accounting&lt;/code&gt; (for RFC 3588) and &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; for the Diameter Base Accounting application with application identifier 3 and &lt;code&gt;diameter_gen_relay&lt;/code&gt; the Relay application with application identifier 0xFFFFFFFF.</source>
          <target state="translated">Приложение диаметра включает в себя пять словарных модулей , соответствующих приложения , определенных в разделе 2.4 RFC 6733: &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; и &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; для диаметра общего приложения Сообщения с идентификатором приложения 0, &lt;code&gt;diameter_gen_accounting&lt;/code&gt; (для RFC 3588) и &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; для диаметра базовой бухгалтерии приложения с идентификатором приложения- и &lt;code&gt;diameter_gen_relay&lt;/code&gt; приложения реле с идентификатором приложения 0xFFFFFFFF.</target>
        </trans-unit>
        <trans-unit id="55ad411fdd3feccef9ab5e2a70e1c6ecf0dda6f6" translate="yes" xml:space="preserve">
          <source>The diameter application is an implementation of the Diameter protocol as defined by RFC 6733. It supports arbitrary Diameter applications by way of a &lt;strong&gt;dictionary&lt;/strong&gt; interface that allows messages and AVPs to be defined and input into diameter as configuration. It has support for all roles defined in the RFC: client, server and agent. This chapter provides a short overview of the application.</source>
          <target state="translated">Приложение Diameter является реализацией протокола Diameter, как определено в RFC 6733. Оно поддерживает произвольные приложения Diameter с помощью интерфейса &lt;strong&gt;словаря,&lt;/strong&gt; который позволяет определять сообщения и AVP и вводить их в диаметр в качестве конфигурации. Он поддерживает все роли, определенные в RFC: клиент, сервер и агент. В этой главе дается краткий обзор приложения.</target>
        </trans-unit>
        <trans-unit id="b44b3ae3e6de975127d9868877e61eebf74c5fa6" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before calling most functions in this module.</source>
          <target state="translated">Перед вызовом большинства функций в этом модуле необходимо начать обработку диаметра.</target>
        </trans-unit>
        <trans-unit id="5970544b2f23768c3400e92a3796dc5f84073d7d" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before starting a service. In a production system this is typically accomplished by a boot file, not by calling &lt;code&gt;start/0&lt;/code&gt; explicitly.</source>
          <target state="translated">Приложение диаметра должно быть запущено до начала обслуживания. В производственной системе это обычно выполняется с помощью загрузочного файла, а не путем явного вызова &lt;code&gt;start/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d87148c3c9af3d9845486aa30c973c1b2043ba3" translate="yes" xml:space="preserve">
          <source>The diameter application takes responsibility for exchanging CER/CEA with the peer. Upon successful completion of capabilities exchange the service calls each relevant application module's &lt;code&gt;peer_up/3&lt;/code&gt; callback after which the caller can exchange Diameter messages with the peer over the transport. In addition to CER/CEA, the service takes responsibility for the handling of DWR/DWA and required by RFC 3539, as well as for DPR/DPA.</source>
          <target state="translated">Приложение диаметра берет на себя обмен CER / CEA с партнером. После успешного завершения обмена возможностями служба вызывает обратный вызов &lt;code&gt;peer_up/3&lt;/code&gt; каждого соответствующего прикладного модуля, после чего вызывающая сторона может обмениваться сообщениями Diameter с партнером по транспорту. Помимо CER / CEA, служба берет на себя ответственность за обработку DWR / DWA и требует RFC 3539, а также DPR / DPA.</target>
        </trans-unit>
        <trans-unit id="fb2713bf78bad945032228e7d72a8fff3c2317e0" translate="yes" xml:space="preserve">
          <source>The diameter user does not need to call functions here explicitly when sending and receiving messages using &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; and the callback interface documented in &lt;code&gt;diameter_app(3)&lt;/code&gt;: diameter itself provides encode/decode as a consequence of configuration passed to &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, and the results may differ from those returned by the functions documented here, depending on configuration.</source>
          <target state="translated">Пользователю Diameter не нужно явно вызывать функции здесь при отправке и получении сообщений с использованием &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; и интерфейса обратного вызова, задокументированного в &lt;code&gt;diameter_app(3)&lt;/code&gt; : Сам диаметр обеспечивает кодирование / декодирование как следствие конфигурации, переданной в &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; , и результаты могут отличаться от результатов, возвращаемых функциями, описанными здесь, в зависимости от конфигурации.</target>
        </trans-unit>
        <trans-unit id="2251e3cdeb76f922995ac0b63ebf88f13a0667db" translate="yes" xml:space="preserve">
          <source>The diameterc utility is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter required to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">Утилита Diameterc используется для компиляции &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; диаметров в исходный код Erlang. Результирующий источник реализует диаметр интерфейса, необходимый для кодирования и декодирования сообщений словаря и AVP.</target>
        </trans-unit>
        <trans-unit id="a115af3fd2bc7d650329a3a62d8207ca3be6bd75" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt; deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b611f53150beb161ae68d1baa02e238a69d7fe" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Словарь, выбранный компрессором, может быть определен по значению Adler, возвращенному или брошенному вызовом функции inflate. Компрессор и декомпрессор должны использовать один и тот же словарь (см. &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc7c7b0117c79bf085087df0d9077cbcde71b86c" translate="yes" xml:space="preserve">
          <source>The dictionary interface documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; provides extensibility, allowing the user to defined new AVPs, commands, and applications. Ready dictionaries are provided for the RFC 6733 common message, base accounting, and relay applications, as well as for RFC 7683, Diameter Overload Indicator Conveyance.</source>
          <target state="translated">Интерфейс словаря, задокументированный в Diameter_dict &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; обеспечивает расширяемость, позволяя пользователю определять новые AVP, команды и приложения. Готовые словари предоставляются для приложений RFC 6733 для общих сообщений, базового учета и ретрансляции, а также для RFC 7683, &amp;laquo;Передача индикатора перегрузки диаметра&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="569d4e7fc1379c78daae74de968aa2107c8de266" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; on one hand, and &lt;code&gt;ordered_set&lt;/code&gt; on the other, regarding the fact that &lt;code&gt;ordered_set&lt;/code&gt; view keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt; whereas the other table types regard them equal only when they &lt;strong&gt;match&lt;/strong&gt;, holds for &lt;code&gt;lookup_element/3&lt;/code&gt;.</source>
          <target state="translated">Разница между &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; и &lt;code&gt;duplicate_bag&lt;/code&gt; , с одной стороны, и &lt;code&gt;ordered_set&lt;/code&gt; с другой, в том, что &lt;code&gt;ordered_set&lt;/code&gt; представления order_set равны, когда они &lt;strong&gt;сравниваются равными,&lt;/strong&gt; тогда как другие типы таблиц считают их равными только тогда, когда они &lt;strong&gt;совпадают&lt;/strong&gt; , сохраняется для &lt;code&gt;lookup_element/3&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="623ffdc435a2f724f0836bec7cc8ec30bc41c15a" translate="yes" xml:space="preserve">
          <source>The difference between lists as semantic objects (built up of individual &quot;cons&quot; and &quot;nil&quot; terms) and the various syntactic forms for denoting lists may be bewildering at first. This module provides functions both for exact control of the syntactic representation as well as for the simple composition and deconstruction in terms of cons and head/tail operations.</source>
          <target state="translated">Различие между списками как семантическими объектами (построенными из отдельных терминов &quot;минус&quot; и &quot;ноль&quot;)и различными синтаксическими формами для обозначения списков может поначалу вызывать недоумение.Этот модуль предоставляет функции как для точного управления синтаксическим представлением,так и для простой композиции и деконструкции в терминах &quot;cons&quot; и &quot;head/tail&quot;.</target>
        </trans-unit>
        <trans-unit id="da1728bb07e837f250209bb055d7409170953dd6" translate="yes" xml:space="preserve">
          <source>The difference between the &lt;code&gt;config&lt;/code&gt; terms above is that with &lt;code&gt;ConfigDir&lt;/code&gt;, &lt;code&gt;ConfigBaseNames&lt;/code&gt; is a list of base names, that is, without directory paths. &lt;code&gt;ConfigFiles&lt;/code&gt; must be full names, including paths. For example, the following two terms have the same meaning:</source>
          <target state="translated">Разница между &lt;code&gt;config&lt;/code&gt; выше терминами является то , что с &lt;code&gt;ConfigDir&lt;/code&gt; , &lt;code&gt;ConfigBaseNames&lt;/code&gt; список базовых имен, то есть, без путей каталогов. &lt;code&gt;ConfigFiles&lt;/code&gt; должны быть полные имена, включая пути. Например, следующие два термина имеют одинаковое значение:</target>
        </trans-unit>
        <trans-unit id="4f869b97b89ad5b7b934ce2b75aa574db5f22948" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is in how they get the modules to check. &lt;code&gt;versions1&lt;/code&gt; uses the app-file and &lt;code&gt;versions2&lt;/code&gt; uses the function &lt;code&gt;application:get_key&lt;/code&gt;.</source>
          <target state="translated">Разница между двумя функциями заключается в том, как они заставляют модули проверять. &lt;code&gt;versions1&lt;/code&gt; использует приложение-файл и &lt;code&gt;versions2&lt;/code&gt; использует функцию &lt;code&gt;application:get_key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="633f35639fdb5cc1cb10fd8f4689bf3336703581" translate="yes" xml:space="preserve">
          <source>The difference between these functions is the order the table is accessed for &lt;code&gt;ordered_set&lt;/code&gt; tables. For other table types the functions are equivalent.</source>
          <target state="translated">Разница между этими функциями заключается в порядке доступа к таблице для таблиц &lt;code&gt;ordered_set&lt;/code&gt; . Для других типов таблиц функции эквивалентны.</target>
        </trans-unit>
        <trans-unit id="293fb4be14373398bacd278126f271ff3f4aab95" translate="yes" xml:space="preserve">
          <source>The difference between using the macros and the exported functions is that macros add location (originator) information to the metadata, and performs lazy evaluation by wrapping the logger call in a case statement, so it is only evaluated if the log level of the event passes the primary log level check.</source>
          <target state="translated">Разница между использованием макросов и экспортированными функциями заключается в том,что макросы добавляют информацию о местоположении (отправителе)в метаданные и выполняют ленивую оценку,обертывая вызов логгера в утверждение случая,поэтому он оценивается только в том случае,если уровень журнала события проходит проверку на первичном уровне журнала.</target>
        </trans-unit>
        <trans-unit id="9bd33d3347fbec04e6dd5bced0f65f041be1e03c" translate="yes" xml:space="preserve">
          <source>The difference here is that a check is made for two keys in each map argument. The other keys are ignored.</source>
          <target state="translated">Разница заключается в том,что в каждом аргументе карты делается проверка на наличие двух ключей.Остальные ключи игнорируются.</target>
        </trans-unit>
        <trans-unit id="57afc2a6da2d7ad1a93ff6f446c9b773c487ccf9" translate="yes" xml:space="preserve">
          <source>The difference is the same as between &lt;code&gt;=:=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Разница такая же, как между &lt;code&gt;=:=&lt;/code&gt; и &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a13a50925424597a830fc48487f1c8e6506ee4cb" translate="yes" xml:space="preserve">
          <source>The different &lt;code&gt;&lt;a href=&quot;#Time-Outs&quot;&gt;Time-Outs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;next_event&lt;/a&gt;&lt;/code&gt; actions generate new events with corresponding &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; Event Types and Event Content &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37953effd4c1eb8de7eafd4f2558c81bd077904b" translate="yes" xml:space="preserve">
          <source>The different amounts of memory that are summed are &lt;strong&gt;not&lt;/strong&gt; gathered atomically, which introduces an error in the result.</source>
          <target state="translated">Суммируемые различные объемы памяти &lt;strong&gt;не&lt;/strong&gt; собираются атомарно, что приводит к ошибке в результате.</target>
        </trans-unit>
        <trans-unit id="63548572b896ecd0cf28068a1070f068efa94f1e" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; to load the MIB, and &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="translated">Различные приложения используют разные стратегии для загрузки MIB в агент. Некоторые реализации MIB предназначены только для кода, в то время как другим требуется сервер. Один из способов, используемый реализациями MIB только для кода, - это вызов пользователем функции, такой как &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; чтобы загрузить MIB, и &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; чтобы выгрузить MIB. См. Страницу руководства для каждого приложения, где описано, как загрузить каждую MIB.</target>
        </trans-unit>
        <trans-unit id="c8edadae2095be022adc91aad4a672571547faa5" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; to load the MIB, and &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79b82512ebbf07ebe9d9f10fb15d9e8e743cedd" translate="yes" xml:space="preserve">
          <source>The different options that can be given to &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Различные параметры, которые можно задать &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a06445034a6453f0f6ebe99a200207183eacb6" translate="yes" xml:space="preserve">
          <source>The different queries are described in section &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Различные запросы описаны в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39eab07bc9f9f2de5d553eb9e3b513aeec95de3f" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc4891f4df1692cd0b3f6e8badc0320a795dc5b" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="translated">Различные состояния, в которых может находиться поток. Подробности смотрите в &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59070d2c07904f6e20fde995a37ca6d79f115caa" translate="yes" xml:space="preserve">
          <source>The different trace tags that the tracer is called with. Each trace tag is described in detail in &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Различные теги трассировки, с которыми вызывается трассировщик. Каждый тег трассировки подробно описан в &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26366e48ea2a96c9fc5d9a43d23aaffa5017f9cd" translate="yes" xml:space="preserve">
          <source>The different types are as follows:</source>
          <target state="translated">Различные типы являются следующими:</target>
        </trans-unit>
        <trans-unit id="33105c1c6606db02bff579f3c5759de25bdebf48" translate="yes" xml:space="preserve">
          <source>The different types of schedulers handle specific types of jobs. Every job is assigned to a specific scheduler type. Jobs can migrate between different schedulers of the same type, but never between schedulers of different types. This fact has to be taken under consideration when evaluating the result returned.</source>
          <target state="translated">Различные типы планировщиков обрабатывают конкретные типы заданий.Каждому заданию присваивается определенный тип планировщика.Задания могут мигрировать между различными планировщиками одного и того же типа,но никогда-между планировщиками разных типов.Этот факт необходимо учитывать при оценке возвращаемого результата.</target>
        </trans-unit>
        <trans-unit id="1be30a2a4e12fc360bee8dc49ed629e5a73999d2" translate="yes" xml:space="preserve">
          <source>The different values have the following relation to each other. Values beginning with an uppercase letter is not part of the result.</source>
          <target state="translated">Различные значения имеют следующее отношение друг к другу.Значения,начинающиеся с прописной буквы,не являются частью результата.</target>
        </trans-unit>
        <trans-unit id="27f3bb8909ba5f23310f5128f455bc5958825585" translate="yes" xml:space="preserve">
          <source>The digraph can be read and modified by the creating process only.</source>
          <target state="translated">Диграф может быть прочитан и модифицирован только в процессе создания.</target>
        </trans-unit>
        <trans-unit id="5490f515ffc9d05efae42bd4eb4b5cd4c506605c" translate="yes" xml:space="preserve">
          <source>The digraph is to be kept &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Орграф должен быть &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a122eabc0003f4c72a6d838ab9da37d1a4643c2" translate="yes" xml:space="preserve">
          <source>The digraphs managed by this module are stored in &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS tables&lt;/a&gt;&lt;/code&gt;. That implies the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c044f6070f82e882ec6b0eabc539f770d3dd32" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-error(Term)&lt;/code&gt; causes a compilation error.</source>
          <target state="translated">Директива &lt;code&gt;-error(Term)&lt;/code&gt; вызывает ошибку компиляции.</target>
        </trans-unit>
        <trans-unit id="b3797b9e1d8ee2883c9f63d0a42a95ca4d06540e" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-warning(Term)&lt;/code&gt; causes a compilation warning.</source>
          <target state="translated">Директива &lt;code&gt;-warning(Term)&lt;/code&gt; вызывает предупреждение компиляции.</target>
        </trans-unit>
        <trans-unit id="58617ed5f0889f1d1f3277ea479ef4c02a22c0a7" translate="yes" xml:space="preserve">
          <source>The directories given by the &lt;code&gt;include&lt;/code&gt; option</source>
          <target state="translated">Каталоги даваемые &lt;code&gt;include&lt;/code&gt; опцию</target>
        </trans-unit>
        <trans-unit id="1f52da4640ac6f1c489638d9eafbfb94f7337064" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;-I&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">Каталоги, указанные с помощью опции &lt;code&gt;-I&lt;/code&gt; ; каталог, указанный последним, ищется первым</target>
        </trans-unit>
        <trans-unit id="071745beb88d646a425661fabb7b2b140020baaf" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;i&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">Каталоги, указанные с помощью опции &lt;code&gt;i&lt;/code&gt; ; каталог, указанный последним, ищется первым</target>
        </trans-unit>
        <trans-unit id="be6fba73ebc340991bdfb6820c1ebc97ba0e0651" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;Path&lt;/code&gt;does not exist.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; каталогу не существует.</target>
        </trans-unit>
        <trans-unit id="7bccd89dc32dbb0c503ff0753756340f2c3e005e" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Каталог можно изменить с помощью опции &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdb62f5fdc6e1ffa70960cbc73d316528fae55b5" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc2f12b5fc8219c0bfb75133fa338329e4cc3b0" translate="yes" xml:space="preserve">
          <source>The directory does not exist.</source>
          <target state="translated">Каталога не существует.</target>
        </trans-unit>
        <trans-unit id="117b6acef024fb182d6e7698c7419f59fe7b75af" translate="yes" xml:space="preserve">
          <source>The directory for (1) back-up copy and (2) Erlang-specific configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">Каталог для (1) резервной копии и (2) специфичного для Erlang файла конфигурации для &lt;code&gt;syslogd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="339f3fbc63ee87a760e5d5881f1be19ceac96fd2" translate="yes" xml:space="preserve">
          <source>The directory is not empty.</source>
          <target state="translated">Каталог не пустой.</target>
        </trans-unit>
        <trans-unit id="7febdc58b57a39ad1e446e02f6b42469827aa2db" translate="yes" xml:space="preserve">
          <source>The directory listing also contains one &lt;code&gt;.DAT&lt;/code&gt; file, which contains the schema itself, contained in the &lt;code&gt;schema.DAT&lt;/code&gt; file. The &lt;code&gt;DAT&lt;/code&gt; files are indexed files, and it is efficient to insert and search for records in these files with a specific key. The &lt;code&gt;.DAT&lt;/code&gt; files are used for the schema and for &lt;code&gt;disc_only_copies&lt;/code&gt; tables. The &lt;code&gt;Mnesia&lt;/code&gt; data files are currently implemented in the standard library module &lt;code&gt;dets&lt;/code&gt; in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">Список каталогов также содержит один файл &lt;code&gt;.DAT&lt;/code&gt; , который содержит саму схему, содержащуюся в файле &lt;code&gt;schema.DAT&lt;/code&gt; . В &lt;code&gt;DAT&lt;/code&gt; файлы проиндексированные файлы, и она эффективна для вставки и поиска записей в этих файлах с определенным ключом. В &lt;code&gt;.DAT&lt;/code&gt; файлы используются для схемы и &lt;code&gt;disc_only_copies&lt;/code&gt; таблиц. В &lt;code&gt;Mnesia&lt;/code&gt; файлы данных в настоящее время реализованы в стандартной библиотеки модулей &lt;code&gt;dets&lt;/code&gt; в &lt;code&gt;STDLIB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc8511921c9959d184fd92a30bcce8e510e914f" translate="yes" xml:space="preserve">
          <source>The directory structure for the code installed by the release handler from a release package is as follows:</source>
          <target state="translated">Структура каталога для кода,установленного обработчиком выпуска из пакета выпуска,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a42562d2ee99aac69e248e9c1d20b489a29d934f" translate="yes" xml:space="preserve">
          <source>The directory to read the application from. This parameter can be used to point out a specific location to fetch the application from. This is useful for instance if the parent directory for some reason is no good as a library directory on system level.</source>
          <target state="translated">Каталог для чтения приложения.Этот параметр может быть использован для указания определенного места для получения приложения.Это полезно,например,если родительский каталог по каким-то причинам не подходит в качестве библиотечного каталога на системном уровне.</target>
        </trans-unit>
        <trans-unit id="d7bfc486e65b60f6f17e8c030cc98aaf1f5887ba" translate="yes" xml:space="preserve">
          <source>The directory where temporary files are put can be chosen explicitly. The default, implied by value &lt;code&gt;&quot;&quot;&lt;/code&gt;, is to put temporary files on the same directory as the sorted output file. If output is a function (see below), the directory returned by &lt;code&gt;file:get_cwd()&lt;/code&gt; is used instead. The names of temporary files are derived from the Erlang nodename (&lt;code&gt;node()&lt;/code&gt;), the process identifier of the current Erlang emulator (&lt;code&gt;os:getpid()&lt;/code&gt;), and a unique integer (&lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt;). A typical name is &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt;, where &lt;code&gt;17&lt;/code&gt; is a sequence number. Existing files are overwritten. Temporary files are deleted unless some uncaught &lt;code&gt;EXIT&lt;/code&gt; signal occurs.</source>
          <target state="translated">Каталог, в который помещаются временные файлы, можно выбрать явно. По умолчанию, подразумеваемое значением &lt;code&gt;&quot;&quot;&lt;/code&gt; , временные файлы помещаются в тот же каталог, что и отсортированный выходной файл. Если вывод является функцией (см. Ниже), вместо этого используется каталог, возвращаемый &lt;code&gt;file:get_cwd()&lt;/code&gt; . Имена временных файлов являются производными от имени &lt;code&gt;node()&lt;/code&gt; Erlang ( node () ), идентификатора процесса текущего эмулятора Erlang ( &lt;code&gt;os:getpid()&lt;/code&gt; ) и уникального целого числа ( &lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt; ). Типичное имя - &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt; , где &lt;code&gt;17&lt;/code&gt; - порядковый номер. Существующие файлы перезаписываются. Временные файлы удаляются, если какой-то неперехваченный &lt;code&gt;EXIT&lt;/code&gt; появляется сигнал.</target>
        </trans-unit>
        <trans-unit id="26b2546fb62728f487df23d7a64fc6038e2f04cd" translate="yes" xml:space="preserve">
          <source>The directory where the compiler is to place the output files. Defaults to the current working directory.</source>
          <target state="translated">Каталог,в который компилятор должен поместить выходные файлы.По умолчанию-текущая рабочая директория.</target>
        </trans-unit>
        <trans-unit id="23d4b2c59c247070b6160ec438b2f4a12342bdf0" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the agent.</source>
          <target state="translated">В качестве параметра агенту передается каталог,в котором находятся конфигурационные файлы.</target>
        </trans-unit>
        <trans-unit id="f35f2fdf2411bb1709c721e727448cb07cb8e62e" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the manager.</source>
          <target state="translated">Каталог,в котором находятся конфигурационные файлы,задается в качестве параметра менеджера.</target>
        </trans-unit>
        <trans-unit id="57ac9409f64c817119b2a62c56ec2039ee44af45" translate="yes" xml:space="preserve">
          <source>The directory where the module is being compiled</source>
          <target state="translated">Каталог,в котором компилируется модуль</target>
        </trans-unit>
        <trans-unit id="a823ed8e05f4f19f697c128e1d3b1f2bf689cda5" translate="yes" xml:space="preserve">
          <source>The disconnect may either be made explicitly by a call to megaco:disconnect/2 or implicitly when the control process of the connection dies.</source>
          <target state="translated">Отсоединение может быть произведено либо явным образом по вызову megaco:disconnect/2,либо неявно,когда процесс управления соединением умирает.</target>
        </trans-unit>
        <trans-unit id="4ffbc4f5819bc4c210bf785d2c507c9b376119c7" translate="yes" xml:space="preserve">
          <source>The discovery module may implement the following callback:</source>
          <target state="translated">Модуль обнаружения может реализовать следующий обратный вызов:</target>
        </trans-unit>
        <trans-unit id="84d184d395f04b053ca8e8de39c92096a4dfaac1" translate="yes" xml:space="preserve">
          <source>The discovery module needs to implement the same API as the regular &lt;code&gt;EPMD module&lt;/code&gt;. However, instead of communicating with EPMD you can connect to any service to find out connection details of other nodes. A discovery module is enabled by setting &lt;code&gt;-epmd_module&lt;/code&gt; when starting erlang. The discovery module must implement the following callbacks:</source>
          <target state="translated">Модуль обнаружения должен реализовывать тот же API, что и обычный &lt;code&gt;EPMD module&lt;/code&gt; . Однако вместо связи с EPMD вы можете подключиться к любой службе, чтобы узнать подробности подключения других узлов. Модуль обнаружения включается установкой &lt;code&gt;-epmd_module&lt;/code&gt; при запуске erlang. Модуль обнаружения должен реализовывать следующие обратные вызовы:</target>
        </trans-unit>
        <trans-unit id="99d7db3ae01fbb644d3dec6e8da4ab75b95c8848" translate="yes" xml:space="preserve">
          <source>The disk log process is not terminated as long as there are owners or users of the log. All owners must close the log, possibly by terminating. Also, any other process, not only the processes that have opened the log anonymously, can decrement the &lt;code&gt;users&lt;/code&gt; counter by closing the log. Attempts to close a log by a process that is not an owner are ignored if there are no users.</source>
          <target state="translated">Процесс журнала диска не завершается, пока есть владельцы или пользователи журнала. Все владельцы должны закрыть журнал, возможно, завершив работу. Кроме того, любой другой процесс, а не только процессы, открывшие журнал анонимно, может уменьшить счетчик &lt;code&gt;users&lt;/code&gt; , закрыв журнал. Попытки закрыть журнал процессом, не являющимся владельцем, игнорируются, если нет пользователей.</target>
        </trans-unit>
        <trans-unit id="170e47f1105c3410c9337c315483a1099114bce2" translate="yes" xml:space="preserve">
          <source>The disk space required by Solaris can be minimized by using the Core User support installation. It requires about 80 MB of disk space. This installs only the minimum software required to boot and run Solaris. The disk space can be further reduced by deleting unnecessary individual files. However, unless disk space is a critical resource the effort required and the risks involved cannot be justified.</source>
          <target state="translated">Необходимое для Solaris дисковое пространство может быть минимизировано с помощью установки поддержки Core User.Для этого требуется около 80 МБ дискового пространства.При этом устанавливается только минимальное программное обеспечение,необходимое для загрузки и запуска Solaris.Дисковое пространство можно дополнительно сократить,удалив ненужные отдельные файлы.Однако,если дисковое пространство не является критическим ресурсом,то необходимые усилия и связанные с этим риски не могут быть оправданы.</target>
        </trans-unit>
        <trans-unit id="fe0b0c298992c4d4142451f12161d0c1045bd18b" translate="yes" xml:space="preserve">
          <source>The distributed &lt;code&gt;disk_log&lt;/code&gt; feature is as of &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; and will be removed in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6a6e83a54df4db4da031bb114c30e047aae690" translate="yes" xml:space="preserve">
          <source>The distributed disk log feature has been deprecated. This feature has also been scheduled for removal in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5252445bcfdf0c4e9a0db2f6abd1c5ab396bbcae" translate="yes" xml:space="preserve">
          <source>The distribution does this implicitly when sending messages across node boundaries.</source>
          <target state="translated">Распределение делает это неявно при отправке сообщений через границы узлов.</target>
        </trans-unit>
        <trans-unit id="54a389857119d0e949a971f667eeb2bc4135d70c" translate="yes" xml:space="preserve">
          <source>The distribution header format is as follows:</source>
          <target state="translated">Формат распределительных заголовков следующий:</target>
        </trans-unit>
        <trans-unit id="ec94c3993a60ce6a0e075478f122164e01b59597" translate="yes" xml:space="preserve">
          <source>The distribution header is sent by the erlang distribution to carry metadata about the coming &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; and potential payload. It is primarily used to handle the atom cache in the Erlang distribution. Since OTP-22 it is also used to fragment large distribution messages into multiple smaller fragments. For more information about how the distribution uses the distribution header, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7207d53f2df6dd951040b5a96c6e6f572abc8fba" translate="yes" xml:space="preserve">
          <source>The distribution header only contains an atom cache reference section, but can in the future contain more information. The distribution header precedes one or more Erlang terms on the external format. For more information, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="translated">Заголовок распределения содержит только раздел ссылок на атомный кеш, но в будущем может содержать дополнительную информацию. Заголовок распределения предшествует одному или нескольким терминам Erlang во внешнем формате. Для получения дополнительной информации см. Документацию &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; в документации &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2379df6378023fbabe88db9769e48826a29d56a" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is implemented using TCP/IP sockets. How to implement an alternative carrier is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">Механизм распространения реализован с использованием сокетов TCP / IP. Как внедрить альтернативный носитель, описано в &lt;code&gt;ERTS User's Guide&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62295fb74df53713cac7805be082a69085ad9fa7" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is not backward compatible by default. This flag sets the emulator in compatibility mode with an earlier Erlang/OTP release &lt;code&gt;ReleaseNumber&lt;/code&gt;. The release number must be in the range &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt;. This limits the emulator, making it possible for it to communicate with Erlang nodes (as well as C- and Java nodes) running that earlier release.</source>
          <target state="translated">Механизм распространения по умолчанию не имеет обратной совместимости. Этот флаг устанавливает эмулятор в режим совместимости с &lt;code&gt;ReleaseNumber&lt;/code&gt; более ранней версии Erlang / OTP . Номер версии должен находиться в диапазоне &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt; . Это ограничивает эмулятор, позволяя ему связываться с узлами Erlang (а также узлами C и Java), на которых запущена эта более ранняя версия.</target>
        </trans-unit>
        <trans-unit id="9cd5b036f8947d038790d0e5bd184b32b79cd32e" translate="yes" xml:space="preserve">
          <source>The distribution module expose an API that &lt;code&gt;net_kernel&lt;/code&gt; call in order to manage connections to other nodes. The module name should have the suffix &lt;code&gt;_dist&lt;/code&gt;.</source>
          <target state="translated">Модуль распространения предоставляет API, который &lt;code&gt;net_kernel&lt;/code&gt; для управления подключениями к другим узлам. Имя модуля должно иметь суффикс &lt;code&gt;_dist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9731f94ba0606fc85b916d2adf784a2aceb2f3dc" translate="yes" xml:space="preserve">
          <source>The distribution module for SSL/TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="translated">Модуль распространения для SSL / TLS называется &lt;code&gt;inet_tls_dist&lt;/code&gt; и указывается в командной строке с параметром &lt;code&gt;-proto_dist&lt;/code&gt; . Аргумент &lt;code&gt;-proto_dist&lt;/code&gt; должен быть именем модуля без суффикса &lt;code&gt;_dist&lt;/code&gt; . Итак, этот модуль распространения указывается с помощью &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="b1f0fad23847abdca6666c395577ff14f2547ccd" translate="yes" xml:space="preserve">
          <source>The distribution module for TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aeea032ca4cef8b317244fbb44d9a32ae5f5898" translate="yes" xml:space="preserve">
          <source>The distribution protocol can be divided into four parts:</source>
          <target state="translated">Протокол распределения можно разделить на четыре части:</target>
        </trans-unit>
        <trans-unit id="ff1a3d4e65478d9f5f71da059cfc38ed2c96b5ba" translate="yes" xml:space="preserve">
          <source>The distribution starts at boot if all the above is specified and an &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; flag is present at the command line.</source>
          <target state="translated">Распространение запускается при загрузке, если все вышеперечисленное указано и в командной строке присутствует флаг &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b01c03572e2e4aaafce0356c4411e135ed1f526" translate="yes" xml:space="preserve">
          <source>The document returned by &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; and &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. The type of the returned record depends on the value of the document option passed to the function.</source>
          <target state="translated">Документ, возвращаемый &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; и &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; . Тип возвращаемой записи зависит от значения параметра документа, переданного функции.</target>
        </trans-unit>
        <trans-unit id="00d8e9f113e0a458f5df4e4708996df9d6090e13" translate="yes" xml:space="preserve">
          <source>The documentation can be installed either using the &lt;code&gt;install-docs&lt;/code&gt; target, or using the &lt;code&gt;release_docs&lt;/code&gt; target.</source>
          <target state="translated">Документацию можно установить либо с помощью цели &lt;code&gt;install-docs&lt;/code&gt; , либо с &lt;code&gt;release_docs&lt;/code&gt; цели release_docs .</target>
        </trans-unit>
        <trans-unit id="5149c903e3309937ac98a7bf77705046a7abe19b" translate="yes" xml:space="preserve">
          <source>The dollar character is an assertion that is true only if the current matching point is at the end of the subject string, or immediately before a newline at the end of the string (by default). Notice however that it does not match the newline. Dollar needs not to be the last character of the pattern if some alternatives are involved, but it is to be the last item in any branch in which it appears. Dollar has no special meaning in a character class.</source>
          <target state="translated">Символ доллара-это утверждение,которое верно только в том случае,если текущая точка выравнивания находится в конце тематической строки,или непосредственно перед новой строкой в конце строки (по умолчанию).Заметьте,однако,что он не совпадает с новой строкой.Доллар не обязательно должен быть последним символом шаблона,если задействованы некоторые альтернативы,но он должен быть последним элементом в любой ветке,в которой он появляется.Доллар не имеет особого значения в классе символов.</target>
        </trans-unit>
        <trans-unit id="0fbbfd153dd0451d5221908c40847d88ba4f1d83" translate="yes" xml:space="preserve">
          <source>The domain of a family is called the &lt;strong&gt;index set&lt;/strong&gt;, and the range is called the &lt;strong&gt;indexed set&lt;/strong&gt;.</source>
          <target state="translated">Домен семейства называется &lt;strong&gt;индексным набором&lt;/strong&gt; , а диапазон - &lt;strong&gt;индексированным набором&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5952578f1a7b818cc8da70c30b5eb53cf1931cf6" translate="yes" xml:space="preserve">
          <source>The dot metacharacter</source>
          <target state="translated">Точечный метахарактер</target>
        </trans-unit>
        <trans-unit id="0c39bb4aef52ace658cb63c48687e207b1ca1ec6" translate="yes" xml:space="preserve">
          <source>The downgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;downgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">Затем сценарий &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; можно оценить с помощью eval_appup_script / 4 . Вместо этого рекомендуется использовать &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; , но эта функция ( &lt;code&gt;downgrade_script&lt;/code&gt; ) полезна для проверки содержимого скрипта.</target>
        </trans-unit>
        <trans-unit id="1a9b899e09f583022f6155a633fa34d496d384c3" translate="yes" xml:space="preserve">
          <source>The downside of an enforced transaction recovery decision is that the decision can be incorrect, because of insufficient information about the recovery decisions from the other nodes. This can result in an inconsistent database where &lt;code&gt;Mnesia&lt;/code&gt; has committed the transaction on some nodes but terminated it on others.</source>
          <target state="translated">Обратной стороной принудительного решения о восстановлении транзакции является то, что решение может быть неверным из-за недостаточной информации о решениях восстановления от других узлов. Это может привести к несогласованности базы данных, где &lt;code&gt;Mnesia&lt;/code&gt; зафиксировала транзакцию на некоторых узлах, но завершила ее на других.</target>
        </trans-unit>
        <trans-unit id="4bcc2bcf2d8764baa874ccaf0e26026a8ea86d10" translate="yes" xml:space="preserve">
          <source>The drive does not exist.</source>
          <target state="translated">Привода не существует.</target>
        </trans-unit>
        <trans-unit id="a20548a0f73bb216b4b211c372344d02764897f0" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is not present in the system.</source>
          <target state="translated">Водитель &lt;code&gt;Name&lt;/code&gt; не присутствует в системе.</target>
        </trans-unit>
        <trans-unit id="822e4982aaf8b56398bd1a181c2b6889e1c63b93" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is present in the system, but there is no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of it in this process.</source>
          <target state="translated">Водитель &lt;code&gt;Name&lt;/code&gt; присутствует в системе, но не &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; его в этом процессе.</target>
        </trans-unit>
        <trans-unit id="1b210ce4bf131d4b12dbe57304824a0514f38f51" translate="yes" xml:space="preserve">
          <source>The driver binary has a field, &lt;code&gt;orig_bytes&lt;/code&gt;, which marks the start of the data in the binary.</source>
          <target state="translated">В двоичном &lt;code&gt;orig_bytes&lt;/code&gt; драйвера есть поле orig_bytes , которое отмечает начало данных в двоичном файле .</target>
        </trans-unit>
        <trans-unit id="790a2c01c39cd01e89b6ba7ec3e95447572133e7" translate="yes" xml:space="preserve">
          <source>The driver callback functions are called synchronously from the Erlang emulator. If they take too long before completing, they can cause time-outs in the emulator. Use the queue or asynchronous calls if necessary, as the emulator must be responsive.</source>
          <target state="translated">Функции обратного вызова драйвера вызываются синхронно из эмулятора Erlang.Если они занимают слишком много времени перед завершением,они могут вызвать тайм-ауты в эмуляторе.При необходимости используйте очереди или асинхронные вызовы,так как эмулятор должен реагировать.</target>
        </trans-unit>
        <trans-unit id="157c45a036de0fa3ddd4ea0c8781ead7513f314e" translate="yes" xml:space="preserve">
          <source>The driver calls back to the emulator, using the API functions declared in &lt;code&gt;erl_driver.h&lt;/code&gt;. They are used for outputting data from the driver, using timers, and so on.</source>
          <target state="translated">Драйвер обращается к эмулятору, используя функции API, объявленные в &lt;code&gt;erl_driver.h&lt;/code&gt; . Они используются для вывода данных из драйвера, с помощью таймеров и так далее.</target>
        </trans-unit>
        <trans-unit id="bc789bf203b3722793ad6336ed379ee48dc982f5" translate="yes" xml:space="preserve">
          <source>The driver can exit and signal errors up to Erlang. This is only for severe errors, when the driver cannot possibly keep open.</source>
          <target state="translated">Драйвер может выходить и сигнализировать об ошибках вплоть до Эрланга.Это только в случае серьезных ошибок,когда водитель не может оставаться открытым.</target>
        </trans-unit>
        <trans-unit id="6e77324ef81504134fd1f1323beb52a29f3e3f65" translate="yes" xml:space="preserve">
          <source>The driver can only be unloaded when there are no open ports using it and no more &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; require it to be loaded.</source>
          <target state="translated">Драйвер может быть выгружен только в том случае, если нет открытых портов, использующих его, и &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; больше не требуется его загрузка.</target>
        </trans-unit>
        <trans-unit id="02d2238ddb29e9e347e288bd01312cba05b7f070" translate="yes" xml:space="preserve">
          <source>The driver data types and the functions available to the driver writer are defined in header file &lt;code&gt;erl_driver.h&lt;/code&gt; seated in Erlang's include directory. See the &lt;code&gt;erl_driver&lt;/code&gt; documentation for details of which functions are available.</source>
          <target state="translated">Типы данных драйвера и функции, доступные для средства записи драйвера, определены в заголовочном файле &lt;code&gt;erl_driver.h&lt;/code&gt; , расположенном в каталоге включения Erlang. См. Документацию по &lt;code&gt;erl_driver&lt;/code&gt; , чтобы узнать, какие функции доступны.</target>
        </trans-unit>
        <trans-unit id="85f6b3a5e6e8b698b73cc7423736b57c1fc18515" translate="yes" xml:space="preserve">
          <source>The driver entry contains the functions that will be called by the emulator. In this example, only &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;control&lt;/code&gt; are provided:</source>
          <target state="translated">Запись драйвера содержит функции, которые будут вызываться эмулятором. В этом примере предоставляются только &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; и &lt;code&gt;control&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fbb368d133889289794fdcfad4ea08d3c6807b8d" translate="yes" xml:space="preserve">
          <source>The driver has made itself permanent, in which case it can no longer be manipulated by this interface (much like a statically linked-in driver).</source>
          <target state="translated">Драйвер сделал себя постоянным,и в этом случае им больше нельзя манипулировать через этот интерфейс (как статически связанным драйвером).</target>
        </trans-unit>
        <trans-unit id="66000da869d699cedf77816fe5c89cc8b497a778" translate="yes" xml:space="preserve">
          <source>The driver has requested itself to be permanent, making it behave like an Erlang linked-in driver and can no longer be manipulated with this API.</source>
          <target state="translated">Драйвер попросил себя быть постоянным,что заставляет его вести себя как драйвер,связанный с Erlang,и им больше нельзя манипулировать с помощью этого API.</target>
        </trans-unit>
        <trans-unit id="7f5e1b2ebfdf61236b9724f8274637d3ec47df15" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb99a228136eba922ef8092328ac0928261c0a09" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="translated">Драйвер реализует интерфейс управления, который представляет собой синхронный интерфейс, вызываемый, когда Erlang вызывает &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; . Только этот интерфейс может управлять драйвером, когда он находится в режиме &lt;code&gt;data&lt;/code&gt; . Его можно вызвать с помощью следующих кодов операций:</target>
        </trans-unit>
        <trans-unit id="eb42a7455c90c66663b33eefe7d7a842a5468cbc" translate="yes" xml:space="preserve">
          <source>The driver initialization routine is (usually) declared with a macro to make the driver easier to port between different operating systems (and flavors of systems). This is the only routine that must have a well-defined name. All other callbacks are reached through the driver structure. The macro to use is named &lt;code&gt;DRIVER_INIT&lt;/code&gt; and takes the driver name as parameter:</source>
          <target state="translated">Процедура инициализации драйвера (обычно) объявляется с макросом, чтобы упростить перенос драйвера между различными операционными системами (и разновидностями систем). Это единственная процедура, у которой должно быть четко определенное имя. Все остальные обратные вызовы достигаются через структуру драйвера. Используемый макрос называется &lt;code&gt;DRIVER_INIT&lt;/code&gt; и принимает имя драйвера в качестве параметра:</target>
        </trans-unit>
        <trans-unit id="df5c267a32b3ddcfaa0938eb24b89bd6abfd4b02" translate="yes" xml:space="preserve">
          <source>The driver is already loaded with other &lt;code&gt;DriverOptionList&lt;/code&gt; or a different &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; argument.</source>
          <target state="translated">Драйвер уже загружен с другим &lt;code&gt;DriverOptionList&lt;/code&gt; или другим &lt;strong&gt;буквальным&lt;/strong&gt; аргументом &lt;code&gt;Path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="123d2435bbdf7446863fb98cf76173c154e93eaf" translate="yes" xml:space="preserve">
          <source>The driver is loaded by other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; when option &lt;code&gt;{reload, pending_driver}&lt;/code&gt; was specified.</source>
          <target state="translated">Драйвер загружается другими &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; если была указана опция &lt;code&gt;{reload, pending_driver}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de8f98e94d0922e6ef27e0959b36602f7f443810" translate="yes" xml:space="preserve">
          <source>The driver is loaded with &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt;. If this is successful, or if it is already loaded, it is opened. This will call the &lt;code&gt;start&lt;/code&gt; function in the driver.</source>
          <target state="translated">Драйвер загружается с помощью &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; . Если это успешно или если он уже загружен, он открывается. Это вызовет функцию &lt;code&gt;start&lt;/code&gt; в драйвере.</target>
        </trans-unit>
        <trans-unit id="f2356f498f6f6669e3b679a9b55e2c73ebdf7ef2" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt; erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebdfd6fd6dc142da610d573bd0e04e4e99b405d" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="translated">Драйвер выгружается только в результате вызова &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt; или при остановке эмулятора.</target>
        </trans-unit>
        <trans-unit id="aa4be31a9519f969227f921236d7d6aa51f75a8a" translate="yes" xml:space="preserve">
          <source>The driver is synchronous, it uses the synchronous calls of the client library. This is only for simplicity, but not good, as it halts the emulator while waiting for the database. This is improved below with an asynchronous sample driver.</source>
          <target state="translated">Драйвер синхронный,он использует синхронные вызовы клиентской библиотеки.Это только для простоты,но не хорошо,так как он останавливает эмулятор в ожидании базы данных.Это улучшено ниже с помощью асинхронного драйвера-образеца.</target>
        </trans-unit>
        <trans-unit id="d2846f7d13f5d6eeed6af66056f38ff13c49aabc" translate="yes" xml:space="preserve">
          <source>The driver is to be compiled and linked to a shared library (DLL on Windows). With gcc, this is done with link flags &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fpic&lt;/code&gt;. As we use the &lt;code&gt;ei&lt;/code&gt; library, we should include it too. There are several versions of &lt;code&gt;ei&lt;/code&gt;, compiled for debug or non-debug and multi-threaded or single-threaded. In the makefile for the samples, the &lt;code&gt;obj&lt;/code&gt; directory is used for the &lt;code&gt;ei&lt;/code&gt; library, meaning that we use the non-debug, single-threaded version.</source>
          <target state="translated">Драйвер должен быть скомпилирован и связан с общей библиотекой (DLL в Windows). В gcc это делается с помощью флагов &lt;code&gt;-shared&lt;/code&gt; и &lt;code&gt;-fpic&lt;/code&gt; . Поскольку мы используем библиотеку &lt;code&gt;ei&lt;/code&gt; , мы также должны включить ее. Существует несколько версий &lt;code&gt;ei&lt;/code&gt; , скомпилированных для отладки или без отладки, многопоточные или однопоточные. В make-файле для примеров каталог &lt;code&gt;obj&lt;/code&gt; используется для библиотеки &lt;code&gt;ei&lt;/code&gt; , что означает, что мы используем однопоточную версию без отладки.</target>
        </trans-unit>
        <trans-unit id="8352df0d68d66243c84331cdb4bc76e073f0f8fd" translate="yes" xml:space="preserve">
          <source>The driver is to be provided as a dynamically linked library in an object code format specific for the platform in use, that is, &lt;code&gt;.so&lt;/code&gt; files on most Unix systems and &lt;code&gt;.ddl&lt;/code&gt; files on Windows. An Erlang linked-in driver must provide specific interfaces to the emulator, so this module is not designed for loading arbitrary dynamic libraries. For more information about Erlang drivers, see &lt;code&gt;erts:erl_driver&lt;/code&gt; .</source>
          <target state="translated">Драйвер должен быть предоставлен в виде динамически подключаемой библиотеки в формате объектного кода, специфичном для используемой платформы, то есть файлы &lt;code&gt;.so&lt;/code&gt; в большинстве систем Unix и файлы &lt;code&gt;.ddl&lt;/code&gt; в Windows. Связанный драйвер Erlang должен предоставлять определенные интерфейсы для эмулятора, поэтому этот модуль не предназначен для загрузки произвольных динамических библиотек. Для получения дополнительной информации о драйверах Erlang см. &lt;code&gt;erts:erl_driver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11f7d0670a21cf6663ffe1e7be79926c35deca09" translate="yes" xml:space="preserve">
          <source>The driver is to fail only when in severe error situations, when the driver cannot possibly keep open, for example, buffer allocation gets out of memory. For normal errors it is more appropriate to send error codes with &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Драйвер должен выйти из строя только в случае серьезных ошибок, когда драйвер не может оставаться открытым, например, из-за нехватки памяти. Для обычных ошибок более целесообразно отправлять коды ошибок с помощью &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12952854b617484d4a3a18ae5571038f275167c0" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc198aad17d226134b089c46b5d58abebda6515e" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="translated">Имя драйвера. Он должен соответствовать атому, используемому в &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; , и имени файла библиотеки драйверов (без расширения).</target>
        </trans-unit>
        <trans-unit id="c745a240a8b09464690a74b0ded828b443277620" translate="yes" xml:space="preserve">
          <source>The driver names are returned as a list of strings rather than a list of atoms for historical reasons.</source>
          <target state="translated">Имена водителей возвращаются в виде списка строк,а не списка атомов по историческим причинам.</target>
        </trans-unit>
        <trans-unit id="8c90e4dc558838312154093ae7e4d33a042314e8" translate="yes" xml:space="preserve">
          <source>The driver options for a specified driver name need always to be consistent, &lt;strong&gt;even when the driver is reloaded&lt;/strong&gt;, meaning that they are as much a part of the driver as the name.</source>
          <target state="translated">Параметры драйвера для указанного имени драйвера всегда должны быть согласованными, &lt;strong&gt;даже когда драйвер перезагружается&lt;/strong&gt; , что означает, что они являются такой же частью драйвера, как и имя.</target>
        </trans-unit>
        <trans-unit id="ec7187710cb97de822c20a1794719f5b691ec563" translate="yes" xml:space="preserve">
          <source>The driver queue is available to queue output from the emulator to the driver (data from the driver to the emulator is queued by the emulator in normal Erlang message queues). This can be useful if the driver must wait for slow devices, and so on, and wants to yield back to the emulator. The driver queue is implemented as an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">Очередь драйвера доступна для постановки в очередь вывода из эмулятора в драйвер (данные из драйвера в эмулятор ставятся в очередь эмулятором в обычных очередях сообщений Erlang). Это может быть полезно, если драйвер должен ждать медленных устройств и т. Д. И хочет вернуться к эмулятору. Очередь драйверов реализована как &lt;code&gt;ErlIOVec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="267e1ade55aca0a7989f62dc5c3745421b17592a" translate="yes" xml:space="preserve">
          <source>The driver structure contains the driver name and some 15 function pointers, which are called at different times by the emulator.</source>
          <target state="translated">Структура драйвера содержит имя драйвера и около 15 указателей на функции,которые в разное время вызываются эмулятором.</target>
        </trans-unit>
        <trans-unit id="777fa5f89808e7871ea95ba4af70a119a6124215" translate="yes" xml:space="preserve">
          <source>The driver structure is filled with the driver name and function pointers. It is returned from the special entry point, declared with the macro &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">Структура драйвера заполнена именем драйвера и указателями функций. Он возвращается из специальной точки входа, объявленной с помощью макроса &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca38a39e87b4ab492f8fbeb01d018493a1577466" translate="yes" xml:space="preserve">
          <source>The driver structure is similar for statically linked-in drivers and dynamically loaded. However, some of the fields are to be left empty (that is, initialized to NULL) in the different types of drivers. The first field (the &lt;code&gt;init&lt;/code&gt; function pointer) is always left blank in a dynamically loaded driver, see line 26. &lt;code&gt;NULL&lt;/code&gt; on line 37 is always to be there, the field is no longer used and is retained for backward compatibility. No timers are used in this driver, why no callback for timers is needed. The &lt;code&gt;outputv&lt;/code&gt; field (line 40) can be used to implement an interface similar to Unix &lt;code&gt;writev&lt;/code&gt; for output. The Erlang runtime system could previously not use &lt;code&gt;outputv&lt;/code&gt; for the distribution, but it can as from ERTS 5.7.2. As this driver was written before ERTS 5.7.2 it does not use the &lt;code&gt;outputv&lt;/code&gt; callback. Using the &lt;code&gt;outputv&lt;/code&gt; callback is preferred, as it reduces copying of data. (We will however use scatter/gather I/O internally in the driver.)</source>
          <target state="translated">Структура драйвера аналогична для статически связанных драйверов и динамически загружаемых. Однако некоторые поля следует оставить пустыми (то есть инициализировать NULL) в различных типах драйверов. Первое поле ( указатель функции &lt;code&gt;init&lt;/code&gt; ) всегда остается пустым в динамически загружаемом драйвере, см. &lt;code&gt;NULL&lt;/code&gt; 26. NULL в строке 37 всегда должен присутствовать, поле больше не используется и сохраняется для обратной совместимости. В этом драйвере не используются таймеры, поэтому обратный вызов для таймеров не нужен. Поле &lt;code&gt;outputv&lt;/code&gt; (строка 40) может использоваться для реализации интерфейса, аналогичного &lt;code&gt;writev&lt;/code&gt; в Unix для вывода. Система времени выполнения Erlang ранее не могла использовать &lt;code&gt;outputv&lt;/code&gt; для раздачи, но может как из ERTS 5.7.2. Поскольку этот драйвер был написан до ERTS 5.7.2, он не использует &lt;code&gt;outputv&lt;/code&gt; вызов outputv . Использование обратного вызова &lt;code&gt;outputv&lt;/code&gt; является предпочтительным, так как это уменьшает копирование данных. (Однако мы будем использовать ввод-вывод с разбросом / сборкой внутри драйвера.)</target>
        </trans-unit>
        <trans-unit id="13e83e61fa641454caf4f4f17446cac682b522d1" translate="yes" xml:space="preserve">
          <source>The driver used for Erlang distribution is to implement a reliable, order maintaining, variable length packet-oriented protocol. All error correction, resending and such need to be implemented in the driver or by the underlying communications protocol. If the protocol is stream-oriented (as is the case with both TCP/IP and our streamed Unix domain sockets), some mechanism for packaging is needed. We will use the simple method of having a header of four bytes containing the length of the package in a big-endian 32-bit integer. As Unix domain sockets only can be used between processes on the same machine, we do not need to code the integer in some special endianess, but we will do it anyway because in most situation you need to do it. Unix domain sockets are reliable and order maintaining, so we do not need to implement resends and such in the driver.</source>
          <target state="translated">Драйвер,используемый для распределения Erlang,реализует надежный,поддерживающий заказ,пакетно-ориентированный протокол переменной длины.Все исправления ошибок,повторная отправка и т.д.должны быть реализованы в драйвере или базовом протоколе связи.Если протокол является потоково-ориентированным (как в случае как с TCP/IP,так и с нашими потоковыми Unix доменными сокетами),необходим некоторый механизм для упаковки.Мы будем использовать простой метод,при котором заголовок,состоящий из четырех байт,содержит длину пакета в big-endian 32-битное целое число.Поскольку Unix-доменные сокеты могут использоваться только между процессами на одной и той же машине,нам не нужно кодировать целое число в какой-то особой эндианности,но мы сделаем это в любом случае,потому что в большинстве ситуаций это нужно делать.Unix-доменные сокеты надежны и поддерживают порядок,поэтому нам не нужно реализовывать пересылки и тому подобное в драйвере.</target>
        </trans-unit>
        <trans-unit id="885a9c9f85b39e7698683efce0ff5bba88451a67" translate="yes" xml:space="preserve">
          <source>The driver was already loaded by another process or is in use by a living port, or both. The load by you is registered and a corresponding &lt;code&gt;try_unload&lt;/code&gt; is expected sometime in the future.</source>
          <target state="translated">Драйвер уже был загружен другим процессом или используется живым портом, или и тем, и другим. Ваша загрузка зарегистрирована, и &lt;code&gt;try_unload&lt;/code&gt; нибудь в будущем ожидается соответствующая попытка загрузки .</target>
        </trans-unit>
        <trans-unit id="380ea6d015cef2cddc2581f363be87321f771e9f" translate="yes" xml:space="preserve">
          <source>The driver was immediately unloaded, meaning that the driver name is now free to use by other drivers and, if the underlying OS permits it, the memory occupied by the driver object code is now reclaimed.</source>
          <target state="translated">Драйвер был немедленно выгружен,что означает,что имя драйвера теперь свободно для использования другими драйверами,и,если базовая ОС разрешает это,память,занятая объектным кодом драйвера,будет восстановлена.</target>
        </trans-unit>
        <trans-unit id="e3da2e19322e3c6628d119e07b3e56934634eac8" translate="yes" xml:space="preserve">
          <source>The driver was loaded and is immediately usable.</source>
          <target state="translated">Водитель был загружен и сразу же может быть использован.</target>
        </trans-unit>
        <trans-unit id="d864f9d9077463dec755426c28ec5da6f217e91e" translate="yes" xml:space="preserve">
          <source>The driver with the specified name is an Erlang statically linked-in driver, which cannot be manipulated with this API.</source>
          <target state="translated">Драйвер с указанным именем является статически связанным драйвером Erlang,которым нельзя манипулировать с данным API.</target>
        </trans-unit>
        <trans-unit id="75b79644c08326087c431ff0fd0e1f208afbe371" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt; driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1eb9606d6f4220a244d8c3b7748d550c419a79a" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">Разработчик драйвера должен предоставить память для хранения монитора при вызове &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt; . Адрес данных не сохраняется вне драйвера, поэтому &lt;code&gt;ErlDrvMonitor&lt;/code&gt; можно использовать как любые другие данные, его можно скопировать, переместить в память, забыть и т. Д.</target>
        </trans-unit>
        <trans-unit id="f4c87103ae153cd308d8f26cfae1b35225c5ea0c" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4025b3383bc4889c1c9cd923cfef69764fc7fb73" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определяемый драйвером дескриптор, который передается в последующих вызовах обратным вызовам драйвера. Обратите внимание, что &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; не вызывается для этого нового экземпляра драйвера. Определяемый драйвером дескриптор обычно создается в &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; когда порт создается с помощью erlang: open_port / 2 .</target>
        </trans-unit>
        <trans-unit id="394034fd0da749c1d06ef57ce69c6215ae425eb2" translate="yes" xml:space="preserve">
          <source>The driver-entry structure used by Erlang drivers.</source>
          <target state="translated">Водитель-входная структура,используемая водителями Эрланга.</target>
        </trans-unit>
        <trans-unit id="e67bdfbeb3c1793f1075c60e9dfc86106434ef3f" translate="yes" xml:space="preserve">
          <source>The dump is truncated.</source>
          <target state="translated">Свалка усечена.</target>
        </trans-unit>
        <trans-unit id="58fd56942c22b98ca6dfc0e41f2fc24c62b5de4a" translate="yes" xml:space="preserve">
          <source>The dump is truncated. In this case, a warning is displayed in the status bar of the main window.</source>
          <target state="translated">Свалка усечена.В этом случае в строке состояния главного окна отображается предупреждение.</target>
        </trans-unit>
        <trans-unit id="26da6cb9d5e2b4d506bf3083a6055833ae7a4362" translate="yes" xml:space="preserve">
          <source>The durability property ensures that changes made to the DBMS by a transaction are permanent. Once a transaction is committed, all changes made to the database are durable, that is, they are written safely to disc and do not become corrupted and do not disappear.</source>
          <target state="translated">Свойство долговечности гарантирует,что изменения,вносимые в СУБД транзакцией,являются постоянными.После совершения транзакции все изменения,вносимые в СУБД,долговечны,то есть безопасно записываются на диск,не повреждаются и не исчезают.</target>
        </trans-unit>
        <trans-unit id="a7aa3c54478ccaa5bbddda8a5fe6086c5ab90507" translate="yes" xml:space="preserve">
          <source>The duration time is specified as &lt;code&gt;HHMMSS&lt;/code&gt;, for example, &lt;code&gt;-duration 012030&lt;/code&gt; or &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt;</source>
          <target state="translated">Продолжительность указывается как &lt;code&gt;HHMMSS&lt;/code&gt; , например &lt;code&gt;-duration 012030&lt;/code&gt; или &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b34138fd668a3a91f262b3c8cc94e10c40614310" translate="yes" xml:space="preserve">
          <source>The dynamic engine is not supported in LibreSSL from version 2.2.1</source>
          <target state="translated">Динамический движок не поддерживается в LibreSSL начиная с версии 2.2.1.</target>
        </trans-unit>
        <trans-unit id="46cf93457fc198c7fc4b11e05da4141275628e59" translate="yes" xml:space="preserve">
          <source>The earlier factorial example can act as a counter-example. It is not tail-recursive, since a multiplication is done on the result of the recursive call to &lt;code&gt;fact(N-1)&lt;/code&gt;.</source>
          <target state="translated">Предыдущий факториальный пример может выступать в качестве контрпримера. Это не хвостовая рекурсия, поскольку умножение выполняется на результате рекурсивного обращения к &lt;code&gt;fact(N-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7471d512bedffa6e5e516b4425ff9cbeaebad94b" translate="yes" xml:space="preserve">
          <source>The easiest path is to mimic the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet_tcp&lt;/code&gt; interfaces, but not much functionality in those modules needs to be implemented. In the example application, only a few of the usual interfaces are implemented, and they are much simplified.</source>
          <target state="translated">Самый простой путь - имитировать интерфейсы &lt;code&gt;inet&lt;/code&gt; и &lt;code&gt;inet_tcp&lt;/code&gt; , но не нужно реализовывать много функций в этих модулях. В примере приложения реализованы лишь некоторые из обычных интерфейсов, и они значительно упрощены.</target>
        </trans-unit>
        <trans-unit id="5a4e2857f3f8ff97859f4357e2a194c2963da6e0" translate="yes" xml:space="preserve">
          <source>The easiest way of using &lt;code&gt;ET&lt;/code&gt;, is to just use it as a graphical tool for displaying message sequence charts. In order to do that you need to first start a &lt;code&gt;Viewer&lt;/code&gt; (which by default starts a &lt;code&gt;Collector&lt;/code&gt;):</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;ET&lt;/code&gt; - просто использовать его как графический инструмент для отображения диаграмм последовательности сообщений. Для этого вам нужно сначала запустить &lt;code&gt;Viewer&lt;/code&gt; (который по умолчанию запускает &lt;code&gt;Collector&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="3e2ec62c427c4d0d3ce97e74cc8645fe104a328c" translate="yes" xml:space="preserve">
          <source>The easiest way to start Crashdump Viewer is to use shell script &lt;code&gt;cdv&lt;/code&gt; with the full path to the Erlang crashdump as argument. The script is located in directory &lt;code&gt;priv&lt;/code&gt; of the Observer application. This starts the Crashdump Viewer GUI and loads the specified file. If no filename is specified, a file dialog is opened where the file can be selected.</source>
          <target state="translated">Самый простой способ запустить Crashdump Viewer - использовать &lt;code&gt;cdv&lt;/code&gt; сценария оболочки с полным путем к аварийному дампу Erlang в качестве аргумента. Скрипт находится в директории &lt;code&gt;priv&lt;/code&gt; приложения Observer. Это запустит графический интерфейс Crashdump Viewer и загрузит указанный файл. Если имя файла не указано, открывается диалоговое окно с файлом, в котором его можно выбрать.</target>
        </trans-unit>
        <trans-unit id="55d0d417d785ac1626163667303a6253a1c8a917" translate="yes" xml:space="preserve">
          <source>The effect of (*THEN) is now confined to the inner subpattern. After a failure in C, matching moves to (*FAIL), which causes the whole subpattern to fail, as there are no more alternatives to try. In this case, matching does now backtrack into A.</source>
          <target state="translated">Эффект (*THEN)теперь ограничивается внутренней подмаскировкой.После сбоя в C,соответствие переходит в (*FAIL),что приводит к неудаче всей подмаски,так как больше нет альтернатив,чтобы попробовать.В этом случае совпадение теперь возвращается в A.</target>
        </trans-unit>
        <trans-unit id="f16407eee4518305b005b9dbecb5884bd7cbf3bc" translate="yes" xml:space="preserve">
          <source>The effect of combining &lt;code&gt;set_on_first_link&lt;/code&gt; with &lt;code&gt;set_on_link&lt;/code&gt; is the same as &lt;code&gt;set_on_first_link&lt;/code&gt; alone. Likewise for &lt;code&gt;set_on_spawn&lt;/code&gt; and &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">Эффект объединения &lt;code&gt;set_on_first_link&lt;/code&gt; с &lt;code&gt;set_on_link&lt;/code&gt; такой же, как &lt;code&gt;set_on_first_link&lt;/code&gt; только set_on_first_link . &lt;code&gt;set_on_spawn&lt;/code&gt; же самое для set_on_spawn и &lt;code&gt;set_on_first_spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb46e1d7474732484a66c32367c6751904b1bed" translate="yes" xml:space="preserve">
          <source>The effect of option &lt;code&gt;cache&lt;/code&gt; is that when generator &lt;code&gt;QH2'&lt;/code&gt; is run the first time, every answer is stored in an ETS table. When the next answer of &lt;code&gt;QH1&lt;/code&gt; is tried, answers to &lt;code&gt;QH2'&lt;/code&gt; are copied from the ETS table, which is very fast. As for option &lt;code&gt;unique&lt;/code&gt; the cost is a possibly substantial amount of RAM memory.</source>
          <target state="translated">Эффект &lt;code&gt;cache&lt;/code&gt; опций заключается в том, что при &lt;code&gt;QH2'&lt;/code&gt; запуске генератора QH2 ' каждый ответ сохраняется в таблице ETS. При &lt;code&gt;QH1&lt;/code&gt; следующего ответа QH1 ответы на &lt;code&gt;QH2'&lt;/code&gt; копируются из таблицы ETS, что очень быстро. Что касается &lt;code&gt;unique&lt;/code&gt; варианта, то его стоимость - возможно, значительный объем оперативной памяти.</target>
        </trans-unit>
        <trans-unit id="46af5dbb6ad32f950d071087d55fd5eedd3a2dcc" translate="yes" xml:space="preserve">
          <source>The election process is modified as described in 5.6.4.</source>
          <target state="translated">Процесс выборов изменен,как описано в пункте 5.6.4.</target>
        </trans-unit>
        <trans-unit id="cdd607a9ef230a55bb6d74140b011672a2b70ef4" translate="yes" xml:space="preserve">
          <source>The element in position &lt;code&gt;Pos&lt;/code&gt; in &lt;code&gt;Pattern&lt;/code&gt; must be bound. &lt;code&gt;Pos&lt;/code&gt; is an integer (&lt;code&gt;#record.Field&lt;/code&gt;) or an attribute name.</source>
          <target state="translated">Элемент в позиции &lt;code&gt;Pos&lt;/code&gt; в &lt;code&gt;Pattern&lt;/code&gt; должен быть привязан. &lt;code&gt;Pos&lt;/code&gt; - это целое число ( &lt;code&gt;#record.Field&lt;/code&gt; ) или имя атрибута.</target>
        </trans-unit>
        <trans-unit id="c52c7c2c532d8015d87a1ff9dad023e4fb851308" translate="yes" xml:space="preserve">
          <source>The element to update is also the key.</source>
          <target state="translated">Элемент для обновления также является ключевым.</target>
        </trans-unit>
        <trans-unit id="133139824edb56fee5c9537204f00d5c8e6d31f2" translate="yes" xml:space="preserve">
          <source>The element to update is not an integer.</source>
          <target state="translated">Обновляемый элемент не является целым числом.</target>
        </trans-unit>
        <trans-unit id="6e2b6d90876d98adc6125d07f13d8d523ed72322" translate="yes" xml:space="preserve">
          <source>The embedded system and all the applications start automatically if the script file shown below is added to directory &lt;code&gt;/etc/rc3.d&lt;/code&gt;. The file must be owned and readable by &lt;code&gt;root&lt;/code&gt;. Its name cannot be arbitrarily assigned; the following name is recommended:</source>
          <target state="translated">Встроенная система и все приложения запускаются автоматически, если файл сценария, показанный ниже, добавлен в каталог &lt;code&gt;/etc/rc3.d&lt;/code&gt; . Файл должен принадлежать пользователю &lt;code&gt;root&lt;/code&gt; и быть доступным для чтения . Его имя нельзя присвоить произвольно; рекомендуется следующее имя:</target>
        </trans-unit>
        <trans-unit id="bad88f7a085d192e2f6cec49768a38f2903f8ae0" translate="yes" xml:space="preserve">
          <source>The emulator calls the driver in the following situations:</source>
          <target state="translated">Эмулятор вызывает драйвера в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="218b5d9983c658a4cef0aef4b47157f1b19f1a20" translate="yes" xml:space="preserve">
          <source>The emulator has been started with only one scheduler thread.</source>
          <target state="translated">Эмулятор запущен только с одним потоком планировщика.</target>
        </trans-unit>
        <trans-unit id="00ecfc5e261b4531e61f24b2c4f3b8605c732361" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, and no scheduler threads are blocked. That is, all available scheduler threads schedule Erlang processes and execute Erlang code.</source>
          <target state="translated">Эмулятор имеет более одного потока планировщика,и ни один поток планировщика не блокируется.То есть все доступные потоки планировщика планируют обработку и выполнение кода Erlang.</target>
        </trans-unit>
        <trans-unit id="d1335d1e55e250963f0d3ef76a97d106ea1aeeed" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all normal scheduler threads except one are blocked. Notice that dirty schedulers are not blocked, and can schedule Erlang processes and execute native code.</source>
          <target state="translated">Эмулятор имеет более одного потока планировщика,но все нормальные потоки планировщика,кроме одного,блокируются.Обратите внимание,что грязные планировщики не блокируются,и могут планировать процессы Erlang и выполнять нативный код.</target>
        </trans-unit>
        <trans-unit id="9e09f5c935221131fa5aa069cd7be0f9d773e6f4" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all scheduler threads except one are blocked. That is, only one scheduler thread schedules Erlang processes and executes Erlang code.</source>
          <target state="translated">Эмулятор имеет более одного потока планировщика,но все потоки планировщика,кроме одного,блокируются.То есть только один поток планировщика планирует обработку и выполнение кода Erlang.</target>
        </trans-unit>
        <trans-unit id="9414404aaefeb3f5826ea98674c66ad27f121727" translate="yes" xml:space="preserve">
          <source>The emulator probably uses more memory, and because garbage collections occur less frequently, huge binaries can be kept much longer.</source>
          <target state="translated">Эмулятор,вероятно,использует больше памяти,а поскольку сборщики мусора встречаются реже,огромные двоичные файлы можно хранить гораздо дольше.</target>
        </trans-unit>
        <trans-unit id="8c90a0c569f6e401278d0c92d5efb3209b403c33" translate="yes" xml:space="preserve">
          <source>The emulator refuses to load a driver that does not use the extended driver interface, to allow for 64-bit capable drivers, as incompatible type changes for the callbacks &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; were introduced in Erlang/OTP R15B. A driver written with the old types would compile with warnings and when called return garbage sizes to the emulator, causing it to read random memory and create huge incorrect result blobs.</source>
          <target state="translated">Эмулятор отказывается загружать драйвер, который не использует расширенный интерфейс драйвера, чтобы разрешить использование 64-разрядных драйверов, поскольку несовместимые изменения типов для &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; обратных вызовов были введены в Erlang / OTP R15B. Драйвер, написанный со старыми типами, будет компилироваться с предупреждениями и при вызове возвращать размеры мусора в эмулятор, заставляя его читать случайную память и создавать огромные блоки с неверными результатами.</target>
        </trans-unit>
        <trans-unit id="7a03fbfd7f6822486dc5e29a1dba526a017e4427" translate="yes" xml:space="preserve">
          <source>The emulator restart on Windows NT expects that the system is started using the &lt;code&gt;erlsrv&lt;/code&gt; program (as a service). Furthermore, the release handler expects that the service is named &lt;code&gt;NodeName&lt;/code&gt;_&lt;code&gt;Release&lt;/code&gt;, where &lt;code&gt;NodeName&lt;/code&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;code&gt;Release&lt;/code&gt; is the current release version. The release handler furthermore expects that a program like &lt;code&gt;start_erl.exe&lt;/code&gt; is specified as &quot;machine&quot; to &lt;code&gt;erlsrv&lt;/code&gt;. During upgrading with restart, a new service is registered and started. The new service is set to automatic and the old service is removed when the new release is made permanent.</source>
          <target state="translated">При перезапуске эмулятора в Windows NT предполагается, что система будет запущена с помощью программы &lt;code&gt;erlsrv&lt;/code&gt; (как службы). Кроме того, обработчик выпуска ожидает, что служба будет называться &lt;code&gt;NodeName&lt;/code&gt; _ &lt;code&gt;Release&lt;/code&gt; , где &lt;code&gt;NodeName&lt;/code&gt; - это первая часть имени узла Erlang (до, но не включая &quot;@&quot;), а &lt;code&gt;Release&lt;/code&gt; - это текущая версия выпуска. Обработчик выпуска, кроме того, ожидает, что такая программа, как &lt;code&gt;start_erl.exe&lt;/code&gt; , указана как &quot;машина&quot; для &lt;code&gt;erlsrv&lt;/code&gt; . Во время обновления с перезапуском регистрируется и запускается новая служба. Новая служба настроена на автоматический режим, а старая служба удаляется, когда новая версия становится постоянной.</target>
        </trans-unit>
        <trans-unit id="e59343153e5b1fe6b3e23daad5cd40c9373e3696" translate="yes" xml:space="preserve">
          <source>The encoder and decoder can also be run from the shell:</source>
          <target state="translated">Энкодер и декодер также могут быть запущены из оболочки:</target>
        </trans-unit>
        <trans-unit id="5524aa1d01a0ef49a1ac5386a1c63b808ac68425" translate="yes" xml:space="preserve">
          <source>The encoder callback interface is defined by the &lt;code&gt;megaco_encoder&lt;/code&gt; behaviour, see &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Интерфейс обратного вызова кодировщика определяется поведением &lt;code&gt;megaco_encoder&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e115c3caf0848d64461367ca5e16e6bd2197d5d0" translate="yes" xml:space="preserve">
          <source>The encoding fails if &lt;code&gt;p&lt;/code&gt; is not a valid string in encoding &lt;code&gt;from_enc&lt;/code&gt;.</source>
          <target state="translated">Кодировка не выполняется, если &lt;code&gt;p&lt;/code&gt; не является допустимой строкой в ​​кодировке &lt;code&gt;from_enc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09633aa618d0dc8af3be96ad739582e309ef108d" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">Кодировку имени &lt;code&gt;Filename&lt;/code&gt; можно задать с помощью комментария, как описано в &lt;code&gt;epp(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ac74f2d9e4b6b15103658ee4d9051874ee9e500" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment, as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">Кодировку имени &lt;code&gt;Filename&lt;/code&gt; можно задать с помощью комментария, как описано в &lt;code&gt;epp(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d77e867cd506d61a5b722d136e431c9f033298c" translate="yes" xml:space="preserve">
          <source>The encoding of each file can be specified using comments as described in the &lt;code&gt;epp(3)&lt;/code&gt; module.</source>
          <target state="translated">Кодировку каждого файла можно указать с помощью комментариев, как описано в модуле &lt;code&gt;epp(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04f41a4c6fb716f1b91e8ba50a1b730e2b5f3a4d" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (&lt;code&gt;ber&lt;/code&gt;), Packed Encoding Rules (&lt;code&gt;per&lt;/code&gt;) aligned, PER unaligned (&lt;code&gt;uper&lt;/code&gt;) and JSON Encoding Rules (&lt;code&gt;jer&lt;/code&gt;). The &lt;code&gt;jer&lt;/code&gt; option can be used by itself to generate a module that only supports encoding/decoding to JER or it can be used as a supplementary option to ber, per and uper. In the latter case a module with for both the main encoding rules and JER will be generated. The exported functions for JER will then be &lt;code&gt;jer_encode(Type, Value)&lt;/code&gt; and &lt;code&gt;jer_decode(Type, Bytes)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2118a8dc4b068a3e8e22ff922dd1be302891f7" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (BER), Packed Encoding Rules (PER) aligned, and PER unaligned. If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">Правило кодирования, которое будет использоваться. Поддерживаемые правила кодирования: базовые правила кодирования (BER), упакованные правила кодирования (PER), выровненные, и невыровненные PER. Если опция правила кодирования опущена, по умолчанию используется &lt;code&gt;ber&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f95e0e32837beadf0f93d78df4e27d5991fa179" translate="yes" xml:space="preserve">
          <source>The encoding specified by the above mentioned comment applies to the script itself. The encoding of the I/O-server, however, must be set explicitly as follows:</source>
          <target state="translated">Кодировка,указанная в вышеуказанном комментарии,относится к самому скрипту.Однако кодировка сервера ввода/вывода должна быть явно задана следующим образом:</target>
        </trans-unit>
        <trans-unit id="d1c828e598776df003c2646b5bcedb28e057c204" translate="yes" xml:space="preserve">
          <source>The encoding_config of the megaco_erl_dist_encoder module may be one of these:</source>
          <target state="translated">Кодировка_config модуля megaco_erl_dist_encoder может быть одной из них:</target>
        </trans-unit>
        <trans-unit id="97065c3a3729efa68679ce76351a30a9cd3dfa65" translate="yes" xml:space="preserve">
          <source>The encryption or decryption is applied to the generated stream of bytes prior to sending the resulting stream to the SFTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48fa03ddf781f161c43a06b94c0c75681b96550" translate="yes" xml:space="preserve">
          <source>The endianness specification can be either &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, or &lt;code&gt;native&lt;/code&gt;. Native-endian means that the endian is resolved at load time, to be either big-endian or little-endian, depending on what is &quot;native&quot; for the CPU that the Erlang machine is run on.</source>
          <target state="translated">Спецификация порядка байтов может быть &lt;code&gt;big&lt;/code&gt; , &lt;code&gt;little&lt;/code&gt; или &lt;code&gt;native&lt;/code&gt; . Native-endian означает, что endian разрешается во время загрузки, чтобы быть либо big-endian, либо little-endian, в зависимости от того, что является &amp;laquo;родным&amp;raquo; для ЦП, на котором работает машина Erlang.</target>
        </trans-unit>
        <trans-unit id="60e0f49d56e51cf1a5d46c013c216c0ae5dc1eb9" translate="yes" xml:space="preserve">
          <source>The entire contents of the cache will be deleted.</source>
          <target state="translated">Все содержимое кэша будет удалено.</target>
        </trans-unit>
        <trans-unit id="a01a496ea7149df2179e8879a105341306c0f911" translate="yes" xml:space="preserve">
          <source>The entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;, even when a list of objects is inserted.</source>
          <target state="translated">Вся операция гарантированно &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; , даже когда вставлен список объектов.</target>
        </trans-unit>
        <trans-unit id="e7a75cc762ec33088a0ac070865ceb613941ab44" translate="yes" xml:space="preserve">
          <source>The entire program is motorcycles2html.erl:</source>
          <target state="translated">Вся программа-это мотоциклы2html.erl:</target>
        </trans-unit>
        <trans-unit id="0ea59e660bb8e967761f1c651703a92fd998d941" translate="yes" xml:space="preserve">
          <source>The entire super carrier implementation is kept in erl_mmap.c. The name suggest that it can be viewed as our own mmap implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7e661e53cfa83634f92105a4582a374de077bb" translate="yes" xml:space="preserve">
          <source>The entire tar file is compressed, as if it has been run through the &lt;code&gt;gzip&lt;/code&gt; program. To abide to the convention that a compressed tar file is to end in &quot;&lt;code&gt;.tar.gz&lt;/code&gt;&quot; or &quot;&lt;code&gt;.tgz&lt;/code&gt;&quot;, add the appropriate extension.</source>
          <target state="translated">Весь tar-файл сжимается, как если бы он был запущен с помощью программы &lt;code&gt;gzip&lt;/code&gt; . Чтобы соответствовать соглашению о том, что сжатый файл tar должен заканчиваться на &amp;laquo; &lt;code&gt;.tar.gz&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;.tgz&lt;/code&gt; &amp;raquo;, добавьте соответствующее расширение.</target>
        </trans-unit>
        <trans-unit id="e1f58ced4a1c7fafa8f4a838e0a3347b18963414" translate="yes" xml:space="preserve">
          <source>The entities involved in this model are the agent, which terminates the management protocol, and the resources, which is to be managed, that is, the actual application entities. The resources should in general have no knowledge of the management protocol used, and the agent should have no knowledge of the managed resources. This implies that a translation mechanism is needed, to translate the management operations to operations on the resources. This translation mechanism is usually called &lt;strong&gt;instrumentation&lt;/strong&gt; and the function that implements it is called &lt;strong&gt;instrumentation function&lt;/strong&gt;. The instrumentation functions are written for each combination of management protocol and resource to be managed. For example, if an application is to be managed by SNMP and HTTP, two sets of instrumentation functions are defined; one that maps SNMP requests to the resources, and one that, for example, generates an HTML page for some resources.</source>
          <target state="translated">Сущностями, задействованными в этой модели, являются агент, завершающий протокол управления, и ресурсы, которыми необходимо управлять, то есть фактические сущности приложения. Ресурсы, как правило, не должны знать используемый протокол управления, а агент не должен знать об управляемых ресурсах. Это означает, что необходим механизм перевода, чтобы преобразовать операции управления в операции над ресурсами. Этот механизм трансляции обычно называется &lt;strong&gt;инструментарием,&lt;/strong&gt; а функция, которая его реализует, называется &lt;strong&gt;функцией инструментария.&lt;/strong&gt;, Функции инструментария написаны для каждой комбинации протокола управления и ресурса, которым нужно управлять. Например, если приложение должно управляться с помощью SNMP и HTTP, определены два набора инструментальных функций; один отображает запросы SNMP на ресурсы, а другой, например, генерирует HTML-страницу для некоторых ресурсов.</target>
        </trans-unit>
        <trans-unit id="fc41ee140a0e19b3389932dacfd061ee5abd2931" translate="yes" xml:space="preserve">
          <source>The entry format in all files are Erlang terms, separated by a '&lt;strong&gt;.&lt;/strong&gt;' and a &lt;strong&gt;newline&lt;/strong&gt;. In the following sections, the formats of these terms are described. Comments may be specified as ordinary Erlang comments.</source>
          <target state="translated">Формат ввода во всех файлах - это термины Erlang, разделенные знаком ' &lt;strong&gt;. &lt;/strong&gt;'и &lt;strong&gt;новую строку&lt;/strong&gt; . В следующих разделах описаны форматы этих условий. Комментарии могут быть указаны как обычные комментарии Erlang.</target>
        </trans-unit>
        <trans-unit id="cb54532373ef856c343b0b5dff86075c30ed3fbc" translate="yes" xml:space="preserve">
          <source>The entry point of the process, that is, what function was referenced in the &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt; call that started the process.</source>
          <target state="translated">Точка входа в процесс, то есть, какая функция была &lt;code&gt;spawn_link&lt;/code&gt; вызове &lt;code&gt;spawn&lt;/code&gt; или spawn_link , запустившем процесс.</target>
        </trans-unit>
        <trans-unit id="7f963220ca94e530caaeba1df441378f7d481672" translate="yes" xml:space="preserve">
          <source>The enumerated type is similar to an integer type, when defined with a set of predefined values. The difference is that an enumerated type can only have specified values, whereas an integer can have any value.</source>
          <target state="translated">Перечисленный тип аналогичен целочисленному типу,если он определен с набором предопределенных значений.Разница заключается в том,что перечисляемый тип может иметь только заданные значения,в то время как целое число может иметь любое значение.</target>
        </trans-unit>
        <trans-unit id="a3be6551e42e26d4ead34f786dcb51c0272efaf5" translate="yes" xml:space="preserve">
          <source>The environment can also affect filename interpretation, if Erlang is started with flag &lt;code&gt;+fna&lt;/code&gt; (which is default from Erlang/OTP 17.0).</source>
          <target state="translated">Среда также может влиять на интерпретацию имени файла, если Erlang запускается с флагом &lt;code&gt;+fna&lt;/code&gt; (который по умолчанию установлен в Erlang / OTP 17.0).</target>
        </trans-unit>
        <trans-unit id="913d6ab5c0934539b281e92b0bf02bbbfef5d5f9" translate="yes" xml:space="preserve">
          <source>The environment of an Erlang machine started as a service contains two special variables:</source>
          <target state="translated">Среда машины Erlang,запущенной как служба,содержит две специальные переменные:</target>
        </trans-unit>
        <trans-unit id="572b1efce0a6ff1c606a8d7cea991c683d1b2312" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must be &lt;code&gt;NULL&lt;/code&gt; only if calling from a created thread.</source>
          <target state="translated">Среда вызывающего процесса. Должен быть &lt;code&gt;NULL&lt;/code&gt; только при вызове из созданного потока.</target>
        </trans-unit>
        <trans-unit id="08711127236c0db559a0b4dc910c12dabe3750d5" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must not be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Среда вызывающего процесса. Не может быть &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="933ad549b39351dffb7bbbba0584672a0a00358b" translate="yes" xml:space="preserve">
          <source>The environment of the calling thread (&lt;code&gt;&lt;a href=&quot;#proc_bound_env&quot;&gt;process bound&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#callback_env&quot;&gt;callback&lt;/a&gt;&lt;/code&gt; environment) or &lt;code&gt;NULL&lt;/code&gt; if calling from a custom thread not spawned by ERTS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679199f710a5ea0668dae02978ff4e536ea45dcb" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt; enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd010a7cf9f07e2e5e5be6548225fb6c23b8fd6" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Среда термина сообщения. Может быть независимой от процесса средой, выделенной с помощью &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7b8c22351117abf032d5f79babc11a6b4db57f" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da50f98e6b47c2b008dfdf790cd4b0c2b6bf64d" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="translated">Среда термина сообщения. Должна быть независимая от процесса среда, выделенная с помощью &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; или NULL.</target>
        </trans-unit>
        <trans-unit id="2fa8fc26b6ef033d7a364376d908df5f6b781167" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; can be used to indicate which logical cluster a C-node belongs to.</source>
          <target state="translated">Переменная среды &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; может использоваться, чтобы указать, к какому логическому кластеру принадлежит C-узел.</target>
        </trans-unit>
        <trans-unit id="e087dc753b87601d38d03f83c1f1759586e203d5" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; can be used to configure the heart time-outs; it can be set in the operating system shell before Erlang is started or be specified at the command line:</source>
          <target state="translated">Переменная среды &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; может использоваться для настройки тайм-аутов сердечного ритма ; его можно установить в оболочке операционной системы до запуска Erlang или указать в командной строке:</target>
        </trans-unit>
        <trans-unit id="6dd0dd179f2f7ae89d1e41f5898aa9a98a1d1adc" translate="yes" xml:space="preserve">
          <source>The environment variables can also be used to detect that we are running as a service and make port programs react correctly to the control events generated on logout (see the next section).</source>
          <target state="translated">Переменные среды также могут быть использованы,чтобы определить,что мы работаем как служба и заставить программы порта корректно реагировать на управляющие события,генерируемые при выходе из системы (см.следующий раздел).</target>
        </trans-unit>
        <trans-unit id="0155a47d2e3d28b9149121cf101f2c0d304723b6" translate="yes" xml:space="preserve">
          <source>The erl scheme is designed to mimic plain CGI, but without the extra overhead. An URL that calls an Erlang &lt;code&gt;erl&lt;/code&gt; function has the following syntax (regular expression):</source>
          <target state="translated">Схема erl предназначена для имитации простого CGI, но без дополнительных накладных расходов. URL-адрес, вызывающий функцию Erlang &lt;code&gt;erl&lt;/code&gt; , имеет следующий синтаксис (регулярное выражение):</target>
        </trans-unit>
        <trans-unit id="9f146c11c8615922912cc793d4380f3827809366" translate="yes" xml:space="preserve">
          <source>The erlang connection process spawned by connect/2, will open a port to a c-process that handles the communication with the database through Microsoft's ODBC API. The erlang port will be kept open for exit signal propagation, if something goes wrong in the c-process and it exits we want know as mush as possible about the reason. The main communication with the c-process is done through sockets. The C-process consists of two threads, the supervisor thread and the database handler thread. The supervisor thread checks for shutdown messages on the supervisor socket and the database handler thread receives requests and sends answers on the database socket. If the database thread seems to hang on some database call, the erlang control process will send a shutdown message on the supervisor socket, in this case the c-process will exit. If the c-process crashes/exits it will bring the erlang-process down too and vice versa i.e. the connection is terminated.</source>
          <target state="translated">Процесс соединения erlang,порожденный connect/2,откроет порт для c-процесса,который обрабатывает связь с базой данных через ODBC API от Microsoft.Порт erlang будет оставаться открытым для распространения выходного сигнала,если что-то пойдет не так в c-процессе и он выйдет из него,мы хотим знать как можно больше о причине.Основная связь с c-процессом осуществляется через сокеты.C-процесс состоит из двух потоков:потока супервизора и потока обработчика базы данных.Поток супервизора проверяет сообщения о выключении на сокет супервизора,а поток обработчика базы данных получает запросы и посылает ответы на сокет базы данных.Если поток базы данных,кажется,зависает при каком-то вызове базы данных,то процесс управления erlang посылает сообщение о выключении на сокет супервизора,в этом случае c-процесс завершает работу.В случае сбоя/выхода c-процесса он приведет к завершению и erlang-процесса,и наоборот,т.е.соединение будет прервано.</target>
        </trans-unit>
        <trans-unit id="df7997d41de6ac2a1785cee171c352d42d04f93c" translate="yes" xml:space="preserve">
          <source>The error behavior differs, see below.</source>
          <target state="translated">Поведение ошибки отличается,см.ниже.</target>
        </trans-unit>
        <trans-unit id="011b09627444a05b2b15d34028f40a28dfdddfe0" translate="yes" xml:space="preserve">
          <source>The error descriptor defaults to &lt;code&gt;DefaultED&lt;/code&gt;, but can be overridden with an alternate one by returning &lt;code&gt;{reply,ED}&lt;/code&gt; or &lt;code&gt;{no_reply,ED}&lt;/code&gt; instead of &lt;code&gt;reply&lt;/code&gt; and &lt;code&gt;no_reply&lt;/code&gt; respectively.</source>
          <target state="translated">Дескриптор ошибки по умолчанию - &lt;code&gt;DefaultED&lt;/code&gt; , но может быть заменен другим, возвращая &lt;code&gt;{reply,ED}&lt;/code&gt; или &lt;code&gt;{no_reply,ED}&lt;/code&gt; вместо &lt;code&gt;reply&lt;/code&gt; и &lt;code&gt;no_reply&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="461fac531aaf141393d180babf97f72d93ada5dc" translate="yes" xml:space="preserve">
          <source>The error handling strategy and possible errors sources are described in the Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Стратегия обработки ошибок и возможные источники ошибок описаны в &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt; Erlang ODBC .</target>
        </trans-unit>
        <trans-unit id="5d405471c43706742d66ca4dd53edcd35e7ff6cb" translate="yes" xml:space="preserve">
          <source>The error information is handled by Logger, which is part of the Kernel application.</source>
          <target state="translated">Информация об ошибках обрабатывается Журналером,который является частью приложения Kernel.</target>
        </trans-unit>
        <trans-unit id="9eb4cd48329bca9a99f8dc4cb317a0559bc9784e" translate="yes" xml:space="preserve">
          <source>The error message will look like this:</source>
          <target state="translated">Сообщение об ошибке будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="3061a1ab3e6a1d434208df5bfeb44852fc476d18" translate="yes" xml:space="preserve">
          <source>The error report module is configured using the directive &lt;code&gt;error_report_mod&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Модуль отчета об ошибках настраивается с помощью директивы &lt;code&gt;error_report_mod&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69f328c65ecacb1785a10bfaee95a3f42966f16c" translate="yes" xml:space="preserve">
          <source>The error return in the Erlang client (The text as data type 1 and exit_status 255):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a00c6827ff6af3c91907db56029def4bf079b7" translate="yes" xml:space="preserve">
          <source>The errors and warnings are listed in the order in which they are encountered in the forms. The errors from one file can therefore be split into different entries in the list of errors.</source>
          <target state="translated">Ошибки и предупреждения перечислены в порядке,в котором они встречаются в формах.Поэтому ошибки из одного файла можно разделить на разные записи в списке ошибок.</target>
        </trans-unit>
        <trans-unit id="0e3460fc594164d8bbf96577fb24868bb714be37" translate="yes" xml:space="preserve">
          <source>The errors detected include:</source>
          <target state="translated">Обнаруженные ошибки включают в себя:</target>
        </trans-unit>
        <trans-unit id="b62e06cf6a78a94894293a2f2fefb7491e659ccc" translate="yes" xml:space="preserve">
          <source>The escape \o must be followed by a sequence of octal digits, enclosed in braces. An error occurs if this is not the case. This escape is a recent addition to Perl; it provides way of specifying character code points as octal numbers greater than 0777, and it also allows octal numbers and back references to be unambiguously specified.</source>
          <target state="translated">За выходом \o должна следовать последовательность восьмеричных цифр,заключенная в фигурные скобки.В противном случае возникает ошибка.Этот escape является недавним дополнением к Perl;он обеспечивает способ указания символьных кодовых точек как восьмеричных чисел больше 0777,а также позволяет однозначно указывать восьмеричные числа и обратные ссылки.</target>
        </trans-unit>
        <trans-unit id="e09cca6482e14cefd7789aca27e688d2b8fc2ae0" translate="yes" xml:space="preserve">
          <source>The escape sequence \K causes any previously matched characters not to be included in the final matched sequence. For example, the following pattern matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;:</source>
          <target state="translated">Экранирующая последовательность \K приводит к тому,что все ранее совпадающие символы не включаются в конечную совпадающую последовательность.Например,следующий образец совпадает с &quot;foobar&quot;,но сообщает,что он совпал с &quot;bar&quot;:</target>
        </trans-unit>
        <trans-unit id="1fdcd1532b972da832570c4e46f8a01588e3f319" translate="yes" xml:space="preserve">
          <source>The escape sequence \N behaves like a dot, except that it is not affected by option &lt;code&gt;PCRE_DOTALL&lt;/code&gt;. That is, it matches any character except one that signifies the end of a line. Perl also uses \N to match characters by name but PCRE does not support this.</source>
          <target state="translated">Управляющая последовательность \ N ведет себя как точка, за исключением того, что на нее не влияет параметр &lt;code&gt;PCRE_DOTALL&lt;/code&gt; . То есть он соответствует любому символу, кроме символа, обозначающего конец строки. Perl также использует \ N для сопоставления символов по имени, но PCRE не поддерживает это.</target>
        </trans-unit>
        <trans-unit id="9ac8458115fbc9af33358e4aea3bbde3c0be1319" translate="yes" xml:space="preserve">
          <source>The escape sequences allowed are the same as for Erlang strings:</source>
          <target state="translated">Допустимые последовательности эвакуации такие же,как и для струн Эрланга:</target>
        </trans-unit>
        <trans-unit id="32812c856e631f3ed1dcd90e3601c5c2b3077c8f" translate="yes" xml:space="preserve">
          <source>The eval scheme can seriously threaten the integrity of the Erlang node housing a web server, for example:</source>
          <target state="translated">Схема оценки может серьезно угрожать целостности узла Erlang,на котором расположен веб-сервер:</target>
        </trans-unit>
        <trans-unit id="21baa0e66c42986302a436c2cc18ea33ca352672" translate="yes" xml:space="preserve">
          <source>The eval scheme is straight-forward and does not mimic the behavior of plain CGI. An URL that calls an Erlang &lt;code&gt;eval&lt;/code&gt; function has the following syntax:</source>
          <target state="translated">Схема eval проста и не имитирует поведение простого CGI. URL-адрес, вызывающий функцию &lt;code&gt;eval&lt;/code&gt; в Erlang, имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="10a18f07017de460e02711d1cf0600325f33b7fb" translate="yes" xml:space="preserve">
          <source>The evaluation of the query fails if the &lt;code&gt;qlc&lt;/code&gt; module cannot carry out the chosen join method. Defaults to &lt;code&gt;any&lt;/code&gt;, which means that some fast join method is used if possible.</source>
          <target state="translated">Оценка запроса не выполняется, если модуль &lt;code&gt;qlc&lt;/code&gt; не может выполнить выбранный метод соединения. По умолчанию &lt;code&gt;any&lt;/code&gt; , что означает, что по возможности используется какой-либо метод быстрого соединения.</target>
        </trans-unit>
        <trans-unit id="fa8e9b7cfecc247f7bff705d3a3988485befc88c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed (user) type application expression.</source>
          <target state="translated">Оценка вызывает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет выражение приложения правильно сформированного (пользовательского) типа.</target>
        </trans-unit>
        <trans-unit id="4921b565820162e2c60edc6bea683451b957b890" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed &lt;code&gt;file&lt;/code&gt; attribute.</source>
          <target state="translated">Оценка вызывает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет атрибут &lt;code&gt;file&lt;/code&gt; правильно сформированного .</target>
        </trans-unit>
        <trans-unit id="618ce4cbe8b9ff30f535342ccae4d3cf10b313ea" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed application expression.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильно сформированное выражение приложения.</target>
        </trans-unit>
        <trans-unit id="dc7fabf51da4bb4e7f1257e9d4dede7a0e536748" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed export attribute.</source>
          <target state="translated">Оценка вызывает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильно сформированный атрибут экспорта.</target>
        </trans-unit>
        <trans-unit id="0f66579024f348d7bb0f390e794429a5be199446" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function definition.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильное определение функции.</target>
        </trans-unit>
        <trans-unit id="5406ed8fb8fc38e89372ce85d6f56374209215a4" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function name.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильное имя функции.</target>
        </trans-unit>
        <trans-unit id="30e8edf0d9aca5a1873eb5bed65e4d0bd6633e76" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed implicit fun.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильно сформированное неявное развлечение.</target>
        </trans-unit>
        <trans-unit id="9cbc54914d2a7b46a8529bdd08a5e3617825c157" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed import attribute.</source>
          <target state="translated">Оценка вызывает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильно сформированный атрибут импорта.</target>
        </trans-unit>
        <trans-unit id="1ce44851dc662379c8d2493f03d24234da3c175f" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed module attribute.</source>
          <target state="translated">Оценка вызывает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильно сформированный атрибут модуля.</target>
        </trans-unit>
        <trans-unit id="e9d8a2fbebf4113ef3337fce36bf9fbf369a6379" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record declaration attribute.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет атрибут объявления правильно сформированной записи.</target>
        </trans-unit>
        <trans-unit id="bf9e76769c09ba06d5b9bf9c1944e2acfb2dfc1a" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record field specifier.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет спецификатор поля записи правильно сформированный.</target>
        </trans-unit>
        <trans-unit id="ea05ee075bf7f2350e2fc6059b34cff5cb33b78c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed type name.</source>
          <target state="translated">Оценка вызывает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильное имя типа.</target>
        </trans-unit>
        <trans-unit id="363e188710c96a0d0d2f45cbb80bd88dddfe084d" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed wild attribute.</source>
          <target state="translated">Оценка вызывает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; не представляет правильно сформированный атрибут wild.</target>
        </trans-unit>
        <trans-unit id="223a63e0ec00c2810aadc750354eca2f59b6acb8" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not well-formed.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; имеет неправильный формат .</target>
        </trans-unit>
        <trans-unit id="527c092490ea3417d05959de64ac4673c4e2242c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; represents a record expression that is not well-formed.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; , если &lt;code&gt;Node&lt;/code&gt; представляет некорректное выражение записи.</target>
        </trans-unit>
        <trans-unit id="78caee1b9d51c269ecfa277516c192bac800da86" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if an ill-formed Erlang construct is encountered.</source>
          <target state="translated">Оценка выдает &lt;code&gt;syntax_error&lt;/code&gt; если встречается неправильно сформированная конструкция Erlang.</target>
        </trans-unit>
        <trans-unit id="e360281a65b675290b77c855abb3396feae48026" translate="yes" xml:space="preserve">
          <source>The event &lt;code&gt;user_unblock&lt;/code&gt; is not triggered when a user is removed from the block list explicitly using the &lt;code&gt;unblock_user&lt;/code&gt; function.</source>
          <target state="translated">Событие &lt;code&gt;user_unblock&lt;/code&gt; не запускается, когда пользователь удаляется из списка блокировки явным образом с &lt;code&gt;unblock_user&lt;/code&gt; функции unblock_user .</target>
        </trans-unit>
        <trans-unit id="e9adf6f3e6bc9d678bcfcbf56c75783efdc79bfe" translate="yes" xml:space="preserve">
          <source>The event handler must be able to handle the events in this module, see section &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обработчик событий должен иметь возможность обрабатывать события в этом модуле, см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07fadfa5cd3629d9138971bd824a14ddd43b2990" translate="yes" xml:space="preserve">
          <source>The event handler return values are defined in the description of &lt;code&gt;Module:StateName/3&lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="translated">Возвращаемые значения обработчика событий определены в описании &lt;code&gt;Module:StateName/3&lt;/code&gt; на &lt;code&gt;gen_statem&lt;/code&gt; руководства gen_statem , но вот более читаемый список:</target>
        </trans-unit>
        <trans-unit id="9b5aab32f54b078cb1c0faaf00cf7eb4a19eec31" translate="yes" xml:space="preserve">
          <source>The event handler terminates abnormally and &lt;code&gt;gen_event&lt;/code&gt; logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">Обработчик событий аварийно завершает работу, и &lt;code&gt;gen_event&lt;/code&gt; регистрирует ошибку. &lt;code&gt;Opt&lt;/code&gt; устанавливается на атом &lt;code&gt;terminate&lt;/code&gt; для этого случая.</target>
        </trans-unit>
        <trans-unit id="f7f89716df5f45b5490450ec2ac15b0b43b462e0" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler.</source>
          <target state="translated">Событие обрабатывается обработчиком журнала по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2545cd2dda316056d2647ebcf0c0876379df39a7" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler. The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Событие обрабатывается обработчиком Logger по умолчанию. Уровень журнала можно изменить на ошибку или информацию, см. &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="836db6626acc8d2b63d4479e731dd11320410d43" translate="yes" xml:space="preserve">
          <source>The event is handled by:</source>
          <target state="translated">Событием занимается:</target>
        </trans-unit>
        <trans-unit id="670f3a97ec79b1617d1253c86abd242fbfe96cb8" translate="yes" xml:space="preserve">
          <source>The event is made into a message and sent to the event manager. When the event is received, the event manager calls &lt;code&gt;handle_event(Event, State)&lt;/code&gt; for each installed event handler, in the same order as they were added. The function is expected to return a tuple &lt;code&gt;{ok,State1}&lt;/code&gt;, where &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the event handler.</source>
          <target state="translated">Событие оформляется в виде сообщения и отправляется диспетчеру событий. Когда событие получено, диспетчер событий вызывает &lt;code&gt;handle_event(Event, State)&lt;/code&gt; для каждого установленного обработчика событий в том же порядке, в котором они были добавлены. Ожидается, что функция вернет кортеж &lt;code&gt;{ok,State1}&lt;/code&gt; , где &lt;code&gt;State1&lt;/code&gt; - новое значение для состояния обработчика событий.</target>
        </trans-unit>
        <trans-unit id="b73ba2f2d96d9d903429f26f68141cab3925fb1c" translate="yes" xml:space="preserve">
          <source>The event is sent to the &lt;code&gt;gen_statem&lt;/code&gt;. When the event is received, the &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt;, or &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt;. &lt;code&gt;StateName&lt;/code&gt; is the name of the current state and &lt;code&gt;NewStateName&lt;/code&gt; is the name of the next state to go to. &lt;code&gt;NewData&lt;/code&gt; is a new value for the server data of the &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;Actions&lt;/code&gt; is a list of actions to be performed by the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">Событие отправляется в &lt;code&gt;gen_statem&lt;/code&gt; . Когда событие получено, &lt;code&gt;gen_statem&lt;/code&gt; вызывает &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt; , который, как ожидается, вернет кортеж &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt; или &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt; . &lt;code&gt;StateName&lt;/code&gt; - это имя текущего состояния, а &lt;code&gt;NewStateName&lt;/code&gt; - это имя следующего состояния, в которое нужно перейти. &lt;code&gt;NewData&lt;/code&gt; - это новое значение для данных сервера &lt;code&gt;gen_statem&lt;/code&gt; , а &lt;code&gt;Actions&lt;/code&gt; - это список действий, которые должен выполнить &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd753f364308c6d8a412367394b65eb5bb6c7da" translate="yes" xml:space="preserve">
          <source>The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt; Module:handle_call/2&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482c8d79933fe33bda06c58901ec825b1db485ea" translate="yes" xml:space="preserve">
          <source>The event manager essentially maintains a list of &lt;code&gt;{Module, State}&lt;/code&gt; pairs, where each &lt;code&gt;Module&lt;/code&gt; is an event handler, and &lt;code&gt;State&lt;/code&gt; is the internal state of that event handler.</source>
          <target state="translated">Диспетчер событий по существу поддерживает список пар &lt;code&gt;{Module, State}&lt;/code&gt; , где каждый &lt;code&gt;Module&lt;/code&gt; является обработчиком событий, а &lt;code&gt;State&lt;/code&gt; - внутренним состоянием этого обработчика событий.</target>
        </trans-unit>
        <trans-unit id="76d57c410515c44cc8bc28a8d09b64ef1f2639aa" translate="yes" xml:space="preserve">
          <source>The event manager terminates if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is &lt;strong&gt;not&lt;/strong&gt; part of a supervision tree, it terminates if it receives an &lt;code&gt;'EXIT'&lt;/code&gt; message from its parent.</source>
          <target state="translated">Диспетчер событий завершает свою работу, если он является частью дерева надзора и его супервизор приказывает завершить работу. Даже если он &lt;strong&gt;не&lt;/strong&gt; является частью дерева надзора, он завершает свою работу, если получает сообщение &lt;code&gt;'EXIT'&lt;/code&gt; от своего родителя.</target>
        </trans-unit>
        <trans-unit id="c2ce4c38c0aa823b9e5e74e4d8bcd2d1c4f1111f" translate="yes" xml:space="preserve">
          <source>The event tracer framework is made up of four modules:</source>
          <target state="translated">Фреймворк трассировщика событий состоит из четырех модулей:</target>
        </trans-unit>
        <trans-unit id="d0f7cae16de84ad2c9c39b99cb4c031af931d1d5" translate="yes" xml:space="preserve">
          <source>The event types are described in the next sections.</source>
          <target state="translated">Типы событий описаны в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="f1782c63eb3688ca0c9af0612dd19da36a393122" translate="yes" xml:space="preserve">
          <source>The events are also documented in &lt;code&gt;ct_event.erl&lt;/code&gt;. This module can serve as an example of what an event handler for the &lt;code&gt;Common Test&lt;/code&gt; event manager can look like.</source>
          <target state="translated">События также задокументированы в &lt;code&gt;ct_event.erl&lt;/code&gt; . Этот модуль может служить примером того, как может выглядеть обработчик событий для диспетчера событий &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c24f138a33faf79d167906d2c594eb6f61632b5" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt; handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa54bda16841cabde0c2e6fc00114e179e4c8c7f" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">События форматируются с помощью функции, которая определяется процессом, &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt; событие (с вызовом handle_debug / 4) .</target>
        </trans-unit>
        <trans-unit id="ed5fedd80749f48dc22eb2ae97b4b16538b4c269" translate="yes" xml:space="preserve">
          <source>The exact error message depends on the actual callback module. The Error message makes the connection to fail, and is returned from e.g ssh:connect/3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa1279652840651c701347ac0d11ff90fe9b0b8" translate="yes" xml:space="preserve">
          <source>The exact set of options and there syntax &lt;strong&gt;may&lt;/strong&gt; be changed without prior notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d4c6263423994284ba2b9c6d7623abbea04412" translate="yes" xml:space="preserve">
          <source>The example &lt;code&gt;Subject&lt;/code&gt; field has one C, two CN and one O part. It is only the CN (Common Name) that is used by hostname verification. The two other (C and O) is not used here even when they contain a domain name like the O part. The C and O parts are defined elsewhere and meaningful only for other functions.</source>
          <target state="translated">Пример &lt;code&gt;Subject&lt;/code&gt; поле имеет один, два C CN и одну O части. Только CN (общее имя) используется для проверки имени хоста. Два других (C и O) здесь не используются, даже если они содержат доменное имя, такое как часть O. Части C и O определены в другом месте и имеют значение только для других функций.</target>
        </trans-unit>
        <trans-unit id="53789d2e92c1fda46d0fae07ec08f87e98bdd01d" translate="yes" xml:space="preserve">
          <source>The example I/O server stores characters in an ETS table, making up a fairly crude RAM file.</source>
          <target state="translated">Пример сервера ввода/вывода хранит символы в таблице ETS,составляя довольно грубый файл оперативной памяти.</target>
        </trans-unit>
        <trans-unit id="3a18dec0331c54c7d131f7f05a54cda624c44be5" translate="yes" xml:space="preserve">
          <source>The example below sets up trace on the exported functions (default) of module &lt;code&gt;snmp_generic&lt;/code&gt; and all functions of module &lt;code&gt;snmp_generic_mnesia&lt;/code&gt;. With return values (which is default) and timestamps in both cases (which is also default):</source>
          <target state="translated">В приведенном ниже примере выполняется трассировка экспортируемых функций (по умолчанию) модуля &lt;code&gt;snmp_generic&lt;/code&gt; и всех функций модуля &lt;code&gt;snmp_generic_mnesia&lt;/code&gt; . С возвращаемыми значениями (что по умолчанию) и отметками времени в обоих случаях (что также по умолчанию):</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
