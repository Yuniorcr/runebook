<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="7ba69074df191132a5aee72b7de68af231ccb23b" translate="yes" xml:space="preserve">
          <source>A fun is a functional object. Funs make it possible to create an anonymous function and pass the function itself -- not its name -- as argument to other functions.</source>
          <target state="translated">Веселье-это функциональный объект.Веселье позволяет создать анонимную функцию и передать саму функцию,а не ее имя,в качестве аргумента другим функциям.</target>
        </trans-unit>
        <trans-unit id="a83e179e2a0b967f058ad516cb4229a827e95fd9" translate="yes" xml:space="preserve">
          <source>A fun is applied to the wrong number of arguments. &lt;code&gt;F&lt;/code&gt; describes the fun and the arguments.</source>
          <target state="translated">Забава применяется к неправильному количеству аргументов. &lt;code&gt;F&lt;/code&gt; описывает развлечения и аргументы.</target>
        </trans-unit>
        <trans-unit id="331ce727ff0b82a2baa3eca467f7f047acb2688e" translate="yes" xml:space="preserve">
          <source>A fun refers into a fun table, which also consumes memory.</source>
          <target state="translated">Веселье относится к веселью,которое также потребляет память.</target>
        </trans-unit>
        <trans-unit id="4fc6c3b004a9c28596e264b75abedbe106e6b063" translate="yes" xml:space="preserve">
          <source>A fun that takes the socket info and returns a &lt;code&gt;boolean()&lt;/code&gt; (&lt;code&gt;true&lt;/code&gt; if the socket sould be included and &lt;code&gt;false&lt;/code&gt; if should not).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25c37b8117f77137d7a7610d86f37adc3dd7d32" translate="yes" xml:space="preserve">
          <source>A fun which converts a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report() &lt;/a&gt;&lt;/code&gt; to a format string and arguments, or directly to a string. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917f02c1a076a8a47ebb3722785173da993cb101" translate="yes" xml:space="preserve">
          <source>A fun with the following signature:</source>
          <target state="translated">Забава со следующей подписью:</target>
        </trans-unit>
        <trans-unit id="9c0db4550739af00d32b0dfa12f09adabde22929" translate="yes" xml:space="preserve">
          <source>A function (&lt;code&gt;fun/0&lt;/code&gt; or &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) tuple) can be specified as timetrap value in the suite-, group- and test case information function, and as argument to function &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция ( &lt;code&gt;fun/0&lt;/code&gt; или &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) кортеж) может быть указана как значение timetrap в функции информации набора, группы и тестового примера, а также как аргумент функции &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a3cf7ceca0e362fe2af257283edf78084fc160" translate="yes" xml:space="preserve">
          <source>A function breakpoint is a set of line breakpoints, one at the first line of each clause in the specified function.</source>
          <target state="translated">Точка останова функции-это набор точек останова линии,по одной в первой строке каждого пункта в указанной функции.</target>
        </trans-unit>
        <trans-unit id="5f0fd871bd70c7514030529afb1f484443906fd8" translate="yes" xml:space="preserve">
          <source>A function can have many arguments. Let us expand the module &lt;code&gt;tut1&lt;/code&gt; with the function to multiply two numbers:</source>
          <target state="translated">У функции может быть много аргументов. Давайте расширим модуль &lt;code&gt;tut1&lt;/code&gt; функцией умножения двух чисел:</target>
        </trans-unit>
        <trans-unit id="fede52edfc71f21c837f79f6a8e9fb78f0248b2b" translate="yes" xml:space="preserve">
          <source>A function compliant with these functions. For details, see the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page.</source>
          <target state="translated">Функция, совместимая с этими функциями. Подробности см. На странице руководства &lt;code&gt;supervisor(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f617733f33e20e330ebc8aa6d33e7c36f5c2a1" translate="yes" xml:space="preserve">
          <source>A function constraint Fc is a non-empty sequence of constraints &lt;code&gt;C_1, ..., C_k&lt;/code&gt;, and Rep(Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt;.</source>
          <target state="translated">Функциональное ограничение Fc представляет собой непустую последовательность ограничений &lt;code&gt;C_1, ..., C_k&lt;/code&gt; и Rep (Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dfcd76722f3584d620315b3cb799ba807ca502f" translate="yes" xml:space="preserve">
          <source>A function for an exclusive decode, whose name the user decides in the configuration file</source>
          <target state="translated">Функция эксклюзивного декодирования,имя которой пользователь определяет в конфигурационном файле</target>
        </trans-unit>
        <trans-unit id="be3487c9bce760681de79e5934bed4a4861cc982" translate="yes" xml:space="preserve">
          <source>A function in a test suite that is meant to be used for setting up, cleaning up, and/or verifying the state and environment on the System Under Test (SUT) and/or the &lt;code&gt;Common Test&lt;/code&gt; host node, so that a test case (or a set of test cases) can execute correctly.</source>
          <target state="translated">Функция в наборе тестов, которая предназначена для использования для настройки, очистки и / или проверки состояния и среды в тестируемой системе (SUT) и / или узле хоста &lt;code&gt;Common Test&lt;/code&gt; , чтобы тестовый пример ( или набор тестовых примеров) может выполняться правильно.</target>
        </trans-unit>
        <trans-unit id="8a453d0634dfbb426f81f44cc7d5fb202b518059" translate="yes" xml:space="preserve">
          <source>A function in a test suite that returns a list of properties (read by the &lt;code&gt;Common Test&lt;/code&gt; server) that describes the conditions for executing the test cases in the suite.</source>
          <target state="translated">Функция в наборе тестов, которая возвращает список свойств (считанных сервером &lt;code&gt;Common Test&lt;/code&gt; ), который описывает условия для выполнения тестовых случаев в наборе.</target>
        </trans-unit>
        <trans-unit id="bee93e2fd141ac952df7640f626d3d10f1e92fbd" translate="yes" xml:space="preserve">
          <source>A function in the &lt;code&gt;proc_lib&lt;/code&gt; module is to be used to start the process. Several functions are available, for example, &lt;code&gt;spawn_link/3,4&lt;/code&gt; for asynchronous start and &lt;code&gt;start_link/3,4,5&lt;/code&gt; for synchronous start.</source>
          <target state="translated">Функция в модуле &lt;code&gt;proc_lib&lt;/code&gt; должна использоваться для запуска процесса. Доступно несколько функций, например, &lt;code&gt;spawn_link/3,4&lt;/code&gt; для асинхронного запуска и &lt;code&gt;start_link/3,4,5&lt;/code&gt; для синхронного запуска.</target>
        </trans-unit>
        <trans-unit id="1ea8125453a1f5033d8778318612575164d3d3ce" translate="yes" xml:space="preserve">
          <source>A function is called using the &lt;code&gt;M:F&lt;/code&gt; syntax, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are atoms or expressions.</source>
          <target state="translated">Функция вызывается с использованием синтаксиса &lt;code&gt;M:F&lt;/code&gt; , где &lt;code&gt;M&lt;/code&gt; и &lt;code&gt;F&lt;/code&gt; - атомы или выражения.</target>
        </trans-unit>
        <trans-unit id="f874e0a252012bc547a3211dd48e03d0c6554317" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;f&lt;/code&gt; in the module &lt;code&gt;m&lt;/code&gt; and with arity &lt;code&gt;N&lt;/code&gt; is often denoted as &lt;code&gt;m:f/N&lt;/code&gt;.</source>
          <target state="translated">Функция с именем &lt;code&gt;f&lt;/code&gt; в модуле &lt;code&gt;m&lt;/code&gt; и валентности &lt;code&gt;N&lt;/code&gt; часто обозначается как &lt;code&gt;m:f/N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e2076ece482295f13f43d68037c1f2992b8f9a" translate="yes" xml:space="preserve">
          <source>A function not explicitly documented as thread-safe can, at some point in time, have a thread-safe implementation in the runtime system. Such an implementation can however change to a thread &lt;strong&gt;unsafe&lt;/strong&gt; implementation at any time &lt;strong&gt;without any notice&lt;/strong&gt;.</source>
          <target state="translated">Функция, явно не задокументированная как потокобезопасная, может в какой-то момент иметь поточно-ориентированную реализацию в системе времени выполнения. Однако такая реализация может измениться на &lt;strong&gt;небезопасную&lt;/strong&gt; для потока реализацию в любое время &lt;strong&gt;без какого-либо уведомления&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ad55a8c4f2fdc2e2ad52ed3c0264567f558d6c9a" translate="yes" xml:space="preserve">
          <source>A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, and the reply is returned as value of the current call to the sort or merge function.</source>
          <target state="translated">В качестве вывода может быть указана функция одного аргумента. Результаты сортировки или объединения входных данных собираются в непустую последовательность списков переменной длины двоичных файлов или терминов в зависимости от формата. Функция вывода вызывается с одним списком за раз, и предполагается, что она возвращает новую функцию вывода. Любое другое возвращаемое значение немедленно возвращается как значение текущего вызова функции сортировки или слияния. Каждая функция вывода вызывается ровно один раз. Когда какая-либо функция вывода была применена ко всем результатам или возникает ошибка, последняя функция вызывается с аргументом &lt;code&gt;close&lt;/code&gt; , и ответ возвращается как значение текущего вызова функции сортировки или слияния.</target>
        </trans-unit>
        <trans-unit id="59fe57d80e3ef9db4ebd49c663824a7be50c8252" translate="yes" xml:space="preserve">
          <source>A function specification can be overloaded. That is, it can have several types, separated by a semicolon (&lt;code&gt;;&lt;/code&gt;):</source>
          <target state="translated">Спецификация функции может быть перегружена. То есть он может иметь несколько типов, разделенных точкой с запятой ( &lt;code&gt;;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="fa95908fabb759c7e5694e79bc74d7fa4cb9cab8" translate="yes" xml:space="preserve">
          <source>A function that adds a family to the database can be written as follows if there is a structure &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt;:</source>
          <target state="translated">Функцию, которая добавляет семью в базу данных, можно записать следующим образом, если есть структура &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd3a3a3eaa7687c88a4600f70861728b853757b4" translate="yes" xml:space="preserve">
          <source>A function that is intended to be traced.</source>
          <target state="translated">Функция,которая предназначена для отслеживания.</target>
        </trans-unit>
        <trans-unit id="84f14d74551f2c944f4c5fc40a31a1120c5642d9" translate="yes" xml:space="preserve">
          <source>A function type Ft is one of the following:</source>
          <target state="translated">Тип функции Ft является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="f2ed1d7e05b7d9f3e384891d361b5e9e23e3a041" translate="yes" xml:space="preserve">
          <source>A function which has been called with &lt;code&gt;is_set_ok&lt;/code&gt; will be called again, either with &lt;code&gt;set&lt;/code&gt; if there was no error, or with &lt;code&gt;undo&lt;/code&gt;, if an error occurred. In this way, resources can be reserved in the &lt;code&gt;is_set_ok&lt;/code&gt; operation, released in the &lt;code&gt;undo&lt;/code&gt; operation, or made permanent in the &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">Функция, которая была вызвана с &lt;code&gt;is_set_ok&lt;/code&gt; , будет вызвана снова, либо с &lt;code&gt;set&lt;/code&gt; , если ошибки не было, либо с &lt;code&gt;undo&lt;/code&gt; , если ошибка произошла. Таким образом, ресурсы могут быть зарезервированы в операции &lt;code&gt;is_set_ok&lt;/code&gt; , освобождены в операции &lt;code&gt;undo&lt;/code&gt; или сделаны постоянными в операции &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd8be8e88421b65c5785dda3b74a299c4437c971" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test()&lt;/code&gt; is recognized by EUnit as a simple test function - it takes no arguments, and its execution either succeeds (returning some arbitrary value that EUnit will throw away), or fails by throwing an exception of some kind (or by not terminating, in which case it will be aborted after a while).</source>
          <target state="translated">Функция с именем, заканчивающимся на &lt;code&gt;..._test()&lt;/code&gt; , распознается EUnit как простая тестовая функция - она ​​не принимает аргументов, и ее выполнение либо завершается успешно (возвращает какое-то произвольное значение, которое EUnit отбрасывает), либо завершается ошибкой, бросая исключение какого-либо вида (или невыполнение, в этом случае оно будет прервано через некоторое время).</target>
        </trans-unit>
        <trans-unit id="6cb5bb4750e96bdf1cb4a018b0ae8f0c42348f8c" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test_()&lt;/code&gt; (note the final underscore) is recognized by EUnit as a &lt;strong&gt;test generator&lt;/strong&gt; function. Test generators return a &lt;strong&gt;representation&lt;/strong&gt; of a &lt;strong&gt;set of tests&lt;/strong&gt; to be executed by EUnit.</source>
          <target state="translated">Функция с именем, оканчивающимся на &lt;code&gt;..._test_()&lt;/code&gt; (обратите внимание на последнее подчеркивание), распознается EUnit как функция &lt;strong&gt;генератора тестов&lt;/strong&gt; . Испытательные генераторы возвращают &lt;strong&gt;представление&lt;/strong&gt; о &lt;strong&gt;наборе тестов&lt;/strong&gt; , которые будут выполняться EUnit.</target>
        </trans-unit>
        <trans-unit id="1a48507b735622ceff0ef19da321ab8f330d7565" translate="yes" xml:space="preserve">
          <source>A functional interface to system messages.</source>
          <target state="translated">Функциональный интерфейс к системным сообщениям.</target>
        </trans-unit>
        <trans-unit id="5718538818085276e24476684d081fe2c16ac1e8" translate="yes" xml:space="preserve">
          <source>A functional object (fun) is called.</source>
          <target state="translated">Называется функциональный объект (веселье).</target>
        </trans-unit>
        <trans-unit id="a77ae01d0047b90d93e3127e8ab05f3c2f271265" translate="yes" xml:space="preserve">
          <source>A functional, extendible array. The representation is not documented and is subject to change without notice. Notice that arrays cannot be directly compared for equality.</source>
          <target state="translated">Функциональный,расширяемый массив.Представление не документировано и может быть изменено без предварительного уведомления.Обратите внимание,что массивы нельзя напрямую сравнивать для равенства.</target>
        </trans-unit>
        <trans-unit id="e1e00f7b7a96013a7ac2150829df3b65546f70ca" translate="yes" xml:space="preserve">
          <source>A general address format on the form &lt;code&gt;{Family, Destination}&lt;/code&gt; where &lt;code&gt;Family&lt;/code&gt; is an atom such as &lt;code&gt;local&lt;/code&gt; and the format of &lt;code&gt;Destination&lt;/code&gt; depends on &lt;code&gt;Family&lt;/code&gt;, and is a complete address (for example an IP address including port number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ada27e365cb4a22611cb6a9989b7fa6327cde2" translate="yes" xml:space="preserve">
          <source>A general balanced set iterator.</source>
          <target state="translated">Общий сбалансированный итератор.</target>
        </trans-unit>
        <trans-unit id="abd2d7ccb70af9192a88e9078363ed031f3357e6" translate="yes" xml:space="preserve">
          <source>A general balanced set.</source>
          <target state="translated">Общий сбалансированный набор.</target>
        </trans-unit>
        <trans-unit id="8cf5f3092481aa2537de6a0b5a55a3c05a0431e5" translate="yes" xml:space="preserve">
          <source>A general balanced tree iterator.</source>
          <target state="translated">Общий уравновешенный итератор деревьев.</target>
        </trans-unit>
        <trans-unit id="9983fa582405ead1dae547bcbe84a7f86c9c2c6a" translate="yes" xml:space="preserve">
          <source>A general balanced tree.</source>
          <target state="translated">Общее сбалансированное дерево.</target>
        </trans-unit>
        <trans-unit id="ef9ed8ddc12844f0870bb4f089487a9445710baf" translate="yes" xml:space="preserve">
          <source>A general function for creating Erlang terms using a format specifier and a corresponding set of arguments, much in the way &lt;code&gt;printf()&lt;/code&gt; works.</source>
          <target state="translated">Общая функция для создания терминов Erlang с использованием спецификатора формата и соответствующего набора аргументов, во многом &lt;code&gt;printf()&lt;/code&gt; принципу работы printf () .</target>
        </trans-unit>
        <trans-unit id="2e207a92b9beca5dbcb01f63b66742b4b78e66b3" translate="yes" xml:space="preserve">
          <source>A general function for retrieving any kind of object from the registry.</source>
          <target state="translated">Общая функция для получения любого типа объектов из реестра.</target>
        </trans-unit>
        <trans-unit id="59cb7a53195dd959efa385b2b1d8e6b04a5e665a" translate="yes" xml:space="preserve">
          <source>A generated error is when the code itself calls &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;throw/1&lt;/code&gt;. Notice that emulated run-time errors are not denoted as generated errors here.</source>
          <target state="translated">Сгенерированная ошибка возникает, когда сам код вызывает &lt;code&gt;exit/1&lt;/code&gt; или &lt;code&gt;throw/1&lt;/code&gt; . Обратите внимание, что эмулируемые ошибки времени выполнения здесь не обозначаются как сгенерированные ошибки.</target>
        </trans-unit>
        <trans-unit id="8faf45d14b7e5fe4683d094888fbeeed4fc63af0" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library.</source>
          <target state="translated">Общая симпатичная библиотека принтеров.</target>
        </trans-unit>
        <trans-unit id="96309c20b89273ad4e96e038b104fd007caed27f" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library. This module uses a strict-style context passing implementation of John Hughes algorithm, described in &quot;The design of a Pretty-printing Library&quot;. The paragraph-style formatting, empty documents, floating documents, and null strings are my own additions to the algorithm.</source>
          <target state="translated">Общая симпатичная библиотека принтеров.В этом модуле используется реализация алгоритма Джона Хьюза,описанного в &quot;Дизайн библиотеки красивых принтеров&quot;,в строгом стиле.Форматирование в стиле абзаца,пустые документы,плавающие документы и нулевые строки-это мои собственные дополнения к алгоритму.</target>
        </trans-unit>
        <trans-unit id="ac6a4400b941cc8bdd539f01f5213eda72cb86dc" translate="yes" xml:space="preserve">
          <source>A generic single object compare-and-swap operation:</source>
          <target state="translated">Общая операция сравнения и замены одного объекта:</target>
        </trans-unit>
        <trans-unit id="3f766bd2ae406c1622999afa0312a1512bd99928" translate="yes" xml:space="preserve">
          <source>A generic state machine process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">Общий процесс &lt;code&gt;gen_statem&lt;/code&gt; автомата ( gen_statem ), реализованный с помощью этого модуля, имеет стандартный набор интерфейсных функций и включает в себя функции для отслеживания и сообщения об ошибках. Он также вписывается в дерево контроля OTP. Для получения дополнительной информации см. &lt;code&gt;OTP Design Principles&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17deb413c89fd01affc6582636308eea7c33a228" translate="yes" xml:space="preserve">
          <source>A generic state machine server process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97b266d23ce2fe3a69cfab0ece23a4c06694585" translate="yes" xml:space="preserve">
          <source>A global group defined with &lt;code&gt;PublishType&lt;/code&gt; equal to &lt;code&gt;hidden&lt;/code&gt; is said to be a hidden global group. All nodes in a hidden global group are hidden nodes, whether they are started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; or not.</source>
          <target state="translated">Глобальная группа, определенная с &lt;code&gt;PublishType&lt;/code&gt; , равным &lt;code&gt;hidden&lt;/code&gt; , называется скрытой глобальной группой. Все узлы в скрытой глобальной группе являются скрытыми узлами, независимо от того, запущены они с флагом командной строки &lt;code&gt;-hidden&lt;/code&gt; или нет.</target>
        </trans-unit>
        <trans-unit id="be16c14a618ebfab9ed6b6a24231e3d1ce85555b" translate="yes" xml:space="preserve">
          <source>A global name registration facility.</source>
          <target state="translated">Глобальный центр регистрации имен.</target>
        </trans-unit>
        <trans-unit id="5ca996b1105de3e2c7c27a0f7cfb576400f98429" translate="yes" xml:space="preserve">
          <source>A global trace flag for the Erlang node that makes all trace time stamps using flag &lt;code&gt;timestamp&lt;/code&gt; to be in CPU time, not wall clock time. That is, &lt;code&gt;cpu_timestamp&lt;/code&gt; is not be used if &lt;code&gt;monotonic_timestamp&lt;/code&gt; or &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; is enabled. Only allowed with &lt;code&gt;PidPortSpec==all&lt;/code&gt;. If the host machine OS does not support high-resolution CPU time measurements, &lt;code&gt;trace/3&lt;/code&gt; exits with &lt;code&gt;badarg&lt;/code&gt;. Notice that most OS do not synchronize this value across cores, so be prepared that time can seem to go backwards when using this option.</source>
          <target state="translated">Флаг глобальной трассировки для узла Erlang, который делает все метки времени трассировки, используя &lt;code&gt;timestamp&lt;/code&gt; флага, во времени процессора, а не времени настенных часов. То есть, &lt;code&gt;cpu_timestamp&lt;/code&gt; не будет использоваться , если &lt;code&gt;monotonic_timestamp&lt;/code&gt; или &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; включена. Разрешено только с &lt;code&gt;PidPortSpec==all&lt;/code&gt; . Если ОС хост-машины не поддерживает измерения времени ЦП с высоким разрешением, &lt;code&gt;trace/3&lt;/code&gt; завершается с помощью &lt;code&gt;badarg&lt;/code&gt; . Обратите внимание, что большинство ОС не синхронизируют это значение между ядрами, поэтому будьте готовы к тому, что при использовании этой опции время может идти в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="a35f6209ff3e97a1fbff24a3ba0f5b7de01c5979" translate="yes" xml:space="preserve">
          <source>A good book explaining those reference texts is Dubuisson: ASN.1 - Communication Between Heterogeneous Systems, is free to download at &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Хорошая книга, объясняющая эти справочные тексты, - это Дубюиссон: ASN.1 - Связь между гетерогенными системами, которую можно бесплатно загрузить с &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb427e2a68f8e5f95a66a1dfb82ade3b982ce6f" translate="yes" xml:space="preserve">
          <source>A good start when programming efficiently is to know how much memory different data types and operations require. It is implementation-dependent how much memory the Erlang data types and other items consume, but the following table shows some figures for the &lt;code&gt;erts-8.0&lt;/code&gt; system in OTP 19.0.</source>
          <target state="translated">Хорошее начало для эффективного программирования - это знать, сколько памяти требуется для различных типов данных и операций. &lt;code&gt;erts-8.0&lt;/code&gt; памяти, потребляемой типами данных Erlang и другими элементами, зависит от реализации, но в следующей таблице показаны некоторые цифры для системы erts-8.0 в OTP 19.0.</target>
        </trans-unit>
        <trans-unit id="104d4b7a2a11dda4f50138a2b0c530944556b6b2" translate="yes" xml:space="preserve">
          <source>A good way to check if more IO poll threads are needed is to use &lt;code&gt;microstate accounting&lt;/code&gt; and see what the load of the IO poll thread is. If it is high it could be a good idea to add more threads.</source>
          <target state="translated">Хороший способ проверить, нужны ли дополнительные потоки опроса ввода-вывода, - использовать &lt;code&gt;microstate accounting&lt;/code&gt; и посмотреть, какова нагрузка потока опроса ввода-вывода. Если он высокий, неплохо было бы добавить больше потоков.</target>
        </trans-unit>
        <trans-unit id="902246acf44b902caba68cbdbd165ab3a85407bd" translate="yes" xml:space="preserve">
          <source>A grammar to parse list expressions (with empty associated code):</source>
          <target state="translated">Грамматика для разбора выражений списка (с пустым ассоциированным кодом):</target>
        </trans-unit>
        <trans-unit id="1046b82d616c92a5ac3eba8ae29c8d175e6a998a" translate="yes" xml:space="preserve">
          <source>A group nested under a parallel group starts executing in parallel with previous (parallel) test cases (no matter what properties the nested group has). However, as test cases are never executed in parallel with &lt;code&gt;init_per_group/2&lt;/code&gt; or &lt;code&gt;end_per_group/2&lt;/code&gt; of the same group, it is only after a nested group has finished that remaining parallel cases in the previous group become spawned.</source>
          <target state="translated">Группа, вложенная в параллельную группу, начинает выполняться параллельно с предыдущими (параллельными) тестовыми примерами (независимо от того, какие свойства вложенная группа имеет). Однако, поскольку тестовые примеры никогда не выполняются параллельно с &lt;code&gt;init_per_group/2&lt;/code&gt; или &lt;code&gt;end_per_group/2&lt;/code&gt; той же группы, только после завершения вложенной группы создаются оставшиеся параллельные случаи в предыдущей группе.</target>
        </trans-unit>
        <trans-unit id="2bac3d793bd4b0481740f078d1dd54e8fa1f7130" translate="yes" xml:space="preserve">
          <source>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</source>
          <target state="translated">Внутри транзакции может быть вызвана группа функций или процессов.Транзакция может включать в себя операторы чтения,записи или удаления данных из СУБД.Многие такие транзакции могут выполняться одновременно,и программисту нет необходимости явно синхронизировать процессы,манипулирующие данными.</target>
        </trans-unit>
        <trans-unit id="05cb23555bdd306501c7337362942fb611d143f7" translate="yes" xml:space="preserve">
          <source>A group of processes can be accessed by a common name. For example, if there is a group named &lt;code&gt;foobar&lt;/code&gt;, there can be a set of processes (which can be located on different nodes) that are all members of the group &lt;code&gt;foobar&lt;/code&gt;. There are no special functions for sending a message to the group. Instead, client functions are to be written with the functions &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; to determine which processes are members of the group. Then the message can be sent to one or more group members.</source>
          <target state="translated">Доступ к группе процессов можно получить по общему имени. Например, если есть группа с именем &lt;code&gt;foobar&lt;/code&gt; , может быть набор процессов (которые могут быть расположены на разных узлах), которые все являются членами группы &lt;code&gt;foobar&lt;/code&gt; . Специальных функций для отправки сообщения группе нет. Вместо этого клиентские функции должны быть написаны с функциями &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; , чтобы определить, какие процессы являются членами группы. Затем сообщение можно отправить одному или нескольким участникам группы.</target>
        </trans-unit>
        <trans-unit id="5a3229fa1db1fe8eed7e1f7d567d0b55b01718ab" translate="yes" xml:space="preserve">
          <source>A group that starts with (?| resets the capturing parentheses numbers in each alternative (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt;). The assertions at the start of each branch check the next UTF-8 character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of the character are then captured by the appropriate number of groups.</source>
          <target state="translated">Группа, которая начинается с (? | &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; числа в скобках для записи в каждой альтернативе (см. Раздел &amp;laquo; Дублированные номера подшаблонов&amp;raquo; ). Утверждения в начале каждой ветви проверяют следующий символ UTF-8 на предмет значений, в кодировке которых используются 1, 2, 3, или 4 байта, соответственно. Затем отдельные байты символа захватываются соответствующим количеством групп.</target>
        </trans-unit>
        <trans-unit id="6db07dc0cd651815b5c72435ed2208f519f62680" translate="yes" xml:space="preserve">
          <source>A guard G is a non-empty sequence of guard tests &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt;, and Rep(G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt; G - это непустая последовательность проверок защиты Gt_1, ..., Gt_k и Rep (G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9da1b8fcba29590ca36e99b9fdb91354688f306d" translate="yes" xml:space="preserve">
          <source>A guard sequence Gs is a sequence of guards &lt;code&gt;G_1; ...; G_k&lt;/code&gt;, and Rep(Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt;. If the guard sequence is empty, then Rep(Gs) = &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Охранная последовательность Gs - это последовательность охранников &lt;code&gt;G_1; ...; G_k&lt;/code&gt; и Rep (Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt; . Если защитная последовательность пуста, то Rep (Gs) = &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e607c9ab56bd394d6c9eeddb457df24a34026a6" translate="yes" xml:space="preserve">
          <source>A guard test Gt is one of the following:</source>
          <target state="translated">Тест на охрану Gt-один из следующих:</target>
        </trans-unit>
        <trans-unit id="0958ebfcb794773c3476244fc72f207f83085686" translate="yes" xml:space="preserve">
          <source>A handle to driver-specific data, passed to the driver callbacks. It is a pointer, and is most often type cast to a specific pointer in the driver.</source>
          <target state="translated">Ручка с данными,специфичными для водителя,передаваемая водителю для обратного вызова.Это указатель,который чаще всего приводится к конкретному указателю в драйвере.</target>
        </trans-unit>
        <trans-unit id="fdc243bdb933b5a71a48ce564407f75cabaaebaf" translate="yes" xml:space="preserve">
          <source>A handler callback module must export:</source>
          <target state="translated">Модуль обратного вызова обработчика должен экспортироваться:</target>
        </trans-unit>
        <trans-unit id="678e5d07b0fa73bdf7fd807616029bb8f1f11655" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt; logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31be10ebd1dea0e036e6cc2ff50b43986eb9b610" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="translated">Обработчик можно удалить, вызвав &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt; вызывает HModule: remove_handler (Config) и удаляет конфигурацию обработчика из базы данных конфигурации.</target>
        </trans-unit>
        <trans-unit id="8b450cb00cc7d0fceaaaa8e163bad6a1a09d773b" translate="yes" xml:space="preserve">
          <source>A handler is defined as a module exporting at least the following callback function:</source>
          <target state="translated">Обработчик определяется как модуль,экспортирующий,по крайней мере,следующую функцию обратного вызова:</target>
        </trans-unit>
        <trans-unit id="a23d43ddf6d207f81a92e3f11ea5d88e0322baa2" translate="yes" xml:space="preserve">
          <source>A hidden node is a node started with the command-line flag &lt;code&gt;-hidden&lt;/code&gt;. Connections between hidden nodes and other nodes are not transitive, they must be set up explicitly. Also, hidden nodes does not show up in the list of nodes returned by &lt;code&gt;nodes()&lt;/code&gt;. Instead, &lt;code&gt;nodes(hidden)&lt;/code&gt; or &lt;code&gt;nodes(connected)&lt;/code&gt; must be used. This means, for example, that the hidden node is not added to the set of nodes that &lt;code&gt;global&lt;/code&gt; is keeping track of.</source>
          <target state="translated">Скрытый узел - это узел, запущенный с флагом командной строки &lt;code&gt;-hidden&lt;/code&gt; . Связи между скрытыми узлами и другими узлами не являются транзитивными, они должны быть установлены явно. Кроме того, скрытые узлы не отображаются в списке узлов, возвращаемом &lt;code&gt;nodes()&lt;/code&gt; . Вместо этого должны использоваться &lt;code&gt;nodes(hidden)&lt;/code&gt; или &lt;code&gt;nodes(connected)&lt;/code&gt; . Это означает, например, что скрытый узел не добавляется к набору узлов, которые отслеживает &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad527cdee0b441182ba0bc41ca62d2081d24f24" translate="yes" xml:space="preserve">
          <source>A histogram of block sizes where each interval's upper bound is twice as high as the one before it.</source>
          <target state="translated">Гистограмма размеров блоков,где верхняя граница каждого интервала в два раза больше,чем перед ним.</target>
        </trans-unit>
        <trans-unit id="ad63f98e4ec8a5df7f88023c80bfbc7bf7d5bd26" translate="yes" xml:space="preserve">
          <source>A hook function (cf. the &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; type) is passed the current syntax tree node, the context, and a continuation. The context can be examined and manipulated by functions such as &lt;code&gt;get_ctxt_user/1&lt;/code&gt; and &lt;code&gt;set_ctxt_user/2&lt;/code&gt;. The hook must return a &quot;document&quot; data structure (see &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt;); this may be constructed in part or in whole by applying the continuation function. For example, the following is a trivial hook:</source>
          <target state="translated">Перехватывающей функции (см. Тип &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; ) передается текущий узел синтаксического дерева, контекст и продолжение. Контекст можно исследовать и управлять такими функциями, как &lt;code&gt;get_ctxt_user/1&lt;/code&gt; и &lt;code&gt;set_ctxt_user/2&lt;/code&gt; . Ловушка должна возвращать структуру данных &amp;laquo;документ&amp;raquo; (см. &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt; ); это можно построить частично или полностью, применив функцию продолжения. Например, вот простой хук:</target>
        </trans-unit>
        <trans-unit id="1edf358d74594d5d0d07749392202e53a874bde3" translate="yes" xml:space="preserve">
          <source>A job that alternates between I/O bound and CPU bound can be reclassified and rescheduled using &lt;code&gt;enif_schedule_nif&lt;/code&gt; so that it executes on the correct type of dirty scheduler at all times. For more information see the documentation of the &lt;code&gt;erl(1)&lt;/code&gt; command line arguments &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Задание, которое чередуется между привязкой ввода-вывода и привязкой к ЦП, может быть переклассифицировано и перепланировано с помощью &lt;code&gt;enif_schedule_nif&lt;/code&gt; , чтобы оно всегда выполнялось в правильном типе грязного планировщика. Для получения дополнительной информации см. Документацию по аргументам командной строки &lt;code&gt;erl(1)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da4d22f9cc705b47b11f5556a6a98d52ebdf94f6" translate="yes" xml:space="preserve">
          <source>A key for des3 is a list of three iolists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bc46bb25920857aea5ff4cc78f13c35d6caf0e" translate="yes" xml:space="preserve">
          <source>A key to an entry in the session cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58867f002dc318ccf9bce1131e2694062d5333ed" translate="yes" xml:space="preserve">
          <source>A larger buffer limit allows processes to buffer more outgoing messages over the distribution. When the buffer limit has been reached, sending processes will be suspended until the buffer size has shrunk. The buffer limit is per distribution channel. A higher limit gives lower latency and higher throughput at the expense of higher memory use.</source>
          <target state="translated">Большой лимит буфера позволяет процессам буферировать больше исходящих сообщений над дистрибутивом.Когда лимит буфера достигнут,отправка процессов будет приостановлена до тех пор,пока размер буфера не уменьшится.Лимит буфера устанавливается для каждого канала рассылки.Более высокий лимит дает меньшую задержку и большую пропускную способность за счет большего использования памяти.</target>
        </trans-unit>
        <trans-unit id="06a81726c24b8781e74e0cf024d9ccac67383c44" translate="yes" xml:space="preserve">
          <source>A level in term &lt;code&gt;CpuTopology&lt;/code&gt; can be omitted if only one entry exists and &lt;code&gt;InfoList&lt;/code&gt; is empty.</source>
          <target state="translated">Уровень в термине &lt;code&gt;CpuTopology&lt;/code&gt; может быть опущен, если существует только одна запись и &lt;code&gt;InfoList&lt;/code&gt; пуст.</target>
        </trans-unit>
        <trans-unit id="dce227656c4a97473171d894829d7b5055a34016" translate="yes" xml:space="preserve">
          <source>A library application that cannot be started or stopped, does not need any application callback module.</source>
          <target state="translated">Библиотечное приложение,которое не может быть запущено или остановлено,не нуждается в модуле обратного вызова приложения.</target>
        </trans-unit>
        <trans-unit id="95d53ac43bdcd275e024568761344b42b310394a" translate="yes" xml:space="preserve">
          <source>A lightweight lookup in the table was the most important feature, but we also wanted to improve modifications of the table. The process table is modified when a new process is spawned, i.e. a new pointer is inserted into the table, and when a process terminates, i.e. a pointer is deleted in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1237e5b11078ec794450ace16c7850dee19ffaa" translate="yes" xml:space="preserve">
          <source>A line breakpoint can also be created (and deleted) by double-clicking the line when the module is displayed in the View Module window or Attach Process window.</source>
          <target state="translated">Точку останова линии также можно создать (и удалить)двойным щелчком мыши на линии,когда модуль отображается в окне View Module или Attach Process.</target>
        </trans-unit>
        <trans-unit id="25e27b31c8e51ff696a72775acff4cd63fac142f" translate="yes" xml:space="preserve">
          <source>A line breakpoint is created at a certain line in a module.</source>
          <target state="translated">Точка останова линии создаётся на определённой линии в модуле.</target>
        </trans-unit>
        <trans-unit id="98ca655fbbfd2af69c799f1de396c9692c8ffecf" translate="yes" xml:space="preserve">
          <source>A line level calls analysis of &lt;code&gt;channel&lt;/code&gt; can be written to a file using &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt;:</source>
          <target state="translated">Анализ вызовов на уровне линии &lt;code&gt;channel&lt;/code&gt; может быть записана в файл с помощью &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="71f85c48df8221b4058723c56c5fee97655b5db6" translate="yes" xml:space="preserve">
          <source>A line with &lt;code&gt;//&lt;/code&gt; is also a comment. It is recommended to only use this style of comments in files that define implementations of instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c244651147c5c8032fa00f6a8115a6bb5b8002" translate="yes" xml:space="preserve">
          <source>A link between &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; was set up on the node where &lt;code&gt;Result&lt;/code&gt; resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f9e5debe76dcfd36d855503d282295078ca73b" translate="yes" xml:space="preserve">
          <source>A link can be removed by calling the BIF &lt;code&gt;unlink(Pid)&lt;/code&gt;.</source>
          <target state="translated">Ссылку можно удалить, вызвав BIF &lt;code&gt;unlink(Pid)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b621ff75576ed0db731737d0b2db8dd71853fd" translate="yes" xml:space="preserve">
          <source>A link existed between the local process and the remote process at the time of the crash.</source>
          <target state="translated">В момент аварии существовала связь между локальным процессом и удаленным процессом.</target>
        </trans-unit>
        <trans-unit id="71334f2a43a0426d62a5d4505c43986a1e04107a" translate="yes" xml:space="preserve">
          <source>A link is broken. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes, and &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; contains the reason for the exit.</source>
          <target state="translated">Ссылка не работает. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; и &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; содержат идентификаторы связанных процессов, а &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; - причину выхода.</target>
        </trans-unit>
        <trans-unit id="ff85adc5284cadbc93a39945b54d30501de96451" translate="yes" xml:space="preserve">
          <source>A link or monitor to a remote process was broken because a connection between the nodes could not be established or was severed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d5b20cc777398a2954a5f904e0c368fb34c735" translate="yes" xml:space="preserve">
          <source>A link to all runs executed from a certain directory is written in the log named &lt;code&gt;all_runs.html&lt;/code&gt; and direct links to all tests (the latest results) are written to the top-level &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">Ссылка на все &lt;code&gt;all_runs.html&lt;/code&gt; выполняемые из определенного каталога, записывается в журнал с именем all_runs.html, а прямые ссылки на все тесты (последние результаты) записываются в &lt;code&gt;index.html&lt;/code&gt; верхнего уровня .</target>
        </trans-unit>
        <trans-unit id="c9ed186e6c9cb98bafec7585f14769f53a755b9c" translate="yes" xml:space="preserve">
          <source>A list comprehension returns a list, where the elements are the result of evaluating &lt;code&gt;Expr&lt;/code&gt; for each combination of generator list elements and bit string generator elements, for which all filters are true.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; списка возвращает список, элементы которого являются результатом вычисления Expr для каждой комбинации элементов списка генератора и элементов генератора битовой строки, для которых все фильтры истинны.</target>
        </trans-unit>
        <trans-unit id="02a87e72df2e9591f46019f9ed75098ceee2e35d" translate="yes" xml:space="preserve">
          <source>A list comprehension:</source>
          <target state="translated">Понимание списка:</target>
        </trans-unit>
        <trans-unit id="7085d8980ae301152b6ee803668c44a99ddba230" translate="yes" xml:space="preserve">
          <source>A list is a compound data type with a variable number of terms.</source>
          <target state="translated">Список-это составной тип данных с переменным количеством терминов.</target>
        </trans-unit>
        <trans-unit id="cdf78c94ee3134a5064c3958c1d7c8e4a3de8736" translate="yes" xml:space="preserve">
          <source>A list must be specified with the number of elements, including the tail, which is the last term preceding &lt;code&gt;ERL_DRV_LIST&lt;/code&gt;.</source>
          <target state="translated">Список должен быть указан с количеством элементов, включая хвост, который является последним термином, предшествующим &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70b8617890707dfd903ea1026d415236f1bdc921" translate="yes" xml:space="preserve">
          <source>A list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">Список записей 'ActionReply',возможно,содержащих указания на ошибку.</target>
        </trans-unit>
        <trans-unit id="51c375d52fb989d38f521acbea65939966bc14e9" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;UpdateOp&lt;/code&gt; can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done.</source>
          <target state="translated">Список &lt;code&gt;UpdateOp&lt;/code&gt; может быть предоставлен для выполнения множества операций обновления внутри объекта. Операции выполняются в порядке, указанном в списке. Если одна и та же позиция счетчика встречается в списке более одного раза, соответствующий счетчик, таким образом, обновляется много раз, каждый раз на основе предыдущего результата. Возвращаемое значение - это список новых значений счетчика от каждой операции обновления в том же порядке, что и в списке операций. Если указан пустой список, ничего не обновляется и возвращается пустой список. Если функция не работает, обновления не выполняются.</target>
        </trans-unit>
        <trans-unit id="030f0cbd94947cdf93b77d371b60c32ef8fca036" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Memory}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Memory&lt;/code&gt; is how much memory it occupies</source>
          <target state="translated">Список кортежей &lt;code&gt;{Name, Memory}&lt;/code&gt; , где &lt;code&gt;Name&lt;/code&gt; - это &lt;code&gt;Name&lt;/code&gt; фрагмента , а &lt;code&gt;Memory&lt;/code&gt; - сколько памяти он занимает.</target>
        </trans-unit>
        <trans-unit id="c72f78c95adc9eeb9cf8ccea551cf18350671fbd" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Size}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Size&lt;/code&gt; is how many records it contains</source>
          <target state="translated">Список кортежей &lt;code&gt;{Name, Size}&lt;/code&gt; , где &lt;code&gt;Name&lt;/code&gt; - это &lt;code&gt;Name&lt;/code&gt; фрагмента , а &lt;code&gt;Size&lt;/code&gt; - количество записей, которые он содержит</target>
        </trans-unit>
        <trans-unit id="e2180b4c9facbabd3ef7f26e9137ff364cfb6bb1" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Pos,Value}&lt;/code&gt; can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results.</source>
          <target state="translated">Список &lt;code&gt;{Pos,Value}&lt;/code&gt; может быть предоставлен для обновления многих элементов в одном объекте. Если одна и та же позиция встречается в списке более одного раза, записывается последнее значение в списке. Если список пуст или функция не работает, обновления не выполняются. Функция также является атомарной в том смысле, что другие процессы никогда не могут увидеть никаких промежуточных результатов.</target>
        </trans-unit>
        <trans-unit id="b3c0a15b7c94f033790cb5a9578215ba2c5eb2b7" translate="yes" xml:space="preserve">
          <source>A list of &lt;strong&gt;release upgrade instructions&lt;/strong&gt;, see &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt;. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by &lt;code&gt;systools&lt;/code&gt; when creating the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">Список &lt;strong&gt;инструкций по обновлению выпуска&lt;/strong&gt; см. В разделе &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt; . Рекомендуется использовать только инструкции высокого уровня. Они автоматически переводятся в инструкции низкого уровня с помощью программных &lt;code&gt;systools&lt;/code&gt; при создании файла &lt;code&gt;relup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9313069dff4ca94cf23c29546a7ad4ed8220831c" translate="yes" xml:space="preserve">
          <source>A list of DER-encoded certificates in trust order ending with the peer certificate.</source>
          <target state="translated">Список сертификатов с DER-кодировкой в порядке доверия,заканчивающийся сертификатом &quot;равный-равному&quot;.</target>
        </trans-unit>
        <trans-unit id="cfdc5fa9c2f2d452137349f08f0ebdc7cd06e86e" translate="yes" xml:space="preserve">
          <source>A list of active checkpoints can be obtained with the following functions:</source>
          <target state="translated">Список активных контрольно-пропускных пунктов можно получить с помощью следующих функций:</target>
        </trans-unit>
        <trans-unit id="22e1cd424af636813424f38dcaf9d38efccd215c" translate="yes" xml:space="preserve">
          <source>A list of all valid Erlang Top configuration parameters is available in module &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Список всех допустимых параметров конфигурации Erlang Top доступен в модуле &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84f87e145849ab0fff970812ed60b4958a7995b9" translate="yes" xml:space="preserve">
          <source>A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the dictionary of the application in question. At decode, such AVPs are represented as diameter_avp records in the &lt;code&gt;'AVP'&lt;/code&gt; field of a decoded message or Grouped AVP, the first alternate that succeeds in decoding the AVP setting the record's value field. At encode, values in an &lt;code&gt;'AVP'&lt;/code&gt; list can be passed as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of such a tuple.</source>
          <target state="translated">Список альтернативных словарных модулей, с помощью которых можно кодировать / декодировать AVP, которые не определены в словаре рассматриваемого приложения. При декодировании такие AVP представлены в виде записей Diameter_avp в поле &lt;code&gt;'AVP'&lt;/code&gt; декодированного сообщения или Grouped AVP, первой альтернативы, которая успешно декодирует AVP, устанавливающую поле значения записи. При кодировании значения в списке &lt;code&gt;'AVP'&lt;/code&gt; могут быть переданы как 2-кортежи имя / значение AVP, и определение AVP такого кортежа является ошибкой кодирования, поскольку нет альтернативы.</target>
        </trans-unit>
        <trans-unit id="bcb8af967c3f5df09119723a75e7c020769c5e61" translate="yes" xml:space="preserve">
          <source>A list of application versions that the application depends on. An example of such an application version is &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt;. Application versions specified as runtime dependencies are minimum requirements. That is, a larger application version than the one specified in the dependency satisfies the requirement. For information about how to compare application versions, see section &lt;code&gt;Versions&lt;/code&gt; in the System Principles User's Guide.</source>
          <target state="translated">Список версий приложения, от которых оно зависит. Пример такой версии приложения - &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt; . Версии приложения, указанные как зависимости времени выполнения, являются минимальными требованиями. То есть более крупная версия приложения, чем та, которая указана в зависимости, удовлетворяет требованию. Для получения информации о том, как сравнивать версии приложений, см. Раздел &amp;laquo; &lt;code&gt;Versions&lt;/code&gt; в Руководстве пользователя по принципам системы.</target>
        </trans-unit>
        <trans-unit id="85bcb2be6c30593796c07db13b64536f31aab04f" translate="yes" xml:space="preserve">
          <source>A list of applications that are included by an application included in the release. The list must be a subset of the included applications specified in the application resource file (&lt;code&gt;Application.app&lt;/code&gt;) and overrides this value. Defaults to the same value as in the application resource file.</source>
          <target state="translated">Список приложений, которые включены в приложение, включенное в выпуск. Список должен быть подмножеством включенных приложений, указанных в файле ресурсов приложения ( &lt;code&gt;Application.app&lt;/code&gt; ), и переопределять это значение. По умолчанию используется то же значение, что и в файле ресурсов приложения.</target>
        </trans-unit>
        <trans-unit id="7501d56e7513156f76383768c05bf058cd48248a" translate="yes" xml:space="preserve">
          <source>A list of arbitrary socket options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a81a79f1a7098f6cb205944af55c35f111d222" translate="yes" xml:space="preserve">
          <source>A list of atoms corresponding to atoms in the &lt;code&gt;NamedBitList&lt;/code&gt; in the &lt;code&gt;BIT STRING&lt;/code&gt; definition. A &lt;code&gt;BIT STRING&lt;/code&gt; with symbolic names is always decoded to the format shown in the following example:</source>
          <target state="translated">Список атомов, соответствующих атомам в &lt;code&gt;NamedBitList&lt;/code&gt; в определении &lt;code&gt;BIT STRING&lt;/code&gt; . &lt;code&gt;BIT STRING&lt;/code&gt; с символическими именами всегда декодируются в формат , показанном в следующем примере:</target>
        </trans-unit>
        <trans-unit id="dad15913daed65e8f5cbb546acf62e2eac396099" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt; enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4416e89ecd0bec31a83597e47f21c9429cab1bb6" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Список двоичных файлов. Этот тип данных полезно использовать вместе с &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc21ad3fb691b61137a500e7fa67b8eec7cc2074" translate="yes" xml:space="preserve">
          <source>A list of cipher suites that should be supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64654646df6b843e592f4468159e2fedaaec3b28" translate="yes" xml:space="preserve">
          <source>A list of functions specified in option &lt;code&gt;Startup&lt;/code&gt; are executed after startup of the node. Notice that all used modules are to be present in the code path on &lt;code&gt;Host&lt;/code&gt;.</source>
          <target state="translated">Список функций, указанных в опции &lt;code&gt;Startup&lt;/code&gt; , выполняется после запуска узла. Обратите внимание, что все используемые модули должны присутствовать в пути кода на &lt;code&gt;Host&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33ed581a843666d74741e3c3b88fa9be23335a3f" translate="yes" xml:space="preserve">
          <source>A list of identifiers for all the processes, ports and NIF resources, that are monitoring the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8da2df3aade9466893560d8879580f6ac7224df" translate="yes" xml:space="preserve">
          <source>A list of integers sets the generator's internal state directly, after algorithm-dependent checks of the value and masking to the proper word size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b9f4cc16d6de8c7e19f996e3ff20895acaba69" translate="yes" xml:space="preserve">
          <source>A list of key-value tuples (that is, a property list) containing runtime configuration data passed from the configuration functions to the test cases.</source>
          <target state="translated">Список кортежей с ключевыми значениями (т.е.список свойств),содержащий данные конфигурации,передаваемые из конфигурационных функций в тестовые случаи.</target>
        </trans-unit>
        <trans-unit id="53072cdf6c2b3e1f0ce0b618f29746a989ccb6e4" translate="yes" xml:space="preserve">
          <source>A list of low-level release upgrade instructions, see &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt;. It consists of the release upgrade instructions from the respective application upgrade files (high-level instructions are translated to low-level instructions), in the same order as in the start script.</source>
          <target state="translated">Список инструкций по обновлению низкоуровневого выпуска см. В &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt; . Он состоит из инструкций по обновлению выпуска из соответствующих файлов обновления приложения (высокоуровневые инструкции переводятся в низкоуровневые инструкции) в том же порядке, что и в стартовом скрипте.</target>
        </trans-unit>
        <trans-unit id="07cd63bd8b8a5bee2676cad933dc31cee7b4f8e9" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5458cb9ed4430c9a1044722c1c9f0ec73351850" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Список характеристик соответствия. Пустой список эквивалентен &lt;code&gt;true&lt;/code&gt; . Описание характеристик соответствия см. В разделе &amp;laquo; &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="139fe9d39aad421da9b537eadc3c0d0b13b2c1fe" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f24e9180cc135394011e3f9e98998139bc43ae7" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Список характеристик соответствия. Сопоставление выполняется по списку &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; . &lt;code&gt;Node&lt;/code&gt; - это имя узла отправителя. &lt;code&gt;Sender&lt;/code&gt; - это процесс или идентификатор порта отправителя, или атом &lt;code&gt;undefined&lt;/code&gt; если отправитель неизвестен (что может иметь место для удаленных отправителей). &lt;code&gt;Msg&lt;/code&gt; - это термин сообщения. Доступ к pid принимающего процесса можно получить с помощью функции защиты &lt;code&gt;self/0&lt;/code&gt; . Пустой список соответствует &lt;code&gt;true&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="d87f996d594a00d6035f5f5ee9ddba88e768355e" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae6c5016a51b941ea9b569f5d1e616278b56ff4" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Список характеристик соответствия. Соответствие выполняется в списке &lt;code&gt;[Receiver, Msg]&lt;/code&gt; . &lt;code&gt;Receiver&lt;/code&gt; - это идентификатор процесса или порта получателя, а &lt;code&gt;Msg&lt;/code&gt; - термин сообщения. Доступ к pid отправляющего процесса можно получить с помощью функции защиты &lt;code&gt;self/0&lt;/code&gt; . Пустой список соответствует &lt;code&gt;true&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="f891abb57f22c043046c0acca9828e5f72f099a9" translate="yes" xml:space="preserve">
          <source>A list of monitors (started by &lt;code&gt;monitor/2&lt;/code&gt;) that are active for the process. For a local process monitor or a remote process monitor by a process identifier, the list consists of:</source>
          <target state="translated">Список мониторов (запущенных &lt;code&gt;monitor/2&lt;/code&gt; ), активных для процесса. Для локального монитора процесса или удаленного монитора процесса по идентификатору процесса список состоит из:</target>
        </trans-unit>
        <trans-unit id="1e09e85b1d23a2d1904ace9e97601c063a94ad34" translate="yes" xml:space="preserve">
          <source>A list of node names (atoms), the group nodes.</source>
          <target state="translated">Список имен узлов (атомов),групповых узлов.</target>
        </trans-unit>
        <trans-unit id="f513e60b833a271eafeea13f285937ef60a9f36a" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes currently synchronized with the local node.</source>
          <target state="translated">Список имен узлов,групповых узлов,синхронизированных в данный момент с локальным узлом.</target>
        </trans-unit>
        <trans-unit id="d5813c5a7e310a9d07043782acc2491f544da810" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes to which there are currently no connections.</source>
          <target state="translated">Список имен узлов,групповых узлов,к которым на данный момент нет подключений.</target>
        </trans-unit>
        <trans-unit id="ede2a365270db1734a514f8930fed986e258eb67" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes with which the local node has failed to synchronize.</source>
          <target state="translated">Список имен узлов,групповых узлов,с которыми локальный узел не смог синхронизироваться.</target>
        </trans-unit>
        <trans-unit id="68320e1e6e32580922546695a30d4ffc50df4758" translate="yes" xml:space="preserve">
          <source>A list of objects and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращается список объектов и продолжение, если таблица не пуста, и в этом случае &lt;code&gt;'$end_of_table'&lt;/code&gt; . Продолжение должно использоваться при сопоставлении других объектов путем вызова &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795b45a529dceb8a27da1be92835aa76262ca94d" translate="yes" xml:space="preserve">
          <source>A list of pids, specifying the processes that have subscribed to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">Список pid, определяющий процессы, которые подписались на сообщения &lt;code&gt;nodeup&lt;/code&gt; и &lt;code&gt;nodedown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc2862b14b19fa3c52a7c39935bdc51459df8ec" translate="yes" xml:space="preserve">
          <source>A list of process identifiers monitoring the process (with &lt;code&gt;monitor/2&lt;/code&gt;).</source>
          <target state="translated">Список идентификаторов процессов, отслеживающих процесс (с помощью &lt;code&gt;monitor/2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="798f3c6d606c88936e16d8fb3e746a3c0d7e414f" translate="yes" xml:space="preserve">
          <source>A list of start phases and corresponding start arguments for the application. If this key is present, the application master, in addition to the usual call to &lt;code&gt;Module:start/2&lt;/code&gt;, also calls &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; for each start phase defined by key &lt;code&gt;start_phases&lt;/code&gt;. Only after this extended start procedure, &lt;code&gt;application:start(Application)&lt;/code&gt; returns.</source>
          <target state="translated">Список этапов запуска и соответствующие аргументы запуска для приложения. Если этот ключ присутствует, мастер приложения, помимо обычного вызова &lt;code&gt;Module:start/2&lt;/code&gt; , также вызывает &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; для каждой фазы запуска, определенной ключом &lt;code&gt;start_phases&lt;/code&gt; . Только после этой расширенной процедуры &lt;code&gt;application:start(Application)&lt;/code&gt; возвращается application: start (Приложение) .</target>
        </trans-unit>
        <trans-unit id="edf21767ef6072f1fd3b3c1a6a4c7c161dc74414" translate="yes" xml:space="preserve">
          <source>A list of the characters in the matched token.</source>
          <target state="translated">Список символов в соответствующем токене.</target>
        </trans-unit>
        <trans-unit id="8133b9a65a9c55bb804a98f418e83c6fd30bd2dd" translate="yes" xml:space="preserve">
          <source>A list of the nodes that do not exist</source>
          <target state="translated">Список узлов,которые не существуют.</target>
        </trans-unit>
        <trans-unit id="4787cc71f8b45d2d5a1e6a23232994156e3e6848" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server does not exist</source>
          <target state="translated">Список узлов,где нет сервера.</target>
        </trans-unit>
        <trans-unit id="23fbc37251525e0fbe5e6808d56771dd9e1bb61d" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server terminated before sending any reply.</source>
          <target state="translated">Список узлов,на которых сервер прекратил работу до отправки ответа.</target>
        </trans-unit>
        <trans-unit id="86b3af01504c95f1ff0a3bad6e86965e662943b1" translate="yes" xml:space="preserve">
          <source>A list of tokens produced by the scanner should end with a special &lt;code&gt;end_of_input&lt;/code&gt; tuple which the parser is looking for. The format of this tuple should be &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt;, where &lt;code&gt;Endsymbol&lt;/code&gt; is an identifier that is distinguished from all the terminal and non-terminal categories of the syntax rules. The &lt;code&gt;Endsymbol&lt;/code&gt; may be declared in the grammar file (see below).</source>
          <target state="translated">Список токенов, созданный сканером, должен заканчиваться специальным кортежем &lt;code&gt;end_of_input&lt;/code&gt; , который ищет анализатор. Формат этого кортежа должен быть &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt; , где &lt;code&gt;Endsymbol&lt;/code&gt; - это идентификатор, который отличается от всех терминальных и нетерминальных категорий синтаксических правил. &lt;code&gt;Endsymbol&lt;/code&gt; могут быть объявлены в файле грамматики (см . Ниже)</target>
        </trans-unit>
        <trans-unit id="c2109516cde7b07bab03027450759556426aff7c" translate="yes" xml:space="preserve">
          <source>A list of tuples containing results for individual schedulers as well as aggregated averages. &lt;code&gt;Util&lt;/code&gt; is the scheduler utilization as a floating point value between 0.0 and 1.0. &lt;code&gt;Percent&lt;/code&gt; is the same utilization as a more human readable string expressed in percent.</source>
          <target state="translated">Список кортежей, содержащий результаты для отдельных планировщиков, а также агрегированные средние значения. &lt;code&gt;Util&lt;/code&gt; - это использование планировщика в виде значения с плавающей запятой от 0,0 до 1,0. &lt;code&gt;Percent&lt;/code&gt; - это то же использование, что и более удобочитаемая строка, выраженная в процентах.</target>
        </trans-unit>
        <trans-unit id="2ea742332d3293e5cbb6278b7055ef5cb1f029ed" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each function in a module, in decreasing &lt;code&gt;FuncCallCount&lt;/code&gt; order.</source>
          <target state="translated">Список кортежей, по одному для каждой функции в модуле, в порядке убывания &lt;code&gt;FuncCallCount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d414f3936cc6ab0feb3f8f3f242331f59448312d" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each module except &lt;code&gt;cprof&lt;/code&gt;, in decreasing &lt;code&gt;ModCallCount&lt;/code&gt; order.</source>
          <target state="translated">Список кортежей, по одному для каждого модуля, кроме &lt;code&gt;cprof&lt;/code&gt; , в порядке убывания &lt;code&gt;ModCallCount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a515d4554cb24670f64c931a7f1c050e2d9f77e" translate="yes" xml:space="preserve">
          <source>A list representing the tail elements of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Список, представляющий хвостовые элементы списка &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49c534723b00f62164b408805f640dc737cc5620" translate="yes" xml:space="preserve">
          <source>A list sorted as follows:</source>
          <target state="translated">Список отсортирован следующим образом:</target>
        </trans-unit>
        <trans-unit id="f5ef252277490863011469cba50309fcc2a552c0" translate="yes" xml:space="preserve">
          <source>A list where the tail is a list is sometimes called a &lt;strong&gt;proper list&lt;/strong&gt;. It is allowed to have a list where the tail is not a list, for example, &lt;code&gt;[a|b]&lt;/code&gt;. However, this type of list is of little practical use.</source>
          <target state="translated">Список, в котором хвост является списком, иногда называют &lt;strong&gt;правильным списком&lt;/strong&gt; . Допускается иметь список, в котором хвост не является списком, например, &lt;code&gt;[a|b]&lt;/code&gt; . Однако этот тип списка мало пригоден.</target>
        </trans-unit>
        <trans-unit id="efe540ae45894e0fdbc313179169b5e104e7d954" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list Each element can be:</source>
          <target state="translated">Список с таким количеством элементов, как список &lt;code&gt;Cols&lt;/code&gt; . Каждый элемент может быть:</target>
        </trans-unit>
        <trans-unit id="9b2d1080e5c727bcb4180b6c054a8305dfd68dfc" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list, where each element is the value of the corresponding column. Each element can be:</source>
          <target state="translated">Список с таким количеством элементов, как список &lt;code&gt;Cols&lt;/code&gt; , где каждый элемент является значением соответствующего столбца. Каждый элемент может быть:</target>
        </trans-unit>
        <trans-unit id="1f4d38e7e775065b86b76958019e087be5338c72" translate="yes" xml:space="preserve">
          <source>A list with integers &amp;gt; 255 is considered an error if the Unicode translation modifier is not specified:</source>
          <target state="translated">Список с целыми числами&amp;gt; 255 считается ошибкой, если не указан модификатор перевода Unicode:</target>
        </trans-unit>
        <trans-unit id="56ba062b97d1eab0e07bd7682980396fa3439b42" translate="yes" xml:space="preserve">
          <source>A list, empty or not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14565d44a02de06df96d7cafd4c87d042823638e" translate="yes" xml:space="preserve">
          <source>A listbox containing the names of all interpreted modules</source>
          <target state="translated">Окно списка,содержащее имена всех интерпретируемых модулей</target>
        </trans-unit>
        <trans-unit id="d04bc0e41b8be3fc83734efd80c9fb1225163fbf" translate="yes" xml:space="preserve">
          <source>A listening transport presents its information slightly differently since there may be multiple accepted connections for the same &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;transport&lt;/code&gt; info returned by a server with a single client connection might look as follows.</source>
          <target state="translated">Прослушивающий транспорт представляет свою информацию несколько иначе, поскольку для одного и того же &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; может быть несколько принятых соединений . Информация о &lt;code&gt;transport&lt;/code&gt; возвращаемая сервером с одним клиентским подключением, может выглядеть следующим образом.</target>
        </trans-unit>
        <trans-unit id="9f635b77fbd8f2fa61daabd2f18c04196f559460" translate="yes" xml:space="preserve">
          <source>A literal &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Понимание буквального &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17c58bfa57cd941d6af606b21964e3471f8b0dec" translate="yes" xml:space="preserve">
          <source>A literal data character</source>
          <target state="translated">Буквальный характер данных</target>
        </trans-unit>
        <trans-unit id="b9eff8ef6bae96d4d99cb1d0d45944faf85b28e0" translate="yes" xml:space="preserve">
          <source>A literal string can be written instead of an element:</source>
          <target state="translated">Вместо элемента может быть записана буквальная строка:</target>
        </trans-unit>
        <trans-unit id="c5bb25cde669006f83df9c8db3230c71118a01ae" translate="yes" xml:space="preserve">
          <source>A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded, the new module instance needs to load its own NIF library (or maybe choose not to). The new module instance can, however, choose to load the exact same NIF library as the old code if it wants to. Sharing the dynamic library means that static data defined by the library is shared as well. To avoid unintentionally shared static data between module instances, each Erlang module version can keep its own private data. This private data can be set when the NIF library is loaded and later retrieved by calling &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Загруженная библиотека NIF привязана к экземпляру модуля Erlang, который ее загрузил. Если модуль обновлен, новый экземпляр модуля должен загрузить свою собственную библиотеку NIF (или, возможно, выбрать не делать этого). Однако новый экземпляр модуля может выбрать загрузку той же самой библиотеки NIF, что и старый код, если захочет. Совместное использование динамической библиотеки означает, что статические данные, определенные библиотекой, также являются общими. Чтобы избежать непреднамеренного совместного использования статических данных между экземплярами модуля, каждая версия модуля Erlang может хранить свои собственные личные данные. Эти личные данные могут быть установлены при загрузке библиотеки NIF, а затем извлечены путем вызова &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b6d76f899d39de86797bece2df0524e5c5bc58f" translate="yes" xml:space="preserve">
          <source>A log file can be opened more than once by giving different values to option &lt;code&gt;name&lt;/code&gt; or by using the same file when distributing a log on different nodes. It is up to the user of module &lt;code&gt;disk_log&lt;/code&gt; to ensure that not more than one disk log process has write access to any file, otherwise the file can be corrupted.</source>
          <target state="translated">Файл журнала можно открыть более одного раза, задав разные значения &lt;code&gt;name&lt;/code&gt; параметра или используя один и тот же файл при распространении журнала на разные узлы. Пользователь модуля &lt;code&gt;disk_log&lt;/code&gt; должен убедиться, что не более одного процесса журнала диска имеют доступ на запись к любому файлу, иначе файл может быть поврежден.</target>
        </trans-unit>
        <trans-unit id="0f75009c18af2951c814381c778a999ec618f179" translate="yes" xml:space="preserve">
          <source>A log file for one particular test case. Also called the test case log file.</source>
          <target state="translated">Лог-файл для одного конкретного тестового случая.Также называется лог-файл тестового случая.</target>
        </trans-unit>
        <trans-unit id="6a0809efff21f90864c4f42725c904032725ee3b" translate="yes" xml:space="preserve">
          <source>A logical error is when a program does not behave as intended, but does not crash. An example is that nothing happens when a button in a graphical user interface is clicked.</source>
          <target state="translated">Логической ошибкой является то,что программа ведет себя не так,как предполагалось,но не аварийно.Например,ничего не происходит при нажатии кнопки в графическом интерфейсе пользователя.</target>
        </trans-unit>
        <trans-unit id="874913df600124a6285f4364c4fbf70b34e930c1" translate="yes" xml:space="preserve">
          <source>A long line can be broken into shorter lines by a placing a &lt;code&gt;\&lt;/code&gt; before the newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca61b37a0ea4d7b34c40913d6020ff25d24aa5f" translate="yes" xml:space="preserve">
          <source>A long queue of requests can cause a user-perceived delay, as earlier requests can take a long time to complete. The HTTP/1.1 specification suggests a limit of two persistent connections per server, which is the default value of option &lt;code&gt;max_sessions&lt;/code&gt;.</source>
          <target state="translated">Длинная очередь запросов может вызвать задержку, воспринимаемую пользователем, поскольку выполнение более ранних запросов может занять много времени. Спецификация HTTP / 1.1 предлагает ограничение в два постоянных соединения на сервер, что является значением по умолчанию для параметра &lt;code&gt;max_sessions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4935bb183b98bea21599c5ff3981cab6721e4f54" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;, where all occurrences of a variable &lt;code&gt;Var&lt;/code&gt; from the macro definition are replaced with the corresponding argument &lt;code&gt;Arg&lt;/code&gt;.</source>
          <target state="translated">Макрос &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; заменяется на &lt;code&gt;Replacement&lt;/code&gt; , где все вхождения переменной &lt;code&gt;Var&lt;/code&gt; из определения макроса заменяются соответствующим аргументом &lt;code&gt;Arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d257ea7c2cd44ef76446306fb9244bed68bdcdf" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; with a (possibly empty) list of arguments results in an error message if there is at least one definition of &lt;code&gt;Func&lt;/code&gt; with arguments, but none with N arguments.</source>
          <target state="translated">Макрос &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; с (возможно, пустым) списком аргументов приводит к сообщению об ошибке, если существует хотя бы одно определение &lt;code&gt;Func&lt;/code&gt; с аргументами, но ни одно определение с N аргументами.</target>
        </trans-unit>
        <trans-unit id="b1a7684d730263c657e047ab83e0ed99db2901a8" translate="yes" xml:space="preserve">
          <source>A macro can also be invoked from within another macro. For example, &lt;code&gt;move_deallocate_return/2&lt;/code&gt; avoids repeating code by invoking &lt;code&gt;$deallocate_return()&lt;/code&gt; as a macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f534c58d9ea31eaf8fb9427562c3ead1595373" translate="yes" xml:space="preserve">
          <source>A macro definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the macro.</source>
          <target state="translated">Определение макроса может быть размещено в любом месте среди атрибутов и деклараций функций модуля,но определение должно прийти до любого использования макроса.</target>
        </trans-unit>
        <trans-unit id="98be1362f60e2ee14c3e74a98f904123979eba5e" translate="yes" xml:space="preserve">
          <source>A macro definition whose name and arity matches a family of specific instructions is assumed to be the implementation of that instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba3e72543889c84d73759d1071163c5b4427577" translate="yes" xml:space="preserve">
          <source>A macro definitions must start at the beginning of the line (no spaces allowed), the opening curly bracket must be on the same line, and the finishing curly bracket must be at the beginning of a line. It is recommended that the macro body is properly indented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b023cfdfd3e8c944def982069911746c56dbb5ff" translate="yes" xml:space="preserve">
          <source>A macro is also used when spawning the server process:</source>
          <target state="translated">Макрос также используется при порождении серверного процесса:</target>
        </trans-unit>
        <trans-unit id="7f21e1aec85a7381be96d5bfbfec7f097bd47be9" translate="yes" xml:space="preserve">
          <source>A macro is defined as follows:</source>
          <target state="translated">Макрос определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="ce03814050d5f8680e3201e0fe96acef21b95f3d" translate="yes" xml:space="preserve">
          <source>A macro is used as follows:</source>
          <target state="translated">Макрос используется следующим образом:</target>
        </trans-unit>
        <trans-unit id="88726427099902153bb75f43bd476a92b9488c2a" translate="yes" xml:space="preserve">
          <source>A manager generates commands and receives notifications from agents. There usually are only a few managers in a system.</source>
          <target state="translated">Менеджер генерирует команды и получает уведомления от агентов.Обычно в системе всего несколько менеджеров.</target>
        </trans-unit>
        <trans-unit id="11e6d2013425970bf367a17f1b0c89bb48e7ff98" translate="yes" xml:space="preserve">
          <source>A map containing information about a specific thread. The percentages in the map can be either run-time or real-time depending on if &lt;code&gt;runtime&lt;/code&gt; or &lt;code&gt;realtime&lt;/code&gt; was requested from &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;system&lt;/code&gt; is the percentage of total system time for this specific thread.</source>
          <target state="translated">Карта, содержащая информацию о конкретной теме. Проценты в карте может быть либо во время выполнения или в режиме реального времени в зависимости от того, если во &lt;code&gt;runtime&lt;/code&gt; или в &lt;code&gt;realtime&lt;/code&gt; было предложено от &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;system&lt;/code&gt; - это процент от общего системного времени для этого конкретного потока.</target>
        </trans-unit>
        <trans-unit id="c1a5aa45e09b54b7bc479445ee3316a7d38b6bc0" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states and the number of microseconds spent in it.</source>
          <target state="translated">Карта,содержащая различные состояния микрогосударственного учета и количество микросекунд,потраченных на нее.</target>
        </trans-unit>
        <trans-unit id="55baef3a4a4f36d3a95ce66a57813b6156ada372" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states. Each value in the map contains another map with the percentage of time that this thread has spent in the specific state. Both the percentage of &lt;code&gt;system&lt;/code&gt; time and the time for that specific &lt;code&gt;thread&lt;/code&gt; is part of the map.</source>
          <target state="translated">Карта, содержащая различные состояния учета на микрогосударствах. Каждое значение на карте содержит другую карту с процентным соотношением времени, которое этот поток провел в определенном состоянии. И процент &lt;code&gt;system&lt;/code&gt; времени, и время для этого конкретного &lt;code&gt;thread&lt;/code&gt; являются частью карты.</target>
        </trans-unit>
        <trans-unit id="55c86ea1a266f601e2fcf39f41d436ed4bb1d415" translate="yes" xml:space="preserve">
          <source>A map is a compound data type with a variable number of key-value associations:</source>
          <target state="translated">Карта-это составной тип данных с переменным количеством ассоциаций ключей-значений:</target>
        </trans-unit>
        <trans-unit id="d505ce33814e76ba28c2120be515c6067e3749b3" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt; enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df3d7501dc214f5a620dc3e70ec00231ed3a7da" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Итератор карты полезен только во время жизни среды &lt;code&gt;env&lt;/code&gt; , к которой принадлежит &lt;code&gt;map&lt;/code&gt; . Итератор необходимо уничтожить вызовом &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="48183a4afcb12654d2835dae35952f5ae81cc70f" translate="yes" xml:space="preserve">
          <source>A map must be specified with the number of key-value pairs &lt;code&gt;N&lt;/code&gt;. The key-value pairs must precede the &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; in this order: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt;. Duplicate keys are not allowed.</source>
          <target state="translated">Карта должна быть указана с числом пар ключ-значение &lt;code&gt;N&lt;/code&gt; . Пары &amp;laquo;ключ-значение&amp;raquo; должны предшествовать &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; в следующем порядке: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt; . Повторяющиеся ключи не допускаются.</target>
        </trans-unit>
        <trans-unit id="31783f08d32874056a3057b68b1693f84e957994" translate="yes" xml:space="preserve">
          <source>A match specification can turn on or off sequential tracing. This function returns a match specification, which turns on sequential tracing with the specified &lt;code&gt;Flags&lt;/code&gt;.</source>
          <target state="translated">Спецификация соответствия может включать или отключать последовательную трассировку. Эта функция возвращает спецификацию соответствия, которая включает последовательную трассировку с указанными &lt;code&gt;Flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6ddfb750b1e05982e25e257ab27afe27127e930" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;'receive'&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;, &lt;code&gt;is_seq_trace&lt;/code&gt;, &lt;code&gt;get_seq_token&lt;/code&gt;, &lt;code&gt;set_seq_token&lt;/code&gt;, &lt;code&gt;enable_trace&lt;/code&gt;, &lt;code&gt;disable_trace&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;silent&lt;/code&gt;, and &lt;code&gt;process_dump&lt;/code&gt;.</source>
          <target state="translated">Спецификация соответствия для трассировки &lt;code&gt;'receive'&lt;/code&gt; может использовать все функции защиты и тела, кроме &lt;code&gt;caller&lt;/code&gt; , &lt;code&gt;is_seq_trace&lt;/code&gt; , &lt;code&gt;get_seq_token&lt;/code&gt; , &lt;code&gt;set_seq_token&lt;/code&gt; , &lt;code&gt;enable_trace&lt;/code&gt; , &lt;code&gt;disable_trace&lt;/code&gt; , &lt;code&gt;trace&lt;/code&gt; , &lt;code&gt;silent&lt;/code&gt; и &lt;code&gt;process_dump&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1a2a4c3c454f94b1fa52f933e896cf4b6f1dcf" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;send&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;.</source>
          <target state="translated">Спецификация соответствия для трассировки &lt;code&gt;send&lt;/code&gt; может использовать все функции защиты и тела, кроме &lt;code&gt;caller&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775d888e22b3e82c594b4190a83e5f1b3950e566" translate="yes" xml:space="preserve">
          <source>A match specification used in &lt;code&gt;ets(3)&lt;/code&gt; can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">Спецификацию соответствия, используемую в &lt;code&gt;ets(3)&lt;/code&gt; можно описать следующей &lt;strong&gt;неформальной&lt;/strong&gt; грамматикой:</target>
        </trans-unit>
        <trans-unit id="83306dec354257cfad7ed48f591c0ff422b66b68" translate="yes" xml:space="preserve">
          <source>A match specification used in tracing can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">Спецификацию соответствия, используемую при трассировке, можно описать следующей &lt;strong&gt;неформальной&lt;/strong&gt; грамматикой:</target>
        </trans-unit>
        <trans-unit id="c3565e8901b4b3516619d211f5de1eb7c7f5a2de" translate="yes" xml:space="preserve">
          <source>A match specification, see above.</source>
          <target state="translated">Спецификация соответствия,см.выше.</target>
        </trans-unit>
        <trans-unit id="abb2961d578d0b3c60f269fc6add18fea6c7cde0" translate="yes" xml:space="preserve">
          <source>A match specifications with excessive nesting will cause a &lt;code&gt;&lt;a href=&quot;#ets_failures&quot;&gt;system_limit&lt;/a&gt;&lt;/code&gt; error exception to be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfda4d3ad9a01b6a5ad6d226917a35814c884393" translate="yes" xml:space="preserve">
          <source>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before each backtrack occurs (in this example, 10 times).</source>
          <target state="translated">Сравнение со строкой &quot;aaaa&quot; всегда не удается,но вызов принимается перед каждым обратным ходом (в данном примере 10 раз).</target>
        </trans-unit>
        <trans-unit id="6f29c903e3589affa8d324ed95b31c5c61e91931" translate="yes" xml:space="preserve">
          <source>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the &lt;code&gt;mmap&lt;/code&gt; system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</source>
          <target state="translated">Распределитель сегментов памяти. Он используется другими распределителями для выделения сегментов памяти и доступен только в системах, в которых есть системный вызов &lt;code&gt;mmap&lt;/code&gt; . Освобожденные сегменты памяти некоторое время хранятся в кэше сегментов, прежде чем они будут уничтожены. Когда сегменты выделяются, по возможности используются кэшированные сегменты вместо создания новых сегментов. Это позволяет сократить количество выполняемых системных вызовов.</target>
        </trans-unit>
        <trans-unit id="12c52bcf9d23dfb0dbc1111b21b3e77c0d64c7e0" translate="yes" xml:space="preserve">
          <source>A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22559646ed04a3865a223cef10ef45e28e857451" translate="yes" xml:space="preserve">
          <source>A middlebox which terminates a TLS connection MUST behave as a compliant TLS server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c010e88e46ea60a66fde46681834435a05128c" translate="yes" xml:space="preserve">
          <source>A minimal example of a NIF library can look as follows:</source>
          <target state="translated">Минимальный пример библиотеки NIF может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="87e74e52d3b9087104d60a0e55cc35f5604c3259" translate="yes" xml:space="preserve">
          <source>A minimum Windows NT installation with networking needs 250 MB, and an extra 130 MB for the swap file.</source>
          <target state="translated">Минимальная инсталляция Windows NT с сетью требует 250 МБ,а для файла подкачки дополнительно 130 МБ.</target>
        </trans-unit>
        <trans-unit id="ccca12c026cce7e56e7fa3fc8b384f432861042d" translate="yes" xml:space="preserve">
          <source>A misbehaving filter will be removed.</source>
          <target state="translated">Фильтр от неправильного поведения будет удален.</target>
        </trans-unit>
        <trans-unit id="06a13e586eee527b77c49434cc8f50ec42065c62" translate="yes" xml:space="preserve">
          <source>A module attribute consists of a tag and a value:</source>
          <target state="translated">Атрибут модуля состоит из тега и значения:</target>
        </trans-unit>
        <trans-unit id="dab39b0e69b099bf9e59a93c7991371da0a76b13" translate="yes" xml:space="preserve">
          <source>A module can also be used to represent a test set; see &lt;code&gt;ModuleName&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">Модуль также может использоваться для представления тестового набора; см. &lt;code&gt;ModuleName&lt;/code&gt; в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="c521c6a7b79de7232798a925aa632173f772fa44" translate="yes" xml:space="preserve">
          <source>A module can be specified by its module name (atom) or filename.</source>
          <target state="translated">Модуль может быть указан по имени (атому)или по имени файла.</target>
        </trans-unit>
        <trans-unit id="4d45b4986dc3244ccb1e4bc16129b111cc4334f7" translate="yes" xml:space="preserve">
          <source>A module can export some types to declare that other modules are allowed to refer to them as &lt;strong&gt;remote types&lt;/strong&gt;. This declaration has the following form:</source>
          <target state="translated">Модуль может экспортировать некоторые типы, чтобы объявить, что другим модулям разрешено ссылаться на них как на &lt;strong&gt;удаленные типы&lt;/strong&gt; . Это заявление имеет следующий вид:</target>
        </trans-unit>
        <trans-unit id="c7142355abe56d1cdac6e2f4354e4ece086ad515" translate="yes" xml:space="preserve">
          <source>A module can use data generated by previous modules in the Erlang webserver API module sequence or generate data to be used by consecutive Erlang Web Server API modules. This is possible owing to an internal list of key-value tuples, referred to as interaction data.</source>
          <target state="translated">Модуль может использовать данные,сгенерированные предыдущими модулями в последовательности API модулей веб-сервера Erlang или генерировать данные для использования последовательными API модулями веб-сервера Erlang.Это возможно благодаря внутреннему списку кортежей со значениями ключей,называемых данными взаимодействия.</target>
        </trans-unit>
        <trans-unit id="18900dbf59944d973af029df61cc566921cfdcc4" translate="yes" xml:space="preserve">
          <source>A module contains an &lt;code&gt;-on_load function&lt;/code&gt;.</source>
          <target state="translated">Модуль содержит функцию &lt;code&gt;-on_load function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93157c2c246b2925926264e6f2195084f98fb551" translate="yes" xml:space="preserve">
          <source>A module declaration consists of a sequence of forms, which are either function declarations or attributes.</source>
          <target state="translated">Модульная декларация состоит из последовательности форм,которые являются либо декларациями функций,либо атрибутами.</target>
        </trans-unit>
        <trans-unit id="610a0d8699dc82d5f83c6e9ce3301c3d01553b3b" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour. The info functions of this module will be called at various stages of delivery.</source>
          <target state="translated">Модуль, реализующий поведение &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; . Информационные функции этого модуля будут вызываться на разных этапах доставки.</target>
        </trans-unit>
        <trans-unit id="c6984ab40887600f2a1370e3539c8ccdba1c5de4" translate="yes" xml:space="preserve">
          <source>A module is included more than once in &lt;code&gt;Modules&lt;/code&gt;.</source>
          <target state="translated">Модуль входит в &lt;code&gt;Modules&lt;/code&gt; более одного раза .</target>
        </trans-unit>
        <trans-unit id="cd8890dc272bd36c3a480c734c6925501fff4e99" translate="yes" xml:space="preserve">
          <source>A module specified as a &lt;code&gt;transport_module&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; must implement the interface documented here. The interface consists of a function with which diameter starts a transport process and a message interface with which the transport process communicates with the process that starts it (aka its parent).</source>
          <target state="translated">Модуль, указанный как &lt;code&gt;transport_module&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; должен реализовывать интерфейс, описанный здесь. Интерфейс состоит из функции, с помощью которой диаметр запускает транспортный процесс, и интерфейса сообщений, с помощью которого транспортный процесс взаимодействует с процессом, который его запускает (он же родительский).</target>
        </trans-unit>
        <trans-unit id="492b06093c2441b11284458e2b4d042f4ba5283d" translate="yes" xml:space="preserve">
          <source>A monitor can be removed by calling &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt;.</source>
          <target state="translated">Монитор можно удалить, вызвав &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c985866a716b1f38553284b766cb9d078544843" translate="yes" xml:space="preserve">
          <source>A monitor created as &lt;code&gt;unloaded_only&lt;/code&gt; behaves exactly as one created as &lt;code&gt;unloaded&lt;/code&gt; except that the &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; message is never sent, but the monitor instead persists until the driver &lt;strong&gt;really&lt;/strong&gt; gets unloaded.</source>
          <target state="translated">Монитор, созданный как &lt;code&gt;unloaded_only&lt;/code&gt; , ведет себя точно так же, как созданный как &lt;code&gt;unloaded&lt;/code&gt; , за исключением того, что сообщение &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; никогда не отправляется, а вместо этого монитор продолжает работать до тех пор, пока драйвер &lt;strong&gt;действительно не&lt;/strong&gt; будет выгружен.</target>
        </trans-unit>
        <trans-unit id="1f4b0ba77513970218ad1a2b88d07cb4eef5317e" translate="yes" xml:space="preserve">
          <source>A monitor from &lt;code&gt;To&lt;/code&gt; to &lt;code&gt;Result&lt;/code&gt; was set up on the node where &lt;code&gt;Result&lt;/code&gt; resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcac2207e183cb309e308e8c36f24d54ce1572c" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e224d8a9f9c0d94e691cbfa15fef0b1fe2f4e60f" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Монотонно увеличивающееся время, обеспечиваемое системой времени выполнения Erlang. Монотонное время Эрланга увеличивается с некоторого неопределенного момента времени. Чтобы получить его, вызовите &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcff3bd090752a02621fd3d2ad9e629fddd5e95" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the OS. This time does not leap and has a relatively steady frequency although not completely correct. However, it is not uncommon that OS monotonic time stops if the system is suspended. This time typically increases since some unspecified point in time that is not connected to &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. This type of time is not necessarily provided by all OSs.</source>
          <target state="translated">Монотонно увеличивающееся время, предоставляемое ОС. Это время без скачков и имеет относительно стабильную частоту, хотя и не совсем правильную. Однако не редкость, что монотонное время ОС останавливается, если система приостановлена. Это время обычно увеличивается с некоторого неопределенного момента времени, который не связан с &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; . Этот тип времени не обязательно предоставляется всеми ОС.</target>
        </trans-unit>
        <trans-unit id="5712c1400575e91c9656e681e7475784bdfd9eda" translate="yes" xml:space="preserve">
          <source>A more complicated example with two quad core processors, each processor in its own NUMA node. The ordering of logical processors is a bit weird. This to give a better example of identifier lists:</source>
          <target state="translated">Более сложный пример с двумя четырёхъядерными процессорами,каждый процессор в своём узле NUMA.Порядок расположения логических процессоров немного странный.Это для того,чтобы привести лучший пример списков идентификаторов:</target>
        </trans-unit>
        <trans-unit id="a0d3ff79b050cf4e67f5f12480ec66e526e82e53" translate="yes" xml:space="preserve">
          <source>A more detailed internal representation of the state of this process.</source>
          <target state="translated">Более подробное внутреннее представление состояния этого процесса.</target>
        </trans-unit>
        <trans-unit id="2c7b4f8b72fc3001a39709ba6f707df737f50704" translate="yes" xml:space="preserve">
          <source>A more explicit way to cancel a timer is to use a &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; on the form &lt;code&gt; {TimeoutType, cancel} &lt;/code&gt; which is a feature introduced in OTP 22.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c43b55cc6e4ec72f53a82fa0f070f9038b700e" translate="yes" xml:space="preserve">
          <source>A more precise language for MIB specification</source>
          <target state="translated">Более точный язык для спецификации MIB</target>
        </trans-unit>
        <trans-unit id="d9a6a54885c00dec728fc7fc51d18dd588db7351" translate="yes" xml:space="preserve">
          <source>A more refined version of this format handler is function &lt;code&gt;handle_gc/4&lt;/code&gt; in module &lt;code&gt;multitrace.erl&lt;/code&gt; included in directory &lt;code&gt;src&lt;/code&gt; of the Observer application.</source>
          <target state="translated">Более усовершенствованная версия этого обработчика формата - это функция &lt;code&gt;handle_gc/4&lt;/code&gt; в модуле &lt;code&gt;multitrace.erl&lt;/code&gt; , включенном в каталог &lt;code&gt;src&lt;/code&gt; приложения Observer.</target>
        </trans-unit>
        <trans-unit id="5d37f040ad3ea680b60e046bb149872d221815ff" translate="yes" xml:space="preserve">
          <source>A multi-lingual SNMP manager.</source>
          <target state="translated">Многоязычный менеджер SNMP.</target>
        </trans-unit>
        <trans-unit id="9e37a488733c4647d4a17da583fd3b03c8d0d81b" translate="yes" xml:space="preserve">
          <source>A name (an Erlang atom) associated with a data value read from a configuration file.</source>
          <target state="translated">Имя (атом Erlang),связанное со значением данных,считанных из конфигурационного файла.</target>
        </trans-unit>
        <trans-unit id="2416bd3c84f93d0172f4762c1b29e0836c7a7539" translate="yes" xml:space="preserve">
          <source>A name and association to configuration data introduced through a require statement, or a call to &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt;.</source>
          <target state="translated">Имя и связь с данными конфигурации, введенными посредством оператора require или вызова &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; , например, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a56d53bccebb00764e45b858a26b5ebf2ade91" translate="yes" xml:space="preserve">
          <source>A name constructed from the name of the function in which they are created</source>
          <target state="translated">Имя,построенное из названия функции,в которой они созданы.</target>
        </trans-unit>
        <trans-unit id="ccf5e0e4e127bfae4bef5668c5a9b13172a11e7a" translate="yes" xml:space="preserve">
          <source>A name for the data must be allocated in the suite using &lt;code&gt;require&lt;/code&gt; (see the example above). Pass this name as argument &lt;code&gt;SnmpAppConfName&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_snmp&lt;/code&gt; specifies default values for some &lt;code&gt;SNMP&lt;/code&gt; application configuration parameters (such as &lt;code&gt;{verbosity,trace}&lt;/code&gt; for parameter &lt;code&gt;config&lt;/code&gt;). This set of defaults is merged with the parameters specified by the user. The user values override &lt;code&gt;ct_snmp&lt;/code&gt; defaults.</source>
          <target state="translated">Имя для данных должно быть выделено в наборе с помощью &lt;code&gt;require&lt;/code&gt; (см. Пример выше). Передайте это имя в качестве аргумента &lt;code&gt;SnmpAppConfName&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ct_snmp&lt;/code&gt; задает значения по умолчанию для некоторых параметров конфигурации приложения &lt;code&gt;SNMP&lt;/code&gt; (например, &lt;code&gt;{verbosity,trace}&lt;/code&gt; для параметра &lt;code&gt;config&lt;/code&gt; ). Этот набор значений по умолчанию объединяется с параметрами, указанными пользователем. Пользовательские значения переопределяют &lt;code&gt;ct_snmp&lt;/code&gt; умолчанию ct_snmp .</target>
        </trans-unit>
        <trans-unit id="5489bf9abf580e46c80a7d46f5c6b357c56bfd5f" translate="yes" xml:space="preserve">
          <source>A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique.</source>
          <target state="translated">С этим глаголом всегда требуется имя.В шаблоне может быть столько экземпляров (*MARK),сколько вам нравится,и их имена не обязательно должны быть уникальными.</target>
        </trans-unit>
        <trans-unit id="37561d5bd1b8f3c3ed788a8368cee35cffb7641d" translate="yes" xml:space="preserve">
          <source>A native function doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">Собственная функция, выполняющая &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; перед возвратом, ухудшает отзывчивость виртуальной машины и может вызывать разные странные поведения. Такое странное поведение включает, помимо прочего, чрезмерное использование памяти и плохую балансировку нагрузки между планировщиками. Странное поведение, которое может возникнуть из-за длительной работы, также может различаться между выпусками Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="054cf9ceb563ed6f90ffbc9bbce068da6480e085" translate="yes" xml:space="preserve">
          <source>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the native function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">Собственная функция выполняется как прямое расширение собственного кода виртуальной машины. Казнь не производится в безопасных условиях. Виртуальная машина &lt;strong&gt;не может&lt;/strong&gt; предоставлять те же услуги, которые предоставляются при выполнении кода Erlang, такие как упреждающее планирование или защита памяти. Если собственная функция не работает должным образом, вся виртуальная машина будет вести себя неправильно.</target>
        </trans-unit>
        <trans-unit id="5d7156f3c126c629744aa907155b989bd0af5b92" translate="yes" xml:space="preserve">
          <source>A native function that crash will crash the whole VM.</source>
          <target state="translated">Нативная функция,которая аварийно завершает работу всей ВМ.</target>
        </trans-unit>
        <trans-unit id="1b2752eee15054c7525aaed65d65bee26e41c9b7" translate="yes" xml:space="preserve">
          <source>A native function that crashes will crash the whole VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a596b85ce60a4ebd518468dd4ada66946ee5ba8d" translate="yes" xml:space="preserve">
          <source>A native signed 64-bit integer type.</source>
          <target state="translated">Нативный знаковый 64-битный целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="d333b99d2c176e6cef29cdbe662fff2fc82351f6" translate="yes" xml:space="preserve">
          <source>A native unsigned 64-bit integer type.</source>
          <target state="translated">Нативный 64-битный целочисленный беззнаковый тип.</target>
        </trans-unit>
        <trans-unit id="1a25fa736ef55d7f9c1d89a3af60f13910153e4c" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;WindowBits&lt;/code&gt; value makes zlib ignore the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">Отрицательное значение &lt;code&gt;WindowBits&lt;/code&gt; заставляет zlib игнорировать заголовок zlib (и контрольную сумму) из потока. Обратите внимание, что в источнике zlib это упоминается только как недокументированная функция.</target>
        </trans-unit>
        <trans-unit id="bff6f239743ba458b6fef3d31577263304f30dcc" translate="yes" xml:space="preserve">
          <source>A negative length can be used to extract bytes at the end of a binary:</source>
          <target state="translated">Отрицательная длина может быть использована для извлечения байтов в конце двоичного файла:</target>
        </trans-unit>
        <trans-unit id="6a5647dc70e502438e63ae1f528d8168602285f6" translate="yes" xml:space="preserve">
          <source>A negative response can look as follows:</source>
          <target state="translated">Отрицательная реакция может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="acfd9f30ed035c8f515380634a9f49e2e6305307" translate="yes" xml:space="preserve">
          <source>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">Отрицательное значение заставляет систему времени выполнения ждать неопределенное время, пока файл аварийного дампа не будет полностью записан. Это значение по умолчанию , если параметр &lt;code&gt;-heart&lt;/code&gt; это &lt;strong&gt;не&lt;/strong&gt; передается &lt;code&gt;erl&lt;/code&gt; и &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; не установлен.</target>
        </trans-unit>
        <trans-unit id="9ad2ef1372f693b05aa57e2e774e90e14b42ac7f" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation.</source>
          <target state="translated">Фильтр сетевого интерфейса может использоваться,например,во время испытаний или для регулирования нагрузки.</target>
        </trans-unit>
        <trans-unit id="0081be6ade151701784fff921945a2cc10ab3867" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;&lt;a href=&quot;snmp_config#agent_ni_req_limit&quot;&gt;req_limit&lt;/a&gt;&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5da2ab0a310bd02dc005df1f2a390906381786a" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;req_limit&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Фильтр сетевого интерфейса можно использовать, например, во время тестирования или для регулирования нагрузки. Если предполагаемое использование - регулирование нагрузки, см. Также &lt;code&gt;req_limit&lt;/code&gt; и функцию &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a37e856dd2d89d23cca0a3d2993676ef15b297" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;person&lt;/code&gt; record is created as follows:</source>
          <target state="translated">Запись нового &lt;code&gt;person&lt;/code&gt; создается следующим образом:</target>
        </trans-unit>
        <trans-unit id="0cb57df1a585271753d77c0b683d96263a8aeb0a" translate="yes" xml:space="preserve">
          <source>A new boot script was generated, without the &lt;code&gt;local&lt;/code&gt; option set, before the release package was made. In the release package, all application directories are placed under &lt;code&gt;lib&lt;/code&gt;. You do not know where the release package will be installed, so no hard-coded absolute paths are allowed.</source>
          <target state="translated">Перед созданием пакета выпуска был сгенерирован новый сценарий загрузки без установленной &lt;code&gt;local&lt;/code&gt; опции. В пакете выпуска все каталоги приложений помещены в &lt;code&gt;lib&lt;/code&gt; . Вы не знаете, где будет установлен пакет выпуска, поэтому жестко заданные абсолютные пути не допускаются.</target>
        </trans-unit>
        <trans-unit id="207531ae5013e77eabff64456ffa724e18f8f181" translate="yes" xml:space="preserve">
          <source>A new config file format was introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd3d52715f74b16be431ae39bdcad7432af2c3a" translate="yes" xml:space="preserve">
          <source>A new interface &lt;code&gt;delete/1&lt;/code&gt; is now added to handle the case when a process wants to discard an index table (i.e. to build a completely new). Any application using transient snmp indexes has to be modified to handle this.</source>
          <target state="translated">Теперь добавлен новый интерфейс &lt;code&gt;delete/1&lt;/code&gt; для обработки случая, когда процесс хочет отбросить индексную таблицу (т.е. построить полностью новую). Любое приложение, использующее временные индексы snmp, должно быть изменено, чтобы справиться с этим.</target>
        </trans-unit>
        <trans-unit id="f3852a09c1ed59005d5821e005f965364a5620d8" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt; on the node &lt;code&gt;Node&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7813433a94ab5122a108632d44422a9630945f8c" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Новый процесс запускается приложением &lt;code&gt;Module:Function&lt;/code&gt; к &lt;code&gt;Args&lt;/code&gt; . Одновременно отслеживается процесс. Возвращает идентификатор процесса и ссылку на монитор. В противном случае работает как &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c6aeb17dbb1f994107439b1a93fe0bdeabaadd7" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value and &lt;code&gt;OldRecords&lt;/code&gt; contains the records before the operation is performed. Notice that the new content depends on the table type.</source>
          <target state="translated">Написан новый рекорд. &lt;code&gt;NewRecord&lt;/code&gt; содержит новое значение записи, а &lt;code&gt;OldRecords&lt;/code&gt; содержит записи до выполнения операции. Обратите внимание, что новое содержимое зависит от типа таблицы.</target>
        </trans-unit>
        <trans-unit id="eecdd1aca65c090cd037cecb43b60372b3e2d23d" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value.</source>
          <target state="translated">Написан новый рекорд. &lt;code&gt;NewRecord&lt;/code&gt; содержит новое значение записи.</target>
        </trans-unit>
        <trans-unit id="45c9322699414697ef1b7c8765e8214aef90bc96" translate="yes" xml:space="preserve">
          <source>A new tuple with the tag &lt;code&gt;available_memory&lt;/code&gt; will be added to the result when this value is provided by the kernel. The &lt;code&gt;available_memory&lt;/code&gt; value informs about the amount memory that is available for use if there is an increased memory need. This value is not based on a calculation of the other provided values and should give a better value of the amount of memory that actually is available than calculating a value based on the other values reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbee27c7629c70c521974bc4a2ef6365b44965e" translate="yes" xml:space="preserve">
          <source>A new version of the &lt;code&gt;ch_app.app&lt;/code&gt; file must now be created, where the version is updated:</source>
          <target state="translated">Теперь необходимо создать новую версию файла &lt;code&gt;ch_app.app&lt;/code&gt; , в которой версия обновлена:</target>
        </trans-unit>
        <trans-unit id="207842ca1ef434b687fe891079409854db11ce8f" translate="yes" xml:space="preserve">
          <source>A newline convention can also be specified by starting a pattern string with one of the following five sequences:</source>
          <target state="translated">Новое соглашение может быть также задано путем запуска строки шаблона с одной из следующих пяти последовательностей:</target>
        </trans-unit>
        <trans-unit id="810a5966eb1e7ee3bb3f54687643fa10446c0bcc" translate="yes" xml:space="preserve">
          <source>A newly spawned Erlang process uses 309 words of memory in the non-SMP emulator without HiPE support. (SMP support and HiPE support both add to this size.) The size can be found as follows:</source>
          <target state="translated">Недавно созданный процесс Erlang использует 309 слов памяти в не-SMP эмуляторе без поддержки HiPE.(поддержка SMP и поддержка HiPE добавляют к этому размеру.)Размер можно найти следующим образом:</target>
        </trans-unit>
        <trans-unit id="1297f35b745c72bd20c54efe3dd92735d746a15b" translate="yes" xml:space="preserve">
          <source>A newly started erlang shell shows that no &lt;code&gt;'ssh-dss'&lt;/code&gt; is present in the &lt;code&gt;public_key&lt;/code&gt; entry:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c8c9ea0c1555c71b7dd9ae8ee6da8f6b7d0bc2" translate="yes" xml:space="preserve">
          <source>A nice feature is that a test specification that includes node information can still be used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server (as described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;). The result is that any test specified to run on a node with the same name as the &lt;code&gt;Common Test&lt;/code&gt; node in question (typically &lt;code&gt;ct@somehost&lt;/code&gt; if started with the &lt;code&gt;ct_run&lt;/code&gt; program), is performed. Tests without explicit node association are always performed too, of course.</source>
          <target state="translated">Приятной особенностью является то, что спецификацию теста, включающую информацию об узлах, можно по-прежнему использовать в качестве входных данных для обычного сервера &lt;code&gt;Common Test&lt;/code&gt; (как описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; ). В результате выполняется любой тест, указанный для запуска на узле с тем же именем, что и рассматриваемый узел &lt;code&gt;Common Test&lt;/code&gt; (обычно &lt;code&gt;ct@somehost&lt;/code&gt; если запускается с &lt;code&gt;ct_run&lt;/code&gt; программы ct_run ). Конечно, всегда выполняются тесты без явной привязки узлов.</target>
        </trans-unit>
        <trans-unit id="7ee9953adae41a7655f8d2084b4fa873e00e82bf" translate="yes" xml:space="preserve">
          <source>A node can crash (probably a buggy one, hence traced). Use &lt;code&gt;resume&lt;/code&gt; to resume tracing on the node automatically when it gets back. The failing node then tries to reconnect to trace control node when &lt;code&gt;Runtime_Tools&lt;/code&gt; is started. This implies that &lt;code&gt;Runtime_Tools&lt;/code&gt; must be included in the startup chain of other nodes (if not, you can still resume tracing by starting &lt;code&gt;Runtime_Tools&lt;/code&gt; manually, that is, by an RPC call).</source>
          <target state="translated">Узел может аварийно завершить работу (возможно, с ошибкой, поэтому отслеживается). Используйте &lt;code&gt;resume&lt;/code&gt; для автоматического возобновления трассировки на узле, когда он вернется. Затем отказавший узел пытается повторно подключиться к узлу управления трассировкой при &lt;code&gt;Runtime_Tools&lt;/code&gt; . Это означает, что &lt;code&gt;Runtime_Tools&lt;/code&gt; должен быть включен в цепочку запуска других узлов (если нет, вы все равно можете возобновить трассировку, запустив &lt;code&gt;Runtime_Tools&lt;/code&gt; вручную, то есть с помощью вызова RPC).</target>
        </trans-unit>
        <trans-unit id="e9ed4743bc1cec802b20617a0fd885483b2dd9dc" translate="yes" xml:space="preserve">
          <source>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</source>
          <target state="translated">Узел получает номер порта другого узла через EPMD (на другом узле),чтобы инициировать запрос на соединение.</target>
        </trans-unit>
        <trans-unit id="4faa439d4cf9e40f5ce1dc04ca048d241e286cf4" translate="yes" xml:space="preserve">
          <source>A node of type &lt;code&gt;map_expr&lt;/code&gt; is a leaf node if and only if it has no argument and no fields. A node of type &lt;code&gt;map_type&lt;/code&gt; is a leaf node if and only if it has no fields (&lt;code&gt;any_size&lt;/code&gt;). A node of type &lt;code&gt;tuple&lt;/code&gt; is a leaf node if and only if its arity is zero. A node of type &lt;code&gt;tuple_type&lt;/code&gt; is a leaf node if and only if it has no elements (&lt;code&gt;any_size&lt;/code&gt;).</source>
          <target state="translated">Узел типа &lt;code&gt;map_expr&lt;/code&gt; является листовым узлом тогда и только тогда, когда у него нет аргументов и полей. Узел типа &lt;code&gt;map_type&lt;/code&gt; является листовым узлом тогда и только тогда, когда он не имеет полей ( &lt;code&gt;any_size&lt;/code&gt; ). Узел типа &lt;code&gt;tuple&lt;/code&gt; является листовым тогда и только тогда, когда его арность равна нулю. Узел типа &lt;code&gt;tuple_type&lt;/code&gt; является листовым узлом тогда и только тогда, когда он не имеет элементов ( &lt;code&gt;any_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb52c93cebdeac0dab7fcc67ec63e9553ad8a863" translate="yes" xml:space="preserve">
          <source>A node running on Windows can only start slave nodes on the host on which it is running.</source>
          <target state="translated">Узел,работающий под управлением Windows,может запускать подчиненные узлы только на том узле,на котором он запущен.</target>
        </trans-unit>
        <trans-unit id="9d21f5fbd84596b473f63ef2991ce0e43cba7cfb" translate="yes" xml:space="preserve">
          <source>A node started in this way is fully functional, using TLS as the distribution protocol.</source>
          <target state="translated">Узел,запущенный таким образом,полностью функционален,используя TLS в качестве протокола распределения.</target>
        </trans-unit>
        <trans-unit id="fc7f66a0ac45a7c84f0bb5f9e9d30342b7788580" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using SSL/TLS distribution over IPv6.</source>
          <target state="translated">Узел,запущенный таким образом,сможет взаимодействовать с другими узлами только с помощью распространения SSL/TLS по протоколу IPv6.</target>
        </trans-unit>
        <trans-unit id="943b5fd70c0828774c26840cbeb96989a96b92f2" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using TLS distribution over IPv6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e879d0b785427426139719e5c9dfe725a5b841" translate="yes" xml:space="preserve">
          <source>A node started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; (see &lt;code&gt;erl(1)&lt;/code&gt;) is said to be a &lt;strong&gt;hidden&lt;/strong&gt; node. A hidden node establishes hidden connections to nodes not part of the same global group, but normal (visible) connections to nodes part of the same global group.</source>
          <target state="translated">Узел, запущенный с флагом командной строки &lt;code&gt;-hidden&lt;/code&gt; (см. &lt;code&gt;erl(1)&lt;/code&gt; ), называется &lt;strong&gt;скрытым&lt;/strong&gt; узлом. Скрытый узел устанавливает скрытые соединения с узлами, не входящими в одну и ту же глобальную группу, а обычные (видимые) соединения с узлами, входящими в одну и ту же глобальную группу.</target>
        </trans-unit>
        <trans-unit id="20c980faeffa1454b2f85d7502b23e1c0b0103b4" translate="yes" xml:space="preserve">
          <source>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</source>
          <target state="translated">Узел сам удаляется из EPMD,закрывая TCP-соединение с EPMD,установленное при регистрации узла.</target>
        </trans-unit>
        <trans-unit id="d42befae27c8be5c2d1b9032dc8b9a0535e6021b" translate="yes" xml:space="preserve">
          <source>A node with a long node name cannot communicate with a node with a short node name.</source>
          <target state="translated">Узел с длинным именем не может взаимодействовать с узлом с коротким именем.</target>
        </trans-unit>
        <trans-unit id="5608a2aa0096e2c431c4d688274c5bfed3dfbe6a" translate="yes" xml:space="preserve">
          <source>A node with name &lt;code&gt;Name@Host&lt;/code&gt; already exists.</source>
          <target state="translated">Узел с именем &lt;code&gt;Name@Host&lt;/code&gt; уже существует.</target>
        </trans-unit>
        <trans-unit id="9de4833cf4636cc7347017906607c0375ae36fb9" translate="yes" xml:space="preserve">
          <source>A non-local return from a function. If evaluated within a &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; returns value &lt;code&gt;Any&lt;/code&gt;. Example:</source>
          <target state="translated">Нелокальный возврат из функции. Если вычислено в пределах &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; возвращает значение &lt;code&gt;Any&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="3104d91a116c49b17930265301a213974b99a618" translate="yes" xml:space="preserve">
          <source>A non-terminal category can be used at the left hand side (= &lt;code&gt;lhs&lt;/code&gt;, or &lt;code&gt;head&lt;/code&gt;) of a grammar rule. It can also appear at the right hand side of rules.</source>
          <target state="translated">Нетерминальная категория может быть использована на левой стороне (= &lt;code&gt;lhs&lt;/code&gt; , или &lt;code&gt;head&lt;/code&gt; ) из правила грамматики. Он также может отображаться в правой части правил.</target>
        </trans-unit>
        <trans-unit id="522676de41bafa253c8f310dce88c669f1124e1c" translate="yes" xml:space="preserve">
          <source>A nonempty list &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; of syntax trees. This is equivalent to passing &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt;.</source>
          <target state="translated">Непустой список &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; синтаксических деревьев. Это эквивалентно переходу &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a728b05450ce93eb12d475c06f9983d66527797f" translate="yes" xml:space="preserve">
          <source>A nonempty list of lists of syntax trees &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt;, which is equivalent to passing &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt;.</source>
          <target state="translated">Непустой список списков синтаксических деревьев &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt; , что эквивалентно передаче &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfe0accad3b0782ec5f58066cb4e83f925efd4a7" translate="yes" xml:space="preserve">
          <source>A normal file is really a process so it can be used as an I/O device (see &lt;code&gt;io&lt;/code&gt;). Therefore, when data is written to a normal file, the sending of the data to the file process, copies all data that are not binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the file is opened on another node, or if the file server runs as slave to the file server of another node, also binaries are copied.</source>
          <target state="translated">Обычный файл - это действительно процесс, поэтому его можно использовать как устройство ввода-вывода (см. &lt;code&gt;io&lt;/code&gt; ). Поэтому, когда данные записываются в обычный файл, при отправке данных в файловый процесс копируются все данные, которые не являются двоичными. Поэтому рекомендуется открыть файл в двоичном режиме и записать двоичные файлы. Если файл открыт на другом узле или если файловый сервер работает как подчиненный файлового сервера другого узла, также копируются двоичные файлы.</target>
        </trans-unit>
        <trans-unit id="c470da7bdfad13769766d01b29332c73881e0c5a" translate="yes" xml:space="preserve">
          <source>A normal installation of Windows NT 4.0, with Service Pack 4 or later, is required for an embedded Windows NT running OTP.</source>
          <target state="translated">Обычная установка Windows NT 4.0 с пакетом обновления 4 или более поздней версии требуется для встроенной Windows NT,работающей по протоколу OTP.</target>
        </trans-unit>
        <trans-unit id="b9be4139254b3d41e2b3331c9e7f9cdccd473c9d" translate="yes" xml:space="preserve">
          <source>A normal scheduler thread.</source>
          <target state="translated">Обычный поток планировщика.</target>
        </trans-unit>
        <trans-unit id="1ba3e6a43cfdf42b7ee92131fc56ef43d47532de" translate="yes" xml:space="preserve">
          <source>A notable return value is &lt;code&gt;{error, closed}&lt;/code&gt; indicating that the socket is closed.</source>
          <target state="translated">Примечательным возвращаемым значением является &lt;code&gt;{error, closed}&lt;/code&gt; указывающее, что сокет закрыт.</target>
        </trans-unit>
        <trans-unit id="3b3bb227d33cdecc5e31e4a78df3f54b111efcf9" translate="yes" xml:space="preserve">
          <source>A notation that tells which part of the type to be decoded</source>
          <target state="translated">Примечание,которое указывает,какая часть типа должна быть декодирована.</target>
        </trans-unit>
        <trans-unit id="d7dc1e195006c9ad7d9414abaacea8ee8034b8fa" translate="yes" xml:space="preserve">
          <source>A notation that tells which parts of the message structure to be excluded from decode</source>
          <target state="translated">Примечание,указывающее,какие части структуры сообщения должны быть исключены из декодирования.</target>
        </trans-unit>
        <trans-unit id="027b96af0679f806c12b49fa73f516241d045fca" translate="yes" xml:space="preserve">
          <source>A note of warning: Igor cannot do anything about the case when the name of a remote function is passed to the built-in functions &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;spawn&lt;/code&gt;&lt;strong&gt;unless&lt;/strong&gt; the module and function names are explicitly stated in the call, as in e.g. &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt;. In all other cases, Igor leaves such calls unchanged, and warns the user that manual editing might be necessary.</source>
          <target state="translated">Примечание к предупреждению: Игорь не может ничего сделать в случае, когда имя удаленной функции передается встроенным функциям &lt;code&gt;apply&lt;/code&gt; и &lt;code&gt;spawn&lt;/code&gt; ,&lt;strong&gt;если&lt;/strong&gt; имена модуля и функции явно не указаны в вызове, как, например, в &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt; . Во всех остальных случаях Игорь оставляет такие вызовы без изменений и предупреждает пользователя, что может потребоваться ручное редактирование.</target>
        </trans-unit>
        <trans-unit id="bb34c061995c9bd9c3bf3fd5336b0597518696e6" translate="yes" xml:space="preserve">
          <source>A notification filter is a module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; behaviour. A filter is added/deleted using the functions: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Фильтр уведомлений - это модуль, реализующий поведение &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; . Фильтр добавляется / удаляется с помощью функций: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23a7337393f51adec78486c788d793b331d07279" translate="yes" xml:space="preserve">
          <source>A nullary functional value (i.e., a fun that takes zero arguments). Examples:</source>
          <target state="translated">Нулевое функциональное значение (т.е.веселье,которое принимает нулевые аргументы).Примеры:</target>
        </trans-unit>
        <trans-unit id="e5362e0c25c0703bb5ca7c53501e9fabd30aa894" translate="yes" xml:space="preserve">
          <source>A number (starting with 0) indicating the number of that fun within that function</source>
          <target state="translated">Номер (начинающийся с 0),указывающий на количество этого удовольствия в рамках этой функции.</target>
        </trans-unit>
        <trans-unit id="cf27cfd569963d1d3e948b114051da6fdcf3d00a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Thoose objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для работы приложения SSH необходимо наличие ряда объектов. Выбранные объекты по умолчанию хранятся в файлах. Имена, пути и форматы файлов по умолчанию такие же, как для &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; . Ключи могут быть созданы с помощью программы &lt;code&gt;ssh-keygen&lt;/code&gt; из OpenSSH. См. &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba15943266d8f4ba14bfaf35d8549aabc72bd73a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Those objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c32086c997452421cf26bca4ec5f8f37980a88f" translate="yes" xml:space="preserve">
          <source>A one-line description of the application.</source>
          <target state="translated">Однострочное описание приложения.</target>
        </trans-unit>
        <trans-unit id="7676e10e4c0c5db81948c82045b717673602dd63" translate="yes" xml:space="preserve">
          <source>A one-shot timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; is not linked to any process. Hence, such a timer is removed only when it reaches its time-out, or if it is explicitly removed by a call to &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt; таймер, то есть таймер, созданный путем оценки любой из функций apply_after / 4 , &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; , не связан с любой процесс. Следовательно, такой таймер удаляется только тогда, когда он достигает своего тайм-аута, или если он явно удаляется вызовом &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652f0a6b7da70ccce812924b966b0be33a66985d" translate="yes" xml:space="preserve">
          <source>A packet is a line-terminated by a delimiter byte, default is the latin-1 newline character. The delimiter byte is included in the returned packet unless the line was truncated according to option &lt;code&gt;line_length&lt;/code&gt;.</source>
          <target state="translated">Пакет - это строка, оканчивающаяся байтом-разделителем, по умолчанию - символ новой строки latin-1. Байт-разделитель включается в возвращаемый пакет, если строка не была усечена в соответствии с опцией &lt;code&gt;line_length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="243cae021af59d36fb2ba67a11310414b8344606" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt;, where &lt;code&gt;LineNumber&lt;/code&gt; is a nonnegative integer and &lt;code&gt;SimpleTest&lt;/code&gt; is another simple test object. &lt;code&gt;LineNumber&lt;/code&gt; should indicate the source line of the test. Pairs like this are usually only created via &lt;code&gt;?_test(...)&lt;/code&gt; macros; see &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Пара &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt; , где &lt;code&gt;LineNumber&lt;/code&gt; - неотрицательное целое число, а &lt;code&gt;SimpleTest&lt;/code&gt; - еще один простой тестовый объект. &lt;code&gt;LineNumber&lt;/code&gt; должен указывать на исходную строку теста. &lt;code&gt;?_test(...)&lt;/code&gt; пары обычно создаются только с помощью макросов? _Test (...) ; см. &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="defb50c3733240a6d3613348a3d9ea0d5e3378d6" translate="yes" xml:space="preserve">
          <source>A parallel test case has a private I/O server as its group leader. (For a description of the group leader concept, see &lt;code&gt;ERTS&lt;/code&gt;). The central I/O server process, which handles the output from regular test cases and configuration functions, does not respond to I/O messages during execution of parallel groups. This is important to understand to avoid certain traps, like the following:</source>
          <target state="translated">Параллельный тестовый пример имеет частный сервер ввода-вывода в качестве лидера группы. (Описание концепции лидера группы см. В &lt;code&gt;ERTS&lt;/code&gt; ). Процесс центрального сервера ввода-вывода, который обрабатывает выходные данные из обычных тестовых примеров и функций конфигурации, не отвечает на сообщения ввода-вывода во время выполнения параллельных групп. Это важно понимать, чтобы избежать определенных ловушек, например следующих:</target>
        </trans-unit>
        <trans-unit id="59ee8343e4e789ac929459cd04d582cafeb246fb" translate="yes" xml:space="preserve">
          <source>A parameterized type is to be considered as an embedded type. Each time such a type is referenced, an instance of it is defined. Thus, in the following example a record with name &lt;code&gt;'Seq_b'&lt;/code&gt; is generated in the &lt;code&gt;.hrl&lt;/code&gt; file and is used to hold values:</source>
          <target state="translated">Параметризованный тип следует рассматривать как встроенный. Каждый раз, когда на такой тип ссылаются, определяется его экземпляр. Таким образом, в следующем примере запись с именем &lt;code&gt;'Seq_b'&lt;/code&gt; генерируется в &lt;code&gt;.hrl&lt;/code&gt; файл и используется для значений трюмов:</target>
        </trans-unit>
        <trans-unit id="024ff9d111af56355737a8c26860d8a633650503" translate="yes" xml:space="preserve">
          <source>A parenthesized subpattern (including assertions)</source>
          <target state="translated">Подмаска в скобках (включая утверждения).</target>
        </trans-unit>
        <trans-unit id="3ea3805acd22f42cb11f366b367ef59a1e1dc7d4" translate="yes" xml:space="preserve">
          <source>A parse transformation that translates fun syntax into match specifications.</source>
          <target state="translated">Преобразование разбора,которое переводит синтаксис веселья в спецификации на соответствие.</target>
        </trans-unit>
        <trans-unit id="991f645ed0dc31daba5645f487f69d46fc37f314" translate="yes" xml:space="preserve">
          <source>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Частичный сбой доставки. В текущей реализации привязки Erlang / SCTP это событие внутренне преобразуется в термин &lt;code&gt;error&lt;/code&gt; возвращаемый &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb726df29d93231b466c44dbe8038aa91fcb314b" translate="yes" xml:space="preserve">
          <source>A pattern can be selected to narrow the profiling. For instance a specific module can be selected, and only the code executed in that module will be profiled.</source>
          <target state="translated">Деталь можно выбрать,чтобы сузить профилирование.Например,можно выбрать конкретный модуль,и профилировать будет только код,выполняемый в этом модуле.</target>
        </trans-unit>
        <trans-unit id="387373efa88307dec031353d353693de37d89f74" translate="yes" xml:space="preserve">
          <source>A pattern for an instruction consists of its name, followed by a pattern for each of its operands. The operand patterns are separated by spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67b6c7226586d1f049336989af73704b318b899" translate="yes" xml:space="preserve">
          <source>A pattern has the same structure as a term but can contain unbound variables.</source>
          <target state="translated">Шаблон имеет ту же структуру,что и термин,но может содержать несвязанные переменные.</target>
        </trans-unit>
        <trans-unit id="430efb2a85da18740aa7226ea60c97fb378ca179" translate="yes" xml:space="preserve">
          <source>A pattern is a term that can contain:</source>
          <target state="translated">Образец-это термин,который может содержать:</target>
        </trans-unit>
        <trans-unit id="17c671d86e70778fccd78b1c171062748a656776" translate="yes" xml:space="preserve">
          <source>A pattern that matches a certain record is created in the same way as a record is created:</source>
          <target state="translated">Шаблон,совпадающий с определенной записью,создается так же,как и запись:</target>
        </trans-unit>
        <trans-unit id="086559c23f422f88dfb22263e5064971fda50484" translate="yes" xml:space="preserve">
          <source>A peer's DiameterIdentity is not required when initiating a connection: the identify is received at capabilities exchange, at which time the connection can be rejected if the identity is objectionable.</source>
          <target state="translated">При инициации подключения не требуется DiameterIdentity аналога:идентификация получена при обмене возможностями,и в этот момент соединение может быть отклонено,если идентификация вызывает возражения.</target>
        </trans-unit>
        <trans-unit id="6ac1afaee6db30631244af22883394c04ea016de" translate="yes" xml:space="preserve">
          <source>A piece of data of any data type is called a &lt;strong&gt;term&lt;/strong&gt;.</source>
          <target state="translated">Фрагмент данных любого типа называется &lt;strong&gt;термином&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="27a9280a59a327bcaa7fa4531cf4080082cc2a4d" translate="yes" xml:space="preserve">
          <source>A pointer to a function to execute in the created thread.</source>
          <target state="translated">Указатель на функцию для выполнения в созданном потоке.</target>
        </trans-unit>
        <trans-unit id="2425be4490c62b2d9ac48f8dfb6dca6c94bc6de8" translate="yes" xml:space="preserve">
          <source>A pointer to a thread identifier variable.</source>
          <target state="translated">Указатель на переменную идентификатора потока.</target>
        </trans-unit>
        <trans-unit id="bdca82216af70bfb4f52fcc1c479301f1b25be42" translate="yes" xml:space="preserve">
          <source>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</source>
          <target state="translated">Указатель на целое число.Целое число используется как для передачи входного,так и выходного размера (см.ниже).</target>
        </trans-unit>
        <trans-unit id="9e7bc1ca5fcc169a07a734702da7afb3a87a923b" translate="yes" xml:space="preserve">
          <source>A pointer to an output buffer.</source>
          <target state="translated">Указатель на выходной буфер.</target>
        </trans-unit>
        <trans-unit id="78c2fb1c9ead9f20103777b7ae3edafb6a2eea4e" translate="yes" xml:space="preserve">
          <source>A pointer to another port structure, which is either the listen port from which this port is accepting a connection or conversely. The &quot;partner relation&quot; is always bidirectional.</source>
          <target state="translated">Указатель на другую структуру порта,которая является либо портом прослушивания,с которого этот порт принимает соединение,либо наоборот.Партнерские отношения&quot; всегда являются двунаправленными.</target>
        </trans-unit>
        <trans-unit id="aae44b20ecd8d8611c610749c380b8aec87c9bfa" translate="yes" xml:space="preserve">
          <source>A pointer to argument to the &lt;code&gt;func&lt;/code&gt; function.</source>
          <target state="translated">Указатель на аргумент &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f4cacb4211d371a86050f3b2bf4514f77eeffa8" translate="yes" xml:space="preserve">
          <source>A pointer to the contents of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Указатель на содержимое &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5991945ec65c59205cb652ca3121b479552f42" translate="yes" xml:space="preserve">
          <source>A pointer to the function that implements the NIF.</source>
          <target state="translated">Указатель на функцию,реализующую NIF.</target>
        </trans-unit>
        <trans-unit id="d4bf94b670a866ff43aac180a11292d00d614edb" translate="yes" xml:space="preserve">
          <source>A pointer to thread options to use or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Указатель на используемые параметры потока или &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1206cda26f132192edd3659328975e4d3cafd278" translate="yes" xml:space="preserve">
          <source>A port can be set to use binaries instead of lists of bytes. It is then not necessary to invent any encoding/decoding scheme. Erl_Interface functions are used for unpacking the binary and convert it into a struct similar to an Erlang term. Such a struct can be manipulated in different ways, be converted to the Erlang external format, and sent to Erlang.</source>
          <target state="translated">Можно настроить порт на использование двоичных файлов вместо списков байт.Тогда нет необходимости изобретать какую-либо схему кодирования/декодирования.Функции Erl_Interface используются для распаковки бинарного файла и преобразования его в структуру,аналогичную термину Erlang.Такой структурой можно манипулировать различными способами,преобразовывать во внешний формат Erlang и отправлять на Erlang.</target>
        </trans-unit>
        <trans-unit id="7a9af688d21b53184095c38ddf61f01deed4f70c" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt; driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt; driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt; driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39dd0f30e9a0ba72b5dacc6b581f2019abf49ac" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Блокировка данных порта считается подсчетом ссылок, и когда счетчик ссылок достигает нуля, она уничтожается. Эмулятор, по крайней мере, увеличивает счетчик ссылок один раз при создании блокировки и уменьшает его после завершения работы порта, связанного с блокировкой. Эмулятор также увеличивает счетчик ссылок, когда асинхронное задание ставится в очередь, и уменьшает его, когда асинхронное задание было вызвано. Кроме того, драйвер отвечает за то, чтобы счетчик ссылок не достиг нуля до последнего использования блокировки драйвером. Счетчик ссылок может быть прочитан, увеличен и уменьшен с помощью &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="293c8a353a9462ae3b6bfddcb9d1223abb498be9" translate="yes" xml:space="preserve">
          <source>A port driver is a linked-in driver that is accessible as a port from an Erlang program. It is a shared library (SO in UNIX, DLL in Windows), with special entry points. The Erlang runtime system calls these entry points when the driver is started and when data is sent to the port. The port driver can also send data to Erlang.</source>
          <target state="translated">Драйвер порта-это драйвер linked-in,который доступен как порт из программы Erlang.Это разделяемая библиотека (SO в UNIX,DLL в Windows),со специальными точками входа.Система исполнения Erlang вызывает эти точки входа при запуске драйвера и при отправке данных в порт.Драйвер порта также может отправлять данные на Эрланг.</target>
        </trans-unit>
        <trans-unit id="3c0708dd623cb47c7df1202d9dbfe1fbb7d19e65" translate="yes" xml:space="preserve">
          <source>A port identifier identifies an Erlang port.</source>
          <target state="translated">Идентификатор порта идентифицирует порт Эрланг.</target>
        </trans-unit>
        <trans-unit id="19b3ddd399fc086f92748ad13d0d6c9f12e76af1" translate="yes" xml:space="preserve">
          <source>A port identifier refers into a port table and a node table, which also consumes memory.</source>
          <target state="translated">Идентификатор порта относится к таблице портов и к таблице узлов,которая также потребляет память.</target>
        </trans-unit>
        <trans-unit id="18856ffa7bc1d834314eb745f89d3f4ac81cef62" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type.</source>
          <target state="translated">Идентификатор порта. В отличие от терминов идентификатора порта (экземпляры &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; ), &lt;code&gt;ErlNifPort&lt;/code&gt; являются самодостаточными и не привязаны к какой-либо &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPort&lt;/code&gt; - непрозрачный тип.</target>
        </trans-unit>
        <trans-unit id="ea470bfa2ec4cfaf642ebb2fc7a49f8233c8c023" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type. It can be copied, moved in memory, forgotten, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5794b57a917a22a654e45737ed3a63e4f792f19" translate="yes" xml:space="preserve">
          <source>A port that is connected to a listen socket. This port does not do much, no data pumping is done on this socket, but read data is available when one is trying to do an accept on the port.</source>
          <target state="translated">Порт,подключенный к прослушивающему разъему.Этот порт не делает много,на этом сокетах не производится накачка данных,но чтение данных доступно,когда кто-то пытается сделать прием на этом порту.</target>
        </trans-unit>
        <trans-unit id="e728f787c7fc14ca780c0ed99792cf4bab0d04bc" translate="yes" xml:space="preserve">
          <source>A positive integer or &lt;code&gt;infinity&lt;/code&gt;, defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Положительное целое число или &lt;code&gt;infinity&lt;/code&gt; , по умолчанию - &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff16a10dbcc92f0a90f938ecb26a69d5a07cb38" translate="yes" xml:space="preserve">
          <source>A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (in case no messages has been sent).</source>
          <target state="translated">Положительное целое число или атом &lt;code&gt;undefined_serial&lt;/code&gt; (в случае, если сообщения не были отправлены).</target>
        </trans-unit>
        <trans-unit id="a0b0b2de29f48def22ce618959435b19ac7becd8" translate="yes" xml:space="preserve">
          <source>A positive integer representing the absolute maximum size a string returned from this formatter can have. If the formatted string is longer, after possibly being limited by &lt;code&gt;chars_limit&lt;/code&gt; or &lt;code&gt;depth&lt;/code&gt;, it is truncated.</source>
          <target state="translated">Положительное целое число, представляющее абсолютный максимальный размер строки, возвращаемой этим средством форматирования. Если форматированная строка длиннее, после возможного ограничения &lt;code&gt;chars_limit&lt;/code&gt; или &lt;code&gt;depth&lt;/code&gt; , она усекается.</target>
        </trans-unit>
        <trans-unit id="8432f1221b4e6180daa30dde8c243b5ace3ee8ed" translate="yes" xml:space="preserve">
          <source>A positive integer representing the maximum depth to which terms shall be printed by this formatter. Format strings passed to this formatter are rewritten. The format controls ~p and ~w are replaced with ~P and ~W, respectively, and the value is used as the depth parameter. For details, see &lt;code&gt;io:format/2,3&lt;/code&gt; in STDLIB.</source>
          <target state="translated">Положительное целое число, представляющее максимальную глубину, до которой термины должны быть напечатаны этим средством форматирования. Строки формата, переданные в это средство форматирования, перезаписываются. Элементы управления форматом ~ p и ~ w заменяются на ~ P и ~ W соответственно, а значение используется в качестве параметра глубины. Подробнее см. &lt;code&gt;io:format/2,3&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="c0c5f0649daa5aaf66aa8692a46961fb52172dd0" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt; io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b666ac2b38c4545ad7cf98d3da66419760a1f1f" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt;io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="translated">Положительное целое число, представляющее значение параметра с тем же именем, которое будет использоваться при вызове &lt;code&gt;io_lib:format/3&lt;/code&gt; . Это значение ограничивает общее количество символов, печатаемых для каждого события журнала. Обратите внимание, что это мягкий предел. Чтобы узнать о жестком пределе усечения, см. &lt;code&gt;max_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00810275831c468fa832818d7831816d4d68cc76" translate="yes" xml:space="preserve">
          <source>A positive integer, defaults to 1.</source>
          <target state="translated">Положительное целое число,по умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="eae0729316a72e8195f927b7d08f3a3e873b0f72" translate="yes" xml:space="preserve">
          <source>A possible output from the system's &lt;code&gt;sequential_tracer&lt;/code&gt; can be like this:</source>
          <target state="translated">Возможный вывод из системы &lt;code&gt;sequential_tracer&lt;/code&gt; может быть таким:</target>
        </trans-unit>
        <trans-unit id="af7898411039ac7f27c7f7c532905e5b1d3ef4a9" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;Big(X)&lt;/code&gt; is defined, which is &lt;code&gt;true&lt;/code&gt; if its argument is greater that 10:</source>
          <target state="translated">Определен предикат &lt;code&gt;Big(X)&lt;/code&gt; , который &lt;code&gt;true&lt;/code&gt; если его аргумент больше 10:</target>
        </trans-unit>
        <trans-unit id="e7d9312c9e6373085b2581d401f52947630c30ca" translate="yes" xml:space="preserve">
          <source>A predicate is a function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;any&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if there is a term &lt;code&gt;X&lt;/code&gt; in the list such that &lt;code&gt;P(X)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Предикат - это функция, которая возвращает &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;any&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , если существует терм &lt;code&gt;X&lt;/code&gt; в списке таких , что &lt;code&gt;P(X)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a559512ddfd19a254b3dc8766e06627c3cf21e5" translate="yes" xml:space="preserve">
          <source>A prefix is optional but can be be used to disambiguate between record and constant names resulting from similarly named messages and AVPs in different Diameter applications.</source>
          <target state="translated">Префикс является необязательным,но может быть использован для разделения имен записей и констант,полученных из одноименных сообщений и AVP в различных приложениях Diameter.</target>
        </trans-unit>
        <trans-unit id="c17bae9646cdd5e9bda0a78a3791df32fbe7c33e" translate="yes" xml:space="preserve">
          <source>A previously loaded module contains an &lt;code&gt;-on_load&lt;/code&gt; function that never finished.</source>
          <target state="translated">Ранее загруженный модуль содержит функцию &lt;code&gt;-on_load&lt;/code&gt; , которая никогда не завершалась.</target>
        </trans-unit>
        <trans-unit id="1b8f8657029f4d6aa6e01af505f0ff328ca9512f" translate="yes" xml:space="preserve">
          <source>A problem can arise if a replicated table on one node is initiated, but &lt;code&gt;Mnesia&lt;/code&gt; deduces that another (remote) replica is more recent than the replica existing on the local node, and the initialization procedure does not proceed. In this situation, a call to &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt;, suspends the caller until the remote node has initialized the table from its local disc and the node has copied the table over the network to the local node.</source>
          <target state="translated">Проблема может возникнуть, если реплицируемая таблица на одном узле инициирована, но &lt;code&gt;Mnesia&lt;/code&gt; делает вывод, что другая (удаленная) реплика является более новой, чем реплика, существующая на локальном узле, и процедура инициализации не продолжается. В этой ситуации вызов &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt; приостанавливает выполнение вызывающей стороны до тех пор, пока удаленный узел не инициализирует таблицу со своего локального диска и узел не скопирует таблицу по сети на локальный узел.</target>
        </trans-unit>
        <trans-unit id="6f4802cb3c2b14a3f4d0a0759994b3bcff8bf5ac" translate="yes" xml:space="preserve">
          <source>A process bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process bound environments between NIF calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebbb1fef06e8f55da3f26cfd1b065a870dd9421" translate="yes" xml:space="preserve">
          <source>A process calling &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;spawn_link&lt;/code&gt;, &lt;code&gt;spawn_monitor&lt;/code&gt;, or &lt;code&gt;spawn_opt&lt;/code&gt; is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out.</source>
          <target state="translated">Процесс, вызывающий &lt;code&gt;spawn&lt;/code&gt; , &lt;code&gt;spawn_link&lt;/code&gt; , &lt;code&gt;spawn_monitor&lt;/code&gt; или &lt;code&gt;spawn_opt&lt;/code&gt; , планируется сразу после завершения вызова. Когда используются более высокие модифицированные уровни синхронизации, вызывающий абонент также спит некоторое время после того, как это запланировано.</target>
        </trans-unit>
        <trans-unit id="072b0b4dc3c07ad9ff81bf5af27f95232daef7d4" translate="yes" xml:space="preserve">
          <source>A process can also be terminated if it receives an exit signal with another exit reason than &lt;code&gt;normal&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Процесс также может быть завершен, если он получает сигнал выхода с другой причиной выхода, чем &lt;code&gt;normal&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f16a41a56038d323a59c139120b39c4d98df3227" translate="yes" xml:space="preserve">
          <source>A process can also call the function &lt;code&gt;exit(Pid,Reason)&lt;/code&gt;. This results in an exit signal with exit reason &lt;code&gt;Reason&lt;/code&gt; being emitted to &lt;code&gt;Pid&lt;/code&gt;, but does not affect the calling process.</source>
          <target state="translated">Процесс также может вызывать функцию &lt;code&gt;exit(Pid,Reason)&lt;/code&gt; . Это приводит к сигналу выхода с выходом Причина &lt;code&gt;Reason&lt;/code&gt; излучаемый на &lt;code&gt;Pid&lt;/code&gt; , но не влияет на процесс вызова.</target>
        </trans-unit>
        <trans-unit id="e6966f7ea916abf9765baf180b15bfc451003b50" translate="yes" xml:space="preserve">
          <source>A process can be set to trap exit signals by calling:</source>
          <target state="translated">Процесс может быть настроен на ловушку сигналов выхода путем вызова:</target>
        </trans-unit>
        <trans-unit id="49077ba72c45965099e62393fc4505d1bc5f8e7a" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt; erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d9fe10dcef55d7d44c0442f222152ab34ddbe3" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="translated">Процесс может быть приостановлен несколькими процессами и может быть приостановлен несколько раз одним процессом. Приостановленный процесс не выходит из приостановленного состояния, пока его счетчик приостановки не достигнет нуля. Счетчик приостановки &lt;code&gt;Suspendee&lt;/code&gt; уменьшается, когда &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; вызывается тем же процессом, который вызвал &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt; . Все увеличенные счетчики приостановок для других процессов, полученные процессом, автоматически уменьшаются при завершении процесса.</target>
        </trans-unit>
        <trans-unit id="32f69066cd227a9815efdfec6c96cb7e6e8de0aa" translate="yes" xml:space="preserve">
          <source>A process can terminate itself by calling one of the following BIFs:</source>
          <target state="translated">Процесс может завершиться вызовом одного из следующих BIF:</target>
        </trans-unit>
        <trans-unit id="b321553d2b5e342e2d1b929ffc0921e013068c69" translate="yes" xml:space="preserve">
          <source>A process created due to a spawn request that has been abandoned may communicate with its parent as any other process. It is &lt;strong&gt;only&lt;/strong&gt; the direct effects on the parent of the actual spawn request, that will be canceled by abandoning a spawn request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5238f73e1d44a290b4f80529059292d57da507" translate="yes" xml:space="preserve">
          <source>A process fixes a table by calling &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt;. The table remains fixed until the process releases it by calling &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt;, or until the process terminates.</source>
          <target state="translated">Процесс исправляет таблицу, вызывая &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt; . Таблица остается фиксированной, пока процесс не освободит ее, вызвав &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt; , или пока процесс не завершится.</target>
        </trans-unit>
        <trans-unit id="42b2c1b73ec6ef9ef96e79e9e9449854c76818bb" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type.</source>
          <target state="translated">Идентификатор процесса (pid). В отличие от терминов pid (экземпляры &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; ), &lt;code&gt;ErlNifPid&lt;/code&gt; являются самодостаточными и не привязаны к какой-либо &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPid&lt;/code&gt; - непрозрачный тип.</target>
        </trans-unit>
        <trans-unit id="ba9734ec123feb8eec22b585c124792c0472e055" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type. It can be copied, moved in memory, forgotten, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37148f5c507ec0173b138452557614229468263f" translate="yes" xml:space="preserve">
          <source>A process identifier as in &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt;. Represents the process in which the fun was created.</source>
          <target state="translated">Идентификатор процесса, как в &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; . Представляет процесс, в котором было создано веселье.</target>
        </trans-unit>
        <trans-unit id="10461d2fc7608d820f0dfe163bcb992712ebe48a" translate="yes" xml:space="preserve">
          <source>A process identifier refers into a process table and a node table, which also consumes memory.</source>
          <target state="translated">Идентификатор процесса относится к таблице процесса и к таблице узлов,которая также потребляет память.</target>
        </trans-unit>
        <trans-unit id="69b2f4b3ae91aebe493ff76d27f3c271b8cfb661" translate="yes" xml:space="preserve">
          <source>A process identifier, pid, identifies a process.</source>
          <target state="translated">Идентификатор процесса,pid,идентифицирует процесс.</target>
        </trans-unit>
        <trans-unit id="98c8d95b2cf9ab7d1d26152983625cb3f9b34934" translate="yes" xml:space="preserve">
          <source>A process in a supervision tree is expected to terminate with the same reason as its parent.</source>
          <target state="translated">Ожидается,что процесс в дереве наблюдения завершится по той же причине,что и его родитель.</target>
        </trans-unit>
        <trans-unit id="d6ba7c3c946bdd4b03479883e86c12f1505bd1d6" translate="yes" xml:space="preserve">
          <source>A process is created by calling &lt;code&gt;spawn&lt;/code&gt;:</source>
          <target state="translated">Процесс создается путем вызова &lt;code&gt;spawn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="655669bae8fcf2c6bd4e506e48fb385c11ebcc8b" translate="yes" xml:space="preserve">
          <source>A process is said to &lt;strong&gt;use&lt;/strong&gt; a module &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification used to start the process, see &lt;code&gt;supervisor(3)&lt;/code&gt;. In the case of &lt;code&gt;gen_event&lt;/code&gt;, an event manager process is said to use &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is an installed event handler.</source>
          <target state="translated">Говорят, что процесс &lt;strong&gt;использует&lt;/strong&gt; модуль &lt;code&gt;Mod&lt;/code&gt; , если &lt;code&gt;Mod&lt;/code&gt; указан в части &amp;laquo; &lt;code&gt;Modules&lt;/code&gt; дочерней спецификации, используемой для запуска процесса, см. &lt;code&gt;supervisor(3)&lt;/code&gt; . В случае &lt;code&gt;gen_event&lt;/code&gt; говорят , что процесс диспетчера событий использует &lt;code&gt;Mod&lt;/code&gt; , если &lt;code&gt;Mod&lt;/code&gt; является установленным обработчиком событий.</target>
        </trans-unit>
        <trans-unit id="6ce5d54306fa5b34ccef5a88ec9ab67fc328d882" translate="yes" xml:space="preserve">
          <source>A process is said to terminate &lt;strong&gt;normally&lt;/strong&gt;, if the exit reason is the atom &lt;code&gt;normal&lt;/code&gt;. A process with no more code to execute terminates normally.</source>
          <target state="translated">Говорят, что процесс завершается &lt;strong&gt;нормально&lt;/strong&gt; , если причиной выхода является &lt;code&gt;normal&lt;/code&gt; атом . Процесс, у которого больше нет кода для выполнения, завершается нормально.</target>
        </trans-unit>
        <trans-unit id="fb8a0c82e2b3e6de1b3a292697b7dd18d1ac9e70" translate="yes" xml:space="preserve">
          <source>A process may join multiple groups. It may join the same group multiple times. It is only allowed to join processes running on local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5476607e3cda2543b898df9573ff320bd9b1b5a4" translate="yes" xml:space="preserve">
          <source>A process must complete the sending of a fragmented message before it can start sending any other message on the same distribution channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262937e9bbf32c8d0ea317c09244f8bdfd384e14" translate="yes" xml:space="preserve">
          <source>A process spawn is represented as multiple information transfers. At least one spawn request and one spawn reply. The actual amount of information transfers depends on what type of spawn it is and may also change in future implementations. Note that this is more or less an internal protocol that you are peeking at. The spawn request will be represented as a tuple with the first element containing the atom &lt;code&gt;spawn_request&lt;/code&gt;, but this is more or less all that you can depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38c68c3f6186a6925602a46f9f750d6d6a871ba" translate="yes" xml:space="preserve">
          <source>A process started using one of these functions stores information (for example, about the ancestors and initial call) that is needed for a process in a supervision tree.</source>
          <target state="translated">Процесс,запущенный с помощью одной из этих функций,хранит информацию (например,о предках и начальном вызове),необходимую для процесса в дереве наблюдения.</target>
        </trans-unit>
        <trans-unit id="8a720c57ae355af10862b0bdc7f574cf5fde79d5" translate="yes" xml:space="preserve">
          <source>A process terminates when there is nothing more for it to do, that is, the last function it calls simply returns and does not call another function. Another way for a process to terminate is for it to call &lt;code&gt;exit/1&lt;/code&gt;. The argument to &lt;code&gt;exit/1&lt;/code&gt; has a special meaning, which is discussed later. In this example, &lt;code&gt;exit(normal)&lt;/code&gt; is done, which has the same effect as a process running out of functions to call.</source>
          <target state="translated">Процесс завершается, когда ему больше нечего делать, то есть последняя вызываемая им функция просто возвращается и не вызывает другую функцию. Другой способ завершить процесс - вызвать &lt;code&gt;exit/1&lt;/code&gt; . Аргумент &lt;code&gt;exit/1&lt;/code&gt; имеет особое значение, которое обсуждается позже. В этом примере выполняется &lt;code&gt;exit(normal)&lt;/code&gt; , который имеет тот же эффект, что и процесс, у которого заканчиваются функции для вызова.</target>
        </trans-unit>
        <trans-unit id="b7284987fd39b3d4aa792c2690fb0c00bf937e45" translate="yes" xml:space="preserve">
          <source>A process terminates with an exit reason &lt;code&gt;{Reason,Stack}&lt;/code&gt; when a run-time error occurs. See &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Процесс завершается по причине выхода &lt;code&gt;{Reason,Stack}&lt;/code&gt; , когда возникает ошибка времени выполнения. См. &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f5ab350433257813ae5457fda256563bb26173" translate="yes" xml:space="preserve">
          <source>A process that has subscribed receives the messages &lt;code&gt;{nodeup, Node}&lt;/code&gt; and &lt;code&gt;{nodedown, Node}&lt;/code&gt; when a group node connects or disconnects, respectively.</source>
          <target state="translated">Подписавшийся процесс получает сообщения &lt;code&gt;{nodeup, Node}&lt;/code&gt; и &lt;code&gt;{nodedown, Node}&lt;/code&gt; когда узел группы подключается или отключается, соответственно.</target>
        </trans-unit>
        <trans-unit id="88f957222cd12e5811bc10dccb60ff786260ced6" translate="yes" xml:space="preserve">
          <source>A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old heap contains mostly garbage. To ensure a fullsweep occasionally, set &lt;code&gt;Number&lt;/code&gt; to a suitable value, such as 10 or 20.</source>
          <target state="translated">Процесс, который в основном имеет краткосрочные данные, редко или никогда полностью очищается, то есть старая куча в основном содержит мусор. Чтобы время от времени обеспечивать полную развертку, установите для &lt;code&gt;Number&lt;/code&gt; подходящее значение, например 10 или 20.</target>
        </trans-unit>
        <trans-unit id="b02ce9655d7ee12a68cc9c922758cfe90268e361" translate="yes" xml:space="preserve">
          <source>A process that terminates emits an &lt;strong&gt;exit signal&lt;/strong&gt; with an &lt;strong&gt;exit reason&lt;/strong&gt; that says something about which error has occurred. Normally, some information about the error is printed to the terminal.</source>
          <target state="translated">Процесс , который заканчивается выдает &lt;strong&gt;сигнал на выход&lt;/strong&gt; с &lt;strong&gt;причиной выхода&lt;/strong&gt; , что говорит о котором произошла ошибка. Обычно некоторая информация об ошибке выводится на терминал.</target>
        </trans-unit>
        <trans-unit id="4c1ad1b1dc6212b6747cc5b78c88b6a9bc5616a4" translate="yes" xml:space="preserve">
          <source>A process uses a module if the name is listed in &lt;code&gt;Modules&lt;/code&gt; in the child specification for the process.</source>
          <target state="translated">Процесс использует модуль, если имя указано в &lt;code&gt;Modules&lt;/code&gt; в дочерней спецификации для процесса.</target>
        </trans-unit>
        <trans-unit id="d52b7cef11e2674343ad2926d3e4df68d2f02770" translate="yes" xml:space="preserve">
          <source>A process which encounters a runtime error (for example, divide by zero, bad match, trying to call a function that does not exist and so on) exits with an error, that is, has an &lt;strong&gt;abnormal&lt;/strong&gt; exit. A process which executes &lt;code&gt;exit(Reason)&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is any Erlang term except the atom &lt;code&gt;normal&lt;/code&gt;, also has an abnormal exit.</source>
          <target state="translated">Процесс, который обнаруживает ошибку времени выполнения (например, деление на ноль, неправильное совпадение, попытка вызвать функцию, которая не существует, и т. Д.) Завершается с ошибкой, то есть имеет &lt;strong&gt;ненормальный&lt;/strong&gt; выход. Процесс, который выполняет &lt;code&gt;exit(Reason)&lt;/code&gt; где &lt;code&gt;Reason&lt;/code&gt; - это любой термин Erlang, кроме атома &lt;code&gt;normal&lt;/code&gt; , также имеет аномальный выход.</target>
        </trans-unit>
        <trans-unit id="d8cf739fd5b866124284242faae0350386ccbc38" translate="yes" xml:space="preserve">
          <source>A process which executes &lt;code&gt;exit(normal)&lt;/code&gt; or simply runs out of things to do has a &lt;strong&gt;normal&lt;/strong&gt; exit.</source>
          <target state="translated">Процесс, который выполняет &lt;code&gt;exit(normal)&lt;/code&gt; или просто заканчивает работу, имеет &lt;strong&gt;нормальный&lt;/strong&gt; выход.</target>
        </trans-unit>
        <trans-unit id="d70973a9129b09df85556ba1f21b22c9c9188ac7" translate="yes" xml:space="preserve">
          <source>A process-bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process-bound environments between NIF calls.</source>
          <target state="translated">Среда,связанная с процессом,содержит переходную информацию о вызывающем процессе Erlang.Среда действительна только в том потоке,в который она была передана в качестве аргумента,до тех пор,пока NIF не вернется.Таким образом,бесполезно и опасно хранить указатели на связанные с процессами среды между вызовами NIF.</target>
        </trans-unit>
        <trans-unit id="8439869a5f898e9ec34e7c4ce1fd0dfa05b36050" translate="yes" xml:space="preserve">
          <source>A program development technique where you continuously write tests &lt;strong&gt;before&lt;/strong&gt; you implement the code that is supposed to pass those tests. This can help you focus on solving the right problems, and not make a more complicated implementation than necessary, by letting the unit tests determine when a program is &quot;done&quot;: if it fulfils its specifications, there is no need to keep adding functionality.</source>
          <target state="translated">Метод разработки программ, при котором вы постоянно пишете тесты &lt;strong&gt;перед&lt;/strong&gt; тем, как реализовать код, который должен пройти эти тесты. Это может помочь вам сосредоточиться на решении правильных проблем и не создавать более сложную реализацию, чем необходимо, позволяя модульным тестам определять, когда программа &quot;завершена&quot;: если она соответствует ее спецификациям, нет необходимости продолжать добавлять функциональные возможности.</target>
        </trans-unit>
        <trans-unit id="31698109f367fecfe3048c58496050f0b7013f39" translate="yes" xml:space="preserve">
          <source>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</source>
          <target state="translated">Программа работает независимо от местоположения данных.Не имеет значения,находятся ли данные на локальном узле или на удаленном.</target>
        </trans-unit>
        <trans-unit id="31abad1a30c128c77e1602c287c4f23c333d4d5c" translate="yes" xml:space="preserve">
          <source>A programming language is not much use if you only can run code from the shell. So here is a small Erlang program. Enter it into a file named &lt;code&gt;tut.erl&lt;/code&gt; using a suitable text editor. The file name &lt;code&gt;tut.erl&lt;/code&gt; is important, and also that it is in the same directory as the one where you started &lt;code&gt;erl&lt;/code&gt;). If you are lucky your editor has an Erlang mode that makes it easier for you to enter and format your code nicely (see &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; in Tools User's Guide), but you can manage perfectly well without. Here is the code to enter:</source>
          <target state="translated">Язык программирования бесполезен, если вы можете запускать код только из оболочки. Итак, вот небольшая программа на Erlang. Введите его в файл с именем &lt;code&gt;tut.erl&lt;/code&gt; , используя подходящий текстовый редактор. Важно имя файла &lt;code&gt;tut.erl&lt;/code&gt; , а также то, что он находится в том же каталоге, что и тот, где вы запустили &lt;code&gt;erl&lt;/code&gt; ). Если вам повезло, в вашем редакторе есть режим Erlang, который упрощает вам ввод и форматирование кода (см. &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; в Руководстве пользователя инструментов), но вы можете прекрасно справиться и без него. Вот код для входа:</target>
        </trans-unit>
        <trans-unit id="01bea3eff51113f444f36e486039be93438b9aa1" translate="yes" xml:space="preserve">
          <source>A progress report is issued when a supervisor starts or restarts a child. A progress report contains the following items:</source>
          <target state="translated">Отчет о проделанной работе выдается,когда руководитель начинает или перезапускает ребенка.Отчет о проделанной работе содержит следующие пункты:</target>
        </trans-unit>
        <trans-unit id="7a2323a209e1a22ed12fa10ec6f9c3cae4a441ed" translate="yes" xml:space="preserve">
          <source>A proper list of arguments to use in the call to the entry point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc5b72e9976f09f432e0a687f016f57f9a5aece" translate="yes" xml:space="preserve">
          <source>A proper list of spawn options to use when spawning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa1a1d7586f8b047c09414dbfe4922da8132644" translate="yes" xml:space="preserve">
          <source>A protocol-independent equivalent of &lt;code&gt;tos&lt;/code&gt; above. Setting priority implies setting &lt;code&gt;tos&lt;/code&gt; as well.</source>
          <target state="translated">Независимый от протокола эквивалент приведенных выше &lt;code&gt;tos&lt;/code&gt; . Установка приоритета подразумевает также установку &lt;code&gt;tos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dcc85d5e6a8d3b2dabc11b50011d74738e45c9a" translate="yes" xml:space="preserve">
          <source>A proxy-authorization header using the provided username and password is added to the request.</source>
          <target state="translated">К запросу добавляется заголовок прокси-авторизации,использующий предоставленные имя пользователя и пароль.</target>
        </trans-unit>
        <trans-unit id="fca72e9fdf4fbe435757ecdf4f89e484c25bdd95" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для сеанса запрошен псевдотерминал. &lt;code&gt;Terminal&lt;/code&gt; - это значение переменной среды TERM, то есть &lt;code&gt;vt100&lt;/code&gt; . Параметры нулевого размера следует игнорировать. Размеры символа / строки имеют приоритет над размерами в пикселях (если они не равны нулю). Размеры в пикселях относятся к области рисования окна. &lt;code&gt;Opcode&lt;/code&gt; в списке &lt;code&gt;TerminalModes&lt;/code&gt; - это мнемоническое имя, представленное в виде строчного атома Эрланга, определенное в &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; , раздел 8. Он также может быть &lt;code&gt;Opcode&lt;/code&gt; если мнемоническое имя не указано в RFC. Пример: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt; . Это событие отправляется в результате вызова &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fc5e44171b910f411dd9eff54be6144ce19b764" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section/8&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53dd83df64a4aed582356aeff9d756b34b98db4" translate="yes" xml:space="preserve">
          <source>A qualifier Q is one of the following:</source>
          <target state="translated">Квалификатор Q является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="16e918dd54f68fd1cee2a154501ced6dc2ab06fa" translate="yes" xml:space="preserve">
          <source>A query handle is evaluated in the following order:</source>
          <target state="translated">Ручка обработки запросов обрабатывается в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="0e8baf0d28cdf7d93d387dd8846b5f6b10083008" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on a particular platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61712a9538d9f895b83ffb3d3be147091cb2096" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on the current platform.</source>
          <target state="translated">Необработанный запрос параметра &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; может использоваться для получения информации о параметрах сокета, которые (явно) не поддерживаются эмулятором. Использование необработанных параметров сокета делает код непереносимым, но позволяет программисту на Erlang использовать необычные функции, присутствующие на текущей платформе.</target>
        </trans-unit>
        <trans-unit id="3ebff0e214120dc5d32ac8a4a0637ce5cce89676" translate="yes" xml:space="preserve">
          <source>A read event was cancelled by &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; or &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and is guaranteed not to generate a &lt;code&gt;ready_input&lt;/code&gt; notification message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff008f39f98c26bb673531ccb371655a692f01c" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; data type, and the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Рекомендуемая отправная точка для начинающего пользователя - это документация по &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; данных syntaxTree () и &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; функции / 1 .</target>
        </trans-unit>
        <trans-unit id="eb56dddcb8b70cd19ebdc2bcc639e335bb693c26" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e58752debf6eb10b77ef1dd1dbb8c914a8de4f8" translate="yes" xml:space="preserve">
          <source>A record definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the record.</source>
          <target state="translated">Определение записи может быть размещено где угодно среди атрибутов и деклараций функций модуля,но определение должно прийти до любого использования записи.</target>
        </trans-unit>
        <trans-unit id="ba583d421bbddc518a0b6122d30465ab600660d3" translate="yes" xml:space="preserve">
          <source>A record definition consists of the name of the record, followed by the field names of the record. Record and field names must be atoms. Each field can be given an optional default value. If no default value is supplied, &lt;code&gt;undefined&lt;/code&gt; is used.</source>
          <target state="translated">Определение записи состоит из имени записи, за которым следуют имена полей записи. Имена записей и полей должны быть атомами. Каждому полю может быть присвоено необязательное значение по умолчанию. Если значение по умолчанию не указано, используется &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbaae8298ac3d9e6e938e77fc79043b34deaf0a" translate="yes" xml:space="preserve">
          <source>A record has possibly been deleted with &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;OldRecord&lt;/code&gt; contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">Возможно, запись была удалена с помощью &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;OldRecord&lt;/code&gt; содержит значение старой записи, как указано приложением в качестве аргумента. Обратите внимание, что другие записи с тем же ключом могут оставаться в таблице, если она имеет тип &lt;code&gt;bag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72d63fe5211c7ae3ef0a86204219aaaa2f059f47" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. However, a record is not a true data type. Instead, record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">Запись - это структура данных для хранения фиксированного количества элементов. Он имеет именованные поля и похож на структуру в C. Однако запись не является истинным типом данных. Вместо этого выражения записи преобразуются в выражения кортежа во время компиляции. Следовательно, выражения записи не распознаются оболочкой, если не предпринимаются специальные действия. За подробностями обращайтесь к странице руководства &lt;code&gt;shell(3)&lt;/code&gt; в STDLIB).</target>
        </trans-unit>
        <trans-unit id="10b1bbed2ccfee04b70ac0a61eb0d3ccdccb28c7" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. Record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">Запись - это структура данных для хранения фиксированного количества элементов. Он имеет именованные поля и похож на структуру в C. Выражения записи преобразуются в выражения кортежа во время компиляции. Следовательно, выражения записи не распознаются оболочкой, если не предпринимаются специальные действия. За подробностями обращайтесь к странице руководства &lt;code&gt;shell(3)&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="c08da4f4936f6c7ef6c5c849615f4e5aa16f8d6a" translate="yes" xml:space="preserve">
          <source>A record is defined as:</source>
          <target state="translated">Запись определяется как:</target>
        </trans-unit>
        <trans-unit id="2caff8ac97a88a40d8081c22ddabb3164e9d8ee2" translate="yes" xml:space="preserve">
          <source>A record that describes an employee can look as follows:</source>
          <target state="translated">Запись,описывающая сотрудника,может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="ea49bf259e7f3ffbeb1c63e53edd2986c4da3837" translate="yes" xml:space="preserve">
          <source>A reference is a term that is unique in an Erlang runtime system, created by calling &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">Ссылка - это термин, который является уникальным в системе времени выполнения Erlang, созданный путем вызова &lt;code&gt;make_ref/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14e8331cdb8c151b2856ff19909f37919f2942e9" translate="yes" xml:space="preserve">
          <source>A reference refers into a node table, which also consumes memory.</source>
          <target state="translated">Ссылка относится к таблице узлов,которая также потребляет память.</target>
        </trans-unit>
        <trans-unit id="f5a40d0612040493ede164c97573dfd19a4e473a" translate="yes" xml:space="preserve">
          <source>A reference that uniquely identifies the (select) operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4f0d6f1f9b5df543605d7bc8edbd15d630e93c" translate="yes" xml:space="preserve">
          <source>A registered name.</source>
          <target state="translated">Зарегистрированное имя.</target>
        </trans-unit>
        <trans-unit id="4417be038ecab856e8399ba11dec3102f33f7d40" translate="yes" xml:space="preserve">
          <source>A registered send operation has occurred and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contains the pid of the sender. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; зарегистрированная операция отправки, и emsg-&amp;gt; from содержит pid отправителя. Сообщение находится в &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e77a6a05b56401cd9d0ab970f691941ff41f5126" translate="yes" xml:space="preserve">
          <source>A registered send operation occurred. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contains the pid of the sender.</source>
          <target state="translated">Произошла зарегистрированная операция отправки. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; содержит идентификатор отправителя.</target>
        </trans-unit>
        <trans-unit id="f8d3748e235b7729da3350a0d2920104b36dba36" translate="yes" xml:space="preserve">
          <source>A registry that has previously been created with &lt;code&gt;ei_reg_open()&lt;/code&gt; is closed, and all the objects it contains are freed.</source>
          <target state="translated">Реестр, который ранее был создан с помощью &lt;code&gt;ei_reg_open()&lt;/code&gt; , закрывается, и все содержащиеся в нем объекты освобождаются.</target>
        </trans-unit>
        <trans-unit id="d54a6449f65944104c58b103284695849e8fb0c0" translate="yes" xml:space="preserve">
          <source>A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.</source>
          <target state="translated">Генератор лексического анализатора на основе регулярных выражений для Erlang,похожий на lex или flex.</target>
        </trans-unit>
        <trans-unit id="d1dac6b0a35eaa9eeb715296367bf1003d8ca372" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself:</source>
          <target state="translated">Регулярное выражение-это шаблон,который сопоставляется с тематической строкой слева направо.Большинство символов стоят в шаблоне и совпадают с соответствующими символами в теме.В качестве тривиального примера,следующий шаблон соответствует части строки темы,которая идентична самой себе:</target>
        </trans-unit>
        <trans-unit id="72879a85f0e7c023321bf2bf93898f7dd0d964ea" translate="yes" xml:space="preserve">
          <source>A relation R in X is &lt;strong&gt;reflexive&lt;/strong&gt; if x R x for every element x of X, it is &lt;strong&gt;symmetric&lt;/strong&gt; if x R y implies that y R x, and it is &lt;strong&gt;transitive&lt;/strong&gt; if x R y and y R z imply that x R z.</source>
          <target state="translated">Отношение R в X &lt;strong&gt;рефлексивно,&lt;/strong&gt; если x R x для каждого элемента x из X, оно &lt;strong&gt;симметрично,&lt;/strong&gt; если x R y влечет y R x, и &lt;strong&gt;транзитивно,&lt;/strong&gt; если x R y и y R z влекут x R z.</target>
        </trans-unit>
        <trans-unit id="d4e299db49e468c2bde2833d058721d987434955" translate="yes" xml:space="preserve">
          <source>A relation in a set is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is reflexive, symmetric, and transitive.</source>
          <target state="translated">Отношение в наборе является &lt;strong&gt;отношением эквивалентности,&lt;/strong&gt; если оно рефлексивно, симметрично и транзитивно.</target>
        </trans-unit>
        <trans-unit id="0ebab014aefe1952987eeb358deade3e55cb740e" translate="yes" xml:space="preserve">
          <source>A relational/object hybrid data model that is suitable for telecommunications applications.</source>
          <target state="translated">Гибридная модель реляционных/объектных данных,подходящая для телекоммуникационных приложений.</target>
        </trans-unit>
        <trans-unit id="bdbc21562cd7fcdf1a6c8c8fdaf7713b768b8540" translate="yes" xml:space="preserve">
          <source>A release package can also contain:</source>
          <target state="translated">Пакет выпуска также может содержать:</target>
        </trans-unit>
        <trans-unit id="70a237d6b6ad6eae7ebaff5d81629ed2d641cc80" translate="yes" xml:space="preserve">
          <source>A release package is always to contain:</source>
          <target state="translated">Пакет выпуска всегда должен содержать:</target>
        </trans-unit>
        <trans-unit id="ec17e9f9c454053a070fd20ff7eeb8af0a65c4c3" translate="yes" xml:space="preserve">
          <source>A release resource file, &lt;code&gt;Name.rel&lt;/code&gt;</source>
          <target state="translated">Файл ресурсов выпуска, &lt;code&gt;Name.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa054e2d79bd8ac06f390024625251631581f417" translate="yes" xml:space="preserve">
          <source>A release upgrade file, &lt;code&gt;relup&lt;/code&gt;</source>
          <target state="translated">Файл обновления выпуска, &lt;code&gt;relup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe2e6189285d97d6577d1e21b467c08a9445c7c" translate="yes" xml:space="preserve">
          <source>A released application must follow a certain structure.</source>
          <target state="translated">Выпущенное приложение должно следовать определенной структуре.</target>
        </trans-unit>
        <trans-unit id="1ffc64bafad7783a2c6df745a520b71eddb2ea11" translate="yes" xml:space="preserve">
          <source>A relup script can only have one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and it must always be placed at the end. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">Сценарий relup может иметь только одну инструкцию &lt;code&gt;restart_emulator&lt;/code&gt; , и ее всегда нужно размещать в конце. Если повторная установка создается с помощью &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; , это обеспечивается автоматически.</target>
        </trans-unit>
        <trans-unit id="c55e43ee14cb55c89c46dda7dd3c64e06ed074e9" translate="yes" xml:space="preserve">
          <source>A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (directly or through NFS).</source>
          <target state="translated">Удаленный файловый сервер Erlang не может быть использован.Компьютер,на котором запущен узел Erlang,должен иметь доступ к файловой системе (напрямую или через NFS).</target>
        </trans-unit>
        <trans-unit id="a57b69cf3ad43e824a3831ee7e57db92ae3dde80" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="translated">Удаленное выполнение может быть завершено принудительно из-за сигнала. Тогда это сообщение можно будет получить. Дополнительные сведения о допустимых строковых значениях см. В разделе 6.10 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; , в котором показан особый случай этих сигналов.</target>
        </trans-unit>
        <trans-unit id="9c596892eeac26bffdaa259eeeee428644ec4341" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-6.10&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa0f3b36cc97b41ae10c4a61219216ab07da247" translate="yes" xml:space="preserve">
          <source>A remote node Y must be known to node X if there exists any pids, ports, references, or funs (Erlang data types) from Y on X, or if X and Y are connected. The maximum number of remote nodes simultaneously/ever known to a node is limited by the &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; available for node names. All data concerning remote nodes, except for the node name atom, are garbage-collected.</source>
          <target state="translated">Удаленный узел Y должен быть известен узлу X, если существуют какие-либо pid, порты, ссылки или funs (типы данных Erlang) из Y на X, или если X и Y связаны. Максимальное количество удаленных узлов, одновременно / когда-либо известных узлу, ограничено &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; доступных для имен узлов. Все данные об удаленных узлах, за исключением атома имени узла, собираются сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="2ef0e40b8a94e3602eaf0a08318e503302907b08" translate="yes" xml:space="preserve">
          <source>A reply sent with this function is not visible in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug output.</source>
          <target state="translated">Ответ, отправленный с помощью этой функции, не отображается в выводе отладки &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="968b931f26a7eb0a1ce8e38bc2b4799ef2fd705f" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt; logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65b57be2761081067ca64ced4646ffe5f623f66" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="translated">Обратный вызов отчета используется модулем форматирования для преобразования сообщений журнала в форме отчета в строку формата и аргументы. Обратный вызов отчета может быть указан в метаданных для события журнала. Если в метаданных нет обратного вызова отчета, &lt;code&gt;logger_formatter&lt;/code&gt; будет использовать &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; в качестве обратного вызова по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3cb325283449bed9030a0b8eb054228f9049d2fb" translate="yes" xml:space="preserve">
          <source>A representaion of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="translated">Представление части (или диапазона) в двоичном формате. &lt;code&gt;Start&lt;/code&gt; - это смещение с нуля в &lt;code&gt;binary()&lt;/code&gt; а &lt;code&gt;Length&lt;/code&gt; - это длина этой части. В качестве входных данных для функций в этом модуле разрешена спецификация обратной части, построенная с отрицательной &lt;code&gt;Length&lt;/code&gt; , так что часть двоичного файла начинается с &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; и имеет длину - &lt;code&gt;Length&lt;/code&gt; . Это полезно для ссылки на последние &lt;code&gt;N&lt;/code&gt; байтов двоичного файла как &lt;code&gt;{size(Binary), -N}&lt;/code&gt; . Функции в этом модуле всегда возвращают &lt;code&gt;part()&lt;/code&gt; с положительной &lt;code&gt;Length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1aa5116d3fb4b00376ef8dcd3fa6e2ce235d63" translate="yes" xml:space="preserve">
          <source>A representation of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd076e54cc70b0a6f690c2fbc8ae7eee141d7ed" translate="yes" xml:space="preserve">
          <source>A representation of the current context of the pretty-printer. Can be accessed in hook functions.</source>
          <target state="translated">Представление текущего контекста симпатичного принтера.Доступно в функциях крючка.</target>
        </trans-unit>
        <trans-unit id="e2faa414df8b457497c58bbac25134eed33ca746" translate="yes" xml:space="preserve">
          <source>A request handle, see &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt; send_request/2 &lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060acb73f9bf52d61dfcf27189e091e2a0ff80f3" translate="yes" xml:space="preserve">
          <source>A request handle, see &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt; send_request/3 &lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489f7c9165ae17355e87065058b1cd9bf9bd345f" translate="yes" xml:space="preserve">
          <source>A request to http://your.server.org/cgi-bin/example/httpd_example:yahoo would refer to httpd_example:yahoo/3 or, if that does not exist, httpd_example:yahoo/2 and http://your.server.org/cgi-bin/example/other:yahoo would not be allowed to execute.</source>
          <target state="translated">Запрос на http://your.server.org/cgi-bin/example/httpd_example:yahoo будет содержать ссылку на httpd_example:yahoo/3 или,если ее нет,httpd_example:yahoo/2 и http://your.server.org/cgi-bin/example/other:yahoo не будет разрешен к выполнению.</target>
        </trans-unit>
        <trans-unit id="aa222544811c186e688c873a3b1f9169cad3037b" translate="yes" xml:space="preserve">
          <source>A request to terminate the transport process after having received DPA in response to DPR. The transport process should exit. &lt;code&gt;Pid&lt;/code&gt; is the pid() of the parent process.</source>
          <target state="translated">Запрос на завершение транспортного процесса после получения DPA в ответ на DPR. Процесс транспортировки должен завершиться. &lt;code&gt;Pid&lt;/code&gt; - это pid () родительского процесса.</target>
        </trans-unit>
        <trans-unit id="7e78eeac55809d5c5a5db06a988ff97769682bea" translate="yes" xml:space="preserve">
          <source>A required variable can also be given a default value to be used if the variable is not found in any configuration file. To specify a default value, add a tuple on the form &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; to the test case information list (the position in the list is irrelevant).</source>
          <target state="translated">Обязательной переменной также может быть присвоено значение по умолчанию, которое будет использоваться, если переменная не найдена ни в одном файле конфигурации. Чтобы указать значение по умолчанию, добавьте кортеж в форме &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; в список информации о тестовом примере (позиция в списке не имеет значения).</target>
        </trans-unit>
        <trans-unit id="c1229803283f11562375509c222552c10accf62d" translate="yes" xml:space="preserve">
          <source>A resource term can be serialized with &lt;code&gt;term_to_binary&lt;/code&gt; and later be fully recreated if the resource object is still alive when &lt;code&gt;binary_to_term&lt;/code&gt; is called. A &lt;strong&gt;stale&lt;/strong&gt; resource term will be returned from &lt;code&gt;binary_to_term&lt;/code&gt; if the resource object has been deallocated. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; will return false for stale resource terms.</source>
          <target state="translated">Термин ресурса можно сериализовать с помощью &lt;code&gt;term_to_binary&lt;/code&gt; и позже полностью воссоздать, если объект ресурса все еще жив, когда &lt;code&gt;binary_to_term&lt;/code&gt; . &lt;strong&gt;Несвежий&lt;/strong&gt; термин ресурса будет возвращен из &lt;code&gt;binary_to_term&lt;/code&gt; если объект ресурса был освобожден. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; вернет false для устаревших условий ресурса.</target>
        </trans-unit>
        <trans-unit id="50ae922c622293c13dbc2965d257c86fc95a1f21" translate="yes" xml:space="preserve">
          <source>A resource to be managed is represented by a managed object, which resides in the MIB. In an SNMP MIB, the managed objects are either:</source>
          <target state="translated">Ресурс,которым необходимо управлять,представляет собой управляемый объект,который находится в MIB.В SNMP MIB управляемыми объектами являются также объекты:</target>
        </trans-unit>
        <trans-unit id="8e4eb7e095c0c09d5767bd5279f5cdff3096b732" translate="yes" xml:space="preserve">
          <source>A restricted set of &lt;code&gt;&lt;a href=&quot;#type-spawn_option&quot;&gt;spawn options&lt;/a&gt;&lt;/code&gt;. Most notably &lt;code&gt;monitor&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; part of these options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d797a366df3377e950dd7503223fc79e6918d3ba" translate="yes" xml:space="preserve">
          <source>A returned error reason can be converted into a readable string using &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; причина ошибки может быть преобразована в читаемую строку с помощью format_error / 1 .</target>
        </trans-unit>
        <trans-unit id="e1717e1bc6c4fa58d53cbf11fb5819e00bdd83ca" translate="yes" xml:space="preserve">
          <source>A rudimentary DNS client.</source>
          <target state="translated">Зачаточный DNS-клиент.</target>
        </trans-unit>
        <trans-unit id="59d2054b44ad5d0ec1cf63133801ae0786ec3996" translate="yes" xml:space="preserve">
          <source>A rule is recognized by its right-pointer arrow: &lt;code&gt;=&amp;gt;&lt;/code&gt;. To the left of the arrow is one or more instruction patterns, separated by &lt;code&gt;|&lt;/code&gt;. To the right of the arrow is zero or more instructions, separated by &lt;code&gt;|&lt;/code&gt;. If the instructions from the BEAM code matches the instruction patterns on the left side, they will be replaced with instructions on the right side (or removed if there are no instructions on the right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ab6d0ea4f0599f5b342196442f9968fded07ef" translate="yes" xml:space="preserve">
          <source>A run queue has four queues for processes of different priority and one queue for ports. The scheduler thread associated with the run queue switch evenly between execution of processes and execution of ports while both processes and ports exist in the queue. This is not completely true, but not important for this discussion. A port that is in a run queue also has a queue of tasks to execute. Each task corresponds to an in- or outgoing signal. When the port is selected for execution each task will be executed in sequence. The run queue locks not only protected the queues of ports, but also the queues of port tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd25b98d67a3d5acbff27d930ee3340ca6349672" translate="yes" xml:space="preserve">
          <source>A run-time error can also be emulated by calling &lt;code&gt;erlang:error(Reason)&lt;/code&gt; or &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt;.</source>
          <target state="translated">Ошибка времени выполнения также может быть эмулирована вызовом &lt;code&gt;erlang:error(Reason)&lt;/code&gt; или &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb56303785fbc88fcc2408a8fd31a4003ffe1f34" translate="yes" xml:space="preserve">
          <source>A run-time error is another name for an exception of class &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">Ошибка времени выполнения - это другое название исключения &lt;code&gt;error&lt;/code&gt; класса .</target>
        </trans-unit>
        <trans-unit id="608acd283e8c59f26f33232a215b266093ace6dd" translate="yes" xml:space="preserve">
          <source>A run-time error is when a crash occurs. An example is when an operator is applied to arguments of the wrong type. The Erlang programming language has built-in features for handling of run-time errors.</source>
          <target state="translated">Ошибка во время выполнения-это когда происходит сбой.Пример-когда оператор применяется к аргументам неправильного типа.Язык программирования Erlang имеет встроенные возможности для работы с ошибками во время выполнения.</target>
        </trans-unit>
        <trans-unit id="fe2de4d023b6ff93a7868d6e63e1e0f0f608db09" translate="yes" xml:space="preserve">
          <source>A runtime error occurred which raised and error exception while applying the function, and the applied function did not catch the exception. The error reason &lt;code&gt;ErrorReason&lt;/code&gt; indicates the type of error that occurred. &lt;code&gt;StackTrace&lt;/code&gt; is formatted as when caught in a &lt;code&gt;try/catch&lt;/code&gt; construct. The &lt;code&gt;StackTrace&lt;/code&gt; is limited to the applied function and functions called by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f38ec391b2ae32351853cf5569dd5468c7febd8" translate="yes" xml:space="preserve">
          <source>A runtime system Lock Profiling tool.</source>
          <target state="translated">Инструмент Блокировки Профилирования системы во время выполнения.</target>
        </trans-unit>
        <trans-unit id="95c23e7c0085aa6a0c7d2ad3fa2a9bf1781844a4" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents:</source>
          <target state="translated">Второе использование обратного слеша обеспечивает способ кодирования непечатаемых символов в шаблонах видимым образом.Нет никаких ограничений на появление непечатающихся символов,кроме двоичного нуля,который прерывает шаблон.Когда шаблон подготавливается путем редактирования текста,часто проще использовать одну из следующих экранирующих последовательностей,чем двоичный символ,который он представляет:</target>
        </trans-unit>
        <trans-unit id="a201830f8803ef3e185325b4733be9adee2043a8" translate="yes" xml:space="preserve">
          <source>A second way to specify the configuration file is to set environment variable &lt;code&gt;ERL_INETRC&lt;/code&gt; to the full name of the file. Example (bash):</source>
          <target state="translated">Второй способ указать файл конфигурации - установить в переменной среды &lt;code&gt;ERL_INETRC&lt;/code&gt; полное имя файла. Пример (bash):</target>
        </trans-unit>
        <trans-unit id="7c03bbcb91f237153974d54fa53f5db174271fa2" translate="yes" xml:space="preserve">
          <source>A seed value for the generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab326930bafdf3ccbffeefe99fd3e37e21b2a36" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf16&lt;/code&gt; can match 2 or 4 bytes in the binary. The match fails if the binary at the match position does not contain a legal UTF-16 encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</source>
          <target state="translated">Сегмент типа &lt;code&gt;utf16&lt;/code&gt; может соответствовать 2 или 4 байтам в двоичном файле . Сопоставление не удается, если двоичный файл в позиции сопоставления не содержит допустимую кодировку UTF-16 кодовой точки Unicode. (См. RFC-2781 или стандарт Unicode.)</target>
        </trans-unit>
        <trans-unit id="39d79b140754fe8ea4a56be0590e56af2f7d1ffd" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf32&lt;/code&gt; can match 4 bytes in the binary in the same way as an &lt;code&gt;integer&lt;/code&gt; segment matches 32 bits. The match fails if the resulting integer is outside the legal ranges mentioned above.</source>
          <target state="translated">Сегмент типа &lt;code&gt;utf32&lt;/code&gt; может соответствовать 4 байтам в двоичном формате так же, как &lt;code&gt;integer&lt;/code&gt; сегмент соответствует 32 битам. Сопоставление не удается, если результирующее целое число выходит за пределы допустимых диапазонов, указанных выше.</target>
        </trans-unit>
        <trans-unit id="9984182f8f78656080573a1d2d8804143caf4c98" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf8&lt;/code&gt; matches 1-4 bytes in the binary, if the binary at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the Unicode standard.)</source>
          <target state="translated">Сегмент типа &lt;code&gt;utf8&lt;/code&gt; соответствует 1&amp;ndash;4 байтам в двоичном файле, если двоичный файл в позиции сопоставления содержит допустимую последовательность UTF-8. (См. RFC-3629 или стандарт Unicode.)</target>
        </trans-unit>
        <trans-unit id="a68e30a75c41fb283b1d801f37a87f7e17458fd0" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behavior as for any &lt;code&gt;gen_*&lt;/code&gt; behavior, as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviors must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the callback module.</source>
          <target state="translated">Выборочный прием не может быть использован из поведения &lt;code&gt;gen_statem&lt;/code&gt; , как и для любого поведения &lt;code&gt;gen_*&lt;/code&gt; , поскольку оператор приема находится внутри самого &lt;code&gt;gen_*&lt;/code&gt; . Он должен быть там, потому что все &lt;code&gt;sys&lt;/code&gt; - совместимые поведения должны отвечать на системные сообщения и, следовательно, делать это в цикле приема своего движка, передавая несистемные сообщения в модуль обратного вызова.</target>
        </trans-unit>
        <trans-unit id="0745a97f08a27b99c095a4208fa9ad69e20c8725" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behaviour (or from any &lt;code&gt;gen_*&lt;/code&gt; behaviour), as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviours must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the &lt;strong&gt;callback module&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784ef7e594348fdd6dc02214ab3a2844aad416d3" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="translated">Группа последовательностей может иметь подгруппы. Такие подгруппы могут иметь любое свойство, то есть они не обязательно должны быть последовательностями. Если вы хотите, чтобы статус подгруппы влиял на последовательность на уровне выше, верните &lt;code&gt;{return_group_result,Status}&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; , как описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; в написании наборов тестов&amp;raquo;. Неудачная подгруппа ( &lt;code&gt;Status == failed&lt;/code&gt; ) вызывает сбой выполнения последовательности так же, как и тестовый пример.</target>
        </trans-unit>
        <trans-unit id="93d62b825639ee7da64906b6efb6ddcaeabea4e9" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0188d5cbf054170629f3b385114881c263276f" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;code&gt;Len&lt;/code&gt; big-endian unsigned integers (4 bytes each, so &lt;code&gt;N'&lt;/code&gt; = 4 * &lt;code&gt;Len&lt;/code&gt;), but is to be regarded as uninterpreted data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c229a36faac40695a5902fc9fc7dd25d6c2813" translate="yes" xml:space="preserve">
          <source>A sequence of test cases is defined as a test case group with a &lt;code&gt;sequence&lt;/code&gt; property. Test case groups are defined through function &lt;code&gt;groups/0&lt;/code&gt; in the test suite (for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Последовательность тестовых примеров определяется как группа тестовых примеров со свойством &lt;code&gt;sequence&lt;/code&gt; . Группы тестовых наборов определяются через &lt;code&gt;groups/0&lt;/code&gt; функций / 0 в наборе тестов (подробности см. В разделе &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; тестовых примеров .</target>
        </trans-unit>
        <trans-unit id="c3bba90a5446a96b415be975533162f2c93173c4" translate="yes" xml:space="preserve">
          <source>A server (daemon) is started with &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt;. Possible channel handlers (subsystems) are declared with the &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; option when the daemon is started.</source>
          <target state="translated">Сервер (демон) запускается с помощью &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt; . Возможные обработчики каналов (подсистемы) объявляются с параметром &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; при запуске демона.</target>
        </trans-unit>
        <trans-unit id="c393c06211d748a66541912f6034dffb6bc6e68b" translate="yes" xml:space="preserve">
          <source>A server (daemon) will use the user name &lt;code&gt;foo&lt;/code&gt;, and a client will use the name &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7591fe377fd82c97d5cbe48dffa3dba89975a255" translate="yes" xml:space="preserve">
          <source>A server only does x509-path validation in mode &lt;code&gt;verify_peer&lt;/code&gt;, as it then sends a certificate request to the client (this message is not sent if the verify option is &lt;code&gt;verify_none&lt;/code&gt;). You can then also want to specify option &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt;.</source>
          <target state="translated">Сервер выполняет только проверку x509-пути в режиме &lt;code&gt;verify_peer&lt;/code&gt; , поскольку затем он отправляет клиенту запрос сертификата (это сообщение не отправляется, если опция проверки - &lt;code&gt;verify_none&lt;/code&gt; ). Затем вы также можете указать опцию &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e1655ac106f00ec7e87a3349502f0ed6e2829f5" translate="yes" xml:space="preserve">
          <source>A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55cabe8354d1d604d4df37a3e5535ff9d3abddc" translate="yes" xml:space="preserve">
          <source>A server which receives just enough requests to never become idle will score a CPU utilization of 100%. If the server receives 50% more requests, it will still score 100%. When the system load is calculated with the percentage formula shown previously, the load will increase from 80% to 87%.</source>
          <target state="translated">Сервер,который получает достаточно запросов,чтобы никогда не простаивать,получит 100% загрузку процессора.Если сервер получает на 50% больше запросов,он все равно получит 100%.Когда загрузка системы рассчитывается по формуле процента,показанной ранее,нагрузка увеличится с 80% до 87%.</target>
        </trans-unit>
        <trans-unit id="49249370ad03c7d756d03cbc940860544a07d772" translate="yes" xml:space="preserve">
          <source>A server- or client-channel process can choose to close their session by sending a close event.</source>
          <target state="translated">Процесс серверного или клиентского канала может решить закрыть свою сессию,отправив событие закрытия.</target>
        </trans-unit>
        <trans-unit id="80df1578413d7127e8d72a01fdf816a3b3d60cac" translate="yes" xml:space="preserve">
          <source>A server-side subssystem (channel) server is requested by the client with &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сервер подсистемы (канала) на стороне сервера запрашивается клиентом с помощью &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d3204ae6a9c144bcf2930bab159f079cdea0012" translate="yes" xml:space="preserve">
          <source>A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Служба определяет локально реализованный узел Diameter, определяя возможности, которые будут объявляться во время обмена возможностями. Транспорты добавляются к сервису с помощью &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4b0724093ca8cf67b42fd8065ef62234f98ab2d" translate="yes" xml:space="preserve">
          <source>A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; is passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">Служба должна настроить один кортеж для каждого приложения Diameter, которое она намеревается поддерживать. Для исходящего запроса соответствующий &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; передается в &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; , в то время как для входящего запроса идентификатор приложения в заголовке сообщения определяет приложение, идентификатор указывается в файле &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; приложения .</target>
        </trans-unit>
        <trans-unit id="aaffe8ed9bffeb5034f89141848d697c4f8ddf46" translate="yes" xml:space="preserve">
          <source>A service started as &lt;code&gt;stand_alone&lt;/code&gt;, that is, the service is not started as part of the &lt;code&gt;Inets&lt;/code&gt; application, lose all OTP application benefits, such as soft upgrade. The &lt;code&gt;stand_alone&lt;/code&gt;-service is linked to the process that started it. Usually some supervision functionality is still in place and in some sense the calling process becomes the top supervisor.</source>
          <target state="translated">Служба, запущенная как &lt;code&gt;stand_alone&lt;/code&gt; , то есть служба не запускается как часть приложения &lt;code&gt;Inets&lt;/code&gt; , теряет все преимущества приложения OTP, такие как мягкое обновление. &lt;code&gt;stand_alone&lt;/code&gt; -service связан с процессом , который начал его. Обычно некоторые функции надзора все еще используются, и в некотором смысле вызывающий процесс становится главным супервизором.</target>
        </trans-unit>
        <trans-unit id="e8a6a012891bda48b015b0c9afa1553acf746ed9" translate="yes" xml:space="preserve">
          <source>A service that does not use shared peers will always pass the empty list as the second argument of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">Служба, которая не использует общих одноранговых узлов, всегда будет передавать пустой список в качестве второго аргумента &lt;code&gt;pick_peer/4&lt;/code&gt; вызовов pick_peer / 4 .</target>
        </trans-unit>
        <trans-unit id="10b22bcc7e1248f51cdd1cbb03116a8abb78e603" translate="yes" xml:space="preserve">
          <source>A service to read internally formatted wrap disk logs.</source>
          <target state="translated">Служба для чтения внутренне отформатированных оберточных дисковых журналов.</target>
        </trans-unit>
        <trans-unit id="948069c04efacc3c5dcde4803a65b30408e7f31d" translate="yes" xml:space="preserve">
          <source>A session opened in this way is closed using function &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сессия, открытая таким образом, закрывается с помощью функции &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8dce1ed875eff8e76251a001abc25f652960e66" translate="yes" xml:space="preserve">
          <source>A set of calls between strongly connected components is a sorted list without duplicates of &lt;code&gt;ComponentCall&lt;/code&gt;.</source>
          <target state="translated">Набор вызовов между сильно связанными компонентами представляет собой отсортированный список без дубликатов &lt;code&gt;ComponentCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="710107e57e111e349884878304dfebbb60768c1a" translate="yes" xml:space="preserve">
          <source>A set of calls is represented by a sorted list without duplicates of &lt;code&gt;call()&lt;/code&gt;.</source>
          <target state="translated">Набор вызовов представлен отсортированным списком без дубликатов &lt;code&gt;call()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ec339bfafa729e7589bcb584094f5693b62949" translate="yes" xml:space="preserve">
          <source>A set of constants is represented by a sorted list without duplicates of &lt;code&gt;constant()&lt;/code&gt;.</source>
          <target state="translated">Набор констант представлен отсортированным списком без дубликатов &lt;code&gt;constant()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8184ec1b26baabe0df7138952aceaf16df4b13b" translate="yes" xml:space="preserve">
          <source>A set of functions is provided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46692ec19a49b0489e3ac224ff31df52bd24aef0" translate="yes" xml:space="preserve">
          <source>A set of functions is provvided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="translated">Предусмотрен набор функций для отправки и получения непрерывных частей файла для сохранения в удаленном файле. Для отправки см. &lt;code&gt;send_chunk_start/2&lt;/code&gt; , &lt;code&gt;send_chunk/2&lt;/code&gt; и &lt;code&gt;send_chunk_end/1&lt;/code&gt; . Для получения см. &lt;code&gt;recv_chunk_start/2&lt;/code&gt; и &lt;code&gt;recv_chunk/&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a9d7c3dd3508b04f4667584c78e7f619f9eb1de" translate="yes" xml:space="preserve">
          <source>A set of line numbered function calls is represented by a sorted list without duplicates of &lt;code&gt;CallAt&lt;/code&gt;.</source>
          <target state="translated">Набор вызовов функций с пронумерованными &lt;code&gt;CallAt&lt;/code&gt; представлен отсортированным списком без дубликатов CallAt .</target>
        </trans-unit>
        <trans-unit id="6b7c151fe3e99d8bd5f4ffa52f47c3f04812cf74" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions and function calls is represented by a sorted list without duplicates of &lt;code&gt;AllLines&lt;/code&gt;.</source>
          <target state="translated">Набор функций и вызовов функций с номерами строк представлен отсортированным списком без дубликатов &lt;code&gt;AllLines&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="840dbd2f93a5198291444ddc8bbccef2c8f9c9ff" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions is represented by a sorted list without duplicates of &lt;code&gt;DefineAt&lt;/code&gt;.</source>
          <target state="translated">Набор функций с номерами строк представлен отсортированным списком без дубликатов &lt;code&gt;DefineAt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a5c61082d9404d5c0adf57236aa5f42fbc02337" translate="yes" xml:space="preserve">
          <source>A set of strongly connected components is a sorted list without duplicates of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">Набор сильно связанных компонентов - это отсортированный список без дубликатов &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac0087ee308abd483706f991654adce8870956a6" translate="yes" xml:space="preserve">
          <source>A set of tables is created. The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates the required database tables. The options available with &lt;code&gt;ArgList&lt;/code&gt; are explained in &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Создан набор таблиц. Функция &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; создает необходимые таблицы базы данных. Параметры, доступные в &lt;code&gt;ArgList&lt;/code&gt; , описаны в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f06211d11839665e84e1ea20d520a0f11afac6" translate="yes" xml:space="preserve">
          <source>A set of test cases sharing configuration functions and execution properties. The execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is be repeated. Test case groups can also be nested. That is, a group can, besides test cases, contain subgroups.</source>
          <target state="translated">Набор тестовых примеров,совместно использующих функции конфигурации и свойства выполнения.Свойства исполнения определяют,будут ли тестовые случаи в группе выполняться в случайном порядке,параллельно или последовательно,и будет ли выполнение группы повторяться.Группы тестовых сценариев также могут быть вложены.То есть группа может,помимо тестовых случаев,содержать подгруппы.</target>
        </trans-unit>
        <trans-unit id="12949a595f1f2f62a415607d8b62df7565321239" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">Краткая форма для &lt;code&gt;report_errors&lt;/code&gt; и &lt;code&gt;report_warnings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63beb5981caaa740ca850381d113e7457110327c" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">Краткая форма для &lt;code&gt;return_errors&lt;/code&gt; и &lt;code&gt;return_warnings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea5611de1365c235cc088e3d33261341dcca035" translate="yes" xml:space="preserve">
          <source>A signal can be delivered to the remote process/service using the following message. Some systems do not support signals, in which case they are to ignore this message. There is currently no function to generate this event as the signals referred to are on OS-level and not something generated by an Erlang program.</source>
          <target state="translated">Сигнал может быть передан удаленному процессу/службе с помощью следующего сообщения.Некоторые системы не поддерживают сигналы,в этом случае они должны игнорировать это сообщение.В настоящее время нет функции генерации этого события,так как сигналы,о которых идет речь,находятся на уровне операционной системы,а не что-то,генерируемое программой Erlang.</target>
        </trans-unit>
        <trans-unit id="42eda09ed588353be26cc09cfa2d978f18b6e4d1" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for representation of time.</source>
          <target state="translated">Знаковый 64-битный целочисленный тип для представления времени.</target>
        </trans-unit>
        <trans-unit id="2ec4fc4bbc8342af35d07fe169518f0743782cba" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for time representation.</source>
          <target state="translated">Знаковый 64-битный целочисленный тип для представления времени.</target>
        </trans-unit>
        <trans-unit id="38a842896cfe88c4a3ddef8d3cf91788c49c732c" translate="yes" xml:space="preserve">
          <source>A signed integer type, the size of &lt;code&gt;ErlDrvSizeT&lt;/code&gt;.</source>
          <target state="translated">Целочисленный тип со &lt;code&gt;ErlDrvSizeT&lt;/code&gt; , размером ErlDrvSizeT .</target>
        </trans-unit>
        <trans-unit id="1024fdaa70807f16fbbe54892e86672633b5e291" translate="yes" xml:space="preserve">
          <source>A significant number of middleboxes misbehave when a TLS 1.3 connection is negotiated. Implementations can increase the chance of making connections through those middleboxes by making the TLS 1.3 handshake more like a TLS 1.2 handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0fe9a2b6f1d0a57855755f4b057af6a3783f46" translate="yes" xml:space="preserve">
          <source>A similar syntax as for module attributes is used for specifying types and function specifications:</source>
          <target state="translated">Синтаксис,аналогичный синтаксису атрибутов модуля,используется для указания типов и спецификаций функций:</target>
        </trans-unit>
        <trans-unit id="8a8c55df8388e2c8abf4b42d441b92ec7fc5ed46" translate="yes" xml:space="preserve">
          <source>A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</source>
          <target state="translated">Простой инструмент профилирования подсчета вызовов с использованием точек останова для минимального влияния на производительность.</target>
        </trans-unit>
        <trans-unit id="c5cb837e5d2ca7e262291078f0d5802db7966be5" translate="yes" xml:space="preserve">
          <source>A simple Erlang SCTP client that uses the &lt;code&gt;connect_init&lt;/code&gt; API:</source>
          <target state="translated">Простой клиент SCTP на Erlang, использующий API &lt;code&gt;connect_init&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d0c9a192d81f4fa039cbd886ce4bd4a73ce2b099" translate="yes" xml:space="preserve">
          <source>A simple configuration handling driver, asking an external server for configuration data, can be implemented as follows:</source>
          <target state="translated">Простой драйвер для работы с конфигурацией,запрашивающий конфигурационные данные у внешнего сервера,может быть реализован следующим образом:</target>
        </trans-unit>
        <trans-unit id="94159518c423ba9ecd622c20fd73db453e69d787" translate="yes" xml:space="preserve">
          <source>A simple distributed agent can be managed without sub-agents. The instrumentation functions can use distributed Erlang to communicate with other parts of the application. However, a sub-agent can be used on each node if this generates too much unnecessary traffic. A sub-agent processes requests per incoming SNMP request, not per variable. Therefore the network traffic is minimized.</source>
          <target state="translated">Простой распределенный агент может управляться без субагентов.Функции приборов могут использовать распределенный Erlang для связи с другими частями приложения.Однако,субагент может быть использован на каждом узле,если это генерирует слишком много ненужного трафика.Субагент обрабатывает запросы на входящий SNMP-запрос,а не на переменную.Поэтому сетевой трафик сводится к минимуму.</target>
        </trans-unit>
        <trans-unit id="37a291b9ccd26ae2e858205df24cc14753b44a96" translate="yes" xml:space="preserve">
          <source>A simple example of how to use the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">Простой пример использования компонента &quot;Менеджер&quot; в SNMP Development Toolkit.</target>
        </trans-unit>
        <trans-unit id="e0d43223e0be204bdc5f431e2cd09f2620cd3cba" translate="yes" xml:space="preserve">
          <source>A simple example of how to write agent test cases, using the new manager.</source>
          <target state="translated">Простой пример того,как писать тестовые кейсы для агентов,используя нового менеджера.</target>
        </trans-unit>
        <trans-unit id="a47de2d4ec5f53818458005215063c067e9f2a3e" translate="yes" xml:space="preserve">
          <source>A simple example. A single quad core processor can be described as follows:</source>
          <target state="translated">Простой пример.Процессор с одним четырехъядерным процессором можно описать следующим образом:</target>
        </trans-unit>
        <trans-unit id="dd61143e005b303fe8d62ae782f18058638458a2" translate="yes" xml:space="preserve">
          <source>A simple handler that prints to the terminal can be implemented as follows:</source>
          <target state="translated">Простой обработчик,который печатает на терминал,может быть реализован следующим образом:</target>
        </trans-unit>
        <trans-unit id="d231f36ed1b4dce67cc3b50e0ae15aa4df7e9395" translate="yes" xml:space="preserve">
          <source>A simple interactive configuration tool. Simple configuration files can be generated, but more complex configurations still have to be edited manually.</source>
          <target state="translated">Простой интерактивный инструмент настройки.Простые конфигурационные файлы могут быть сгенерированы,но более сложные конфигурации все равно придется редактировать вручную.</target>
        </trans-unit>
        <trans-unit id="9bb0a791b7816e17ce1b48c1aee66bf6abe2e694" translate="yes" xml:space="preserve">
          <source>A simple solution would be to use the &lt;code&gt;name&lt;/code&gt; field as the key instead of the &lt;code&gt;idno&lt;/code&gt; field, but that would cause problems if the names were not unique. A more general solution would be to create a second table with &lt;code&gt;name&lt;/code&gt; as key and &lt;code&gt;idno&lt;/code&gt; as data, that is, to index (invert) the table regarding the &lt;code&gt;name&lt;/code&gt; field. Clearly, the second table would have to be kept consistent with the master table. Mnesia can do this for you, but a home brew index table can be very efficient compared to the overhead involved in using Mnesia.</source>
          <target state="translated">Простым решением было бы использовать поле &lt;code&gt;name&lt;/code&gt; в качестве ключа вместо поля &lt;code&gt;idno&lt;/code&gt; , но это могло бы вызвать проблемы, если бы имена не были уникальными. Более общим решением было бы создать вторую таблицу с &lt;code&gt;name&lt;/code&gt; качестве ключа и &lt;code&gt;idno&lt;/code&gt; в качестве данных, то есть индексировать (инвертировать) таблицу относительно поля &lt;code&gt;name&lt;/code&gt; . Очевидно, что вторая таблица должна быть согласована с основной таблицей. Mnesia может сделать это за вас, но таблица индексов домашнего пива может быть очень эффективной по сравнению с накладными расходами, связанными с использованием Mnesia.</target>
        </trans-unit>
        <trans-unit id="a677c35bea852cdbf8756b158d2b8bcbf8d2e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue the following commands:</source>
          <target state="translated">Простой способ сделать это-выдать следующие команды:</target>
        </trans-unit>
        <trans-unit id="464b91e40e2a3cb96819c357b1617d8db059e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue these commands:</source>
          <target state="translated">Простой способ сделать это-выдать эти команды:</target>
        </trans-unit>
        <trans-unit id="eea77823d49a9512680d9b481e0a65ed1b7a8abb" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;~&lt;/code&gt; is expected in the input.</source>
          <target state="translated">На входе ожидается одиночный &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d3145e708c1deab465a16f4608e04895d3f01b3" translate="yes" xml:space="preserve">
          <source>A single atom represents a module name, and is equivalent to &lt;code&gt;{module, ModuleName}&lt;/code&gt;. This is often used as in the call &lt;code&gt;eunit:test(some_module)&lt;/code&gt;.</source>
          <target state="translated">Отдельный атом представляет имя модуля и эквивалентен &lt;code&gt;{module, ModuleName}&lt;/code&gt; . Это часто используется как в вызове &lt;code&gt;eunit:test(some_module)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="437abe5f66fc807f023b84e5b53bea27300039ac" translate="yes" xml:space="preserve">
          <source>A single binary can be sent with &lt;code&gt;driver_output_binary()&lt;/code&gt;.</source>
          <target state="translated">Один двоичный файл можно отправить с помощью &lt;code&gt;driver_output_binary()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d82ab9afcf3b874d81d1b01e2b29a3023c6ead3c" translate="yes" xml:space="preserve">
          <source>A single line (as in former example) is requested with the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">Одна линия (как в предыдущем примере) запрашивается со следующей &lt;code&gt;Request&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91eb11dd51a7d947aa277af7b00518dd07ecd8dd" translate="yes" xml:space="preserve">
          <source>A single string represents the path of a file or directory, and is equivalent to &lt;code&gt;{file, Path}&lt;/code&gt;, or &lt;code&gt;{dir, Path}&lt;/code&gt;, respectively, depending on what &lt;code&gt;Path&lt;/code&gt; refers to in the file system.</source>
          <target state="translated">Одна строка представляет путь к файлу или каталогу и эквивалентна &lt;code&gt;{file, Path}&lt;/code&gt; или &lt;code&gt;{dir, Path}&lt;/code&gt; , соответственно, в зависимости от того, на какой &lt;code&gt;Path&lt;/code&gt; ссылается в файловой системе.</target>
        </trans-unit>
        <trans-unit id="f128070bab19006a2ef91c51aaca808921167bc6" translate="yes" xml:space="preserve">
          <source>A single test included in a test suite. A test case is implemented as a function in a test suite module.</source>
          <target state="translated">Один тест,включенный в набор тестов.Тестовый пример реализован как функция в модуле набора тестов.</target>
        </trans-unit>
        <trans-unit id="c6134a35a4b3aed44a3d6f996738074a3183b087" translate="yes" xml:space="preserve">
          <source>A single, well-defined test, that somehow can be uniquely identified. When executed, the test case either &lt;strong&gt;passes&lt;/strong&gt; or &lt;strong&gt;fails&lt;/strong&gt;; the test report should identify exactly which test cases failed.</source>
          <target state="translated">Единый, четко определенный тест, который каким-то образом можно однозначно идентифицировать. При выполнении тестовый пример либо &lt;strong&gt;проходит,&lt;/strong&gt; либо &lt;strong&gt;не &lt;/strong&gt;&lt;strong&gt;проходит&lt;/strong&gt; ; отчет о тестировании должен точно определять, какие тестовые примеры не прошли.</target>
        </trans-unit>
        <trans-unit id="ff7e932fb59b9670681676d154f390a5b9707270" translate="yes" xml:space="preserve">
          <source>A situation where it might be useful to add an algorithm is when one need to use a supported but disabled one. An example is the &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; which nowadays is very unsecure and therefore disabled. It is however still supported and might be used.</source>
          <target state="translated">Ситуация, когда может быть полезно добавить алгоритм, - это когда нужно использовать поддерживаемый, но отключенный. Примером может служить &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; который в настоящее время очень небезопасен и поэтому отключен. Однако он все еще поддерживается и может быть использован.</target>
        </trans-unit>
        <trans-unit id="c8a737055966988fa33536560d8ee3886f563bb5" translate="yes" xml:space="preserve">
          <source>A skeleton is a piece of pre-written code that can be inserted into the buffer. Erlang mode comes with a set of predefined skeletons. The skeletons can be accessed either from the Erlang menu of from commands named &lt;code&gt;tempo-template-erlang-*&lt;/code&gt;, as the skeletons is defined using the standard Emacs package &quot;tempo&quot;. Here follows a brief description of the available skeletons:</source>
          <target state="translated">Каркас - это кусок заранее написанного кода, который можно вставить в буфер. В режиме Erlang есть набор предопределенных скелетов. К скелетам можно получить доступ либо из меню Erlang, либо из команд с именем &lt;code&gt;tempo-template-erlang-*&lt;/code&gt; , так как скелеты определяются с использованием стандартного пакета Emacs &amp;laquo;tempo&amp;raquo;. Ниже следует краткое описание имеющихся скелетов:</target>
        </trans-unit>
        <trans-unit id="3fbeb5f6d202d2f6a94d6926e8772e60f8395d0b" translate="yes" xml:space="preserve">
          <source>A sketch of the procedure employed:</source>
          <target state="translated">Очерк используемой процедуры:</target>
        </trans-unit>
        <trans-unit id="347ad9db1092bfae38de28e8384c541f8eda0f16" translate="yes" xml:space="preserve">
          <source>A slogan indicating the reason for the dump</source>
          <target state="translated">Лозунг,указывающий на причину свалки...</target>
        </trans-unit>
        <trans-unit id="c82db0ac725e371be4e92cf842d525309be1a960" translate="yes" xml:space="preserve">
          <source>A small &lt;code&gt;ssh&lt;/code&gt; subsystem that echoes N bytes can be implemented as shown in the following example:</source>
          <target state="translated">Небольшая подсистема &lt;code&gt;ssh&lt;/code&gt; , которая отображает N байтов, может быть реализована, как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="ee793e88b05c2c54637d37d2dc3b6df251a95612" translate="yes" xml:space="preserve">
          <source>A small note about each failed test case.</source>
          <target state="translated">Небольшая записка о каждом неудачном тесте.</target>
        </trans-unit>
        <trans-unit id="89269626521455c0533dcc1024e681dcdd2fe91d" translate="yes" xml:space="preserve">
          <source>A small number of &quot;-&quot; flags exist, which now actually are emulator flags, see the description below.</source>
          <target state="translated">Существует небольшое количество &quot;-&quot; флагов,которые теперь фактически являются эмуляторными флагами,см.описание ниже.</target>
        </trans-unit>
        <trans-unit id="b8571dea892b8010a396168429a316241eeb9263" translate="yes" xml:space="preserve">
          <source>A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;&lt;code&gt;...&lt;/code&gt;&quot;. &lt;code&gt;CharsLimit&lt;/code&gt; defaults to -1, which means no limit on the number of characters returned.</source>
          <target state="translated">Мягкое ограничение на количество возвращаемых символов. Когда количество символов достигнуто, оставшиеся структуры заменяются на &amp;laquo; &lt;code&gt;...&lt;/code&gt; &amp;raquo;. &lt;code&gt;CharsLimit&lt;/code&gt; по умолчанию равен -1, что означает отсутствие ограничения на количество возвращаемых символов.</target>
        </trans-unit>
        <trans-unit id="c5403e8588747737164215b85effd60defff4f50" translate="yes" xml:space="preserve">
          <source>A sorted list of &lt;code&gt;{Node, Count}&lt;/code&gt; tuples that are sorted in increasing &lt;code&gt;Count&lt;/code&gt; order. &lt;code&gt;Count&lt;/code&gt; is the total number of replicas that this fragmented table hosts on each &lt;code&gt;Node&lt;/code&gt;. The list always contains at least all nodes in &lt;code&gt;node_pool&lt;/code&gt;. Nodes that do not belong to &lt;code&gt;node_pool&lt;/code&gt; are put last in the list even if their &lt;code&gt;Count&lt;/code&gt; is lower.</source>
          <target state="translated">Отсортированный список &lt;code&gt;{Node, Count}&lt;/code&gt; кортежей, которые отсортированы в увеличении &lt;code&gt;Count&lt;/code&gt; порядка. &lt;code&gt;Count&lt;/code&gt; - это общее количество реплик, которые эта фрагментированная таблица размещает на каждом &lt;code&gt;Node&lt;/code&gt; . Список всегда содержит по крайней мере все узлы в &lt;code&gt;node_pool&lt;/code&gt; . Узлы , которые не принадлежат к &lt;code&gt;node_pool&lt;/code&gt; помещаются последним в списке , даже если их &lt;code&gt;Count&lt;/code&gt; является ниже.</target>
        </trans-unit>
        <trans-unit id="920a6a7e45bffb0b7a8b87d5da85daae27b47541" translate="yes" xml:space="preserve">
          <source>A space-separated string specifying the program to be executed. The second field is typically a command name such as &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Строка, разделенная пробелами, определяющая программу, которую нужно выполнить. Второе поле обычно представляет собой имя команды, например &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1636d9fe46ac8e8fc16a7c4f98f7781df515d1ba" translate="yes" xml:space="preserve">
          <source>A spawn reply message will be sent to the caller regardless of whether the operation succeeds or not. If the call to &lt;code&gt;spawn_request()&lt;/code&gt; returns without raising an exception and the &lt;code&gt;reply&lt;/code&gt; option is set to &lt;code&gt;yes&lt;/code&gt;, the caller is guaranteed to be delivered either a &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;#spawn_request_error_message&quot;&gt;&lt;i&gt;error message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;reply&lt;/code&gt; option is by default set to &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d70a605fe0829e66ec6bd35120d29d1093a9d34" translate="yes" xml:space="preserve">
          <source>A spawn request can be abandoned by calling &lt;code&gt;&lt;a href=&quot;#spawn_request_abandon-1&quot;&gt;spawn_request_abandon/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db8ca18baf39ee044af1edfffece3234114b4cf" translate="yes" xml:space="preserve">
          <source>A spawn request can only be successfully abandoned until the spawn request has completed. When a spawn request has been successfully abandoned, the caller will not be effected by future direct effects of the spawn request itself. For example, it will not receive a spawn reply message. The request is however not withdrawn, so a new process may or may not be created due to the request. If a new process is created after the spawn request was abandoned, no monitors nor links will be set up to the caller of &lt;code&gt;spawn_request_abandon/1&lt;/code&gt; due to the spawn request. If the spawn request included the &lt;code&gt;link&lt;/code&gt; option, the process created due to this request will be sent an exit signal from its parent with the exit reason &lt;code&gt;abandoned&lt;/code&gt; when it is detected that the spawn operation has succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bbb00e915060a377363fa9765e2fd6a815cb4ee" translate="yes" xml:space="preserve">
          <source>A special item that consists of (? followed by a number &amp;gt; 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression.</source>
          <target state="translated">Специальный элемент, состоящий из (?, За которым следует число&amp;gt; 0 и закрывающая скобка, является рекурсивным вызовом подпрограммы подшаблона данного числа, если он встречается внутри этого подшаблона. (Если нет, то это нерекурсивный вызов подпрограммы , который описывается в следующем разделе.) Специальный элемент (? R) или (? 0) - это рекурсивный вызов всего регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="61cc845c2afb7bd85647ca3d1e06f065258da29c" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d7d4630bf6e699f86315587f52b147af8c7634" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="translated">Специальная процедура, вызываемая с помощью &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; . Он работает как &amp;laquo;ioctl&amp;raquo; для драйверов Erlang. Данные, указанные для &lt;code&gt;port_control/3&lt;/code&gt; , поступают в &lt;code&gt;buf&lt;/code&gt; и &lt;code&gt;len&lt;/code&gt; . Драйвер может отправлять данные обратно, используя &lt;code&gt;*rbuf&lt;/code&gt; и &lt;code&gt;rlen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="818bed6690afd85a8e837d5ce544a94b65462268" translate="yes" xml:space="preserve">
          <source>A special type of error is when no actual invalid integers or bytes are found, but a trailing &lt;code&gt;binary()&lt;/code&gt; consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An &lt;code&gt;incomplete&lt;/code&gt; tuple is then returned instead of the &lt;code&gt;error&lt;/code&gt; tuple. It consists of the same parts as the &lt;code&gt;error&lt;/code&gt; tuple, but the tag is &lt;code&gt;incomplete&lt;/code&gt; instead of &lt;code&gt;error&lt;/code&gt; and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.</source>
          <target state="translated">Особый тип ошибки возникает, когда не обнаруживаются действительные недопустимые целые числа или байты, но завершающий &lt;code&gt;binary()&lt;/code&gt; состоит из слишком малого количества байтов для декодирования последнего символа. Эта ошибка может возникать, если байты читаются из файла по частям или если двоичные файлы другими способами разбиваются на границах символов, отличных от UTF. &lt;code&gt;incomplete&lt;/code&gt; кортеж затем возвращаются вместо &lt;code&gt;error&lt;/code&gt; кортежа. Он состоит из тех же частей, что и кортеж с &lt;code&gt;error&lt;/code&gt; , но тег является &lt;code&gt;incomplete&lt;/code&gt; а не &lt;code&gt;error&lt;/code&gt; а последний элемент всегда гарантированно является двоичным, состоящим из первой части (пока) действительного символа UTF.</target>
        </trans-unit>
        <trans-unit id="3916fb4d3122880bb80b867dc9d2527f278db29f" translate="yes" xml:space="preserve">
          <source>A specific instruction can have at most 6 operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb0a5535ecc63bd01763b04dca57f5130132dad" translate="yes" xml:space="preserve">
          <source>A specific instruction is defined by first giving its name followed by the types for each operand. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebe590a8a4fd637cbd36f90802e9523ed6a4512" translate="yes" xml:space="preserve">
          <source>A specification (or contract) for a function is given using the &lt;code&gt;-spec&lt;/code&gt; attribute. The general format is as follows:</source>
          <target state="translated">Спецификация (или контракт) для функции дается с использованием атрибута &lt;code&gt;-spec&lt;/code&gt; . Общий формат следующий:</target>
        </trans-unit>
        <trans-unit id="7dc4ccb3d8ddcce0db9cf1c2ea5d5fda23fcb4be" translate="yes" xml:space="preserve">
          <source>A state change cancels a &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; and any new transition option of this type belongs to the new state.</source>
          <target state="translated">Изменение состояния отменяет &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; и любая новая опция перехода этого типа принадлежит новому состоянию.</target>
        </trans-unit>
        <trans-unit id="c48da406465f6ed9b4beb63690dac21a0092fc89" translate="yes" xml:space="preserve">
          <source>A stateful session ticket is a database reference to internal state information. A stateless session ticket is a self-encrypted binary that contains both cryptographic keying material and state data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce1fae1923f3d7397b496fc579d7f7f29266cd7" translate="yes" xml:space="preserve">
          <source>A status, which is &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. An inactive breakpoint is ignored.</source>
          <target state="translated">Статус, &lt;strong&gt;активный&lt;/strong&gt; или &lt;strong&gt;неактивный&lt;/strong&gt; . Неактивная точка останова игнорируется.</target>
        </trans-unit>
        <trans-unit id="cb3254f6f71d42ad5babf60af6c4beadc5fe794a" translate="yes" xml:space="preserve">
          <source>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</source>
          <target state="translated">Липкий замок-это замок,который остается на месте в узле после того,как сделка,которая первой приобрела замок,завершилась.Чтобы проиллюстрировать это,предположим,что выполняется следующая транзакция:</target>
        </trans-unit>
        <trans-unit id="167c0844b749b5b3dade41e2fb760895a3da7567" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt; erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d036eed01d979d152da2689054b2a8a3616ab3b" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Строка, содержащая номер выпуска OTP (такой же, как возвращаемый &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7a887f90504538f7764832dfb1ec18f08b3d4d4e" translate="yes" xml:space="preserve">
          <source>A string containing the regular expression</source>
          <target state="translated">Строка,содержащая регулярное выражение</target>
        </trans-unit>
        <trans-unit id="6a30a94b91175e13eab64a9eaaf574ffd247249b" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt; erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f49966a17385c888cdd7ff3581d6cc3b4a55ee" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Строка, содержащая номер версии системы времени выполнения (такая же, как возвращаемая &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a067c189aea167f729e4e4094e5cef684c3ebe5a" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable names using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) and &lt;code&gt;$=&lt;/code&gt; characters are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">Строка, содержащая допустимые символы в конкретной ОС для имен переменных среды с использованием кодировки &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что конкретно нулевые символы (целочисленное значение ноль) и символы &lt;code&gt;$=&lt;/code&gt; не допускаются. Однако обратите внимание, что не все недопустимые символы обязательно приведут к сбою операций primitiv, но вместо этого могут дать недопустимые результаты.</target>
        </trans-unit>
        <trans-unit id="70f78f37d5d4757bbdf76a8e2359db2143d09529" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">Строка, содержащая допустимые символы для конкретной ОС для значений переменных среды с использованием кодировки &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что конкретно нулевые символы (целочисленное значение ноль) не допускаются. Однако обратите внимание, что не все недопустимые символы обязательно приведут к сбою операций primitiv, но вместо этого могут дать недопустимые результаты.</target>
        </trans-unit>
        <trans-unit id="9de478315c2065a78cf4db328a67478bae83694c" translate="yes" xml:space="preserve">
          <source>A string describing the error is obtained with the following call:</source>
          <target state="translated">Строка,описывающая ошибку,получается при следующем вызове:</target>
        </trans-unit>
        <trans-unit id="ee46978e6166eeae1dd2570aa404c6015d82f71d" translate="yes" xml:space="preserve">
          <source>A string identifying the created thread. It is used to identify the thread in planned future debug functionality.</source>
          <target state="translated">Строка,идентифицирующая созданный поток.Используется для идентификации потока в планируемой будущей отладочной функциональности.</target>
        </trans-unit>
        <trans-unit id="759a963eafd4f199bcd9d735f8b965dcd00ef19c" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d553d44ab1b8299b71777d9750b77ba466363e" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="translated">Строка в этом модуле представлена &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; , то есть списком кодовых точек, двоичных файлов с кодовыми точками в&lt;strong&gt; кодировке UTF-8 (двоичные файлы UTF-8&lt;/strong&gt; ) или их сочетанием.</target>
        </trans-unit>
        <trans-unit id="d11f0427336c725f5ed476d29c20afbd08fe897b" translate="yes" xml:space="preserve">
          <source>A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned.</source>
          <target state="translated">Читается строка не белых пробельных символов.Если задана ширина поля,то считывается это количество символов,а все последующие пробельные символы удаляются.Возвращается Erlang-строка (список символов).</target>
        </trans-unit>
        <trans-unit id="64783b9aab5a7910a29cafe20f9a64dc124f28e3" translate="yes" xml:space="preserve">
          <source>A string representing atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Строка, представляющая атом &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d7e23be6d1d7577f504730a2152e66a4301352e" translate="yes" xml:space="preserve">
          <source>A string that describes the error is obtained with the following call:</source>
          <target state="translated">Строка,описывающая ошибку,получается при следующем вызове:</target>
        </trans-unit>
        <trans-unit id="6b058a7796b9b771b09e5ec69321b91ea4d6b069" translate="yes" xml:space="preserve">
          <source>A string version of &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt;. When the query handle is evaluated, the fun created by the parse transform is interpreted by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. The query string is to be one single QLC terminated by a period.</source>
          <target state="translated">Строковая версия &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; . Когда &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; запроса оценивается, удовольствие, созданное преобразованием синтаксического анализа, интерпретируется erl_eval (3) . Строка запроса должна быть одним QLC, оканчивающимся точкой.</target>
        </trans-unit>
        <trans-unit id="e691523a7275fa4ec7b2002f9ce045f810aebbb7" translate="yes" xml:space="preserve">
          <source>A string with no adjacent dots.</source>
          <target state="translated">Строка без соседних точек.</target>
        </trans-unit>
        <trans-unit id="7b45ae634d5f2aacf52f18c9890284a21d2682fc" translate="yes" xml:space="preserve">
          <source>A stub module descriptor contains the module name, a list of exported functions, and a list of module attributes. Each function is described by its name (which includes its arity), and the corresponding module and function that it calls. (The arities should always match.) The attributes are simply described by key-value pairs.</source>
          <target state="translated">Дескриптор модуля заглушки содержит имя модуля,список экспортируемых функций и список атрибутов модуля.Каждая функция описывается ее именем (которое включает в себя ее атрибуты),а также соответствующим модулем и функцией,которую она вызывает.(Атрибуты должны всегда совпадать.)Атрибуты просто описываются парами ключ-значение.</target>
        </trans-unit>
        <trans-unit id="8dff76e790c867438fab881dad7f0b72bb5ec367" translate="yes" xml:space="preserve">
          <source>A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level:</source>
          <target state="translated">Подмаска,не содержащая символа |,является лишь частью вложенной альтернативы;это не вложенная альтернатива с одной альтернативой.Эффект (*THEN)распространяется за пределы такой подмаски на вложенную альтернативу.Рассмотрим следующий шаблон,где A,B и т.д.являются сложными фрагментами шаблона,не содержащими на этом уровне символов |:</target>
        </trans-unit>
        <trans-unit id="359594612c2eb9a5932465070d74beae6a372eb0" translate="yes" xml:space="preserve">
          <source>A subpattern that is referenced by name can appear in the pattern before or after the reference.</source>
          <target state="translated">Подмаска,на которую делается ссылка по имени,может появиться на детали до или после ссылки.</target>
        </trans-unit>
        <trans-unit id="d8554111ace0a51aa20ae047b50f0d90058ec0d6" translate="yes" xml:space="preserve">
          <source>A subroutine call to a subpattern (recursive or otherwise)</source>
          <target state="translated">Вызов подпрограммы к подмаскировке (рекурсивной или иной).</target>
        </trans-unit>
        <trans-unit id="1e9e2570d27c2595d94b29222dcc52f4683b8c79" translate="yes" xml:space="preserve">
          <source>A subset of all semantic checks on types are implemented. For example, strictly the &lt;code&gt;TimeTicks&lt;/code&gt; may not be sub-classed but the compiler allows this (standard MIBs must pass through the compiler) (deviates from SMIv2 only).</source>
          <target state="translated">Реализовано подмножество всех семантических проверок типов. Например, строго &lt;code&gt;TimeTicks&lt;/code&gt; не может быть подклассом, но компилятор позволяет это (стандартные MIB должны проходить через компилятор) (отклоняется только от SMIv2).</target>
        </trans-unit>
        <trans-unit id="29bc759fe88a2b272d7f7e146c9840a7ce6ba6f5" translate="yes" xml:space="preserve">
          <source>A successful match of a segment of a &lt;code&gt;utf&lt;/code&gt; type, results in an integer in the range 0..16#D7FF or 16#E000..16#10FFFF. The match fails if the returned value falls outside those ranges.</source>
          <target state="translated">Успешное совпадение сегмента типа &lt;code&gt;utf&lt;/code&gt; приводит к целому числу в диапазоне 0..16 # D7FF или 16 # E000..16 # 10FFFF. Сопоставление не удается, если возвращаемое значение выходит за пределы этих диапазонов.</target>
        </trans-unit>
        <trans-unit id="0dd5399d68fd62c8aa61dea1b9cd129c66c4e135" translate="yes" xml:space="preserve">
          <source>A suggestion, in kilowords, on how large a stack to use. A value &amp;lt; 0 means default size.</source>
          <target state="translated">Предложение в киловордах о том, какой размер стека использовать. Значение &amp;lt;0 означает размер по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d2bcf77bf32e3c737f6132f4ba89272aa61deb33" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be constructed from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by the following example code:</source>
          <target state="translated">Подходящий &lt;code&gt;erlang_pid&lt;/code&gt; может быть построен из структуры &lt;code&gt;ei_cnode&lt;/code&gt; с помощью следующего примера кода:</target>
        </trans-unit>
        <trans-unit id="c330db35fee146e2f49165430e3031752b587566" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be retrieved from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by calling &lt;code&gt;ei_self(cnode_pointer)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e635ab7a6524cfed54f5074b2c5f201fa29a542e" translate="yes" xml:space="preserve">
          <source>A summary of all the run test cases.</source>
          <target state="translated">Краткий обзор всех тестовых заданий.</target>
        </trans-unit>
        <trans-unit id="490b87fb70901b3cf146b436d3ad3d6969ae85d3" translate="yes" xml:space="preserve">
          <source>A summary of allocated block sizes (including their headers) grouped by their &lt;code&gt;Origin&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">Сводка размеров выделенных блоков (включая их заголовки), сгруппированных по их &lt;code&gt;Origin&lt;/code&gt; и &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="555b82edcc9a51ba9b0a8648b94fe2cee0f8eb4a" translate="yes" xml:space="preserve">
          <source>A super carrier is large memory area, allocated at VM start, which can be used during runtime to allocate normal carriers from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c019e1f1b48948e812995eacd1c55f50920bdf21" translate="yes" xml:space="preserve">
          <source>A super carrier needs to satisfy two slightly different kinds of allocation requests; multi block carriers (MBC) and single block carriers (SBC). They are both rather large blocks of continious memory, but MBCs and SBCs have different demands on alignment and size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4170b78b8fb9e3847e667242b4de5cec174c5" translate="yes" xml:space="preserve">
          <source>A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions.</source>
          <target state="translated">Мост супервизора принимает на себя функции запуска и остановки подсистемы,расположенной в модуле обратного вызова,экспортируя предопределенный набор функций.</target>
        </trans-unit>
        <trans-unit id="f8e585f469018050c24b2320c6df8c355fe43361" translate="yes" xml:space="preserve">
          <source>A supervisor can have one of the following &lt;strong&gt;restart strategies&lt;/strong&gt; specified with the &lt;code&gt;strategy&lt;/code&gt; key in the above map:</source>
          <target state="translated">Супервизор может иметь одну из следующих &lt;strong&gt;стратегий перезапуска,&lt;/strong&gt; указанных с помощью ключа &lt;code&gt;strategy&lt;/code&gt; на приведенной выше карте:</target>
        </trans-unit>
        <trans-unit id="2b7d18f5eb25e50d03987db777d14f147e150acb" translate="yes" xml:space="preserve">
          <source>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions.</source>
          <target state="translated">Супервизор ожидает,что в модуле обратного вызова,экспортирующем предопределенный набор функций,будет указано,какие дочерние процессы должны контролироваться.</target>
        </trans-unit>
        <trans-unit id="f82d3f2d9f94a9fc80489eaf4729fa8c31535cf1" translate="yes" xml:space="preserve">
          <source>A supervisor for the SNMP agent Processes</source>
          <target state="translated">Руководитель процессов агента SNMP.</target>
        </trans-unit>
        <trans-unit id="07d7e065bf97522ff7b29841ee97a5f3abaaa707" translate="yes" xml:space="preserve">
          <source>A supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it is to keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">Супервайзер отвечает за запуск,остановку и мониторинг процессов,происходящих с детьми.Основная идея супервайзера заключается в том,что он должен поддерживать свои дочерние процессы,перезапуская их,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="8efae13f8c7942b2ac38b9a2a73eb196c3d0a6ff" translate="yes" xml:space="preserve">
          <source>A supervisor report is issued when a supervised child terminates unexpectedly. A supervisor report contains the following items:</source>
          <target state="translated">При неожиданной гибели ребенка,находящегося под наблюдением,выдается заключение руководителя.Отчет супервайзера содержит следующие пункты:</target>
        </trans-unit>
        <trans-unit id="2d5726e30c2bfdd999c9a419984c8b7f106bff81" translate="yes" xml:space="preserve">
          <source>A supervisor with restart strategy &lt;code&gt;simple_one_for_one&lt;/code&gt; is a simplified &lt;code&gt;one_for_one&lt;/code&gt; supervisor, where all child processes are dynamically added instances of the same process.</source>
          <target state="translated">Супервизор со стратегией перезапуска &lt;code&gt;simple_one_for_one&lt;/code&gt; - это упрощенный супервизор &lt;code&gt;one_for_one&lt;/code&gt; , в котором все дочерние процессы являются динамически добавляемыми экземплярами одного и того же процесса.</target>
        </trans-unit>
        <trans-unit id="4a17c6d57373e353ac6abb1cd3af415a947ff039" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. &lt;code&gt;Suspendee&lt;/code&gt; eventually suspends unless it is resumed before it could suspend. The caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; returns immediately, regardless of whether &lt;code&gt;Suspendee&lt;/code&gt; has suspended yet or not. The point in time when &lt;code&gt;Suspendee&lt;/code&gt; suspends cannot be deduced from other events in the system. It is only guaranteed that &lt;code&gt;Suspendee&lt;/code&gt;&lt;strong&gt;eventually&lt;/strong&gt; suspends (unless it is resumed). If no &lt;code&gt;asynchronous&lt;/code&gt; options has been passed, the caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; is blocked until &lt;code&gt;Suspendee&lt;/code&gt; has suspended.</source>
          <target state="translated">Запрос на приостановку отправляется процессу, указанному &lt;code&gt;Suspendee&lt;/code&gt; . &lt;code&gt;Suspendee&lt;/code&gt; конечном итоге приостанавливается, если она не будет возобновлена ​​до того, как она сможет приостановить. Вызывающий &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; немедленно возвращается, вне зависимости от того, &lt;code&gt;Suspendee&lt;/code&gt; ли Suspende еще или нет. Момент времени, когда &lt;code&gt;Suspendee&lt;/code&gt; приостановка, нельзя вывести из других событий в системе. Гарантируется только то, что &lt;code&gt;Suspendee&lt;/code&gt; приостановки в &lt;strong&gt;конечном итоге будет&lt;/strong&gt; приостановлена ​​(если только она не будет возобновлена). Если не было передано никаких &lt;code&gt;asynchronous&lt;/code&gt; параметров, вызывающий &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; блокируется до тех пор, пока &lt;code&gt;Suspendee&lt;/code&gt; не будет приостановлена.</target>
        </trans-unit>
        <trans-unit id="25b4e7d3e689427411ff502e735d917aa357caf7" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. When the suspend request has been processed, a reply message is sent to the caller of this function. The reply is on the form &lt;code&gt;{ReplyTag, State}&lt;/code&gt; where &lt;code&gt;State&lt;/code&gt; is either:</source>
          <target state="translated">Запрос на приостановку отправляется процессу, указанному &lt;code&gt;Suspendee&lt;/code&gt; . Когда запрос приостановки обработан, вызывающей стороне этой функции отправляется ответное сообщение. Ответ находится в форме &lt;code&gt;{ReplyTag, State}&lt;/code&gt; где &lt;code&gt;State&lt;/code&gt; либо:</target>
        </trans-unit>
        <trans-unit id="aa31c4e6104829ed1e5940c6b760d5e5f8223aa4" translate="yes" xml:space="preserve">
          <source>A symbolic link in the path points above the root of the relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab5b92521d5334adcd3b34a7cd584da12e53036" translate="yes" xml:space="preserve">
          <source>A syntax tree can be transformed to the &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; representation with the &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Синтаксическое дерево может быть преобразовано в представление &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; с помощью функции &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe7a01f61caca49ad408b9e314c2eab8ae04b7a" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">Системный вектор ввода-вывода, используемый &lt;code&gt;writev&lt;/code&gt; в Unix и &lt;code&gt;WSASend&lt;/code&gt; в Win32. Он используется в &lt;code&gt;ErlIOVec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0af2eabcce5a60d4fed7164c28fadc9a20e4493d" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlNifIOVec&lt;/code&gt; and by &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Системный вектор ввода-вывода, используемый &lt;code&gt;writev&lt;/code&gt; в Unix и &lt;code&gt;WSASend&lt;/code&gt; в Win32. Он используется в &lt;code&gt;ErlNifIOVec&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616d063d630bdaee784166c5d2aa3d7079333cc2" translate="yes" xml:space="preserve">
          <source>A system configuration file, &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">Файл конфигурации системы, &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a27085bf58c10c3bac131eedf2381b0839b7998" translate="yes" xml:space="preserve">
          <source>A system configuration source file, &lt;code&gt;sys.config.src&lt;/code&gt;</source>
          <target state="translated">Исходный файл конфигурации системы, &lt;code&gt;sys.config.src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="475c3957e8fbb0321adf13488719ce7f864fd2ec" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt; Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c879d34c3ec9d9665df9efe9db8cf8d5df6abde2" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt;Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="translated">Достигнут системный предел. См. &lt;code&gt;Efficiency Guide&lt;/code&gt; по эффективности для получения информации о системных ограничениях.</target>
        </trans-unit>
        <trans-unit id="8b8fdecfc617b9fa3706b79edfcf234ce5f241ff" translate="yes" xml:space="preserve">
          <source>A tab followed by character &quot;3&quot;</source>
          <target state="translated">Вкладка,за которой следует символ &quot;3&quot;.</target>
        </trans-unit>
        <trans-unit id="7d11781c842639135820e9eada3b27c9a8d0d9ad" translate="yes" xml:space="preserve">
          <source>A table called &lt;code&gt;myTable&lt;/code&gt; has five columns. The first two are keys (not accessible), and the table has three rows. The instrumentation function for this table is called &lt;code&gt;my_table&lt;/code&gt;.</source>
          <target state="translated">Таблица &lt;code&gt;myTable&lt;/code&gt; состоит из пяти столбцов. Первые два являются ключами (недоступны), а таблица состоит из трех строк. Инструментальная функция для этой таблицы называется &lt;code&gt;my_table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75534734c58db0aa05f9239f37f6428de398c20c" translate="yes" xml:space="preserve">
          <source>A table identifier, as returned by &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Идентификатор таблицы, возвращаемый функцией &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f0fe364ceb37c8d8dc5f9217f78c519dc139c59" translate="yes" xml:space="preserve">
          <source>A table may contain columns that are used internally, but should not be visible to a manager. These internal columns must be the last columns in the table. The &lt;code&gt;set&lt;/code&gt; operation will not work with this arrangement, because there are columns that the agent does not know about. This situation is handled by adding values for the internal columns in the &lt;code&gt;set&lt;/code&gt; function.</source>
          <target state="translated">Таблица может содержать столбцы, которые используются внутри компании, но не должны быть видны руководителю. Эти внутренние столбцы должны быть последними столбцами в таблице. Операция &lt;code&gt;set&lt;/code&gt; не будет работать с таким расположением, потому что есть столбцы, о которых агент не знает. Эта ситуация обрабатывается путем добавления значений для внутренних столбцов в функцию &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ccf87ca282ead9bb584834a165823229be63f73" translate="yes" xml:space="preserve">
          <source>A table object</source>
          <target state="translated">Объект таблицы</target>
        </trans-unit>
        <trans-unit id="57b2065e432402661ed8ccb643e2901e6965c10a" translate="yes" xml:space="preserve">
          <source>A table of type &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; has either zero or one record per key, whereas a table of type &lt;code&gt;bag&lt;/code&gt; can have an arbitrary number of records per key. The key for each record is always the first attribute of the record.</source>
          <target state="translated">Таблица типа &lt;code&gt;set&lt;/code&gt; или &lt;code&gt;ordered_set&lt;/code&gt; имеет либо ноль, либо одну запись на ключ, тогда как таблица типа &lt;code&gt;bag&lt;/code&gt; может иметь произвольное количество записей на ключ. Ключ для каждой записи всегда является первым атрибутом записи.</target>
        </trans-unit>
        <trans-unit id="a88c8b440b3f81b0c6b1eb623a7b8614ba6ccb2c" translate="yes" xml:space="preserve">
          <source>A table traversal is &lt;strong&gt;safe&lt;/strong&gt; if either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be8a69bc11325d2a87005532e2b29bbd011c378" translate="yes" xml:space="preserve">
          <source>A tag that describes the (select) operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338d3dd5c9171dcfa74ab3490bd081525d78c330" translate="yes" xml:space="preserve">
          <source>A tail-recursive function that does not need to reverse the list at the end is faster than a body-recursive function, as are tail-recursive functions that do not construct any terms at all (for example, a function that sums all integers in a list).</source>
          <target state="translated">Хвостовая рекурсивная функция,которой не нужно перевернуть список в конце,быстрее,чем телесная рекурсивная функция,так же как и хвостовая рекурсивная функция,которая вообще не строит никаких членов (например,функция,которая суммирует все целые числа в списке).</target>
        </trans-unit>
        <trans-unit id="6ed306bfabb588bedad1a38ebc28c88dc1ee79a9" translate="yes" xml:space="preserve">
          <source>A target system may have several releases but the one given as &lt;code&gt;boot_rel&lt;/code&gt; will be used as default when the system is booting up.</source>
          <target state="translated">Целевая система может иметь несколько выпусков, но тот, который указан как &lt;code&gt;boot_rel&lt;/code&gt; , будет использоваться по умолчанию при загрузке системы.</target>
        </trans-unit>
        <trans-unit id="af9eae26f481905b914e12255a1f498f1501fe7a" translate="yes" xml:space="preserve">
          <source>A task that can be aborted is referred via another data structure from other parts of the system, so that a thread that needs to abort the task can reach it. In order to be sure to safely deallocate a task that is no longer used, we first clear this reference and then use the thread progress functionality in order to make sure no references can exist to the task. Unfortunately, also unmanaged threads might abort tasks. This is very infrequent, but might occur. This could be handled locally for each port, but would require extra information in each port structure which very infrequently would be used. Instead of implementing this in each port, we implemented general functionality that can be used from unmanaged threads to delay thread progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba0e9f6775914dcfade32d5d8265e1ed8ccd90d" translate="yes" xml:space="preserve">
          <source>A temporary process will be created for each callback call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a162c972e0a2da1ef36842b8e1183dc63976d3" translate="yes" xml:space="preserve">
          <source>A term in which the state machine implementation is to store any server data it needs. The difference between this and the &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state.</source>
          <target state="translated">Термин, в котором реализация конечного автомата заключается в хранении любых необходимых ему данных сервера. Разница между этим и самим &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; заключается в том, что изменение этих данных не вызывает повторной попытки отложенных событий. Следовательно, если изменение этих данных приведет к изменению набора обрабатываемых событий, то этот элемент данных должен стать частью состояния.</target>
        </trans-unit>
        <trans-unit id="3c82bdf9ca846d33c59020cff263330ebd6a6321" translate="yes" xml:space="preserve">
          <source>A term of type &lt;code&gt;&lt;a href=&quot;#type-iovec&quot;&gt;iovec()&lt;/a&gt;&lt;/code&gt;, structured according to the Erlang external term format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59430379cf9648470c25a50d2a2c81bb2b89218" translate="yes" xml:space="preserve">
          <source>A term, if the event handler is removed because of an error. Which term depends on the error.</source>
          <target state="translated">Термин,если обработчик события удален из-за ошибки.Какой срок зависит от ошибки.</target>
        </trans-unit>
        <trans-unit id="9594dc172a1a303c23e2c7f885380aa1c05fad93" translate="yes" xml:space="preserve">
          <source>A test case can handle several connections to one or more target systems, instruments, and traffic generators in parallel to perform the necessary actions for a test. The handling of many connections in parallel is one of the major strengths of &lt;code&gt;Common Test&lt;/code&gt;, thanks to the efficient support for concurrency in the Erlang runtime system, which &lt;code&gt;Common Test&lt;/code&gt; users can take great advantage of.</source>
          <target state="translated">Тестовый пример может обрабатывать несколько подключений к одной или нескольким целевым системам, инструментам и генераторам трафика параллельно для выполнения необходимых действий для теста. Параллельная обработка множества соединений является одной из основных сильных сторон &lt;code&gt;Common Test&lt;/code&gt; благодаря эффективной поддержке параллелизма в системе времени выполнения Erlang, которой пользователи &lt;code&gt;Common Test&lt;/code&gt; могут воспользоваться большим преимуществом.</target>
        </trans-unit>
        <trans-unit id="3f0276c5d34cae70dd7c0725d3127cfdb7e17a06" translate="yes" xml:space="preserve">
          <source>A test case failure is specified as a runtime error (a crash), no matter what the reason for termination is. If you use Erlang pattern matching effectively, you can take advantage of this property. The result is concise and readable test case functions that look much more like scripts than actual programs. A simple example:</source>
          <target state="translated">Сбой в тестовом случае указывается как ошибка во время выполнения (сбой),независимо от причины его завершения.Если вы эффективно используете совпадение по шаблону Erlang,вы можете воспользоваться этим свойством.В результате получаются лаконичные и читаемые функции тестового случая,которые гораздо больше похожи на скрипты,чем на реальные программы.Простой пример:</target>
        </trans-unit>
        <trans-unit id="57803d84844b81148f638909cfbdf834fb63a201" translate="yes" xml:space="preserve">
          <source>A test case group can be repeated a certain number of times (specified by an integer) or indefinitely (specified by &lt;code&gt;forever&lt;/code&gt;). The repetition can also be stopped too early if any or all cases fail or succeed, that is, if any of the properties &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, &lt;code&gt;repeat_until_any_ok&lt;/code&gt;, &lt;code&gt;repeat_until_all_fail&lt;/code&gt;, or &lt;code&gt;repeat_until_all_ok&lt;/code&gt; is used. If the basic &lt;code&gt;repeat&lt;/code&gt; property is used, status of test cases is irrelevant for the repeat operation.</source>
          <target state="translated">Группа тестовых примеров может повторяться определенное количество раз (задано целым числом) или бесконечно (задано &lt;code&gt;forever&lt;/code&gt; ). Повторение также может быть остановлено слишком рано, если один или все случаи &lt;code&gt;repeat_until_any_ok&lt;/code&gt; &lt;code&gt;repeat_until_all_fail&lt;/code&gt; или &lt;code&gt;repeat_until_all_ok&lt;/code&gt; успешно, то есть, если используется какое-либо из свойств &lt;code&gt;repeat_until_any_fail&lt;/code&gt; , repeat_until_any_ok , repeat_until_all_fail или repeat_until_all_ok . Если используется базовое свойство &lt;code&gt;repeat&lt;/code&gt; , статус тестовых примеров не имеет значения для операции повтора.</target>
        </trans-unit>
        <trans-unit id="70f3b406878b1ad27d06f47209f488fb0090bedb" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="translated">Группа тестовых примеров - это набор тестовых примеров, совместно использующих функции конфигурации и свойства выполнения. Группы тестовых примеров определяются функциональными &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; соответствии со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="6615fe68020574c9d51502afda77dbb501f32348" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e797bd2be17f58c7efe8dfeff204b02c5adaa5d5" translate="yes" xml:space="preserve">
          <source>A test case is considered successful if it returns to the caller, no matter what the returned value is. However, a few return values have special meaning as follows:</source>
          <target state="translated">Тестовый случай считается успешным,если он возвращается вызывающему абоненту,независимо от того,какое возвращаемое значение.Однако несколько возвращаемых значений имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="dcc50de966066784aa8d897c8ffe49a70bbe3620" translate="yes" xml:space="preserve">
          <source>A test is performed by running one or more test suites. A test suite consists of test cases, configuration functions, and information functions. Test cases can be grouped in so called test case groups. A test suite is an Erlang module and test cases are implemented as Erlang functions. Test suites are stored in test directories.</source>
          <target state="translated">Тест выполняется путем запуска одного или нескольких наборов тестов.Набор тестов состоит из тестовых примеров,функций конфигурации и информационных функций.Тестовые случаи можно сгруппировать в так называемые группы тестовых случаев.Набор тестов представляет собой модуль Erlang,а тестовые примеры реализуются в виде функций Erlang.Наборы тестов хранятся в тестовых каталогах.</target>
        </trans-unit>
        <trans-unit id="82b0d4348a040296baa971a336f70137d0143756" translate="yes" xml:space="preserve">
          <source>A test set can be easily created by placing a sequence of test objects in a list. If &lt;code&gt;T_1&lt;/code&gt;, ..., &lt;code&gt;T_N&lt;/code&gt; are individual test objects, then &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; is a test set consisting of those objects (in that order).</source>
          <target state="translated">Набор тестов можно легко создать, поместив последовательность тестовых объектов в список. Если &lt;code&gt;T_1&lt;/code&gt; , ..., &lt;code&gt;T_N&lt;/code&gt; - отдельные тестовые объекты, то &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; - это тестовый набор, состоящий из этих объектов (в указанном порядке).</target>
        </trans-unit>
        <trans-unit id="850a2b153e54fe3302effc5897fd48daf6d71d85" translate="yes" xml:space="preserve">
          <source>A test suite is an ordinary Erlang module that contains test cases. It is recommended that the module has a name on the form &lt;code&gt;*_SUITE.erl&lt;/code&gt;. Otherwise, the directory and auto compilation function in &lt;code&gt;Common Test&lt;/code&gt; cannot locate it (at least not by default).</source>
          <target state="translated">Набор тестов - это обычный модуль Erlang, содержащий тестовые примеры. Рекомендуется, чтобы у модуля было имя в форме &lt;code&gt;*_SUITE.erl&lt;/code&gt; . В противном случае каталог и функция автоматической компиляции в &lt;code&gt;Common Test&lt;/code&gt; не смогут его найти (по крайней мере, по умолчанию).</target>
        </trans-unit>
        <trans-unit id="c6a46a09bfa35f6d6a3e0deef8196b3ea6cd2281" translate="yes" xml:space="preserve">
          <source>A test term can also specify one or more test suites, groups, or test cases to be skipped. Skipped suites, groups, and cases are not executed and show up in the HTML log files as &lt;code&gt;SKIPPED&lt;/code&gt;.</source>
          <target state="translated">Термин теста также может указывать один или несколько наборов тестов, групп или тестовых примеров, которые следует пропустить. Пропущенные наборы, группы и дела не выполняются и отображаются в файлах журнала HTML как &lt;code&gt;SKIPPED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc9a7da069ee22047038749756cf97523761175f" translate="yes" xml:space="preserve">
          <source>A textual comment describing the service. Not mandatory, but shows up as the service description in the Windows service manager.</source>
          <target state="translated">Текстовый комментарий с описанием услуги.Не является обязательным,но отображается как описание службы в менеджере служб Windows.</target>
        </trans-unit>
        <trans-unit id="1b69647db9e6ba8a0e002c236579c1374755b41d" translate="yes" xml:space="preserve">
          <source>A the time of writing this, the latest released version of SystemTap is version 1.6. Erlang's DTrace support requires a MACRO that was introduced after that release. So either get a newer release or build SystemTap from git yourself (see: http://sourceware.org/systemtap/getinvolved.html)</source>
          <target state="translated">На момент написания этой статьи последней выпущенной версией SystemTap является версия 1.6.Для поддержки DTrace Эрланга требуется MACRO,который был введен после этого выпуска.Так что либо получите новый релиз,либо соберите SystemTap самостоятельно из git'а (см.:http://sourceware.org/systemtap/getinvolved.html).</target>
        </trans-unit>
        <trans-unit id="9b18f6bb3b01d76a4dfa566d98c87a28d7f6b44e" translate="yes" xml:space="preserve">
          <source>A third alternative is to download and install MSYS2 from:</source>
          <target state="translated">Третья альтернатива-скачать и установить MSYS2:</target>
        </trans-unit>
        <trans-unit id="1d370bfacb3e303ae0b301510d2fd8f9fe73b2f2" translate="yes" xml:space="preserve">
          <source>A third feature is to have the super carrier limit the &lt;strong&gt;maximum&lt;/strong&gt; amount of memory used by the VM. If +MMsco (Super Carrier Only) is set to true, which is default, allocations will only be done from the super carrier. When the super carrier gets full, the VM will fail due to out of memory. If +MMsco is false, allocations will use mmap directly if the super carrier is full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52be3095703dc09da3f8d9ef4629a28e6444954" translate="yes" xml:space="preserve">
          <source>A third problem was management of low memory in the halfword emulator. The implementation used a naive linear search structure to hold free segments which would lead to poor performance when fragmentation increased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c4754ee9c691b3be255533c56967a9f65767a3" translate="yes" xml:space="preserve">
          <source>A third usage is to block login attempts from a missbehaving peer. The &lt;code&gt;State&lt;/code&gt; described above can be used for this. The return value &lt;code&gt;disconnect&lt;/code&gt; is useful for this.</source>
          <target state="translated">Третий вариант использования - блокирование попыток входа в систему со стороны некорректного партнера. &lt;code&gt;State&lt;/code&gt; описано выше , можно использовать для этого. Для этого полезно возвращаемое значение &lt;code&gt;disconnect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9a2152eb9572e05f0a61d8511698051e7c78f8" translate="yes" xml:space="preserve">
          <source>A thread can only be joined once. The behavior of joining more than once is undefined, an emulator crash is likely. If &lt;code&gt;exit_value == NULL&lt;/code&gt;, the exit value of the terminated thread is ignored, otherwise the exit value of the terminated thread is stored at &lt;code&gt;*exit_value&lt;/code&gt;.</source>
          <target state="translated">К цепочке можно присоединиться только один раз. Поведение многократного присоединения не определено, возможен сбой эмулятора. Если &lt;code&gt;exit_value == NULL&lt;/code&gt; , значение выхода завершенного потока игнорируется, в противном случае значение выхода завершенного потока сохраняется в &lt;code&gt;*exit_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="713f4e1d5b50f7df039ee9fe6e1996e2572d7a3a" translate="yes" xml:space="preserve">
          <source>A thread identifier can be reused very quickly after a thread has terminated. Therefore, if a thread corresponding to one of the involved thread identifiers has terminated since the thread identifier was saved, the result of &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; does possibly not give the expected result.</source>
          <target state="translated">Идентификатор потока может быть повторно использован очень быстро после завершения потока. Следовательно, если поток, соответствующий одному из задействованных идентификаторов потока, завершился после сохранения идентификатора потока, результат &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; , возможно, не даст ожидаемого результата.</target>
        </trans-unit>
        <trans-unit id="cad763d5e07983c99c13f14998b109764ecd9488" translate="yes" xml:space="preserve">
          <source>A time stamp as returned by the BIF &lt;code&gt;now()&lt;/code&gt;.</source>
          <target state="translated">Отметка времени, возвращенная BIF &lt;code&gt;now()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09f8c7e2d1b4631a8a0fd8e3a936590e5cfc3d7c" translate="yes" xml:space="preserve">
          <source>A time warp is a leap forwards or backwards in time. That is, the difference of time values taken before and after the time warp does not correspond to the actual elapsed time.</source>
          <target state="translated">Искривление времени-это скачок вперед или назад во времени.То есть разница значений времени,взятых до и после искривления времени,не соответствует фактическому истекшему времени.</target>
        </trans-unit>
        <trans-unit id="cd86c3e0b5292795cee07d9ad33f244af7a25314" translate="yes" xml:space="preserve">
          <source>A time-out feature inherited from &lt;code&gt;gen_statem&lt;/code&gt;'s predecessor &lt;code&gt;gen_fsm&lt;/code&gt;, is an event time-out, that is, if an event arrives the timer is cancelled. You get either an event or a time-out, but not both.</source>
          <target state="translated">Тайм-аут особенность , унаследованная от &lt;code&gt;gen_statem&lt;/code&gt; &amp;laquo;s предшественника &lt;code&gt;gen_fsm&lt;/code&gt; , является тайм-аут события, то есть, если событие прибывает таймер будет отменен. Вы получаете либо событие, либо тайм-аут, но не то и другое одновременно.</target>
        </trans-unit>
        <trans-unit id="e4e7c858b3f4a06a0ae20e24345812eb57867da0" translate="yes" xml:space="preserve">
          <source>A time-out value of &lt;code&gt;0&lt;/code&gt; (zero) means that time-outs are disabled. Calling a &lt;code&gt;_tmo&lt;/code&gt; function with the last argument as &lt;code&gt;0&lt;/code&gt; is therefore the same thing as calling the function without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">Значение тайм-аута &lt;code&gt;0&lt;/code&gt; (ноль) означает, что тайм-ауты отключены. Вызов &lt;code&gt;_tmo&lt;/code&gt; функции с последним аргументом , как &lt;code&gt;0&lt;/code&gt; , поэтому то же самое , как вызов функции без &lt;code&gt;_tmo&lt;/code&gt; суффикса.</target>
        </trans-unit>
        <trans-unit id="e51396500c23760a237e8c8ce1759124abbdb2b6" translate="yes" xml:space="preserve">
          <source>A timeout, in seconds, for how long the &lt;code&gt;memsup&lt;/code&gt; process should wait for a result from a memory check. If the timeout expires, a warning message &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; is issued via &lt;code&gt;error_logger&lt;/code&gt; and any pending, synchronous client calls will return a dummy value. Normally, this situation should not occur. There have been cases on Linux, however, where the pseudo file from which system data is read is temporarily unavailable when the system is heavily loaded.</source>
          <target state="translated">&lt;code&gt;memsup&lt;/code&gt; аут в секундах, в течение которого процесс memsup должен ждать результата проверки памяти. Если время ожидания истекает, через &lt;code&gt;error_logger&lt;/code&gt; выдается предупреждающее сообщение &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; и любые ожидающие синхронные вызовы клиента возвращают фиктивное значение. Обычно такой ситуации не должно быть. Однако в Linux были случаи, когда псевдофайл, из которого считывались системные данные, был временно недоступен, когда система сильно загружена.</target>
        </trans-unit>
        <trans-unit id="68ff3c996ac6d98f27aaaac3ca2c11d67e8039ea" translate="yes" xml:space="preserve">
          <source>A timer can always be removed by calling &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Таймер всегда можно удалить, вызвав &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="726a053f638d7072079d375380c92439b2bbdb5e" translate="yes" xml:space="preserve">
          <source>A timer reference.</source>
          <target state="translated">Ссылка на таймер.</target>
        </trans-unit>
        <trans-unit id="fb8ee6e4fe82a072a334ccee3c68e3012d95b6b8" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;&lt;a href=&quot;#timestamp-0&quot;&gt; logger:timestamp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ea6da4ccb85a54c3d9ad09e70c59b90ddafcec" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt;.</source>
          <target state="translated">Метка времени, созданная с помощью &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="224b47a99ccb8f9ad2636eb28064f8326a8f1842" translate="yes" xml:space="preserve">
          <source>A timetrap can also be set or reset dynamically during the execution of a test case, or configuration function. This is done by calling &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;. This function cancels the current timetrap and starts a new one (that stays active until time-out, or end of the current function).</source>
          <target state="translated">Временную ловушку также можно устанавливать или сбрасывать динамически во время выполнения тестового примера или функции конфигурации. Это делается вызовом &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; . Эта функция отменяет текущую временную ловушку и запускает новую (которая остается активной до истечения времени ожидания или до конца текущей функции).</target>
        </trans-unit>
        <trans-unit id="8f213ae236a5f4c3df724a5656b6f24789d1f1a8" translate="yes" xml:space="preserve">
          <source>A tool for applying XSLT stylesheets to XML documents. Download xsltproc from &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Инструмент для применения таблиц стилей XSLT к XML-документам. Загрузите xsltproc с &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08f1e7c2bddf5c69b2f61fa1070545348579586c" translate="yes" xml:space="preserve">
          <source>A trace port is an Erlang port to a dynamically linked in driver that handles trace messages directly, without the overhead of sending them as messages in the Erlang virtual machine.</source>
          <target state="translated">Порт трассировки-это порт Erlang на динамически связанный в драйвере,который обрабатывает сообщения трассировки напрямую,без накладных расходов на их отправку в качестве сообщений на виртуальной машине Erlang.</target>
        </trans-unit>
        <trans-unit id="12ee06a6ceec6852b8fcedb1fbb55e6e9c5f6756" translate="yes" xml:space="preserve">
          <source>A trace server started in this way will simply display the trace messages in a formatted way in the Erlang shell (i. e. use io:format). See &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; for a description of how the trace message handler can be customized.</source>
          <target state="translated">Сервер трассировки, запущенный таким образом, будет просто отображать сообщения трассировки в отформатированном виде в оболочке Erlang (то есть использовать io: format). См. &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; для описания того, как можно настроить обработчик сообщений трассировки.</target>
        </trans-unit>
        <trans-unit id="c312d23149bf55415c7facde91760776534bda23" translate="yes" xml:space="preserve">
          <source>A trace token contains a label and a set of flags. Both the label and the flags are set in both alternatives above.</source>
          <target state="translated">Токен трассировки содержит метку и набор флагов.И метка,и флаги установлены в обоих вариантах выше.</target>
        </trans-unit>
        <trans-unit id="a0a3ada2bd3e540543826094f00fde5f11b86200" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will consist of &lt;code&gt;Erlang monotonic time&lt;/code&gt; and a monotonically increasing integer. The time-stamp has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает создание строгой монотонной временной метки для каждого отслеживаемого события. По умолчанию - &lt;code&gt;false&lt;/code&gt; . Отметки времени будут состоять из &lt;code&gt;Erlang monotonic time&lt;/code&gt; и монотонно увеличивающегося целого числа. &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; времени имеет тот же формат и значение, что и {erlang: monotonic_time (наносекунда), erlang: unique_integer ([monotonic])} .</target>
        </trans-unit>
        <trans-unit id="60097663814cb4e095c2a6a722349f6b5a5bf437" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will use &lt;code&gt;Erlang monotonic time&lt;/code&gt;. The time-stamp has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает создание строгой монотонной временной метки для каждого отслеживаемого события. По умолчанию - &lt;code&gt;false&lt;/code&gt; . Метки времени будут использовать &lt;code&gt;Erlang monotonic time&lt;/code&gt; . Метка времени имеет тот же формат и значение, что и &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82d8ecb25fb90aa7ddd424dd220b83a7b34ebd81" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает создание отметки времени для каждого отслеживаемого события. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3e634022f908badf152e1987898bd0b2c230015" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on explicit calls to &lt;code&gt;seq_trace:print/1&lt;/code&gt;. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает трассировку явных вызовов &lt;code&gt;seq_trace:print/1&lt;/code&gt; . По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f928f7c9e2d7e89a32e5aa2b16d563a9022c4418" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on information reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f03f78eba803fb7a7f1c41468a0fa1580e2a31" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on information sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde9aedc5e9c949b0aa2b17f37ee8c40d03b21b6" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг маркера трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает трассировку при получении сообщения. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c367670f41b59db0e6ecd2630bb172d3da0c69" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает трассировку при отправке сообщения. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb16a1ee7cb5dc148d050fd7c6dc758d85f029eb" translate="yes" xml:space="preserve">
          <source>A traditional 3-tuple of integers seed is passed through algorithm-dependent hashing functions to create the generator's initial state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef110e2f0ab9e0376d172bcb7bfe8b65a404cd6" translate="yes" xml:space="preserve">
          <source>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</source>
          <target state="translated">Транзакционная система позволяет одновременно выполнять два или более процесса,которые манипулируют одной и той же записью.Программисту нет необходимости проверять синхронизацию обновлений,это контролируется обработчиком транзакции.Все программы,обращающиеся к БД через транзакционную систему,могут быть записаны так,как если бы у них был единоличный доступ к данным.</target>
        </trans-unit>
        <trans-unit id="040494e8706d570977340364653c32d0f74758d8" translate="yes" xml:space="preserve">
          <source>A transport can both override its service's capabilities and restrict its supported Diameter applications so &quot;service = Diameter node as identified by Origin-Host&quot; is not necessarily the case.</source>
          <target state="translated">Транспорт может как переопределить возможности своей службы,так и ограничить поддерживаемые приложения Diameter,поэтому &quot;service=Diameter node as identified by Origin-Host&quot; (служба=узел Diameter)не обязательно является таковым.</target>
        </trans-unit>
        <trans-unit id="023338b0c93aa9ea43a308354e8c6cb312d2e262" translate="yes" xml:space="preserve">
          <source>A transport process can expect messages of the following types from its parent.</source>
          <target state="translated">Транспортный процесс может ожидать от своих родителей сообщений следующих типов.</target>
        </trans-unit>
        <trans-unit id="c02ea719b68545a61ef8005dfcb9fa67f5f85090" translate="yes" xml:space="preserve">
          <source>A transport process must implement the message interface documented below. It should retain the pid of its parent, monitor the parent and terminate if it dies. It should not link to the parent. It should exit if its transport connection with its peer is lost.</source>
          <target state="translated">Транспортный процесс должен реализовывать интерфейс сообщения,описанный ниже.Он должен сохранить pid своего родителя,контролировать родителя и прекращать работу в случае его смерти.Он не должен связываться с родителем.Он должен завершить работу,если транспортное соединение с родителем потеряно.</target>
        </trans-unit>
        <trans-unit id="22cab074839dd6633c044492cf9e00d79ad7b9b9" translate="yes" xml:space="preserve">
          <source>A transport process should send messages of the following types to its parent.</source>
          <target state="translated">Транспортный процесс должен отправлять родителю сообщения следующих типов.</target>
        </trans-unit>
        <trans-unit id="90161712010dfd82bbaf6035b7ca236a047b2d07" translate="yes" xml:space="preserve">
          <source>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (&lt;strong&gt;enable&lt;/strong&gt;), or to become inactive (&lt;strong&gt;disable&lt;/strong&gt;), or to be removed (&lt;strong&gt;delete&lt;/strong&gt;).</source>
          <target state="translated">Действие триггера. При достижении точки останова действие триггера указывает, должна ли точка останова оставаться активной ( &lt;strong&gt;включить&lt;/strong&gt; ), стать неактивной ( &lt;strong&gt;отключить&lt;/strong&gt; ) или быть удаленной ( &lt;strong&gt;удалить&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="f841f79d498699c727c107e3b0ca4c79fda4714f" translate="yes" xml:space="preserve">
          <source>A true embedded system must start when the system boots. This section accounts for the necessary configurations needed to achieve that.</source>
          <target state="translated">Настоящая встроенная система должна запускаться при загрузке системы.В данном разделе рассматриваются необходимые для этого конфигурации.</target>
        </trans-unit>
        <trans-unit id="1e80ac87b4ba604d5c15b3ca4c06f00704683ae7" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt;. The &lt;code&gt;HashAlgoSpec&lt;/code&gt; specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the &lt;code&gt;accept_callback()&lt;/code&gt;. The &lt;code&gt;HashALgoSpec&lt;/code&gt; is either an atom or a list of atoms as the first argument in &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt;. If it is a list of hash algorithm names, the &lt;code&gt;FingerPrint&lt;/code&gt; argument in the &lt;code&gt;accept_callback()&lt;/code&gt; will be a list of fingerprints in the same order as the corresponding name in the &lt;code&gt;HashAlgoSpec&lt;/code&gt; list.</source>
          <target state="translated">Кортеж &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt; . В &lt;code&gt;HashAlgoSpec&lt;/code&gt; определяет , какой алгоритм хеширования должен использоваться для вычисления отпечатка пальца используется в вызове &lt;code&gt;accept_callback()&lt;/code&gt; . &lt;code&gt;HashALgoSpec&lt;/code&gt; либо атом или список атомов в качестве первого аргумента в &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt; . Если это список имен хеш-алгоритмов, аргумент &lt;code&gt;FingerPrint&lt;/code&gt; в &lt;code&gt;accept_callback()&lt;/code&gt; будет списком отпечатков пальцев в том же порядке, что и соответствующее имя в списке &lt;code&gt;HashAlgoSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7e5e9de3bf6f4c7060bdc6cec37d2c3b2e6d0c" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Major,Minor}&lt;/code&gt; containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return &lt;code&gt;{0,0}&lt;/code&gt; in this field.</source>
          <target state="translated">Кортеж &lt;code&gt;{Major,Minor}&lt;/code&gt; , содержащий основную и вспомогательную версии формата файла для дампа таблиц ETS. Это поле версии было добавлено, начиная с STDLIB 1.5.1. Файлы, сброшенные более старыми версиями, возвращают в этом поле &lt;code&gt;{0,0}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07bab1189c6299dfc8d87b9698a9d20069024cab" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; for function calls</source>
          <target state="translated">Кортеж &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; для вызовов функций</target>
        </trans-unit>
        <trans-unit id="85c425ef8b5c09edd293415683557a467b94cc4b" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{registered_name,node_name}&lt;/code&gt; is used instead of just the &lt;code&gt;registered_name&lt;/code&gt;.</source>
          <target state="translated">Кортеж &lt;code&gt;{registered_name,node_name}&lt;/code&gt; используется вместо только &lt;code&gt;registered_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3f0f1a112bc371fc9fac3b642164488b8dd6fb" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt;, where &lt;code&gt;ModuleName&lt;/code&gt; and &lt;code&gt;FunctionName&lt;/code&gt; are atoms, referring to the function &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</source>
          <target state="translated">Кортеж &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt; , где &lt;code&gt;ModuleName&lt;/code&gt; и &lt;code&gt;FunctionName&lt;/code&gt; - это атомы, относящиеся к функции &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7faaaea4addaa524ef387ae744a4927d4b84f230" translate="yes" xml:space="preserve">
          <source>A tuple is a compound data type with a fixed number of terms:</source>
          <target state="translated">Кортеж кортежа-это составной тип данных с фиксированным количеством сроков:</target>
        </trans-unit>
        <trans-unit id="df982bb074bb2bcc07a3f3574312720f45bcca1f" translate="yes" xml:space="preserve">
          <source>A tuple must be specified with the number of elements. (The elements precede the &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; term.)</source>
          <target state="translated">Кортеж должен быть указан с количеством элементов. (Элементы предшествуют термину &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="694f68c6889d3f88be664ff0fedc1704129e38dd" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d813ebdb5f103f06a944c56ba2c1950a8ea79499" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="translated">Возвращается кортеж размером, равным &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; . Элементы кортежа являются целыми числами или &lt;code&gt;unbound&lt;/code&gt; атомом . Идентификаторы логических процессоров представлены целыми числами. &lt;code&gt;N&lt;/code&gt; - й элемент кортежа равен току связывания для планировщика с планировщиком идентификатором , равным &lt;code&gt;N&lt;/code&gt; . Например, если планировщики связаны, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; возвращает идентификатор логического процессора, на котором выполняется вызывающий процесс.</target>
        </trans-unit>
        <trans-unit id="810d5b526b8906970f984c1b3db62a6c47f80147" translate="yes" xml:space="preserve">
          <source>A tuple of size three containing: the segment number, the &lt;code&gt;last segment indicator&lt;/code&gt; and finally a list of 'ActionReply' records possibly containing error indications. This is of course only possible if the reply was segmented.</source>
          <target state="translated">Кортеж размером три, содержащий: номер &lt;code&gt;last segment indicator&lt;/code&gt; и, наконец, список записей ActionReply, которые могут содержать индикаторы ошибок. Конечно, это возможно только в том случае, если ответ был сегментирован.</target>
        </trans-unit>
        <trans-unit id="3dd7bc1a3405fbef606b572d8949507a33cc4df9" translate="yes" xml:space="preserve">
          <source>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращается кортеж привязок и продолжение, если таблица не пуста, и в этом случае &lt;code&gt;'$end_of_table'&lt;/code&gt; . Продолжение следует использовать при сопоставлении других объектов путем вызова &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c722068339f5605671934079ecb1e3f17e82123" translate="yes" xml:space="preserve">
          <source>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching more objects by calling &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращается кортеж результатов применения спецификации соответствия и продолжения, если таблица не пуста, и в этом случае &lt;code&gt;'$end_of_table'&lt;/code&gt; . Продолжение следует использовать при сопоставлении большего количества объектов путем вызова &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24035af62a2fdeb2d8901fd0ee530961ccde951f" translate="yes" xml:space="preserve">
          <source>A tuple passed using the external format of Erlang.</source>
          <target state="translated">Кортеж передается с использованием внешнего формата Erlang.</target>
        </trans-unit>
        <trans-unit id="8690cf67b400404bcc0f4ff1dceb7bb83944c22f" translate="yes" xml:space="preserve">
          <source>A tuple where the elements are of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Кортеж , в котором элементы имеют тип &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4c3a805c0c5a81f38e677fa3cd9def6b983c21d" translate="yes" xml:space="preserve">
          <source>A tuple with the string and the options for compilation</source>
          <target state="translated">Кортеж со строкой и опциями компиляции</target>
        </trans-unit>
        <trans-unit id="151bd15a2cb84f42df927246cfbe8c0dd7313819" translate="yes" xml:space="preserve">
          <source>A type specifier list TSL for a bitstring element is a sequence of type specifiers &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt;, and Rep(TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt;.</source>
          <target state="translated">Список спецификаторов типа TSL для элемента строки битов представляет собой последовательность спецификаторов типа &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt; и Rep (TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08976fc5cbfe03343391c63ca50f5f50c10b8d0b" translate="yes" xml:space="preserve">
          <source>A typical (compress) usage is as follows:</source>
          <target state="translated">Типичное (компрессионное)использование выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="126a0170061e6a79a71ccf9406ef6f3af55349d4" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;.erlang&lt;/code&gt; file contains a set of search paths, for example:</source>
          <target state="translated">Типичный файл &lt;code&gt;.erlang&lt;/code&gt; содержит набор путей поиска, например:</target>
        </trans-unit>
        <trans-unit id="72082aa56cd4d1e59057d7f28996bf925833376c" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;Common Test&lt;/code&gt; test suite using &lt;code&gt;ct_property_test&lt;/code&gt; is organized as follows:</source>
          <target state="translated">Типичный набор тестов &lt;code&gt;Common Test&lt;/code&gt; с использованием &lt;code&gt;ct_property_test&lt;/code&gt; организован следующим образом:</target>
        </trans-unit>
        <trans-unit id="6ef96d247bf0039ba1ccb9fddcabd0176ac0a0c3" translate="yes" xml:space="preserve">
          <source>A typical error reason is:</source>
          <target state="translated">Типичная причина ошибки:</target>
        </trans-unit>
        <trans-unit id="05d8d9f5d6888b35439d18b6e544520b23957a25" translate="yes" xml:space="preserve">
          <source>A typical error reason:</source>
          <target state="translated">Типичная причина ошибки:</target>
        </trans-unit>
        <trans-unit id="9061494e205704eb0cdfcf7a4c046c23d96666b9" translate="yes" xml:space="preserve">
          <source>A typical implementation on Unix is to do &lt;code&gt;close((int)event)&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация в Unix - это &lt;code&gt;close((int)event)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541396ef46ffec4bf5fa435c55b2863004f29300" translate="yes" xml:space="preserve">
          <source>A typical operation could include the following steps:</source>
          <target state="translated">Типичная операция может включать следующие шаги:</target>
        </trans-unit>
        <trans-unit id="50f89c2180f830349252137c0faf845e512001e7" translate="yes" xml:space="preserve">
          <source>A typical overload situation occurs when the applications perform more updates on disc resident tables than &lt;code&gt;Mnesia&lt;/code&gt; can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</source>
          <target state="translated">Типичная ситуация перегрузки возникает, когда приложения выполняют больше обновлений резидентных таблиц диска, чем &lt;code&gt;Mnesia&lt;/code&gt; может обработать. Игнорирование такого рода перегрузки может привести к ситуации, когда дисковое пространство исчерпано (независимо от размера таблиц, хранящихся на диске).</target>
        </trans-unit>
        <trans-unit id="acb703e9dec014081d4b1835cb51aaeb3d0b76b2" translate="yes" xml:space="preserve">
          <source>A typical use of this function is to replace unbounded-size control sequences like &lt;code&gt;~w&lt;/code&gt; and &lt;code&gt;~p&lt;/code&gt; with the depth-limited variants &lt;code&gt;~W&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; before formatting to text in, for example, a logger.</source>
          <target state="translated">Типичное использование этой функции - замена управляющих последовательностей неограниченного размера, таких как &lt;code&gt;~w&lt;/code&gt; и &lt;code&gt;~p&lt;/code&gt; вариантами &lt;code&gt;~W&lt;/code&gt; и &lt;code&gt;~P&lt;/code&gt; с ограниченной глубиной перед форматированием в текст, например, в регистраторе.</target>
        </trans-unit>
        <trans-unit id="3807873b97b8b82278afb2ef76e8ea8f9bb29594" translate="yes" xml:space="preserve">
          <source>A unique identifier for a filter.</source>
          <target state="translated">Уникальный идентификатор для фильтра.</target>
        </trans-unit>
        <trans-unit id="aeb6160c71f6b3c49b7dc45e065a90d43611f9a7" translate="yes" xml:space="preserve">
          <source>A unique identifier for a handler instance.</source>
          <target state="translated">Уникальный идентификатор экземпляра обработчика.</target>
        </trans-unit>
        <trans-unit id="35c6d039fac0be1661199d1ae0d64a6d99224787" translate="yes" xml:space="preserve">
          <source>A useful dispatch function that can be used from client functions. It returns a process on the local node, if such a process exists. Otherwise, it selects one randomly.</source>
          <target state="translated">Полезная функция диспетчеризации,которую можно использовать из клиентских функций.Она возвращает процесс на локальном узле,если такой процесс существует.В противном случае она выбирает один случайным образом.</target>
        </trans-unit>
        <trans-unit id="f5bfc38acae2f40bfaee12c264aaf4416d8847f9" translate="yes" xml:space="preserve">
          <source>A useful number.</source>
          <target state="translated">Полезный номер.</target>
        </trans-unit>
        <trans-unit id="5f280d2fcfe90c0ab1a22509cb3602587fb270ec" translate="yes" xml:space="preserve">
          <source>A useful way of looking at parts of lists, is by using &quot;|&quot;. This is best explained by an example using the shell:</source>
          <target state="translated">Полезным способом просмотра частей списков является использование &quot;|&quot;.Это лучше всего объяснить на примере использования оболочки:</target>
        </trans-unit>
        <trans-unit id="14fd4e6872c372a6c8cb217dbc2352699bd53754" translate="yes" xml:space="preserve">
          <source>A user defined identity representing this notification send operation.</source>
          <target state="translated">Идентификатор пользователя,представляющий данную операцию отправки уведомления.</target>
        </trans-unit>
        <trans-unit id="2a353ec2b424bd07df4385f13b10e3ea7d64ca54" translate="yes" xml:space="preserve">
          <source>A user is being blocked from access.</source>
          <target state="translated">Доступ пользователя блокируется.</target>
        </trans-unit>
        <trans-unit id="0c5079fbb762cb2270895845abfb45816e3f4e3e" translate="yes" xml:space="preserve">
          <source>A user is being removed from the block list.</source>
          <target state="translated">Пользователь удаляется из списка блоков.</target>
        </trans-unit>
        <trans-unit id="101ba63129c1dab0968eb1083541b31cda478b02" translate="yes" xml:space="preserve">
          <source>A user is identified by its UserMid, which must be a legal Megaco MID.</source>
          <target state="translated">Пользователя идентифицирует его UserMid,который должен быть законным Megaco MID.</target>
        </trans-unit>
        <trans-unit id="fd3a9f3997e885cf7dcc7677ac20d4c9631d90cc" translate="yes" xml:space="preserve">
          <source>A user may either be statically configured in a .config file according to the application concept of Erlang/OTP or dynamically started with the configuration settings as arguments to megaco:start_user/2. These configuration settings may be updated later on with megaco:update_conn_info/2.</source>
          <target state="translated">Пользователь может быть либо статически сконфигурирован в .config-файле в соответствии с концепцией приложения Erlang/OTP,либо динамически запущен с конфигурационными настройками в качестве аргументов в megaco:start_user/2.Эти конфигурационные настройки могут быть обновлены позже с помощью megaco:update_conn_info/2.</target>
        </trans-unit>
        <trans-unit id="1504430f3d4afc3f6c812eb47a15e10f01419f56" translate="yes" xml:space="preserve">
          <source>A user may have a number of &quot;virtual&quot; connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to any number of MG's. For each connection the user selects a transport service, an encoding scheme and a user callback module.</source>
          <target state="translated">Пользователь может иметь несколько &quot;виртуальных&quot; соединений с другими пользователями.MG подключается максимум к одному MGC,в то время как MGC может быть подключен к любому количеству MG.Для каждого соединения пользователь выбирает транспортную службу,схему кодирования и пользовательский модуль обратного вызова.</target>
        </trans-unit>
        <trans-unit id="e67f458b7905dc65a23e9c34758bfcdd553eff54" translate="yes" xml:space="preserve">
          <source>A user process can subscribe on the events generated by &lt;code&gt;Mnesia&lt;/code&gt;. The following two functions are provided:</source>
          <target state="translated">Пользовательский процесс может подписаться на события, генерируемые &lt;code&gt;Mnesia&lt;/code&gt; . Предусмотрены две следующие функции:</target>
        </trans-unit>
        <trans-unit id="a930c1684ddd9a6efd75c38df17f190cbc0c2e7d" translate="yes" xml:space="preserve">
          <source>A user variable is employed for holding the &lt;code&gt;digraph&lt;/code&gt; representation of the function graph for use in many queries. The reason is efficiency. As opposed to the &lt;code&gt;=&lt;/code&gt; operator, the &lt;code&gt;:=&lt;/code&gt; operator saves a value for subsequent analyses. Here might be the place to note that equal subexpressions within a query are evaluated only once; &lt;code&gt;=&lt;/code&gt; cannot be used for speeding things up.</source>
          <target state="translated">Пользовательская переменная используется для хранения &lt;code&gt;digraph&lt;/code&gt; представления графа функции для использования во многих запросах. Причина в эффективности. В отличие от оператора &lt;code&gt;=&lt;/code&gt; , оператор &lt;code&gt;:=&lt;/code&gt; сохраняет значение для последующего анализа. Здесь можно отметить, что одинаковые подвыражения в запросе оцениваются только один раз; &lt;code&gt;=&lt;/code&gt; нельзя использовать для ускорения.</target>
        </trans-unit>
        <trans-unit id="5dca3db2b5e814aa2f8b6c5ddad967e0eb6d4fd1" translate="yes" xml:space="preserve">
          <source>A user-defined instrumentation function for each object attaches the managed objects to real resources. This function is called by the agent on a &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; operation. The function could read some hardware register, perform a calculation, or whatever is necessary to implement the semantics associated with the conceptual variable. These functions must be written both for scalar variables and for tables. They are specified in the association file, which is a text file. In this file, the &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;, or symbolic name for each managed object, is associated with an Erlang tuple &lt;code&gt;{Module,&lt;/code&gt;&lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;ListOfExtraArguments}&lt;/code&gt;.</source>
          <target state="translated">Определяемая пользователем функция инструментария для каждого объекта связывает управляемые объекты с реальными ресурсами. Эта функция вызывается агентом при операции &lt;code&gt;get&lt;/code&gt; или &lt;code&gt;set&lt;/code&gt; . Функция может читать некоторый аппаратный регистр, выполнять вычисления или что-то еще, что необходимо для реализации семантики, связанной с концептуальной переменной. Эти функции должны быть написаны как для скалярных переменных, так и для таблиц. Они указаны в файле ассоциации, который представляет собой текстовый файл. В этом файле &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; , или символическое имя для каждого управляемого объекта, связан с кортежем Erlang &lt;code&gt;{Module,&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; , &lt;code&gt;ListOfExtraArguments}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4272ec5ada9781d28edc9d23bde5292b08de6e" translate="yes" xml:space="preserve">
          <source>A user-defined parameter passed from the function &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;. It is used in the return value of &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определяемый пользователем параметр, переданный из функции &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; . Он используется в возвращаемом значении &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab19e68c658754f6d616e8a9359af12c979f8b2d" translate="yes" xml:space="preserve">
          <source>A user-perceived character, consisting of one or more codepoints.</source>
          <target state="translated">Пользовательский символ,состоящий из одной или нескольких кодовых точек.</target>
        </trans-unit>
        <trans-unit id="b6da77940e722515281bb6aabce021b2bbcff9af" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt; cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt; ssl:tls_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c487c4839c1da9e5bc76ca352a5448a09547f8c" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt;ssl:ssl_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">Допустимая цепочка должна иметь как минимум ROOT и одноранговый сертификат. Корневой сертификат может быть предоставлен либо как сертификат, предварительно созданный с помощью &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; , либо как параметры генерации корневого сертификата. Корневой сертификат, созданный &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; . Для доступных опций см. &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; ниже. Это подмножество типа &lt;code&gt;ssl:ssl_option()&lt;/code&gt; . &lt;code&gt;PrivateKey&lt;/code&gt; - это то, что возвращает &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b7f3becec263c2ea738b6691bf529e9d0210ac" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has SMP support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;!= 0&lt;/code&gt; если исполняющая система поддерживает SMP; в противном случае &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac91e865bee333c1075b80d53873b9d3418a7c3" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has support for dirty scheduler threads; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;!= 0&lt;/code&gt; если исполняющая система поддерживает грязные потоки планировщика; в противном случае &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ec437d87d8ab2a59f963ce8195782385431267f" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has thread support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;!= 0&lt;/code&gt; если в исполняющей системе есть поддержка потоков; в противном случае &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ba959b8daba0b753bc8f2d86eb3f9db8c6578e" translate="yes" xml:space="preserve">
          <source>A value in the &lt;code&gt;msg&lt;/code&gt; field does &lt;strong&gt;not&lt;/strong&gt; imply an absence of decode errors. The &lt;code&gt;errors&lt;/code&gt; field should also be examined.</source>
          <target state="translated">Значение в поле &lt;code&gt;msg&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; означает отсутствие ошибок декодирования. &lt;code&gt;errors&lt;/code&gt; поле также должно быть рассмотрено.</target>
        </trans-unit>
        <trans-unit id="24b9fc9ee791392b2ee5f6e020d0a3fa901804d7" translate="yes" xml:space="preserve">
          <source>A value must be provided for all variables, which lack default values in the MIB.</source>
          <target state="translated">Значение должно быть предоставлено для всех переменных,в которых отсутствуют значения по умолчанию в MIB.</target>
        </trans-unit>
        <trans-unit id="c6977869e984d6fd810d1cba7c1d446b28da9624" translate="yes" xml:space="preserve">
          <source>A value must have length at least 1.</source>
          <target state="translated">Значение должно иметь длину не менее 1.</target>
        </trans-unit>
        <trans-unit id="5445236ba06b6cb9e9bcd38ff5b377fb1c4caffb" translate="yes" xml:space="preserve">
          <source>A value of this type is encoded as an &lt;code&gt;open type&lt;/code&gt;.</source>
          <target state="translated">Значение этого типа кодируется как &lt;code&gt;open type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c03ee0717973a910f7c750d1a0679fb27eb9cdb9" translate="yes" xml:space="preserve">
          <source>A variable cannot be assigned a new value unless first removed. Variables assigned to by the &lt;code&gt;=&lt;/code&gt; operator are removed at the end of the query, while variables assigned to by the &lt;code&gt;:=&lt;/code&gt; operator can only be removed by calls to &lt;code&gt;forget&lt;/code&gt;. There are no user variables when module data need to be set up again; if any of the functions that make it necessary to set up module data again is called, all user variables are forgotten.</source>
          <target state="translated">Переменной нельзя присвоить новое значение, если она не была сначала удалена. Переменные, присвоенные оператором &lt;code&gt;=&lt;/code&gt; , удаляются в конце запроса, тогда как переменные, назначенные оператором &lt;code&gt;:=&lt;/code&gt; , могут быть удалены только вызовами, чтобы &lt;code&gt;forget&lt;/code&gt; . Отсутствуют пользовательские переменные, когда необходимо заново настроить данные модуля; если вызывается какая-либо из функций, которые заставляют снова настраивать данные модуля, все пользовательские переменные забываются.</target>
        </trans-unit>
        <trans-unit id="cebe1918886957c15927cc44d43277357c762515" translate="yes" xml:space="preserve">
          <source>A variable definition binds a variable to a Perl variable. It is only meaningful to add a new definition if &lt;strong&gt;beam_makeops&lt;/strong&gt; is updated at the same time to use the variable. A variable definition looks this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5646fa290bab26490d3e95c3eda24f90bfb3cb85" translate="yes" xml:space="preserve">
          <source>A variable is an expression. If a variable is bound to a value, the return value is this value. Unbound variables are only allowed in patterns.</source>
          <target state="translated">Переменная-это выражение.Если переменная привязана к значению,то возвращаемым значением является это значение.Несвязанные переменные допускаются только в шаблонах.</target>
        </trans-unit>
        <trans-unit id="ad98bc5cb949befd1ed83fe57c5fe19294f99fe2" translate="yes" xml:space="preserve">
          <source>A variable name that is not in the environment results in an error.</source>
          <target state="translated">Имя переменной,не находящейся в окружении,приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="d4d78baa7493d760df88a559b3a2f6209c0e9bbb" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="translated">Один из вариантов - использовать &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt; . Затем состояние моделируется, например, с помощью кортежа &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde8699f3ff9312f778d465383636d7d89e8acf7" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;complex state&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20State%20Callback&quot;&gt;&lt;strong&gt;one state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89b8938a6cae035d7fea046259542e22b9f6ee1" translate="yes" xml:space="preserve">
          <source>A web server can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application, or dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options, also called properties, are as follows:</source>
          <target state="translated">Веб - сервер может быть настроен на запуск при запуске &lt;code&gt;Inets&lt;/code&gt; приложения или динамически во время выполнения вызова &lt;code&gt;Inets&lt;/code&gt; приложения API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; или &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt; , см &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; . Параметры конфигурации, также называемые свойствами, следующие:</target>
        </trans-unit>
        <trans-unit id="b7054606b43999cf69240d9ae96069173e833e99" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match \w or \W (that is, one matches \w and the other matches \W), or the start or end of the string if the first or last character matches \w, respectively. In UTF mode, the meanings of \w and \W can be changed by setting option &lt;code&gt;ucp&lt;/code&gt;. When this is done, it also affects \b and \B. PCRE and Perl do not have a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However, whatever follows \b normally determines which it is. For example, the fragment \ba matches &quot;a&quot; at the start of a word.</source>
          <target state="translated">Граница слова - это позиция в строке темы, в которой текущий и предыдущий символы не совпадают ни с \ w, ни с \ W (то есть один соответствует \ w, а другой соответствует \ W), а также началу или концу строка, если первый или последний символ соответствует \ w соответственно. В режиме UTF значения \ w и \ W можно изменить, установив опцию &lt;code&gt;ucp&lt;/code&gt; . Когда это будет сделано, это также повлияет на \ b и \ B. PCRE и Perl не имеют отдельной метапоследовательности &amp;laquo;начало слова&amp;raquo; или &amp;laquo;конец слова&amp;raquo;. Однако то, что следует за \ b, обычно определяет, что это за символ. Например, фрагмент \ ba соответствует &quot;a&quot; в начале слова.</target>
        </trans-unit>
        <trans-unit id="62d9a28c75bb240da271eb7051702080009f9364" translate="yes" xml:space="preserve">
          <source>A wrap disk log file consists of many files, called index files. A log file can be opened and closed. Also, a single index file can be opened separately. If a non-existent or non-internally formatted file is opened, an error message is returned. If the file is corrupt, no attempt is made to repair it, but an error message is returned.</source>
          <target state="translated">Оберточный дисковый лог-файл состоит из множества файлов,называемых индексными файлами.Лог-файл может быть открыт и закрыт.Кроме того,один индексный файл может быть открыт отдельно.При открытии несуществующего или не форматированного файла возвращается сообщение об ошибке.Если файл поврежден,попытка восстановить его не предпринимается,но возвращается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="0eb179692808865df9fddfd61d123acd14ceb6dd" translate="yes" xml:space="preserve">
          <source>A wrap files specification is used to limit the disk space consumed by the trace. The trace is written to a limited number of files each with a limited size. The actual filenames are &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt;, where &lt;code&gt;SeqCnt&lt;/code&gt; counts as a decimal string from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;WrapCnt&lt;/code&gt; and then around again from &lt;code&gt;0&lt;/code&gt;. When a trace term written to the current file makes it longer than &lt;code&gt;WrapSize&lt;/code&gt;, that file is closed, if the number of files in this wrap trace is as many as &lt;code&gt;WrapCnt&lt;/code&gt; the oldest file is deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped, there are at most &lt;code&gt;WrapCnt&lt;/code&gt; trace files saved with a size of at least &lt;code&gt;WrapSize&lt;/code&gt; (but not much bigger), except for the last file that might even be empty. The default values are &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; and &lt;code&gt;WrapCnt = 8&lt;/code&gt;.</source>
          <target state="translated">Спецификация файлов переноса используется для ограничения дискового пространства, занимаемого трассировкой. Трассировка записывается в ограниченное количество файлов, каждый с ограниченным размером. Фактические имена файлов - это &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt; , где &lt;code&gt;SeqCnt&lt;/code&gt; считается десятичной строкой от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;WrapCnt&lt;/code&gt; , а затем снова с &lt;code&gt;0&lt;/code&gt; . Когда термин трассировки, записанный в текущий файл, делает его длиннее, чем &lt;code&gt;WrapSize&lt;/code&gt; , этот файл закрывается, если количество файлов в этой трассировке &lt;code&gt;WrapCnt&lt;/code&gt; самый старый файл удаляется, тогда открывается новый файл, который становится текущим. Таким образом, когда трассировка &lt;code&gt;WrapCnt&lt;/code&gt; была остановлена, имеется не более WrapCntфайлы трассировки, сохраненные с размером не менее &lt;code&gt;WrapSize&lt;/code&gt; (но не намного больше), за исключением последнего файла, который может быть даже пуст. Значения по умолчанию: &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; и &lt;code&gt;WrapCnt = 8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a037e42e51e318b55fc1948fa5a1661147cd7c" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The attributes and &lt;code&gt;TabDef&lt;/code&gt; are forwarded to &lt;code&gt;mnesia:create_table/2&lt;/code&gt;. For example, if the table is to reside as &lt;code&gt;disc_only_copies&lt;/code&gt; on all nodes, a call looks as follows:</source>
          <target state="translated">Функция-оболочка для &lt;code&gt;mnesia:create_table/2&lt;/code&gt; , которая создает таблицу (если таблицы не существует) с соответствующим набором &lt;code&gt;attributes&lt;/code&gt; . Атрибуты и &lt;code&gt;TabDef&lt;/code&gt; передаются в &lt;code&gt;mnesia:create_table/2&lt;/code&gt; . Например, если таблица должна находиться как &lt;code&gt;disc_only_copies&lt;/code&gt; на всех узлах, вызов будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="36b94a437ad5d966a2bc660ff3e1289bcc1b9fd7" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The table only resides on the local node and its storage type is the same as the &lt;code&gt;schema&lt;/code&gt; table on the local node, that is, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; or &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt;.</source>
          <target state="translated">Функция-оболочка для &lt;code&gt;mnesia:create_table/2&lt;/code&gt; , которая создает таблицу (если таблицы не существует) с соответствующим набором &lt;code&gt;attributes&lt;/code&gt; . Таблица находится только на локальном узле, и ее тип хранения такой же, как таблица &lt;code&gt;schema&lt;/code&gt; на локальном узле, то есть &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; или &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fbfb3b2a70e7676f439e216ddfb41c8f42fcb5d" translate="yes" xml:space="preserve">
          <source>A write event was cancelled by &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; or &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and is guaranteed not to generate a &lt;code&gt;ready_output&lt;/code&gt; notification message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bab14cb554b0f0419a6e027fa857770d1ae7636" translate="yes" xml:space="preserve">
          <source>A write operation on a &lt;code&gt;disc_copies&lt;/code&gt; table replica is performed in two steps. First the write operation is appended to a log file, then the actual operation is performed in RAM.</source>
          <target state="translated">Операция записи в &lt;code&gt;disc_copies&lt;/code&gt; таблицы disc_copies выполняется в два этапа. Сначала операция записи добавляется в файл журнала, затем фактическая операция выполняется в ОЗУ.</target>
        </trans-unit>
        <trans-unit id="d9843d85d25b1bd741fdb98939b327e3138b2bfb" translate="yes" xml:space="preserve">
          <source>A zlib stream, see &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поток zlib, см. &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17afbf6d1d5b871c5ae0cee1ba18a4f7071dc38b" translate="yes" xml:space="preserve">
          <source>A: Cygwin, MSYS or MSYS2 is the environment, which closely resembles the environment found on any Unix machine. It's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, Cygwin/MSYS/MSYS2 tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; and &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in Cygwin/MSYS/MSYS2 are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The Cygwin specific command &lt;code&gt;cygpath&lt;/code&gt; is used for most of the path conversions in a Cygwin environment. Other tools are used (when needed) in the corresponding MSYS and MSYS2 environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="translated">A: Cygwin, MSYS или MSYS2 - это среда, которая очень похожа на среду на любой машине Unix. Это почти как если бы у вас была виртуальная машина Unix внутри Windows. Configure, задав определенные параметры, затем создает файлы сборки, которые используются программой gnu-make среды для сборки системы. Однако большинство реальных компиляторов и т. Д. Не являются инструментами Cygwin / MSYS / MSYS2, поэтому мы написали пару оболочек (сценариев оболочки Bourne), которые находятся в &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; и &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt; , Все они выполняют преобразование параметров и переключателей, общих для среды Unix, для соответствия встроенным инструментам Windows. Наиболее примечательны, конечно, пути, которые в Cygwin / MSYS / MSYS2 являются Unix-подобными путями с &amp;laquo;косой чертой&amp;raquo; (/) и без букв дисков. Специфическая команда Cygwin &lt;code&gt;cygpath&lt;/code&gt; используется для большинства преобразований пути в среде Cygwin. Другие инструменты используются (при необходимости) в соответствующей среде MSYS и MSYS2. К счастью, большинство компиляторов принимают в качестве разделителей пути косую черту вместо обратной, но все же нужно правильно указать буквы дисков и т. Д. Скрипты оболочки не являются общими в том смысле, что, например, cc.sh понимает и переводит все возможные параметры gcc и передает правильные параметры в cl.exe. Принцип состоит в том, что скрипты достаточно мощные, чтобы позволить создавать Erlang / OTP, ни больше, ни меньше. Им могут потребоваться расширения, чтобы справиться с изменениями во время разработки Erlang, и это одна из причин, по которой мы сделали их сценариями оболочки, а не сценариями Perl. Мы считаем, что их легче понять и изменить таким образом.</target>
        </trans-unit>
        <trans-unit id="4d1ee8b13defdb6f13a0a5e7daa4cf8a74b29540" translate="yes" xml:space="preserve">
          <source>A: For Cygwin, MSYS and MSYS2 alike, we try to use the latest releases available when building. What versions you use shouldn't really matter. We try to include workarounds for the bugs we've found in different Cygwin/MSYS/MSYS2 releases. Please help us add workarounds for new Cygwin/MSYS/MSYS2-related bugs as soon as you encounter them. Also please do submit bug reports to the appropriate Cygwin, MSYS and/or MSYS2 developers. The GCC we used for 21 was version 4.8.1 (MinGW 32bit) and 4.8.5 (MSYS2 64bit). We used VC++ 12.0 (i.e. Visual studio 2013), Sun's JDK 1.6.0_45 (32bit) and Sun's JDK 1.7.0_1 (64bit), NSIS 2.46, and Win32 OpenSSL 1.0.2d. Please read the next section for details on what you need.</source>
          <target state="translated">О:Для Cygwin,MSYS и MSYS2 мы стараемся использовать при сборке самые свежие релизы.Какие версии вы используете на самом деле не должны иметь значения.Мы стараемся включать обходные пути для найденных ошибок в различных релизах Cygwin/MSYS/MSYS2.Пожалуйста,помогите нам добавить обходные пути для новых ошибок,связанных с Cygwin/MSYS/MSYS2,как только вы с ними столкнетесь.Также,пожалуйста,отправляйте отчеты об ошибках соответствующим разработчикам Cygwin,MSYS и/или MSYS2.GCC,который мы использовали для 21,был версии 4.8.1 (MinGW 32bit)и 4.8.5 (MSYS2 64bit).Мы использовали VC++12.0 (т.е.Visual Studio 2013),Sun's JDK 1.6.0_45 (32 бит)и Sun's JDK 1.7.0_1 (64 бит),NSIS 2.46 и Win32 OpenSSL 1.0.2d.Пожалуйста,прочтите следующий раздел для получения подробной информации о том,что вам нужно.</target>
        </trans-unit>
        <trans-unit id="731d5bc0547d3ee14b9d073a740322bb562e4b26" translate="yes" xml:space="preserve">
          <source>A: No, never. The hassle of keeping the project files up to date and do all the steps that constitute an OTP build from within the VC++ GUI is simply not worth it, maybe even impossible. A VC++ project file for Erlang/OTP will never happen.</source>
          <target state="translated">О:Нет,никогда.Суета в том,чтобы держать проектные файлы в актуальном состоянии и выполнять все шаги,которые составляют сборку OTP изнутри VC++GUI,просто не стоит,может быть,даже невозможна.Файл проекта VC++для Erlang/OTP никогда не случится.</target>
        </trans-unit>
        <trans-unit id="521d37ede1551a08a3beff1206807c9cd55ca94a" translate="yes" xml:space="preserve">
          <source>A: No, not really, but see this as a step in the right direction.</source>
          <target state="translated">О:Нет,не совсем,но рассматривайте это как шаг в правильном направлении.</target>
        </trans-unit>
        <trans-unit id="58e458048a7a9548592140528083c14b19023a3f" translate="yes" xml:space="preserve">
          <source>A: No, the result will be a pure Windows binary, and as far as I know, it's not possible to make a Cygwin binary yet. That is of course something desirable, but there are still some problems with the dynamic linking (dynamic Erlang driver loading) as well as the TCP/IP emulation in Cygwin, which, I'm sure of, will improve, but still has some problems. Fixing those problems might be easy or might be hard. I suggest you try yourself and share your experience. No one would be happier if a simple &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; would produce a fully fledged Cygwin binary.</source>
          <target state="translated">О: Нет, результатом будет чистый двоичный файл Windows, и, насколько мне известно, создать двоичный файл Cygwin пока невозможно. Это, конечно, желательно, но все еще есть проблемы с динамической компоновкой (динамическая загрузка драйвера Erlang), а также с эмуляцией TCP / IP в Cygwin, которая, я уверен, улучшится, но все еще имеет некоторые проблемы. , Устранение этих проблем может быть простым или трудным. Предлагаю вам попробовать себя и поделиться своим опытом. Никто не был бы счастливее, если бы простой &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; создал бы полноценный двоичный файл Cygwin.</target>
        </trans-unit>
        <trans-unit id="f58ec10da79cf14638b87d58a71fefc5754e9d5f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the Cygwin environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler. The Windows SDK is however enough to build Erlang, you do not need to buy Visual C++, just download the SDK (SDK version 8.1 == Visual studio 2013).</source>
          <target state="translated">О:Нет,к сожалению,нет.Вам понадобится Visual C++от Microsoft.Скрипт Bourne-shell (cc.sh)обёртывает компилятор Visual C++и запускает его из среды Cygwin.Все остальные инструменты,необходимые для сборки Erlang,являются свободно распространяемыми/открытыми исходными текстами,но не компилятор C.Однако для сборки Erlang достаточно Windows SDK,вам не нужно покупать Visual C++,просто скачайте SDK (SDK версии 8.1 ==Visual Studio 2013).</target>
        </trans-unit>
        <trans-unit id="85724e56e3dcb9f76cc960c4345313a7227e07b7" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the WSL environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a599e8e13ccfd4f3e0504f6192bcbcf31a59938f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately we haven't got time to help with Cygwin/MSYS/MSYS2 related user problems, please read related websites, newsgroups and mailing lists.</source>
          <target state="translated">A:Нет,к сожалению,у нас нет времени,чтобы помочь с проблемами пользователей,связанными с Cygwin/MSYS/MSYS2,пожалуйста,ознакомьтесь с соответствующими сайтами,новостными группами и списками рассылки.</target>
        </trans-unit>
        <trans-unit id="210dcbb21de47a153ba938b86b20600d7d480a0c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using Cygwin's or MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="translated">A: Хорошо, я допускаю, что один из файлов компилируется с использованием Cygwin или MinGW GCC, а полученный объектный код затем конвертируется в совместимый с MS VC ++ coff с помощью небольшого хака на C. Это потому, что этот конкретный файл, &lt;code&gt;beam_emu.c&lt;/code&gt; , очень выигрывает от возможности использовать расширение GCC labels-as-values, которое повышает производительность эмулятора до 50%. К сожалению, это (пока) не означает, что весь OTP может быть скомпилирован с использованием GCC. Этот конкретный исходный код не делает ничего специфичного для системы и фактически адаптирован к тому факту, что GCC используется для его компиляции в Windows.</target>
        </trans-unit>
        <trans-unit id="81af1c0ed56bada7f1365c496431c92fc23f483c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e36bf356b0e8d7e06efee09f6d96691782df63" translate="yes" xml:space="preserve">
          <source>A: WSL/Ubuntu is the environment, it's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, WSL tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/wsl_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in WSL are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The WSL specific command &lt;code&gt;wslpath&lt;/code&gt; is used for most of the path conversions in a WSL environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2634e5d15aa84185c8c93ac17bc4f970898371" translate="yes" xml:space="preserve">
          <source>A: We use WSL 1 with Ubuntu 18.04. The GCC we used for 23 was version 7.3-win32. We used Visual studio 2019, Sun's JDK 1.8.0_241, NSIS 3.05, Win32 OpenSSL 1.1.1d and wxWidgets-3.1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fcb970b445ac9a87b96b37bf7ea3a4ab4cab29" translate="yes" xml:space="preserve">
          <source>A: Well, it's not expensive, it's free (as in free beer). Just download and install the latest Windows SDK from Microsoft and all the tools you need are there. The included debugger (WinDbg) is also quite usable. That's what I used when porting Erlang to 64bit Windows. Another reason to use later Microsoft compilers is DLL compatibility. DLL's using a new version of the standard library might not load if the VM is compiled with an old VC++ version. So we should aim to use the latest freely available SDK and compiler.</source>
          <target state="translated">О:Ну,это не дорого,это бесплатно (как в бесплатном пиве).Просто скачайте и установите последнюю версию Windows SDK от Microsoft,и все необходимые инструменты будут там.Входящий в комплект отладчик (WinDbg)также весьма удобен.Это то,что я использовал при переносе Erlang на 64-битную Windows.Другой причиной использования более поздних компиляторов Microsoft является совместимость с DLL.Использование DLL в новой версии стандартной библиотеки может не загружаться,если ВМ скомпилирована со старой версией VC++.Поэтому следует стремиться использовать новейший свободно доступный SDK и компилятор.</target>
        </trans-unit>
        <trans-unit id="c041ae7e57578688a11137a9916f0588de32a73f" translate="yes" xml:space="preserve">
          <source>A: Well, partly because it's a good compiler - really! Actually it's been possible in late R11-releases to build using mingw instead of visual C++ (you might see the remnants of that in some scripts and directories). Unfortunately the development of the SMP version for Windows broke the mingw build and we chose to focus on the VC++ build as the performance has been much better in the VC++ versions. The mingw build will possibly be back, but as long as VC++ gives better performance, the commercial build will be a VC++ one.</source>
          <target state="translated">О:Ну,отчасти потому,что это хороший компилятор-на самом деле! На самом деле,в поздних R11-релизах стало возможным собирать с помощью mingw вместо визуального C++(остатки этого можно увидеть в некоторых скриптах и каталогах).К сожалению,разработка версии SMP для Windows сломала сборку mingw,и мы решили сконцентрироваться на сборке VC++,так как в версиях VC++производительность была намного лучше.Возможно,сборка mingw и вернется,но пока VC++дает лучшую производительность,коммерческая сборка будет VC++.</target>
        </trans-unit>
        <trans-unit id="8315e42a391d74c84bc127e20d99aa2c7b6bc114" translate="yes" xml:space="preserve">
          <source>A: Yes, we use the exact same build procedure.</source>
          <target state="translated">О:Да,мы используем точно такую же процедуру построения.</target>
        </trans-unit>
        <trans-unit id="c88a17178680779495642b56e9c7d27ea864c737" translate="yes" xml:space="preserve">
          <source>AH(NeedStack, NeedHeap, Live)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be36dfbb5116564a40ed7d5b4cbdf3999ccff9dc" translate="yes" xml:space="preserve">
          <source>API Description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436942b9131313ac7f725ef0106016a7cb814a52" translate="yes" xml:space="preserve">
          <source>API for a SSL/TLS CRL (Certificate Revocation List) cache.</source>
          <target state="translated">API для кэша SSL/TLS CRL (Certificate Revocation List-список отзыва сертификатов).</target>
        </trans-unit>
        <trans-unit id="01fc1fc29ee3bdfac97c802f999cf7358e251132" translate="yes" xml:space="preserve">
          <source>API for a TLS CRL (Certificate Revocation List) cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23c8e20572073978952d048d9433a8575f6a97d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang NIF library.</source>
          <target state="translated">Функции API для библиотеки Erlang NIF.</target>
        </trans-unit>
        <trans-unit id="361d551affb47befd80fca6479fe8a167dc7036d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang driver.</source>
          <target state="translated">Функции API для драйвера Эрланга.</target>
        </trans-unit>
        <trans-unit id="e80b30d77b2cab01b81ccc87fb312659f6e0dd98" translate="yes" xml:space="preserve">
          <source>API functions in the module &lt;code&gt;httpd_conf&lt;/code&gt; was deprecated in favor of standard modules such as &lt;code&gt;lists&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;filelib&lt;/code&gt;, and &lt;code&gt;erlang&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d310425c434730e2f59306f932cf1691ae572d78" translate="yes" xml:space="preserve">
          <source>API functions to write customized SSH clients and servers applications</source>
          <target state="translated">Функции API для написания настраиваемых SSH клиентов и серверных приложений</target>
        </trans-unit>
        <trans-unit id="de210df0a505b46fa42dc263d10d332cce666788" translate="yes" xml:space="preserve">
          <source>API kept from previous versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bf5fea06a2041d232930267f67048618c99f45" translate="yes" xml:space="preserve">
          <source>API module for Logger, the standard logging facility in Erlang/OTP.</source>
          <target state="translated">API модуль для Журнала,стандартный журнал в Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="0be52be7a0efe4a62d99e98efb97a08aef84fe41" translate="yes" xml:space="preserve">
          <source>API module for public-key infrastructure.</source>
          <target state="translated">API модуль для инфраструктуры открытых ключей.</target>
        </trans-unit>
        <trans-unit id="76827dde5bd6ab1accea3ccbe25374a63afc24e6" translate="yes" xml:space="preserve">
          <source>ARM: ARMv5TE (i.e. XScale) processors should work. Both big-endian and little-endian modes are supported.</source>
          <target state="translated">ARM:Должны работать процессоры ARMv5TE (т.е.XScale).Поддерживаются режимы big-endian и little-endian.</target>
        </trans-unit>
        <trans-unit id="ca8c02ce6c85a255754680e86371209b9b2680ce" translate="yes" xml:space="preserve">
          <source>ARM: Linux</source>
          <target state="translated">ARM:Linux</target>
        </trans-unit>
        <trans-unit id="d9932f6f9e0505be61dc8fcd25736c1bf8cf818f" translate="yes" xml:space="preserve">
          <source>ASCII value or unicode code-point of the character &lt;strong&gt;&lt;code&gt;char&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Значение ASCII или кодовая точка Unicode символа &lt;strong&gt; &lt;code&gt;char&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="196ab313cd92b6ea93995c7fc93f081f77b30992" translate="yes" xml:space="preserve">
          <source>ASN.1 DER-encoded entity as an Erlang binary.</source>
          <target state="translated">ASN.1 Объект,закодированный в DER как двоичный Erlang.</target>
        </trans-unit>
        <trans-unit id="5fa4ef6c7f4c743ebd97fa57feafd946e53e8d8c" translate="yes" xml:space="preserve">
          <source>ASN.1 Specifications, Messages, and Configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368efd7c5142e650553f401aa461d1b76d069901" translate="yes" xml:space="preserve">
          <source>ASN.1 compiler and compile-time support functions</source>
          <target state="translated">Функции компилятора и поддержки времени компиляции ASN.1</target>
        </trans-unit>
        <trans-unit id="c009d6d020f91e9075e192687145f1f9183e3b17" translate="yes" xml:space="preserve">
          <source>ASN.1 has both primitive and constructed types:</source>
          <target state="translated">ASN.1 имеет как примитивные,так и сконструированные типы:</target>
        </trans-unit>
        <trans-unit id="cfcd66d008f9b63d7b919bdf916303779861fe19" translate="yes" xml:space="preserve">
          <source>ASN.1 is a formal language for describing data structures to be exchanged between distributed computer systems. The purpose of ASN.1 is to have a platform and programming language independent notation to express types using a standardized set of rules for the transformation of values of a defined type into a stream of bytes. This stream of bytes can then be sent on any type of communication channel. This way, two applications written in different programming languages running on different computers, and with different internal representation of data, can exchange instances of structured data types.</source>
          <target state="translated">ASN.1 является формальным языком описания структур данных,которыми необходимо обмениваться между распределенными компьютерными системами.Назначение ASN.1-иметь независимую от платформы и языка программирования нотацию для выражения типов с использованием стандартизированного набора правил для преобразования значений определенного типа в поток байт.Этот поток байтов может затем передаваться по любому каналу связи.Таким образом,два приложения,написанные на разных языках программирования и работающие на разных компьютерах с разным внутренним представлением данных,могут обмениваться экземплярами структурированных типов данных.</target>
        </trans-unit>
        <trans-unit id="3b1ea2d9df3b25e2e5fe146441abf268990d9a8f" translate="yes" xml:space="preserve">
          <source>ASN.1 is used in two different ways in SNMP. The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1.</source>
          <target state="translated">ASN.1 используется в SNMP двумя различными способами.SMI основан на ASN.1,а сообщения в протоколе определяются с помощью ASN.1.</target>
        </trans-unit>
        <trans-unit id="18afe0241096372d9207a097906f4cc9e96ca40a" translate="yes" xml:space="preserve">
          <source>ASN.1 itself specifies indefinitely large integers. Erlang systems with version 4.3 and higher support very large integers, in practice indefinitely large integers.</source>
          <target state="translated">Сам ASN.1 определяет бесконечно большие целые числа.Системы Erlang версии 4.3 и выше поддерживают очень большие целые числа,на практике бесконечно большие целые числа.</target>
        </trans-unit>
        <trans-unit id="1b5feca556ffbb7ecdf53e29fcc97d476a5bf5f3" translate="yes" xml:space="preserve">
          <source>ASN.1 module &lt;code&gt;People&lt;/code&gt; is now accepted and the abstract syntax tree is saved in file &lt;code&gt;People.asn1db&lt;/code&gt;. The generated Erlang code is compiled using the Erlang compiler and loaded into the Erlang runtime system. There is now an API for &lt;code&gt;encode/2&lt;/code&gt; and &lt;code&gt;decode/2&lt;/code&gt; in module &lt;code&gt;People&lt;/code&gt;, which is called like:</source>
          <target state="translated">Модуль ASN.1 &lt;code&gt;People&lt;/code&gt; теперь принят, а абстрактное синтаксическое дерево сохраняется в файле &lt;code&gt;People.asn1db&lt;/code&gt; . Сгенерированный код Erlang компилируется с помощью компилятора Erlang и загружается в систему времени выполнения Erlang. Теперь в модуле &lt;code&gt;People&lt;/code&gt; есть API для &lt;code&gt;encode/2&lt;/code&gt; и &lt;code&gt;decode/2&lt;/code&gt; , который называется примерно так:</target>
        </trans-unit>
        <trans-unit id="38ab94405d2e97c97a998a6475af5251fa89b825" translate="yes" xml:space="preserve">
          <source>ASN.1 supports a wide variety of character sets. The main difference between an &lt;code&gt;OCTET STRING&lt;/code&gt; and a character string is that the &lt;code&gt;OCTET STRING&lt;/code&gt; has no imposed semantics on the bytes delivered.</source>
          <target state="translated">ASN.1 поддерживает широкий спектр наборов символов. Основное различие между &lt;code&gt;OCTET STRING&lt;/code&gt; и символьной строкой состоит в том, что &lt;code&gt;OCTET STRING&lt;/code&gt; не имеет навязанной семантики доставляемых байтов.</target>
        </trans-unit>
        <trans-unit id="00118b8d7398e0597bbf5e3a9b1a946f91c275ba" translate="yes" xml:space="preserve">
          <source>ASN.1 type present in the Public Key applications ASN.1 specifications.</source>
          <target state="translated">Тип ASN.1,присутствующий в спецификациях ASN.1 для приложений с открытым ключом.</target>
        </trans-unit>
        <trans-unit id="999234c8b850d2864e4971ba3f6a923f854d60c2" translate="yes" xml:space="preserve">
          <source>ASN1 file. It creates an &lt;code&gt;.erl&lt;/code&gt;, &lt;code&gt;.hrl&lt;/code&gt;, and &lt;code&gt;.asn1db&lt;/code&gt; file from an &lt;code&gt;.asn1&lt;/code&gt; file. Also compiles the &lt;code&gt;.erl&lt;/code&gt; using the Erlang compiler unless option &lt;code&gt;+noobj&lt;/code&gt; is specified.</source>
          <target state="translated">ASN1 файл. Он создает &lt;code&gt;.erl&lt;/code&gt; , &lt;code&gt;.hrl&lt;/code&gt; и &lt;code&gt;.asn1db&lt;/code&gt; из файла &lt;code&gt;.asn1&lt;/code&gt; . Также компилирует &lt;code&gt;.erl&lt;/code&gt; с помощью компилятора Erlang, если не указан параметр &lt;code&gt;+noobj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4ea8e8df4b539a09e4694a57b64fe87acc6aa2" translate="yes" xml:space="preserve">
          <source>AVP Codes</source>
          <target state="translated">AVP-коды</target>
        </trans-unit>
        <trans-unit id="5f07924d7df0ed6c7a91768f9fe2d84ed905e783" translate="yes" xml:space="preserve">
          <source>AVP Considerations</source>
          <target state="translated">Соображения АВП</target>
        </trans-unit>
        <trans-unit id="358dba47c0c1d2a1ab4897c5be6e756cf7939cf1" translate="yes" xml:space="preserve">
          <source>AVP Flags</source>
          <target state="translated">флаги AVP</target>
        </trans-unit>
        <trans-unit id="147e947b2ccddb2127e44e91cd77c7172c834c87" translate="yes" xml:space="preserve">
          <source>AVP Header</source>
          <target state="translated">заголовок AVP</target>
        </trans-unit>
        <trans-unit id="db689f171790fb1bc972a968ef05e4c119e28132" translate="yes" xml:space="preserve">
          <source>AVP Occurrence Tables</source>
          <target state="translated">Таблицы происхождений AVP</target>
        </trans-unit>
        <trans-unit id="7b38fc4069f3bc947361bf1d7d5e19953586e35e" translate="yes" xml:space="preserve">
          <source>AVP Values</source>
          <target state="translated">Значения AVP</target>
        </trans-unit>
        <trans-unit id="c483ce0c3913a6678d954f208b0703dcb0e25b18" translate="yes" xml:space="preserve">
          <source>AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types.</source>
          <target state="translated">Значения AVP,отправляемые в исходящих сообщениях CER или CEA во время обмена возможностями.Может быть сконфигурировано как на службе,так и на транспорте,значения на последнем имеют приоритет.Имеет один из следующих типов.</target>
        </trans-unit>
        <trans-unit id="2c0e57636791ead050a384bc77e79f8d2fe33260" translate="yes" xml:space="preserve">
          <source>AVPs are decoded into a list of diameter_avp records in &lt;code&gt;avps&lt;/code&gt; field of diameter_packet records independently of &lt;code&gt;decode_format&lt;/code&gt;.</source>
          <target state="translated">AVP декодируются в список записей &lt;code&gt;avps&lt;/code&gt; поле avps записей Diameter_packet независимо от &lt;code&gt;decode_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84bf21f5193b0af6e24655608ac0e30ceef7e07a" translate="yes" xml:space="preserve">
          <source>AVPs defined in the RFC are defined in dictionaries provided by diameter. Their proper use in application messages is the responsibility of the user.</source>
          <target state="translated">АВП,определенные в КСФ,определяются в словарях,предоставляемых по диаметру.Ответственность за их правильное использование в сообщениях приложения несет пользователь.</target>
        </trans-unit>
        <trans-unit id="6734299ae0f748faa6b52d7e11abf2d0c25ca64f" translate="yes" xml:space="preserve">
          <source>AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question.</source>
          <target state="translated">AVP,используемые для построения исходящих сообщений CER/CEA.Значения имеют приоритет над любыми указанными в данной услуге.</target>
        </trans-unit>
        <trans-unit id="5816a66e2c13a6d76644d2e1d9520bcb6dbe4591" translate="yes" xml:space="preserve">
          <source>Aa a list of binary digits (0 or 1). This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if option &lt;strong&gt;legacy_bit_string&lt;/strong&gt; is given.</source>
          <target state="translated">Список двоичных цифр (0 или 1). Этот формат принимается в качестве входных данных для функций кодирования, и &lt;code&gt;BIT STRING&lt;/code&gt; декодируется в этот формат, если &lt;strong&gt;задана&lt;/strong&gt; опция &lt;strong&gt;legacy_bit_string&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c2fc2e3239e8ec3bf7008184c81466440651887a" translate="yes" xml:space="preserve">
          <source>Abandon a previously issued spawn request. &lt;code&gt;ReqId&lt;/code&gt; corresponds to a request identifier previously returned by &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request()&lt;/a&gt;&lt;/code&gt; in a call from current process. That is, only the process that has made the request can abandon the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bdc897b18ae8c316a38939d3d1d0e98477ad32" translate="yes" xml:space="preserve">
          <source>Abandon carrier free block min limit. A valid &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; is a positive integer representing a block size limit. The largest free block in a carrier must be at least &lt;code&gt;bytes&lt;/code&gt; large, for the carrier to be abandoned. The default is zero but can be changed in the future.</source>
          <target state="translated">Отказаться от минимального ограничения на количество блоков без несущей. Допустимый &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; - это положительное целое число, представляющее ограничение на размер блока. Самый большой свободный блок на носителе должен быть не менее &lt;code&gt;bytes&lt;/code&gt; , чтобы носитель был оставлен. Значение по умолчанию равно нулю, но в будущем его можно будет изменить.</target>
        </trans-unit>
        <trans-unit id="2e058521811c5ddbaf236521691a6aac5c91e2d2" translate="yes" xml:space="preserve">
          <source>Abandon carrier number limit. A valid &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</source>
          <target state="translated">Отказаться от ограничения количества операторов связи. Допустимое &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; - это положительное целое число, представляющее максимальное количество брошенных несущих на экземпляр распределителя. По умолчанию 1000, что практически отключит ограничение, но это может быть изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="ddd8504b781a1a9f6d7b92f1aa500221a0c4787e" translate="yes" xml:space="preserve">
          <source>Abandon carrier utilization limit. A valid &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; is an integer in the range &lt;code&gt;[0, 100]&lt;/code&gt; representing utilization in percent. When a utilization value &amp;gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If &lt;code&gt;de&lt;/code&gt; (default enabled) is passed instead of a &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt;, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to &lt;code&gt;de&lt;/code&gt;, but this can be changed in the future.</source>
          <target state="translated">Отказаться от ограничения использования оператора связи. Допустимое значение &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; - это целое число в диапазоне &lt;code&gt;[0, 100]&lt;/code&gt; представляющее коэффициент использования в процентах. Когда используется значение использования&amp;gt; 0, экземплярам распределителя разрешается отказаться от многоблочных несущих. Если вместо &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; передается &lt;code&gt;de&lt;/code&gt; (по умолчанию включено) , используется рекомендованное ненулевое значение использования. Выбранное значение зависит от типа распределителя и может быть изменено между версиями ERTS. По умолчанию &lt;code&gt;de&lt;/code&gt; , но это может быть изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="99ed550f3cfb54b7e586b3d6dae1d5c6c29740db" translate="yes" xml:space="preserve">
          <source>Ability to start an Erlang emulator with more flags (any flags supported by &lt;code&gt;erl&lt;/code&gt; are supported).</source>
          <target state="translated">Возможность запустить эмулятор Erlang с большим количеством флагов (поддерживаются любые флаги, поддерживаемые &lt;code&gt;erl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31592e98a78da975e62737d1409cd4fb77bffb8e" translate="yes" xml:space="preserve">
          <source>Abnormally terminates the association specified by &lt;code&gt;Assoc&lt;/code&gt;, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and the socket can be used in new associations.</source>
          <target state="translated">Аномально завершает ассоциацию, указанную &lt;code&gt;Assoc&lt;/code&gt; , без сброса неотправленных данных. Сама розетка остается открытой. Другие ассоциации, открытые в этом сокете, все еще действительны, и сокет может использоваться в новых ассоциациях.</target>
        </trans-unit>
        <trans-unit id="54e07c4e032173c30d3e1d7eccc1fc09c4351b63" translate="yes" xml:space="preserve">
          <source>Abort-Session-Answer</source>
          <target state="translated">Abort-Session-Answer</target>
        </trans-unit>
        <trans-unit id="aa6a977eb79f01d2748881fca70eaba063d40819" translate="yes" xml:space="preserve">
          <source>Abort-Session-Request</source>
          <target state="translated">Abort-Session-Request</target>
        </trans-unit>
        <trans-unit id="53f8d6aa2f451847b8dbd7813ad859f16188a7eb" translate="yes" xml:space="preserve">
          <source>Aborting a Session</source>
          <target state="translated">Прерывание сессии</target>
        </trans-unit>
        <trans-unit id="19fdf66eca72538f9393a1351c5653c5dbe6dba0" translate="yes" xml:space="preserve">
          <source>Aborts the connection when it is closed. Discards any data still remaining in the send buffers and sends RST to the peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90030936dbb152015b9486771f1ada8423bb6a8" translate="yes" xml:space="preserve">
          <source>Aborts the current association without flushing any unsent data</source>
          <target state="translated">Прерывает текущую ассоциацию,не смывая не отправленные данные.</target>
        </trans-unit>
        <trans-unit id="32505d42e4f66e192dcee78817ac876d40a66d28" translate="yes" xml:space="preserve">
          <source>Aborts the currently executing test case. The user must know with certainty which test case is currently executing. The function is therefore only safe to call from a function that has been called (or synchronously invoked) by the test case.</source>
          <target state="translated">Отменяет выполняемый в настоящее время тест.Пользователь должен точно знать,какой тестовый случай выполняется в данный момент.Поэтому функция может быть безопасно вызвана только из функции,которая была вызвана (или синхронно вызвана)тестовым случаем.</target>
        </trans-unit>
        <trans-unit id="d5a894573c68d878cab4cb98be562e26f9a7f0d1" translate="yes" xml:space="preserve">
          <source>Aborts the test run if one or more suites fail to compile (described earlier).</source>
          <target state="translated">Прерывает выполнение теста,если один или несколько комплектов не скомпилированы (описано выше).</target>
        </trans-unit>
        <trans-unit id="0744eff0f05c525e12f11abc8717d631608439c4" translate="yes" xml:space="preserve">
          <source>Absolute &lt;code&gt;Time&lt;/code&gt; value. The &lt;code&gt;Time&lt;/code&gt; value is interpreted as an absolute Erlang monotonic time in milliseconds.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;Time&lt;/code&gt; . Значение &lt;code&gt;Time&lt;/code&gt; интерпретируется как абсолютное монотонное время Эрланга в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="6f0553231a05faffe297bc7acf9cdaa15d3ad0d6" translate="yes" xml:space="preserve">
          <source>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">Абсолютный максимальный размер кэша не подходит (в килобайтах). Сегмент в кэше сегментов памяти не используется повторно, если его размер превышает запрошенный размер, превышающий значение этого параметра. По умолчанию &lt;code&gt;4096&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06e7393a1c9fa0746c02d1ffbcea8603bb27631f" translate="yes" xml:space="preserve">
          <source>Absolute offset.</source>
          <target state="translated">Абсолютное смещение.</target>
        </trans-unit>
        <trans-unit id="44496adc987c03d870e59213dad3144a175329ee" translate="yes" xml:space="preserve">
          <source>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Абсолютный порог усадки одноблочного носителя (в килобайтах). Когда блок, расположенный в одноблочной несущей &lt;code&gt;mseg_alloc&lt;/code&gt; , сжимается, несущая остается неизменной, если объем неиспользуемой памяти меньше этого порога, в противном случае несущая уменьшается. См. Также &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff57be685f71df6825a00bb0dd0675ff72e59819" translate="yes" xml:space="preserve">
          <source>Absolute time-out time</source>
          <target state="translated">Абсолютный тайм-аут</target>
        </trans-unit>
        <trans-unit id="87b7af24fbc7dca667aaef7cedf788bba72797a9" translate="yes" xml:space="preserve">
          <source>Abstract Data Type for SNMP Indexing</source>
          <target state="translated">Аннотация Тип данных для SNMP индексирования</target>
        </trans-unit>
        <trans-unit id="5609a156333d78829625afc9b9f892be80c713da" translate="yes" xml:space="preserve">
          <source>Abstract Erlang syntax trees.</source>
          <target state="translated">Абстрактные синтаксические деревья Эрланга.</target>
        </trans-unit>
        <trans-unit id="0fc0a26f5661ecd86fced093abdeb714aebff28c" translate="yes" xml:space="preserve">
          <source>Abstract data type for FIFO queues.</source>
          <target state="translated">Абстрактный тип данных для FIFO-очереди.</target>
        </trans-unit>
        <trans-unit id="0036b597c9166dc75f5f416f3d4f8e2976e568cd" translate="yes" xml:space="preserve">
          <source>Abstract datatype for the annotations of the Erlang Compiler.</source>
          <target state="translated">Абстрактный тип данных для аннотаций компилятора Erlang.</target>
        </trans-unit>
        <trans-unit id="60de543c8b0a2bf7a7b2b18c9b9c6e2e54182daa" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang clause.</source>
          <target state="translated">Абстрактная форма пункта Эрланга.</target>
        </trans-unit>
        <trans-unit id="d6672e8badf7c19620dd4aaaf05ad582f5d5750e" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang expression.</source>
          <target state="translated">Абстрактная форма выражения Эрланга.</target>
        </trans-unit>
        <trans-unit id="39fe847d06d62d8e80b55d37a59200693c709fd2" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang form.</source>
          <target state="translated">Абстрактная форма формы Эрланга.</target>
        </trans-unit>
        <trans-unit id="b2f998c312eeafe0281400d148af41f390922671" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang type.</source>
          <target state="translated">Абстрактная форма типа Эрланг.</target>
        </trans-unit>
        <trans-unit id="5a9b296f4df7477eb5b5b50aeb9d835778376408" translate="yes" xml:space="preserve">
          <source>Abstract representation of a generator or a bitstring generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492e4e253beefd260963df05d99c417ca4290bfc" translate="yes" xml:space="preserve">
          <source>Abstract representation of a record field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00f2a5860c99ba7cb396e03f0dc272d78b0cc94" translate="yes" xml:space="preserve">
          <source>Abstract representation of a remote function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5c131fe9c0f70e4b39d2d2baddcf228a489a93" translate="yes" xml:space="preserve">
          <source>Abstract representation of an element of a bitstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c262fbcd830c7cce729c33d7fe8e67175762f3" translate="yes" xml:space="preserve">
          <source>Accept a connection on a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4a58616d72eca00517c5490fb42e2012ac253a" translate="yes" xml:space="preserve">
          <source>Accept connections on the listen socket identified by &lt;code&gt;*ctx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e50abdb48c5e81f25cc8ea3044d328ca8ac2fce" translate="yes" xml:space="preserve">
          <source>Accept the connection.</source>
          <target state="translated">Примите соединение.</target>
        </trans-unit>
        <trans-unit id="f62959ef635bf54ce8db016df3aaff0dd63a1788" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt; handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the TLS/DTLS connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632efb93ff14184018a35197a6178c2417c5bf58" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the SSL/TLS/DTLS connection.</source>
          <target state="translated">Принимает входящий запрос на подключение к прослушивающему сокету. &lt;code&gt;ListenSocket&lt;/code&gt; должен быть сокетом, возвращенным из &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; . Возвращенный сокет должен быть передан на &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; для завершения квитирования, то есть установления соединения SSL / TLS / DTLS.</target>
        </trans-unit>
        <trans-unit id="69d043ef57e7745987475e175cb8e488f0827aa5" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listening socket. &lt;code&gt;Socket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out value in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Принимает входящий запрос на подключение к прослушивающему сокету. &lt;code&gt;Socket&lt;/code&gt; должен быть сокетом, возвращенным из &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;Timeout&lt;/code&gt; указывает значение тайм-аута в миллисекундах. По умолчанию &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cebb4f984dd0627e66700aca28cb0e1a5e9b377" translate="yes" xml:space="preserve">
          <source>Accepts from the listen socket identified by the specified identification number. The identification number is retrieved with the &lt;code&gt;uds_control&lt;/code&gt; routine.</source>
          <target state="translated">Принимает от прослушивающего сокета, идентифицированного указанным идентификационным номером. Идентификационный номер получается с &lt;code&gt;uds_control&lt;/code&gt; процедуры uds_control .</target>
        </trans-unit>
        <trans-unit id="376e9046cc5fd2842ce29e30d9b75eab2742e487" translate="yes" xml:space="preserve">
          <source>Access Restrictions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804ff6a7ca49a544473ae24cb9339afd2154136e" translate="yes" xml:space="preserve">
          <source>Access globally registered names.</source>
          <target state="translated">Доступ к глобально зарегистрированным именам.</target>
        </trans-unit>
        <trans-unit id="119dea3e192ecc9326f47133ed54d5f5ec4367c3" translate="yes" xml:space="preserve">
          <source>Access rights must be set so that all nodes in the pool have the authority to access each other.</source>
          <target state="translated">Права доступа должны быть установлены таким образом,чтобы все узлы пула имели право доступа друг к другу.</target>
        </trans-unit>
        <trans-unit id="7a783c4df63409ddf4859d4d9c63884928a701bd" translate="yes" xml:space="preserve">
          <source>Access to TCP/IP protocols.</source>
          <target state="translated">Доступ к протоколам TCP/IP.</target>
        </trans-unit>
        <trans-unit id="cb621788e34fed8e0f28301fdda0b265d5b636b7" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/17/foo would cause the server to run the script /web/17/cgi-bin/foo.</source>
          <target state="translated">Доступ к http://your.server.org/cgi-bin/17/foo заставит сервер запустить скрипт /web/17/cgi-bin/foo.</target>
        </trans-unit>
        <trans-unit id="a462746b4ce0075f7024ce8c93ee0d727108ca1e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/foo would cause the server to run the script /web/cgi-bin/foo.</source>
          <target state="translated">Доступ к http://your.server.org/cgi-bin/foo заставит сервер запустить скрипт /web/cgi-bin/foo.</target>
        </trans-unit>
        <trans-unit id="50c06117af6e8e6670291bbfd27326b9ace3849a" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/docs/ would return http://your.server.org/docs/index.html or http://your.server.org/docs/welcome.html if index.html does not exist.</source>
          <target state="translated">Доступ к http://your.server.org/docs/вернет http://your.server.org/docs/index.html или http://your.server.org/docs/welcome.html,если index.html не существует.</target>
        </trans-unit>
        <trans-unit id="55663d7fd0c514824e934bdabda94079e8fc90bd" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/image/foo.gif would refer to the file /ftp/pub/image/foo.gif.</source>
          <target state="translated">Доступ по адресу http://your.server.org/image/foo.gif осуществляется по ссылке на файл /ftp/pub/image/foo.gif.</target>
        </trans-unit>
        <trans-unit id="427eed565a2163db52b5b617c51105003a80c4da" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7455d0c1b31ee765842e7d4c484ec0f7dd272b9e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif. In an Apache-like configuration file, &lt;code&gt;Re&lt;/code&gt; is separated from &lt;code&gt;Replacement&lt;/code&gt; with one single space, and as expected backslashes do not need to be backslash escaped, the same example would become:</source>
          <target state="translated">Доступ к http://your.server.org/~bob/foo.gif будет относиться к файлу /home/bob/public/foo.gif. В конфигурационном файле, подобном Apache, &lt;code&gt;Re&lt;/code&gt; отделяется от &lt;code&gt;Replacement&lt;/code&gt; одним пробелом, и, как ожидается, обратная косая черта не требует экранирования обратной косой черты, тот же пример будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="a5376bb41fa3654f4b966a3b6b6e89c5279df85f" translate="yes" xml:space="preserve">
          <source>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)</source>
          <target state="translated">AccessMod:all_keys(ActivityId,Opaque,Tab,LockKind)</target>
        </trans-unit>
        <trans-unit id="6f94df94a3e7a36d86e327efa5167226380b0374" translate="yes" xml:space="preserve">
          <source>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:delete(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="b5445c5aafa2ff9673bac795581de2bbc41c0c0f" translate="yes" xml:space="preserve">
          <source>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind)</source>
          <target state="translated">AccessMod:delete_object(ActivityId,Opaque,Tab,RecXS,LockKind)</target>
        </trans-unit>
        <trans-unit id="3e7316c12d79f02736aee472f82ff47536afd350" translate="yes" xml:space="preserve">
          <source>AccessMod:first(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:первый (ActivityId,непрозрачный,вкладка)</target>
        </trans-unit>
        <trans-unit id="b3f5ad115c23452c24775618b9441d204cbd0d17" translate="yes" xml:space="preserve">
          <source>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_match_object(ActivityId,Opaque,Tab,Pattern,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="64b8364a718a756d7a35ce5b28a17687b5f7875e" translate="yes" xml:space="preserve">
          <source>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_read(ActivityId,Opaque,Tab,SecondaryKey,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="405ecfd3752c77ca520244aedede4b5587dbac66" translate="yes" xml:space="preserve">
          <source>AccessMod:last(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:последний(ActivityId,непрозрачный,вкладка)</target>
        </trans-unit>
        <trans-unit id="0fe0be60df449ead6d34747d5036ed4f5deeb071" translate="yes" xml:space="preserve">
          <source>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)</source>
          <target state="translated">AccessMod:замок (ActivityId,Opaque,LockItem,LockKind)</target>
        </trans-unit>
        <trans-unit id="7f89b76e80a1cb03dd0d79dad619cfd7ed1b75a0" translate="yes" xml:space="preserve">
          <source>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind)</source>
          <target state="translated">AccessMod:match_object(ActivityId,Opaque,Tab,Pattern,LockKind)</target>
        </trans-unit>
        <trans-unit id="2eb39b70c8643684acb852d676bca64e66ecf08b" translate="yes" xml:space="preserve">
          <source>AccessMod:next(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:next(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="377e160f1491a996cf09b6412ddf1f19b01e4596" translate="yes" xml:space="preserve">
          <source>AccessMod:prev(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:prev(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="3240408ebba47649936190643d81115a2facdad7" translate="yes" xml:space="preserve">
          <source>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:read(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="f4ae75249d02d33c6b19d3db539b11ddf2e8c3b7" translate="yes" xml:space="preserve">
          <source>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)</source>
          <target state="translated">AccessMod:table_info(ActivityId,Opaque,Tab,InfoItem)</target>
        </trans-unit>
        <trans-unit id="593b1df980f5bc3e0025a26bd60fd36b84ab2a86" translate="yes" xml:space="preserve">
          <source>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)</source>
          <target state="translated">AccessMod:запись (ActivityId,Opaque,Tab,Rec,LockKind)</target>
        </trans-unit>
        <trans-unit id="21658514a1a49042d074927498970b49e42450f1" translate="yes" xml:space="preserve">
          <source>AccessMode :: write | read,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bb0b3771b790d4a4246ea93a50f0538d3b9ae5" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;Mnesia&lt;/code&gt; tables from a QLC list comprehension must always be done within a transaction. Consider the following function:</source>
          <target state="translated">Доступ к таблицам &lt;code&gt;Mnesia&lt;/code&gt; из списка QLC всегда должен выполняться в рамках транзакции. Рассмотрим следующую функцию:</target>
        </trans-unit>
        <trans-unit id="d4e0ceeb0457db320ec7c5e806ad2aa7f79465dd" translate="yes" xml:space="preserve">
          <source>Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size:</source>
          <target state="translated">Доступ к записи,выходящей за пределы последнего установленного значения,также возвращает значение по умолчанию,если массив не имеет фиксированного размера:</target>
        </trans-unit>
        <trans-unit id="555bba9fd6c14d06717b8dc43b3cc1f3a8debed5" translate="yes" xml:space="preserve">
          <source>Accessing an unset entry returns default value:</source>
          <target state="translated">Доступ к невыполненной записи возвращает значение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="436be26b911d05b439e447f05501826f189bbbef" translate="yes" xml:space="preserve">
          <source>According to good practices certificates should not use IP-addresses as &quot;server names&quot;. It would be very surprising if this happen outside a closed network.</source>
          <target state="translated">В соответствии с надлежащей практикой сертификаты не должны использовать IP-адреса в качестве &quot;имен серверов&quot;.Было бы очень удивительно,если бы это происходило за пределами закрытой сети.</target>
        </trans-unit>
        <trans-unit id="89a4478d0cf104e90423519324b8b69d771bbee7" translate="yes" xml:space="preserve">
          <source>According to the myth, using a tail-recursive function that builds a list in reverse followed by a call to &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; is faster than a body-recursive function that builds the list in correct order; the reason being that body-recursive functions use more memory than tail-recursive functions.</source>
          <target state="translated">Согласно мифу, использование хвостовой рекурсивной функции, которая создает список в обратном порядке, с последующим вызовом &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; быстрее, чем основная рекурсивная функция, которая строит список в правильном порядке; Причина в том, что функции с основной рекурсией используют больше памяти, чем функции с хвостовой рекурсией.</target>
        </trans-unit>
        <trans-unit id="2c1de79f36acb95726c8b2c2f40931be25c53188" translate="yes" xml:space="preserve">
          <source>Accounting</source>
          <target state="translated">Accounting</target>
        </trans-unit>
        <trans-unit id="576eaeceb1da93e9cd8653f97cabbf793c67007b" translate="yes" xml:space="preserve">
          <source>Accounting AVP Table</source>
          <target state="translated">Бухгалтерская таблица АВП</target>
        </trans-unit>
        <trans-unit id="76507b1aa8142b5faffaa0f07c625ec43966a2b9" translate="yes" xml:space="preserve">
          <source>Accounting AVPs</source>
          <target state="translated">АВП по бухгалтерскому учету</target>
        </trans-unit>
        <trans-unit id="9a7ff18e07e31b5c000920070a2994c9d40115bb" translate="yes" xml:space="preserve">
          <source>Accounting Application Extension and Requirements</source>
          <target state="translated">Продление срока действия и требования к бухгалтерским приложениям</target>
        </trans-unit>
        <trans-unit id="e635c0e384e30717aefe63c449ad41cb13b32539" translate="yes" xml:space="preserve">
          <source>Accounting Command Codes</source>
          <target state="translated">Командные коды бухгалтерского учёта</target>
        </trans-unit>
        <trans-unit id="50de3db981430abf69687c31bfddbc582f239b78" translate="yes" xml:space="preserve">
          <source>Accounting Records</source>
          <target state="translated">Бухгалтерская документация</target>
        </trans-unit>
        <trans-unit id="44b909aba948aa304a039b3c325904ad3054b180" translate="yes" xml:space="preserve">
          <source>Accounting Session State Machine</source>
          <target state="translated">Бухгалтерская сессия Государственная машина</target>
        </trans-unit>
        <trans-unit id="c15004aaef4f7a17d065e02f132efa0a95238fb5" translate="yes" xml:space="preserve">
          <source>Accounting is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">Бухгалтерский учет является обязанностью пользователя:диаметр не реализует эту государственную машину.</target>
        </trans-unit>
        <trans-unit id="3abb791315e4021643390d032dcd3ee861202b30" translate="yes" xml:space="preserve">
          <source>Accounting-Answer</source>
          <target state="translated">Accounting-Answer</target>
        </trans-unit>
        <trans-unit id="348fbc285b20d73c4251ffc831b8fc2daa3046c1" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP</source>
          <target state="translated">Учет-Реальное время-Требуется AVP</target>
        </trans-unit>
        <trans-unit id="4913676d8f98f760d1dc436d2423796cf2783306" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP Values</source>
          <target state="translated">Учет-Реальное время-Приобретенные значения AVP</target>
        </trans-unit>
        <trans-unit id="a41e3ac9cf5023d32cd91b4a3e716042b6c367b5" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Number AVP</source>
          <target state="translated">Учетная запись-учетная запись-номер AVP</target>
        </trans-unit>
        <trans-unit id="b804c4b652a1521f5cb9135277fefe013043b5f6" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP</source>
          <target state="translated">Учетная запись-видеозапись-AVP</target>
        </trans-unit>
        <trans-unit id="8df79aebdffebcd5564a4906eb6116d78fd976e9" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP Values</source>
          <target state="translated">Учетная запись-Тип записи-Значения AVP</target>
        </trans-unit>
        <trans-unit id="3f4954249bb9c6c0d9946303733718179dac9afc" translate="yes" xml:space="preserve">
          <source>Accounting-Request</source>
          <target state="translated">Accounting-Request</target>
        </trans-unit>
        <trans-unit id="cb2f33108011b0c4743b447ccd4a9acfb53d2777" translate="yes" xml:space="preserve">
          <source>Accounting-Sub-Session-Id AVP</source>
          <target state="translated">Бухгалтерия-Суб-сессия-Ид AVP</target>
        </trans-unit>
        <trans-unit id="356f92ff6ca6eed8d6a653c61fd409eb10ae68df" translate="yes" xml:space="preserve">
          <source>Accounting-related messages and AVPs are defined in provided dictionaries. Their proper use is the user's responsibility.</source>
          <target state="translated">Сообщения,связанные с учетными записями и AVP,определяются в предоставляемых словарях.Ответственность за их правильное использование лежит на пользователе.</target>
        </trans-unit>
        <trans-unit id="4b31db96c0a841f9a7113ac5bbc52a214e1829fa" translate="yes" xml:space="preserve">
          <source>Acct-Application-Id AVP</source>
          <target state="translated">Акт-приложение-Ид AVP</target>
        </trans-unit>
        <trans-unit id="4cabe3c0597d0d6af37709b22cdb0a59a5dae54e" translate="yes" xml:space="preserve">
          <source>Acct-Interim-Interval AVP</source>
          <target state="translated">Acct Interim Interval AVP</target>
        </trans-unit>
        <trans-unit id="1e0b1bf1afd755a9ceed94d413ee8713ddf31cc4" translate="yes" xml:space="preserve">
          <source>Acct-Multi-Session-Id AVP</source>
          <target state="translated">Акт-Мульти-Сессия-Ид AVP</target>
        </trans-unit>
        <trans-unit id="73a3b6a3e03bc80ba04f6bde167f6434da42cc10" translate="yes" xml:space="preserve">
          <source>Acct-Session-Id AVP</source>
          <target state="translated">АВП-аккаунт-сессия</target>
        </trans-unit>
        <trans-unit id="1a968060d9b2a6b964d729cfbd1eea55cfdc2c19" translate="yes" xml:space="preserve">
          <source>Accumulated waiting time for this lock. This could be greater than actual wall clock time, it is accumulated for all threads. Trylock conflicts does not accumulate time.</source>
          <target state="translated">Накопленное время ожидания этого замка.Это может быть больше,чем фактическое время настенных часов,оно накапливается для всех нитей.Конфликты трилока не накапливают время.</target>
        </trans-unit>
        <trans-unit id="d9ecd9efddc0ef5836c8bbbde646a0d66732f097" translate="yes" xml:space="preserve">
          <source>Accumulates cover results over multiple tests. See section &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; in the Users's Guide.</source>
          <target state="translated">Накапливает результаты покрытия за несколько тестов. См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="be2701277b8bc3bbce61a03a361606bf878d1187" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Точность и точность &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="875e7dcdc327d43caf0dcdf9d04b310d14d9feaf" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Точность и точность &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58eae709361b11b3ca7bd3fc358b5d94391cf26b" translate="yes" xml:space="preserve">
          <source>Acknowledges the start of the port.</source>
          <target state="translated">Подтверждает начало работы порта.</target>
        </trans-unit>
        <trans-unit id="788233b34a130f2756fb1eaafa64431bb5c3d2da" translate="yes" xml:space="preserve">
          <source>Acknowledgment of a successful TLS handshake. &lt;code&gt;Ref&lt;/code&gt; is the reference() received in the &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; message in response to which the reply is sent. A transport must exit if a handshake is not successful.</source>
          <target state="translated">Подтверждение успешного установления связи TLS. &lt;code&gt;Ref&lt;/code&gt; - это ссылка (), полученная в сообщении &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; в ответ на которое отправляется ответ. Транспорт должен выйти, если рукопожатие не удалось.</target>
        </trans-unit>
        <trans-unit id="f975f613537adf39477a68ad11e1dc4894dd6870" translate="yes" xml:space="preserve">
          <source>Action Mappings</source>
          <target state="translated">Картины действий</target>
        </trans-unit>
        <trans-unit id="2440fec108b517d1d709ba90c75d4f7a63c7e81f" translate="yes" xml:space="preserve">
          <source>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...}</source>
          <target state="translated">ActionCall ::={ActionFunction}| {ActionFunction,ActionTerm,...}</target>
        </trans-unit>
        <trans-unit id="5590c86022b5bc14c1ea74cf910bca92aa274578" translate="yes" xml:space="preserve">
          <source>ActionFunction ::= &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</source>
          <target state="translated">ActionFunction :: = &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51c493fd8bfe5291ac344e060529e5b42558f385" translate="yes" xml:space="preserve">
          <source>ActionTerm ::= ConditionExpression | ActionCall</source>
          <target state="translated">ActionTerm ::=ConditionExpression | ActionCall</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="89ff6dbfdb936ca69e6587ae4d22e9a120904bf2" translate="yes" xml:space="preserve">
          <source>Actions :: [&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">Действия :: [ &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="61334da16104ac9d91a8736e913a8cbee03e40e6" translate="yes" xml:space="preserve">
          <source>Actions are executed in the containing list order.</source>
          <target state="translated">Действия выполняются в содержащем список порядке.</target>
        </trans-unit>
        <trans-unit id="4975204a056c5025b62a4a29c1e32e8f3dc531af" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition options &lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef0f3b4c93f31bddb43b327dd452b51df2f0936" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;event_timeout()&lt;/code&gt; in the list.</source>
          <target state="translated">Действия, устанавливающие &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; приоритет над любыми предыдущими действиями того же типа, поэтому побеждает последнее в содержащем списке. Например, последний &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; отменяет любое предыдущее &lt;code&gt;event_timeout()&lt;/code&gt; в списке.</target>
        </trans-unit>
        <trans-unit id="b1964869d062538b54d1a15f6f4171d706fef3d8" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="translated">Действия, устанавливающие &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; приоритет над любыми предыдущими действиями того же типа, поэтому побеждает последнее в содержащем списке. Например, последний &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; отменяет любой предыдущий &lt;code&gt;postpone()&lt;/code&gt; в списке.</target>
        </trans-unit>
        <trans-unit id="13b1df2d40bde8a02c4921e1004b0065de68e10c" translate="yes" xml:space="preserve">
          <source>Activates a connection to a remote user. When this is done the connection can be used to send messages (with SendMod:send_message/2). The ControlPid is the identifier of a process that controls the connection. That process will be supervised and if it dies, this will be detected and the UserMod:handle_disconnect/2 callback function will be invoked. See the megaco_user module for more info about the callback arguments. The connection may also explicitly be deactivated by invoking megaco:disconnect/2.</source>
          <target state="translated">Активирует соединение с удаленным пользователем.После этого соединение может быть использовано для отправки сообщений (с помощью SendMod:send_message/2).ControlPid-это идентификатор процесса,который управляет соединением.Этот процесс будет контролироваться,и в случае его умирания,он будет обнаружен,и будет вызвана функция UserMod:handle_disconnect/2.Дополнительную информацию об аргументах обратного вызова смотрите в модуле megaco_user.Соединение также может быть явно деактивировано вызовом megaco:disconnect/2.</target>
        </trans-unit>
        <trans-unit id="f69ba29b1f84217c9d2ca2dc152317da71e06308" translate="yes" xml:space="preserve">
          <source>Activates a new checkpoint covering all Mnesia tables, including the schema, with maximum degree of redundancy, and performs a backup using &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt;. The default value of the backup callback module &lt;code&gt;BackupMod&lt;/code&gt; is obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;.</source>
          <target state="translated">Активирует новую контрольную точку, охватывающую все таблицы Mnesia, включая схему, с максимальной степенью избыточности, и выполняет резервное копирование с помощью &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt; . Значение по умолчанию для модуля обратного вызова резервного копирования &lt;code&gt;BackupMod&lt;/code&gt; получается с помощью &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0574212bd6baf73e32ac9c415b72677146bade9b" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates on all &lt;code&gt;Mnesia&lt;/code&gt; tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">Активирует все события на уровне отладки. На этом уровне обработчик событий &lt;code&gt;Mnesia&lt;/code&gt; начинает подписываться на обновления всех таблиц &lt;code&gt;Mnesia&lt;/code&gt; . Этот уровень предназначен только для отладки небольших игрушечных систем, так как может быть сгенерировано много крупных событий.</target>
        </trans-unit>
        <trans-unit id="1473502b15ef43d2fc312f7968ec2627f8afe701" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the Mnesia event handler starts subscribing to updates on all Mnesia tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">Активирует все события на уровне отладки.На этом уровне обработчик событий Mnesia начинает подписываться на обновления во всех таблицах Mnesia.Этот уровень предназначен только для отладки небольших игрушечных систем,так как может генерироваться много больших событий.</target>
        </trans-unit>
        <trans-unit id="a11fef95fdd152ac782e603cddf000bf9537358d" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus full trace of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler. On this debug level, the Mnesia event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">Активирует все события на подробном уровне плюс полную трассировку всех событий отладки. Эти события отладки генерируют &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; события {mnesia_info, Format, Args} . Процессы могут подписаться на эти события с помощью &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; . События всегда отправляются в обработчик событий Mnesia. На этом уровне отладки обработчик событий Mnesia начинает подписываться на обновления в таблице схемы.</target>
        </trans-unit>
        <trans-unit id="d10f11346b4f9c94838ab97da164ecb5b326c009" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus traces of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler. On this debug level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">Активирует все события на подробном уровне плюс трассировки всех событий отладки. Эти события отладки генерируют &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; события {mnesia_info, Format, Args} . Процессы могут подписаться на эти события с помощью &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; . События всегда отправляются в обработчик событий &lt;code&gt;Mnesia&lt;/code&gt; . На этом уровне отладки обработчик событий &lt;code&gt;Mnesia&lt;/code&gt; начинает подписываться на обновления в таблице схемы.</target>
        </trans-unit>
        <trans-unit id="6ded0de3f180c32378392899db72b086ca5f1741" translate="yes" xml:space="preserve">
          <source>Activates read data buffering. If &lt;code&gt;read/2&lt;/code&gt; calls are for significantly less than &lt;code&gt;Size&lt;/code&gt; bytes, read operations to the operating system are still performed for blocks of &lt;code&gt;Size&lt;/code&gt; bytes. The extra data is buffered and returned in subsequent &lt;code&gt;read/2&lt;/code&gt; calls, giving a performance gain as the number of operating system calls is reduced.</source>
          <target state="translated">Активирует буферизацию считываемых данных. Если вызовы &lt;code&gt;read/2&lt;/code&gt; предназначены для значительно меньших, чем &lt;code&gt;Size&lt;/code&gt; байтов, операции чтения в операционной системе по-прежнему выполняются для блоков &lt;code&gt;Size&lt;/code&gt; байтов. Дополнительные данные буферизуются и возвращаются в последующих вызовах &lt;code&gt;read/2&lt;/code&gt; , что дает прирост производительности по мере уменьшения количества вызовов операционной системы.</target>
        </trans-unit>
        <trans-unit id="eb6a9b28d658257a2883ec371985ebb9360570ed" translate="yes" xml:space="preserve">
          <source>Activates the fragmentation properties of an existing table. &lt;code&gt;FragProps&lt;/code&gt; is either to contain &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; or be empty.</source>
          <target state="translated">Активирует свойства фрагментации существующей таблицы. &lt;code&gt;FragProps&lt;/code&gt; должен либо содержать &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; либо быть пустым.</target>
        </trans-unit>
        <trans-unit id="532f0aa046ec26e3e6682e682916731e989482e8" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler.</source>
          <target state="translated">Активирует отслеживание важных событий отладки. Эти события генерируют &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; события {mnesia_info, Format, Args} . Процессы могут подписаться на эти события с помощью &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; . События всегда отправляются в обработчик событий Mnesia.</target>
        </trans-unit>
        <trans-unit id="e0f95d91404d34111854383ce61fa17d9871d976" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler.</source>
          <target state="translated">Активирует отслеживание важных событий отладки. Эти события генерируют &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; события {mnesia_info, Format, Args} . Процессы могут подписаться на эти события с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; . События всегда отправляются в обработчик событий &lt;code&gt;Mnesia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f2c331b898e66e4e4d774932df99c6432852c98" translate="yes" xml:space="preserve">
          <source>Activates/deactivates tracing by changing the current trace pattern.</source>
          <target state="translated">Активирует/отключает трассировку,изменяя текущий шаблон трассы.</target>
        </trans-unit>
        <trans-unit id="29f45195e4be19fb8b96702dcdd15944ea37fdad" translate="yes" xml:space="preserve">
          <source>Active breakpoints are displayed in red and inactive breakpoints in blue.</source>
          <target state="translated">Активные точки останова отображаются красным цветом,а неактивные-синим.</target>
        </trans-unit>
        <trans-unit id="2ec1ddc09f5f20f205f66ac493ee50b1fd7b2567" translate="yes" xml:space="preserve">
          <source>Activity Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a903c4b66a2fb224f4d96a51df759ac9a67bfc6d" translate="yes" xml:space="preserve">
          <source>Activity concept and various access contexts</source>
          <target state="translated">Концепция деятельности и различные условия доступа</target>
        </trans-unit>
        <trans-unit id="713a8072ef62aa0b1fde6095af47e4a910316756" translate="yes" xml:space="preserve">
          <source>Actual protocol version.</source>
          <target state="translated">Текущая версия протокола.</target>
        </trans-unit>
        <trans-unit id="c3e87cfb1bb3f9be88098c653af2df64757bc8b0" translate="yes" xml:space="preserve">
          <source>Actual ticket age shall be less than the ticket lifetime (stateless session tickets contain the servers timestamp when the ticket was issued).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91282b72e27e9203f0008e0bb427b78168c9ee89" translate="yes" xml:space="preserve">
          <source>Add 'makensis.exe' to your path environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134344cda8fb9734c656b66e40554d208ac6e58b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;-ct_hooks&lt;/code&gt; as an argument to &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;. To add multiple CTHs using this method, append them to each other using the keyword &lt;code&gt;and&lt;/code&gt;, that is, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt;.</source>
          <target state="translated">Добавьте &lt;code&gt;-ct_hooks&lt;/code&gt; в качестве аргумента в &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; . Чтобы добавить несколько CTHs , используя этот метод, добавьте их друг с другом , используя ключевое слово &lt;code&gt;and&lt;/code&gt; , то есть, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c736205df679d1eb6863a5f647010553ce017bf9" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Incr&lt;/code&gt; to atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03f5ebcb056f1a256b52c0c938b58b71f342864" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Incr&lt;/code&gt; to counter at index &lt;code&gt;Ix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8718d4f36d948a3675c6bdc12db7b8c27966873" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;return_trace&lt;/code&gt; message if the function is of arity 3:</source>
          <target state="translated">Добавьте сообщение &lt;code&gt;return_trace&lt;/code&gt; , если функция имеет арность 3:</target>
        </trans-unit>
        <trans-unit id="dcfe51c34611d10c0d112932679c857d2a6476fa" translate="yes" xml:space="preserve">
          <source>Add a filter to the specified handler.</source>
          <target state="translated">Добавьте фильтр в указанный обработчик.</target>
        </trans-unit>
        <trans-unit id="95b618e55bafddbb2a2984de23f6ce57bb36d2c0" translate="yes" xml:space="preserve">
          <source>Add a handler that prints &lt;code&gt;debug&lt;/code&gt; log events to a file, while the default handler prints only up to &lt;code&gt;notice&lt;/code&gt; level events to standard out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988a7e297bf981c7e71c06b09b7717bd00d611be" translate="yes" xml:space="preserve">
          <source>Add a handler with the given configuration.</source>
          <target state="translated">Добавьте обработчик с заданной конфигурацией.</target>
        </trans-unit>
        <trans-unit id="07e4c199b9f19567f7bbd64299d17b2cc8c094ac" translate="yes" xml:space="preserve">
          <source>Add a primary filter to Logger.</source>
          <target state="translated">Добавить первичный фильтр в журнал.</target>
        </trans-unit>
        <trans-unit id="1970f7a8e650aa5473c699a8c07cc9a162ef1004" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the primary nameserver to use for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">Добавьте адрес (и порт, если он &lt;code&gt;inet_res(3)&lt;/code&gt; от значения по умолчанию) основного сервера имен, который будет использоваться для inet_res (3) .</target>
        </trans-unit>
        <trans-unit id="1cfc1bd9fd579f7622617b9af78a944445ba8847" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the secondary nameserver for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">Добавьте адрес (и порт, если не по умолчанию) вторичного сервера имен для &lt;code&gt;inet_res(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8a12963c05fa3aec6cf7012ff1f7fc0a2d99e08" translate="yes" xml:space="preserve">
          <source>Add an entry. The entry must not exist.</source>
          <target state="translated">Добавь запись.Запись не должна существовать.</target>
        </trans-unit>
        <trans-unit id="6652a41804b950794ec5752c7d6fd942b05025cf" translate="yes" xml:space="preserve">
          <source>Add file and line number to log entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e310729251dbd2e2aab36a457e446b150b20e5e" translate="yes" xml:space="preserve">
          <source>Add host entry to the hosts table.</source>
          <target state="translated">Добавьте запись о хосте в таблицу хостов.</target>
        </trans-unit>
        <trans-unit id="064eb4472489455e1a24510aa444bd6d5e585d65" translate="yes" xml:space="preserve">
          <source>Add javac &lt;strong&gt;LAST&lt;/strong&gt; to your path environment in bash, in my case this means:</source>
          <target state="translated">Добавьте javac &lt;strong&gt;LAST&lt;/strong&gt; в среду вашего пути в bash, в моем случае это означает:</target>
        </trans-unit>
        <trans-unit id="246e6fb32e5a050387dbde2f21177185267ea2d6" translate="yes" xml:space="preserve">
          <source>Add javac to your path environment, in my case this means:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0bb0d661a36f1c95bc663da03400bb07c43351" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">Добавьте или обновите данные конфигурации для указанного обработчика. Если данный &lt;code&gt;Key&lt;/code&gt; уже существует, связанное с ним значение будет изменено на &lt;code&gt;Value&lt;/code&gt; . Если его не существует, он будет добавлен.</target>
        </trans-unit>
        <trans-unit id="7bc4a78cb8fcc809731f59f9c373269672f429fa" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to the given value. If it does not exist, it will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e23ac8cf9bd396ad94605da91fe04cfdf9b6acd" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">Добавьте или обновите данные первичной конфигурации для Logger. Если данный &lt;code&gt;Key&lt;/code&gt; уже существует, связанное с ним значение будет изменено на &lt;code&gt;Value&lt;/code&gt; . Если его не существует, он будет добавлен.</target>
        </trans-unit>
        <trans-unit id="21e8ff5c385c237ae3065c84dd8d4d8e0844640c" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to the given value. If it does not exist, it will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1f218791abec296d536eef9aee8fee9c4907e8" translate="yes" xml:space="preserve">
          <source>Add search domains for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">Добавьте поисковые домены для &lt;code&gt;inet_res(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ed69d0e5ae060c18a4527cc0780a8f4a4070ca5" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt; Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1016b584a0c08284e356371e0b67d2c6544a4a" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавьте тег &lt;code&gt;ct_hooks&lt;/code&gt; в свою &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62bfcf8bed94dcc27f1ebd702bd7df63f5908679" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your call to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавьте тег &lt;code&gt;ct_hooks&lt;/code&gt; к вашему вызову в &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb8bd196c7c5b5791600663f12d69529068e2cf5" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;{scanner, flex}&lt;/code&gt; (or similar) directive to an Erlang system config file for the megaco app (see &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; chapter for details).</source>
          <target state="translated">Добавьте директиву &lt;code&gt;{scanner, flex}&lt;/code&gt; (или аналогичную) в системный файл конфигурации Erlang для приложения megaco (подробности см. В главе о &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a2012ba10173073b8d6e03fc90ee362531d7db30" translate="yes" xml:space="preserve">
          <source>Add the applications Crypto, Public Key, and SSL with their current version numbers after the STDLIB application.</source>
          <target state="translated">После приложения STDLIB добавьте приложения Crypto,Public Key и SSL с их номерами текущей версии.</target>
        </trans-unit>
        <trans-unit id="3f47e924c15f0cebe23f7a60a12208b6f3fe188b" translate="yes" xml:space="preserve">
          <source>Add the engine to OpenSSL's internal list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1eaff143827738e997da2b572220e89eec79fb" translate="yes" xml:space="preserve">
          <source>Add the filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf34fb9a5fda73afda9f1d571b702839ff2f58b3" translate="yes" xml:space="preserve">
          <source>Add the following directive to the module:</source>
          <target state="translated">Добавьте в модуль следующую директиву:</target>
        </trans-unit>
        <trans-unit id="497564ebabd956c895ba8a4ea1a4bb25e8ed7093" translate="yes" xml:space="preserve">
          <source>Add transport capability to a service.</source>
          <target state="translated">Добавьте транспортную возможность к услуге.</target>
        </trans-unit>
        <trans-unit id="ae43487688376dc95ae859ba01f32a0ade700fa9" translate="yes" xml:space="preserve">
          <source>Add-On Application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34d04c7e63a5b637ab5047d8987b49d86783a46" translate="yes" xml:space="preserve">
          <source>Added in OTP 23.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83212da8655f0855cd75f303dd85d4cf0dc4e2d" translate="yes" xml:space="preserve">
          <source>Adding Own Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a12811718bf0eb0d5f20cc44584c455597c9de0" translate="yes" xml:space="preserve">
          <source>Adding Patches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1377afcaa6077fc60c3ef67a50fc7f61a7ad112" translate="yes" xml:space="preserve">
          <source>Adding Records and Relationships to Database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ba7777616ece673914dfbc3af9096a68b87e29" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using &lt;code&gt;add_module&lt;/code&gt;.</source>
          <target state="translated">Добавление приложения означает, что модули, определенные ключом &lt;code&gt;modules&lt;/code&gt; в файле &lt;code&gt;.app&lt;/code&gt; , загружаются с помощью &lt;code&gt;add_module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19baa62e86ec3c161512eb728cf268b6e381fb8a" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using a number of &lt;code&gt;add_module&lt;/code&gt; instructions, and then the application is started.</source>
          <target state="translated">Добавление приложения означает, что модули, определенные ключом &lt;code&gt;modules&lt;/code&gt; в файле &lt;code&gt;.app&lt;/code&gt; , загружаются с использованием ряда инструкций &lt;code&gt;add_module&lt;/code&gt; , а затем приложение запускается.</target>
        </trans-unit>
        <trans-unit id="6dd28665b92c3d1eafe29d80d8f4b9041dfdeca0" translate="yes" xml:space="preserve">
          <source>Adding and Deleting Child Processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2fed64edcf79517387cddb884610573fd90ba1" translate="yes" xml:space="preserve">
          <source>Adding patches</source>
          <target state="translated">Добавление патчей</target>
        </trans-unit>
        <trans-unit id="9aa3df6db85161c52e69b8f34d6e3268949dc0a1" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;fop&lt;/code&gt; script (in &lt;code&gt;$FOP_HOME&lt;/code&gt;) to your &lt;code&gt;$PATH&lt;/code&gt;, either by adding &lt;code&gt;$FOP_HOME&lt;/code&gt; to &lt;code&gt;$PATH&lt;/code&gt;, or by copying the &lt;code&gt;fop&lt;/code&gt; script to a directory already in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">Добавление &lt;code&gt;fop&lt;/code&gt; сценария (в &lt;code&gt;$FOP_HOME&lt;/code&gt; ) на свой &lt;code&gt;$PATH&lt;/code&gt; , либо путем добавления &lt;code&gt;$FOP_HOME&lt;/code&gt; в &lt;code&gt;$PATH&lt;/code&gt; , или путем копирования &lt;code&gt;fop&lt;/code&gt; скрипт в каталог уже в вашей &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38751bf8e4b616e26910db8b22c357a8c20a53f2" translate="yes" xml:space="preserve">
          <source>Adding the location of your installation of &lt;code&gt;fop&lt;/code&gt; in &lt;code&gt;$FOP_HOME&lt;/code&gt;.</source>
          <target state="translated">Добавление расположения вашей установки &lt;code&gt;fop&lt;/code&gt; в &lt;code&gt;$FOP_HOME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab0b27d891b1318285ee4899ad6b140de6e4ed3b" translate="yes" xml:space="preserve">
          <source>Additional information and links of interest for Erlang programmers can be found on the Erlang Open Source site &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt;.</source>
          <target state="translated">Дополнительную информацию и ссылки, представляющие интерес для программистов на Erlang, можно найти на сайте Erlang Open Source &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6afdeb8447e9059c599becedc9101b844f957850" translate="yes" xml:space="preserve">
          <source>Additionally, values that can be encoded are limited by way of their encoding as four octets as required by RFC 6733 with the required extension from RFC 2030. In particular, only values between &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; and &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (both inclusive) can be encoded.</source>
          <target state="translated">Кроме того, значения, которые могут быть закодированы, ограничены путем их кодирования четырьмя октетами, как того требует RFC 6733 с необходимым расширением из RFC 2030. В частности, только значения между &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; и &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (оба включительно) могут быть закодированы.</target>
        </trans-unit>
        <trans-unit id="cb4f94d5cabe0fc39f4035959e69499b50e9e3b2" translate="yes" xml:space="preserve">
          <source>Address-to-name translation in a protocol-independant manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fda4b3ec4ffdc7738f6833bc3191a5b59bbcea" translate="yes" xml:space="preserve">
          <source>Addresses as inputs to functions can be either a string or a tuple. For example, the IP address 150.236.20.73 can be passed to &lt;code&gt;gethostbyaddr/1&lt;/code&gt;, either as string &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; or as tuple &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt;.</source>
          <target state="translated">Адреса в качестве входных данных для функций могут быть строкой или кортежем. Например, IP-адрес 150.236.20.73 может быть передан в &lt;code&gt;gethostbyaddr/1&lt;/code&gt; либо как строка &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; либо как кортеж &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6ffba73db48bc15c7ed64cbfce1198067c6f6ff" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt; ip_address() &lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt; local_address(). &lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919ffc168cee16019d09aa5279148893d8d24a34" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="translated">Адреса, помимо &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; , которые возвращаются функциями API сокета. См., В частности, &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; Семейство &lt;code&gt;unspec&lt;/code&gt; соответствует AF_UNSPEC и может возникнуть, если на другой стороне нет адреса сокета. &lt;code&gt;undefined&lt;/code&gt; семья может иметь место только в том маловероятном случае семейства адресов , что VM не признает.</target>
        </trans-unit>
        <trans-unit id="e5d78a2b44c9f8c46bb6a05a403783dea60e8b77" translate="yes" xml:space="preserve">
          <source>Addresses to the test plant or other instruments</source>
          <target state="translated">Адреса к испытательной установке или другим приборам</target>
        </trans-unit>
        <trans-unit id="e2dc16d39802f8e13757680f2285e270d512d4d0" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. If &lt;code&gt;Dir&lt;/code&gt; exists, it is removed from the old position in the code path.</source>
          <target state="translated">Добавляет &lt;code&gt;Dir&lt;/code&gt; в начало пути кода. Если &lt;code&gt;Dir&lt;/code&gt; существует, он удаляется из старой позиции в пути кода.</target>
        </trans-unit>
        <trans-unit id="926f262a813d5bf3968371cfef08e827663b2a16" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the code path. The directory is added as the last directory in the new path. If &lt;code&gt;Dir&lt;/code&gt; already exists in the path, it is not added.</source>
          <target state="translated">Добавляет &lt;code&gt;Dir&lt;/code&gt; в путь кода. Каталог будет добавлен в качестве последнего каталога в новый путь. Если &lt;code&gt;Dir&lt;/code&gt; уже существует в пути, он не добавляется.</target>
        </trans-unit>
        <trans-unit id="ca41b9b5a14be7cc19bac8bafe3b381efcc40caa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the list of directories to be searched when including a file. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">Добавляет &lt;code&gt;Dir&lt;/code&gt; в список каталогов для поиска при включении файла. При обнаружении директивы &lt;code&gt;-include&lt;/code&gt; или &lt;code&gt;-include_lib&lt;/code&gt; компилятор ищет файлы заголовков в следующих каталогах:</target>
        </trans-unit>
        <trans-unit id="5307e57c8c5d61db386c45a450b3023f9b59e82e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;IncludeDir&lt;/code&gt; to the search-path for &lt;code&gt;.asn1db&lt;/code&gt; and &lt;code&gt;ASN.1&lt;/code&gt; source files. The compiler tries to open an &lt;code&gt;.asn1db&lt;/code&gt; file when a module imports definitions from another &lt;code&gt;ASN.1&lt;/code&gt; module. If no &lt;code&gt;.asn1db&lt;/code&gt; file is found, the &lt;code&gt;ASN.1&lt;/code&gt; source file is parsed. Several &lt;code&gt;{i, IncludeDir}&lt;/code&gt; can be given.</source>
          <target state="translated">Добавляет &lt;code&gt;IncludeDir&lt;/code&gt; в путь &lt;code&gt;.asn1db&lt;/code&gt; исходных файлов .asn1db и &lt;code&gt;ASN.1&lt;/code&gt; . Компилятор пытается открыть файл &lt;code&gt;.asn1db&lt;/code&gt; , когда модуль импортирует определения из другого модуля &lt;code&gt;ASN.1&lt;/code&gt; . Если файл &lt;code&gt;.asn1db&lt;/code&gt; не найден, анализируется исходный файл &lt;code&gt;ASN.1&lt;/code&gt; . Можно &lt;code&gt;{i, IncludeDir}&lt;/code&gt; несколько {i, IncludeDir} .</target>
        </trans-unit>
        <trans-unit id="595c4b05c70f5ee3afd4c0ee71bd2a9507a8d8e9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and store this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">Добавляет &lt;code&gt;Increment&lt;/code&gt; к значению, связанному с &lt;code&gt;Key&lt;/code&gt; и сохраняет это значение. Если &lt;code&gt;Key&lt;/code&gt; отсутствует в словаре, &lt;code&gt;Increment&lt;/code&gt; сохраняется как первое значение.</target>
        </trans-unit>
        <trans-unit id="9cf5a5933a7780d09616786318d8b162063b8502" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and stores this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">Добавляет &lt;code&gt;Increment&lt;/code&gt; к значению, связанному с &lt;code&gt;Key&lt;/code&gt; и сохраняет это значение. Если &lt;code&gt;Key&lt;/code&gt; отсутствует в словаре, &lt;code&gt;Increment&lt;/code&gt; сохраняется как первое значение.</target>
        </trans-unit>
        <trans-unit id="608d4ac3b1f40dea43a70f3ee04cd69ef181057c" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;Slave&lt;/code&gt; node to the list of allowed slave hosts.</source>
          <target state="translated">Добавляет &lt;code&gt;Slave&lt;/code&gt; узел в список разрешенных ведомых хостов.</target>
        </trans-unit>
        <trans-unit id="c8419b1c93b9fd6c91cbede4425bbc8634cca3f1" translate="yes" xml:space="preserve">
          <source>Adds a USM security data (user) to the agent config. Equivalent to one line in the &lt;code&gt;usm.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет данные безопасности USM (пользователя) в конфигурацию агента. Эквивалентно одной строке в файле &lt;code&gt;usm.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="608718b6fe3ec7101404f6c3f283054c442dd2b4" translate="yes" xml:space="preserve">
          <source>Adds a access definition to the agent config. Equivalent to one vacmAccess-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет определение доступа в конфигурацию агента. Эквивалентно одной строке &lt;code&gt;vacm.conf&lt;/code&gt; файле vacm.conf .</target>
        </trans-unit>
        <trans-unit id="56be82c63eeffefdb9fecc96c8582dde485169c1" translate="yes" xml:space="preserve">
          <source>Adds a comment to the zip archive.</source>
          <target state="translated">Добавляет комментарий к zip архиву.</target>
        </trans-unit>
        <trans-unit id="43e098c039b116cd95896a1756a343c44df7c071" translate="yes" xml:space="preserve">
          <source>Adds a community to the agent config. Equivalent to one line in the &lt;code&gt;community.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет сообщество в конфигурацию агента. Эквивалентно одной строке в файле &lt;code&gt;community.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45955c71ab38b246ddf99aa7e08be1cf306c82b3" translate="yes" xml:space="preserve">
          <source>Adds a context to the agent config. Equivalent to one line in the &lt;code&gt;context.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет контекст в конфигурацию агента. Эквивалентно одной строке в файле &lt;code&gt;context.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c32cf7ccbd49be4e1811292b2c307f4eba42f61" translate="yes" xml:space="preserve">
          <source>Adds a driver entry to the list of drivers known by Erlang. The &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; function of parameter &lt;code&gt;de&lt;/code&gt; is called.</source>
          <target state="translated">Добавляет запись драйвера в список драйверов, известных Erlang. &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; функция параметра &lt;code&gt;de&lt;/code&gt; называется.</target>
        </trans-unit>
        <trans-unit id="d07970fe182b9d81897e40e78d3b14e7a4e7a0d7" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавляет файл в tar-файл, открытый для записи командой &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2fca474d01b00ce9ba861cfe769df64577ac35b" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;. This function accepts the same options as &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавляет файл в tar-файл, который был открыт для записи командой &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; . Эта функция принимает те же параметры, что и &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eccbecba42ae4288806c579ad8b8fbf3b51a728" translate="yes" xml:space="preserve">
          <source>Adds a fragment to a fragmented table. All records in one of the old fragments are rehashed and about half of them are moved to the new (last) fragment. All other fragmented tables, which refer to this table in their foreign key, automatically get a new fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</source>
          <target state="translated">Добавляет фрагмент к фрагментированной таблице.Все записи в одном из старых фрагментов перефрагментированы и примерно половина из них перенесена в новый (последний)фрагмент.Все остальные фрагментированные таблицы,которые ссылаются на эту таблицу в своем постороннем ключе,автоматически получают новый фрагмент.Кроме того,их записи динамически перефразируются так же,как и для основной таблицы.</target>
        </trans-unit>
        <trans-unit id="d84d2fb93ae834309e6167a0b3e43d9fab2545e1" translate="yes" xml:space="preserve">
          <source>Adds a host key to the set of trusted host keys.</source>
          <target state="translated">Добавляет ключ хоста к набору доверенных ключей хоста.</target>
        </trans-unit>
        <trans-unit id="2d77c18b4124fe87017036ce4362ca94cf644272" translate="yes" xml:space="preserve">
          <source>Adds a module and its &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The module will not be member of any application. Returns the name of the module.</source>
          <target state="translated">Добавляет модуль и его &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . Модуль не будет членом какого-либо приложения. Возвращает имя модуля.</target>
        </trans-unit>
        <trans-unit id="32c8a7869e19433d754f5fcd1913f72de6ee2803" translate="yes" xml:space="preserve">
          <source>Adds a new &lt;code&gt;Key&lt;/code&gt; to the process dictionary, associated with the value &lt;code&gt;Val&lt;/code&gt;, and returns &lt;code&gt;undefined&lt;/code&gt;. If &lt;code&gt;Key&lt;/code&gt; exists, the old value is deleted and replaced by &lt;code&gt;Val&lt;/code&gt;, and the function returns the old value. Example:</source>
          <target state="translated">Добавляет новый &lt;code&gt;Key&lt;/code&gt; в словарь процесса, связанный со значением &lt;code&gt;Val&lt;/code&gt; , и возвращает &lt;code&gt;undefined&lt;/code&gt; . Если &lt;code&gt;Key&lt;/code&gt; существует, старое значение удаляется и заменяется &lt;code&gt;Val&lt;/code&gt; , а функция возвращает старое значение. Пример:</target>
        </trans-unit>
        <trans-unit id="72a77907fe15211efb4ac1705211f4a6082a3750" translate="yes" xml:space="preserve">
          <source>Adds a new event handler in the same way as &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;, but also supervises the connection between the event handler and the calling process.</source>
          <target state="translated">Добавляет новый обработчик событий так же, как &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; , но также контролирует соединение между обработчиком событий и вызывающим процессом.</target>
        </trans-unit>
        <trans-unit id="e9446fd51850eeb6666eac3dc67fdb3d82b72082" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to event manager &lt;code&gt;EventMgrRef&lt;/code&gt;. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initiate the event handler and its internal state.</source>
          <target state="translated">Добавляет новый обработчик событий в диспетчер событий &lt;code&gt;EventMgrRef&lt;/code&gt; . Диспетчер событий вызывает &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; , чтобы запустить обработчик событий и его внутреннее состояние.</target>
        </trans-unit>
        <trans-unit id="be923232cecb872d45d1007a0378c8bbbe25c6cc" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to the error logger. The event handler must be implemented as a &lt;code&gt;gen_event&lt;/code&gt; callback module, see &lt;code&gt;gen_event(3)&lt;/code&gt;.</source>
          <target state="translated">Добавляет новый обработчик событий в журнал ошибок. Обработчик событий должен быть реализован как &lt;code&gt;gen_event&lt;/code&gt; обратного вызова gen_event , см. &lt;code&gt;gen_event(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346f98f933f954790f0ea34b8324039679ac74dd" translate="yes" xml:space="preserve">
          <source>Adds a node to &lt;code&gt;node_pool&lt;/code&gt;. The new node pool affects the list returned from the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Добавляет узел в &lt;code&gt;node_pool&lt;/code&gt; . Новый пул узлов влияет на список, возвращаемый функцией &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35b3eb9263608d380a272fe1f7c6c1eafd65bf84" translate="yes" xml:space="preserve">
          <source>Adds a notify definition to the agent config. Equivalent to one line in the &lt;code&gt;notify.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет определение уведомления в конфигурацию агента. Эквивалентно одной строке в файле &lt;code&gt;notify.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13890bf5b34b3baf9845e8775db87c295022c6ec" translate="yes" xml:space="preserve">
          <source>Adds a phony target for each dependency.</source>
          <target state="translated">Добавляет фальшивую цель для каждой зависимости.</target>
        </trans-unit>
        <trans-unit id="07656b9ba19395d09fa6add9f69eacc86c1efcdf" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt; enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b1ac0ca171003684f30d397e314620318042ec" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="translated">Добавляет ссылку на объект ресурса &lt;code&gt;obj&lt;/code&gt; , полученный из &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; . Каждый вызов &lt;code&gt;enif_keep_resource&lt;/code&gt; для объекта должен быть сбалансирован вызовом &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; до того, как объект будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="ac2aa5a6a26bf2accad0209a44849095d34310fd" translate="yes" xml:space="preserve">
          <source>Adds a release, the applications of the release, the modules of the applications, and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The applications will be members of the release, and the modules will be members of the applications. The default is to use the base name of the directory as release name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the release.</source>
          <target state="translated">Добавляет выпуск, приложения выпуска, модули приложений и &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; модулей модулей на &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . Приложения будут членами выпуска, а модули будут членами приложений. По умолчанию в качестве имени выпуска используется базовое имя каталога, но это можно изменить с помощью параметра &lt;code&gt;name&lt;/code&gt; . Возвращает название выпуска.</target>
        </trans-unit>
        <trans-unit id="5963e0eadddadc6570ac86b11276f6f4e83b3156" translate="yes" xml:space="preserve">
          <source>Adds a security to group definition to the agent config. Equivalent to one vacmSecurityToGroup-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет безопасность для определения группы в конфигурацию агента. Эквивалентно одной строке &lt;code&gt;vacm.conf&lt;/code&gt; файле vacm.conf .</target>
        </trans-unit>
        <trans-unit id="d4f785833568b0e86ada1e532e1405f500e20a42" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. See &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; for a more complete description.</source>
          <target state="translated">Добавляет небольшой тег к каждому выделенному блоку, который содержит основную информацию о том, что это такое и кто его выделил. Смотрите &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; для более полного описания.</target>
        </trans-unit>
        <trans-unit id="0dfd9dbecdeed6491e670fb60727a24505e80431" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. Use the &lt;code&gt;instrument&lt;/code&gt; module to inspect this information.</source>
          <target state="translated">Добавляет небольшой тег к каждому выделенному блоку, который содержит основную информацию о том, что это такое и кто его выделил. Используйте модуль &lt;code&gt;instrument&lt;/code&gt; для проверки этой информации.</target>
        </trans-unit>
        <trans-unit id="e4864b206394f8b2d7b76e4230a5c12a58cc9d0e" translate="yes" xml:space="preserve">
          <source>Adds a target address definition to the agent config. Equivalent to one line in the &lt;code&gt;target_addr.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет определение целевого адреса в конфигурацию агента. Эквивалентно одной строке в файле &lt;code&gt;target_addr.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82b2d6b8384860d53fc589e045f4515d51086799" translate="yes" xml:space="preserve">
          <source>Adds a target parameter definition to the agent config. Equivalent to one line in the &lt;code&gt;target_params.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет определение целевого параметра в конфигурацию агента. Эквивалентно одной строке в файле &lt;code&gt;target_params.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5794b16429f3c188c00edeb3043c4596518ea624" translate="yes" xml:space="preserve">
          <source>Adds a view tree family definition to the agent config. Equivalent to one vacmViewTreeFamily-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">Добавляет определение семейства дерева представлений в конфигурацию агента. Эквивалентно одной строке &lt;code&gt;vacm.conf&lt;/code&gt; файле vacm.conf .</target>
        </trans-unit>
        <trans-unit id="10d0b1e780ad0788836f31276e65ce6efb15e764" translate="yes" xml:space="preserve">
          <source>Adds an application, the modules of the application and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The modules will be members of the application. The default is to use the base name of the directory with the version removed as application name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the application.</source>
          <target state="translated">Добавляет приложение, модули приложения и &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; модулей модулей на &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . Модули будут членами приложения. По умолчанию в качестве имени приложения используется базовое имя каталога с удаленной версией, но это можно изменить с помощью параметра &lt;code&gt;name&lt;/code&gt; . Возвращает имя приложения.</target>
        </trans-unit>
        <trans-unit id="110ffd01521ffa85d725f633c684562720f4ba39" translate="yes" xml:space="preserve">
          <source>Adds binding &lt;code&gt;Name=Value&lt;/code&gt; to &lt;code&gt;BindingStruct&lt;/code&gt;. Returns an updated binding structure.</source>
          <target state="translated">Добавляет привязку &lt;code&gt;Name=Value&lt;/code&gt; в &lt;code&gt;BindingStruct&lt;/code&gt; . Возвращает обновленную структуру привязки.</target>
        </trans-unit>
        <trans-unit id="166b6b5a44b378b7ef528300e6dd1ab66edcbe83" translate="yes" xml:space="preserve">
          <source>Adds nodes to current cover test. Notice that this only works if cover support is active.</source>
          <target state="translated">Добавляет узлы к текущему тесту на обложку.Обратите внимание,что это работает,только если активна поддержка обложки.</target>
        </trans-unit>
        <trans-unit id="ebbd57f6aab385f9f5cefe84013bbde0f94bd2a8" translate="yes" xml:space="preserve">
          <source>Adds optional capabilities and sends a &lt;code&gt;hello&lt;/code&gt; message to the server and waits for the return.</source>
          <target state="translated">Добавляет дополнительные возможности и отправляет &lt;code&gt;hello&lt;/code&gt; сообщение на сервер и ожидает ответа.</target>
        </trans-unit>
        <trans-unit id="f4e867c0e696fbab1087c9d79da2f2d90aa8bb6f" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. &lt;code&gt;Bindings&lt;/code&gt; specifies the set of bound variables in the environment of the top level node. The following annotations are affected:</source>
          <target state="translated">Добавляет или обновляет аннотации к узлам в синтаксическом дереве. &lt;code&gt;Bindings&lt;/code&gt; задают набор связанных переменных в среде узла верхнего уровня. Затронуты следующие аннотации:</target>
        </trans-unit>
        <trans-unit id="b3ac712b8a650dd6e42451afed1ca538238431c7" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. Equivalent to &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; where the top-level environment &lt;code&gt;Bindings&lt;/code&gt; is taken from the annotation &lt;code&gt;{env, Bindings}&lt;/code&gt; on the root node of &lt;code&gt;Tree&lt;/code&gt;. An exception is thrown if no such annotation should exist.</source>
          <target state="translated">Добавляет или обновляет аннотации к узлам в синтаксическом дереве. Эквивалентно &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; где &lt;code&gt;Bindings&lt;/code&gt; среды верхнего уровня берутся из аннотации &lt;code&gt;{env, Bindings}&lt;/code&gt; в корневом узле &lt;code&gt;Tree&lt;/code&gt; . Если такой аннотации не должно существовать, генерируется исключение.</target>
        </trans-unit>
        <trans-unit id="7bbf9ca1c736db15763a8239f95f4d5c1b66558d" translate="yes" xml:space="preserve">
          <source>Adds the directories in &lt;code&gt;Dirs&lt;/code&gt; to the end of the code path. If a &lt;code&gt;Dir&lt;/code&gt; exists, it is not added.</source>
          <target state="translated">Добавляет каталоги в &lt;code&gt;Dirs&lt;/code&gt; в конец пути кода. Если &lt;code&gt;Dir&lt;/code&gt; существует, он не добавляется.</target>
        </trans-unit>
        <trans-unit id="c8d419cc2314f6341b04eb8bad24bf2f277d7f87" translate="yes" xml:space="preserve">
          <source>Adds the modules found in the given directory and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The default is not to examine subdirectories, but if the option &lt;code&gt;recurse&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, modules are searched for in subdirectories on all levels as well as in the given directory. Returns a sorted list of the names of the added modules.</source>
          <target state="translated">Добавляет модули, найденные в данном каталоге, и &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . По умолчанию подкаталоги не проверяются, но если параметр &lt;code&gt;recurse&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , модули ищутся в подкаталогах на всех уровнях, а также в заданном каталоге. Возвращает отсортированный список имен добавленных модулей.</target>
        </trans-unit>
        <trans-unit id="34d712dcc34471fdb6acaa22554dc0975d1f5dc6" translate="yes" xml:space="preserve">
          <source>Adds the registered name of the process. This can be useful when tracing on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">Добавляет зарегистрированное название процесса.Это может быть полезно при трассировке на многих узлах,так как процессы с таким именем затем трассируются на всех отслеживаемых узлах.</target>
        </trans-unit>
        <trans-unit id="6bbf14dbe70908fe6ce0549e066a68aa359629b3" translate="yes" xml:space="preserve">
          <source>Adds the selected process and all processes below, right of it, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">Добавляет выбранный процесс и все процессы ниже, справа от него, на вкладку &lt;strong&gt;Trace Overview&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3fcbc67018c8db0d7d54f40db7c26439211fb94f" translate="yes" xml:space="preserve">
          <source>Adds the selected process identifier to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the process resides on.</source>
          <target state="translated">Добавляет выбранный идентификатор процесса на вкладку &lt;strong&gt;Обзор трассировки&lt;/strong&gt; плюс узел, на котором находится процесс.</target>
        </trans-unit>
        <trans-unit id="31b3e1e7afc7441a8de7e4b30d8d409a2bd10a0f" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt; code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aebb82fdca9aa95c0538fef0af13a3b616d5fe2" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt;code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="translated">Добавляет указанные каталоги в начало пути кода, аналогично &lt;code&gt;code:add_pathsa/1&lt;/code&gt; . Обратите внимание, что порядок данных каталогов в конечном пути будет обратным.</target>
        </trans-unit>
        <trans-unit id="0a1c883186e0d00a77adaf41f013ddc82c811398" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the end of the code path, similar to &lt;code&gt;code:add_pathsz/1&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">Добавляет указанные каталоги в конец пути кода, аналогично &lt;code&gt;code:add_pathsz/1&lt;/code&gt; ; см. &lt;code&gt;code(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d2e0e96fcba01247b2f834ed2a0365db181f6d4" translate="yes" xml:space="preserve">
          <source>Adds the specified primary filters.</source>
          <target state="translated">Добавляет указанные первичные фильтры.</target>
        </trans-unit>
        <trans-unit id="d613e82163d56d8326249e8169f52e84f75a04cb" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of compress extensions.</source>
          <target state="translated">Добавляет эти расширения в список расширений компрессора.</target>
        </trans-unit>
        <trans-unit id="25822e567273ecdc04d1dd713da5a9ee0671d675" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of uncompress extensions.</source>
          <target state="translated">Добавляет эти расширения в список несжатых расширений.</target>
        </trans-unit>
        <trans-unit id="2f502d97e1ab810c3754afd45a8594c92efa30f8" translate="yes" xml:space="preserve">
          <source>Adds to &lt;code&gt;Forms&lt;/code&gt; the code for the standard pre-defined functions (such as &lt;code&gt;module_info/0&lt;/code&gt;) that are to be included in every module.</source>
          <target state="translated">Добавляет в &lt;code&gt;Forms&lt;/code&gt; код стандартных предопределенных функций (таких как &lt;code&gt;module_info/0&lt;/code&gt; ), которые должны быть включены в каждый модуль.</target>
        </trans-unit>
        <trans-unit id="bb8f1512f2d702beeef48e8c7223a0b1dde1e4a0" translate="yes" xml:space="preserve">
          <source>Adjust the process(&quot;beam&quot;) reference to your beam version and attach the script to a running &quot;beam&quot; instance:</source>
          <target state="translated">Настройте ссылку process(&quot;beam&quot;)на вашу версию луча и прикрепите скрипт к работающему экземпляру &quot;beam&quot;:</target>
        </trans-unit>
        <trans-unit id="c57f256463601b2a2c62f254f5126bfecb16a4d2" translate="yes" xml:space="preserve">
          <source>Adjusts the SSH flow control window. This is to be done by both the client- and server-side channel processes.</source>
          <target state="translated">Регулирует окно управления потоком SSH.Это должно быть сделано как клиентским,так и серверным каналом.</target>
        </trans-unit>
        <trans-unit id="980e8823b26ab3a416e4eec330a78a5f567d8a4d" translate="yes" xml:space="preserve">
          <source>Affects SSL-3.0 and TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="translated">Влияет только на соединения SSL-3.0 и TLS-1.0. Используется для изменения стратегии защиты BEAST для взаимодействия с устаревшим программным обеспечением. По умолчанию &lt;code&gt;one_n_minus_one&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6004ea02cc23d09682422b618c26d349782aa93" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. If set to &lt;code&gt;false&lt;/code&gt;, it disables the block cipher padding check to be able to interoperate with legacy software.</source>
          <target state="translated">Влияет только на соединения TLS-1.0. Если установлено значение &lt;code&gt;false&lt;/code&gt; , он отключает проверку заполнения блочного шифра, чтобы иметь возможность взаимодействовать с устаревшим программным обеспечением.</target>
        </trans-unit>
        <trans-unit id="debeed9026878cefb793f6e84d87d4b3c12ed8e6" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6ffc59171bd18b8e61a3e781dab573deabf10a" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs on Windows only. The standard input and standard output handles of the port program are, if this option is supplied, opened with flag &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt;, so that the port program can (and must) do overlapped I/O on its standard handles. This is not normally the case for simple port programs, but an option of value for the experienced Windows programmer. &lt;strong&gt;On all other platforms, this option is silently discarded.&lt;/strong&gt;</source>
          <target state="translated">Влияет только на порты внешних программ в Windows. Стандартные дескрипторы ввода и вывода программы порта, если указана эта опция, открываются с флагом &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; , так что программа порта может (и должна) выполнять перекрывающийся ввод-вывод на своих стандартных дескрипторах. Обычно это не относится к простым портированным программам, но это вариант, представляющий ценность для опытного программиста Windows. &lt;strong&gt;На всех других платформах эта опция автоматически игнорируется.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf4fb0d4263b60ac21dc80f51c2dec3dcfb5747e" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs. The executed program gets its standard error file redirected to its standard output file. &lt;code&gt;stderr_to_stdout&lt;/code&gt; and &lt;code&gt;nouse_stdio&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">Влияет на порты внешних программ. Выполняемая программа перенаправляет свой стандартный файл ошибок в стандартный выходной файл. &lt;code&gt;stderr_to_stdout&lt;/code&gt; и &lt;code&gt;nouse_stdio&lt;/code&gt; являются взаимоисключающими.</target>
        </trans-unit>
        <trans-unit id="1e538da53759cfec60cd8a151505e38fb92a9633" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1089&quot;&gt;all terms&lt;/a&gt;&lt;/code&gt; referenced by the root-set have been copied, the collector scans the &lt;strong&gt;to space&lt;/strong&gt; and copies all terms that these terms reference. When scanning, the collector steps through each term on the &lt;strong&gt;to space&lt;/strong&gt; and any term still referencing the &lt;strong&gt;from space&lt;/strong&gt; is copied over to the &lt;strong&gt;to space&lt;/strong&gt;. Some terms contain non-term data (the payload of a on heap binary for instance). When encountered by the collector, these values are simply skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c066b0f9a1e6496e99cead0881b8f872728f45" translate="yes" xml:space="preserve">
          <source>After LTTng is properly installed on the system Erlang/OTP can be built with LTTng support.</source>
          <target state="translated">После правильной установки LTTng в систему Erlang/OTP можно построить с поддержкой LTTng.</target>
        </trans-unit>
        <trans-unit id="093311043e9bea9fbc9705d1e98f8e3acfd08364" translate="yes" xml:space="preserve">
          <source>After STDLIB 3.4 (OTP 20.0) compiled match specifications have an external representation as a node specific reference to the original compiled match specification. If passed through &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; or sent to another node and back, the result &lt;strong&gt;may or may not&lt;/strong&gt; be a valid compiled match specification depending on if the original compiled match specification was still alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1facbcf11ae5793aa1bc80ef16d286aebd0fc34d" translate="yes" xml:space="preserve">
          <source>After \0 up to two further octal digits are read. If there are fewer than two digits, just those that are present are used. Thus the sequence \0\x\015 specifies two binary zeros followed by a CR character (code value 13). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">После \0 читаются еще две восьмеричные цифры.Если их меньше двух,используются только те,которые присутствуют.Таким образом,последовательность \0\x\015 задает два двоичных нуля,за которыми следует символ CR (значение кода 13).Убедитесь,что после начального нуля введены две цифры,если последующий символ паттерна сам по себе является восьмеричной цифрой.</target>
        </trans-unit>
        <trans-unit id="ec54f9531929f3cd1ca22e8febfcaf52fc58636a" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; it contains the number of bytes padded. Otherwise 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d732389ea2448ab3a2fa3d0a36ca3e321f1eb8c8" translate="yes" xml:space="preserve">
          <source>After a partial match or a failed match, the last encountered name in the entire match process is returned, for example:</source>
          <target state="translated">После частичного совпадения или неудачного совпадения возвращается,например,фамилия,которая встречалась во время всего процесса поиска:</target>
        </trans-unit>
        <trans-unit id="5fc9546102b17d8235883e41d7c9f9c95505b3d1" translate="yes" xml:space="preserve">
          <source>After a succesful incoming authentication, a new process runs as the just authenticated user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46c18eae1ac24b22616197a0acee7d1074a413c" translate="yes" xml:space="preserve">
          <source>After a successful authentication an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ee0e3703c2647b03b1406f234f9cc3d123429d" translate="yes" xml:space="preserve">
          <source>After adding more records to the &lt;code&gt;Company&lt;/code&gt; database, the result can be the following records:</source>
          <target state="translated">После добавления дополнительных записей в базу данных &lt;code&gt;Company&lt;/code&gt; результатом могут быть следующие записи:</target>
        </trans-unit>
        <trans-unit id="93fdc04d975de9f436b576b59d005bc9bf8bf315" translate="yes" xml:space="preserve">
          <source>After all name servers have been tried, there is a timeout before the name servers are tried again. This is to prevent the server from answering the query with what's in the servfail cache, &lt;code&gt;inet_res(3)&lt;/code&gt;. Defaults to 1500 milli seconds .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22669be288b8402f937e20a5b4c0d8be02ada8ae" translate="yes" xml:space="preserve">
          <source>After an analysis, you can inspect this information. In the &lt;strong&gt;PLT&lt;/strong&gt; menu you can choose to either search the PLT or inspect the contents of the whole PLT. The information is presented in &lt;code&gt;EDoc&lt;/code&gt; format.</source>
          <target state="translated">После анализа вы можете проверить эту информацию. В меню &lt;strong&gt;PLT&lt;/strong&gt; вы можете выбрать либо поиск по PLT, либо просмотр содержимого всего PLT. Информация представлена ​​в формате &lt;code&gt;EDoc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ef9c0c6bbe4e27c696f859b427107c4e849d03c" translate="yes" xml:space="preserve">
          <source>After any post hook has been executed for all installed CTHs, &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; is called if the testcase failed or was skipped, respectively. You cannot affect the outcome of the tests any further at this point.</source>
          <target state="translated">После того, как любой обработчик post был выполнен для всех установленных CTH, &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; , если тестовый сценарий не прошел или был пропущен, соответственно. На этом этапе вы больше не можете повлиять на результат тестов.</target>
        </trans-unit>
        <trans-unit id="f056750b4e33f30fb9d5942f6265a2d4f346b9dc" translate="yes" xml:space="preserve">
          <source>After at least one tab-character, the line added is to contain the full name of the named pipe where &lt;code&gt;syslogd&lt;/code&gt; writes its information. The path must be the same as for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The filename must be &lt;code&gt;syslog.otp&lt;/code&gt;.</source>
          <target state="translated">После хотя бы одного символа табуляции добавляемая строка должна содержать полное имя именованного канала, в который &lt;code&gt;syslogd&lt;/code&gt; записывает свою информацию. Путь должен быть таким же, как и для файлов &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; и &lt;code&gt;syslog.conf.OTP&lt;/code&gt; . Имя файла должно быть &lt;code&gt;syslog.otp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ce4ab81087082fd95156bdaf8c2e0786410e8e3" translate="yes" xml:space="preserve">
          <source>After completing all the normal building steps described above a debug enabled runtime system can be built. To do this you have to change directory to &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and execute:</source>
          <target state="translated">После выполнения всех обычных шагов сборки, описанных выше, можно построить систему времени выполнения с включенной отладкой. Для этого вам нужно сменить каталог на &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; и выполнить:</target>
        </trans-unit>
        <trans-unit id="9cd742cd300933dfb65e0a535f4d15de36d37f01" translate="yes" xml:space="preserve">
          <source>After decoding a message various user callback functions are invoked in order to allow the user to act properly. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">После декодирования сообщения вызываются различные функции обратного вызова для того,чтобы пользователь мог действовать корректно.Подробнее об аргументах обратного вызова смотрите в модуле megaco_user.</target>
        </trans-unit>
        <trans-unit id="dc240b1130d5df1612bf5772e5400cd74e1cad80" translate="yes" xml:space="preserve">
          <source>After flag fields for atom cache references, another half byte flag field is located with the following format:</source>
          <target state="translated">После полей флагов для ссылок на атомный кэш расположено еще одно полбайтовое поле флага со следующим форматом:</target>
        </trans-unit>
        <trans-unit id="8aca18c81b4ecc6e98bd69677c9d22a41d1f8407" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use &lt;code&gt;erl_connect()&lt;/code&gt;. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="translated">После инициализации вы настраиваете соединение с узлом Erlang. Чтобы указать узел Erlang, к &lt;code&gt;erl_connect()&lt;/code&gt; вы хотите подключиться, используйте erl_connect () . Следующий пример устанавливает соединение и должен привести к действительному дескриптору файла сокета:</target>
        </trans-unit>
        <trans-unit id="d230e040d4a295e72e3f66c85d88ac7727295ab3" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use the &lt;code&gt;ei_connect_*()&lt;/code&gt; family of functions. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71297d463c83eda2a6c9154b983ee09e837036ff" translate="yes" xml:space="preserve">
          <source>After installation you can access the documentation by</source>
          <target state="translated">После установки вы можете получить доступ к документации по</target>
        </trans-unit>
        <trans-unit id="6b0c5270a184c48e498da3c725b4712069c50f99" translate="yes" xml:space="preserve">
          <source>After matching all six digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only five digits matching item \d+, and then with four, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term taken from Jeffrey Friedl's book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way.</source>
          <target state="translated">После совпадения всех шести цифр,а затем неудачи с &quot;фу&quot;,обычным действием матчера является повторная попытка только с пятью цифрами,совпадающими с элементом \d+,а затем с четырьмя,и так далее,прежде чем в конечном итоге неудача.&quot;Атомная группировка&quot; (термин,взятый из книги Джеффри Фридла)дает возможность указать,что как только подмасказка совпадает,она не должна подвергаться повторной оценке таким образом.</target>
        </trans-unit>
        <trans-unit id="ae043d6d909deeb13bd861dc2fdf16fc111c0f4f" translate="yes" xml:space="preserve">
          <source>After reading the &lt;code&gt;erts_alloc(3)&lt;/code&gt; documentation, the returned information more or less speaks for itself, but it can be worth explaining some things. Call counts are presented by two values, the first value is giga calls, and the second value is calls. &lt;code&gt;mbcs&lt;/code&gt; and &lt;code&gt;sbcs&lt;/code&gt; denote multi-block carriers, and single-block carriers, respectively. Sizes are presented in bytes. When a size is not presented, it is the amount of something. Sizes and amounts are often presented by three values:</source>
          <target state="translated">После прочтения документации по &lt;code&gt;erts_alloc(3)&lt;/code&gt; возвращенная информация более или менее говорит сама за себя, но, возможно, стоит объяснить некоторые вещи. Счетчики вызовов представлены двумя значениями: первое значение - гигабайтные вызовы, а второе - вызовы. &lt;code&gt;mbcs&lt;/code&gt; и &lt;code&gt;sbcs&lt;/code&gt; обозначают многоблочные несущие и одноблочные несущие соответственно. Размеры представлены в байтах. Когда размер не указан, это количество чего-то. Размеры и суммы часто представлены тремя значениями:</target>
        </trans-unit>
        <trans-unit id="90a4520417596de12836632d1f1ef59e2dcef82d" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;ei_connect#ei_accept&quot;&gt; ei_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9095c6393c06f16504fcb2b9e560f38a38a063b" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="translated">После регистрации имени используйте &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; для ожидания входящих соединений.</target>
        </trans-unit>
        <trans-unit id="d3c38468398c9f7ba65583a0574f32622bbcf3f0" translate="yes" xml:space="preserve">
          <source>After sending the message &lt;code&gt;pong&lt;/code&gt; to the process &quot;ping&quot;, &quot;pong&quot; calls the &lt;code&gt;pong&lt;/code&gt; function again, which causes it to get back to the &lt;code&gt;receive&lt;/code&gt; again and wait for another message.</source>
          <target state="translated">После отправки сообщения &lt;code&gt;pong&lt;/code&gt; процессу &amp;laquo;ping&amp;raquo;, &amp;laquo;pong&amp;raquo; снова вызывает функцию &lt;code&gt;pong&lt;/code&gt; , что заставляет его снова вернуться к &lt;code&gt;receive&lt;/code&gt; и ждать следующего сообщения.</target>
        </trans-unit>
        <trans-unit id="e36306045d856ed44b3178bdde7ee2e0ace1e9c1" translate="yes" xml:space="preserve">
          <source>After setting the dictionary the inflate operation should be retried without new input.</source>
          <target state="translated">После настройки словаря операцию надувания следует повторить без нового ввода.</target>
        </trans-unit>
        <trans-unit id="46b2484894cf1b418bcc258ea3f4b87e3bcd685f" translate="yes" xml:space="preserve">
          <source>After testing that the client process exists:</source>
          <target state="translated">После проверки,что клиентский процесс существует:</target>
        </trans-unit>
        <trans-unit id="22756028dc88f951673801206c8f0149ec02c1b4" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;Flags&lt;/code&gt; field follow the &lt;code&gt;AtomCacheRefs&lt;/code&gt;. The first &lt;code&gt;AtomCacheRef&lt;/code&gt; is the one corresponding to &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0. Higher indices follow in sequence up to index &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt;.</source>
          <target state="translated">После поля &lt;code&gt;Flags&lt;/code&gt; следуйте &lt;code&gt;AtomCacheRefs&lt;/code&gt; . Первый &lt;code&gt;AtomCacheRef&lt;/code&gt; - это тот, который соответствует &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0. Более высокие индексы следуют последовательно до индекса &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca4e4c96c0a14c7be226e5bd7489709c72d0c43" translate="yes" xml:space="preserve">
          <source>After the application specifications have been updated, the instructions in the script are evaluated and the function returns &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; if successful. &lt;code&gt;OtherVsn&lt;/code&gt; and &lt;code&gt;Descr&lt;/code&gt; are the version (&lt;code&gt;UpFromVsn&lt;/code&gt; or &lt;code&gt;Vsn&lt;/code&gt;) and description (&lt;code&gt;Descr1&lt;/code&gt; or &lt;code&gt;Descr2&lt;/code&gt;) as specified in the script.</source>
          <target state="translated">После обновления спецификаций приложения выполняются инструкции в сценарии, и в случае успеха функция возвращает &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; . &lt;code&gt;OtherVsn&lt;/code&gt; и &lt;code&gt;Descr&lt;/code&gt; - это версия ( &lt;code&gt;UpFromVsn&lt;/code&gt; или &lt;code&gt;Vsn&lt;/code&gt; ) и описание ( &lt;code&gt;Descr1&lt;/code&gt; или &lt;code&gt;Descr2&lt;/code&gt; ), как указано в скрипте.</target>
        </trans-unit>
        <trans-unit id="0d4f7a31773a30c9ab44ee914a380f7ad8d9358d" translate="yes" xml:space="preserve">
          <source>After the change, 5 lines are presented as follows:</source>
          <target state="translated">После изменения 5 строк представлены следующим образом:</target>
        </trans-unit>
        <trans-unit id="2c691aee72f4af2559c4df9a131c0a55a89cadf0" translate="yes" xml:space="preserve">
          <source>After the database is deleted, it can still be possible to start Mnesia as a disc-less node. This depends on how configuration parameter &lt;code&gt;schema_location&lt;/code&gt; is set.</source>
          <target state="translated">После удаления базы данных Mnesia все еще можно будет запустить как бездисковый узел. Это зависит от того, как &lt;code&gt;schema_location&lt;/code&gt; параметр конфигурации schema_location .</target>
        </trans-unit>
        <trans-unit id="d5839b9af149f08b9df4808444dfa4c5b3879065" translate="yes" xml:space="preserve">
          <source>After the handshake is performed, the user process receives messages with the tickets sent by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4298986c5c1910d7ad391031923615fdac4c6079" translate="yes" xml:space="preserve">
          <source>After the header word has been copied a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.h#L45-L46&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; is destructively placed in it pointing to the term in the &lt;strong&gt;to space&lt;/strong&gt;. Any other term that points to the already moved term will &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1125&quot;&gt;see this move marker&lt;/a&gt;&lt;/code&gt; and copy the referring pointer instead. For example, if the have the following Erlang code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e458fe2735510f2a3f94986ee2e1c2798b1558" translate="yes" xml:space="preserve">
          <source>After the insertion of the employee named &lt;code&gt;klacke&lt;/code&gt;, the database has the following records:</source>
          <target state="translated">После вставки сотрудника по имени &lt;code&gt;klacke&lt;/code&gt; в базе данных есть следующие записи:</target>
        </trans-unit>
        <trans-unit id="014d2e6e6b7efad4c0429a37b959bc880d48f38c" translate="yes" xml:space="preserve">
          <source>After the installation, the application controller compares the old and new configuration parameters for all running applications and call the callback function:</source>
          <target state="translated">После установки контроллер приложений сравнивает старые и новые параметры конфигурации для всех запущенных приложений и вызывает функцию обратного вызова:</target>
        </trans-unit>
        <trans-unit id="8b5bb17b2c511826d46800999f421579e3ca514c" translate="yes" xml:space="preserve">
          <source>After the restore operation, the entire contents of the registry is marked as unmodified. Notice that this includes any objects that were modified before the restore and not overwritten by the restore.</source>
          <target state="translated">После операции восстановления все содержимое реестра помечается как неизмененное.Обратите внимание,что сюда относятся все объекты,которые были изменены до восстановления и не были перезаписаны при восстановлении.</target>
        </trans-unit>
        <trans-unit id="c4f3acb2fc60165a466769fee1869d300231ddf6" translate="yes" xml:space="preserve">
          <source>After the rootsymbol declaration comes an optional declaration of the &lt;code&gt;end_of_input&lt;/code&gt; symbol that your scanner is expected to use. For example:</source>
          <target state="translated">После объявления rootymbol следует необязательное объявление символа &lt;code&gt;end_of_input&lt;/code&gt; , который, как ожидается, будет использовать ваш сканер. Например:</target>
        </trans-unit>
        <trans-unit id="2770f0bd427f63fd51d60a2a398782f6d81807ca" translate="yes" xml:space="preserve">
          <source>After the successful build it's time to patch. The source tree directory, the directory of the installation and the applications to patch are given as arguments to &lt;code&gt;otp_patch_apply&lt;/code&gt;. The dependencies of each application are validated against the applications in the installation and the other applications given as arguments. If a dependency error is detected, the script will be aborted.</source>
          <target state="translated">После успешной сборки пора патчить. Каталог исходного дерева, каталог установки и приложения, которые нужно исправить, передаются в качестве аргументов для &lt;code&gt;otp_patch_apply&lt;/code&gt; . Зависимости каждого приложения проверяются на соответствие приложениям в установке и другим приложениям, указанным в качестве аргументов. Если обнаружена ошибка зависимости, сценарий будет прерван.</target>
        </trans-unit>
        <trans-unit id="59c978cfe3812d62d5db4509ebca4d4c5513e4b6" translate="yes" xml:space="preserve">
          <source>After the system has been cross built you can build and install the documentation the same way as after a native build of the system. See the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; section in the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document for information on how to build the documentation.</source>
          <target state="translated">После кросс-сборки системы вы можете собрать и установить документацию так же, как после собственной сборки системы. См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; &amp;raquo; в документе &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; для получения информации о том, как создать документацию.</target>
        </trans-unit>
        <trans-unit id="0aad644b2254828a652fc4d00f391c4ee2e9798e" translate="yes" xml:space="preserve">
          <source>After these steps, the intermediate data structure, an &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;, is fully normalized. The last step is applying &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; that converts the intermediate structure into a valid canonical URI string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3f9b5771b4280d0c55a70767959a27ea46eb52" translate="yes" xml:space="preserve">
          <source>After this is compiled and the file &lt;code&gt;tut19.beam&lt;/code&gt; is copied to the necessary directories, the following is seen on (pong@kosken):</source>
          <target state="translated">После того, как это скомпилировано и файл &lt;code&gt;tut19.beam&lt;/code&gt; скопирован в необходимые каталоги, на (pong @ kosken) будет видно следующее:</target>
        </trans-unit>
        <trans-unit id="c6e5f33003aed8582bf379cb6df791e38f259eef" translate="yes" xml:space="preserve">
          <source>After thread progress, commit the staging area by assigning &lt;code&gt;the_staging_code_index&lt;/code&gt; to &lt;code&gt;the_active_code_index&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0717a39ec07e9aad70e9e475eae5bb9f752c8e1" translate="yes" xml:space="preserve">
          <source>Again, the &lt;code&gt;relup&lt;/code&gt; file is created manually. Either from scratch or by editing a generated version. Load all code for &lt;code&gt;ch_app&lt;/code&gt; first, and also load the application specification, before &lt;code&gt;prim_sup&lt;/code&gt; is updated. When downgrading, &lt;code&gt;prim_sup&lt;/code&gt; is to updated first, before the code for &lt;code&gt;ch_app&lt;/code&gt; and its application specification are unloaded.</source>
          <target state="translated">Опять же, файл &lt;code&gt;relup&lt;/code&gt; создается вручную. Либо с нуля, либо путем редактирования сгенерированной версии. &lt;code&gt;ch_app&lt;/code&gt; загрузите весь код для ch_app , а также загрузите спецификацию приложения перед обновлением &lt;code&gt;prim_sup&lt;/code&gt; . При &lt;code&gt;prim_sup&lt;/code&gt; на более раннюю версию сначала обновляется prim_sup , прежде чем будет выгружен код для &lt;code&gt;ch_app&lt;/code&gt; и его спецификация приложения.</target>
        </trans-unit>
        <trans-unit id="1b5e61e0895721c0ebf450f07d288833226aa589" translate="yes" xml:space="preserve">
          <source>Again, this works in Perl, but not in PCRE, and for the same reason. When a deeper recursion has matched a single character, it cannot be entered again to match an empty string. The solution is to separate the two cases, and write out the odd and even cases as alternatives at the higher level:</source>
          <target state="translated">Опять же,это работает на Perl,но не на PCRE,и по той же причине.Когда более глубокая рекурсия совпадает с одним символом,она не может быть введена повторно,чтобы совпасть с пустой строкой.Решение состоит в том,чтобы разделить эти два случая и записать нечетные и четные случаи в качестве альтернативы на более высоком уровне:</target>
        </trans-unit>
        <trans-unit id="3b2767e308e62a98e4db59a3a9f824fa516512cb" translate="yes" xml:space="preserve">
          <source>Agent configuration:</source>
          <target state="translated">Настройка агента:</target>
        </trans-unit>
        <trans-unit id="3ec3b79e0abd28ca38f812dac049f7131b92ea23" translate="yes" xml:space="preserve">
          <source>Agent semantics</source>
          <target state="translated">Семантика агента</target>
        </trans-unit>
        <trans-unit id="292ef3c4e0286769b6dbb07a9c3a55d1d989a61e" translate="yes" xml:space="preserve">
          <source>Agent specific config options and types:</source>
          <target state="translated">Опции и типы конфигурации,специфичные для агентов:</target>
        </trans-unit>
        <trans-unit id="9183ce25ce4e057cce5e3b5d3d28a86f4aa93b15" translate="yes" xml:space="preserve">
          <source>Agents to be accessed by the manager needs to be registered by a user. Once registered, they can be accessed by all registered users.</source>
          <target state="translated">Агенты,к которым обращается менеджер,должны быть зарегистрированы пользователем.После регистрации к ним могут получить доступ все зарегистрированные пользователи.</target>
        </trans-unit>
        <trans-unit id="b321e7cb00697b98b1069def622912b90e34756e" translate="yes" xml:space="preserve">
          <source>Aho &amp;amp; Johnson: 'LR Parsing', ACM Computing Surveys, vol. 6:2, 1974.</source>
          <target state="translated">Aho &amp;amp; Johnson: LR Parsing, ACM Computing Surveys, т. 6: 2, 1974.</target>
        </trans-unit>
        <trans-unit id="8314c1bccd7fbe31d59f08ffd330d112f0923137" translate="yes" xml:space="preserve">
          <source>Aim for finding bugs. Write whatever test that has the highest probability of finding a bug, now or in the future. Concentrate more on the critical parts. Bugs in critical subsystems are much more expensive than others.</source>
          <target state="translated">Цель-найти жучки.Пишите любой тест,который имеет наибольшую вероятность найти ошибку,сейчас или в будущем.Сосредоточьтесь больше на критических частях.Ошибки в критических подсистемах намного дороже других.</target>
        </trans-unit>
        <trans-unit id="2e73e04c930e7b3b6a12e1613006c2d06e333b4f" translate="yes" xml:space="preserve">
          <source>Aim for functionality testing rather than implementation details. Implementation details change quite often, and the test suites are to be long lived. Implementation details often differ on different platforms and versions. If implementation details must be tested, try to factor them out into separate test cases. These test cases can later be rewritten or skipped.</source>
          <target state="translated">Цель-тестирование функциональности,а не детали реализации.Детали реализации меняются довольно часто,и тестовые наборы должны быть долговечными.Детали реализации часто отличаются на разных платформах и версиях.Если детали реализации необходимо проверить,постарайтесь учесть их в отдельных тестовых примерах.Позже эти тестовые примеры можно будет переписать или пропустить.</target>
        </trans-unit>
        <trans-unit id="5204c24c2356e334c01209b09953d29e8b1c732c" translate="yes" xml:space="preserve">
          <source>Alarm handling</source>
          <target state="translated">Обработка аварийных сигналов</target>
        </trans-unit>
        <trans-unit id="07994d0d2fea2b8ccddc2fe4a57609e0e8cf0605" translate="yes" xml:space="preserve">
          <source>Alarm, that is, the BEL character (hex 07)</source>
          <target state="translated">Сигнал тревоги,то есть персонаж БЭЛ (hex 07)</target>
        </trans-unit>
        <trans-unit id="44b68bd3aa7ebc745c49072e3fc9224605032491" translate="yes" xml:space="preserve">
          <source>Alarms are reported to the SASL alarm handler, see &lt;code&gt;alarm_handler(3)&lt;/code&gt;. To set an alarm, &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; is called where &lt;code&gt;Alarm&lt;/code&gt; is either of the alarms specified above.</source>
          <target state="translated">Аварийные сигналы передаются обработчику аварийных сигналов SASL, см. &lt;code&gt;alarm_handler(3)&lt;/code&gt; . Для установки будильника &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; где &lt;code&gt;Alarm&lt;/code&gt; является одним из указанных выше сигналов.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
