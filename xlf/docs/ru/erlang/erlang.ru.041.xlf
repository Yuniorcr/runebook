<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="b1514fe84ab0f4ebd6e6cad9a7b7bbf021b9cbbe" translate="yes" xml:space="preserve">
          <source>The registered name, if any. If a registered name is not displayed, it can be that Debugger received information about the process before the name was registered. Try selecting &lt;strong&gt;Edit &amp;gt; Refresh&lt;/strong&gt;.</source>
          <target state="translated">Зарегистрированное имя, если есть. Если зарегистрированное имя не отображается, возможно, отладчик получил информацию о процессе до того, как имя было зарегистрировано. Попробуйте выбрать &amp;laquo; &lt;strong&gt;Правка&amp;raquo;&amp;gt; &amp;laquo;Обновить&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="253fb5321acafacd5bcd81a207e0260e1e20f165" translate="yes" xml:space="preserve">
          <source>The registered names are stored in replica global name tables on every node. There is no central storage point. Thus, the translation of a name to a pid is fast, as it is always done locally. For any action resulting in a change to the global name table, all tables on other nodes are automatically updated.</source>
          <target state="translated">Зарегистрированные имена хранятся в репликах таблиц глобальных имен на каждом узле.Нет центральной точки хранения.Таким образом,перевод имени в pid происходит быстро,как это всегда делается локально.Для любого действия,приводящего к изменению таблицы глобальных имен,все таблицы на других узлах обновляются автоматически.</target>
        </trans-unit>
        <trans-unit id="b656ecffd1ced10be89c73c0264120c641a1a963" translate="yes" xml:space="preserve">
          <source>The registry contains keys and values. Keys are like the directories in a file system, they form a hierarchy. Values are like files, they have a name and a value, and also a type.</source>
          <target state="translated">Реестр содержит ключи и значения.Ключи подобны каталогам в файловой системе,они образуют иерархию.Значения похожи на файлы,у них есть имя и значение,а также тип.</target>
        </trans-unit>
        <trans-unit id="0f19e0edc2bdf4a111b804cb06a4a4fda7a24377" translate="yes" xml:space="preserve">
          <source>The registry is a hierarchical database, used to store various system and software information in Windows. It contains installation data, and is updated by installers and system programs. The Erlang installer updates the registry by adding data that Erlang needs.</source>
          <target state="translated">Реестр представляет собой иерархическую базу данных,используемую для хранения различной системной и программной информации в Windows.Она содержит данные об установке и обновляется инсталляторами и системными программами.Инсталлятор Erlang обновляет реестр,добавляя данные,необходимые Erlang.</target>
        </trans-unit>
        <trans-unit id="a1df08771ef4b4eb79805f54d0af976d930c81c1" translate="yes" xml:space="preserve">
          <source>The registry must have been opened in write mode.</source>
          <target state="translated">Реестр должен был быть открыт в режиме записи.</target>
        </trans-unit>
        <trans-unit id="3e31d2327ae3a594ef721ad76afd4e76d34b773c" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;(|at)&lt;/code&gt; first match at the initial position of string &lt;code&gt;cat&lt;/code&gt;, giving the result set &lt;code&gt;[{0,0},{0,0}]&lt;/code&gt; (the second &lt;code&gt;{0,0}&lt;/code&gt; is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet.</source>
          <target state="translated">Регулярное выражение &lt;code&gt;(|at)&lt;/code&gt; сначала соответствует начальной позиции строки &lt;code&gt;cat&lt;/code&gt; , давая набор результатов &lt;code&gt;[{0,0},{0,0}]&lt;/code&gt; (второе &lt;code&gt;{0,0}&lt;/code&gt; из-за подвыражения, отмеченного скобки). Поскольку длина совпадения равна 0, мы еще не переходим к следующей позиции.</target>
        </trans-unit>
        <trans-unit id="c67bde651eeeb2e55477d91b265e707252cb8bd3" translate="yes" xml:space="preserve">
          <source>The regular expression is specified as a Unicode &lt;code&gt;charlist()&lt;/code&gt; and the resulting regular expression code is to be run against a valid Unicode &lt;code&gt;charlist()&lt;/code&gt; subject. Also consider option &lt;code&gt;ucp&lt;/code&gt; when using Unicode characters.</source>
          <target state="translated">Регулярное выражение указывается как Unicode &lt;code&gt;charlist()&lt;/code&gt; а результирующий код регулярного выражения должен запускаться с допустимой &lt;code&gt;charlist()&lt;/code&gt; Unicode charlist () . Также рассмотрите вариант &lt;code&gt;ucp&lt;/code&gt; при использовании символов Unicode.</target>
        </trans-unit>
        <trans-unit id="e4b1e3caf6818ade884c58fbfd440b868fffc15b" translate="yes" xml:space="preserve">
          <source>The regular expressions allowed here is a subset of the set found in &lt;code&gt;egrep&lt;/code&gt; and in the AWK programming language, as defined in the book, The AWK Programming Language, by A. V. Aho, B. W. Kernighan, P. J. Weinberger. They are composed of the following characters:</source>
          <target state="translated">Разрешенные здесь регулярные выражения - это подмножество набора, содержащегося в &lt;code&gt;egrep&lt;/code&gt; и языке программирования AWK, как определено в книге А. В. Ахо, Б. В. Кернигана, П. Дж. Вайнбергера в книге &amp;laquo;Язык программирования AWK&amp;raquo;. Они состоят из следующих персонажей:</target>
        </trans-unit>
        <trans-unit id="7f4fcc0ee2bcb5481ad7e8a8560c012d54b3a581" translate="yes" xml:space="preserve">
          <source>The relation of equality between the elements of {a,b,c}:</source>
          <target state="translated">Отношение равенства между элементами {a,b,c}:</target>
        </trans-unit>
        <trans-unit id="0c26a1fbdd58094ae590c77744a027cfe086295e" translate="yes" xml:space="preserve">
          <source>The relationships between the predefined variables &lt;code&gt;XU&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and a few others are worth elaborating upon. The reference manual mentions two ways of expressing the set of all functions, one that focuses on how they are defined: &lt;code&gt;X&amp;nbsp;+&amp;nbsp;L&amp;nbsp;+&amp;nbsp;B&amp;nbsp;+&amp;nbsp;U&lt;/code&gt;, and one that focuses on how they are used: &lt;code&gt;UU&amp;nbsp;+&amp;nbsp;LU&amp;nbsp;+&amp;nbsp;XU&lt;/code&gt;. The reference also mentions some &lt;code&gt;&lt;a href=&quot;xref#simple_facts&quot;&gt;facts&lt;/a&gt;&lt;/code&gt; about the variables:</source>
          <target state="translated">Отношения между предопределенными переменными &lt;code&gt;XU&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; и некоторыми другими заслуживают внимания. В справочном руководстве упоминаются два способа выражения набора всех функций, один из которых сосредоточен на том, как они определены: &lt;code&gt;X&amp;nbsp;+&amp;nbsp;L&amp;nbsp;+&amp;nbsp;B&amp;nbsp;+&amp;nbsp;U&lt;/code&gt; , а другой - на том, как они используются: &lt;code&gt;UU&amp;nbsp;+&amp;nbsp;LU&amp;nbsp;+&amp;nbsp;XU&lt;/code&gt; . В справочнике также упоминаются некоторые &lt;code&gt;&lt;a href=&quot;xref#simple_facts&quot;&gt;facts&lt;/a&gt;&lt;/code&gt; о переменных:</target>
        </trans-unit>
        <trans-unit id="11c6e207d55ada23ec986425dc6bc5e23db12059" translate="yes" xml:space="preserve">
          <source>The relative product of binary relations can be generalized to n-ary relations as follows. Let TR be an ordered set (R[1], ..., R[n]) of binary relations from X to Y[i] and S a binary relation from (Y[1] &amp;times; ... &amp;times; Y[n]) to Z. The &lt;strong id=&quot;tuple_relative_product&quot;&gt;relative product&lt;/strong&gt; of TR and S is the binary relation T from X to Z defined so that x T z if and only if there exists an element y[i] in Y[i] for each 1 &amp;lt;= i &amp;lt;= n such that x R[i] y[i] and (y[1], ..., y[n]) S z. Now let TR be a an ordered set (R[1], ..., R[n]) of binary relations from X[i] to Y[i] and S a subset of X[1] &amp;times; ... &amp;times; X[n]. The &lt;strong id=&quot;multiple_relative_product&quot;&gt;multiple relative product&lt;/strong&gt; of TR and S is defined to be the set {z : z = ((x[1], ..., x[n]), (y[1],...,y[n])) for some (x[1], ..., x[n]) in S and for some (x[i], y[i]) in R[i], 1 &amp;lt;= i &amp;lt;= n}.</source>
          <target state="translated">Относительный продукт бинарных отношений можно обобщить на n-мерные отношения следующим образом. Пусть TR - упорядоченное множество (R [1], ..., R [n]) бинарных отношений от X до Y [i], а S - бинарное отношение из (Y [1] &amp;times; ... &amp;times; Y [n ]) к Z. &lt;strong id=&quot;tuple_relative_product&quot;&gt;Относительное произведение&lt;/strong&gt; TR и S - это бинарное отношение T от X к Z, определенное таким образом, что x T z тогда и только тогда, когда существует элемент y [i] в ​​Y [i] для каждого 1 &amp;lt;= i &amp;lt;= n такое, что x R [i] y [i] и (y [1], ..., y [n]) S z. Теперь пусть TR - упорядоченное множество (R [1], ..., R [n]) бинарных отношений от X [i] до Y [i], а S - подмножество X [1] &amp;times; ... &amp;times; Х [п]. &lt;strong id=&quot;multiple_relative_product&quot;&gt;Кратным относительно продукта&lt;/strong&gt; ТР и S определяется как множество {г: г = ((х [1], ..., х [п]), (у [1], ..., у [п] )) для некоторых (x [1], ..., x [n]) в S и для некоторых (x [i], y [i]) в R [i], 1 &amp;lt;= i &amp;lt;= n}.</target>
        </trans-unit>
        <trans-unit id="1a5a729dfd664ee2cc4b65eb400d7906d640d28a" translate="yes" xml:space="preserve">
          <source>The relative product of two functions F1 and F2 is called the &lt;strong id=&quot;composite&quot;&gt;composite&lt;/strong&gt; of F1 and F2 if the range of F1 is a subset of the domain of F2.</source>
          <target state="translated">Относительное произведение двух функций F1 и F2 называется &lt;strong id=&quot;composite&quot;&gt;составом&lt;/strong&gt; F1 и F2, если диапазон F1 является подмножеством области определения F2.</target>
        </trans-unit>
        <trans-unit id="c3e4729853dcefec28c04c62495d1227e52695db" translate="yes" xml:space="preserve">
          <source>The release handler at a node running on a diskless machine, or with a read-only file system, must be configured accordingly using the following SASL configuration parameters (for details, see &lt;code&gt;sasl(6)&lt;/code&gt;):</source>
          <target state="translated">Обработчик выпуска на узле, работающем на бездисковой машине или с файловой системой только для чтения, должен быть настроен соответствующим образом с использованием следующих параметров конфигурации SASL (подробности см. В &lt;code&gt;sasl(6)&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aba90e774f5b7292d69eb5ee7c87083b704de367" translate="yes" xml:space="preserve">
          <source>The release handler can also be used to unpack and install release packages when not running Erlang as an embedded system. However, in this case the user must somehow ensure that correct boot scripts and configuration files are used if the system must be restarted.</source>
          <target state="translated">Обработчик выпуска также может использоваться для распаковки и установки пакетов выпуска,если Erlang не запущен как встроенная система.Однако,в этом случае пользователь должен каким-то образом удостовериться,что используются правильные загрузочные сценарии и конфигурационные файлы,если система должна быть перезапущена.</target>
        </trans-unit>
        <trans-unit id="1a98562301df489f924334591464c2abdffdac36" translate="yes" xml:space="preserve">
          <source>The release handler evalutes &lt;code&gt;apply(M, F, A)&lt;/code&gt;.</source>
          <target state="translated">Применяются оценки обработчика выпуска &lt;code&gt;apply(M, F, A)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5810b19374ebd0aa36b0ddc3dbb430e23ad41e2" translate="yes" xml:space="preserve">
          <source>The release handler process is a locally registered process on each node. When a release is installed in a distributed system, the release handler on each node must be called. The release installation can be synchronized between nodes. From an operator view, it can be unsatisfactory to specify each node. The aim is to install one release package in the system, no matter how many nodes there are. It is recommended that software management functions are written that take care of this problem. Such a function can have knowledge of the system architecture, so it can contact each individual release handler to install the package.</source>
          <target state="translated">Обработчик выпуска-это локально зарегистрированный процесс на каждом узле.Когда релиз устанавливается в распределенной системе,необходимо вызывать обработчик релизов на каждом узле.Установка релиза может быть синхронизирована между узлами.С точки зрения оператора,указывать каждый узел может быть неудовлетворительно.Целью является установка одного пакета выпуска в систему,независимо от количества узлов.Рекомендуется написать функции управления программным обеспечением,которые бы решали эту проблему.Такая функция может обладать знаниями об архитектуре системы,поэтому она может связаться с каждым отдельным обработчиком выпуска для установки пакета.</target>
        </trans-unit>
        <trans-unit id="1d789ea08f7bf36cfa8a0d6324e5d810748f8d2a" translate="yes" xml:space="preserve">
          <source>The release handler suspends, asks for code change, and resumes processes by calling the functions &lt;code&gt;sys:suspend/1,2&lt;/code&gt;, &lt;code&gt;sys:change_code/4,5&lt;/code&gt;, and &lt;code&gt;sys:resume/1,2&lt;/code&gt;, respectively.</source>
          <target state="translated">Обработчик выпуска приостанавливает, запрашивает изменение кода и возобновляет процессы, вызывая функции &lt;code&gt;sys:suspend/1,2&lt;/code&gt; , &lt;code&gt;sys:change_code/4,5&lt;/code&gt; и &lt;code&gt;sys:resume/1,2&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="bd503abbdadf3c3e7f2d6dab188fa7588e61f6b8" translate="yes" xml:space="preserve">
          <source>The release handling instructions for adding, removing, and restarting applications apply to primary applications only. There are no corresponding instructions for included applications. However, since an included application is really a supervision tree with a topmost supervisor, started as a child process to a supervisor in the including application, a &lt;code&gt;relup&lt;/code&gt; file can be manually created.</source>
          <target state="translated">Инструкции по управлению выпуском для добавления, удаления и перезапуска приложений относятся только к основным приложениям. Для включенных приложений нет соответствующих инструкций. Однако, поскольку включенное приложение на самом деле является деревом наблюдения с самым верхним супервизором, запущенным как дочерний процесс для супервизора во включающем приложении, файл &lt;code&gt;relup&lt;/code&gt; может быть создан вручную.</target>
        </trans-unit>
        <trans-unit id="3463f0904903fe50d36a8d31b7efcf59b3d94b17" translate="yes" xml:space="preserve">
          <source>The release of a maintenance patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; version while the release of an emergency patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Patch&amp;gt;&lt;/code&gt; version. This is however not necessarily always the case since changes of OTP versions are based on the actual changes in the code and not based on whether the patch was planned or not. For more information see the &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; section above.</source>
          <target state="translated">Выпуск пакета исправлений обслуживания обычно подразумевает увеличение версии OTP &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; , тогда как выпуск пакета аварийных исправлений обычно подразумевает увеличение версии OTP &lt;code&gt;&amp;lt;Patch&amp;gt;&lt;/code&gt; . Однако это не всегда так, поскольку изменения версий OTP основаны на фактических изменениях в коде, а не на том, был ли запланирован патч или нет. Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; &amp;raquo; выше.</target>
        </trans-unit>
        <trans-unit id="2f38068eb9610d0b0cbd1a9bc480aef4c5039577" translate="yes" xml:space="preserve">
          <source>The release package by default contains:</source>
          <target state="translated">Пакет выпуска по умолчанию содержит:</target>
        </trans-unit>
        <trans-unit id="1ddf2f95ffb2351a4606d3527df333525dbf30af" translate="yes" xml:space="preserve">
          <source>The release package can be &lt;strong&gt;unpacked&lt;/strong&gt;, which extracts the files. An unpacked release can be &lt;strong&gt;installed&lt;/strong&gt;. The currently used version of the release is then upgraded or downgraded to the specified version by evaluating the instructions in the &lt;code&gt;relup&lt;/code&gt; file. An installed release can be made &lt;strong&gt;permanent&lt;/strong&gt;. Only one permanent release can exist in the system, and this release is used if the system is restarted. An installed release, except the permanent one, can be &lt;strong&gt;removed&lt;/strong&gt;. When a release is removed, all files belonging to that release only are deleted.</source>
          <target state="translated">Пакет выпуска можно &lt;strong&gt;распаковать&lt;/strong&gt; , при этом файлы будут извлечены. Можно &lt;strong&gt;установить&lt;/strong&gt; распакованный выпуск . Текущая используемая версия выпуска затем обновляется или понижается до указанной версии путем оценки инструкций в файле &lt;code&gt;relup&lt;/code&gt; . Установленный выпуск можно сделать &lt;strong&gt;постоянным&lt;/strong&gt; . В системе может существовать только один постоянный выпуск, и этот выпуск используется при перезапуске системы. Установленный выпуск, кроме постоянного, можно &lt;strong&gt;удалить&lt;/strong&gt; . При удалении выпуска удаляются все файлы, принадлежащие только этому выпуску.</target>
        </trans-unit>
        <trans-unit id="e9b6c34e733e444ceb133eb0558e587c5c6c416c" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is compared with all release resource files &lt;code&gt;Name2.rel&lt;/code&gt;, specified in &lt;code&gt;UpFrom&lt;/code&gt; and &lt;code&gt;DownTo&lt;/code&gt;. For each such pair, the following is deducted:</source>
          <target state="translated">Файл ресурсов выпуска &lt;code&gt;Name.rel&lt;/code&gt; сравнивается со всеми файлами ресурсов выпуска &lt;code&gt;Name2.rel&lt;/code&gt; , указанными в &lt;code&gt;UpFrom&lt;/code&gt; и &lt;code&gt;DownTo&lt;/code&gt; . На каждую такую ​​пару вычитается:</target>
        </trans-unit>
        <trans-unit id="7359f911881a84330db66568ed156a10773a2e38" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine the version and modules of each application (keys &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;).</source>
          <target state="translated">Файл ресурсов выпуска &lt;code&gt;Name.rel&lt;/code&gt; считывается, чтобы определить, какие приложения включены в выпуск. Затем &lt;code&gt;App.app&lt;/code&gt; соответствующие файлы ресурсов приложения App.app , чтобы определить версию и модули каждого приложения (ключи &lt;code&gt;vsn&lt;/code&gt; и &lt;code&gt;modules&lt;/code&gt; , см. &lt;code&gt;app(4)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="20395e6c5537d7e841a28ec3e32487d66bee87cf" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine which modules to be loaded, and if and how the applications are to be started. (Keys &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;.</source>
          <target state="translated">Файл ресурсов выпуска &lt;code&gt;Name.rel&lt;/code&gt; считывается, чтобы определить, какие приложения включены в выпуск. Затем &lt;code&gt;App.app&lt;/code&gt; соответствующие файлы ресурсов приложения App.app , чтобы определить, какие модули должны быть загружены, а также должны ли и как запускаться приложения. (Ключи &lt;code&gt;modules&lt;/code&gt; и &lt;code&gt;mod&lt;/code&gt; см. В &lt;code&gt;app(4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eefac0bf9340fed3bf570202c8d7eea59ecf327" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system) and the file is therefore now instead duplicated in the tar file so no manual copying is necessary.</source>
          <target state="translated">Файл ресурсов выпуска &lt;code&gt;mysystem.rel&lt;/code&gt; дублируется в файле tar. Первоначально этот файл хранился только в каталоге &lt;code&gt;releases&lt;/code&gt; чтобы позволить &lt;code&gt;release_handler&lt;/code&gt; извлечь этот файл отдельно. После распаковки tar-файла &lt;code&gt;release_handler&lt;/code&gt; автоматически скопирует файл в Release &lt;code&gt;releases/FIRST&lt;/code&gt; . Однако иногда tar-файл распаковывается без использования &lt;code&gt;release_handler&lt;/code&gt; (например, при распаковке первой целевой системы), и поэтому файл теперь дублируется в tar-файле, поэтому ручное копирование не требуется.</target>
        </trans-unit>
        <trans-unit id="7c80217b964ae1583cdca52537267d331ce978fc" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system). The file is therefore now instead duplicated in the tar file so no manual copying is needed.</source>
          <target state="translated">Файл ресурсов выпуска &lt;code&gt;mysystem.rel&lt;/code&gt; дублируется в файле tar. Первоначально этот файл хранился только в каталоге &lt;code&gt;releases&lt;/code&gt; чтобы позволить &lt;code&gt;release_handler&lt;/code&gt; извлечь этот файл отдельно. После распаковки tar-файла &lt;code&gt;release_handler&lt;/code&gt; автоматически скопирует файл в Release &lt;code&gt;releases/FIRST&lt;/code&gt; . Однако иногда tar-файл распаковывается без использования &lt;code&gt;release_handler&lt;/code&gt; (например, при распаковке первой целевой системы). Таким образом, теперь файл дублируется в tar-файле, поэтому ручное копирование не требуется.</target>
        </trans-unit>
        <trans-unit id="5ef92a0cda894349ddeef7379b503e49a64bdb11" translate="yes" xml:space="preserve">
          <source>The release resource file is to be called &lt;code&gt;Name.rel&lt;/code&gt;.</source>
          <target state="translated">Файл ресурсов выпуска должен называться &lt;code&gt;Name.rel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5471bf3aa3be047811963240dcf5d4400757add" translate="yes" xml:space="preserve">
          <source>The release resource file is used to generate &lt;code&gt;&lt;a href=&quot;#boot&quot;&gt;boot scripts&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#pack&quot;&gt;release packages&lt;/a&gt;&lt;/code&gt;. A system that is transferred to and installed at another site is called a &lt;strong&gt;target system&lt;/strong&gt;. How to use a release package to create a target system is described in System Principles.</source>
          <target state="translated">Файл ресурсов выпуска используется для создания &lt;code&gt;&lt;a href=&quot;#boot&quot;&gt;boot scripts&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#pack&quot;&gt;release packages&lt;/a&gt;&lt;/code&gt; . Система, которая переносится на другой сайт и устанавливается на нем, называется &lt;strong&gt;целевой системой&lt;/strong&gt; . Как использовать пакет выпуска для создания целевой системы, описано в Принципах системы.</target>
        </trans-unit>
        <trans-unit id="d5c96a363d42d5cbc941b3bdee5cae6301bb427b" translate="yes" xml:space="preserve">
          <source>The releases directory (&lt;code&gt;&quot;/usr/local/erl-target/releases&quot;&lt;/code&gt;</source>
          <target state="translated">Каталог выпусков ( &lt;code&gt;&quot;/usr/local/erl-target/releases&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe0ac93c2480f7003ed1b072da8ef587cc263275" translate="yes" xml:space="preserve">
          <source>The releases page is incomplete and very experimental.</source>
          <target state="translated">Страница релизов является неполной и очень экспериментальной.</target>
        </trans-unit>
        <trans-unit id="fca42c3d6efd5f3bf7036a14ae119c2bac9a56a9" translate="yes" xml:space="preserve">
          <source>The remaining Erlang script file can either contain Erlang &lt;strong&gt;source code&lt;/strong&gt;, an &lt;strong&gt;inlined beam file&lt;/strong&gt;, or an &lt;strong&gt;inlined archive file&lt;/strong&gt;.</source>
          <target state="translated">Оставшийся файл сценария Erlang может содержать либо &lt;strong&gt;исходный код&lt;/strong&gt; Erlang , либо &lt;strong&gt;встроенный файл луча&lt;/strong&gt; , либо &lt;strong&gt;встроенный файл архива&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="839a2a9520ffa3810212231d0366ad625cbea04a" translate="yes" xml:space="preserve">
          <source>The remaining arguments are pointers to callback functions that can be used to initialize the library. They are not used in this simple example, hence they are all set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Остальные аргументы - это указатели на функции обратного вызова, которые можно использовать для инициализации библиотеки. В этом простом примере они не используются, поэтому все они имеют &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="848fe4988b3ebd532672ddf229d63bf17a87732d" translate="yes" xml:space="preserve">
          <source>The remaining filters only show function calls and function returns. All other trace message are discarded. To get the most out of these filters, &lt;code&gt;et_viewer&lt;/code&gt; must know the caller of each function and the time of return. This can be obtained using both the &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; flags when tracing. Notice that flag &lt;code&gt;return_to&lt;/code&gt; only works with local call trace, that is, when trace patterns are set with &lt;code&gt;ttb:tpl&lt;/code&gt;.</source>
          <target state="translated">Остальные фильтры показывают только вызовы функций и возврат функций. Все остальные сообщения трассировки отбрасываются. Чтобы получить максимальную отдачу от этих фильтров, &lt;code&gt;et_viewer&lt;/code&gt; должен знать вызывающего каждую функцию и время возврата. Это можно получить с помощью флагов &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;return_to&lt;/code&gt; при трассировке. Обратите внимание, что флаг &lt;code&gt;return_to&lt;/code&gt; работает только с локальной трассировкой вызовов, то есть когда шаблоны трассировки установлены с помощью &lt;code&gt;ttb:tpl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5ca4f7571fd6b542abb7d48ce27d3b2fc439a8" translate="yes" xml:space="preserve">
          <source>The remote host &lt;code&gt;node&lt;/code&gt; is unreachable.</source>
          <target state="translated">Удаленный хост- &lt;code&gt;node&lt;/code&gt; недоступен.</target>
        </trans-unit>
        <trans-unit id="d37d54820fa9581d298dd9136f05c8334760d7a0" translate="yes" xml:space="preserve">
          <source>The remote mid (of the connection). &lt;code&gt;megaco_mid()&lt;/code&gt;.</source>
          <target state="translated">Удаленный мид (соединения). &lt;code&gt;megaco_mid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bedfee181fa2c0cf108bcb6897f0543af23fb21e" translate="yes" xml:space="preserve">
          <source>The remote node &lt;code&gt;Node&lt;/code&gt; does not support this &lt;code&gt;erpc&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba62da86bb3f99cdfb2879e83169ae1e52ad3de4" translate="yes" xml:space="preserve">
          <source>The remote process was monitoring the local process at the time of the crash.</source>
          <target state="translated">Удаленный процесс контролировал локальный процесс в момент аварии.</target>
        </trans-unit>
        <trans-unit id="f6bb61a4811825e7030b032141e0fc103f13c80c" translate="yes" xml:space="preserve">
          <source>The remote username of the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Удаленное имя пользователя клиента ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="87cb1661c7bb66858ea881ceaeef4b6250aa903b" translate="yes" xml:space="preserve">
          <source>The renaming affects only remote calls (also when disguised by import declarations); local calls within a module are not affected, and no function definitions are renamed. Since the arity cannot change, the new name is represented by &lt;code&gt;{NewModule, NewName}&lt;/code&gt; only. Only calls matching the specified arity will match; multiple entries are necessary for renaming calls to functions that have the same module and function name, but different arities.</source>
          <target state="translated">Переименование влияет только на удаленные вызовы (даже если оно замаскировано объявлениями импорта); локальные вызовы внутри модуля не затрагиваются, и определения функций не переименовываются. Поскольку арность не может измениться, новое имя представлено только &lt;code&gt;{NewModule, NewName}&lt;/code&gt; . Только вызовы, соответствующие указанной арности, будут соответствовать; несколько записей необходимы для переименования вызовов функций, которые имеют одинаковое имя модуля и функции, но разную арность.</target>
        </trans-unit>
        <trans-unit id="7db0a5b5bf696ee011ef06c85df210d03986dfa2" translate="yes" xml:space="preserve">
          <source>The repair time is still proportional to the number of records in the file, but Dets repairs used to be much slower in the past. Dets has been massively rewritten and improved.</source>
          <target state="translated">Время ремонта все еще пропорционально количеству записей в файле,но раньше ремонт Dets был гораздо медленнее.Дефекты были массово переписаны и улучшены.</target>
        </trans-unit>
        <trans-unit id="c2c4a2bf8d01876589d2d63a72ca740faf035967" translate="yes" xml:space="preserve">
          <source>The replacement string can contain the special character &lt;code&gt;&amp;amp;&lt;/code&gt;, which inserts the whole matching expression in the result, and the special sequence &lt;code&gt;\&lt;/code&gt;N (where N is an integer &amp;gt; 0), &lt;code&gt;\g&lt;/code&gt;N, or &lt;code&gt;\g{&lt;/code&gt;N&lt;code&gt;}&lt;/code&gt;, resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted.</source>
          <target state="translated">Строка замены может содержать специальный символ &lt;code&gt;&amp;amp;&lt;/code&gt; , который вставляет все соответствующее выражение в результат, и специальную последовательность &lt;code&gt;\&lt;/code&gt; N (где N - целое число&amp;gt; 0), &lt;code&gt;\g&lt;/code&gt; N или &lt;code&gt;\g{&lt;/code&gt; N &lt;code&gt;}&lt;/code&gt; , в результате чего номер подвыражения N вставляется в результат. Если регулярное выражение не создает подвыражения с таким числом, ничего не вставляется.</target>
        </trans-unit>
        <trans-unit id="faa500aee01a190343697194d03c438c2c602d2a" translate="yes" xml:space="preserve">
          <source>The reply will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="translated">Ответ будет доставлен пользователю через вызов функции обратного вызова &lt;code&gt;handle_pdu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4f1cc106b1e894d4c96e8e317dc640fccb08d0" translate="yes" xml:space="preserve">
          <source>The reply, if it arrives, will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="translated">Ответ, если он поступит, будет доставлен пользователю через вызов функции обратного вызова &lt;code&gt;handle_pdu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6b172375ebcae29181dbc0b6ea9f54803c80f5" translate="yes" xml:space="preserve">
          <source>The report browser is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; defined in STDLIB.</source>
          <target state="translated">Обозреватель отчетов используется для просмотра и форматирования отчетов об ошибках, написанных обработчиком журнала ошибок &lt;code&gt;log_mf_h&lt;/code&gt; , определенным в STDLIB.</target>
        </trans-unit>
        <trans-unit id="e834f0bfe944504c8960d652328e61c3c5a3b766" translate="yes" xml:space="preserve">
          <source>The report callback must be a fun with one or two arguments. If it takes one argument, this is the report itself, and the fun returns a format string and arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462562f8f81a87927a15414f09bedcc8da9f2dcf" translate="yes" xml:space="preserve">
          <source>The reports are matched using the &lt;code&gt;proplists&lt;/code&gt; module in STDLIB. The report must be a proplist to be matched against any of the filters.</source>
          <target state="translated">Отчеты сопоставляются с &lt;code&gt;proplists&lt;/code&gt; модуля proplists в STDLIB. Отчет должен быть проплистом, чтобы его можно было сопоставить с любым из фильтров.</target>
        </trans-unit>
        <trans-unit id="3841a22e3cae4249c1648495d6d06b7dc360f0ae" translate="yes" xml:space="preserve">
          <source>The representation for an empty list, that is, the Erlang syntax &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Представление пустого списка, то есть синтаксис Erlang &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90aa0c68b7c44e3dde7bae01a4485de7f117fcb2" translate="yes" xml:space="preserve">
          <source>The representation of a Diameter message as passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; or returned from a &lt;code&gt;handle_request/3&lt;/code&gt; callback. The record representation is as outlined in &lt;code&gt;&lt;a href=&quot;diameter_dict#MESSAGE_RECORDS&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;: a message as defined in a dictionary file is encoded as a record with one field for each component AVP. Equivalently, a message can also be encoded as a list whose head is the atom-valued message name (as specified in the relevant dictionary file) and whose tail is either a list of AVP name/values pairs or a map with values keyed on AVP names. The format at decode is determined by &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode_format&lt;/a&gt;&lt;/code&gt;. Any of the formats is accepted at encode.</source>
          <target state="translated">Представление сообщения Diameter, переданного в Diameter &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; или возвращенного &lt;code&gt;handle_request/3&lt;/code&gt; . Представление записи описано в &lt;code&gt;&lt;a href=&quot;diameter_dict#MESSAGE_RECORDS&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; : сообщение, определенное в файле словаря, кодируется как запись с одним полем для каждого компонента AVP. Эквивалентно, сообщение также может быть закодировано как список, голова которого представляет собой имя сообщения с атомным значением (как указано в соответствующем файле словаря), а хвост - либо список пар имя / значение AVP, либо карта со значениями, привязанными к AVP имена. Формат при декодировании определяется &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode_format&lt;/a&gt;&lt;/code&gt; . При кодировании принимается любой из форматов.</target>
        </trans-unit>
        <trans-unit id="82a411d117dc57a26bcb9e1f9d378e3ca11f15b7" translate="yes" xml:space="preserve">
          <source>The req_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">Аргументом req_data()для этой функции является термин Erlang,возвращаемый handle_trans_request/3.</target>
        </trans-unit>
        <trans-unit id="23e7ef624fc47862089915bb4bc3e847e83284d8" translate="yes" xml:space="preserve">
          <source>The request &lt;code&gt;Type&lt;/code&gt; as passed to &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt;. This is only mandatory when the connection has been initiated by this node. That is, the connection is set up via &lt;code&gt;setup/5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; запроса, переданный в &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; . Это обязательно только в том случае, если соединение было инициировано этим узлом. То есть соединение настраивается через &lt;code&gt;setup/5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb7e74979895ad253263a88483e0213dfefa217d" translate="yes" xml:space="preserve">
          <source>The request is &lt;strong&gt;ignored&lt;/strong&gt; because &lt;code&gt;net_kernel&lt;/code&gt; is busy changing &lt;code&gt;net_ticktime&lt;/code&gt; to &lt;code&gt;NewNetTicktime&lt;/code&gt; seconds.</source>
          <target state="translated">Запрос &lt;strong&gt;игнорируется,&lt;/strong&gt; потому что &lt;code&gt;net_kernel&lt;/code&gt; занят изменением &lt;code&gt;net_ticktime&lt;/code&gt; на &lt;code&gt;NewNetTicktime&lt;/code&gt; секунд.</target>
        </trans-unit>
        <trans-unit id="8e8fce11312bcfaed7ec364cadd3a5f46ff33d51" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. &lt;code&gt;cast&lt;/code&gt;, and thus &lt;code&gt;free&lt;/code&gt;, then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">Запрос оформляется в виде сообщения и отправляется на &lt;code&gt;gen_server&lt;/code&gt; . &lt;code&gt;cast&lt;/code&gt; и, таким образом, &lt;code&gt;free&lt;/code&gt; , затем возвращает &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03229c07c994ef8bacaf94e79a42852e8c89a6f8" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_call(Request, From, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{reply,Reply,State1}&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is the reply that is to be sent back to the client, and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">Запрос оформляется в виде сообщения и отправляется на &lt;code&gt;gen_server&lt;/code&gt; . Когда запрос получен, &lt;code&gt;gen_server&lt;/code&gt; вызывает &lt;code&gt;handle_call(Request, From, State)&lt;/code&gt; , который, как ожидается, вернет кортеж &lt;code&gt;{reply,Reply,State1}&lt;/code&gt; . &lt;code&gt;Reply&lt;/code&gt; - это ответ, который должен быть отправлен обратно клиенту, а &lt;code&gt;State1&lt;/code&gt; - это новое значение для состояния &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6363c9ddb932fe00abea80ec408ab4c1cea65ddc" translate="yes" xml:space="preserve">
          <source>The request line as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Строка запроса, исходящая от клиента ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2e51eb4e82ec44b07e0af2fe79e985e993a82848" translate="yes" xml:space="preserve">
          <source>The request line exactly as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Строка запроса в точности такая, как она поступила от клиента ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3416c5291401473a7cf1526d471fda57329a38c" translate="yes" xml:space="preserve">
          <source>The request may have reached the server and may have been performed. However, no answer was received from the server within the expected time.</source>
          <target state="translated">Запрос мог дойти до сервера и,возможно,был выполнен.Однако,ответ от сервера не был получен в течение ожидаемого времени.</target>
        </trans-unit>
        <trans-unit id="0609829732d849e2037ce824c383ed1a7b424ab2" translate="yes" xml:space="preserve">
          <source>The request was accepted and &lt;code&gt;SupervisorPid&lt;/code&gt; is the process identifier of the connection supervisor process (which is created in the &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; callback).</source>
          <target state="translated">Запрос был принят, а &lt;code&gt;SupervisorPid&lt;/code&gt; - это идентификатор процесса супервизора соединения (который создается в &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d76fc415bd89f84963ae3ee419c891159d20a10c" translate="yes" xml:space="preserve">
          <source>The request was rejected. This is a fatal error. The acceptor process should terminate.</source>
          <target state="translated">Запрос был отклонен.Это фатальная ошибка.Процесс акцепта должен быть прерван.</target>
        </trans-unit>
        <trans-unit id="0af04869dc460d9fffda5c9cafebc1aa148f650e" translate="yes" xml:space="preserve">
          <source>The requests served by the EPMD are summarized in the following figure.</source>
          <target state="translated">Запросы,обслуживаемые EPMD,обобщены на следующем рисунке.</target>
        </trans-unit>
        <trans-unit id="766cb0fbb7f32280a11f9d0fcaaf21cc2abaa201" translate="yes" xml:space="preserve">
          <source>The resources can send notifications to the manager as well. Examples of notifications are events and alarms. The resource needs to generate protocol-independent notifications. The following picture illustrates how this is achieved:</source>
          <target state="translated">Ресурсы могут отправлять уведомления и менеджеру.Примерами уведомлений являются события и сигналы тревоги.Ресурс должен генерировать уведомления,не зависящие от протокола.Следующая картинка иллюстрирует,как это достигается:</target>
        </trans-unit>
        <trans-unit id="2c83b49760a86aadaf5f3b2f1036293a1e089f52" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;DUMP_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">Ответ на &lt;code&gt;DUMP_REQ&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a65d28bc38322c3bd1cfbf2bf8711df7091101cd" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;KILL_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">Ответ на &lt;code&gt;KILL_REQ&lt;/code&gt; следующий:</target>
        </trans-unit>
        <trans-unit id="b3c2ac7160df49c4588c05e57b87e5aff9422c1f" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;NAMES_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">Ответ на &lt;code&gt;NAMES_REQ&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="0dd3fa630ddc8b538f974287e27afabd12f4340d" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;STOP_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">Ответ на &lt;code&gt;STOP_REQ&lt;/code&gt; следующий:</target>
        </trans-unit>
        <trans-unit id="cbc3d39894fa2184326a46cadccf5d5f95e1ce70" translate="yes" xml:space="preserve">
          <source>The response message &lt;code&gt;ALIVE2_RESP&lt;/code&gt; is as follows:</source>
          <target state="translated">Ответное сообщение &lt;code&gt;ALIVE2_RESP&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="218f2ad1fce75712661ee092a6b642bcf421a9a3" translate="yes" xml:space="preserve">
          <source>The response message is either &lt;code&gt;ALIVE2_X_RESP&lt;/code&gt; or &lt;code&gt;ALIVE2_RESP&lt;/code&gt; depending on distribution version. If both the node and EPMD support distribution version 6 then the response is &lt;code&gt;ALIVE2_X_RESP&lt;/code&gt; otherwise it is the older &lt;code&gt;ALIVE2_RESP&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6677705b73ca8640b5bfd49e04c30a99a6b85930" translate="yes" xml:space="preserve">
          <source>The response shows that the file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been created. This is called a backup file, and it contains an initial schema. If more than one node in the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; had been specified, identical backup files would have been created on all nodes.</source>
          <target state="translated">Ответ показывает, что файл &lt;code&gt;FALLBACK.BUP&lt;/code&gt; создан. Это называется файлом резервной копии, и он содержит исходную схему. Если бы в функции &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; было указано более одного узла, на всех узлах были бы созданы идентичные файлы резервных копий.</target>
        </trans-unit>
        <trans-unit id="a4067e1f0937adfc4de129b497938ce1fa751f3a" translate="yes" xml:space="preserve">
          <source>The rest of the driver is more or less UDS-specific and not of general interest.</source>
          <target state="translated">Остальные водители более или менее специфичны для UDS и не представляют общего интереса.</target>
        </trans-unit>
        <trans-unit id="b248e72516f25e453000ce440baff629617e3ca9" translate="yes" xml:space="preserve">
          <source>The rest of this section is therefore deliberately not adapted for reading by the Erlang programmer, but the examples can help in understanding NAMES as they can be used by (*SKIP).</source>
          <target state="translated">Поэтому остальная часть этого раздела намеренно не адаптирована для чтения программистом Erlang,но примеры могут помочь в понимании NAMES,так как они могут быть использованы (*SKIP).</target>
        </trans-unit>
        <trans-unit id="8d01a53de4ed7d8cd3faf10a1aef24441bc36b6e" translate="yes" xml:space="preserve">
          <source>The restart strategy is specified by the &lt;code&gt;strategy&lt;/code&gt; key in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="translated">Стратегия перезапуска задается ключом &lt;code&gt;strategy&lt;/code&gt; в карте флагов супервизора, возвращаемой функцией обратного вызова &lt;code&gt;init&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="536cf89c0e01376b78ab828ece36006c915f41c1" translate="yes" xml:space="preserve">
          <source>The restoration is performed as a single transaction. If the database is large, it cannot always be restored online. The old database must then be restored by installing a fallback, followed by a restart.</source>
          <target state="translated">Восстановление осуществляется как единая операция.Если база данных большая,ее не всегда можно восстановить в режиме онлайн.Старая база данных должна быть восстановлена путем установки резервной копии с последующим перезапуском.</target>
        </trans-unit>
        <trans-unit id="afdaf9dae668c3f7bdc0ca10a94463ffda8086c1" translate="yes" xml:space="preserve">
          <source>The restriction operators are defined for closures as well; &lt;code&gt;closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is interpreted as the direct or indirect function calls from the &lt;code&gt;xref&lt;/code&gt; module, while the interpretation of &lt;code&gt;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is the set of direct calls from &lt;code&gt;xref&lt;/code&gt;. If some graph is to be used in several graph analyses, it saves time to assign the &lt;code&gt;digraph&lt;/code&gt; representation of the graph to a user variable, and then make sure that every graph analysis operates on that variable instead of the list representation of the graph.</source>
          <target state="translated">Операторы ограничения также определены для замыканий; &lt;code&gt;closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; интерпретируется как прямой или косвенный вызов функции из модуля &lt;code&gt;xref&lt;/code&gt; , тогда как интерпретация &lt;code&gt;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; - это набор прямых вызовов из &lt;code&gt;xref&lt;/code&gt; . Если какой - то график должен быть использован в течение нескольких анализов графика, это экономит время , чтобы назначить &lt;code&gt;digraph&lt;/code&gt; представление графа к пользовательской переменной, а затем убедиться , что каждый анализ график работает на этой переменной , вместо списка представления графа.</target>
        </trans-unit>
        <trans-unit id="603dc83e6b9810f3ec3760b7629ba1cc75f2b142" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Excl_Message&lt;/code&gt; has the same structure as a complete decode would have, except for the parts of the top type that were not decoded. The undecoded parts are on their places in the structure on format &lt;code&gt;{Type_Key,Undecoded_Value}&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;Excl_Message&lt;/code&gt; имеет ту же структуру, что и полное декодирование, за исключением частей верхнего типа, которые не были декодированы. Недекодированные части находятся на своих местах в структуре в формате &lt;code&gt;{Type_Key,Undecoded_Value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5bf40f10fe2bffb0315d5af0604d375695096e5" translate="yes" xml:space="preserve">
          <source>The result above are the fastest of these configurations for each codec. The figures presented are the average of all used messages.</source>
          <target state="translated">Вышеприведенные результаты являются самыми быстрыми из этих конфигураций для каждого кодека.Представленные цифры являются усредненными по всем используемым сообщениям.</target>
        </trans-unit>
        <trans-unit id="32893fd2ec1b1eb00ce0a52b29ac7e0d97610291" translate="yes" xml:space="preserve">
          <source>The result contains information about the following &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="translated">Результат содержит информацию о следующих &lt;code&gt;Item&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2e8b477b4aed021fef6ebb0a1b67b1473cc13b37" translate="yes" xml:space="preserve">
          <source>The result from each test case is recorded in a dedicated HTML log file, created for the particular test run. An overview page displays each test case represented by a table row showing total execution time, if the case was successful, failed, or skipped, plus an optional user comment. For a failed test case, the reason for termination is also printed in the comment field. The overview page has a link to each test case log file, providing simple navigation with any standard HTML browser.</source>
          <target state="translated">Результат каждого тестового случая записывается в специальный HTML лог-файл,созданный для конкретного тестового запуска.Страница обзора отображает каждый тестовый случай в виде строки таблицы,показывающей общее время выполнения,если случай был успешным,неудачным или пропущенным,плюс необязательный комментарий пользователя.Для случая неудачи теста,причина прекращения также печатается в поле комментария.Страница обзора имеет ссылку на каждый лог-файл тестового случая,обеспечивая простую навигацию с помощью любого стандартного HTML-браузера.</target>
        </trans-unit>
        <trans-unit id="200d78a9c16efccfba75389c2e312a153f45a8e8" translate="yes" xml:space="preserve">
          <source>The result from running the test is printed in log files in HTML format (stored in unique log directories on a different level). The following illustration shows the log file structure:</source>
          <target state="translated">Результат выполнения теста распечатывается в лог-файлах в формате HTML (хранится в уникальных лог-каталогах другого уровня).На следующей иллюстрации показана структура лог-файла:</target>
        </trans-unit>
        <trans-unit id="374ecad7f3c9133bbe397289798ccaaa43ce127d" translate="yes" xml:space="preserve">
          <source>The result is &quot;normalized&quot;:</source>
          <target state="translated">Результат &quot;нормализован&quot;:</target>
        </trans-unit>
        <trans-unit id="859cd92f58e2a9a54c26d7e8f5204e954bdffebd" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt;. The fun is straightforward, so the only problem is that all the data from the table must be transferred from the table to the calling process for filtering. That is inefficient compared to the &lt;code&gt;ets:match/2&lt;/code&gt; call where the filtering can be done &quot;inside&quot; the emulator and only the result is transferred to the process.</source>
          <target state="translated">Результат: &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt; . Забава проста, поэтому единственная проблема заключается в том, что все данные из таблицы должны быть переданы из таблицы в вызывающий процесс для фильтрации. Это неэффективно по сравнению с вызовом &lt;code&gt;ets:match/2&lt;/code&gt; , где фильтрация может выполняться &amp;laquo;внутри&amp;raquo; эмулятора, а процессу передается только результат.</target>
        </trans-unit>
        <trans-unit id="3cac868d8974153152b55d9efa1e40ff1114e69d" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;]&lt;/code&gt;, as expected. The equivalent expression using a handwritten match specification would look like this:</source>
          <target state="translated">Результатом будет &lt;code&gt;[&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;]&lt;/code&gt; , как и ожидалось. Эквивалентное выражение, использующее рукописную спецификацию соответствия, будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="d8636350d1356e8fb3f319b7140bff8ef6a16d4e" translate="yes" xml:space="preserve">
          <source>The result is a list of characters.</source>
          <target state="translated">В результате получается список символов.</target>
        </trans-unit>
        <trans-unit id="1bedbbe8e33126fcebf6fc95fcd5a51821596e48" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt; and &lt;code&gt;Files&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details).</source>
          <target state="translated">Результатом является пара &lt;code&gt;{Tree, Stubs}&lt;/code&gt; , где &lt;code&gt;Tree&lt;/code&gt; представляет исходный код, который является результатом слияния всего кода в &lt;code&gt;Sources&lt;/code&gt; и &lt;code&gt;Files&lt;/code&gt; , а &lt;code&gt;Stubs&lt;/code&gt; представляет собой список дескрипторов модулей-заглушек (подробности см. В &lt;code&gt;merge_sources/3&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="389d84201c8d9fc72ea3759187e87ed97f94a3cc" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see below).</source>
          <target state="translated">Результатом является пара &lt;code&gt;{Tree, Stubs}&lt;/code&gt; , где &lt;code&gt;Tree&lt;/code&gt; представляет исходный код, который является результатом слияния всего кода в &lt;code&gt;Sources&lt;/code&gt; , а &lt;code&gt;Stubs&lt;/code&gt; представляет собой список дескрипторов модуля-заглушки (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="9feb7727d1cbada310f559306bd354a9d4c4914e" translate="yes" xml:space="preserve">
          <source>The result is a valid URI where all the special characters are encoded as defined by the standard. Applying &lt;code&gt;&lt;a href=&quot;uri_string#parse-1&quot;&gt;uri_string:parse/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; on the URI returns the original input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1812142f22d2ec8fea49815c861b9d307af9e096" translate="yes" xml:space="preserve">
          <source>The result is an utf8 encoded binary.</source>
          <target state="translated">В результате получается двоичный файл в кодировке utf8.</target>
        </trans-unit>
        <trans-unit id="163326ca75ef4e4877fd05e7489373dbafc7e29a" translate="yes" xml:space="preserve">
          <source>The result is as follows:</source>
          <target state="translated">Результат следующий:</target>
        </trans-unit>
        <trans-unit id="96bc7dfc5e6c338c6e144779bbc57eea9d034108" translate="yes" xml:space="preserve">
          <source>The result is given as a list of &quot;strings&quot;, the preferred data type specified in option &lt;code&gt;return&lt;/code&gt; (default &lt;code&gt;iodata&lt;/code&gt;).</source>
          <target state="translated">Результат представлен в виде списка &amp;laquo;строк&amp;raquo;, предпочтительный тип данных указывается в опции &lt;code&gt;return&lt;/code&gt; (по умолчанию &lt;code&gt;iodata&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a11b14a2bfe2822537c2166099b97fcfb96fde0" translate="yes" xml:space="preserve">
          <source>The result is returned in a form suitable for &lt;code&gt;Common Test&lt;/code&gt; test suites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b8ec2df33b161570c66397c14edb7740f68481" translate="yes" xml:space="preserve">
          <source>The result is sent to the calling process as &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt;.</source>
          <target state="translated">Результат отправляется вызывающему процессу как &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a900f3ce3edf2d3ac29948402338e0f316e3fe94" translate="yes" xml:space="preserve">
          <source>The result is that the child process is started by calling &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt;, or actually:</source>
          <target state="translated">В результате дочерний процесс запускается вызовом &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt; или фактически:</target>
        </trans-unit>
        <trans-unit id="0c3fa086682c777519a4e26ac33755c0fbf61a9a" translate="yes" xml:space="preserve">
          <source>The result is that the test case is skipped with &lt;code&gt;Reason&lt;/code&gt; printed to the log file (as described earlier) and &lt;code&gt;ConfigList&lt;/code&gt; is saved for the next test case. &lt;code&gt;ConfigList&lt;/code&gt; can be read using &lt;code&gt;?config(saved_config, Config)&lt;/code&gt;, as described earlier. &lt;code&gt;skip_and_save&lt;/code&gt; can also be returned from &lt;code&gt;init_per_suite&lt;/code&gt;. In this case, the saved data can be read by &lt;code&gt;init_per_suite&lt;/code&gt; in the suite that follows.</source>
          <target state="translated">В результате тестовый пример пропускается, а &lt;code&gt;Reason&lt;/code&gt; печатается в файле журнала (как описано ранее), а &lt;code&gt;ConfigList&lt;/code&gt; сохраняется для следующего тестового примера. &lt;code&gt;ConfigList&lt;/code&gt; можно прочитать с помощью &lt;code&gt;?config(saved_config, Config)&lt;/code&gt; , как описано ранее. &lt;code&gt;skip_and_save&lt;/code&gt; также можно вернуть из &lt;code&gt;init_per_suite&lt;/code&gt; . В этом случае сохраненные данные могут быть прочитаны &lt;code&gt;init_per_suite&lt;/code&gt; в следующем пакете.</target>
        </trans-unit>
        <trans-unit id="fdba3ae36e083e81eed5d03ef22e016c4c681e51" translate="yes" xml:space="preserve">
          <source>The result is that we prefer carriers created by the thread itself, which is good for NUMA performance. And we get more entry points when searching the pool, which will ease contention and clustering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6438c51f348652f581a109f7cba2e137928b4597" translate="yes" xml:space="preserve">
          <source>The result of &lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; is an &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; event that contains, in particular, the new &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Результатом &lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; является событие &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; которое содержит, в частности, новый &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aecf003aab72f86d85e99eebdbc2c40ed626e60a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;ann_make_tree(get_ann(Node), type(Node), subtrees(Node))&lt;/code&gt; (cf. &lt;code&gt;update_tree/2&lt;/code&gt;) represents the same source code text as the original &lt;code&gt;Node&lt;/code&gt;, assuming that &lt;code&gt;subtrees(Node)&lt;/code&gt; yields a nonempty list. However, it does not necessarily have the exact same data representation as &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5e27a92975d3fafc60ea5040ed17aae30c19cc" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt;) represents the same source code text as the original &lt;code&gt;Node&lt;/code&gt;, assuming that &lt;code&gt;subtrees(Node)&lt;/code&gt; yields a nonempty list. However, it does not necessarily have the same data representation as &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; (см. &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; ) представляет тот же текст исходного кода, что и исходный &lt;code&gt;Node&lt;/code&gt; , при условии, что &lt;code&gt;subtrees(Node)&lt;/code&gt; дают непустой список. Однако он не обязательно имеет то же представление данных, что и &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fda083e58e6dac620272874f82b040b4ce2c7034" translate="yes" xml:space="preserve">
          <source>The result of a call to &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Результат вызова &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7071a214aa01dd546b8a4ab94260ea66857afb3e" translate="yes" xml:space="preserve">
          <source>The result of a call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935e389e977d887f2bcee20a8d60eab32fcf9be1" translate="yes" xml:space="preserve">
          <source>The result of a successful parsing is a tuple &lt;code&gt;{DataStructure,M}&lt;/code&gt;. &lt;code&gt;M&lt;/code&gt; is the XML production Misc, which is the mark-up that comes after the element of the document. It is returned &quot;as is&quot;. &lt;code&gt;DataStructure&lt;/code&gt; is an &lt;code&gt;xmlElement&lt;/code&gt; record, that among others have the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;parents&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; like:</source>
          <target state="translated">Результатом успешного синтаксического анализа является кортеж &lt;code&gt;{DataStructure,M}&lt;/code&gt; . &lt;code&gt;M&lt;/code&gt; - это производная XML-информация Misc, которая представляет собой разметку, которая идет после элемента документа. Он возвращается &amp;laquo;как есть&amp;raquo;. &lt;code&gt;DataStructure&lt;/code&gt; - это запись &lt;code&gt;xmlElement&lt;/code&gt; , которая, среди прочего, имеет &lt;code&gt;name&lt;/code&gt; поля , &lt;code&gt;parents&lt;/code&gt; элементы , &lt;code&gt;attributes&lt;/code&gt; и &lt;code&gt;content&lt;/code&gt; например:</target>
        </trans-unit>
        <trans-unit id="3bdf97f5167b1c9ccc6355ba9b80fe296b53b3fa" translate="yes" xml:space="preserve">
          <source>The result of executing the command can be only one line or thousands of lines depending on the command.</source>
          <target state="translated">Результат выполнения команды может быть только одной строкой или тысячами строк в зависимости от команды.</target>
        </trans-unit>
        <trans-unit id="d2d72cb2c002561132566b627196b081cc82e743" translate="yes" xml:space="preserve">
          <source>The result of passing the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) as a value is platform-dependent. On some platforms the variable value is set to the empty string, on others the environment variable is removed.</source>
          <target state="translated">Результат передачи пустой строки ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ) в качестве значения зависит от платформы. На некоторых платформах значение переменной устанавливается равным пустой строке, на других удаляется переменная среды.</target>
        </trans-unit>
        <trans-unit id="176ec7aa5b60be46f47fbe0fe14c3723b77fddec" translate="yes" xml:space="preserve">
          <source>The result of setting up module data is the  &lt;strong id=&quot;call_graph&quot;&gt;Call Graph&lt;/strong&gt;. A (directed) graph consists of a set of vertices and a set of (directed) edges. The edges represent  &lt;strong id=&quot;call&quot;&gt;calls&lt;/strong&gt; (From, To) between functions, modules, applications or releases. From is said to call To, and To is said to be used by From. The vertices of the Call Graph are the functions of all module data: local and exported functions of analyzed modules; used BIFs; used exported functions of library modules; and unknown functions. The functions &lt;code&gt;module_info/0,1&lt;/code&gt; added by the compiler are included among the exported functions, but only when called from some module. The edges are the function calls of all module data. A consequence of the edges being a set is that there is only one edge if a function is locally or externally used several times on one and the same line of code.</source>
          <target state="translated">Результатом настройки данных модуля является &lt;strong id=&quot;call_graph&quot;&gt;График вызовов&lt;/strong&gt; . (Направленный) граф состоит из набора вершин и набора (направленных) ребер. Ребра представляют &lt;strong id=&quot;call&quot;&gt;вызовы&lt;/strong&gt; (От, Куда) между функциями, модулями, приложениями или выпусками. Говорят, что From вызывает To, а To используется From. Вершины Графа вызовов - это функции всех данных модуля: локальные и экспортируемые функции анализируемых модулей; использовали BIF; использовались экспортируемые функции библиотечных модулей; и неизвестные функции. Функции &lt;code&gt;module_info/0,1&lt;/code&gt; добавленные компилятором, включаются в число экспортируемых функций, но только при вызове из какого-либо модуля. Ребра - это вызовы функций всех данных модуля. Следствием того, что ребра являются набором, является то, что существует только одно ребро, если функция локально или извне используется несколько раз в одной и той же строке кода.</target>
        </trans-unit>
        <trans-unit id="b6d992ed8fa86e71532f265c49bcbb4dc25bd864" translate="yes" xml:space="preserve">
          <source>The result of the call is:</source>
          <target state="translated">Результат звонка:</target>
        </trans-unit>
        <trans-unit id="0e48775b9bb091eea31ee6bd2d8fe10d31512d84" translate="yes" xml:space="preserve">
          <source>The result of the port initialization. Can be the same values as the return value of &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt; start&lt;/a&gt;&lt;/code&gt;, that is, any of the error codes or the &lt;code&gt;ErlDrvData&lt;/code&gt; that is to be used for this port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec8dee4e2044b61dfd39541deba480b6fc0f212" translate="yes" xml:space="preserve">
          <source>The result of the port initialization. Can be the same values as the return value of &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt;, that is, any of the error codes or the &lt;code&gt;ErlDrvData&lt;/code&gt; that is to be used for this port.</source>
          <target state="translated">Результат инициализации порта. Могут быть те же значения, что и возвращаемое значение &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; , то есть любой из кодов ошибок или &lt;code&gt;ErlDrvData&lt;/code&gt; , который должен использоваться для этого порта.</target>
        </trans-unit>
        <trans-unit id="cb0f3fa15c3024585e6a3271632a219e04970822" translate="yes" xml:space="preserve">
          <source>The result should be statistically completely unpredictable random values, since the scrambling is cryptographically strong and the period is ridiculously long. But the generated numbers are not to be regarded as cryptographically strong since there is no re-keying schedule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00d452be45830984444ced9bba7583a3c4c38e3" translate="yes" xml:space="preserve">
          <source>The result shows that &amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt; is selected instead of the shorter match &amp;lt;&amp;lt;&quot;bc&quot;&amp;gt;&amp;gt; (which would have given raise to one more match, &amp;lt;&amp;lt;&quot;de&quot;&amp;gt;&amp;gt;). This corresponds to the behavior of POSIX regular expressions (and programs like awk), but is not consistent with alternative matches in &lt;code&gt;re&lt;/code&gt; (and Perl), where instead lexical ordering in the search pattern selects which string matches.</source>
          <target state="translated">Результат показывает, что &amp;lt;&amp;lt; &quot;bcde&quot; &amp;gt;&amp;gt; выбрано вместо более короткого соответствия &amp;lt;&amp;lt; &quot;bc&quot; &amp;gt;&amp;gt; (которое привело бы к еще одному совпадению, &amp;lt;&amp;lt; &quot;de&quot; &amp;gt;&amp;gt;). Это соответствует поведению регулярных выражений POSIX (и программ вроде awk), но не согласуется с альтернативными совпадениями в &lt;code&gt;re&lt;/code&gt; (и Perl), где вместо этого лексический порядок в шаблоне поиска выбирает, какая строка соответствует.</target>
        </trans-unit>
        <trans-unit id="ea7c245c3de8a57733480ff4f2d83525a81309ec" translate="yes" xml:space="preserve">
          <source>The result value is the tuple &lt;code&gt;{ok, List}&lt;/code&gt;, where &lt;code&gt;List&lt;/code&gt; contains the zip archive comment as the first element.</source>
          <target state="translated">Результатом является кортеж &lt;code&gt;{ok, List}&lt;/code&gt; , где &lt;code&gt;List&lt;/code&gt; содержит комментарий архива zip в качестве первого элемента.</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">Результат будет:</target>
        </trans-unit>
        <trans-unit id="3b29ae4d5e694ab8389bf2e90d3d34997e8aec86" translate="yes" xml:space="preserve">
          <source>The result would be:</source>
          <target state="translated">В результате:</target>
        </trans-unit>
        <trans-unit id="f25af746c0ce14546dc62a293ebeb0fa347f8166" translate="yes" xml:space="preserve">
          <source>The result, ValidElement, is the valid element that conforms to the post-schema-validation infoset. When the validator finds an error it tries to continue and reports a list of all errors found. In those cases an unexpected error is found it may cause a single error reason.</source>
          <target state="translated">Результат,ValidElement,является действительным элементом,который соответствует пост-схема-проверки инфосет.Когда валидатор находит ошибку,он пытается продолжить и сообщает список всех найденных ошибок.В этих случаях неожиданная ошибка найдена,что может привести к единственной причине ошибки.</target>
        </trans-unit>
        <trans-unit id="d2c0cc39b7355bd656ef96e65ce99409f2da03cd" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ETERM&lt;/code&gt; struct is converted into the Erlang external term format using the function &lt;code&gt;erl_encode()&lt;/code&gt; from &lt;code&gt;erl_marshal&lt;/code&gt; and sent to Erlang using &lt;code&gt;write_cmd()&lt;/code&gt;:</source>
          <target state="translated">Результирующая структура &lt;code&gt;ETERM&lt;/code&gt; преобразуется в формат внешнего термина Erlang с помощью функции &lt;code&gt;erl_encode()&lt;/code&gt; из &lt;code&gt;erl_marshal&lt;/code&gt; и отправляется в Erlang с помощью &lt;code&gt;write_cmd()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c67db894cf4a73ec37644dab582a90190d4ea154" translate="yes" xml:space="preserve">
          <source>The resulting C program is as follows:</source>
          <target state="translated">Результирующая программа на C выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="76387c891c14647ed37c7c26b256256d64b3a197" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program is as follows:</source>
          <target state="translated">Получившаяся в результате программа Эрланг выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="dde85e9e8384430e4dfd5c8f18cbf940581018ee" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functionality for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">Получившаяся программа Erlang,включающая функционал для остановки порта и обнаружения сбоев в работе порта,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b6e57ccb1752b17aec9fbb1ccc1b61f1ccbf9235" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functions for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">Полученная программа Erlang,включающая в себя функции для остановки порта и обнаружения сбоев в работе порта,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="f57a31a3619a4eacb10fbb043b62b825bcea6a9d" translate="yes" xml:space="preserve">
          <source>The resulting output from the command can be read with &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Полученный результат команды можно прочитать с помощью &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2db028a846be38d0f5b491dc0acc0c2de71c7201" translate="yes" xml:space="preserve">
          <source>The resulting source code is written to a file named &quot;&lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt;&quot; in the current directory, unless otherwise specified by the options &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;outfile&lt;/code&gt; described below.</source>
          <target state="translated">Результирующий исходный код записывается в файл с именем &amp;laquo; &lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt; &amp;raquo; в текущем каталоге, если иное не указано в параметрах &lt;code&gt;dir&lt;/code&gt; и &lt;code&gt;outfile&lt;/code&gt; , описанных ниже.</target>
        </trans-unit>
        <trans-unit id="0942845035c845f735b01ad27ac6b970e03ffed1" translate="yes" xml:space="preserve">
          <source>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting.</source>
          <target state="translated">Полученное синтаксическое дерево,как правило,полезно только для красивой печати или аналогичного визуального форматирования.</target>
        </trans-unit>
        <trans-unit id="3fac0a475f9b69478ab11507fafdcda6f58da223" translate="yes" xml:space="preserve">
          <source>The results from the measurement run (meas) is four excel-compatible textfiles:</source>
          <target state="translated">Результаты измерения (измерение)представляют собой четыре текстовых файла,совместимых с Excel:</target>
        </trans-unit>
        <trans-unit id="f095f8b68579bff1b0c6a6018ac10269dfd93fd4" translate="yes" xml:space="preserve">
          <source>The results of calling the instrumentation are propagated back to the Master Agent.</source>
          <target state="translated">Результаты вызова приборов передаются обратно главному агенту.</target>
        </trans-unit>
        <trans-unit id="f749a3c0024a4110d2c9ec3020e59247d2fa1de4" translate="yes" xml:space="preserve">
          <source>The results, the mstone value(s), are written to stdout.</source>
          <target state="translated">Результаты,значение(и)mstone,записываются в stdout.</target>
        </trans-unit>
        <trans-unit id="68b25f8a798e229a222e707ac3c343b84eeef3a3" translate="yes" xml:space="preserve">
          <source>The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</source>
          <target state="translated">Возврат этой функции представляет собой строку с версией PCRE системы,которая использовалась при компиляции Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="a5daa3a58a54feb209df655b37c5e59522b9e4ee" translate="yes" xml:space="preserve">
          <source>The return type is always a list of binaries that are all referencing &lt;code&gt;Subject&lt;/code&gt;. This means that the data in &lt;code&gt;Subject&lt;/code&gt; is not copied to new binaries, and that &lt;code&gt;Subject&lt;/code&gt; cannot be garbage collected until the results of the split are no longer referenced.</source>
          <target state="translated">Тип возврата - всегда список двоичных файлов, которые все ссылаются на &lt;code&gt;Subject&lt;/code&gt; . Это означает, что данные в &lt;code&gt;Subject&lt;/code&gt; не копируются в новые двоичные файлы и что &lt;code&gt;Subject&lt;/code&gt; не может быть обработан сборщиком мусора, пока на результаты разделения больше не будут ссылаться.</target>
        </trans-unit>
        <trans-unit id="cc16505451734ce394057d5190ddadeecb680cef" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Pid&lt;/code&gt; is used as a reference to the newly created FTP client in all other functions, and they are to be called by the process that created the connection. The FTP client process monitors the process that created it and terminates if that process terminates.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;Pid&lt;/code&gt; используется как ссылка на вновь созданный FTP-клиент во всех других функциях, и они должны вызываться процессом, создавшим соединение. Процесс клиента FTP отслеживает процесс, который его создал, и завершается, если этот процесс завершается.</target>
        </trans-unit>
        <trans-unit id="f78465bb43d8aa089c1a2e5e2c700b8de6570b00" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;Reply&lt;/code&gt; определяется в возвращаемом значении &lt;code&gt;Module:handle_call/2&lt;/code&gt; . Если указанный обработчик событий не установлен, функция возвращает &lt;code&gt;{error,bad_module}&lt;/code&gt; . Если функция обратного вызова завершается с ошибкой из-за &lt;code&gt;Reason&lt;/code&gt; или возвращает неожиданное значение &lt;code&gt;Term&lt;/code&gt; , эта функция возвращает &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; или &lt;code&gt;{error,Term}&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="a6289ce75177b974046367704a47c1b35eb2e270" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;Reply&lt;/code&gt; определяется в возвращаемом значении &lt;code&gt;Module:handle_call/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb167c76164cb105eb2244033c450ce12d924f6" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is generated when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; returns with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; as one &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;, and that &lt;code&gt;Reply&lt;/code&gt; becomes the return value of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44772176203799075c4cf0e8094950a68499d4a6" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;RequestId&lt;/code&gt; shall later be used with &lt;code&gt;&lt;a href=&quot;#wait_response-2&quot;&gt; wait_response/1,2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#check_response-2&quot;&gt; check_response/2&lt;/a&gt;&lt;/code&gt; to fetch the actual result of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e65900c2497a0e4adbf3bab8d430efb090697d7" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Result&lt;/code&gt; is not further defined, and is always to be ignored.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;Result&lt;/code&gt; далее не определяется и всегда должно игнорироваться.</target>
        </trans-unit>
        <trans-unit id="9c23fe4eff7b888efd68f97990dace6d93d015ba" translate="yes" xml:space="preserve">
          <source>The return value and the handling of errors and warnings are the same as described for &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение и обработка ошибок и предупреждений такие же, как описано для &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba22696e46bcb1ab14efe031c40d755d114fc6e5" translate="yes" xml:space="preserve">
          <source>The return value can have one of the following types.</source>
          <target state="translated">Возвращаемое значение может иметь один из следующих типов.</target>
        </trans-unit>
        <trans-unit id="741aa2cae249c15277ff6de1b81ff1f7de2350e9" translate="yes" xml:space="preserve">
          <source>The return value consists of a &lt;code&gt;Listen&lt;/code&gt; handle (which is later passed to the &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; callback), &lt;code&gt;Address&lt;/code&gt; which is a &lt;code&gt;#net_address{}&lt;/code&gt; record with information about the address for the node (the &lt;code&gt;#net_address{}&lt;/code&gt; record is defined in &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt;), and &lt;code&gt;Creation&lt;/code&gt; which (currently) is an integer &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение состоит из дескриптора &lt;code&gt;Listen&lt;/code&gt; (который позже передается в обратный вызов &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;Address&lt;/code&gt; , который представляет собой &lt;code&gt;#net_address{}&lt;/code&gt; с информацией об адресе узла ( &lt;code&gt;#net_address{}&lt;/code&gt; определена в файле &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt; ) и &lt;code&gt;Creation&lt;/code&gt; , которое (в настоящее время) является целым числом &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; или &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab79f181d05026b86f1878e51d4d3441d03c4055" translate="yes" xml:space="preserve">
          <source>The return value follow the same style as for &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение соответствует тому же стилю, что и для &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346315afa40134fb62265d734d0e42452e705832" translate="yes" xml:space="preserve">
          <source>The return value for all output functions is &lt;code&gt;0&lt;/code&gt; for normal use. If the driver is used for distribution, it can fail and return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение для всех функций вывода - &lt;code&gt;0&lt;/code&gt; для нормального использования. Если драйвер используется для распространения, он может дать сбой и вернуть &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43fdbaf5636b2b9f8f515ab786ad5a8feaf983bd" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; can be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt; enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe44e353cb6821f37b9d4bc7c2c6cb33639ce4d" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; can be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">Возвращаемое значение из &lt;code&gt;enif_make_badarg&lt;/code&gt; может использоваться только как возвращаемое значение из NIF, который его вызвал (прямо или косвенно), или передаваться в &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; , но не в любую другую функцию NIF API.</target>
        </trans-unit>
        <trans-unit id="bc102f8ff2bc19643ee272ec79fc8cf9d22dd9ca" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_raise_exception&lt;/code&gt; can only be used as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt; enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10dc23a005ca2cd50fc7c1d7990584e9fd2be429" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_raise_exception&lt;/code&gt; can only be used as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">Возвращаемое значение из &lt;code&gt;enif_raise_exception&lt;/code&gt; может использоваться только как возвращаемое значение из NIF, который его вызвал (прямо или косвенно), или передаваться в &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; , но не в любую другую функцию NIF API.</target>
        </trans-unit>
        <trans-unit id="41dab507981d86110830d0fd24280799a5b4ee46" translate="yes" xml:space="preserve">
          <source>The return value from the filter fun.</source>
          <target state="translated">Возвращаемое значение из веселья фильтра.</target>
        </trans-unit>
        <trans-unit id="001a5abd75600054653994ccb358aab2ae66f787" translate="yes" xml:space="preserve">
          <source>The return value from the function is in this case a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression.</source>
          <target state="translated">В данном случае возвращаемое значение функции - это &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt; s. Каждый подсписок начинается со строки, выбранной из строки темы, за которой следуют части, соответствующие каждому из подвыражений в порядке их появления в регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="5ccdc21b3308e8b9c79db59288c10d44a28814f7" translate="yes" xml:space="preserve">
          <source>The return value from this function is ignored by Logger.</source>
          <target state="translated">Возвращаемое из этой функции значение игнорируется Журналером.</target>
        </trans-unit>
        <trans-unit id="a4da786e1a06fe4c80b86166fcf1fc85113c7b88" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;-1&lt;/code&gt; if the &lt;code&gt;driver_async&lt;/code&gt; call fails.</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;-1&lt;/code&gt; , если вызов &lt;code&gt;driver_async&lt;/code&gt; завершился неудачно.</target>
        </trans-unit>
        <trans-unit id="e5c3504d0b1f9c55bafbdc1d0b5cee931f0f08b2" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt; for normal use.</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;0&lt;/code&gt; для нормального использования.</target>
        </trans-unit>
        <trans-unit id="2a5dc674809351c5092cd01b94fa3534964ae836" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless &lt;code&gt;ready_input&lt;/code&gt;/&lt;code&gt;ready_output&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, in which case it is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;0&lt;/code&gt; , если &lt;code&gt;ready_input&lt;/code&gt; / &lt;code&gt;ready_output&lt;/code&gt; не равно &lt;code&gt;NULL&lt;/code&gt; , в этом случае это &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4d60964b41244106524f6879c28f2c548eae606" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless the &lt;code&gt;now&lt;/code&gt; pointer is invalid, in which case it is &amp;lt; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;0&lt;/code&gt; , если указатель &lt;code&gt;now&lt;/code&gt; не является недопустимым, и в этом случае он &amp;lt; &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d105bd7aa7f6ee8eda692ca7d456479ff1aacb66" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e56d80f6b96cb9980b29b64b5003509e50ff6732" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;{Item, Value}&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the requested information as described earlier. If a pid for a dead process was specified, or the name of a non-existing function, &lt;code&gt;Value&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;{Item, Value}&lt;/code&gt; , где &lt;code&gt;Value&lt;/code&gt; - запрошенная информация, как описано ранее. Если был указан pid для мертвого процесса или имя несуществующей функции, &lt;code&gt;Value&lt;/code&gt; не &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="086833bd7be1bf42e569670f0bbec7584dac404f" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;{Ret, Mon}&lt;/code&gt; where &lt;code&gt;Ret&lt;/code&gt; corresponds to the &lt;code&gt;Ret&lt;/code&gt; argument in the call to &lt;code&gt;init_ack()&lt;/code&gt;, and &lt;code&gt;Mon&lt;/code&gt; is the monitor reference of the monitor that has been set up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03446d5b267ccb3efe0ace7759b550ebc06efd8" translate="yes" xml:space="preserve">
          <source>The return value is a list of 0, 1, or 2 possible UTC times:</source>
          <target state="translated">Возвращаемое значение представляет собой список 0,1 или 2 возможных UTC-времени:</target>
        </trans-unit>
        <trans-unit id="ce9057d164fb05944ea3d2ae98a443e394d333df" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение всегда равно &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3da23e054f258b1199e04f5ad3b9dd62d3edb83" translate="yes" xml:space="preserve">
          <source>The return value is constructed using the &quot;match variables&quot; bound in &lt;code&gt;MatchHead&lt;/code&gt; or using the special match variables &lt;code&gt;'$_'&lt;/code&gt; (the whole matching object) and &lt;code&gt;'$$'&lt;/code&gt; (all match variables in a list), so that the following &lt;code&gt;match/2&lt;/code&gt; expression:</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;MatchHead&lt;/code&gt; с использованием &amp;laquo;переменных соответствия&amp;raquo;, связанных в MatchHead, или с использованием специальных переменных соответствия &lt;code&gt;'$_'&lt;/code&gt; (весь соответствующий объект) и &lt;code&gt;'$$'&lt;/code&gt; (все соответствующие переменные в списке), так что следующее &lt;code&gt;match/2&lt;/code&gt; выражение:</target>
        </trans-unit>
        <trans-unit id="37128074a43cf6aae3aba83c9d932bd47e3048e4" translate="yes" xml:space="preserve">
          <source>The return value is ignored by Logger.</source>
          <target state="translated">Возвращаемое значение игнорируется Регистратором.</target>
        </trans-unit>
        <trans-unit id="c1dfea7d28396da4de4489ef281ff15cca821d15" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - это количество байтов, возвращаемых в &lt;code&gt;*rbuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a34c82452edda3fc5f857c3e407fba4f89b70680" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;. If &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; is returned (or in fact, anything &amp;lt; 0), &lt;code&gt;erlang:port_call/3&lt;/code&gt; throws a &lt;code&gt;BAD_ARG&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - это количество байтов, возвращаемых в &lt;code&gt;*rbuf&lt;/code&gt; . Если возвращается &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; (или фактически любое значение &amp;lt;0), &lt;code&gt;erlang:port_call/3&lt;/code&gt; выдает &lt;code&gt;BAD_ARG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb09cfa81ef1177832f57170b310c9386fb04033" translate="yes" xml:space="preserve">
          <source>The return value is the number of characters written to the file or string, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;buf[index]&lt;/code&gt; does not contain a valid term. Unfortunately, I/O errors on &lt;code&gt;fp&lt;/code&gt; is not checked.</source>
          <target state="translated">Возвращаемое значение - это количество символов, записанных в файл или строку, или &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;buf[index]&lt;/code&gt; не содержит допустимого термина. К сожалению, ошибки ввода-вывода на &lt;code&gt;fp&lt;/code&gt; не проверяются.</target>
        </trans-unit>
        <trans-unit id="d80fb99a8a27fa381ecc5c817818b46b3ab15dd8" translate="yes" xml:space="preserve">
          <source>The return value is the resulting match specification.</source>
          <target state="translated">Возвращаемое значение является результирующей спецификацией соответствия.</target>
        </trans-unit>
        <trans-unit id="57668a668af4374fe9545618abb646616a496fcc" translate="yes" xml:space="preserve">
          <source>The return value is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,module_not_found}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - это возвращаемое значение &lt;code&gt;Module:terminate/2&lt;/code&gt; . Если указанный обработчик событий не установлен, функция возвращает &lt;code&gt;{error,module_not_found}&lt;/code&gt; . Если функция обратного вызова не работает с &lt;code&gt;Reason&lt;/code&gt; , функция возвращает &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f156a768e7d53f51540a13419deed4e225aae89a" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение такое же, как для &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dfedeee7a3af1d51782288cef9cd7e711ef3e94" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. The number of matched events are never larger than 1 as &lt;code&gt;tpe/2&lt;/code&gt; does not accept any form of wildcards for argument &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение такое же, как для &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; . Число совпадающих событий никогда не превышает 1, поскольку &lt;code&gt;tpe/2&lt;/code&gt; не принимает никаких форм подстановочных знаков для аргумента &lt;code&gt;Event&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9518162065c311fec4cb8d7246362f3b51e7aea" translate="yes" xml:space="preserve">
          <source>The return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;{error, noconnection}&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not a connected node or &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение такое же, как и из &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;{error, noconnection}&lt;/code&gt; если &lt;code&gt;Node&lt;/code&gt; не является подключенным узлом или &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a43749a23c3f85f80f04d4b8d3793842d7c78d0b" translate="yes" xml:space="preserve">
          <source>The return value is the space left in the buffer, that is, if &lt;code&gt;ev&lt;/code&gt; contains less than &lt;code&gt;len&lt;/code&gt; bytes it is the difference, and if &lt;code&gt;ev&lt;/code&gt; contains &lt;code&gt;len&lt;/code&gt; bytes or more, it is &lt;code&gt;0&lt;/code&gt;. This is faster if there is more than one header byte, as the binary syntax can construct integers directly from the binary.</source>
          <target state="translated">Возвращаемое значение - это пространство, оставшееся в буфере, то есть, если &lt;code&gt;ev&lt;/code&gt; содержит меньше &lt;code&gt;len&lt;/code&gt; байтов, это разница, а если &lt;code&gt;ev&lt;/code&gt; содержит &lt;code&gt;len&lt;/code&gt; байтов или больше, это &lt;code&gt;0&lt;/code&gt; . Это быстрее, если имеется более одного байта заголовка, поскольку двоичный синтаксис может создавать целые числа непосредственно из двоичного файла.</target>
        </trans-unit>
        <trans-unit id="ac2f53a327ddcef69bcfc81c81e743ec02f58d49" translate="yes" xml:space="preserve">
          <source>The return value is to be any of the following values, indicating if the specified configuration parameter is valid:</source>
          <target state="translated">Возвращаемое значение должно быть любым из следующих значений,указывающих,действителен ли указанный конфигурационный параметр:</target>
        </trans-unit>
        <trans-unit id="a53de66b6befed22fef727bcfc1593e2a3510e89" translate="yes" xml:space="preserve">
          <source>The return value is to be either of the following:</source>
          <target state="translated">Возвращаемое значение должно быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="ceafeb40fcc33ae37d1bb500d86c43da7ff973a6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;case&lt;/code&gt; expression.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;Body&lt;/code&gt; - это возвращаемое значение выражения &lt;code&gt;case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="667b4e9527fb89bbee21bc3c659692855e17e45e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;Body&lt;/code&gt; - это возвращаемое значение выражения &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12267bfd95ce2e9cae7b8fb4988fa796d16c0a33" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;receive&lt;/code&gt; expression.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;Body&lt;/code&gt; - это возвращаемое значение выражения &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea4fae033ca5b8c06d8b471ec021531504980c6e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;end_per_testcase/2&lt;/code&gt; is ignored by the test server, with exception of the &lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; tuple.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;end_per_testcase/2&lt;/code&gt; игнорируется тестовым сервером, с исключением &lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;fail&lt;/code&gt; кортежа.</target>
        </trans-unit>
        <trans-unit id="56770d741c762804a23c8684019a89bbb9d3b32f" translate="yes" xml:space="preserve">
          <source>The return value of calling this function is intended to be used in the &lt;code&gt;match_fun&lt;/code&gt; option in &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение вызова этой функции предназначено для использования в &lt;code&gt;match_fun&lt;/code&gt; опции в &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76590aed6da8a4573a438a60f16632978a2bec67" translate="yes" xml:space="preserve">
          <source>The return value of the CTH function is always a combination of a result for the suite/group/test and an updated &lt;code&gt;CTHState&lt;/code&gt;. If you do not want the callback to affect the outcome of the test, return the &lt;code&gt;Return&lt;/code&gt; data as it is given to the CTH. You can also modify the test result. By returning the &lt;code&gt;Config&lt;/code&gt; list with element &lt;code&gt;tc_status&lt;/code&gt; removed, you can recover from a test failure. As in all the pre hooks, it is also possible to fail/skip the test case in the post hook.</source>
          <target state="translated">Возвращаемое значение функции CTH всегда является комбинацией результата для набора / группы / теста и обновленного &lt;code&gt;CTHState&lt;/code&gt; . Если вы не хотите, чтобы обратный вызов влиял на результат теста, &lt;code&gt;Return&lt;/code&gt; данные возврата в том виде, в каком они были переданы в CTH. Вы также можете изменить результат теста. Возвращая список &lt;code&gt;Config&lt;/code&gt; с &lt;code&gt;tc_status&lt;/code&gt; элементом tc_status , вы можете восстановиться после сбоя теста. Как и во всех предварительных хуках, в пост-хуке также можно провалить / пропустить тестовый пример.</target>
        </trans-unit>
        <trans-unit id="dc96c849cea9a13470890e82d87865cfd4ec3cde" translate="yes" xml:space="preserve">
          <source>The return value of the expression is the resulting fun.</source>
          <target state="translated">Возвращаемое значение выражения является результирующим развлечением.</target>
        </trans-unit>
        <trans-unit id="ca104835aa5ad01d1fa3d939ad04e391832ceb22" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handler callback:</source>
          <target state="translated">Возвращаемое значение веселья определяет,будет ли событие журнала отбрасываться или пересылаться на обратный вызов обработчика:</target>
        </trans-unit>
        <trans-unit id="d4e70786797f2c0c82a992fd6de3d9da04e6d44f" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handlers:</source>
          <target state="translated">Возвращаемое значение веселья определяет,должно ли событие журнала отбрасываться или пересылаться обработчикам:</target>
        </trans-unit>
        <trans-unit id="8a15ba4a5d207f8ff27af670138d14092b913977" translate="yes" xml:space="preserve">
          <source>The return value of this call is:</source>
          <target state="translated">Возвращаемое значение этого вызова:</target>
        </trans-unit>
        <trans-unit id="ad0e0fbdd470e29f0445d4c32a3c5589be7037b8" translate="yes" xml:space="preserve">
          <source>The return value of this function is the same as the result of the commands &lt;code&gt;openssl crl -hash&lt;/code&gt; and &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt;, when passed the issuer name of a CRL or a certificate, respectively. This hash is used by the &lt;code&gt;c_rehash&lt;/code&gt; tool to maintain a directory of symlinks to CRL files, in order to facilitate looking up a CRL by its issuer name.</source>
          <target state="translated">Возвращаемое значение этой функции такое же, как результат команд &lt;code&gt;openssl crl -hash&lt;/code&gt; и &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt; , когда передается имя эмитента CRL или сертификата, соответственно. Этот хэш используется инструментом &lt;code&gt;c_rehash&lt;/code&gt; для поддержки каталога символических ссылок на файлы CRL, чтобы облегчить поиск CRL по имени его издателя.</target>
        </trans-unit>
        <trans-unit id="556ae7c31e2eeb819041e01f0988fe1443eb20ac" translate="yes" xml:space="preserve">
          <source>The return value reflects how many functions that matched, and is constructed as described in &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. No tuple &lt;code&gt;{saved, N}&lt;/code&gt; is however ever returned (for obvious reasons).</source>
          <target state="translated">Возвращаемое значение отражает количество совпавших функций и строится, как описано в &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; . Однако кортеж &lt;code&gt;{saved, N}&lt;/code&gt; никогда не возвращается (по понятным причинам).</target>
        </trans-unit>
        <trans-unit id="e0a236e08f99621d7b0efd68a7bc22730533f1a9" translate="yes" xml:space="preserve">
          <source>The return values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;blocked&lt;/code&gt;, &lt;code&gt;blocked_normal&lt;/code&gt;, or &lt;code&gt;enabled&lt;/code&gt;. The returned value describes the state just after the call to &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; has been made. For information about the return values, see &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt; erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2493a1b75922ce60ff03955e74f63fe68c01230" translate="yes" xml:space="preserve">
          <source>The return values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;blocked&lt;/code&gt;, &lt;code&gt;blocked_normal&lt;/code&gt;, or &lt;code&gt;enabled&lt;/code&gt;. The returned value describes the state just after the call to &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; has been made. For information about the return values, see &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемые значения &lt;code&gt;disabled&lt;/code&gt; , &lt;code&gt;blocked&lt;/code&gt; , &lt;code&gt;blocked_normal&lt;/code&gt; или &lt;code&gt;enabled&lt;/code&gt; . Возвращаемое значение описывает состояние сразу после вызова &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; . Для получения информации о возвращаемых значениях см. &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="060a85265e14ac614221fba12c3a188491993522" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt; Module:handle_event/2&lt;/a&gt;&lt;/code&gt; except that they also contain a term &lt;code&gt;Reply&lt;/code&gt;, which is the reply to the client as the return value of &lt;code&gt;call/3,4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a5c4a4e2556d9fc5599788448978bc86e18491" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; except that they also contain a term &lt;code&gt;Reply&lt;/code&gt;, which is the reply to the client as the return value of &lt;code&gt;call/3,4&lt;/code&gt;.</source>
          <target state="translated">Возвращаемые значения такие же, как для &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; , за исключением того, что они также содержат термин &lt;code&gt;Reply&lt;/code&gt; , который является ответом клиенту в качестве возвращаемого значения &lt;code&gt;call/3,4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd848a1f14ececc3a82ad290daef2754e5bb654" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt; scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16402449b6bab46b6acb25bee9687ea3d1da1cef" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемые значения такие же, как для &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34736dd65ea7c5f985adcd3b21d438aa1d48110e" translate="yes" xml:space="preserve">
          <source>The return values of the following functions depend much on the implementation of the FTP server at the remote host. In particular, the results from &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;nlist&lt;/code&gt; varies. Often real errors are not reported as errors by &lt;code&gt;ls&lt;/code&gt;, even if, for example, a file or directory does not exist. &lt;code&gt;nlist&lt;/code&gt; is usually more strict, but some implementations have the peculiar behaviour of responding with an error if the request is a listing of the contents of a directory that exists but is empty.</source>
          <target state="translated">Возвращаемые значения следующих функций во многом зависят от реализации FTP-сервера на удаленном хосте. В частности, результаты &lt;code&gt;ls&lt;/code&gt; и &lt;code&gt;nlist&lt;/code&gt; различаются. Часто реальные ошибки не сообщаются &lt;code&gt;ls&lt;/code&gt; как ошибки , даже если, например, файл или каталог не существует. &lt;code&gt;nlist&lt;/code&gt; обычно более строгий, но некоторые реализации имеют специфическое поведение, отвечающее ошибкой, если запрос представляет собой список содержимого каталога, который существует, но является пустым.</target>
        </trans-unit>
        <trans-unit id="28c7c4f49170e50d62e95547c1132e5f03288f96" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;State&lt;/code&gt; should be used in one or more subsequent calls to &lt;code&gt;&lt;a href=&quot;#mac_update-2&quot;&gt;mac_update/2&lt;/a&gt;&lt;/code&gt;. The MAC value is finally returned by calling &lt;code&gt;&lt;a href=&quot;#mac_final-1&quot;&gt;mac_final/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#mac_finalN-2&quot;&gt;mac_finalN/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047a74f745ac921eabba62b69b8f674e3b65c169" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TrueListenPort&lt;/code&gt; is the port that is listened to. It is the same as &lt;code&gt;ListenPort&lt;/code&gt;, except when &lt;code&gt;ListenPort = 0&lt;/code&gt;. In that case a free port is selected by the underlying OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e4973c70cdd56da241fcf626185e66a1c55705" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UtilDesc&lt;/code&gt;(s) will be even more detailed.</source>
          <target state="translated">Возвращенный &lt;code&gt;UtilDesc&lt;/code&gt; (s) будет еще более подробно.</target>
        </trans-unit>
        <trans-unit id="ea4255b1bb88d05e61ad743eab72330c07b40c58" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;outbound_streams&lt;/code&gt; and &lt;code&gt;inbound_streams&lt;/code&gt; are the stream numbers on the socket. These can be different from the requested values (&lt;code&gt;OutStreams&lt;/code&gt; and &lt;code&gt;MaxInStreams&lt;/code&gt;, respectively) if the peer requires lower values.</source>
          <target state="translated">Возвращаемое &lt;code&gt;outbound_streams&lt;/code&gt; и &lt;code&gt;inbound_streams&lt;/code&gt; являются номерами потоков на сокете. Они могут отличаться от запрошенных значений ( &lt;code&gt;OutStreams&lt;/code&gt; и &lt;code&gt;MaxInStreams&lt;/code&gt; соответственно), если одноранговому узлу требуются более низкие значения.</target>
        </trans-unit>
        <trans-unit id="78c4a176ab5344343a3680d64f0f87276de46ba2" translate="yes" xml:space="preserve">
          <source>The returned array is suitable to use with the Unix system call &lt;code&gt;writev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;writev&lt;/code&gt; массив подходит для использования с системным вызовом Unix writev .</target>
        </trans-unit>
        <trans-unit id="45ff48530f77dbc6cc0743bbf1b0bea13f7efa44" translate="yes" xml:space="preserve">
          <source>The returned continuation either is or is not valid in the next call to this function. This is because the log can wrap and delete the file into which the continuation points. To ensure this does not occur, the log can be blocked during the search.</source>
          <target state="translated">Возвращаемое продолжение является или не является действительным при следующем вызове этой функции.Это связано с тем,что журнал может обернуть и удалить файл,в который указывают точки продолжения.Чтобы этого не произошло,журнал можно заблокировать во время поиска.</target>
        </trans-unit>
        <trans-unit id="563414bf21c4083de3c0b515b0ae801f03daf271" translate="yes" xml:space="preserve">
          <source>The returned fun augments the verify hostname matching according to the specific rules for the protocol in the argument.</source>
          <target state="translated">Возвращаемое веселье дополняет проверку совпадения имени хоста в соответствии с конкретными правилами для протокола в аргументе.</target>
        </trans-unit>
        <trans-unit id="1f4757970518220fdc7fe112f9433dc5ad370dd2" translate="yes" xml:space="preserve">
          <source>The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.</source>
          <target state="translated">Возвращаемый указатель выравнивается для любого встроенного типа,который умещается в выделенной памяти.</target>
        </trans-unit>
        <trans-unit id="b2f0dd9c815f2da7d427b069f2a9894879c7f90c" translate="yes" xml:space="preserve">
          <source>The returned reference uniquely identifies the transport within the scope of the service. Note that the function returns before a transport connection has been established.</source>
          <target state="translated">Возвращаемая ссылка однозначно идентифицирует перевозку в рамках услуги.Обратите внимание,что функция возвращается до установления транспортного соединения.</target>
        </trans-unit>
        <trans-unit id="4e5ed52f640bec9583fe09c321a1dc7cfa7d394d" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;ListenSocket&lt;/code&gt; should be used in calls to &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; to accept incoming connection requests.</source>
          <target state="translated">&lt;code&gt;ListenSocket&lt;/code&gt; сокет ListenSocket следует использовать в вызовах &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; для приема входящих запросов на соединение.</target>
        </trans-unit>
        <trans-unit id="ab1d27e257509f8da3d8e76915e7736db74a82b0" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;Socket&lt;/code&gt; is used to send packets from this port with &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt;. When UDP packets arrive at the opened port, if the socket is in an active mode, the packets are delivered as messages to the controlling process:</source>
          <target state="translated">Возвращенный сокет &lt;code&gt;Socket&lt;/code&gt; используется для отправки пакетов с этого порта с помощью &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt; . Когда UDP-пакеты поступают на открытый порт, если сокет находится в активном режиме, пакеты доставляются в виде сообщений контролирующему процессу:</target>
        </trans-unit>
        <trans-unit id="ba58f4a868c9920a0accc2470109df28ce1c8b33" translate="yes" xml:space="preserve">
          <source>The returned value equals &lt;code&gt;How&lt;/code&gt; before flag &lt;code&gt;scheduler_bind_type&lt;/code&gt; was changed.</source>
          <target state="translated">Возвращаемое значение равно &lt;code&gt;How&lt;/code&gt; до изменения флага &lt;code&gt;scheduler_bind_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad1f4738d1ee235637e8713b2fb0e1aed7b3c9ff" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;info&lt;/code&gt; is part of &lt;code&gt;OptionList&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;info&lt;/code&gt; является частью &lt;code&gt;OptionList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="671e79f941b79fced8adb6612252872802f7c324" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple &lt;code&gt;{NewTree, Max}&lt;/code&gt;, where &lt;code&gt;NewTree&lt;/code&gt; is the labeled tree and &lt;code&gt;Max&lt;/code&gt; is 1 plus the largest label value used. All previous annotation terms on the form &lt;code&gt;{label, X}&lt;/code&gt; are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704d94c2e818c260decb81dbc9e54e317cedcd87" translate="yes" xml:space="preserve">
          <source>The returned value is one of the following:</source>
          <target state="translated">Возвращаемое значение является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="17c9f8dadb89f1f4731e454e478946ba8977d737" translate="yes" xml:space="preserve">
          <source>The returned value of the first call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt; by a process will on most systems be the CPU utilization since system boot, but this is not guaranteed and the value should therefore be regarded as garbage. This also applies to the first call after a restart of &lt;code&gt;cpu_sup&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение первого вызова &lt;code&gt;util/0&lt;/code&gt; или &lt;code&gt;util/1&lt;/code&gt; процессом в большинстве систем будет соответствовать загрузке ЦП с момента загрузки системы, но это не гарантируется, и поэтому значение следует рассматривать как мусор. Это также относится к первому вызову после перезапуска &lt;code&gt;cpu_sup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33e425aa419d45203b9e7b0885a322854194b3c4" translate="yes" xml:space="preserve">
          <source>The returned value when there are data available depends on the value of the &lt;code&gt;get_size&lt;/code&gt; option configured on the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt;. For more information see the documentation of the &lt;code&gt;get_size&lt;/code&gt; option for the &lt;code&gt;&lt;a href=&quot;#dist_ctrl_set_opt-3&quot;&gt;erlang:dist_ctrl_set_opt/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbb8b0494dfde82da9ec11120fc8e7694cd4f11" translate="yes" xml:space="preserve">
          <source>The right hand side of a grammar rule may be empty. This is indicated by using the special symbol &lt;code&gt;'$empty'&lt;/code&gt; as rhs. Then the list grammar above may be simplified to:</source>
          <target state="translated">Правая часть правила грамматики может быть пустой. На это указывает использование специального символа &lt;code&gt;'$empty'&lt;/code&gt; качестве rhs. Тогда грамматика списка выше может быть упрощена до:</target>
        </trans-unit>
        <trans-unit id="dc75d0c89181a304f45200607807515a4ebde020" translate="yes" xml:space="preserve">
          <source>The role of a Diameter node is determined by the user's implementation.</source>
          <target state="translated">Роль узла Diameter определяется пользовательской реализацией.</target>
        </trans-unit>
        <trans-unit id="416c824ca6a43adb95da91e2cb1751ab089f31b7" translate="yes" xml:space="preserve">
          <source>The room number is an attribute of the employee record. This is a structured attribute that consists of a tuple. The first element of the tuple identifies a corridor, and the second element identifies the room in that corridor. An alternative is to represent this as a record &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; instead of an anonymous tuple representation.</source>
          <target state="translated">Номер комнаты - это атрибут записи о сотруднике. Это структурированный атрибут, состоящий из кортежа. Первый элемент кортежа определяет коридор, а второй элемент определяет комнату в этом коридоре. Альтернативный вариант - представить это как запись-запись &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; вместо анонимного представления кортежа.</target>
        </trans-unit>
        <trans-unit id="577f0039c4fa2f0d1ea23b58d0300c235c47b7fd" translate="yes" xml:space="preserve">
          <source>The root certificate is a trusted certificate that is present in the trusted certificate database kept by the peer.</source>
          <target state="translated">Корневой сертификат-это доверенный сертификат,который присутствует в базе данных доверенных сертификатов,хранящейся у равноправного пользователя.</target>
        </trans-unit>
        <trans-unit id="52dbe02f6473ea542b1777651fa34126c38819b1" translate="yes" xml:space="preserve">
          <source>The root certificate name.</source>
          <target state="translated">Имя корневого сертификата.</target>
        </trans-unit>
        <trans-unit id="53cd33d8adcdb9225af5611f87476b60c6686390" translate="yes" xml:space="preserve">
          <source>The root directory (&lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt;)</source>
          <target state="translated">Корневой каталог ( &lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="59cc46abe2ddea6a9a499abb0a284b3438d6e2bb" translate="yes" xml:space="preserve">
          <source>The routine above is called from the &lt;code&gt;uds_output&lt;/code&gt; routine:</source>
          <target state="translated">Вышеупомянутая процедура вызывается из процедуры &lt;code&gt;uds_output&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="899ef76204638a6cfef4214df04665f53c56597c" translate="yes" xml:space="preserve">
          <source>The routine builds an I/O vector containing the header bytes and the buffer (the opcode has been removed and the buffer length decreased by the output routine). If the queue is empty, we write the data directly to the socket (or at least try to). If any data is left, it is stored in the queue and then we try to send the queue (line 38). An acknowledgement is sent when the message is delivered completely (line 22). The &lt;code&gt;send_out_queue&lt;/code&gt; sends acknowledgements if the sending is completed there. If the port is in &lt;code&gt;command&lt;/code&gt; mode, the Erlang code serializes the send operations so that only one packet can be waiting for delivery at a time. Therefore the acknowledgement can be sent whenever the queue is empty.</source>
          <target state="translated">Подпрограмма строит вектор ввода-вывода, содержащий байты заголовка и буфер (код операции был удален, а длина буфера уменьшена процедурой вывода). Если очередь пуста, мы записываем данные прямо в сокет (или, по крайней мере, пытаемся). Если какие-то данные остались, они сохраняются в очереди, а затем мы пытаемся отправить очередь (строка 38). Подтверждение отправляется, когда сообщение доставлено полностью (строка 22). &lt;code&gt;send_out_queue&lt;/code&gt; отправляет подтверждения , если отправка будет завершен там. Если порт находится в &lt;code&gt;command&lt;/code&gt; режиме, код Erlang сериализует операции отправки, так что только один пакет может ожидать доставки за раз. Следовательно, подтверждение может быть отправлено всякий раз, когда очередь пуста.</target>
        </trans-unit>
        <trans-unit id="673662eb2121ca41425305edda42a80c288cd1e9" translate="yes" xml:space="preserve">
          <source>The routine initializes the single global data structure and returns a pointer to the driver entry. The routine is called when &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; is called from Erlang.</source>
          <target state="translated">Подпрограмма инициализирует единую глобальную структуру данных и возвращает указатель на запись драйвера. Подпрограмма вызывается, когда &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; вызывается из Erlang.</target>
        </trans-unit>
        <trans-unit id="c17dc336612f84d4c81b404a94002b4ef123f628" translate="yes" xml:space="preserve">
          <source>The routine is simple: it first handles the fact that the output select will concern a socket in the business of connecting (and the connecting blocked). If the socket is in a connected state, it simply sends the output queue. This routine is called when it is possible to write to a socket where we have an output queue, so there is no question what to do.</source>
          <target state="translated">Обычная процедура проста:она сначала обрабатывает тот факт,что выбор выхода будет касаться розетки в бизнесе подключения (а подключение заблокировано).Если сокет находится в подключенном состоянии,он просто посылает выходную очередь.Эта рутина вызывается,когда можно написать в сокет,где есть выходная очередь,так что нет вопроса,что делать.</target>
        </trans-unit>
        <trans-unit id="77a723120b7e543c1800db7036e53529bcbbae13" translate="yes" xml:space="preserve">
          <source>The routine tries to read data until a packet is read or the &lt;code&gt;buffered_read_package&lt;/code&gt; routine returns a &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; (an internally defined constant for the module, which means that the read operation resulted in an &lt;code&gt;EWOULDBLOCK&lt;/code&gt;). If the port is in &lt;code&gt;command&lt;/code&gt; mode, the reading stops when one package is read. If the port is in &lt;code&gt;data&lt;/code&gt; mode, the reading continues until the socket buffer is empty (read failure). If no more data can be read and more is wanted (which is always the case when the socket is in &lt;code&gt;data&lt;/code&gt; mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_input&lt;/code&gt; callback be called when more data is available for reading.</source>
          <target state="translated">Подпрограмма пытается читать данные до тех пор, пока не будет прочитан пакет или пока процедура &lt;code&gt;buffered_read_package&lt;/code&gt; не вернет &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; (внутренне определенная константа для модуля, что означает, что операция чтения привела к &lt;code&gt;EWOULDBLOCK&lt;/code&gt; ). Если порт находится в &lt;code&gt;command&lt;/code&gt; режиме, чтение прекращается при чтении одного пакета. Если порт находится в режиме &lt;code&gt;data&lt;/code&gt; , чтение продолжается до тех пор, пока буфер сокета не станет пустым (ошибка чтения). Если данные больше не могут быть прочитаны и требуется больше (что всегда бывает, когда сокет находится в режиме &lt;code&gt;data&lt;/code&gt; ), &lt;code&gt;driver_select&lt;/code&gt; чтобы вызвать &lt;code&gt;uds_input&lt;/code&gt; вызов uds_input , когда для чтения доступно больше данных.</target>
        </trans-unit>
        <trans-unit id="594d38181d8b0e2c57da4b81cceed123220efbd4" translate="yes" xml:space="preserve">
          <source>The row for the &lt;strong&gt;marked&lt;/strong&gt; function simply contains the sum of all &lt;strong&gt;calling&lt;/strong&gt; rows.</source>
          <target state="translated">Строка для &lt;strong&gt;отмеченной&lt;/strong&gt; функции просто содержит сумму всех &lt;strong&gt;вызывающих&lt;/strong&gt; строк.</target>
        </trans-unit>
        <trans-unit id="f63f268b5b1ba7e518b6ca9840895c249dbd9600" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;called&lt;/strong&gt; functions contains statistics for the &lt;strong&gt;row's&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;marked&lt;/strong&gt; to the &lt;strong&gt;row's&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">Строки для &lt;strong&gt;вызываемых&lt;/strong&gt; функций содержат статистику для функции &lt;strong&gt;строки&lt;/strong&gt; с ограничением, что учитываются только те случаи, когда был сделан вызов из &lt;strong&gt;отмеченной&lt;/strong&gt; функции &lt;strong&gt;строки&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b591b9ee5241f27713065c70477c2cb23e6ae07b" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;calling&lt;/strong&gt; functions contain statistics for the &lt;strong&gt;marked&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;row's&lt;/strong&gt; function to the &lt;strong&gt;marked&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">Строки для &lt;strong&gt;заходящих&lt;/strong&gt; функций содержат статистические данные по &lt;strong&gt;отмеченной&lt;/strong&gt; функции с ограничением , что только случаи , когда вызов был сделан из &lt;strong&gt;грести в&lt;/strong&gt; функции к &lt;strong&gt;отмеченной&lt;/strong&gt; функции, учитываются.</target>
        </trans-unit>
        <trans-unit id="23c9bc526d84923d88d3f3c4aca6eb88d00853db" translate="yes" xml:space="preserve">
          <source>The rules for handling the two address passing options are:</source>
          <target state="translated">Правила работы с двумя опциями передачи адресов:</target>
        </trans-unit>
        <trans-unit id="65d47d40f9e3322daa06f6a9cc9586d8bced1031" translate="yes" xml:space="preserve">
          <source>The rules for importing variables into a fun has the consequence that certain pattern matching operations must be moved into guard expressions and cannot be written in the head of the fun. For example, you might write the following code if you intend the first clause of &lt;code&gt;F&lt;/code&gt; to be evaluated when the value of its argument is &lt;code&gt;Y&lt;/code&gt;:</source>
          <target state="translated">Правила импорта переменных в игру приводят к тому, что определенные операции сопоставления с образцом должны быть перенесены в охранные выражения и не могут быть записаны в заголовке игры. Например, вы можете написать следующий код, если хотите, чтобы первое предложение &lt;code&gt;F&lt;/code&gt; оценивалось, когда значение его аргумента равно &lt;code&gt;Y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b91da3a1a048b58314c1c111db21a5595f2f19a" translate="yes" xml:space="preserve">
          <source>The rules in an access file apply to files in the same directory and in subdirectories. If there exists more than one access file in the path to an asset, the rules in the access file nearest the requested asset is applied.</source>
          <target state="translated">Правила в файле доступа применяются к файлам в той же директории и поддиректориях.Если в пути к активу имеется более одного файла доступа,то применяются правила в файле доступа,расположенном ближе всего к запрашиваемому активу.</target>
        </trans-unit>
        <trans-unit id="e5d1d20f6a0a42644b3aeca3328fe18c9290d7a4" translate="yes" xml:space="preserve">
          <source>The rules used for name binding vary between domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d38dd44eba1bb3a7ed4f14eaa12a0a33476ba0b" translate="yes" xml:space="preserve">
          <source>The running configuration cannot be deleted and &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; must be advertised by the server.</source>
          <target state="translated">Текущая конфигурация не может быть удалена, и сервер должен объявить &lt;code&gt;:candidate&lt;/code&gt; или &lt;code&gt;:startup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c79b5264357f5534cee7c6ef4abc2fbac9660cbd" translate="yes" xml:space="preserve">
          <source>The runtime encoders and decoders execute within a catch and return &lt;code&gt;{ok, Data}&lt;/code&gt; or &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; where &lt;code&gt;Description&lt;/code&gt; is an Erlang term describing the error.</source>
          <target state="translated">Кодеры и декодеры среды выполнения выполняются в пределах перехвата и возвращают &lt;code&gt;{ok, Data}&lt;/code&gt; или &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; где &lt;code&gt;Description&lt;/code&gt; - это термин Erlang, описывающий ошибку.</target>
        </trans-unit>
        <trans-unit id="1bd1e0cd445f2587e2d274da2e56ba41b0124a77" translate="yes" xml:space="preserve">
          <source>The runtime for the process, that is, the time that the process has been scheduled in.</source>
          <target state="translated">Время выполнения процесса,то есть время,в течение которого процесс был запланирован.</target>
        </trans-unit>
        <trans-unit id="0477f575396c2d31573bf1177d25d393514ae802" translate="yes" xml:space="preserve">
          <source>The runtime overhead is one word per allocation when enabled. This may change at any time in the future.</source>
          <target state="translated">При включении этого параметра накладные расходы составляют по одному слову на каждое распределение.Это может измениться в любое время в будущем.</target>
        </trans-unit>
        <trans-unit id="b52f5dd159b93b951f3b921ca939f057c72f0232" translate="yes" xml:space="preserve">
          <source>The runtime system aborts producing a core dump, if that is enabled in the OS.</source>
          <target state="translated">Система выполнения прерывает создание дампа ядра,если это включено в операционной системе.</target>
        </trans-unit>
        <trans-unit id="aedc7575975308f8d984dc3da045923bc133d996" translate="yes" xml:space="preserve">
          <source>The runtime system always takes a lock before running any code in a driver.</source>
          <target state="translated">Система времени выполнения всегда блокируется перед запуском любого кода в драйвере.</target>
        </trans-unit>
        <trans-unit id="0b7cb9b63bdfde371041fe9ecc549e2d3f8291fb" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in &lt;strong&gt;interactive&lt;/strong&gt; or &lt;strong&gt;embedded&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;:</source>
          <target state="translated">Систему времени выполнения можно запустить в &lt;strong&gt;интерактивном&lt;/strong&gt; или &lt;strong&gt;встроенном&lt;/strong&gt; режиме. Какой из них определяется флагом командной строки &lt;code&gt;-mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f194749f9a0abb8f1fc16278fdf82b7ab426657" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in either &lt;strong&gt;embedded&lt;/strong&gt; or &lt;strong&gt;interactive&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;.</source>
          <target state="translated">Систему выполнения можно запустить во &lt;strong&gt;встроенном&lt;/strong&gt; или &lt;strong&gt;интерактивном&lt;/strong&gt; режиме. Какой из них определяется флагом командной строки &lt;code&gt;-mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15f0b229ab22b4247144711faf8addfff0acec04" translate="yes" xml:space="preserve">
          <source>The runtime system can represent binaries up to 64 bytes as heap binaries. They are always copied when sent in messages, but they require less memory if they are not sent to another process and garbage collection is cheaper.</source>
          <target state="translated">Система исполнения может представлять двоичные файлы размером до 64 байт в виде кучи.Они всегда копируются,когда отправляются в сообщениях,но требуют меньше памяти,если они не отправляются в другой процесс,а сбор мусора обходится дешевле.</target>
        </trans-unit>
        <trans-unit id="52f7c1d9fec74d1d87c2aa61e92b2f7031396fc6" translate="yes" xml:space="preserve">
          <source>The runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors.</source>
          <target state="translated">Система времени выполнения по умолчанию &lt;strong&gt;не&lt;/strong&gt; связывает планировщики с логическими процессорами.</target>
        </trans-unit>
        <trans-unit id="fc86dfe1cb0ce649fa9cfc863da2e29d5456fcde" translate="yes" xml:space="preserve">
          <source>The runtime system exits with integer value &lt;code&gt;Status&lt;/code&gt; as status code to the calling environment (OS).</source>
          <target state="translated">Система времени выполнения выходит с целочисленным значением &lt;code&gt;Status&lt;/code&gt; в качестве кода состояния в вызывающую среду (ОС).</target>
        </trans-unit>
        <trans-unit id="d758492b235e5ae70fd740805f185d0f947792cf" translate="yes" xml:space="preserve">
          <source>The runtime system is halted by calling &lt;code&gt;halt/0,1&lt;/code&gt;. For details, see the &lt;code&gt;erlang(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">Система времени выполнения останавливается вызовом &lt;code&gt;halt/0,1&lt;/code&gt; . Для получения дополнительной информации см. Страницу справочника &lt;code&gt;erlang(3)&lt;/code&gt; в ERTS.</target>
        </trans-unit>
        <trans-unit id="737f6644d46fc0b71dce7d366db4bb2df97d5f28" translate="yes" xml:space="preserve">
          <source>The runtime system is started using a &lt;strong&gt;boot script&lt;/strong&gt;. The boot script contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">Система выполнения запускается с помощью &lt;strong&gt;сценария загрузки&lt;/strong&gt; . Сценарий загрузки содержит инструкции о том, какой код загружать, а также какие процессы и приложения запускать.</target>
        </trans-unit>
        <trans-unit id="f56dfcd70ad1156309d29b60e153328381d89995" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a NIF library if the major versions differ, or if the major versions are equal and the minor version used by the NIF library is greater than the one used by the runtime system. Old NIF libraries with lower major versions are, however, allowed after a bump of the major version during a transition period of two major releases. Such old NIF libraries can however fail if deprecated features are used.</source>
          <target state="translated">Система времени исполнения обычно отказывается загружать библиотеку NIF,если основные версии отличаются,или если основные версии равны,а второстепенная версия,используемая библиотекой NIF,больше той,что используется системой времени исполнения.Старые библиотеки NIF с более низкими старшими версиями,однако,допускаются после выхода старшей версии в течение переходного периода из двух мажорных версий.Однако такие старые библиотеки NIF могут выйти из строя,если используются устаревшие возможности.</target>
        </trans-unit>
        <trans-unit id="08dd149e2b409426602405250d51453a541efc1d" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a driver if the major versions differ, or if the major versions are equal and the minor version used by the driver is greater than the one used by the runtime system. Old drivers with lower major versions are however allowed after a bump of the major version during a transition period of two major releases. Such old drivers can, however, fail if deprecated features are used.</source>
          <target state="translated">Система времени исполнения обычно отказывается загружать драйвер,если основные версии отличаются,или если основные версии равны,а второстепенная версия,используемая драйвером,больше той,что используется системой времени исполнения.Старые драйверы с более низкими основными версиями,однако,разрешается загружать драйверы после выхода старшей версии в течение переходного периода двух основных версий.Однако такие старые драйверы могут выйти из строя,если используются устаревшие функции.</target>
        </trans-unit>
        <trans-unit id="c5369a70b6288773729d2ce3df1f9a69da1e0a6d" translate="yes" xml:space="preserve">
          <source>The runtime system rereads the CPU information available and updates its internally stored information about the &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; and the number of logical processors &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#system_info_cpu_quota&quot;&gt;cpu quota&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8941217d6f38b36e1857530b5476e0fe59285c" translate="yes" xml:space="preserve">
          <source>The runtime system rereads the CPU information available and updates its internally stored information about the &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; and the number of logical processors &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Система выполнения повторно считывает доступную информацию о ЦП и обновляет хранящуюся внутри информацию об &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; и количестве логических процессоров, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1318205b88fb228dd3bc1e3526e8e8a8014305b4" translate="yes" xml:space="preserve">
          <source>The runtime system sees that &lt;code&gt;Bin1&lt;/code&gt; is the result from a previous append operation (not from the latest append operation), so it &lt;strong&gt;copies&lt;/strong&gt; the contents of &lt;code&gt;Bin1&lt;/code&gt; to a new binary, reserve extra storage, and so on. (Here is not explained how the runtime system can know that it is not allowed to write into &lt;code&gt;Bin1&lt;/code&gt;; it is left as an exercise to the curious reader to figure out how it is done by reading the emulator sources, primarily &lt;code&gt;erl_bits.c&lt;/code&gt;.)</source>
          <target state="translated">Система времени выполнения видит, что &lt;code&gt;Bin1&lt;/code&gt; является результатом предыдущей операции добавления (а не последней операции добавления), поэтому она &lt;strong&gt;копирует&lt;/strong&gt; содержимое &lt;code&gt;Bin1&lt;/code&gt; в новый двоичный файл, резервирует дополнительное хранилище и так далее. (Здесь не объясняется, как исполняющая система может узнать, что запись в &lt;code&gt;Bin1&lt;/code&gt; запрещена ; любопытному читателю предоставляется в качестве упражнения выяснить, как это делается, читая исходные &lt;code&gt;erl_bits.c&lt;/code&gt; эмулятора, в первую очередь erl_bits.c .)</target>
        </trans-unit>
        <trans-unit id="68dc9c39652a0fdf0a0c35a5221cd9cab865f995" translate="yes" xml:space="preserve">
          <source>The runtime system terminates if the Erlang shell is terminated.</source>
          <target state="translated">В случае завершения работы оболочки Erlang система завершает работу.</target>
        </trans-unit>
        <trans-unit id="8b6b04664129c94fdc81f4426dc13b0df0dd9a3c" translate="yes" xml:space="preserve">
          <source>The runtime system thread that caused the crash dump</source>
          <target state="translated">Поток системы,вызвавший аварийный сброс.</target>
        </trans-unit>
        <trans-unit id="4f7e46dc24b0cfeac08d7cf03ae6775df22b65c6" translate="yes" xml:space="preserve">
          <source>The runtime system uses port-level locking on all ports executing this driver instead of driver-level locking when the driver is run in a runtime system with SMP support. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt; erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788e5f8c02e60181a54b252b202da78929f68515" translate="yes" xml:space="preserve">
          <source>The runtime system uses port-level locking on all ports executing this driver instead of driver-level locking when the driver is run in a runtime system with SMP support. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Система времени выполнения использует блокировку на уровне порта для всех портов, на которых выполняется этот драйвер, вместо блокировки на уровне драйвера, когда драйвер запускается в системе времени выполнения с поддержкой SMP. Для получения дополнительной информации см. &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="625eb63fcb0f8ad6e285974d83dcb34f448ce002" translate="yes" xml:space="preserve">
          <source>The runtime user interface for exclusive decode consists of the following two functions:</source>
          <target state="translated">Интерфейс пользователя для эксклюзивного декодирования состоит из следующих двух функций:</target>
        </trans-unit>
        <trans-unit id="10052e899db5ca3ebb8a3e418f1fe079cb6f6070" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;BootArgs&lt;/code&gt; are used when restarting the system unless the &lt;code&gt;mode&lt;/code&gt; option is given, allowing the code loading mode to be set to either &lt;code&gt;embedded&lt;/code&gt; or &lt;code&gt;interactive&lt;/code&gt;. All other &lt;code&gt;BootArgs&lt;/code&gt; remain the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b6a0c2dcea74f8fdf356aa85c68643c16e46c9" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;ct_hooks&lt;/code&gt; statement without the configuration file would cause HTML logging of all NETCONF connections in to the test case HTML log.</source>
          <target state="translated">Тот же оператор &lt;code&gt;ct_hooks&lt;/code&gt; без файла конфигурации вызовет HTML- запись всех соединений NETCONF в HTML-журнал тестового примера.</target>
        </trans-unit>
        <trans-unit id="a3709997045bd7e766642b396a1ae2ff1790a0c5" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#NEWER_REFERENCE_EXT&quot;&gt; NEWER_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;&lt;strong&gt;except&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cafba0455eaee6936a3e5ea593c4c5aeb6bf49c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt; NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; except &lt;code&gt;ID&lt;/code&gt; is only one word (&lt;code&gt;Len&lt;/code&gt; = 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea96b7a47c7fc1b8ece94f94b50b492d47704af4" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#atom_to_binary-2&quot;&gt;atom_to_binary &lt;/a&gt;&lt;/code&gt;&lt;code&gt;(Atom, utf8)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b840cffdebe323b082a218d46a487482c44da" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom &lt;/a&gt;&lt;/code&gt;&lt;code&gt;(Binary, utf8)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16253d023286775d0b13863a202d80291f45e4b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#binary_to_existing_atom-2&quot;&gt; binary_to_existing_atom&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(Binary, utf8)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32303bc64eb7b0ab0bc9a4d9709684faf012a52" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt; check_process_code(Pid, Module, []) &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d70dc4cc333eac788e481d9bbdc225c08c481a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2aaed7b59951ec082934bf672a9d13e59338ac6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Actions = []&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered. This creates an anonymous server.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;Actions = []&lt;/code&gt; за исключением того, что &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; должен быть зарегистрирован. Это создает анонимный сервер.</target>
        </trans-unit>
        <trans-unit id="00ce5e89ff01ab82881d9162fffdab56312f4944" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt; garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01deb53c6f9077db7db997ce628218c4238aba6e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acdff1fb52f7f6abb40837b1c3ed5e2d87b9d73a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt; but the &lt;code&gt;Option&lt;/code&gt;&lt;code&gt;{netns, Namespace}&lt;/code&gt; sets a network namespace for the OS call, on platforms that supports that feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b6d66e5228a9dab8918f6a6c98f7d11d0ba7da" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt; halt(Status, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85756b3d7fbfe5ef4170983b9b2a6fc5fb5e5087" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="1e5fb0bebe29ee84d11970a1ce3108bad78b288e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="5489eea97ac0b20ab3a3e94d0baa556249bc9b91" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#restart-1&quot;&gt;restart([])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fefb7e584cdbf5a581059aa7dafa15348d8ceb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest, Msg, [nosuspend | Options])&lt;/a&gt;&lt;/code&gt;, but with a Boolean return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ab0cbd248cdcbee578633286dab593f1d8ff75" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest, Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt;, but returns &lt;code&gt;true&lt;/code&gt; if the message was sent and &lt;code&gt;false&lt;/code&gt; if the message was not sent because the sender would have had to be suspended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa8e723ce6c07be8e482111c905cf750f679e8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt;, but with a Boolean return value.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt; , но с возвращаемым значением типа Boolean.</target>
        </trans-unit>
        <trans-unit id="d2197ab46f758634a9dcf871583d61827a00cf65" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt;, but returns &lt;code&gt;true&lt;/code&gt; if the message was sent and &lt;code&gt;false&lt;/code&gt; if the message was not sent because the sender would have had to be suspended.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt; , но возвращает &lt;code&gt;true&lt;/code&gt; если сообщение было отправлено, и &lt;code&gt;false&lt;/code&gt; если сообщение не было отправлено, потому что отправителя пришлось бы приостановить.</target>
        </trans-unit>
        <trans-unit id="17dbd65d2e71dbcfa15810e97f9ccf3f0bc406e6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(Node,erlang,apply,[Fun,[]],Options)&lt;/a&gt;&lt;/code&gt;. That is, a spawn request using the fun &lt;code&gt;Fun&lt;/code&gt; of arity zero as entry point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1075e0e25bfb14e858cab7e38be5445bc5ac4682" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;, except that it also include information about all dirty I/O schedulers.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; , за исключением того, что она также включает информацию обо всех грязных планировщиках ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="f4ceb7a27c576e85ef9e754da89ddaf1dfd654ed" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b72b3a948c1e65ff99938c20b299ba036c263f7" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae50f76bc5179efbef54eeac2130b4b037ae6a9" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt;, retained for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feaf6b5c71e3fafb1e75897b45c0e3840025bb7c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt;, retained for backward compatibility.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt; , сохранено для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="d5a1ef850fec5e3df173bd9dd2c7e3dbb0636f60" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="619006029171444306cc4c87f6a95f63bb972338" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;compile(Regexp,[])&lt;/code&gt;</source>
          <target state="translated">То же, что и &lt;code&gt;compile(Regexp,[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d52831ded701ec877189bfcc53acad1352798f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;eval/1&lt;/code&gt;, but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. For information about the variable bindings, see &lt;code&gt;erl_eval(3)&lt;/code&gt;.</source>
          <target state="translated">То же, что &lt;code&gt;eval/1&lt;/code&gt; , но привязки переменных &lt;code&gt;Bindings&lt;/code&gt; используются в оценке. Для получения информации о привязках переменных см. &lt;code&gt;erl_eval(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08c1e708a98116e2d68d4f0a5026b6a10643e95a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebcfaf2f1268befcb2c2ddd0543f3e6acf79842" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47b9133116b8c5faac32e3c70f25a2bffa651d8f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;path_script/2&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">То же, что &lt;code&gt;path_script/2&lt;/code&gt; , но привязки переменных &lt;code&gt;Bindings&lt;/code&gt; используются в оценке. См. &lt;code&gt;erl_eval(3)&lt;/code&gt; о привязках переменных.</target>
        </trans-unit>
        <trans-unit id="40cc315183d06f20b4fd979426474e04d552a45f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;script/1&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">То же, что &lt;code&gt;script/1&lt;/code&gt; , но привязки переменных &lt;code&gt;Bindings&lt;/code&gt; используются в оценке. См. &lt;code&gt;erl_eval(3)&lt;/code&gt; о привязках переменных.</target>
        </trans-unit>
        <trans-unit id="e1e8982b6aae2a82fb446c9ac15561cf18afb817" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{bof, Offset}&lt;/code&gt;.</source>
          <target state="translated">То же, что и &lt;code&gt;{bof, Offset}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0277407f00337c8bdaf1cca96cdd266e8ea8198" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; with reasonable default values for &lt;code&gt;Size&lt;/code&gt; and &lt;code&gt;Delay&lt;/code&gt; (roughly some 64 KB, 2 seconds).</source>
          <target state="translated">То же, что и &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; с разумными значениями по умолчанию для &lt;code&gt;Size&lt;/code&gt; и &lt;code&gt;Delay&lt;/code&gt; (примерно 64 КБ, 2 секунды).</target>
        </trans-unit>
        <trans-unit id="6b2899bd1d4addd7a93d120f07f6e7b10a7d0282" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{keep_state,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9abc573bcafbc0ede0496d990dff24d6e1602d6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7228431770d5bb25829bb566f3e53142c058363b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{read_ahead, Size}&lt;/code&gt; with a reasonable default value for &lt;code&gt;Size&lt;/code&gt; (roughly some 64 KB).</source>
          <target state="translated">То же, что и &lt;code&gt;{read_ahead, Size}&lt;/code&gt; с разумным значением по умолчанию для &lt;code&gt;Size&lt;/code&gt; (примерно 64 КБ).</target>
        </trans-unit>
        <trans-unit id="fffe3043c0d576fd591d515cb53a9c26beff3c1c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4ea9e9c62a5f384a690dd1c1b7a864f413d95a" translate="yes" xml:space="preserve">
          <source>The same as above with &lt;code&gt;Offset&lt;/code&gt; 0.</source>
          <target state="translated">То же, что и выше, со &lt;code&gt;Offset&lt;/code&gt; 0.</target>
        </trans-unit>
        <trans-unit id="b7fb7711e2123424816edf13ae376ab2d5c4aacc" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#block_call-5&quot;&gt;rpc:block_call(Node, Module, Function, Args, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3087fc6d1e1d288aa13b376d8923b63a482b45" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:call(Node,erlang,apply,[Fun,[]],Timeout)&lt;/a&gt;&lt;/code&gt;. May raise all the same exceptions as &lt;code&gt;erpc:call/5&lt;/code&gt; plus an &lt;code&gt;{erpc, badarg}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception if &lt;code&gt;Fun&lt;/code&gt; is not a fun of zero arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e22e69dc4e1d35bdb54ddabf28dba9a56102a3" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:multicall(Nodes,erlang,apply,[Fun,[]],Timeout)&lt;/a&gt;&lt;/code&gt;. May raise all the same exceptions as &lt;code&gt;erpc:multicall/5&lt;/code&gt; plus an &lt;code&gt;{erpc, badarg}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception if &lt;code&gt;Fun&lt;/code&gt; is not a fun of zero arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee35c7530384a3e971280a311d28237b1c1f4112" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:send_request(Node,erlang,apply,[Fun,[]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2663f078e97ac60be1391fffa07548dd9dddda25" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;rpc:call(Node, Module, Function, Args, Timeout)&lt;/a&gt;&lt;/code&gt; with the exception that it also blocks other &lt;code&gt;rpc:block_call()&lt;/code&gt; operations from executing concurrently on the node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6f525a67ffb4882ef9baaad9bc0a4226046d4a" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#cast-4&quot;&gt;erpc:cast(Node,erlang,apply,[Fun,[]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61097ae2d1a418f76c6a736c6fdbdb81a93b1f3" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#cast-4&quot;&gt;erpc:multicast(Nodes,erlang,apply,[Fun,[]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b12e07cbe44403181759c4034c4f3d2fe0c1ce" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">То же, что и &lt;code&gt;lists:sum(&lt;/code&gt; вызовов : sum ( &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; , но более эффективно.</target>
        </trans-unit>
        <trans-unit id="71c6f84a59f77755e69a52beb91ed4b1a4c03ff2" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">То же, что и &lt;code&gt;lists:sum(&lt;/code&gt; вызовов : сумма ( &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; , но более эффективно.</target>
        </trans-unit>
        <trans-unit id="ee4e69e3e7435faa22aa0647b7b837e57300ad5e" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">То же, что и &lt;code&gt;lists:sum(&lt;/code&gt; вызовов : сумма ( &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; , но более эффективно.</target>
        </trans-unit>
        <trans-unit id="4780b4915f09916bc2a903be56062c7fb948d806" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">То же, что и &lt;code&gt;lists:sum(&lt;/code&gt; вызовов : сумма ( &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; , но более эффективно.</target>
        </trans-unit>
        <trans-unit id="bf890bcea15d91e1f7af9ee8721c2b6276c19354" translate="yes" xml:space="preserve">
          <source>The same as eariler with &lt;code&gt;Offset&lt;/code&gt; 0, that is, &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt;.</source>
          <target state="translated">То же, что и Eariler со &lt;code&gt;Offset&lt;/code&gt; 0, то есть &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f54a8f32c826632119e96a56421e6183f9acc41" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-3&quot;&gt;spawn_request(Node,Fun,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e24153272f6cb2370114e16e592dbcdb26422d5" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-3&quot;&gt;spawn_request(node(),Fun,Options)&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e954c34db34f236fe12717f394cd92ea286c58" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-3&quot;&gt;spawn_request(node(),Fun,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba851e8e2b9c4b92403c2b4b7f3862971b2da77" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(Node,Module,Function,Args,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b62a093725450c7a9da971419193226f8402b35" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(node(),Module,Function,Args,Options)&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6560052e03ae63c0339d4867d19863becd398766" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(node(),Module,Function,Args,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c0a4c6fa2c41025ffdbf6a4c8cdfc2dbae33ea" translate="yes" xml:space="preserve">
          <source>The same example as in the &lt;code&gt;&lt;a href=&quot;#example-of-crypto_one_time-5&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt;, but now with one call to &lt;code&gt;&lt;a href=&quot;crypto#crypto_one_time_aead-6&quot;&gt;crypto_one_time_aead/6&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab38c5d8455e8d0889435a58218240d925e13378" translate="yes" xml:space="preserve">
          <source>The same example as in the &lt;code&gt;&lt;a href=&quot;#examples-of-crypto_init-4-and-crypto_update-2&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt;, but now with one call to &lt;code&gt;&lt;a href=&quot;crypto#crypto_one_time-5&quot;&gt;crypto_one_time/5&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efec8691cd75c256c32c494b80c6d71a6ded7b5a" translate="yes" xml:space="preserve">
          <source>The same example as the first sign example, except that a password protects the key down in the Engine.</source>
          <target state="translated">Тот же пример,что и в примере с первым знаком,за исключением того,что пароль защищает ключ вниз в двигателе.</target>
        </trans-unit>
        <trans-unit id="435f34be8c79fde6527a5114b17d96ad43869933" translate="yes" xml:space="preserve">
          <source>The same example but now using the Erlang ssh client to contact the Erlang server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6845f7d38c3df436bd3fca0892dbe8ee97c2a305" translate="yes" xml:space="preserve">
          <source>The same example but using the Erlang ssh client:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11685d22af41c7bdec311d8efb6717608cc97597" translate="yes" xml:space="preserve">
          <source>The same failure as for &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тот же сбой, что и у &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37284fa9bdbec3125fb6f5f2938b0a9140415e5c" translate="yes" xml:space="preserve">
          <source>The same happens if you insert a binary into an Ets table, send it to a port using &lt;code&gt;erlang:port_command/2&lt;/code&gt;, or pass it to &lt;code&gt;enif_inspect_binary&lt;/code&gt; in a NIF.</source>
          <target state="translated">То же самое происходит, если вы вставляете двоичный файл в таблицу Ets, отправляете его в порт с помощью &lt;code&gt;erlang:port_command/2&lt;/code&gt; или передаете его в &lt;code&gt;enif_inspect_binary&lt;/code&gt; в NIF.</target>
        </trans-unit>
        <trans-unit id="8dd676fc032f39da8f11e805e928df982b381e69" translate="yes" xml:space="preserve">
          <source>The same logic applies to explicitly imported functions from other modules, as to locally defined functions. It is not allowed to both import a function from another module and have the function declared in the module at the same time:</source>
          <target state="translated">Та же логика применима и к явно импортируемым функциям из других модулей,как и к локально определенным функциям.Не разрешается одновременно импортировать функцию из другого модуля и иметь функцию,объявленную в модуле:</target>
        </trans-unit>
        <trans-unit id="c9a8dd64d3d825a10122f8306efa89f8d1dff40d" translate="yes" xml:space="preserve">
          <source>The same occurs if &lt;code&gt;Dest&lt;/code&gt; refers to a local port that is busy. For all other destinations (allowed for the ordinary send operator &lt;code&gt;'!'&lt;/code&gt;), this function sends the message and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">То же самое происходит, если &lt;code&gt;Dest&lt;/code&gt; указывает на занятый локальный порт. Для всех других мест назначения (разрешенных для обычного оператора отправки &lt;code&gt;'!'&lt;/code&gt; ) Эта функция отправляет сообщение и возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c986670ac5f53fe5b7d5d769f706fae8b44b1bd" translate="yes" xml:space="preserve">
          <source>The same principles of serialization apply when passing resource terms in messages to remote nodes and back again. A resource term will act stale on all nodes except the node where its resource object is still alive in memory.</source>
          <target state="translated">Те же принципы сериализации применяются при передаче терминов ресурса в сообщениях на удаленные узлы и обратно.Термин ресурса будет действовать неактуально на всех узлах,кроме узла,где его объект ресурса еще жив в памяти.</target>
        </trans-unit>
        <trans-unit id="4f281f033368479cef02a66d827c4b8a6fe27bfd" translate="yes" xml:space="preserve">
          <source>The same problem can occur for dirty updates. The overload is detected locally on the current node, but its cause can be on another node. Application processes can cause high load if any table resides on another node (replicated or not). By default this event is reported to &lt;code&gt;error_logger.&lt;/code&gt;</source>
          <target state="translated">Та же проблема может возникнуть и с грязными обновлениями. Перегрузка обнаружена локально на текущем узле, но ее причина может быть на другом узле. Прикладные процессы могут вызвать высокую нагрузку, если какая-либо таблица находится на другом узле (реплицированном или нет). По умолчанию об этом событии сообщается &lt;code&gt;error_logger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb9bbb6e34766185444c1af2a9a7f778b5a58e67" translate="yes" xml:space="preserve">
          <source>The same program can also be written as:</source>
          <target state="translated">Та же самая программа может быть написана как:</target>
        </trans-unit>
        <trans-unit id="2fc6942530a03944111630cfbde674aeb2b9833c" translate="yes" xml:space="preserve">
          <source>The same reasons for using the parse transformation apply to &lt;code&gt;dbg&lt;/code&gt;, maybe even more, as filtering using Erlang code is not a good idea when tracing (except afterwards, if you trace to file). The concept is similar to that of &lt;code&gt;ets:fun2ms/1&lt;/code&gt; except that you usually use it directly from the shell (which can also be done with &lt;code&gt;ets:fun2ms/1&lt;/code&gt;).</source>
          <target state="translated">Те же причины для использования преобразования синтаксического анализа применимы к &lt;code&gt;dbg&lt;/code&gt; , возможно, даже больше, поскольку фильтрация с использованием кода Erlang не является хорошей идеей при трассировке (за исключением последующего, если вы трассируете до файла). Концепция аналогична концепции &lt;code&gt;ets:fun2ms/1&lt;/code&gt; , за исключением того, что вы обычно используете ее непосредственно из оболочки (что также можно сделать с помощью &lt;code&gt;ets:fun2ms/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="be2c67bb51461ede16f91f4276fe7a51514360a8" translate="yes" xml:space="preserve">
          <source>The same result can be obtained by using the flag &lt;code&gt;call&lt;/code&gt; only and setting a match specification on local or global function calls as follows:</source>
          <target state="translated">Тот же результат можно получить, используя только &lt;code&gt;call&lt;/code&gt; флага и задав спецификацию соответствия для локальных или глобальных вызовов функций следующим образом:</target>
        </trans-unit>
        <trans-unit id="6367b3aadbf1b22efb4fe6d60edce34f7915ed4d" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used by the preprocessor, which supports file inclusion, macros, and conditional compilation:</source>
          <target state="translated">Тот же синтаксис,что и для атрибутов модуля,используется препроцессором,который поддерживает включение файлов,макросы и условную компиляцию:</target>
        </trans-unit>
        <trans-unit id="1ba61a6106c571f4543444dde7af8861fee4288b" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for changing the pre-defined macros &lt;code&gt;?FILE&lt;/code&gt; and &lt;code&gt;?LINE&lt;/code&gt;:</source>
          <target state="translated">Тот же синтаксис, что и для атрибутов модуля, используется для изменения предопределенных макросов &lt;code&gt;?FILE&lt;/code&gt; и &lt;code&gt;?LINE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49b27eed80040be071f7bd6b90b55a6ca7a1a602" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for record definitions:</source>
          <target state="translated">Для определения записи используется тот же синтаксис,что и для атрибутов модуля:</target>
        </trans-unit>
        <trans-unit id="652d4a8a5d229c7cd102ddf9155b41205986af36" translate="yes" xml:space="preserve">
          <source>The same, provided there are &amp;lt; 40 previous capturing subpatterns</source>
          <target state="translated">То же самое, если имеется &amp;lt;40 предыдущих подшаблонов захвата.</target>
        </trans-unit>
        <trans-unit id="1f8c820898fda9a674e186f206f12995037f99bb" translate="yes" xml:space="preserve">
          <source>The scanner will, by default, be built as a reentrant scanner &lt;strong&gt;if&lt;/strong&gt; the flex utility supports this (it depends on the version of flex). It is possible to explicitly disable this even when flex support this. Use &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; when configuring the application.</source>
          <target state="translated">Сканер по умолчанию будет построен как реентерабельный сканер, &lt;strong&gt;если&lt;/strong&gt; утилита flex поддерживает это (это зависит от версии flex). Это можно явно отключить, даже если это поддерживает flex. Используйте &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; при настройке приложения.</target>
        </trans-unit>
        <trans-unit id="0106bb004e9ef4cae180d81bd2193ccedbf77a79" translate="yes" xml:space="preserve">
          <source>The scanning was successful. &lt;code&gt;Tokens&lt;/code&gt; is the list of tokens including &lt;strong&gt;dot&lt;/strong&gt;.</source>
          <target state="translated">Сканирование прошло успешно. &lt;code&gt;Tokens&lt;/code&gt; - это список токенов, включая &lt;strong&gt;точку&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2eae5d531637391bdf1a2942db36f759f3d1ab" translate="yes" xml:space="preserve">
          <source>The scenario is illustrated in the following figure:</source>
          <target state="translated">Сценарий проиллюстрирован на следующем рисунке:</target>
        </trans-unit>
        <trans-unit id="1b0072021dd8918e3e4a00150a4be77d097faeb0" translate="yes" xml:space="preserve">
          <source>The scheduler bind type can also be set by passing command-line argument &lt;code&gt; +sbt&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb445fb55208c8d6300f1c0c3c7ddd0fdd5dffb" translate="yes" xml:space="preserve">
          <source>The scheduler bind type can also be set by passing command-line argument &lt;code&gt;+sbt&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Тип привязки планировщика также можно установить, передав аргумент командной строки &lt;code&gt;+sbt&lt;/code&gt; в &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9aa6c41e456afc02a165b00e6454af974767459" translate="yes" xml:space="preserve">
          <source>The scheduler ids whose allocator instances will be searched. A scheduler id of 0 will refer to the global instance that is not tied to any particular scheduler. Defaults to all schedulers and the global instance.</source>
          <target state="translated">Идентификаторы планировщиков,чьи экземпляры аллокаторов будут искаться.Ид планировщика,равный 0,будет относиться к глобальному экземпляру,который не привязан ни к одному конкретному планировщику.По умолчанию все планировщики и глобальный экземпляр.</target>
        </trans-unit>
        <trans-unit id="f8238b4700efd0d55eb3ba098718fdc8466aa0bb" translate="yes" xml:space="preserve">
          <source>The schema file and all other files that Mnesia needs are kept in the Mnesia directory. The command-line option &lt;code&gt;-mnesia dir Dir&lt;/code&gt; can be used to specify the location of this directory to the Mnesia system. If no such command-line option is found, the name of the directory defaults to &lt;code&gt;Mnesia.Node&lt;/code&gt;.</source>
          <target state="translated">Файл схемы и все другие файлы, которые нужны Mnesia, хранятся в каталоге Mnesia. Параметр командной строки &lt;code&gt;-mnesia dir Dir&lt;/code&gt; может использоваться для указания местоположения этого каталога в системе Mnesia. Если такой параметр командной строки не найден, имя каталога по умолчанию - &lt;code&gt;Mnesia.Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3f92f1963a15447bf5f1771a2c485f240d49382" translate="yes" xml:space="preserve">
          <source>The schema functions are as follows:</source>
          <target state="translated">Функции схемы следующие:</target>
        </trans-unit>
        <trans-unit id="6c514498238aab18641162374c9ebc46e751b79e" translate="yes" xml:space="preserve">
          <source>The schema in the backup file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been used to generate the file &lt;code&gt;schema.DAT&lt;/code&gt;. Since there are no other disc resident tables than the schema, no other data files were created. The file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; was removed after the successful &quot;restoration&quot;. You also see some files that are for internal use by &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">Схема в файле резервной копии &lt;code&gt;FALLBACK.BUP&lt;/code&gt; использовалась для создания &lt;code&gt;schema.DAT&lt;/code&gt; . Поскольку на диске нет других резидентных таблиц, кроме схемы, никаких других файлов данных создано не было. После успешного &amp;laquo;восстановления&amp;raquo; файл &lt;code&gt;FALLBACK.BUP&lt;/code&gt; был удален. Вы также видите некоторые файлы, предназначенные для внутреннего использования &lt;code&gt;Mnesia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0d7180f9e8c49acad7689271d60b75c4177036" translate="yes" xml:space="preserve">
          <source>The schema itself is a table and is possibly included in the backup. Each node where the schema table resides is regarded as a &lt;code&gt;db_node&lt;/code&gt;.</source>
          <target state="translated">Сама схема представляет собой таблицу и, возможно, включена в резервную копию. Каждый узел, на котором находится таблица схемы, рассматривается как &lt;code&gt;db_node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd14602cf9237e1ff86bf0c3f394217395aea3d" translate="yes" xml:space="preserve">
          <source>The schema table can, as other tables, reside on one or more nodes. The storage type of the schema table can either be &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;ram_copies&lt;/code&gt; (but not &lt;code&gt;disc_only_copies&lt;/code&gt;). At startup, &lt;code&gt;Mnesia&lt;/code&gt; uses its schema to determine with which nodes it is to try to establish contact. If any other node is started already, the starting node merges its table definitions with the table definitions brought from the other nodes. This also applies to the definition of the schema table itself. Application parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; contains a list of nodes that &lt;code&gt;Mnesia&lt;/code&gt; also is to establish contact with besides those found in the schema. Default is &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">Таблица схемы может, как и другие таблицы, находиться на одном или нескольких узлах. Тип хранения таблицы схемы может быть &lt;code&gt;disc_copies&lt;/code&gt; или &lt;code&gt;ram_copies&lt;/code&gt; (но не &lt;code&gt;disc_only_copies&lt;/code&gt; ). При запуске &lt;code&gt;Mnesia&lt;/code&gt; использует свою схему, чтобы определить, с какими узлами следует попытаться установить контакт. Если какой-либо другой узел уже запущен, начальный узел объединяет определения своих таблиц с определениями таблиц, полученными от других узлов. Это также относится к определению самой таблицы схемы. Параметр приложения &lt;code&gt;extra_db_nodes&lt;/code&gt; содержит список узлов, с которыми &lt;code&gt;Mnesia&lt;/code&gt; также должна установить контакт, помимо тех, что указаны в схеме. По умолчанию &lt;code&gt;[]&lt;/code&gt; (пустой список).</target>
        </trans-unit>
        <trans-unit id="503d5a4fc67df91a919a603a14d890c204b2864e" translate="yes" xml:space="preserve">
          <source>The scheme portion of the URI gets converted into atom, meaning that atom leak may occur. Specifying a scheme validation fun is recommended unless the URI is already sanitized.</source>
          <target state="translated">Часть схемы URI преобразуется в атом,что означает,что может произойти утечка атома.Рекомендуется указывать забавный способ проверки схемы,если только URI уже не дезинфицирован.</target>
        </trans-unit>
        <trans-unit id="d3677cc5dde8dec9f0943fbc75e45b112aeaf536" translate="yes" xml:space="preserve">
          <source>The scope for a variable is its function clause. Variables bound in a branch of an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, or &lt;code&gt;receive&lt;/code&gt; expression must be bound in all branches to have a value outside the expression. Otherwise they are regarded as 'unsafe' outside the expression.</source>
          <target state="translated">Область видимости переменной - это ее функциональное предложение. Переменные, связанные в ветви выражения &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; или &lt;code&gt;receive&lt;/code&gt; , должны быть связаны во всех ветвях, чтобы иметь значение вне выражения. В противном случае они считаются &amp;laquo;небезопасными&amp;raquo; вне выражения.</target>
        </trans-unit>
        <trans-unit id="c6288b2668a38169687226d8d788cc7da7e3e234" translate="yes" xml:space="preserve">
          <source>The scope of a &lt;code&gt;::&lt;/code&gt; constraint is the &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; specification after which it appears. To avoid confusion, it is suggested that different variables are used in different constituents of an overloaded contract, as shown in the following example:</source>
          <target state="translated">Область действия &lt;code&gt;::&lt;/code&gt; constraint - это спецификация &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; после которой оно появляется. Чтобы избежать путаницы, предлагается использовать разные переменные в разных составляющих перегруженного контракта, как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="6888ff9909aa4d3472400691e9c55573d784edc2" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in funs are as follows:</source>
          <target state="translated">Для переменных,встречающихся в funs,действуют следующие правила:</target>
        </trans-unit>
        <trans-unit id="4404d931933003579634af4e100185e648005e9e" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in list comprehensions are as follows:</source>
          <target state="translated">Для переменных,которые встречаются в понимании списка,правила области применения следующие:</target>
        </trans-unit>
        <trans-unit id="57d16d66e3e9f378f0fafcdd50a83455cdc8ed0f" translate="yes" xml:space="preserve">
          <source>The script is checked for syntactic and semantic correctness before it is run. If there are warnings (such as unused variables), they are printed and the script will still be run. If there are errors, they are printed and the script will not be run and its exit status is &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">Перед запуском скрипт проверяется на синтаксическую и семантическую корректность. Если есть предупреждения (например, о неиспользуемых переменных), они печатаются, и сценарий все равно будет запущен. Если есть ошибки, они распечатываются, и скрипт не запускается, а его статус выхода &lt;code&gt;127&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb62b1588228fdb2e00bea0a69e7992a3a90205" translate="yes" xml:space="preserve">
          <source>The search is retried with options &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character (&lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Поиск повторяется с параметрами &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; в той же позиции, что не дает интересного результата большей длины, поэтому позиция поиска продвигается к следующему символу ( &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4117f8cd43f5fed32f2aebfe701accad0f731400" translate="yes" xml:space="preserve">
          <source>The search once again matches the empty string, giving &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt;.</source>
          <target state="translated">Поиск снова соответствует пустой строке, давая &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2957d4c2e73e120f5160a9d5de1e8eab79ab85bf" translate="yes" xml:space="preserve">
          <source>The search results in &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt;, so this search is also repeated with the extra options.</source>
          <target state="translated">Результаты поиска в &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt; , поэтому этот поиск также повторяется с дополнительными параметрами.</target>
        </trans-unit>
        <trans-unit id="7019ec1c2fea8d709b52cfb8681127b05dd6a6ce" translate="yes" xml:space="preserve">
          <source>The second argument is a string defining the magic cookie.</source>
          <target state="translated">Второй аргумент-строка,определяющая волшебное куки.</target>
        </trans-unit>
        <trans-unit id="5d7c556937d2f0d9d84069b86f16a68647203e8c" translate="yes" xml:space="preserve">
          <source>The second argument is the &lt;code&gt;Config&lt;/code&gt; key-value list of runtime configuration data, which has the same value as the list returned by &lt;code&gt;init_per_suite&lt;/code&gt;. &lt;code&gt;init_per_testcase/2&lt;/code&gt; can modify this parameter or return it &quot;as is&quot;. The return value of &lt;code&gt;init_per_testcase/2&lt;/code&gt; is passed as parameter &lt;code&gt;Config&lt;/code&gt; to the test case itself.</source>
          <target state="translated">Второй аргумент - это список ключей и значений &lt;code&gt;Config&lt;/code&gt; данных конфигурации среды выполнения, который имеет то же значение, что и список, возвращаемый &lt;code&gt;init_per_suite&lt;/code&gt; . &lt;code&gt;init_per_testcase/2&lt;/code&gt; может изменить этот параметр или вернуть его &amp;laquo;как есть&amp;raquo;. Возвращаемое значение &lt;code&gt;init_per_testcase/2&lt;/code&gt; передается как параметр &lt;code&gt;Config&lt;/code&gt; в сам тестовый пример.</target>
        </trans-unit>
        <trans-unit id="ab475df1b91ae9d944e6820d1389807d78bf68f6" translate="yes" xml:space="preserve">
          <source>The second argument is the array of &lt;code&gt;ErlNifFunc&lt;/code&gt; structures containing name, arity, and function pointer of each NIF.</source>
          <target state="translated">Второй аргумент - это массив структур &lt;code&gt;ErlNifFunc&lt;/code&gt; , содержащий имя, арность и указатель функции каждого NIF.</target>
        </trans-unit>
        <trans-unit id="0886faad82449f45fc6af07be32433d58c83fd99" translate="yes" xml:space="preserve">
          <source>The second argument is the name of the module (&lt;code&gt;ch4&lt;/code&gt;).</source>
          <target state="translated">Второй аргумент - это имя модуля ( &lt;code&gt;ch4&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ae91f868e0e36c5aab81d0643e970c9ad85647d4" translate="yes" xml:space="preserve">
          <source>The second argument is the plain node name.</source>
          <target state="translated">Второй аргумент-простое имя узла.</target>
        </trans-unit>
        <trans-unit id="68aa2b0acb6c307f4edca5d2585ef7f3b4bc172b" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;erl_accept&lt;/code&gt; is a struct &lt;code&gt;ErlConnect&lt;/code&gt; which contains useful information when a connection has been established, for example, the name of the Erlang node.</source>
          <target state="translated">Второй аргумент &lt;code&gt;erl_accept&lt;/code&gt; - это структура &lt;code&gt;ErlConnect&lt;/code&gt; , которая содержит полезную информацию, когда соединение было установлено, например, имя узла Erlang.</target>
        </trans-unit>
        <trans-unit id="fa4ea88aab8e44c4912833f7bf79be8a3c8b83f1" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;select&lt;/code&gt; is a &lt;code&gt;MatchSpecification&lt;/code&gt;. A &lt;code&gt;MatchSpecification&lt;/code&gt; is a list of &lt;code&gt;MatchFunction&lt;/code&gt;s, where each &lt;code&gt;MatchFunction&lt;/code&gt; consists of a tuple containing &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt;:</source>
          <target state="translated">Второй аргумент для &lt;code&gt;select&lt;/code&gt; - это &lt;code&gt;MatchSpecification&lt;/code&gt; . &lt;code&gt;MatchSpecification&lt;/code&gt; список &lt;code&gt;MatchFunction&lt;/code&gt; с, где каждый &lt;code&gt;MatchFunction&lt;/code&gt; состоит из кортежа , содержащего &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="859328262eb9b89de95770488ed8f287011c831c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;ttb:format/2&lt;/code&gt; is a list of options as follows:</source>
          <target state="translated">Второй аргумент &lt;code&gt;ttb:format/2&lt;/code&gt; - это следующий список опций:</target>
        </trans-unit>
        <trans-unit id="d294655854fb12427e99c41c78c6470facb9f485" translate="yes" xml:space="preserve">
          <source>The second argument to the filter fun.</source>
          <target state="translated">Второй аргумент в пользу удовольствия от фильтрации.</target>
        </trans-unit>
        <trans-unit id="5cfc99aab85772fdcb54b5e4fa0185d94a797c5c" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;?MODULE&lt;/code&gt;, is the name of the &lt;strong&gt;callback module&lt;/strong&gt;, that is, the module where the callback functions are located, which is this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06be8768f8415da3e4862a8bcd381b621322fa1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;?MODULE&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located, which is this module.</source>
          <target state="translated">Второй аргумент &lt;code&gt;?MODULE&lt;/code&gt; - это имя модуля обратного вызова, то есть модуля, в котором расположены функции обратного вызова, то есть этого модуля.</target>
        </trans-unit>
        <trans-unit id="e11f122b81a9ab6f35f17499a7c2e31dc0343a63" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">Второй аргумент, &lt;code&gt;[]&lt;/code&gt; , - это термин, который передается функции обратного вызова &lt;code&gt;init&lt;/code&gt; как есть . Здесь &lt;code&gt;init&lt;/code&gt; не требует никаких данных и игнорирует аргумент.</target>
        </trans-unit>
        <trans-unit id="b862edb2184436a21646c9503b2f3762af04c9d1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;ch3&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located.</source>
          <target state="translated">Второй аргумент, &lt;code&gt;ch3&lt;/code&gt; , - это имя модуля обратного вызова, то есть модуля, в котором расположены функции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="12a6cc1ddca791145f200b7b0393d7c9270fb068" translate="yes" xml:space="preserve">
          <source>The second clause sends a message to &quot;pong&quot;:</source>
          <target state="translated">Второе положение посылает сообщение на &quot;понг&quot;:</target>
        </trans-unit>
        <trans-unit id="ae66ead42b1de13d39f41d149d9d7854f9c8aab9" translate="yes" xml:space="preserve">
          <source>The second connection is a session resumption using keying material from the previous handshake:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7315fa80ba44205c16b829da74dfc058d1a1d7a4" translate="yes" xml:space="preserve">
          <source>The second element of the PEM-entry is the ASN.1 &lt;code&gt;DER&lt;/code&gt; encoded key data:</source>
          <target state="translated">Второй элемент PEM-записи - это данные ключа в кодировке ASN.1 &lt;code&gt;DER&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c40944389ed2e7f80311414a40c89625de90b8fe" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is a string (list of characters) representing the filename of the source file of the function.</source>
          <target state="translated">Вторым элементом кортежа является строка (список символов),представляющая собой имя файла исходного файла функции.</target>
        </trans-unit>
        <trans-unit id="30419a9fbcf62ba4094ad4eff3e638ac58c744c8" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is the line number (an integer &amp;gt; 0) in the source file where the exception occurred or the function was called.</source>
          <target state="translated">Второй элемент кортежа - это номер строки (целое число&amp;gt; 0) в исходном файле, где произошло исключение или была вызвана функция.</target>
        </trans-unit>
        <trans-unit id="bc7d989f87dede2e2ca73a50e9ef9b041bd4465f" translate="yes" xml:space="preserve">
          <source>The second instruction, &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt;, takes component &lt;code&gt;number&lt;/code&gt; in the &lt;code&gt;handle&lt;/code&gt; component of type &lt;code&gt;Action&lt;/code&gt;. If the value is &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt;, the internal value 4711 is to be picked by &lt;code&gt;selected_decode_Action&lt;/code&gt;. In an Erlang terminal it looks as follows:</source>
          <target state="translated">Вторая инструкция, &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt; , принимает &lt;code&gt;number&lt;/code&gt; компонента в &lt;code&gt;handle&lt;/code&gt; компонента типа &lt;code&gt;Action&lt;/code&gt; . Если значение равно &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt; , внутреннее значение 4711 должно быть выбрано &lt;code&gt;selected_decode_Action&lt;/code&gt; . В терминале Erlang это выглядит так:</target>
        </trans-unit>
        <trans-unit id="09b4b4758afce0f888fa8c4488323d46e48b894d" translate="yes" xml:space="preserve">
          <source>The second is the maximum value since the last call to &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">Вторая - максимальное значение с момента последнего вызова &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cb423e42dd15bcd7222df4611672554d769f082" translate="yes" xml:space="preserve">
          <source>The second level is at the MPD entry / exit point, i.e. immediately after the basic message processing (accept_recv_pdu) / immediately before the basic message processing (accept_send_pdu).</source>
          <target state="translated">Второй уровень находится в точке входа/выхода MPD,т.е.непосредственно после обработки основного сообщения (accept_recv_pdu)/непосредственно перед обработкой основного сообщения (accept_send_pdu).</target>
        </trans-unit>
        <trans-unit id="774b9d51f0c992a280af87374e7739fea47b5a73" translate="yes" xml:space="preserve">
          <source>The second line also says that this function can be called from outside the module &lt;code&gt;tut&lt;/code&gt;. More about this later. Again, notice the &quot;.&quot; at the end of the line.</source>
          <target state="translated">Во второй строке также говорится, что эту функцию можно вызывать извне модуля &lt;code&gt;tut&lt;/code&gt; . Подробнее об этом позже. Снова обратите внимание на &quot;.&quot; в конце строки.</target>
        </trans-unit>
        <trans-unit id="ea3a8607657a10cb904d6d19adb9e7a687aaf47e" translate="yes" xml:space="preserve">
          <source>The second line in the example contains an optional directive to the &lt;code&gt;Emacs&lt;/code&gt; editor, which causes it to enter the major mode for editing Erlang source files. If the directive is present, it must be located on the second line.</source>
          <target state="translated">Вторая строка в примере содержит необязательную директиву для редактора &lt;code&gt;Emacs&lt;/code&gt; , которая заставляет его войти в основной режим редактирования исходных файлов Erlang. Если директива присутствует, она должна находиться во второй строке.</target>
        </trans-unit>
        <trans-unit id="e7ea568009a70c36f6990dad1c35ac2c65ca7ebb" translate="yes" xml:space="preserve">
          <source>The second line says that the module &lt;code&gt;tut&lt;/code&gt; contains a function called &lt;code&gt;double&lt;/code&gt;, which takes one argument (&lt;code&gt;X&lt;/code&gt; in our example):</source>
          <target state="translated">Во второй строке говорится, что модуль &lt;code&gt;tut&lt;/code&gt; содержит функцию с именем &lt;code&gt;double&lt;/code&gt; , которая принимает один аргумент ( &lt;code&gt;X&lt;/code&gt; в нашем примере):</target>
        </trans-unit>
        <trans-unit id="1dd56257c238ab45a9b4f237dd6d44c5ddae2994" translate="yes" xml:space="preserve">
          <source>The second occurrence of &lt;code&gt;Age&lt;/code&gt; causes a test for equality between the terms, as &lt;code&gt;Age&lt;/code&gt; is already bound to &lt;code&gt;21&lt;/code&gt;. As &lt;code&gt;Age&lt;/code&gt; is bound to &lt;code&gt;21&lt;/code&gt;, the equality test succeeds and the match continues until the end of the pattern.</source>
          <target state="translated">Второе вхождение &lt;code&gt;Age&lt;/code&gt; вызывает проверку на равенство между терминами, так как &lt;code&gt;Age&lt;/code&gt; уже привязано к &lt;code&gt;21&lt;/code&gt; . Поскольку &lt;code&gt;Age&lt;/code&gt; привязан к &lt;code&gt;21&lt;/code&gt; , проверка на равенство завершается успешно, и соответствие продолжается до конца шаблона.</target>
        </trans-unit>
        <trans-unit id="5ada08cc44dca3d5604a8d151410616b99f7a2c2" translate="yes" xml:space="preserve">
          <source>The second operand pattern, &lt;code&gt;an&lt;/code&gt;, will match if the second operand is either an atom or NIL (the empty list). In case of a match, the &lt;code&gt;is_integer/2&lt;/code&gt; instruction will be replaced with a &lt;code&gt;jump/1&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03310e32ba86e2b90c5b008fd886764d7090dce" translate="yes" xml:space="preserve">
          <source>The second part -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382e51e975a6ee94aa9da00eaf8c1fd3b5f3d623" translate="yes" xml:space="preserve">
          <source>The second part says that the factorial of N is N multiplied by the factorial of N - 1:</source>
          <target state="translated">Во второй части сказано,что факториал N умножается на факториал N-1:</target>
        </trans-unit>
        <trans-unit id="30c810f9bece7434133db436ed3f6c1cf5d3af46" translate="yes" xml:space="preserve">
          <source>The second sublist contains all elements that are greater than, or equal to, the first element in the list.</source>
          <target state="translated">Второй подсписок содержит все элементы,которые больше или равны первому элементу списка.</target>
        </trans-unit>
        <trans-unit id="627c2faa2a7cc1454aac523f61132caf4581e1f2" translate="yes" xml:space="preserve">
          <source>The second test to run is for system &lt;code&gt;t2&lt;/code&gt;. The included suites are &lt;code&gt;t2B&lt;/code&gt; and &lt;code&gt;t2C&lt;/code&gt;. Test cases &lt;code&gt;test4&lt;/code&gt;, &lt;code&gt;test1&lt;/code&gt;, and &lt;code&gt;test7&lt;/code&gt; in suite &lt;code&gt;t2A&lt;/code&gt; are also included. The test cases are executed in the specified order.</source>
          <target state="translated">Второй тест предназначен для системы &lt;code&gt;t2&lt;/code&gt; . Включенные люксы - &lt;code&gt;t2B&lt;/code&gt; и &lt;code&gt;t2C&lt;/code&gt; . Также включены тестовые примеры &lt;code&gt;test4&lt;/code&gt; , &lt;code&gt;test1&lt;/code&gt; и &lt;code&gt;test7&lt;/code&gt; в наборе &lt;code&gt;t2A&lt;/code&gt; . Тестовые примеры выполняются в указанном порядке.</target>
        </trans-unit>
        <trans-unit id="55d61df65623e70a8f8d590c69696f032eeda08b" translate="yes" xml:space="preserve">
          <source>The second way in which PCRE and Perl differ in their recursion processing is in the handling of captured values. In Perl, when a subpattern is called recursively or as a subpattern (see the next section), it has no access to any values that were captured outside the recursion. In PCRE these values can be referenced. Consider the following pattern:</source>
          <target state="translated">Второй способ,при котором PCRE и Perl различаются в рекурсивной обработке,заключается в обработке захваченных значений.В Perl,когда подмасказка называется рекурсивной или подмасказкой (см.следующий раздел),она не имеет доступа ни к каким значениям,которые были захвачены за пределами рекурсии.В PCRE на эти значения можно ссылаться.Рассмотрим следующий шаблон:</target>
        </trans-unit>
        <trans-unit id="80e6aee2483553449b41d11b56e552008e4da471" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Definition of Instrumentation Functions&lt;/strong&gt; describes the user defined functions, which the agent calls at different times.</source>
          <target state="translated">В разделе &amp;laquo; &lt;strong&gt;Определение инструментальных функций&amp;raquo;&lt;/strong&gt; описаны пользовательские функции, которые агент вызывает в разное время.</target>
        </trans-unit>
        <trans-unit id="44f4ef1de5e2083869238de908c1bcbfdb9de96a" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory (with exception for the ping/pong messages) messages, which Net If must send to the manager server process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273fb73a0df92aec09d70c97847239277a60baf2" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net If must send and be able to receive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8504a92d5b318cac713f3b2e89234cb14dbccfe1" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send and be able to receive.</source>
          <target state="translated">В разделе &amp;laquo; &lt;strong&gt;Сообщения&amp;raquo;&lt;/strong&gt; описаны обязательные сообщения, которые сеть должна отправлять и иметь возможность получать.</target>
        </trans-unit>
        <trans-unit id="a2e0f488aa581aec3c47fd790570dbca655fc2d9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send to the manager server process.</source>
          <target state="translated">В разделе &amp;laquo; &lt;strong&gt;Сообщения&amp;raquo;&lt;/strong&gt; описаны обязательные сообщения, которые сеть должна отправлять процессу сервера-менеджера.</target>
        </trans-unit>
        <trans-unit id="cb5bc25d5302176ca65d13f47ab8764077fb82e9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;When to use a Sub-agent&lt;/strong&gt; describes situations where the mechanism of loading and unloading MIBs is insufficient. In these cases a sub-agent is needed.</source>
          <target state="translated">В разделе &lt;strong&gt;Когда использовать субагент&lt;/strong&gt; описываются ситуации, когда механизма загрузки и выгрузки MIB недостаточно. В этих случаях необходим субагент.</target>
        </trans-unit>
        <trans-unit id="e27ee525c2d7a1c95013bf055cd814b7495974ff" translate="yes" xml:space="preserve">
          <source>The section is a step-by-step explanation of the &lt;code&gt;uds_dist&lt;/code&gt; example application (in the Kernel application &lt;code&gt;examples&lt;/code&gt; directory). The &lt;code&gt;uds_dist&lt;/code&gt; application implements distribution over Unix domain sockets and is written for the Sun Solaris 2 operating environment. The mechanisms are however general and apply to any operating system Erlang runs on. The reason the C code is not made portable, is simply readability.</source>
          <target state="translated">Секция представляет собой шаг за шагом объяснением &lt;code&gt;uds_dist&lt;/code&gt; примера приложения (в приложении Kernel &lt;code&gt;examples&lt;/code&gt; каталога). Приложение &lt;code&gt;uds_dist&lt;/code&gt; реализует распределение по сокетам домена Unix и написано для операционной среды Sun Solaris 2. Однако эти механизмы являются общими и применимы к любой операционной системе, в которой работает Erlang. Причина того, что код C не переносится, - это простая читаемость.</target>
        </trans-unit>
        <trans-unit id="10205e6d7e5decf9f073a8f33e8e352f8ecad2b8" translate="yes" xml:space="preserve">
          <source>The sections about release structure and release handling have been moved to section &lt;code&gt;OTP Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">Разделы о структуре релизов и обработке релизов перемещены в раздел &lt;code&gt;OTP Design Principles&lt;/code&gt; в &lt;strong&gt;системной документации&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4e2ce648e32ac1ae793549c46cd55a4f21a2abef" translate="yes" xml:space="preserve">
          <source>The security level depends on the parameters provided to the TLS connection setup. Erlang node cookies are however always used, as they can be used to differentiate between two different Erlang networks.</source>
          <target state="translated">Уровень безопасности зависит от параметров,заданных при настройке TLS-соединения.Однако всегда используются куки-файлы узла Erlang,так как они могут использоваться для различения двух разных сетей Erlang.</target>
        </trans-unit>
        <trans-unit id="d750bfe1fcfccb12069aea37fb0d25d1db1f996c" translate="yes" xml:space="preserve">
          <source>The selective receive in this case causes &lt;code&gt;open&lt;/code&gt; to implicitly postpone any events to the &lt;code&gt;locked&lt;/code&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d926590307164245688269e8d14c40ab7bc091d" translate="yes" xml:space="preserve">
          <source>The selective receive in this case causes implicitly &lt;code&gt;open&lt;/code&gt; to postpone any events to the &lt;code&gt;locked&lt;/code&gt; state.</source>
          <target state="translated">Выборочный прием в этом случае вызывает неявное &lt;code&gt;open&lt;/code&gt; чтобы отложить любые события до &lt;code&gt;locked&lt;/code&gt; состояния.</target>
        </trans-unit>
        <trans-unit id="5fd2a7b375c615e788c6695ee553f4da41abbaa4" translate="yes" xml:space="preserve">
          <source>The semantics is that a trace message is sent when a call traced function returns, that is, when a chain of tail recursive calls ends. Only one trace message is sent per chain of tail recursive calls, so the properties of tail recursiveness for function calls are kept while tracing with this flag. Using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; trace together makes it possible to know exactly in which function a process executes at any time.</source>
          <target state="translated">Семантика такова, что сообщение трассировки отправляется при возврате функции с отслеживанием вызовов, то есть когда заканчивается цепочка хвостовых рекурсивных вызовов. На каждую цепочку хвостовых рекурсивных вызовов отправляется только одно сообщение трассировки, поэтому свойства хвостовой рекурсивности для вызовов функций сохраняются при трассировке с этим флагом. Совместное использование &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;return_to&lt;/code&gt; trace позволяет точно знать, в какой функции выполняется процесс в любое время.</target>
        </trans-unit>
        <trans-unit id="4de46ccd64eaf7c6a99ec541d1cbcc55c06b408c" translate="yes" xml:space="preserve">
          <source>The semantics of the protocol has jointly been defined by two standardization bodies:</source>
          <target state="translated">Семантика протокола была совместно определена двумя органами стандартизации:</target>
        </trans-unit>
        <trans-unit id="1ff24da2ee4416d81d99c41d0ad247bd1489bb83" translate="yes" xml:space="preserve">
          <source>The semantics of them and their exact signatures are explained below.</source>
          <target state="translated">Ниже объясняется их семантика и точные подписи.</target>
        </trans-unit>
        <trans-unit id="b1fa04e102f76c0ed958b51776ec1323ba2b420c" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; in the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он получает блокировку типа &lt;code&gt;LockKind&lt;/code&gt; в записи. В настоящее время поддерживаются типы блокировки &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;sticky_write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dec37a1381140705a37e8b22974825983130016" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он получает блокировку типа &lt;code&gt;LockKind&lt;/code&gt; для всей таблицы или отдельной записи. В настоящее время поддерживается &lt;code&gt;read&lt;/code&gt; типа блокировки .</target>
        </trans-unit>
        <trans-unit id="544565c18f11c3bd2d1b3b57f9c37bb23e28513e" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or on a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он получает блокировку типа &lt;code&gt;LockKind&lt;/code&gt; для всей таблицы или для отдельной записи. В настоящее время поддерживается &lt;code&gt;read&lt;/code&gt; типа блокировки .</target>
        </trans-unit>
        <trans-unit id="4ac9b81a840d90d3353dd0dc88e91326c5df9221" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он получает блокировку типа &lt;code&gt;LockKind&lt;/code&gt; для записи. В настоящее время поддерживаются типы блокировки &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;sticky_write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="398f5d70441c50ce9d5e9fd6b232c3ecc7fd8dc0" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. Currently, the lock types &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он получает блокировку типа &lt;code&gt;LockKind&lt;/code&gt; . В настоящее время поддерживаются типы блокировки &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;sticky_write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb63a329083b4ebe624da3e57823d281920ca895" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. The lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он получает блокировку типа &lt;code&gt;LockKind&lt;/code&gt; . Поддерживаются типы блокировки &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;sticky_write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03d20c7795cec81709642f2df218bc112e235d99" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a read lock on the entire table.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он устанавливает блокировку чтения для всей таблицы.</target>
        </trans-unit>
        <trans-unit id="06b7f2394cceb9a5d1549e5bd69d686fb86fba7d" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires locks, otherwise it ignores the request.</source>
          <target state="translated">Семантика этой функции зависит от контекста. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; . В контексте транзакции он устанавливает блокировки, в противном случае он игнорирует запрос.</target>
        </trans-unit>
        <trans-unit id="c555e927f36b7c980e9c0d2dd029f5af17719b16" translate="yes" xml:space="preserve">
          <source>The send handle is provided by the preferred transport module, e.g. megaco_tcp, megaco_udp. Read the documentation about each transport module about the details.</source>
          <target state="translated">Ручка отправки обеспечивается предпочтительным транспортным модулем,например,megaco_tcp,megaco_udp.Ознакомьтесь с документацией по каждому транспортному модулю с подробностями.</target>
        </trans-unit>
        <trans-unit id="8783fac7786ee217686c1dc22e76c11e2bd7dd7d" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes no use of this info, so the only use for it in such a configuration (when using the built in net-if) would be tracing.</source>
          <target state="translated">Опция отправить &lt;code&gt;extra&lt;/code&gt; определяет непрозрачная структура данных передается на нетто-если процесс. Процесс net-if, включенный в это приложение, не использует эту информацию, поэтому единственное его использование в такой конфигурации (при использовании встроенного net-if) - это трассировка.</target>
        </trans-unit>
        <trans-unit id="461af368454e12216cec44ca03086a38551ee6d2" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes, with one exception, no use of this info, so the only use for it in such a option (when using the built in net-if) would be tracing. The one usage exception is: &lt;strong&gt;Any&lt;/strong&gt; tuple with &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; as its first element is reserved for internal use.</source>
          <target state="translated">Опция отправить &lt;code&gt;extra&lt;/code&gt; определяет непрозрачная структура данных передается на нетто-если процесс. Процесс net-if, включенный в это приложение, не использует, за одним исключением, эту информацию, поэтому единственное его использование в такой опции (при использовании встроенного net-if) - это трассировка. Единственное исключение использования: &lt;strong&gt;любой&lt;/strong&gt; кортеж с &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; в качестве его первого элемента зарезервирован для внутреннего использования.</target>
        </trans-unit>
        <trans-unit id="f927792dbf5cf189b45274ee4c9fa05e9b3d6c92" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;receiver&lt;/code&gt; specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the management targets. The &lt;code&gt;receiver&lt;/code&gt; can have three values:</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; опции отправки указывает, куда следует отправлять информацию о доставке информационных запросов. Агент отправляет информационные запросы и ожидает подтверждения от целей управления. &lt;code&gt;receiver&lt;/code&gt; может иметь три значения:</target>
        </trans-unit>
        <trans-unit id="b674ec7cb2a069afaa45f294232597630bb8d191" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;timeout&lt;/code&gt; specifies for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">Тайм- &lt;code&gt;timeout&lt;/code&gt; параметра отправки указывает, как долго запрос действителен (после чего менеджер может удалить его).</target>
        </trans-unit>
        <trans-unit id="a653cc1f1926ea809d716348869498af401847a8" translate="yes" xml:space="preserve">
          <source>The sender can receive this event if a send operation fails.</source>
          <target state="translated">Отправитель может получить это событие,если операция отправки не удается.</target>
        </trans-unit>
        <trans-unit id="8ab6737312426170b7d594e871570564adefdefd" translate="yes" xml:space="preserve">
          <source>The sender of a transaction request has the option of deciding, whether the originating Erlang process should synchronously wait (&lt;code&gt;megaco:call/3&lt;/code&gt;) for a reply or if the message should be sent asynchronously (&lt;code&gt;megaco:cast/3&lt;/code&gt;) and the processing of the reply should be delegated this callback function.</source>
          <target state="translated">Отправитель запроса транзакции имеет возможность решить, должен ли инициирующий процесс Erlang синхронно ждать ( &lt;code&gt;megaco:call/3&lt;/code&gt; ) ответа или сообщение должно быть отправлено асинхронно ( &lt;code&gt;megaco:cast/3&lt;/code&gt; ) и обработка ответ должен быть делегирован этой функции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="b4cb9ec2065f8938c37ab4fe9dffa3ac54b3a9dd" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file &quot;as is&quot; without any formatting. A link to the file is added to the test case HTML log.</source>
          <target state="translated">Отправленные и полученные данные NETCONF регистрируются в отдельном текстовом файле &quot;как есть&quot; без какого-либо форматирования.В HTML-журнал тестового случая добавляется ссылка на файл.</target>
        </trans-unit>
        <trans-unit id="4c9c5717f02ffea08eb9b9a69a645cb0063d78fe" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file with XML data nicely indented. A link to the file is added to the test case HTML log.</source>
          <target state="translated">Отправленные и полученные данные NETCONF записываются в отдельный текстовый файл с данными XML с красивыми отступами.Ссылка на файл добавляется в HTML-журнал тестового случая.</target>
        </trans-unit>
        <trans-unit id="97f2e4431b5646badaae5263442c80d42e8a09b1" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF traffic is pretty printed directly in the test case HTML log.</source>
          <target state="translated">Отправляемый и получаемый трафик NETCONF довольно хорошо распечатывается непосредственно в тестовом HTML-журнале.</target>
        </trans-unit>
        <trans-unit id="9b2a69f81d7c9bd014b0daeb2b91d49e6f9bb88b" translate="yes" xml:space="preserve">
          <source>The sequence (?# marks the start of a comment that continues up to the next closing parenthesis. Nested parentheses are not permitted. If option PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which in this case continues to immediately after the next newline character or character sequence in the pattern. Which characters are interpreted as newlines is controlled by the options passed to a compiling function or by a special sequence at the start of the pattern, as described in section &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt; Newline Conventions&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526a6b0c86f2a163790ccae9cdeca981359b2f9f" translate="yes" xml:space="preserve">
          <source>The sequence (?# marks the start of a comment that continues up to the next closing parenthesis. Nested parentheses are not permitted. If option PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which in this case continues to immediately after the next newline character or character sequence in the pattern. Which characters are interpreted as newlines is controlled by the options passed to a compiling function or by a special sequence at the start of the pattern, as described in section &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">Последовательность (? # Обозначает начало комментария, которое продолжается до следующей закрывающей круглой скобки. Вложенные круглые скобки не разрешены. Если установлена ​​опция PCRE_EXTENDED, неэкранированный символ # также вводит комментарий, который в этом случае продолжается сразу после следующий символ новой строки или последовательность символов в шаблоне.Какие символы интерпретируются как новые строки, определяется параметрами, переданными в функцию компиляции, или специальной последовательностью в начале шаблона, как описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; ранее.</target>
        </trans-unit>
        <trans-unit id="17d5ba7a2bea4311848902de65874e5e13256c29" translate="yes" xml:space="preserve">
          <source>The sequence \g followed by an unsigned or a negative number, optionally enclosed in braces, is an absolute or relative back reference. A named back reference can be coded as \g{name}. Back references are discussed later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">Последовательность \g,за которой следует неподписанное или отрицательное число,по желанию заключенное в фигурные скобки,является абсолютной или относительной обратной ссылкой.Именованная обратная ссылка может быть закодирована как \g{name}.Обратные ссылки рассматриваются позже,после обсуждения подмастерн в скобках.</target>
        </trans-unit>
        <trans-unit id="cf397042cff1c5cb3ebfe293ff40d06f71fdc8c2" translate="yes" xml:space="preserve">
          <source>The sequence \g{-1} is a reference to the most recently started capturing subpattern before \g, that is, it is equivalent to \2 in this example. Similarly, \g{-2} would be equivalent to \1. The use of relative references can be helpful in long patterns, and also in patterns that are created by joining fragments containing references within themselves.</source>
          <target state="translated">Последовательность \g{-1}является ссылкой на самую последнюю начатую захватывающую подмакетку перед \g,то есть эквивалентна \2 в данном примере.Аналогично,\g{-2}будет эквивалентна \1.Использование относительных ссылок может быть полезно в длинных шаблонах,а также в шаблонах,которые создаются путем сшивания фрагментов,содержащих ссылки внутри себя.</target>
        </trans-unit>
        <trans-unit id="9aa5123f81409d6732a8773b396806a7d7a6c8b1" translate="yes" xml:space="preserve">
          <source>The sequence id is used to uniquely identify a fragmented message sent from one process to another on the same distributed connection. This is used to identify which sequence a fragment is a part of as the same process can be in the process of receiving multiple sequences at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78acc7e07953d38a1ab22f1d92af436b05725d02" translate="yes" xml:space="preserve">
          <source>The sequence number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Порядковый номер в pid &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a730581ed9394e9f512b17bf00122fa40d5d6a8c" translate="yes" xml:space="preserve">
          <source>The sequence number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Порядковый номер порта &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9835c9de2ba951e30c90819750512630463b537" translate="yes" xml:space="preserve">
          <source>The sequence of steps shown is probably more complex than normal, but it illustrates the amount of functionality which is available. The following points should be noted:</source>
          <target state="translated">Последовательность показанных шагов,вероятно,сложнее,чем обычно,но она иллюстрирует объем доступной функциональности.Следует отметить следующие моменты:</target>
        </trans-unit>
        <trans-unit id="8ad58d75452c7e291a38fc9baa9ff4ed0360940a" translate="yes" xml:space="preserve">
          <source>The sequences \h, \H, \v, and \V are features that were added to Perl in release 5.10. In contrast to the other sequences, which match only ASCII characters by default, these always match certain high-valued code points, regardless if &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">Последовательности \ h, \ H, \ v и \ V - это функции, которые были добавлены в Perl в версии 5.10. В отличие от других последовательностей, которые по умолчанию соответствуют только символам ASCII, они всегда соответствуют определенным кодовым точкам с высоким значением, независимо от того, установлен ли &lt;code&gt;ucp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc5373a2646de360aa46ef11847fc92698bb563" translate="yes" xml:space="preserve">
          <source>The serial number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Серийный номер в pid &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8111e7055dd7801086cd5e9dd759c58638f73514" translate="yes" xml:space="preserve">
          <source>The server always sends a certificate chain as part of the TLS handshake, but the client only sends one if requested by the server. If the client does not have an appropriate certificate, it can send an &quot;empty&quot; certificate to the server.</source>
          <target state="translated">Сервер всегда отправляет цепочку сертификатов как часть TLS рукопожатия,но клиент отправляет ее только по запросу сервера.Если у клиента нет соответствующего сертификата,он может отправить серверу &quot;пустой&quot; сертификат.</target>
        </trans-unit>
        <trans-unit id="229d25bbfa88632fdde58ad8585ae739c0a0640c" translate="yes" xml:space="preserve">
          <source>The server can also take the options &lt;code&gt;dhfile&lt;/code&gt; and &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; (also prefixed).</source>
          <target state="translated">Сервер также может принимать параметры &lt;code&gt;dhfile&lt;/code&gt; и &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; (также с префиксом).</target>
        </trans-unit>
        <trans-unit id="1700b3d48eb2b123d28d0da14b6deae45c75c3b4" translate="yes" xml:space="preserve">
          <source>The server implements numerous features, such as:</source>
          <target state="translated">Сервер реализует многочисленные функции,такие как:</target>
        </trans-unit>
        <trans-unit id="a419e1724123900e8550b29498eed9bbee902340" translate="yes" xml:space="preserve">
          <source>The server interprets the message headers and most of them are transformed into HTTP headers and sent back to the client together with the message-body.</source>
          <target state="translated">Сервер интерпретирует заголовки сообщений и большинство из них трансформируется в HTTP-заголовки и отправляется обратно клиенту вместе с телом сообщения.</target>
        </trans-unit>
        <trans-unit id="0d98b27dc370a8e06dd56d795ca4cf5591347585" translate="yes" xml:space="preserve">
          <source>The server is configured using an Erlang property list. For the available properties, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e7a7b10ff76bf44d32ec3e60b336ed7bd9d091" translate="yes" xml:space="preserve">
          <source>The server is configured using an Erlang property list. For the available properties, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;. For backwards compatibility, apache-like configuration files are also supported.</source>
          <target state="translated">Сервер настраивается с использованием списка свойств Erlang. Для получения информации о доступных свойствах см. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; . Для обратной совместимости также поддерживаются файлы конфигурации, подобные apache.</target>
        </trans-unit>
        <trans-unit id="5e64a9d0d0fd7079393371b1454efd0dd5fbdc81" translate="yes" xml:space="preserve">
          <source>The server name, in this example the atom &lt;code&gt;ch2&lt;/code&gt;, is hidden from the users of the client functions. This means that the name can be changed without affecting them.</source>
          <target state="translated">Имя сервера, в этом примере атом &lt;code&gt;ch2&lt;/code&gt; , скрыто от пользователей клиентских функций. Это означает, что имя можно изменить, не затрагивая их.</target>
        </trans-unit>
        <trans-unit id="281168d64e74220aa9892e9cc7f847641edee61a" translate="yes" xml:space="preserve">
          <source>The server receives this message and calls:</source>
          <target state="translated">Сервер получает это сообщение и звонит:</target>
        </trans-unit>
        <trans-unit id="e465284becdbbb53a7c1b2b2feedaf65818bc0a6" translate="yes" xml:space="preserve">
          <source>The server side must abort any ongoing operations, release any locks and resources associated with the session, and close any associated connections.</source>
          <target state="translated">Серверная сторона должна прервать все текущие операции,освободить все блокировки и ресурсы,связанные с сеансом,и закрыть все связанные с сеансом соединения.</target>
        </trans-unit>
        <trans-unit id="1b73ca513a3d162c53b9d0f45d3fae15b51ac27d" translate="yes" xml:space="preserve">
          <source>The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's &quot;signature_algorithms&quot; extension (currently RSA, ECDSA, or EdDSA).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eada9e87d673d14717c1c6d8d19ed52103f05b62" translate="yes" xml:space="preserve">
          <source>The service is being started or stopped. No event precedes a &lt;code&gt;start&lt;/code&gt; event. No event follows a &lt;code&gt;stop&lt;/code&gt; event, and this event implies the termination of all transport processes.</source>
          <target state="translated">Служба запускается или останавливается. Никакое событие не предшествует &lt;code&gt;start&lt;/code&gt; событию. За событием &lt;code&gt;stop&lt;/code&gt; не следует ни одного события, и это событие подразумевает завершение всех транспортных процессов.</target>
        </trans-unit>
        <trans-unit id="0bb9705bf71fb4b8fce2bf74aeec82fd5334268d" translate="yes" xml:space="preserve">
          <source>The service will start transport processes as required in order to establish a connection with the peer, either by connecting to the peer (&lt;code&gt;connect&lt;/code&gt;) or by accepting incoming connection requests (&lt;code&gt;listen&lt;/code&gt;). A connecting transport establishes transport connections with at most one peer, an listening transport potentially with many.</source>
          <target state="translated">Служба будет запускать транспортные процессы по мере необходимости, чтобы установить соединение с одноранговым узлом, либо путем подключения к одноранговому узлу ( &lt;code&gt;connect&lt;/code&gt; ), либо путем приема входящих запросов на соединение ( &lt;code&gt;listen&lt;/code&gt; ). Подключающийся транспорт устанавливает транспортные соединения не более чем с одним партнером, а ожидающий транспорт - потенциально со многими.</target>
        </trans-unit>
        <trans-unit id="2d32daf4aa858543bff36659b918ab0126a6b271" translate="yes" xml:space="preserve">
          <source>The session data that is stored for each session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cadccf6e95d9c9b64838c77b38958e4188f878" translate="yes" xml:space="preserve">
          <source>The session is closed.</source>
          <target state="translated">Сессия закрыта.</target>
        </trans-unit>
        <trans-unit id="7cd1dac17852f58fd5b35cb68eccba90aabb1d2d" translate="yes" xml:space="preserve">
          <source>The set of admissible SCTP socket options is by construction orthogonal to the sets of TCP, UDP, and generic &lt;code&gt;inet&lt;/code&gt; options. Only options listed here are allowed for SCTP sockets. Options can be set on the socket using &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, retrieved using &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt;. Options can be changed when calling &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Набор допустимых параметров сокета SCTP по своей конструкции ортогонален наборам TCP, UDP и универсальным параметрам &lt;code&gt;inet&lt;/code&gt; . Для сокетов SCTP разрешены только перечисленные здесь параметры. Параметры могут быть установлены для сокета с помощью &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; , полученных с помощью &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; . Параметры можно изменить при вызове &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab0f75a569127c073d8755a64ed39c5868d2acc4" translate="yes" xml:space="preserve">
          <source>The set of algorithms that the SSH app uses by default depends on the algoritms supported by the:</source>
          <target state="translated">Набор алгоритмов,используемых приложением SSH по умолчанию,зависит от алгоритмов,поддерживаемых этим приложением:</target>
        </trans-unit>
        <trans-unit id="735c513e608e0b547b56dcea8d9766ffad148df8" translate="yes" xml:space="preserve">
          <source>The set of integers returned by &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; using different sets of &lt;code&gt;Modifier&lt;/code&gt;s &lt;strong&gt;will overlap&lt;/strong&gt;. For example, by calling &lt;code&gt;unique_integer([monotonic])&lt;/code&gt;, and &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; repeatedly, you will eventually see some integers that are returned by both calls.</source>
          <target state="translated">Множество целых чисел , возвращаемых &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; с использованием различных наборов &lt;code&gt;Modifier&lt;/code&gt; сек &lt;strong&gt;будут перекрываться&lt;/strong&gt; . Например, &lt;code&gt;unique_integer([monotonic])&lt;/code&gt; вызывая unique_integer ([monotonic]) и &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; , вы в конечном итоге увидите некоторые целые числа, возвращаемые обоими вызовами.</target>
        </trans-unit>
        <trans-unit id="192a51abc57907a3173222d0f7d8aab02a2d5adc" translate="yes" xml:space="preserve">
          <source>The set of nodes that makes up a Mnesia system is kept in a schema. Mnesia nodes can be added to or removed from the schema. The initial schema is normally created on disc with the function &lt;code&gt;mnesia:create_schema/1&lt;/code&gt;. On disc-less nodes, a tiny default schema is generated each time Mnesia is started. During the startup procedure, Mnesia exchanges schema information between the nodes to verify that the table definitions are compatible.</source>
          <target state="translated">Набор узлов, составляющих систему Mnesia, хранится в схеме. Узлы Mnesia можно добавлять в схему или удалять из нее. Начальная схема обычно создается на диске с помощью функции &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; . На бездисковых узлах крошечная схема по умолчанию генерируется каждый раз при запуске Mnesia. Во время процедуры запуска Mnesia обменивается информацией о схеме между узлами, чтобы убедиться, что определения таблиц совместимы.</target>
        </trans-unit>
        <trans-unit id="e6b6ca74b9f0531554c93c10cb1c7070b93217b8" translate="yes" xml:space="preserve">
          <source>The set of predefined types and the syntax for types follows:</source>
          <target state="translated">Далее следует набор предопределенных типов и синтаксис для типов:</target>
        </trans-unit>
        <trans-unit id="d7ecd892863675025b2a96aabc9a9af6b17ad9d4" translate="yes" xml:space="preserve">
          <source>The set of threads that we are interested in we call managed threads. The managed threads are the only threads that we get any information about. These threads &lt;strong&gt;have&lt;/strong&gt; to frequently report progress. Not all threads in the system are able to frequently report progress. Such threads cannot be allowed in the set of managed threads and are called unmanaged threads. An example of unmanaged threads are threads in the async thread pool. Async threads can be blocked for very long times and by this be prevented from frequently reporting progress. Currently only scheduler threads and a couple of other threads are managed threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57bb3e21d7efc4c4d6d866577c535b86827e6e3" translate="yes" xml:space="preserve">
          <source>The set of valid &lt;strong&gt;guard expressions&lt;/strong&gt; (sometimes called guard tests) is a subset of the set of valid Erlang expressions. The reason for restricting the set of valid expressions is that evaluation of a guard expression must be guaranteed to be free of side effects. Valid guard expressions are the following:</source>
          <target state="translated">Набор допустимых &lt;strong&gt;охранных выражений&lt;/strong&gt; (иногда называемых сторожевыми тестами) является подмножеством набора допустимых выражений Erlang. Причина ограничения набора допустимых выражений заключается в том, что оценка охранного выражения должна быть гарантированно свободна от побочных эффектов. Допустимые защитные выражения следующие:</target>
        </trans-unit>
        <trans-unit id="38618d07bcc4ec9219110c6bac629d8ba5add3b8" translate="yes" xml:space="preserve">
          <source>The set of valid &lt;strong&gt;guard expressions&lt;/strong&gt; is a subset of the set of valid Erlang expressions. The reason for restricting the set of valid expressions is that evaluation of a guard expression must be guaranteed to be free of side effects. Valid guard expressions are the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4e6c237902f03c9d37f0c7a6d60075f64b2cbe" translate="yes" xml:space="preserve">
          <source>The sets recognized by this module are represented by elements of the relation Sets, which is defined as the smallest set such that:</source>
          <target state="translated">Множества,распознаваемые этим модулем,представлены элементами отношений Sets,которые определяются как наименьший из множеств,подобных этому:</target>
        </trans-unit>
        <trans-unit id="2cd8e823885a626feb78a98cd7d6126c5141df4e" translate="yes" xml:space="preserve">
          <source>The sets represented by Sets are the elements of the range of function Set from Sets to Erlang terms and sets of Erlang terms:</source>
          <target state="translated">Множества,представленные множествами,являются элементами диапазона функций Set от Sets до Erlang терминов и множеств Erlang терминов:</target>
        </trans-unit>
        <trans-unit id="1e6bfb67315ff8c660eaf25c1733e37c10bf2a84" translate="yes" xml:space="preserve">
          <source>The setting has no effect on a halt log.</source>
          <target state="translated">Настройка не влияет на журнал остановки.</target>
        </trans-unit>
        <trans-unit id="708e1c55726f99e92712010fcf842caa93f6beee" translate="yes" xml:space="preserve">
          <source>The settings of the Perl-compatible options &lt;code&gt;caseless&lt;/code&gt;, &lt;code&gt;multiline&lt;/code&gt;, &lt;code&gt;dotall&lt;/code&gt;, and &lt;code&gt;extended&lt;/code&gt; can be changed from within the pattern by a sequence of Perl option letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are as follows:</source>
          <target state="translated">Параметры Perl-совместимых параметров &lt;code&gt;caseless&lt;/code&gt; , &lt;code&gt;multiline&lt;/code&gt; , &lt;code&gt;dotall&lt;/code&gt; и &lt;code&gt;extended&lt;/code&gt; можно изменить изнутри шаблона с помощью последовательности букв параметров Perl, заключенных между &quot;(?&quot; И &quot;)&quot;. Буквы вариантов следующие:</target>
        </trans-unit>
        <trans-unit id="20fbd9576783a14ac9df5dccf183005898be344d" translate="yes" xml:space="preserve">
          <source>The severity level for the message to be logged.</source>
          <target state="translated">Степень тяжести регистрируемого сообщения.</target>
        </trans-unit>
        <trans-unit id="906ae5d296f5eecb26331f0380669f16fbcadddb" translate="yes" xml:space="preserve">
          <source>The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell.</source>
          <target state="translated">Оболочка также позволяет пользователю запускать несколько одновременных заданий.Задание можно рассматривать как набор процессов,которые могут взаимодействовать с оболочкой.</target>
        </trans-unit>
        <trans-unit id="3c5f2ea6c7e1929748b9a3f26e85b7652daf0ffd" translate="yes" xml:space="preserve">
          <source>The shell can be started in a restricted mode. In this mode, the shell evaluates a function call only if allowed. This feature makes it possible to, for example, prevent a user from accidentally calling a function from the prompt that could harm a running system (useful in combination with system flag &lt;code&gt;+Bi&lt;/code&gt;).</source>
          <target state="translated">Оболочку можно запустить в ограниченном режиме. В этом режиме оболочка оценивает вызов функции, только если это разрешено. Эта функция позволяет, например, предотвратить случайный вызов пользователем функции из приглашения, которая может нанести вред работающей системе (полезно в сочетании с системным флагом &lt;code&gt;+Bi&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b1db3783eaf47b941529ec43e9feba2a87d50ce" translate="yes" xml:space="preserve">
          <source>The shell commands for reading, defining, forgetting, listing, and printing records are described below. Notice that each job has its own set of record definitions. To facilitate matters, record definitions in modules &lt;code&gt;shell_default&lt;/code&gt; and &lt;code&gt;user_default&lt;/code&gt; (if loaded) are read each time a new job is started. For example, adding the following line to &lt;code&gt;user_default&lt;/code&gt; makes the definition of &lt;code&gt;file_info&lt;/code&gt; readily available in the shell:</source>
          <target state="translated">Команды оболочки для чтения, определения, забывания, перечисления и печати записей описаны ниже. Обратите внимание, что каждое задание имеет свой собственный набор определений записей. Чтобы упростить &lt;code&gt;shell_default&lt;/code&gt; , определения записей в модулях shell_default и &lt;code&gt;user_default&lt;/code&gt; (если они загружены) считываются каждый раз при запуске нового задания. Например, добавление следующей строки в &lt;code&gt;user_default&lt;/code&gt; делает определение &lt;code&gt;file_info&lt;/code&gt; легкодоступным в оболочке:</target>
        </trans-unit>
        <trans-unit id="0dffc89af87f5c93512d139994f93842341103ef" translate="yes" xml:space="preserve">
          <source>The shell escape key &lt;code&gt;^G&lt;/code&gt; (Control G) detaches the current job and activates &lt;code&gt;JCL&lt;/code&gt; mode. The &lt;code&gt;JCL&lt;/code&gt; mode prompt is &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt;. If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is entered at the prompt, the following help message is displayed:</source>
          <target state="translated">Клавиша выхода оболочки &lt;code&gt;^G&lt;/code&gt; (Control G) отключает текущее задание и активирует режим &lt;code&gt;JCL&lt;/code&gt; . &lt;code&gt;JCL&lt;/code&gt; режим подсказки является &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; . Если &lt;code&gt;&quot;?&quot;&lt;/code&gt; вводится по запросу, отображается следующее справочное сообщение:</target>
        </trans-unit>
        <trans-unit id="f22132507cc2cbecae41be645fa330c7e74cc00c" translate="yes" xml:space="preserve">
          <source>The shell is a user interface program for entering expression sequences. The expressions are evaluated and a value is returned. A history mechanism saves previous commands and their values, which can then be incorporated in later commands. How many commands and results to save can be determined by the user, either interactively, by calling &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt;, or by setting the application configuration parameters &lt;code&gt;shell_history_length&lt;/code&gt; and &lt;code&gt;shell_saved_results&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">Оболочка - это программа пользовательского интерфейса для ввода последовательностей выражений. Выражения оцениваются, и возвращается значение. Механизм истории сохраняет предыдущие команды и их значения, которые затем могут быть включены в более поздние команды. &lt;code&gt;shell_history_length&lt;/code&gt; &lt;code&gt;shell_saved_results&lt;/code&gt; команд и результатов может быть определено пользователем в интерактивном режиме, вызывая &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt; , или задавая параметры конфигурации приложения shell_history_length и shell_saved_results для приложения STDLIB.</target>
        </trans-unit>
        <trans-unit id="0c05236717660c4e284c99dfbeb455aafa6a7135" translate="yes" xml:space="preserve">
          <source>The shell is usually not invoked to start the program, it is executed directly. &lt;code&gt;PATH&lt;/code&gt; (or equivalent) is not searched. To find a program in &lt;code&gt;PATH&lt;/code&gt; to execute, use &lt;code&gt; os:find_executable/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3c2d38847db4b9d384443450a1704fbe5a9310" translate="yes" xml:space="preserve">
          <source>The shell is usually not invoked to start the program, it is executed directly. &lt;code&gt;PATH&lt;/code&gt; (or equivalent) is not searched. To find a program in &lt;code&gt;PATH&lt;/code&gt; to execute, use &lt;code&gt;os:find_executable/1&lt;/code&gt;.</source>
          <target state="translated">Оболочка обычно не вызывается для запуска программы, она выполняется напрямую. &lt;code&gt;PATH&lt;/code&gt; (или эквивалент) не ищется. Чтобы найти программу в &lt;code&gt;PATH&lt;/code&gt; для выполнения, используйте &lt;code&gt;os:find_executable/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba8c777e2892e18ef92162fb3ae948b677e7e96" translate="yes" xml:space="preserve">
          <source>The shell mode is useful, for example, for debugging test suites, analyzing and debugging the SUT during &quot;simulated&quot; test case execution, and trying out various operations during test suite development.</source>
          <target state="translated">Режим оболочки полезен,например,для отладки тестовых комплектов,анализа и отладки SUT во время выполнения &quot;смоделированного&quot; тестового сценария,а также для отладки различных операций во время разработки тестового комплекта.</target>
        </trans-unit>
        <trans-unit id="dccc3d081d31c25afe702e15e4a49fe7f5d58e4e" translate="yes" xml:space="preserve">
          <source>The shell runs in two modes:</source>
          <target state="translated">Панцирь работает в двух режимах:</target>
        </trans-unit>
        <trans-unit id="547a340a87f4e04c610a24150bcba68bc72ae2d3" translate="yes" xml:space="preserve">
          <source>The shell script &lt;code&gt;start&lt;/code&gt;, which is generated from erts-5.10.4/bin/start.src during installation, is only an example. Edit it to suite your needs. Typically it is executed when the UNIX system boots.</source>
          <target state="translated">Сценарий оболочки &lt;code&gt;start&lt;/code&gt; , который генерируется из ГЭР-5.10.4 / бен / start.src во время установки, является лишь примером. Отредактируйте его под свои нужды. Обычно он выполняется при загрузке системы UNIX.</target>
        </trans-unit>
        <trans-unit id="42c1630d7f9ecc92a9f90f0627702733fa769c29" translate="yes" xml:space="preserve">
          <source>The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt; catch_exception/1&lt;/a&gt;&lt;/code&gt; or by setting the application configuration parameter &lt;code&gt;shell_catch_exception&lt;/code&gt; for the STDLIB application this behavior can be changed. See also the example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dd983c72c713d084adde4deb3fce82550d00d2" translate="yes" xml:space="preserve">
          <source>The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; or by setting the application configuration parameter &lt;code&gt;shell_catch_exception&lt;/code&gt; for the STDLIB application this behavior can be changed. See also the example below.</source>
          <target state="translated">Оболочка использует вспомогательный процесс для оценки команд, чтобы защитить механизм истории от исключений. По умолчанию процесс оценщика &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; при возникновении исключения, но это поведение можно изменить путем вызова catch_exception / 1 или установки параметра конфигурации приложения &lt;code&gt;shell_catch_exception&lt;/code&gt; для приложения STDLIB. См. Также пример ниже.</target>
        </trans-unit>
        <trans-unit id="882fde077f4ebdd694d577f064d7d175010b3652" translate="yes" xml:space="preserve">
          <source>The short version: choose &lt;code&gt;state_functions&lt;/code&gt; - it is the one most like &lt;code&gt;gen_fsm&lt;/code&gt;. But if you do not want the restriction that the state must be an atom, or if you do not want to write one &lt;strong&gt;state callback&lt;/strong&gt; function per state; please read on...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa42edd7ea14c7efba24c3aff26f9dcace9d4328" translate="yes" xml:space="preserve">
          <source>The short version: choose &lt;code&gt;state_functions&lt;/code&gt; - it is the one most like &lt;code&gt;gen_fsm&lt;/code&gt;. But if you do not want the restriction that the state must be an atom, or if you do not want to write one event handler function per state; please read on...</source>
          <target state="translated">Краткая версия: выберите &lt;code&gt;state_functions&lt;/code&gt; - он больше всего похож на &lt;code&gt;gen_fsm&lt;/code&gt; . Но если вы не хотите ограничения, что состояние должно быть атомом, или если вы не хотите писать одну функцию обработчика событий для каждого состояния; пожалуйста, прочтите ...</target>
        </trans-unit>
        <trans-unit id="8fc2135229ea382a9e721c2e40582626084b92c6" translate="yes" xml:space="preserve">
          <source>The shortcuts are as follows:</source>
          <target state="translated">Ярлыки следующие:</target>
        </trans-unit>
        <trans-unit id="ecbf2eb1175e2e5b06e38c7c0a22fd7f8f8611cd" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished repeatedly and reliably when reading time values. Precision is limited by the &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt;, but resolution and precision can differ significantly.</source>
          <target state="translated">Кратчайший временной интервал, который можно многократно и надежно выделить при считывании значений времени. Точность ограничена &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; , но разрешение и точность могут значительно отличаться.</target>
        </trans-unit>
        <trans-unit id="f84d7886a0f9257a8fa3cb849cd4e77cfe8aa126" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished when reading time values.</source>
          <target state="translated">Самый короткий временной интервал,который можно выделить при считывании значений времени.</target>
        </trans-unit>
        <trans-unit id="d2bb1e51130dab7f5283d9470e62aab2d5f6ca06" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the child specification of the supervisor is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">Стратегия выключения, как определено в дочерней спецификации супервизора, представляет собой целочисленное значение тайм-аута, а не &lt;code&gt;brutal_kill&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c80708d1012fab3c8f472912a306a1e18b063172" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the supervisor's child specification is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">Стратегия выключения, как определено в спецификации дочернего супервизора, является целочисленным значением времени ожидания, а не &lt;code&gt;brutal_kill&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9028aec69bf73d6c7de5318e8338d0a2f1c2357" translate="yes" xml:space="preserve">
          <source>The signal &lt;code&gt;SIGUSR2&lt;/code&gt; is reserved for internal usage. No other signals are handled.</source>
          <target state="translated">Сигнал &lt;code&gt;SIGUSR2&lt;/code&gt; зарезервирован для внутреннего использования. Никакие другие сигналы не обрабатываются.</target>
        </trans-unit>
        <trans-unit id="d074b9e825fff0fd1ebfc3258cb4dafc95050e70" translate="yes" xml:space="preserve">
          <source>The signal carries information about the pid it was sent from and the exit reason.</source>
          <target state="translated">Сигнал несет информацию о пиде,с которого он был отправлен,и о причине выхода.</target>
        </trans-unit>
        <trans-unit id="56c2445b0db46d08f19738e31ee8dee208c885fe" translate="yes" xml:space="preserve">
          <source>The signature schemes shall be ordered according to the client's preference (favorite choice first).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186b6e9957386fe2a5f08032e0ba5ef2925f605f" translate="yes" xml:space="preserve">
          <source>The signedness specification can be either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. Notice that signedness only matters for matching.</source>
          <target state="translated">Спецификация подписи может быть &lt;code&gt;signed&lt;/code&gt; или &lt;code&gt;unsigned&lt;/code&gt; . Обратите внимание, что подпись имеет значение только для сопоставления.</target>
        </trans-unit>
        <trans-unit id="0a422acc04b6a76708f58fc88d786a11c4476b80" translate="yes" xml:space="preserve">
          <source>The simple event handler sends all alarms as info reports to the error logger, and saves all in a list. This list can be passed to a user-defined event handler, which can be installed later. The list can grow large if many alarms are generated. This is a good reason to install a better user-defined handler.</source>
          <target state="translated">Простой обработчик событий посылает все сигналы тревоги в виде инфоотчета в журнал ошибок и сохраняет все в списке.Этот список может быть передан пользовательскому обработчику событий,который может быть установлен позже.Список может увеличиваться,если генерируется много сигналов тревоги.Это хорошая причина для установки лучшего пользовательского обработчика.</target>
        </trans-unit>
        <trans-unit id="863023573a43dd8e0ae2605daf1e7cad870d2b5e" translate="yes" xml:space="preserve">
          <source>The simple server from &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;, implemented using &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; so it fits into a supervision tree:</source>
          <target state="translated">Простой сервер из &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; , реализованный с использованием &lt;code&gt;sys&lt;/code&gt; и &lt;code&gt;proc_lib&lt;/code&gt; , поэтому он вписывается в дерево наблюдения:</target>
        </trans-unit>
        <trans-unit id="2b9f3602307725a54911301be89734f09963d9b4" translate="yes" xml:space="preserve">
          <source>The simple-form structure is any of &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt;, &lt;code&gt;{Tag, Content}&lt;/code&gt; or &lt;code&gt;Tag&lt;/code&gt; where:</source>
          <target state="translated">Структура простой формы может быть любой из &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt; , &lt;code&gt;{Tag, Content}&lt;/code&gt; или &lt;code&gt;Tag&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="020fdda90aa20fcb7b4204c69ad0944a63e101ce" translate="yes" xml:space="preserve">
          <source>The simplest SSL/TLS options in the following list can be specified by adding the prefix &lt;code&gt;server_&lt;/code&gt; or &lt;code&gt;client_&lt;/code&gt; to the option name:</source>
          <target state="translated">Простейшие параметры SSL / TLS в следующем списке можно указать, добавив префикс &lt;code&gt;server_&lt;/code&gt; или &lt;code&gt;client_&lt;/code&gt; к имени параметра:</target>
        </trans-unit>
        <trans-unit id="37c028006985a9e5f47283f55be8c5af30259739" translate="yes" xml:space="preserve">
          <source>The simplest TLS options in the following list can be specified by adding the prefix &lt;code&gt;server_&lt;/code&gt; or &lt;code&gt;client_&lt;/code&gt; to the option name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ab52b7039e217a939df83566a221e65ed54107" translate="yes" xml:space="preserve">
          <source>The simplest applications do not have any processes, but consist of a collection of functional modules. Such an application is called a &lt;strong&gt;library application&lt;/strong&gt;. An example of a library application is STDLIB.</source>
          <target state="translated">В простейших приложениях нет процессов, а они состоят из набора функциональных модулей. Такое приложение называется &lt;strong&gt;библиотечным приложением&lt;/strong&gt; . Примером библиотечного приложения является STDLIB.</target>
        </trans-unit>
        <trans-unit id="9d81d04034c8d22db20deb185b1f215da194b3b1" translate="yes" xml:space="preserve">
          <source>The simplest boot script possible includes only the Kernel and STDLIB applications. Such a script is located in the &lt;code&gt;bin&lt;/code&gt; directory of the Erlang distribution. The source for the script is found under the Erlang installation top directory under &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt;.</source>
          <target state="translated">Самый простой сценарий загрузки включает в себя только приложения ядра и STDLIB. Такой сценарий находится в каталоге &lt;code&gt;bin&lt;/code&gt; дистрибутива Erlang. Источник сценария находится в верхнем каталоге установки Erlang в &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6fd995f7841419eb481c6384fc5f636193cf5af" translate="yes" xml:space="preserve">
          <source>The simplest case is to segment the input string into a list of identifiers (atoms) and use those atoms both as categories and values of the tokens. For example, the input string &lt;code&gt;aaa bbb 777, X&lt;/code&gt; may be scanned (tokenized) as:</source>
          <target state="translated">Самый простой случай - разделить входную строку на список идентификаторов (атомов) и использовать эти атомы как в качестве категорий, так и в качестве значений токенов. Например, входная строка &lt;code&gt;aaa bbb 777, X&lt;/code&gt; может быть отсканирована (размечена) как:</target>
        </trans-unit>
        <trans-unit id="010ac940341106a56ccca622ae5fd2705ac4ec5a" translate="yes" xml:space="preserve">
          <source>The simplest form of expression is a term, that is an integer, float, atom, string, list, map, or tuple. The return value is the term itself.</source>
          <target state="translated">Самая простая форма выражения-это термин,то есть целое число,плавающий,атом,строка,список,карта или кортеж.Возвращаемым значением является сам термин.</target>
        </trans-unit>
        <trans-unit id="544f8ad7975052237a1febdf86a30ee264923c26" translate="yes" xml:space="preserve">
          <source>The simplest possible pattern is a variable. Just like in Erlang, a variable must begin with an uppercase letter. If the same variable is used in multiple operands, the pattern will only match if the operands are equal. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0274c28625e90c70fedc79d4e866a2b95142496c" translate="yes" xml:space="preserve">
          <source>The simplest usage is to call &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt; scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4929ec0fe8e8e239995092f36e1eed41d6db7c" translate="yes" xml:space="preserve">
          <source>The simplest usage is to call &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Самый простой способ использования - вызвать &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc802fe07c47aed57126bce485b313dc00cf24cf" translate="yes" xml:space="preserve">
          <source>The simplest way of tracing from the Erlang shell is to use &lt;code&gt;dbg:c/3&lt;/code&gt; or &lt;code&gt;dbg:c/4&lt;/code&gt;, e.g. tracing the function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt;:</source>
          <target state="translated">Самый простой способ трассировки из оболочки Erlang - использовать &lt;code&gt;dbg:c/3&lt;/code&gt; или &lt;code&gt;dbg:c/4&lt;/code&gt; , например, отслеживая функцию &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a55bc0caa59f610838e98d74961ed6dd639de567" translate="yes" xml:space="preserve">
          <source>The simplest way to log something is by using the Logger macros and give a report to the macro. For example if you want to log an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd591e91084c3f463556c98ff8fcc73c0b642942" translate="yes" xml:space="preserve">
          <source>The simplest way to send a notification is to call the function &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt;. In this case, the agent performs a get-operation to retrieve the object values that are defined in the notification specification (with the TRAP-TYPE or NOTIFICATION-TYPE macros). The notification is sent to all managers defined in the target and notify tables, either unacknowledged as traps, or acknowledged as inform requests.</source>
          <target state="translated">Самый простой способ отправить уведомление - вызвать функцию &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt; . В этом случае агент выполняет операцию get для получения значений объекта, которые определены в спецификации уведомления (с помощью макросов TRAP-TYPE или NOTIFICATION-TYPE). Уведомление отправляется всем менеджерам, определенным в таблицах назначения и уведомлений, либо неподтвержденных как прерывания, либо подтвержденных как информационные запросы.</target>
        </trans-unit>
        <trans-unit id="67648b768786640bf14fe9b8b58cbe1c7d6f3c6d" translate="yes" xml:space="preserve">
          <source>The simplest way to use EUnit in an Erlang module is to add the following line at the beginning of the module (after the &lt;code&gt;-module&lt;/code&gt; declaration, but before any function definitions):</source>
          <target state="translated">Самый простой способ использовать EUnit в модуле Erlang - добавить следующую строку в начало модуля (после объявления &lt;code&gt;-module&lt;/code&gt; , но перед любыми определениями функций):</target>
        </trans-unit>
        <trans-unit id="adfed9f44eb21dcbf877737d5382c564e366ffe7" translate="yes" xml:space="preserve">
          <source>The simplest way to use the setting is to call &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;, which uses the return value of this function to decide if a list is a string of printable characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94829f2b959259f751a0e01f1565faf0e83453ae" translate="yes" xml:space="preserve">
          <source>The simplest way to use the setting is to call &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;, which uses the return value of this function to decide if a list is a string of printable characters.</source>
          <target state="translated">Самый простой способ использовать эту настройку - вызвать &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; , который использует возвращаемое значение этой функции, чтобы решить, является ли список строкой печатаемых символов.</target>
        </trans-unit>
        <trans-unit id="410ab688ad74fcb927d318148676d55f9fa41dc2" translate="yes" xml:space="preserve">
          <source>The sixth argument is the instance number.</source>
          <target state="translated">Шестой аргумент-номер экземпляра.</target>
        </trans-unit>
        <trans-unit id="09584020841c67187a5e4c45090a98af5e53582d" translate="yes" xml:space="preserve">
          <source>The size and offset of the specific field</source>
          <target state="translated">Размер и смещение конкретного поля</target>
        </trans-unit>
        <trans-unit id="04a41d7d5ebfc159ad47e6d9484bf8d344a4ee18" translate="yes" xml:space="preserve">
          <source>The size field in the header might not correspond to the number of records in the file if the table is public and records are added or removed from the table during dumping. Public tables updated during dump, and that one wants to verify when reading, needs at least one field of extended information for the read verification process to be reliable later.</source>
          <target state="translated">Поле размера в заголовке может не соответствовать количеству записей в файле,если таблица является публичной и записи добавляются или удаляются из таблицы при дампинге.Публичные таблицы,обновленные во время дампа,и те,которые необходимо проверить при чтении,нуждаются,по крайней мере,в одном поле расширенной информации для того,чтобы процесс проверки чтения был надежным в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="15a82dee25c7ae3a3f7d6659ea3993b106858ed6" translate="yes" xml:space="preserve">
          <source>The size includes 233 words for the heap area (which includes the stack). The garbage collector increases the heap as needed.</source>
          <target state="translated">Размер включает в себя 233 слова для области кучи (которая включает в себя штабель).Устройство для сбора мусора увеличивает кучу мусора по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="b0f54d25af981835a640f1718c86bf5f2b930bc6" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;Dgram&lt;/code&gt; is less than &lt;code&gt;4*HLen&lt;/code&gt;.</source>
          <target state="translated">Размер &lt;code&gt;Dgram&lt;/code&gt; меньше &lt;code&gt;4*HLen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="240cf2840ab83e06087b3c823b3105d452ce4e2c" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;struct tcp_info&lt;/code&gt;</source>
          <target state="translated">Размер &lt;code&gt;struct tcp_info&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ae9729d57a3cca0c039100e26f176b68d312d8b" translate="yes" xml:space="preserve">
          <source>The size of the &quot;old heap&quot;, in words. The Erlang virtual machine uses generational garbage collection with two generations. There is one heap for new data items and one for the data that has survived two garbage collections. The assumption (which is almost always correct) is that data surviving two garbage collections can be &quot;tenured&quot; to a heap more seldom garbage collected, as they will live for a long period. This is a usual technique in virtual machines. The sum of the heaps and stack together constitute most of the allocated memory of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6bd4cbaa0c4a01c449ef3a984d1775fb023405" translate="yes" xml:space="preserve">
          <source>The size of the &quot;old heap&quot;. The Erlang virtual machine uses generational garbage collection with two generations. There is one heap for new data items and one for the data that has survived two garbage collections. The assumption (which is almost always correct) is that data surviving two garbage collections can be &quot;tenured&quot; to a heap more seldom garbage collected, as they will live for a long period. This is a usual technique in virtual machines. The sum of the heaps and stack together constitute most of the allocated memory of the process.</source>
          <target state="translated">размером с &quot;старую кучу&quot;.Виртуальная машина Эрланг использует поколение сборщиков мусора двух поколений.Есть одна куча для новых элементов данных и одна-для данных,которые пережили две коллекции мусора.Предположение (почти всегда верное)заключается в том,что данные,пережившие две сборки мусора,могут &quot;затягиваться&quot; в кучу собранного мусора чаще всего,так как они будут жить долгое время.Это обычная техника в виртуальных машинах.Сумма кучи и стопки вместе составляют большую часть выделенной памяти процесса.</target>
        </trans-unit>
        <trans-unit id="8045fd58723fbeefad6762911d1edbd926bdac7b" translate="yes" xml:space="preserve">
          <source>The size of the &lt;code&gt;PlainText&lt;/code&gt; must be less than &lt;code&gt;byte_size(N)-11&lt;/code&gt; if &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; is used, and &lt;code&gt;byte_size(N)&lt;/code&gt; if &lt;code&gt;rsa_no_padding&lt;/code&gt; is used, where N is public modulus of the RSA key.</source>
          <target state="translated">Размер &lt;code&gt;PlainText&lt;/code&gt; должен быть меньше, чем &lt;code&gt;byte_size(N)-11&lt;/code&gt; если используется &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; , и &lt;code&gt;byte_size(N)&lt;/code&gt; если используется &lt;code&gt;rsa_no_padding&lt;/code&gt; , где N - открытый модуль ключа RSA.</target>
        </trans-unit>
        <trans-unit id="20a866d073ca584886db7c9d897f09b98c62abbf" translate="yes" xml:space="preserve">
          <source>The size of the call counters is the host machine word size. One bit is used when pausing the counter, so the maximum counter value for a 32-bit host is 2147483647.</source>
          <target state="translated">Размер счетчиков вызовов-это размер слова хост-машины.Один бит используется при паузе счетчика,поэтому максимальное значение счетчика для 32-битного хоста равно 2147483647.</target>
        </trans-unit>
        <trans-unit id="fb56015c8eab043674edf8d83f2180e86ae9a77a" translate="yes" xml:space="preserve">
          <source>The size of the compressed file (the size of the uncompressed file is found in &lt;code&gt;info&lt;/code&gt;)</source>
          <target state="translated">Размер сжатого файла (размер несжатого файла указан в &lt;code&gt;info&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2f0d2a526b810e744210895a97ddddfb9dfdd679" translate="yes" xml:space="preserve">
          <source>The size of the data that survived the previous garbage collection.</source>
          <target state="translated">Размер данных,которые пережили предыдущую сборку мусора.</target>
        </trans-unit>
        <trans-unit id="e9d65b80debf675400c50641feff8560b459d932" translate="yes" xml:space="preserve">
          <source>The size of the encoded values was 458 bytes for &lt;code&gt;GUI&lt;/code&gt; and 464 bytes for &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt;.</source>
          <target state="translated">Размер закодированных значений составлял 458 байтов для &lt;code&gt;GUI&lt;/code&gt; и 464 байта для &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6de9b33cf1949c23faaaa88b249a1008b2802a9a" translate="yes" xml:space="preserve">
          <source>The size of the largest contiguous free memory block available to the Erlang emulator.</source>
          <target state="translated">Размер самого большого смежного блока свободной памяти,доступного эмулятору Erlang.</target>
        </trans-unit>
        <trans-unit id="6d118a2b54a2818588ac5a0110de6ef29741d438" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the heap and the stack.</source>
          <target state="translated">Размер блока памяти,используемого для хранения кучи и стека.</target>
        </trans-unit>
        <trans-unit id="e6c71457bdeadfc9d10261846b10fe6f6d7f7a91" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the old heap.</source>
          <target state="translated">Размер блока памяти,используемого для хранения старой кучи.</target>
        </trans-unit>
        <trans-unit id="dc966159ad664aaf70a48fd1f0edce70ddc61365" translate="yes" xml:space="preserve">
          <source>The size of the process in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">Размер процесса в байтах, полученный вызовом &lt;code&gt;process_info(Pid,memory)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="764453484226497e0bb92b39542a42c4b18f03bf" translate="yes" xml:space="preserve">
          <source>The size of the process, in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">Размер процесса в байтах, полученный вызовом &lt;code&gt;process_info(Pid,memory)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="191298b20bbe06d47611b490fefa2f8a4b372b8e" translate="yes" xml:space="preserve">
          <source>The size of the stack and heap (they share memory segment).</source>
          <target state="translated">Размер стека и кучи (они разделяют сегмент памяти).</target>
        </trans-unit>
        <trans-unit id="b499431fe56f03547ddeaaaf414d227e0530ddbf" translate="yes" xml:space="preserve">
          <source>The size of the stack and heap, in words (they share memory segment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178ae932ebc1af7c2dda4dfd8f46a38ebd32810a" translate="yes" xml:space="preserve">
          <source>The size of the stack.</source>
          <target state="translated">Размер стопки.</target>
        </trans-unit>
        <trans-unit id="8f1488fc1dd7db66c80f3a57b0e5af0af66de229" translate="yes" xml:space="preserve">
          <source>The size of the tail must be evenly divisible by 8.</source>
          <target state="translated">Размер хвоста должен быть равномерно разделен на 8.</target>
        </trans-unit>
        <trans-unit id="0d0d88986d4bbf13803d8e24b41f46f6997c4e2c" translate="yes" xml:space="preserve">
          <source>The size of the used part of the heap.</source>
          <target state="translated">Размер использованной части кучи.</target>
        </trans-unit>
        <trans-unit id="2b09e2b23bece918b025556de700326cad53b8b5" translate="yes" xml:space="preserve">
          <source>The size of the used part of the old heap.</source>
          <target state="translated">Размер использованной части старой кучи.</target>
        </trans-unit>
        <trans-unit id="41304c62a18f9ce2c917c4249897d635a4661faf" translate="yes" xml:space="preserve">
          <source>The size of the user-level buffer used by the driver. Not to be confused with options &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt;, which correspond to the Kernel socket buffers. For TCP it is recommended to have &lt;code&gt;val(buffer) &amp;gt;= val(recbuf)&lt;/code&gt; to avoid performance issues because of unnecessary copying. For UDP the same recommendation applies, but the max should not be larger than the MTU of the network path. &lt;code&gt;val(buffer)&lt;/code&gt; is automatically set to the above maximum when &lt;code&gt;recbuf&lt;/code&gt; is set. However, as the size set for &lt;code&gt;recbuf&lt;/code&gt; usually become larger, you are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to analyze the behavior of your operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3a8f533f48a479fd53920b8d4e9fa6257ad510" translate="yes" xml:space="preserve">
          <source>The size of the user-level software buffer used by the driver. Not to be confused with options &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt;, which correspond to the Kernel socket buffers. It is recommended to have &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; to avoid performance issues because of unnecessary copying. &lt;code&gt;val(buffer)&lt;/code&gt; is automatically set to the above maximum when values &lt;code&gt;sndbuf&lt;/code&gt; or &lt;code&gt;recbuf&lt;/code&gt; are set. However, as the sizes set for &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt; usually become larger, you are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to analyze the behavior of your operating system.</source>
          <target state="translated">Размер программного буфера пользовательского уровня, используемого драйвером. Не путать с параметрами &lt;code&gt;sndbuf&lt;/code&gt; и &lt;code&gt;recbuf&lt;/code&gt; , которые соответствуют буферам сокетов ядра. Рекомендуется иметь &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; чтобы избежать проблем с производительностью из-за ненужного копирования. &lt;code&gt;val(buffer)&lt;/code&gt; автоматически устанавливается на указанное выше максимальное значение, когда установлены значения &lt;code&gt;sndbuf&lt;/code&gt; или &lt;code&gt;recbuf&lt;/code&gt; . Однако, поскольку размеры, установленные для &lt;code&gt;sndbuf&lt;/code&gt; и &lt;code&gt;recbuf&lt;/code&gt; , обычно становятся больше, вам рекомендуется использовать &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; для анализа поведения вашей операционной системы.</target>
        </trans-unit>
        <trans-unit id="0337cb0052fe5c48f17d9708364b5583f847dcf3" translate="yes" xml:space="preserve">
          <source>The size used by the atom table.</source>
          <target state="translated">Размер,используемый таблицей атомов.</target>
        </trans-unit>
        <trans-unit id="e83812695b4a0e2f148a81a290a4a4d654c89eac" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of a log file before switching to a new log file. Defaults to 100000, minimum is 1000, maximum is about 2^30.</source>
          <target state="translated">Размер в байтах лог-файла перед переходом на новый лог-файл.По умолчанию 100000,минимум 1000,максимум 2^30.</target>
        </trans-unit>
        <trans-unit id="50b5375e0c8bae3f537af36dd5bfe134a6c1fd3a" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel receive buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(recbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">Размер в байтах буфера приема ядра ОС для этого сокета. Ошибки при &lt;code&gt;val(recbuf)&lt;/code&gt; могут возникать для дейтаграмм, размер которых превышает значение val (recbuf) . Установка этого параметра также регулирует размер буфера драйвера (см. &lt;code&gt;buffer&lt;/code&gt; выше).</target>
        </trans-unit>
        <trans-unit id="744f9981cac8532f8de991a560a3c78c830d93a6" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel send buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(sndbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">Размер в байтах буфера отправки ядра ОС для этого сокета. Ошибки при &lt;code&gt;val(sndbuf)&lt;/code&gt; могут возникать для дейтаграмм, размер которых превышает значение val (sndbuf) . Установка этого параметра также регулирует размер буфера драйвера (см. &lt;code&gt;buffer&lt;/code&gt; выше).</target>
        </trans-unit>
        <trans-unit id="80ca8cbf4860dc45abcab2ee816502487d967651" translate="yes" xml:space="preserve">
          <source>The sizes of the log events affect the memory needs of the handler. For information about how to limit the size of log events, see the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Размеры событий журнала влияют на потребность обработчика в памяти. Для получения информации о том, как ограничить размер событий журнала, см. &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; руководства logger_formatter (3) .</target>
        </trans-unit>
        <trans-unit id="e2bdd08787f901adfc9bda5806a8294e711f82f7" translate="yes" xml:space="preserve">
          <source>The slave node is to use the same file system at the master. At least, Erlang/OTP is to be installed in the same place on both computers and the same version of Erlang is to be used.</source>
          <target state="translated">Ведомый узел должен использовать одну и ту же файловую систему на ведущем устройстве.По крайней мере,Erlang/OTP должен быть установлен в одном и том же месте на обоих компьютерах,и должна использоваться одна и та же версия Erlang.</target>
        </trans-unit>
        <trans-unit id="f96a0c0475b2702681a975d50f5c5275575ff811" translate="yes" xml:space="preserve">
          <source>The slave node resets its &lt;code&gt;user&lt;/code&gt; process so that all terminal I/O that is produced at the slave is automatically relayed to the master. Also, the file process is relayed to the master.</source>
          <target state="translated">Подчиненный узел сбрасывает свой &lt;code&gt;user&lt;/code&gt; процесс, так что весь ввод / вывод терминала, производимый на ведомом, автоматически передается ведущему. Кроме того, файловый процесс передается мастеру.</target>
        </trans-unit>
        <trans-unit id="c5dfcb751ff28f219d1d581b79806c8ef4c53f7f" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt;, passing along &lt;code&gt;Name&lt;/code&gt; and, if provided, &lt;code&gt;Args&lt;/code&gt;. &lt;code&gt;Name&lt;/code&gt; is used as the first part of the node names, &lt;code&gt;Args&lt;/code&gt; is used to specify command-line arguments.</source>
          <target state="translated">Ведомые узлы запускаются с &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt; , передавая &lt;code&gt;Name&lt;/code&gt; и, если предоставлено, &lt;code&gt;Args&lt;/code&gt; . &lt;code&gt;Name&lt;/code&gt; используется в качестве первой части имен узлов, &lt;code&gt;Args&lt;/code&gt; используется для указания аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="b6a9facae6762d3a2d983123523a049078f4b929" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with the &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; module. This effects terminal I/O, file I/O, and code loading.</source>
          <target state="translated">Ведомые узлы запускаются с помощью &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; модуля. Это влияет на ввод-вывод терминала, ввод-вывод файлов и загрузку кода.</target>
        </trans-unit>
        <trans-unit id="eff695ae8a9be5c2401875ebeb79790be1f1fe68" translate="yes" xml:space="preserve">
          <source>The slave nodes send regular reports to the master about their current load.</source>
          <target state="translated">Ведомые узлы регулярно посылают ведущему устройству отчеты о текущей нагрузке.</target>
        </trans-unit>
        <trans-unit id="1bd8d8ae05660e3f8d1c448fac43b54c3d2e34e2" translate="yes" xml:space="preserve">
          <source>The smallest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Наименьший размер мультиблочной несущей ( &lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aa74489ccfd55ad582b4db554e67d3965db81df4" translate="yes" xml:space="preserve">
          <source>The smallest unit that the test server is concerned with is a test case. Each test case can test many things, for example, make several calls to the same interface function with different parameters.</source>
          <target state="translated">Самый маленький блок,который касается тестового сервера,является тестовым случаем.Каждый тестовый случай может проверить много вещей,например,сделать несколько вызовов одной интерфейсной функции с различными параметрами.</target>
        </trans-unit>
        <trans-unit id="9ea79c809c45352a9e00179e7da2c36055d038e8" translate="yes" xml:space="preserve">
          <source>The snmp application provides two different modules, &lt;code&gt;snmpm_net_if&lt;/code&gt; (the default) and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;, both uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;. The difference between the two modules is that the latter is &quot;multi-threaded&quot;, i.e. for each message/request a new process is created that processes the message/request and then exits.</source>
          <target state="translated">Приложение snmp предоставляет два разных модуля, &lt;code&gt;snmpm_net_if&lt;/code&gt; (по умолчанию) и &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; , оба используют UDP в качестве транспортного протокола, т.е. транспортные домены &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; и / или &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; . Разница между двумя модулями заключается в том, что последний является &amp;laquo;многопоточным&amp;raquo;, т.е. для каждого сообщения / запроса создается новый процесс, который обрабатывает сообщение / запрос и затем завершается.</target>
        </trans-unit>
        <trans-unit id="b02a7822a31c2facabfac5e02e61cea15f2e0693" translate="yes" xml:space="preserve">
          <source>The socket interface (module) is basically a &quot;thin&quot; layer on top of the OS socket interface. It is assumed that, unless you have special needs, gen_[tcp|udp|sctp] should be sufficent (when they become available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890d257b12c0103c2f2773954dbb3903b79d49e7" translate="yes" xml:space="preserve">
          <source>The socket is set to a busy state when the amount of data queued internally by the ERTS socket implementation reaches this limit. Defaults to 8 kB.</source>
          <target state="translated">Сокет устанавливается в состояние &quot;занято&quot;,когда количество данных в очереди внутри реализации сокета ERTS достигает этого предела.По умолчанию 8 кБ.</target>
        </trans-unit>
        <trans-unit id="ab70c80adb0296ab4476e7326e05623f1d1b81ea" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be from &lt;code&gt;gen_tcp:connect&lt;/code&gt; or &lt;code&gt;gen_tcp:accept&lt;/code&gt; with option &lt;code&gt;{active,false}&lt;/code&gt;</source>
          <target state="translated">Сокет должен быть от &lt;code&gt;gen_tcp:connect&lt;/code&gt; или &lt;code&gt;gen_tcp:accept&lt;/code&gt; с опцией &lt;code&gt;{active,false}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44cb3c6e112d60616f61ce3179ae2f5db9db0cba" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be result of a &lt;code&gt;gen_tcp:connect&lt;/code&gt; or a &lt;code&gt;gen_tcp:accept&lt;/code&gt;. The socket must be in passive mode (that is, opened with the option &lt;code&gt;{active,false})&lt;/code&gt;.</source>
          <target state="translated">Сокет должен быть результатом &lt;code&gt;gen_tcp:connect&lt;/code&gt; или &lt;code&gt;gen_tcp:accept&lt;/code&gt; . Сокет должен быть в пассивном режиме (то есть открыт с опцией &lt;code&gt;{active,false})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="925659a2ced1ee88f823aa52063a42e6955489e2" translate="yes" xml:space="preserve">
          <source>The socket message queue is set to a busy state when the amount of data on the message queue reaches this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 8 kB.</source>
          <target state="translated">Очередь сообщений сокета устанавливается в состояние &quot;занято&quot;,когда объем данных в очереди сообщений достигает этого предела.Обратите внимание,что этот предел касается только тех данных,которые еще не достигли реализации внутреннего сокета ERTS.По умолчанию 8 кБ.</target>
        </trans-unit>
        <trans-unit id="f02f850d90c7fd6701fa67a1c73724ba84ac1faf" translate="yes" xml:space="preserve">
          <source>The socket owner process.</source>
          <target state="translated">Процесс владельца розетки.</target>
        </trans-unit>
        <trans-unit id="72f50e8cca44d427ecdea919b729a9f976d4b8f1" translate="yes" xml:space="preserve">
          <source>The socket returned can only be used with &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt;. No traffic can be sent or received before that call.</source>
          <target state="translated">Возвращенный сокет можно использовать только с &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; . Перед этим вызовом трафик не может быть отправлен или получен.</target>
        </trans-unit>
        <trans-unit id="68853c7896ab72f079055456a599e669b94ec773" translate="yes" xml:space="preserve">
          <source>The socket, in format &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;, depending on &lt;code&gt;socket_type&lt;/code&gt;.</source>
          <target state="translated">Сокет в формате &lt;code&gt;ip_comm&lt;/code&gt; или &lt;code&gt;ssl&lt;/code&gt; , в зависимости от типа &lt;code&gt;socket_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2268a9a9dea928b5f653dddc6d70d3d7abdecd4b" translate="yes" xml:space="preserve">
          <source>The software the client claims to be using (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">Программное обеспечение,которое,по утверждению клиента,используется (если его невозможно определить,в этом поле ставится знак &quot;минус&quot;).</target>
        </trans-unit>
        <trans-unit id="af7122a56cc3283d794f4f2131bcb161acc514ee" translate="yes" xml:space="preserve">
          <source>The solution in R16 is instead to &lt;strong&gt;replicate&lt;/strong&gt; the code access structures. We have one set of active structures read by the running code. When new code is loaded the active structures are copied, the copy is updated to include the newly loaded module and then a switch is made to make the updated copy the new active set. The active set is identified by a single global atomic variable &lt;code&gt;the_active_code_index&lt;/code&gt;. The switch can thus be made by a single atomic write operation. The running code have to read this atomic variable when using the active access structures, which means one atomic read operation per external function call for example. The performance penalty from this extra atomic read is however very small as it can be done without any memory barriers at all (as described below). With this solution we also preserve the transactional feature of a load operation. Running code will never see the intermediate result of a half loaded module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59919acf7ad71bce9fc6539c387deaefebd73d43" translate="yes" xml:space="preserve">
          <source>The sorter uses temporary files only if &lt;code&gt;QH1&lt;/code&gt; does not evaluate to a list and the size of the binary representation of the answers exceeds &lt;code&gt;Size&lt;/code&gt; bytes, where &lt;code&gt;Size&lt;/code&gt; is the value of option &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Сортировщик использует временные файлы только в том случае, если &lt;code&gt;QH1&lt;/code&gt; не оценивает список и размер двоичного представления ответов превышает &lt;code&gt;Size&lt;/code&gt; байтов, где &lt;code&gt;Size&lt;/code&gt; - это значение &lt;code&gt;size&lt;/code&gt; параметра .</target>
        </trans-unit>
        <trans-unit id="881ec9a1f2e48b94ddfd3fa755f8d866af15e90d" translate="yes" xml:space="preserve">
          <source>The source code can be downloaded from the official site of Erlang/OTP or GitHub.</source>
          <target state="translated">Исходный код можно скачать с официального сайта Erlang/OTP или GitHub.</target>
        </trans-unit>
        <trans-unit id="1e180c78c274b1e63d26ec543874e277c8a7cd9c" translate="yes" xml:space="preserve">
          <source>The source code is indented and each line is prefixed with its line number.</source>
          <target state="translated">Исходный код имеет отступы и каждая строка префикс с номером строки.</target>
        </trans-unit>
        <trans-unit id="772cf36afe48c0ca08d944464d6f5613843516b5" translate="yes" xml:space="preserve">
          <source>The source file is compiled with the the original options appended to the given &lt;code&gt;Options&lt;/code&gt;, the output replacing the old object file if and only if compilation succeeds. A function &lt;code&gt;Filter&lt;/code&gt; can be specified for removing elements from from the original compiler options before the new options are added.</source>
          <target state="translated">Исходный файл компилируется с исходными параметрами, добавленными к заданным &lt;code&gt;Options&lt;/code&gt; , вывод заменяет старый объектный файл тогда и только тогда, когда компиляция завершается успешно. Можно указать функцию &lt;code&gt;Filter&lt;/code&gt; для удаления элементов из исходных параметров компилятора перед добавлением новых параметров.</target>
        </trans-unit>
        <trans-unit id="d06894cd41dc043df906ea8b5e56fb15f704aa5a" translate="yes" xml:space="preserve">
          <source>The source for a backup is an activated checkpoint. The backup function &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; is most commonly used and returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;. It has the following arguments:</source>
          <target state="translated">Источником резервной копии является активированная контрольная точка. Функция резервного копирования &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; используется чаще всего и возвращает &lt;code&gt;ok&lt;/code&gt; или &lt;code&gt;{error,Reason}&lt;/code&gt; . У него следующие аргументы:</target>
        </trans-unit>
        <trans-unit id="21ba4b6f6db86323236436d5d356017eead9a57a" translate="yes" xml:space="preserve">
          <source>The source of the message, usually the name of the application that generated it. This could be almost any string. When matching messages from certain applications, the version number of the application may have to be accounted for. This is what the NT event viewer calls &quot;source&quot;.</source>
          <target state="translated">Источник сообщения,обычно название приложения,которое его создало.Это может быть почти любая строка.При совпадении сообщений из определенных приложений,возможно,придется учитывать номер версии приложения.Это то,что просмотрщик событий NT называет &quot;источником&quot;.</target>
        </trans-unit>
        <trans-unit id="fcf8739969b05c2227a6f3526a3eecacb416317d" translate="yes" xml:space="preserve">
          <source>The source release is delivered with a lot of platform independent build results already pre-built. If you want to remove these pre-built files, invoke &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; from the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. After you have done this, you can build exactly the same way as before, but the build process will take a much longer time.</source>
          <target state="translated">Исходный релиз поставляется с уже готовыми результатами сборки, независимыми от платформы. Если вы хотите удалить эти предварительно созданные файлы, вызовите &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; из &lt;code&gt;$ERL_TOP&lt;/code&gt; . После того, как вы это сделаете, вы можете построить точно так же, как и раньше, но процесс сборки займет гораздо больше времени.</target>
        </trans-unit>
        <trans-unit id="a52e9171d64ddfe2904377da52809c70237ed94b" translate="yes" xml:space="preserve">
          <source>The spawn driver (used when spawning an executable) and the &lt;code&gt;fd&lt;/code&gt; driver do not disable this feature and do not adjust these limits by themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4f39d77f5cdfa59ed6968030318e46812bded4" translate="yes" xml:space="preserve">
          <source>The spawn operation fails either if creation of a new process failed or if the spawn operation was interrupted by a connection failure. When a spawn operation fails, the caller will by default be sent a message on the form &lt;code&gt;{ReplyTag, ReqId, error, Reason}&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is the error reason. Such a message is referred to as an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c6c390b6e4eef5413283b9b82f2f391a4ea8bf" translate="yes" xml:space="preserve">
          <source>The spawn request was successfully abandoned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ba3eb61829a7833d7384b19b027906c4b3feb1" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$ROOT&lt;/code&gt; variable can only be used in the script, not as a command-line argument. The given directory is relative the Erlang installation directory.</source>
          <target state="translated">Специальная переменная &lt;code&gt;$ROOT&lt;/code&gt; может использоваться только в сценарии, но не в качестве аргумента командной строки. Данный каталог является относительным каталогом установки Erlang.</target>
        </trans-unit>
        <trans-unit id="fd2015df355d448e0a3bd19ecbc252e161ab2cfb" translate="yes" xml:space="preserve">
          <source>The special match specification variables &lt;code&gt;'$_'&lt;/code&gt; and &lt;code&gt;'$*'&lt;/code&gt; can be accessed through the pseudo functions &lt;code&gt;object()&lt;/code&gt; (for &lt;code&gt;'$_'&lt;/code&gt;) and &lt;code&gt;bindings()&lt;/code&gt; (for &lt;code&gt;'$*'&lt;/code&gt;). As an example, one can translate the following &lt;code&gt;ets:match_object/2&lt;/code&gt; call to a &lt;code&gt;ets:select/2&lt;/code&gt; call:</source>
          <target state="translated">К специальным переменным спецификации соответствия &lt;code&gt;'$_'&lt;/code&gt; и &lt;code&gt;'$*'&lt;/code&gt; можно получить доступ через &lt;code&gt;object()&lt;/code&gt; (для &lt;code&gt;'$_'&lt;/code&gt; ) и &lt;code&gt;bindings()&lt;/code&gt; (для &lt;code&gt;'$*'&lt;/code&gt; ). В качестве примера можно преобразовать следующий &lt;code&gt;ets:match_object/2&lt;/code&gt; вызов &lt;code&gt;ets:select/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3d184230e40d23967b4ecaa91bc5e82ccd5cf4c3" translate="yes" xml:space="preserve">
          <source>The special property L&amp;amp; is also supported. It matches a character that has the Lu, Ll, or Lt property, that is, a letter that is not classified as a modifier or &quot;other&quot;.</source>
          <target state="translated">Также поддерживается специальное свойство L &amp;amp;. Он соответствует символу, имеющему свойство Lu, Ll или Lt, то есть букве, которая не классифицируется как модификатор или &amp;laquo;другое&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6d78a416b1fb043fc9e7a30712c95b72e4af2747" translate="yes" xml:space="preserve">
          <source>The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence.</source>
          <target state="translated">Все специальные команды оболочки имеют синтаксис (локальных)вызовов функций.Они оцениваются как обычные вызовы функций,и многие команды могут быть использованы в одной последовательности выражений.</target>
        </trans-unit>
        <trans-unit id="63aa3b1e5890590b0f6ee8261569fec19c3e02cf" translate="yes" xml:space="preserve">
          <source>The special term &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; is used to &quot;splice&quot; in a string in a list, a string specified this way is not a list in itself, but the elements are elements of the surrounding list.</source>
          <target state="translated">Специальный термин &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; используется для &amp;laquo;вставки&amp;raquo; в строку в списке, указанная таким образом строка не является списком сама по себе, но элементы являются элементами окружающего списка.</target>
        </trans-unit>
        <trans-unit id="3767f42dfb86884ecfa881e3b33b5f1bd1f1e163" translate="yes" xml:space="preserve">
          <source>The special value &lt;code&gt;disable&lt;/code&gt; prevents the Server Name Indication extension from being sent and disables the hostname verification check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f706ef9a4d4e07f69004ede757b96ff5ef984e0" translate="yes" xml:space="preserve">
          <source>The special value &lt;strong&gt;flag&lt;/strong&gt; instead indicates that the function &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; shall be used.</source>
          <target state="translated">Вместо этого &lt;strong&gt;флаг&lt;/strong&gt; специального значения указывает, что должна использоваться функция &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c180b14afbed7b4ae1c88179e9218b5daae9170a" translate="yes" xml:space="preserve">
          <source>The specific instruction &lt;code&gt;i_bs_get_integer_32&lt;/code&gt; will only be defined on a 64-bit machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf1b065f7475d6ac0e5944dcaad766452c86801" translate="yes" xml:space="preserve">
          <source>The specific instructions are known only to the runtime system and are the instructions that are actually executed. They can be changed at any time without causing compatibility issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbf785b1e1daf48fbb6ef71da6f40a7025aba2b" translate="yes" xml:space="preserve">
          <source>The specification key does not exist.</source>
          <target state="translated">Ключа спецификации не существует.</target>
        </trans-unit>
        <trans-unit id="e6b11d2daf1d2fe5ce8435f49d6f63466ec21923" translate="yes" xml:space="preserve">
          <source>The specification of &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; can be hard-coded as &lt;code&gt;{index, [2]}&lt;/code&gt; and &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt;, respectively.</source>
          <target state="translated">Спецификация &lt;code&gt;index&lt;/code&gt; и &lt;code&gt;attributes&lt;/code&gt; может быть жестко запрограммирована как &lt;code&gt;{index, [2]}&lt;/code&gt; и &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="569ad77b917c89cf2cb18ed8978c4e321b16e950" translate="yes" xml:space="preserve">
          <source>The specifications &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; were used in the test.</source>
          <target state="translated">В тесте использовались спецификации &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c9f9bb6dda1817bac37a46fe84e1fbe4666f5af" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Filename&lt;/code&gt; is prefixed with the node name. Default &lt;code&gt;Filename&lt;/code&gt; is &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">Указанное имя &lt;code&gt;Filename&lt;/code&gt; имеет префикс с именем узла. &lt;code&gt;Filename&lt;/code&gt; умолчанию - &lt;code&gt;ttb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a78dd1ea59140a32308f444a3d3f489add93983" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;comparing equal&lt;/strong&gt; the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table, or &lt;strong&gt;matching&lt;/strong&gt; in other types of tables (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Указанный &lt;code&gt;Key&lt;/code&gt; используется для идентификации объекта либо путем &lt;strong&gt;сравнения равного&lt;/strong&gt; ключа объекта в таблице &lt;code&gt;ordered_set&lt;/code&gt; , либо путем &lt;strong&gt;сопоставления&lt;/strong&gt; в других типах таблиц (подробнее о различиях см. &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="832d1f70c554be8c643c3c3c0c699e86c09d600d" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;matching&lt;/strong&gt; the key of an object in a &lt;code&gt;set&lt;/code&gt; table, or &lt;strong&gt;compare equal&lt;/strong&gt; to the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Указанный &lt;code&gt;Key&lt;/code&gt; используется для идентификации объекта либо путем &lt;strong&gt;сопоставления&lt;/strong&gt; ключа объекта в таблице &lt;code&gt;set&lt;/code&gt; , либо путем &lt;strong&gt;сравнения&lt;/strong&gt; с ключом объекта в таблице &lt;code&gt;ordered_set&lt;/code&gt; (подробнее о различиях см. &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c6caca78cf0733387e75985a561e3ed41d83af2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;logdir&lt;/code&gt; directory is used for storing the HTML log files (in subdirectories tagged with node name, date, and time).</source>
          <target state="translated">Указанный каталог &lt;code&gt;logdir&lt;/code&gt; используется для хранения файлов журнала HTML (в подкаталогах, помеченных именем узла, датой и временем).</target>
        </trans-unit>
        <trans-unit id="d8f4d5f198f549cf59998ab6e9b38627280804f7" translate="yes" xml:space="preserve">
          <source>The specified XML document is sent &quot;as is&quot; to the server. This function can be used for sending XML documents that cannot be expressed by other interface functions in this module.</source>
          <target state="translated">Указанный XML документ отправляется на сервер &quot;как есть&quot;.Эта функция может быть использована для отправки XML-документов,которые не могут быть выражены другими интерфейсными функциями данного модуля.</target>
        </trans-unit>
        <trans-unit id="67af2595bd4825418d486d6611387842fada4fe3" translate="yes" xml:space="preserve">
          <source>The specified XML document is wrapped in a valid NETCONF &lt;code&gt;rpc&lt;/code&gt; request and sent to the server. The &lt;code&gt;message-id&lt;/code&gt; and namespace attributes are added to element &lt;code&gt;rpc&lt;/code&gt;.</source>
          <target state="translated">Указанный XML-документ упаковывается в допустимый запрос NETCONF &lt;code&gt;rpc&lt;/code&gt; и отправляется на сервер. В &lt;code&gt;message-id&lt;/code&gt; атрибуты и пространства имен добавляются к элементу &lt;code&gt;rpc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77ace5a3a9ee7abec7d82aa98cb78832103cfb00" translate="yes" xml:space="preserve">
          <source>The specified application is not loaded.</source>
          <target state="translated">Указанное приложение не загружается.</target>
        </trans-unit>
        <trans-unit id="7d093a57604a6ecaca53b3ce36fbb95e4bc18f8a" translate="yes" xml:space="preserve">
          <source>The specified module flows from your instantiation of the &lt;code&gt;Viewer&lt;/code&gt;, to the &lt;code&gt;Collector&lt;/code&gt; that it automatically creates, gets stashed in as the &lt;code&gt;Trace Pattern&lt;/code&gt;, and eventually goes down into the bowels of the &lt;code&gt;Selector&lt;/code&gt;.</source>
          <target state="translated">Указанный модуль перетекает от вашего экземпляра &lt;code&gt;Viewer&lt;/code&gt; к &lt;code&gt;Collector&lt;/code&gt; который он создает автоматически, сохраняется как &lt;code&gt;Trace Pattern&lt;/code&gt; и в конечном итоге попадает в недра &lt;code&gt;Selector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d37865ea2af043489e228e4a87a6f2db90cb4c8d" translate="yes" xml:space="preserve">
          <source>The specified release version &lt;code&gt;Vsn&lt;/code&gt; does not exist.</source>
          <target state="translated">Указанная версия выпуска &lt;code&gt;Vsn&lt;/code&gt; не существует.</target>
        </trans-unit>
        <trans-unit id="3b8bce2d65b733b38425b28f665ddd56d541e379" translate="yes" xml:space="preserve">
          <source>The specified string or character is case-converted. Notice that the supported character set is ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged</source>
          <target state="translated">Указанная строка или символ преобразуется в регистр.Обратите внимание,что поддерживаемый набор символов-ISO/IEC 8859-1 (также называемый Latin 1);все значения вне этого набора неизменны.</target>
        </trans-unit>
        <trans-unit id="a909f58eed86dcb459bb7e97f8bf0f61f50ce1e8" translate="yes" xml:space="preserve">
          <source>The spelling &lt;code&gt;behavior&lt;/code&gt; is also accepted.</source>
          <target state="translated">Орфография &lt;code&gt;behavior&lt;/code&gt; также принято.</target>
        </trans-unit>
        <trans-unit id="efd3f0f6af9bad896585909bd0ff06183026aa0e" translate="yes" xml:space="preserve">
          <source>The ssh server on the remote host checks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055977833d1ee7a28dbe717c666d179fb1aed3c2" translate="yes" xml:space="preserve">
          <source>The ssh:start/0 function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5309c7fe313dda17e9facd4377c48f36ec3201cb" translate="yes" xml:space="preserve">
          <source>The stack back-trace (&lt;strong&gt;stacktrace&lt;/strong&gt;) is a list of &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; tuples. The field &lt;code&gt;Arity&lt;/code&gt; in the first tuple can be the argument list of that function call instead of an arity integer, depending on the exception.</source>
          <target state="translated">Обратная трассировка стека ( &lt;strong&gt;stacktrace&lt;/strong&gt; ) - это список кортежей &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; . Поле &lt;code&gt;Arity&lt;/code&gt; в первом кортеже может быть списком аргументов этого вызова функции вместо целого числа arity, в зависимости от исключения.</target>
        </trans-unit>
        <trans-unit id="45ce8e9f1c15d0274292ea0288412d440ab1701d" translate="yes" xml:space="preserve">
          <source>The stack dump is a dump of the Erlang process stack. Most of the live data (that is, variables currently in use) are placed on the stack; thus this can be interesting. One has to &quot;guess&quot; what is what, but as the information is symbolic, thorough reading of this information can be useful. As an example, we can find the state variable of the Erlang primitive loader online &lt;code&gt;(5)&lt;/code&gt; and &lt;code&gt;(6)&lt;/code&gt; in the following example:</source>
          <target state="translated">Дамп стека - это дамп стека процесса Erlang. Большая часть оперативных данных (то есть переменных, используемых в данный момент) помещается в стек; таким образом, это может быть интересно. Нужно &amp;laquo;угадывать&amp;raquo;, что к чему, но поскольку информация носит символический характер, ее внимательное прочтение может оказаться полезным. В качестве примера мы можем найти переменную состояния примитивного загрузчика Erlang онлайн &lt;code&gt;(5)&lt;/code&gt; и &lt;code&gt;(6)&lt;/code&gt; в следующем примере:</target>
        </trans-unit>
        <trans-unit id="f4779fab4d980187187f7b568fd5d1cecf627b61" translate="yes" xml:space="preserve">
          <source>The stack trace can be be bound to a variable from within a &lt;code&gt;try&lt;/code&gt; expression, and is returned for exceptions of class &lt;code&gt;error&lt;/code&gt; from a &lt;code&gt;catch&lt;/code&gt; expression.</source>
          <target state="translated">Трассировка стека может быть привязана к переменной из выражения &lt;code&gt;try&lt;/code&gt; и возвращается для исключений &lt;code&gt;error&lt;/code&gt; класса из выражения &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="716b4c8e42164ca68dd1eef2aad830b323c54fbe" translate="yes" xml:space="preserve">
          <source>The stack trace can be bound to a variable from within a &lt;code&gt;try&lt;/code&gt; expression, and is returned for exceptions of class &lt;code&gt;error&lt;/code&gt; from a &lt;code&gt;catch&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8ca8ba7f9cf2f1cf34954b8c2fda1504010ff" translate="yes" xml:space="preserve">
          <source>The stacktrace is the same data as operator &lt;code&gt;catch&lt;/code&gt; returns, for example:</source>
          <target state="translated">Трассировка стека - это те же данные, что возвращает оператор &lt;code&gt;catch&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="fc5e2be1fd73b3184fa33140f882adc2e4eaf503" translate="yes" xml:space="preserve">
          <source>The stacktrace is used as the exception stacktrace for the calling process; it is truncated to the current maximum stacktrace depth.</source>
          <target state="translated">Стековая трасса используется в качестве исключения стековой трассы для вызывающего процесса;она усекается до текущей максимальной глубины стековой трассы.</target>
        </trans-unit>
        <trans-unit id="95f65f456f73c264cfc1076a4ff37600ccf76a4a" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP behaviours are:</source>
          <target state="translated">Стандартное поведение Erlang/OTP:</target>
        </trans-unit>
        <trans-unit id="bf7122f2f75170b13714d7076b64a347b292a606" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP system can be reconfigured to change the default behavior on startup.</source>
          <target state="translated">Стандартная система Erlang/OTP может быть переконфигурирована для изменения поведения по умолчанию при запуске.</target>
        </trans-unit>
        <trans-unit id="b7b586ddbaa84cea01ad2740636b956444f85f5b" translate="yes" xml:space="preserve">
          <source>The standard behaviours (&lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, and so on) send progress and error information to Logger. Progress reports are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt;logger_level&lt;/code&gt;. Supervisor reports, crash reports and other error and information reports are by default logged through the log handler which is set up when the Kernel application is started.</source>
          <target state="translated">Стандартное поведение ( &lt;code&gt;supervisor&lt;/code&gt; , &lt;code&gt;gen_server&lt;/code&gt; и т. Д.) Отправляет информацию о прогрессе и ошибках в Logger. Отчеты о ходе выполнения по умолчанию не регистрируются, но их можно включить, установив для основного уровня журнала значение &lt;code&gt;info&lt;/code&gt; , например, с помощью параметра конфигурации ядра &lt;code&gt;logger_level&lt;/code&gt; . Отчеты супервизора, отчеты о сбоях и другие отчеты об ошибках и информационные отчеты по умолчанию регистрируются через обработчик журнала, который настраивается при запуске приложения ядра.</target>
        </trans-unit>
        <trans-unit id="2005b81eb265a1528dcd843192ed7f5d98a0c04c" translate="yes" xml:space="preserve">
          <source>The standard binary encoding is used whenever a library function in Erlang is to handle Unicode data in binaries, but is of course not enforced when communicating externally. Functions and bit syntax exist to encode and decode both UTF-8, UTF-16, and UTF-32 in binaries. However, library functions dealing with binaries and Unicode in general only deal with the default encoding.</source>
          <target state="translated">Стандартная двоичная кодировка используется всякий раз,когда функция библиотеки на Erlang должна обрабатывать данные Unicode в двоичных файлах,но,конечно же,не применяется при внешнем взаимодействии.Существуют функции и синтаксис битов для кодирования и декодирования как UTF-8,UTF-16,так и UTF-32 в двоичных файлах.Однако библиотечные функции,работающие с бинарными файлами и Юникодом в целом,работают только с кодировкой по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4183835861454020cbfc8b77885a3f621959b27b" translate="yes" xml:space="preserve">
          <source>The standard certificate extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">Стандартные расширения сертификата Атомы имени OID и соответствующие им типы значений следующие:</target>
        </trans-unit>
        <trans-unit id="e8da6740394a506d3316b11fa47e1c984ea529f7" translate="yes" xml:space="preserve">
          <source>The standard documents that define SNMPv2 are incomplete, in the sense that they do not specify how an SNMPv2 message looks like. The message format and security issues are left to a special Administrative Framework. One such framework is the Community-based SNMPv2 Framework (SNMPv2c), which uses the same message format and framework as SNMPv1. Other experimental frameworks as exist, e.g. SNMPv2u and SNMPv2*.</source>
          <target state="translated">Стандартные документы,определяющие SNMPv2,являются неполными в том смысле,что в них не указано,как выглядит сообщение SNMPv2.Формат сообщения и проблемы безопасности оставлены в специальной административной структуре.Одной из таких структур является структура SNMPv2 на базе сообщества (SNMPv2c),которая использует тот же формат сообщений и структуру,что и SNMPv1.Существуют и другие экспериментальные структуры,например,SNMPv2u и SNMPv2*.</target>
        </trans-unit>
        <trans-unit id="dc54a83b77765211d993fa09d8d0f6be7eb0aa1e" translate="yes" xml:space="preserve">
          <source>The standard example is when formatting source code as HTML to be placed within &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; markup, and using e.g. &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; to make parts of the source code stand out. In this case, the markup does not add to the width of the text when viewed in an HTML browser, so the layout engine should simply pretend that the markup has zero width.</source>
          <target state="translated">Стандартный пример - форматирование исходного кода в виде HTML для размещения в разметке &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; и использование, например, &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; , чтобы выделить части исходного кода. В этом случае разметка не увеличивает ширину текста при просмотре в браузере HTML, поэтому механизм макета должен просто делать вид, что разметка имеет нулевую ширину.</target>
        </trans-unit>
        <trans-unit id="913db80fae0242e7eb7aa0597b7610d00dd2e55e" translate="yes" xml:space="preserve">
          <source>The standard list encoding for strings was therefore easily extended to handle the whole Unicode range. A Unicode string in Erlang is a list containing integers, where each integer is a valid Unicode code point and represents one character in the Unicode character set.</source>
          <target state="translated">Таким образом,стандартная кодировка списка для строк была легко расширена для работы со всем диапазоном Unicode.Строка Юникода в Эрланге-это список,содержащий целые числа,где каждое целое число является действительной точкой кода Юникода и представляет один символ в наборе символов Юникода.</target>
        </trans-unit>
        <trans-unit id="96e137cd77a79e26488628d7b4bc6d3c818af033" translate="yes" xml:space="preserve">
          <source>The standard module &lt;code&gt;lists&lt;/code&gt; also contains a function &lt;code&gt;sort(Fun, List)&lt;/code&gt; where &lt;code&gt;Fun&lt;/code&gt; is a fun with two arguments. This fun returns &lt;code&gt;true&lt;/code&gt; if the first argument is less than the second argument, or else &lt;code&gt;false&lt;/code&gt;. Sorting is added to the &lt;code&gt;convert_list_to_c&lt;/code&gt;:</source>
          <target state="translated">Стандартные &lt;code&gt;lists&lt;/code&gt; модулей также содержат функцию &lt;code&gt;sort(Fun, List)&lt;/code&gt; где &lt;code&gt;Fun&lt;/code&gt; - это игра с двумя аргументами. Эта игра возвращает &lt;code&gt;true&lt;/code&gt; если первый аргумент меньше второго, или &lt;code&gt;false&lt;/code&gt; . В &lt;code&gt;convert_list_to_c&lt;/code&gt; добавлена сортировка :</target>
        </trans-unit>
        <trans-unit id="b21571b3224dc79a2851fad7a8fdb257c1dfd3c9" translate="yes" xml:space="preserve">
          <source>The standard shell is set for &lt;code&gt;unicode&lt;/code&gt; or &lt;code&gt;latin1&lt;/code&gt; encoding when the system is started. The encoding is set with the help of the &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variables on Unix-like system or by other means on other systems. So, the user can input Unicode characters and the I/O device is in &lt;code&gt;{encoding, unicode}&lt;/code&gt; mode if the I/O device supports it. The mode can be changed, if the assumption of the runtime system is wrong, by setting this option.</source>
          <target state="translated">Стандартная оболочка устанавливается для кодировки &lt;code&gt;unicode&lt;/code&gt; или &lt;code&gt;latin1&lt;/code&gt; при запуске системы. Кодировка устанавливается с помощью переменных среды &lt;code&gt;LANG&lt;/code&gt; или &lt;code&gt;LC_CTYPE&lt;/code&gt; в Unix-подобной системе или другими способами в других системах. Таким образом, пользователь может вводить символы Unicode, а устройство ввода-вывода находится в режиме &lt;code&gt;{encoding, unicode}&lt;/code&gt; если устройство ввода-вывода его поддерживает. Если предположение о системе выполнения неверно, режим можно изменить, установив эту опцию.</target>
        </trans-unit>
        <trans-unit id="60bbcd01c05d5bf0aeb5fe03e942b16191c94a69" translate="yes" xml:space="preserve">
          <source>The start function &lt;strong&gt;must create and link to&lt;/strong&gt; the child process, and must return &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, where &lt;code&gt;Child&lt;/code&gt; is the pid of the child process and &lt;code&gt;Info&lt;/code&gt; any term that is ignored by the supervisor.</source>
          <target state="translated">Функция start &lt;strong&gt;должна создавать&lt;/strong&gt; дочерний процесс &lt;strong&gt;и связываться с ним&lt;/strong&gt; , а также должна возвращать &lt;code&gt;{ok,Child}&lt;/code&gt; или &lt;code&gt;{ok,Child,Info}&lt;/code&gt; , где &lt;code&gt;Child&lt;/code&gt; - это pid дочернего процесса, а &lt;code&gt;Info&lt;/code&gt; - любой термин, который игнорируется супервизором.</target>
        </trans-unit>
        <trans-unit id="32924ed60f44bfc045cee6cadfb10d688a40ff5d" translate="yes" xml:space="preserve">
          <source>The start function can also return &lt;code&gt;ignore&lt;/code&gt; if the child process for some reason cannot be started, in which case the child specification is kept by the supervisor (unless it is a temporary child) but the non-existing child process is ignored.</source>
          <target state="translated">Функция запуска также может возвращать &lt;code&gt;ignore&lt;/code&gt; если дочерний процесс по какой-либо причине не может быть запущен, и в этом случае дочерняя спецификация сохраняется супервизором (если он не является временным дочерним процессом), но несуществующий дочерний процесс игнорируется.</target>
        </trans-unit>
        <trans-unit id="a860e23df31c942b2bc0c3412b761a4dcef25730" translate="yes" xml:space="preserve">
          <source>The start function required by &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция запуска, необходимая для &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27f87c72bb318d024045b5c43b6afc31f6ec794d" translate="yes" xml:space="preserve">
          <source>The start function should use the &lt;code&gt;Host-IP-Address&lt;/code&gt; list in &lt;code&gt;Svc&lt;/code&gt; and/or &lt;code&gt;Config&lt;/code&gt; to select and return an appropriate list of local IP addresses. In the connecting case, the local address list can instead be communicated in a &lt;code&gt;connected&lt;/code&gt; message (see &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; below) following connection establishment. In either case, the local address list is used to populate &lt;code&gt;Host-IP-Address&lt;/code&gt; AVPs in outgoing capabilities exchange messages if &lt;code&gt;Host-IP-Address&lt;/code&gt; is unspecified.</source>
          <target state="translated">Функция запуска должна использовать список &lt;code&gt;Host-IP-Address&lt;/code&gt; в &lt;code&gt;Svc&lt;/code&gt; и / или &lt;code&gt;Config&lt;/code&gt; для выбора и возврата соответствующего списка локальных IP-адресов. В случае подключения список локальных адресов может вместо этого передаваться в &lt;code&gt;connected&lt;/code&gt; сообщении (см. &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; ниже) после установления подключения. В любом случае список локальных адресов используется для заполнения AVP &lt;code&gt;Host-IP-Address&lt;/code&gt; в исходящих сообщениях обмена возможностями, если &lt;code&gt;Host-IP-Address&lt;/code&gt; не указан.</target>
        </trans-unit>
        <trans-unit id="b96af49834b8af2976c21508cd71a9002ce8721b" translate="yes" xml:space="preserve">
          <source>The start of a sequence of fragmented messages looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cef6600c64628b5df747acb2766fd1cbe1d3b19" translate="yes" xml:space="preserve">
          <source>The start phases are defined by the application specification key &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt;. For included applications, the set of phases must be a subset of the set of phases defined for the including application.</source>
          <target state="translated">Фазы запуска определяются ключом спецификации приложения &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt; . Для включенных приложений набор фаз должен быть подмножеством набора фаз, определенных для включаемого приложения.</target>
        </trans-unit>
        <trans-unit id="7acb8d9625f3baf5a2f8a4a89f3e914252275eb8" translate="yes" xml:space="preserve">
          <source>The start program must call &lt;code&gt;run_erl&lt;/code&gt; as shown below. It must also take an optional parameter, which defaults to &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">Программа запуска должна вызывать &lt;code&gt;run_erl&lt;/code&gt; , как показано ниже. Он также должен принимать необязательный параметр, который по умолчанию имеет значение &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d982b4c5fe8008df5043a1839f9425b5cc9bde4b" translate="yes" xml:space="preserve">
          <source>The starting distribution header is very similar to a non-fragmented distribution header. The atom cache works the same as for normal distribution header and is the same for the entire sequence. The additional fields added are the sequence id and fragment id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dadcd9880753a230e08e39eb7ab7929eb5a6e0c2" translate="yes" xml:space="preserve">
          <source>The startup procedure for a set of Mnesia nodes is a fairly complicated operation. A Mnesia system consists of a set of nodes, with Mnesia started locally on all participating nodes. Normally, each node has a directory where all the Mnesia files are written. This directory is referred to as the Mnesia directory. Mnesia can also be started on disc-less nodes. For more information about disc-less nodes, see &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">Процедура запуска набора узлов Mnesia - довольно сложная операция. Система Mnesia состоит из набора узлов, при этом Mnesia запускается локально на всех участвующих узлах. Обычно у каждого узла есть каталог, в который записаны все файлы Mnesia. Этот каталог называется каталогом Mnesia. Mnesia также можно запустить на бездисковых узлах. Для получения дополнительной информации о &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; узлах см. Mnesia: create_schema / 1 и Руководство пользователя.</target>
        </trans-unit>
        <trans-unit id="9ec6e88891409b6ff8f9a27843da0963ec7c3164" translate="yes" xml:space="preserve">
          <source>The state can be any term and the callback function &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; is used for all states.</source>
          <target state="translated">Состояние может быть любым, а функция обратного вызова &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; используется для всех состояний.</target>
        </trans-unit>
        <trans-unit id="f731d5aeffad554f9b59f5b6251d4203c254e6c3" translate="yes" xml:space="preserve">
          <source>The state is either the name of the function itself or an argument to it. The other arguments are the &lt;code&gt;EventType&lt;/code&gt; and the event dependent &lt;code&gt;EventContent&lt;/code&gt;, both described in section &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt;Event Types and Event Content&lt;/a&gt;&lt;/code&gt;, and the current server &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f821816af50887b3f025a4e6599280206657b6" translate="yes" xml:space="preserve">
          <source>The state is either the name of the function itself or an argument to it. The other arguments are the &lt;code&gt;EventType&lt;/code&gt; described in section &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt;, the event dependent &lt;code&gt;EventContent&lt;/code&gt;, and the current server &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">Состояние - это либо имя самой функции, либо ее аргумент. Другими аргументами являются &lt;code&gt;EventType&lt;/code&gt; , описанный в разделе &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt; событий, &lt;code&gt;EventContent&lt;/code&gt; , зависящий от события , и текущие &lt;code&gt;Data&lt;/code&gt; сервера .</target>
        </trans-unit>
        <trans-unit id="9426ff2ed56deac331065c555f73deceea5d2d1f" translate="yes" xml:space="preserve">
          <source>The state must be of type &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; and one callback function per state, that is, &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;, is used.</source>
          <target state="translated">Состояние должно иметь тип &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; и используется одна функция обратного вызова для каждого состояния, то есть &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d13d42182a76700706e21237d549fc59709fd9b9" translate="yes" xml:space="preserve">
          <source>The state of the handler.</source>
          <target state="translated">Состояние куратора.</target>
        </trans-unit>
        <trans-unit id="15825c6d947625e874b105c1baf6a684fccb64cc" translate="yes" xml:space="preserve">
          <source>The state of the process. This can be one of the following:</source>
          <target state="translated">Состояние процесса.Это может быть одно из следующих:</target>
        </trans-unit>
        <trans-unit id="289e59e1fe9a8e03ffb9d797627caef032453480" translate="yes" xml:space="preserve">
          <source>The state returned from each call of &lt;code&gt;Function&lt;/code&gt; is passed to the next call, even if the next call is to format a message from another log file.</source>
          <target state="translated">Состояние, возвращаемое при каждом вызове &lt;code&gt;Function&lt;/code&gt; , передается следующему вызову, даже если следующий вызов предназначен для форматирования сообщения из другого файла журнала.</target>
        </trans-unit>
        <trans-unit id="dd050ef7cc16c451eba6404d640a1ee02e6c6b42" translate="yes" xml:space="preserve">
          <source>The state returned from this function can not be used to get a reproducable random sequence as from the other &lt;code&gt;rand&lt;/code&gt; functions, since reproducability does not match cryptographically safe.</source>
          <target state="translated">Состояние, возвращаемое этой функцией, не может использоваться для получения воспроизводимой случайной последовательности, как из других функций &lt;code&gt;rand&lt;/code&gt; , поскольку воспроизводимость не соответствует криптографически безопасной.</target>
        </trans-unit>
        <trans-unit id="be5d6f18be3b614032f33a0c6531accfee883ec3" translate="yes" xml:space="preserve">
          <source>The state returned from this function cannot be used to get a reproducable random sequence as from the other &lt;code&gt;rand&lt;/code&gt; functions, since reproducability does not match cryptographically safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e921cfa26002be9bbe7c6ea7a1998649c34a25f8" translate="yes" xml:space="preserve">
          <source>The state specified when calling &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt; erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt;. The tracer state is an immutable value that is passed to &lt;code&gt;erl_tracer&lt;/code&gt; callbacks and is to contain all the data that is needed to generate the trace event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fae0626bf69d79a71c33c9da2c9ae7fb12888d7" translate="yes" xml:space="preserve">
          <source>The state specified when calling &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt;. The tracer state is an immutable value that is passed to &lt;code&gt;erl_tracer&lt;/code&gt; callbacks and is to contain all the data that is needed to generate the trace event.</source>
          <target state="translated">Состояние, указанное при вызове &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt; . Состояние трассировщика - это неизменное значение, которое передается в &lt;code&gt;erl_tracer&lt;/code&gt; вызовы erl_tracer и должно содержать все данные, необходимые для генерации события трассировки.</target>
        </trans-unit>
        <trans-unit id="1ab345b32e922b70cc7799981ef1e76b747d4f17" translate="yes" xml:space="preserve">
          <source>The state.</source>
          <target state="translated">Штат.</target>
        </trans-unit>
        <trans-unit id="43d74fe2df87f64ba71d3e82fa6cf8b2cdbfe68c" translate="yes" xml:space="preserve">
          <source>The status bar at the bottom of the window shows a warning if the currently loaded dump is truncated.</source>
          <target state="translated">В строке состояния в нижней части окна отображается предупреждение,если загруженный в данный момент дамп усечен.</target>
        </trans-unit>
        <trans-unit id="f7d04e6ac2947e96673758e3c7124714a10992b8" translate="yes" xml:space="preserve">
          <source>The status of a module can be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23fa2a9a44b4e044dab676b8f152e4bf3708f35" translate="yes" xml:space="preserve">
          <source>The status of a request. Coresponds to the &lt;code&gt;SSH_MSG_CHANNEL_SUCCESS&lt;/code&gt; and &lt;code&gt;SSH_MSG_CHANNEL_FAILURE&lt;/code&gt; values in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.4&quot;&gt;RFC 4254, Section 5.4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb7334448d68c19546b3da05bde0756339f62d8" translate="yes" xml:space="preserve">
          <source>The status of a subgroup can be returned (&lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;failed&lt;/code&gt;), to affect the execution of the group on the level above. This is accomplished by, in &lt;code&gt;end_per_group/2&lt;/code&gt;, looking up the value of &lt;code&gt;tc_group_properties&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; list and checking the result of the test cases in the group. If status &lt;code&gt;failed&lt;/code&gt; is to be returned from the group as a result, &lt;code&gt;end_per_group/2&lt;/code&gt; is to return the value &lt;code&gt;{return_group_result,failed}&lt;/code&gt;. The status of a subgroup is taken into account by &lt;code&gt;Common Test&lt;/code&gt; when evaluating if execution of a group is to be repeated or not (unless the basic &lt;code&gt;repeat&lt;/code&gt; property is used).</source>
          <target state="translated">Статус подгруппы может быть возвращен ( &lt;code&gt;ok&lt;/code&gt; или &lt;code&gt;failed&lt;/code&gt; ), чтобы повлиять на выполнение группы на уровне выше. Это достигается путем &lt;code&gt;end_per_group/2&lt;/code&gt; в end_per_group / 2 значения &lt;code&gt;tc_group_properties&lt;/code&gt; в списке &lt;code&gt;Config&lt;/code&gt; и проверки результата тестовых случаев в группе. Если в результате из группы должен быть возвращен статус &amp;laquo;Не &lt;code&gt;failed&lt;/code&gt; , &lt;code&gt;end_per_group/2&lt;/code&gt; должен вернуть значение &lt;code&gt;{return_group_result,failed}&lt;/code&gt; . Состояние подгруппы учитывается &lt;code&gt;Common Test&lt;/code&gt; при оценке того, должно ли выполнение группы повторяться или нет (если не используется базовое свойство &lt;code&gt;repeat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b85c37fec76de27c56e3406adaafa6e8b1d27921" translate="yes" xml:space="preserve">
          <source>The status of a test case explicitly skipped in any of the ways described in section &lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Статус тестового примера явно пропущен любым из способов, описанных в разделе &lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96f8f991cb18b753714d9a9e860678595a4a90ad" translate="yes" xml:space="preserve">
          <source>The status value for a nested subgroup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae5f35d675d1272e78fb3eaf4d81a316518f52b" translate="yes" xml:space="preserve">
          <source>The step functionality can be used together with flag/option &lt;code&gt;suite&lt;/code&gt; and &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt;, but not together with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">Функциональность шага может использоваться вместе с &lt;code&gt;suite&lt;/code&gt; флагов / опций и &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt; , но не вместе с &lt;code&gt;dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23a47861a1df8e95627b42341a8487a2338f8876" translate="yes" xml:space="preserve">
          <source>The stop callback was called directly by &lt;code&gt;enif_select&lt;/code&gt;.</source>
          <target state="translated">Обратный вызов остановки был вызван непосредственно &lt;code&gt;enif_select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eff8dcd2a113b22b62950f59f611b3549632ee05" translate="yes" xml:space="preserve">
          <source>The stop callback was scheduled to run on some other thread or later by this thread.</source>
          <target state="translated">Обратный вызов стопа был запланирован на другой поток или позже этим потоком.</target>
        </trans-unit>
        <trans-unit id="6eb9b8c23b1b206be09c84ebb2950996bdcd33b8" translate="yes" xml:space="preserve">
          <source>The storage engine must call &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; and &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt;. See the OpenSSL cryptolib's &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Механизм хранения должен вызывать &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; и &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt; . См. &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt; OpenSSL cryptolib .</target>
        </trans-unit>
        <trans-unit id="1f1ee5838e32832bdcc704cd56398a34eb2a5f6f" translate="yes" xml:space="preserve">
          <source>The storage type is preserved. For example, a RAM table moved from one node remains a RAM on the new node. Other transactions can still read and write in the table while it is being moved.</source>
          <target state="translated">Сохраняется тип хранилища.Например,таблица оперативной памяти,перемещаемая из одного узла,остается оперативной памятью на новом узле.Остальные транзакции могут читать и записывать в таблицу во время ее перемещения.</target>
        </trans-unit>
        <trans-unit id="29dd2c34d1090a0d800c2e247d0fc176342cf1f0" translate="yes" xml:space="preserve">
          <source>The stored events are inserted in the queue as the next to process before any already queued events. The order of these stored events is preserved, so the first &lt;code&gt;next_event&lt;/code&gt; in the containing list becomes the first to process.</source>
          <target state="translated">Сохраненные события вставляются в очередь как следующие для обработки перед любыми уже поставленными в очередь событиями. Порядок этих сохраненных событий сохраняется, поэтому первое &lt;code&gt;next_event&lt;/code&gt; в содержащем списке становится первым для обработки.</target>
        </trans-unit>
        <trans-unit id="c05a53cb68134dabc5d7bae05169ae1a11647b27" translate="yes" xml:space="preserve">
          <source>The stream hasn't been initialized, eg. if &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; wasn't called prior to a call to &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поток не был инициализирован, например. если &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; не был вызван до вызова &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a185e0a14d968eac368fafa4955a9485714c6b7e" translate="yes" xml:space="preserve">
          <source>The stream was used by a process that doesn't control it. Use &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt; set_controlling_process/2&lt;/a&gt;&lt;/code&gt; if you need to transfer a stream to a different process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6455104e94ea1d2cc707927b01ebea3a44bfd27f" translate="yes" xml:space="preserve">
          <source>The stream was used by a process that doesn't control it. Use &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; if you need to transfer a stream to a different process.</source>
          <target state="translated">Поток был использован процессом, который его не контролирует. Используйте &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; , если вам нужно передать поток другому процессу.</target>
        </trans-unit>
        <trans-unit id="9e2fdb4e651b9aa41fcc3bc6966fd38ca9895ed9" translate="yes" xml:space="preserve">
          <source>The string is copied to &lt;code&gt;p&lt;/code&gt;, and enough space must be allocated. The returned string is &lt;code&gt;NULL&lt;/code&gt;-terminated, so you must add an extra byte to the memory requirement.</source>
          <target state="translated">Строка копируется в &lt;code&gt;p&lt;/code&gt; , и должно быть выделено достаточно места. Возвращаемая строка завершается &lt;code&gt;NULL&lt;/code&gt; , поэтому вы должны добавить дополнительный байт к требованию памяти.</target>
        </trans-unit>
        <trans-unit id="68785b1bbdb54c599efe5a2a41d523ae7b013997" translate="yes" xml:space="preserve">
          <source>The string length of &quot;&amp;szlig;&amp;uarr;e̊&quot; is 3, even though it is represented by the codepoints &lt;code&gt;[223,8593,101,778]&lt;/code&gt; or the UTF-8 binary &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Длина строки &amp;laquo;&amp;szlig; &amp;uarr; e̊&amp;raquo; равна 3, даже если она представлена &lt;code&gt;[223,8593,101,778]&lt;/code&gt; или двоичным &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt; UTF-8 &amp;lt;&amp;lt; 195,159,226,134,145,101,204,138 &amp;gt;&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="4cf40fddbed63f7ac0d755d714db5efcb0dab3f9" translate="yes" xml:space="preserve">
          <source>The string the daemon will present to a connecting peer initially. The default value is &quot;Erlang/VSN&quot; where VSN is the ssh application version number.</source>
          <target state="translated">Строка,которую демон первоначально представит соединяющемуся коллеге.Значением по умолчанию является &quot;Erlang/VSN&quot;,где VSN-номер версии ssh приложения.</target>
        </trans-unit>
        <trans-unit id="36753c090f707fe68109d16ad9e5e9da7b79ac27" translate="yes" xml:space="preserve">
          <source>The string was read, but more input is needed to complete the original format string. &lt;code&gt;RestFormat&lt;/code&gt; is the remaining format string, &lt;code&gt;Nchars&lt;/code&gt; is the number of characters scanned, and &lt;code&gt;InputStack&lt;/code&gt; is the reversed list of inputs matched up to that point.</source>
          <target state="translated">Строка была прочитана, но для завершения строки исходного формата требуется дополнительный ввод. &lt;code&gt;RestFormat&lt;/code&gt; - это оставшаяся строка формата, &lt;code&gt;Nchars&lt;/code&gt; - количество отсканированных символов, а &lt;code&gt;InputStack&lt;/code&gt; - это перевернутый список входных данных, сопоставленных до этой точки.</target>
        </trans-unit>
        <trans-unit id="6cf01db782c53881c8e9b381ef1af37e91bea8ec" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the input characters not used.</source>
          <target state="translated">Строка была прочитана. &lt;code&gt;InputList&lt;/code&gt; - это список успешно сопоставленных и прочитанных элементов, а &lt;code&gt;LeftOverChars&lt;/code&gt; - входные символы, которые не используются.</target>
        </trans-unit>
        <trans-unit id="45cb7749daf0319866610d1f7a6f2fda868e24e9" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the remaining characters.</source>
          <target state="translated">Строка была прочитана. &lt;code&gt;InputList&lt;/code&gt; - это список успешно сопоставленных и прочитанных элементов, а &lt;code&gt;LeftOverChars&lt;/code&gt; - оставшиеся символы.</target>
        </trans-unit>
        <trans-unit id="7023fc710fcbee2ee1b2d0076f2bbb73fe92a4c8" translate="yes" xml:space="preserve">
          <source>The structure defines six tables in the database. In &lt;code&gt;Mnesia&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates tables. &lt;code&gt;Name&lt;/code&gt; is the table name.</source>
          <target state="translated">Структура определяет шесть таблиц в базе данных. В &lt;code&gt;Mnesia&lt;/code&gt; функция &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; создает таблицы. &lt;code&gt;Name&lt;/code&gt; - это имя таблицы.</target>
        </trans-unit>
        <trans-unit id="39d9e3d6533e72d537d969467d83db3f839ba80c" translate="yes" xml:space="preserve">
          <source>The structured types of ASN.1 are constructed from other types in a manner similar to the concepts of array and struct in C.</source>
          <target state="translated">Структурные типы ASN.1 построены из других типов таким же образом,как и понятия массива и структурирования в С.</target>
        </trans-unit>
        <trans-unit id="3d28e19e96e7591f2c1e234739ca3d285e1425a0" translate="yes" xml:space="preserve">
          <source>The structured types previously described can have other named types as their components. The general syntax to assign a value to component &lt;code&gt;C&lt;/code&gt; of a named ASN.1 type &lt;code&gt;T&lt;/code&gt; in Erlang is the record syntax &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt;. Here &lt;code&gt;Value&lt;/code&gt; can be a value of yet another type &lt;code&gt;T2&lt;/code&gt;, for example:</source>
          <target state="translated">Описанные ранее структурированные типы могут иметь в качестве своих компонентов другие именованные типы. Общий синтаксис для присвоения значения компоненту &lt;code&gt;C&lt;/code&gt; именованного типа &lt;code&gt;T&lt;/code&gt; ASN.1 в Erlang - это синтаксис записи &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt; . Здесь &lt;code&gt;Value&lt;/code&gt; может быть значением еще одного типа &lt;code&gt;T2&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="0fc0372505592d800b784db4902cf9621fae67f0" translate="yes" xml:space="preserve">
          <source>The subscribe functions activate a subscription of events. The events are delivered as messages to the process evaluating the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; The syntax is as follows:</source>
          <target state="translated">Функции подписки активируют подписку на события. События доставляются в виде сообщений процессу, оценивающему функцию &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; Синтаксис следующий:</target>
        </trans-unit>
        <trans-unit id="c6fc9553c48dee56909efc052afcae5e3f5e6f87" translate="yes" xml:space="preserve">
          <source>The subset of calls from any of the vertices.</source>
          <target state="translated">Подмножество вызовов из любой вершины.</target>
        </trans-unit>
        <trans-unit id="5f5b8c212a6fee019c36df2950bd77268424ff70" translate="yes" xml:space="preserve">
          <source>The subset of calls to and from any of the vertices. For all sets of calls &lt;code&gt;CS&lt;/code&gt; and all sets of vertices &lt;code&gt;VS&lt;/code&gt;, &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; is equivalent to &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt;.</source>
          <target state="translated">Подмножество обращений к любой из вершин и от них. Для всех наборов вызовов &lt;code&gt;CS&lt;/code&gt; и всех наборов вершин &lt;code&gt;VS&lt;/code&gt; , &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; эквивалентно &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5085549ad982bc38493bd15cfb61ace15049e68" translate="yes" xml:space="preserve">
          <source>The subset of calls to any of the vertices.</source>
          <target state="translated">Подмножество вызовов любой из вершин.</target>
        </trans-unit>
        <trans-unit id="3cacc7a2a8051e8a0c0ddaf8749a37e9f9e9ee95" translate="yes" xml:space="preserve">
          <source>The subsystem can be run on the host &lt;strong&gt;tarlop&lt;/strong&gt; with the generated keys, as described in Section &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt; Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe87376a37704db2bf21986e270c17fe93f1cb0" translate="yes" xml:space="preserve">
          <source>The subsystem can be run on the host &lt;strong&gt;tarlop&lt;/strong&gt; with the generated keys, as described in Section &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Подсистема может быть запущена на &lt;strong&gt;tarlop&lt;/strong&gt; хоста с сгенерированными ключами, как описано в Разделе &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e7163b547fafca1e1a01c6c85101dafd95545463" translate="yes" xml:space="preserve">
          <source>The subtype constraint (&lt;code&gt;CONTAINING&lt;/code&gt;/&lt;code&gt;ENCODED BY&lt;/code&gt;) to constrain the content of an octet string or a bit string is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">Ограничение подтипа ( &lt;code&gt;CONTAINING&lt;/code&gt; / , &lt;code&gt;ENCODED BY&lt;/code&gt; ) , чтобы ограничить содержание строки октетов или строки бит обрабатываются при компиляции, но никаких дальнейших действий не предпринимаются. Это ограничение не является видимым для PER.</target>
        </trans-unit>
        <trans-unit id="996c8474dfc5442a02a67e994d403bba3cebf442" translate="yes" xml:space="preserve">
          <source>The subtype constraint by regular expressions (&lt;code&gt;PATTERN&lt;/code&gt;) for character string types is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">Ограничение подтипа регулярными выражениями ( &lt;code&gt;PATTERN&lt;/code&gt; ) для типов символьных строк анализируется при компиляции, но никаких дальнейших действий не предпринимается. Это ограничение не является видимым для PER.</target>
        </trans-unit>
        <trans-unit id="449b6a9e34717e9034f068e9ddd7557ac6068822" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;FuncCallCount&lt;/code&gt; values for all functions in module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">Сумма значений &lt;code&gt;FuncCallCount&lt;/code&gt; для всех функций в модуле &lt;code&gt;Mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3234d4076f0843a2b33750a12acc0b2c6ea1ad8f" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;ModCallCount&lt;/code&gt; values for all modules concerned in &lt;code&gt;ModAnalysisList&lt;/code&gt;.</source>
          <target state="translated">Сумма значений &lt;code&gt;ModCallCount&lt;/code&gt; для всех модулей, &lt;code&gt;ModAnalysisList&lt;/code&gt; в ModAnalysisList .</target>
        </trans-unit>
        <trans-unit id="a7d6e1d3697888bda0178100688b0ec34a104aff" translate="yes" xml:space="preserve">
          <source>The sum of all memory categories.</source>
          <target state="translated">Сумма всех категорий памяти.</target>
        </trans-unit>
        <trans-unit id="ff0037c4e027cabbd2193a3640bbe8630c8ea4e3" translate="yes" xml:space="preserve">
          <source>The sum of all off-heap binaries allocated.</source>
          <target state="translated">Сумма всех выделенных двоичных файлов.</target>
        </trans-unit>
        <trans-unit id="b154828ab69194ef3277c5a0a09ca37fe5a5d84e" translate="yes" xml:space="preserve">
          <source>The sum of all process memory used.</source>
          <target state="translated">Сумма всей используемой памяти процесса.</target>
        </trans-unit>
        <trans-unit id="caa888756fcb43497a5008a81fd1856a0639ea65" translate="yes" xml:space="preserve">
          <source>The super carrier feature was introduced in OTP R16B03. It is enabled with command line option +MMscs &amp;lt;size in Mb&amp;gt; and can be configured with other options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0c117fe89fdcf6ec7fbdc8b7f9539c319a847f" translate="yes" xml:space="preserve">
          <source>The super carrier thus contains two areas. One area for MBCs growing from the bottom and up. And one area for SBCs growing from the top and down. Like a process with a heap and a stack growing towards each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dab01c88ded1b7b32e51ef73e1252818de000b" translate="yes" xml:space="preserve">
          <source>The supervision tree is a hierarchical arrangement of code into supervisors and workers, which makes it possible to design and program fault-tolerant software.</source>
          <target state="translated">Дерево контроля-это иерархическое расположение кода на супервайзеров и сотрудников,которое позволяет проектировать и программировать отказоустойчивое программное обеспечение.</target>
        </trans-unit>
        <trans-unit id="2b52420c5f524763cf64a935f578714dd96d159c" translate="yes" xml:space="preserve">
          <source>The supervisor behaviour supports changing the internal state, that is, changing the restart strategy and maximum restart frequency properties, as well as changing the existing child specifications.</source>
          <target state="translated">Поведение супервайзера поддерживает изменение внутреннего состояния,т.е.изменение стратегии перезапуска и свойств максимальной частоты перезапуска,а также изменение существующих спецификаций ребенка.</target>
        </trans-unit>
        <trans-unit id="cffb4f2e0dfb75d9604922d437c1a8dd8826e6a0" translate="yes" xml:space="preserve">
          <source>The supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it must keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">Супервайзер отвечает за запуск,остановку и мониторинг процессов,происходящих с детьми.Основная идея супервайзера заключается в том,что он должен поддерживать процессы своего ребенка,перезапуская их,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="768e22d6442b06516d91f5426c41a68d034c3f04" translate="yes" xml:space="preserve">
          <source>The supervisor must be registered as &lt;code&gt;ch_sup&lt;/code&gt; for the script to work. If the supervisor is not registered, it cannot be accessed directly from the script. Instead a help function that finds the pid of the supervisor and calls &lt;code&gt;supervisor:restart_child&lt;/code&gt;, and so on, must be written. This function is then to be called from the script using the &lt;code&gt;apply&lt;/code&gt; instruction.</source>
          <target state="translated">Для работы сценария супервизор должен быть зарегистрирован как &lt;code&gt;ch_sup&lt;/code&gt; . Если супервизор не зарегистрирован, к нему нельзя получить доступ непосредственно из сценария. Вместо этого должна быть написана функция справки, которая находит pid супервизора и вызывает &lt;code&gt;supervisor:restart_child&lt;/code&gt; и так далее. Затем эта функция должна быть вызвана из сценария с помощью инструкции &lt;code&gt;apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd784bb324ef894ad782bd6fc54c8cbffbd00c9c" translate="yes" xml:space="preserve">
          <source>The supervisor properties are defined by the supervisor flags. The type definition for the supervisor flags is as follows:</source>
          <target state="translated">Свойства супервизора определяются флагами супервизора.Определение типа для флагов супервизора следующее:</target>
        </trans-unit>
        <trans-unit id="445d5aae8f507ca020cd700c1e982027b7aa04d5" translate="yes" xml:space="preserve">
          <source>The supervisor then starts all its child processes according to the child specifications in the start specification. In this case there is one child process, &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">Затем супервизор запускает все свои дочерние процессы в соответствии с дочерними спецификациями в стартовой спецификации. В этом случае есть один дочерний процесс &lt;code&gt;ch3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1ea33c0638456c050fb5c1069b48715bb9e4c7a" translate="yes" xml:space="preserve">
          <source>The supervisor tree of an included application is started as part of the supervisor tree of the including application. If there is a need for synchronization between processes in the including and included applications, this can be achieved by using &lt;strong&gt;start phases&lt;/strong&gt;.</source>
          <target state="translated">Дерево супервизора включаемого приложения запускается как часть дерева супервизора включаемого приложения. Если есть необходимость в синхронизации между процессами во включаемом и включенном приложениях, это может быть достигнуто с помощью &lt;strong&gt;фаз запуска&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a588b6125bf699dd160cdf7a903456eed3b8cbe9" translate="yes" xml:space="preserve">
          <source>The supervisors have a built-in mechanism to limit the number of restarts which can occur in a given time interval. This is specified by the two keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="translated">У супервизоров есть встроенный механизм для ограничения количества перезапусков, которые могут произойти в заданный интервал времени. Это определяется &lt;code&gt;intensity&lt;/code&gt; двух клавиш и &lt;code&gt;period&lt;/code&gt; в карте флагов супервизора, возвращаемой функцией обратного вызова &lt;code&gt;init&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b2633e4167b1433781a2f1a62c27832d676f8d6" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;Reason&lt;/code&gt; becomes the exit reason for the server process. Default Any &lt;code&gt;Reason&lt;/code&gt; other than &lt;code&gt;kill&lt;/code&gt; sends a request to the server and waits for it to clean up, reply and exit. If &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;kill&lt;/code&gt;, the server is bluntly killed.</source>
          <target state="translated">Указанная &lt;code&gt;Reason&lt;/code&gt; становится причиной выхода для серверного процесса. По умолчанию Любая &lt;code&gt;Reason&lt;/code&gt; кроме &lt;code&gt;kill&lt;/code&gt; , отправляет запрос на сервер и ожидает его очистки, ответа и выхода. Если &lt;code&gt;Reason&lt;/code&gt; - &lt;code&gt;kill&lt;/code&gt; , сервер просто убивается.</target>
        </trans-unit>
        <trans-unit id="96f30a73bfb2b83438049030688c67e96198fa91" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. It is released before it is ready to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release.</source>
          <target state="translated">Поддержка загрузки кода из архивных файлов является экспериментальной.Он выпускается до того,как будет готов к ранней обратной связи.Формат файла,семантика,интерфейсы и т.д.могут быть изменены в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="7908060a0b898a45469fbc25ab16112e1c77d124" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. The purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The function &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; and flag &lt;code&gt;-code_path_choice&lt;/code&gt; are also experimental.</source>
          <target state="translated">Поддержка загрузки кода из архивных файлов экспериментальная. Целью его выпуска до того, как он будет готов, является получение ранней обратной связи. Формат файла, семантика, интерфейсы и т. Д. Могут быть изменены в будущих версиях. Функция &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; и флаг &lt;code&gt;-code_path_choice&lt;/code&gt; также являются экспериментальными.</target>
        </trans-unit>
        <trans-unit id="0fc1d82ce90810c32581e8a0920c335e0c517632" translate="yes" xml:space="preserve">
          <source>The support for loading of code from archive files is experimental. The only purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The &lt;code&gt;-code_path_choice&lt;/code&gt; flag is also experimental.</source>
          <target state="translated">Поддержка загрузки кода из архивных файлов экспериментальная. Единственная цель выпустить его до того, как он будет готов, - это получить раннюю обратную связь. Формат файла, семантика, интерфейсы и т. Д. Могут быть изменены в будущих версиях. &lt;code&gt;-code_path_choice&lt;/code&gt; флаг также экспериментальный.</target>
        </trans-unit>
        <trans-unit id="e2394cc20beed2954b20caec09868b8789fdcf8c" translate="yes" xml:space="preserve">
          <source>The support for sequential tracing provided by Trace Tool Builder includes the following:</source>
          <target state="translated">Поддержка последовательной трассировки,предоставляемая Trace Tool Builder,включает в себя следующее:</target>
        </trans-unit>
        <trans-unit id="6228d25d9b25f4927da788e40437ce4f4ff23407" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;'-&amp;gt;'&lt;/code&gt;, and &lt;code&gt;':'&lt;/code&gt; have to be treated in a special way, as they are meta symbols of the grammar notation, as well as terminal symbols of the Yecc grammar.</source>
          <target state="translated">К символам &lt;code&gt;'-&amp;gt;'&lt;/code&gt; и &lt;code&gt;':'&lt;/code&gt; следует относиться особым образом, поскольку они являются метасимволами грамматической записи, а также терминальными символами грамматики Yecc.</target>
        </trans-unit>
        <trans-unit id="b5b1fca95a16b28d8128e58b5512a0179363f6cf" translate="yes" xml:space="preserve">
          <source>The symbols in front of the application names are intended to describe the status of the application. There are error and warning symbols to signalize that there is something which needs attention. The tick symbol means that the application is included or derived and no problem has been detected. The cross symbol means that the application is excluded or available and no problem has been detected. Applications with error symbols are listed first in each category and are followed by the warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">Символы перед названиями заявок предназначены для описания статуса заявки.Имеются символы ошибок и предупреждений,сигнализирующие о том,что есть что-то,что требует внимания.Тиковый символ означает,что приложение включено или получено,и проблема не обнаружена.Крестиковый символ означает,что приложение исключено или доступно,и проблема не обнаружена.Приложения с символами ошибок перечислены первыми в каждой категории,за ними следуют предупреждения и обычные (галочки и крестики)в конце.</target>
        </trans-unit>
        <trans-unit id="4ff1d477dc7a2e1cb7c0f348638a12a2059b2005" translate="yes" xml:space="preserve">
          <source>The symbols in front of the module names are intended to describe the status of the module. There are error and and warning symbols to signalize that there is something that needs attention. The tick symbol means that the module is included or derived and no problem has been detected. The cross symbol means that the module is excluded or available and no problem has been detected. Modules with error symbols are listed first in each category and are followed by warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">Символы перед названиями модулей предназначены для описания состояния модуля.Имеются символы ошибок и предупреждений,сигнализирующие о том,что есть что-то,что требует внимания.Тиковый символ означает,что модуль включен или производен,и проблема не обнаружена.Крестиковый символ означает,что модуль исключен или доступен,и проблема не обнаружена.Модули с символами ошибок перечислены первыми в каждой категории,за ними следуют предупреждения,а в конце-обычные (тики и крестики).</target>
        </trans-unit>
        <trans-unit id="9cf67be71d81d661199fd8c3ef66c9bc2a23e743" translate="yes" xml:space="preserve">
          <source>The synchronous request &lt;code&gt;alloc()&lt;/code&gt; is implemented using &lt;code&gt;gen_server:call/2&lt;/code&gt;:</source>
          <target state="translated">Синхронный запрос &lt;code&gt;alloc()&lt;/code&gt; реализуется с помощью &lt;code&gt;gen_server:call/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="63eb54580b86c06f3268ea4e7b5bcac96de253d8" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of the regular expressions supported by PCRE are described in detail in the following sections. Perl's regular expressions are described in its own documentation, and regular expressions in general are covered in many books, some with copious examples. Jeffrey Friedl's &quot;Mastering Regular Expressions&quot;, published by O'Reilly, covers regular expressions in great detail. This description of the PCRE regular expressions is intended as reference material.</source>
          <target state="translated">Синтаксис и семантика регулярных выражений,поддерживаемых PCRE,подробно описаны в следующих разделах.Регулярные выражения Perl описаны в собственной документации,а регулярные выражения в целом освещены во многих книгах,некоторые из которых содержат множество примеров.В книге Джеффри Фридла &quot;Освоение регулярных выражений&quot;,изданной O'Reilly,регулярные выражения описаны очень подробно.Это описание регулярных выражений PCRE предназначено для использования в качестве справочного материала.</target>
        </trans-unit>
        <trans-unit id="d795ae62867dbcf3f58c156eb06c595d167b51ae" translate="yes" xml:space="preserve">
          <source>The syntax for an external generic instruction is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9bb02b3f5ad3403931d50bf02d3305e9416e42" translate="yes" xml:space="preserve">
          <source>The syntax for an internal generic instruction is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7e6289b406769100c4fe1cdd3bffd156db1884" translate="yes" xml:space="preserve">
          <source>The syntax highlighting can be activated from the Erlang menu. There are four different alternatives:</source>
          <target state="translated">Подсветка синтаксиса может быть активирована из меню Erlang.Существует четыре различных варианта:</target>
        </trans-unit>
        <trans-unit id="817a7b6234953ff285a5cf26b3d3913052cb1f96" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows (requires a list within the groups list):</source>
          <target state="translated">Синтаксис в оболочке Erlang следующий (требуется список внутри списка групп):</target>
        </trans-unit>
        <trans-unit id="c11a6d8aa6d68bd5c6fc23a6b8b784283b982fbc" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows:</source>
          <target state="translated">Синтаксис в оболочке Эрланга следующий:</target>
        </trans-unit>
        <trans-unit id="21b1becf4be6592870e0896862b9b302a4959623" translate="yes" xml:space="preserve">
          <source>The syntax of  &lt;strong id=&quot;variable&quot;&gt;variables&lt;/strong&gt; is simple:</source>
          <target state="translated">Синтаксис &lt;strong id=&quot;variable&quot;&gt;переменных&lt;/strong&gt; прост:</target>
        </trans-unit>
        <trans-unit id="f3c5861c6322d86304cb4290ee33a8caf450460f" translate="yes" xml:space="preserve">
          <source>The syntax of Erlang tokens allow the use of the full ISO-8859-1 (Latin-1) character set. This is noticeable in the following ways:</source>
          <target state="translated">Синтаксис маркеров Erlang позволяет использовать полный набор символов ISO-8859-1 (латинский-1).Это заметно следующим образом:</target>
        </trans-unit>
        <trans-unit id="094c638d5ce58e342260cad1fbc3fff0f35b6a88" translate="yes" xml:space="preserve">
          <source>The syntax of each file is similar to C code. In fact, most of the contents &lt;strong&gt;is&lt;/strong&gt; C code, interspersed with macro invocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8d5f699e53e1bdc1770774109fbc1b5599f479" translate="yes" xml:space="preserve">
          <source>The system call failed to add the event object to the poll set.</source>
          <target state="translated">Системный вызов не смог добавить объект события в набор для опроса.</target>
        </trans-unit>
        <trans-unit id="401fca03bc6c302beb7da6e4fb8eca70f288ed7b" translate="yes" xml:space="preserve">
          <source>The system can become inconsistent as a result of a power failure. The UNIX feature &lt;code&gt;fsck&lt;/code&gt; can possibly repair the file system, but there is no guarantee that the file content is consistent.</source>
          <target state="translated">Система может выйти из строя в результате отключения электроэнергии. Функция &lt;code&gt;fsck&lt;/code&gt; в UNIX, возможно, может восстановить файловую систему, но нет гарантии, что содержимое файла согласовано.</target>
        </trans-unit>
        <trans-unit id="11ac012ee2a6049d1c81dbfe5e5bcc868023bccc" translate="yes" xml:space="preserve">
          <source>The system configuration files for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;cp3@cave&lt;/code&gt; are identical, except for the list of mandatory nodes, which is to be &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; for &lt;code&gt;cp3@cave&lt;/code&gt;.</source>
          <target state="translated">Файлы конфигурации системы для &lt;code&gt;cp2@cave&lt;/code&gt; и &lt;code&gt;cp3@cave&lt;/code&gt; идентичны, за исключением списка обязательных узлов, который должен быть &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; для &lt;code&gt;cp2@cave&lt;/code&gt; и &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; для &lt;code&gt;cp3@cave&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a86df323fb5ec0c1b444523d82be4cff548c59" translate="yes" xml:space="preserve">
          <source>The system configuration is to be called &lt;code&gt;Name.config&lt;/code&gt; and Erlang is to be started with the command-line argument &lt;code&gt;-config Name&lt;/code&gt;. For details, see the &lt;code&gt;config(4)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">Системная конфигурация должна называться &lt;code&gt;Name.config&lt;/code&gt; , а Erlang запускаться с аргументом командной строки &lt;code&gt;-config Name&lt;/code&gt; . Подробности смотрите на странице руководства &lt;code&gt;config(4)&lt;/code&gt; в Kernel.</target>
        </trans-unit>
        <trans-unit id="9f6cd0cc01a1dae027af31ac2b3320efd5d91c8a" translate="yes" xml:space="preserve">
          <source>The system events are as follows:</source>
          <target state="translated">Системные события выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="40222a7fb3caf074645df66a48dca922ad535e5b" translate="yes" xml:space="preserve">
          <source>The system has run out of memory. &amp;lt;A&amp;gt; is the allocator that failed to allocate memory, &amp;lt;N&amp;gt; is the number of bytes that &amp;lt;A&amp;gt; tried to allocate, and &amp;lt;T&amp;gt; is the memory block type that the memory was needed for. The most common case is that a process stores huge amounts of data. In this case &amp;lt;T&amp;gt; is most often &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;old_heap&lt;/code&gt;, &lt;code&gt;heap_frag&lt;/code&gt;, or &lt;code&gt;binary&lt;/code&gt;. For more information on allocators, see &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В системе закончилась память. &amp;lt;A&amp;gt; - это распределитель, которому не удалось выделить память, &amp;lt;N&amp;gt; - это количество байтов, которые &amp;lt;A&amp;gt; пытался выделить, а &amp;lt;T&amp;gt; - это тип блока памяти, для которого была необходима память. Чаще всего в процессе хранятся огромные объемы данных. В этом случае &amp;lt;T&amp;gt; чаще всего представляет собой &lt;code&gt;heap&lt;/code&gt; , &lt;code&gt;old_heap&lt;/code&gt; , &lt;code&gt;heap_frag&lt;/code&gt; или &lt;code&gt;binary&lt;/code&gt; . Для получения дополнительной информации о распределителях см. &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6876d9a2709d42d9bf8117946f6bf8730f5ef93a" translate="yes" xml:space="preserve">
          <source>The system information should be stored in a file called &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">Системная информация должна храниться в файле с именем &lt;code&gt;standard.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6783eebca0127687dc6f7166b232d99095419a8" translate="yes" xml:space="preserve">
          <source>The system is delivered as a Windows Installer executable. Get it from http://www.erlang.org/download.html</source>
          <target state="translated">Система поставляется в виде исполняемого файла Windows Installer.Получить ее можно на сайте http://www.erlang.org/download.html.</target>
        </trans-unit>
        <trans-unit id="eede666990492464e7d117dc5860f19affbbfd3e" translate="yes" xml:space="preserve">
          <source>The system is restarted &lt;strong&gt;inside&lt;/strong&gt; the running Erlang node, which means that the emulator is not restarted. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system is booted again in the same way as initially started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0ed26a1f271e06db89ef0fba3d2b075b59188d" translate="yes" xml:space="preserve">
          <source>The system is restarted &lt;strong&gt;inside&lt;/strong&gt; the running Erlang node, which means that the emulator is not restarted. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system is booted again in the same way as initially started. The same &lt;code&gt;BootArgs&lt;/code&gt; are used again.</source>
          <target state="translated">Система перезагружается &lt;strong&gt;внутри&lt;/strong&gt; работающего узла Erlang, что означает, что эмулятор не перезапускается. Все приложения плавно отключаются, весь код выгружается, и все порты закрываются перед повторной загрузкой системы таким же образом, как и при первоначальном запуске. &lt;code&gt;BootArgs&lt;/code&gt; используются те же самые BootArgs .</target>
        </trans-unit>
        <trans-unit id="92a035d0281caa4cfae8d815a43e248cd4f5e42d" translate="yes" xml:space="preserve">
          <source>The system keeps information about which versions are old and permanent in the files &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; and &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">Система хранит информацию о том, какие версии старые и постоянные, в файлах &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt; и $ ROOT / Release / start_erl.data .</target>
        </trans-unit>
        <trans-unit id="6da0e848ff2fa7a0109efc8207e6e2b2e7ad33b9" translate="yes" xml:space="preserve">
          <source>The system must be configured using only one system configuration file, called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">Система должна быть настроена с использованием только одного файла конфигурации системы, называемого &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="534f8510b4ab2486a116f82477cc86a51046615f" translate="yes" xml:space="preserve">
          <source>The system settings page is rather incomplete.</source>
          <target state="translated">Страница системных настроек является довольно неполной.</target>
        </trans-unit>
        <trans-unit id="b9d981657e3a5548cb7241507be1ea948d7f1448" translate="yes" xml:space="preserve">
          <source>The system tracer only receives those trace events that occur locally within the Erlang node. To get the whole picture of a sequential trace, involving processes on many Erlang nodes, the output from the system tracer on each involved node must be merged (offline).</source>
          <target state="translated">Системный трассировщик получает только те события трассировки,которые происходят локально в узле Erlang.Для получения полной картины последовательной трассы,включающей процессы на многих узлах Erlang,выходные данные системного трассировщика на каждом задействованном узле должны быть объединены (в автономном режиме).</target>
        </trans-unit>
        <trans-unit id="d708a25f112a938c386e67dff885572e579436bd" translate="yes" xml:space="preserve">
          <source>The system version of the node from which the dump originates</source>
          <target state="translated">Версия системы узла,с которого создается дамп</target>
        </trans-unit>
        <trans-unit id="bc82ebf34afcabbe0cf21d28525ebd613647d5a2" translate="yes" xml:space="preserve">
          <source>The system window consists of four main pages (tabs):</source>
          <target state="translated">Окно системы состоит из четырех основных страниц (вкладок):</target>
        </trans-unit>
        <trans-unit id="b7bde4446c570b77fe2a6f9c4779d3be956d8d0b" translate="yes" xml:space="preserve">
          <source>The system window is started with the function &lt;code&gt;reltool:start/1&lt;/code&gt;. At startup the tool will process all &lt;code&gt;beam&lt;/code&gt; files and &lt;code&gt;app&lt;/code&gt; files in order to find out dependencies between applications and their modules. Once all this information has been derived, it will be possible to explore the tool.</source>
          <target state="translated">Системное окно запускается функцией &lt;code&gt;reltool:start/1&lt;/code&gt; . При запуске инструмент обработает все файлы &lt;code&gt;beam&lt;/code&gt; файлы &lt;code&gt;app&lt;/code&gt; , чтобы определить зависимости между приложениями и их модулями. Как только вся эта информация будет получена, можно будет изучить инструмент.</target>
        </trans-unit>
        <trans-unit id="041698f829edd5b26d5d0d6979109c4827078e80" translate="yes" xml:space="preserve">
          <source>The system writes the crash dump in the current directory of the emulator or in the file pointed out by the environment variable (whatever that means on the current operating system) &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt;. For a crash dump to be written, a writable file system must be mounted.</source>
          <target state="translated">Система записывает аварийный дамп в текущий каталог эмулятора или в файл, указанный в переменной среды (что бы это ни значило в текущей операционной системе) &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt; . Для записи аварийного дампа должна быть смонтирована файловая система с возможностью записи.</target>
        </trans-unit>
        <trans-unit id="279b6ca3b37adc0893d23faefa9739dedcc3dbfa" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;Tab&lt;/code&gt; must have an index on position &lt;code&gt;Pos&lt;/code&gt;.</source>
          <target state="translated">Табличка &lt;code&gt;Tab&lt;/code&gt; должна иметь указатель на позиции &lt;code&gt;Pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc16fbae2468b67b551f7fca9afb369e0f25872" translate="yes" xml:space="preserve">
          <source>The table access rights.</source>
          <target state="translated">Права доступа к таблице.</target>
        </trans-unit>
        <trans-unit id="4c50c3a237a03f8cc2707518e27535b691ad5345" translate="yes" xml:space="preserve">
          <source>The table below summarizes the diameter application's compliance with RFC 6733. Since the diameter application isn't a Diameter node on its own, compliance is strictly the responsibility of the user in many cases, diameter providing the means for the user to be compliant rather than being compliant on its own.</source>
          <target state="translated">В таблице ниже приведены данные о соответствии диаметра приложения RFC 6733.Поскольку приложение диаметра само по себе не является узлом Diameter,во многих случаях ответственность за соответствие лежит исключительно на пользователе,а диаметр предоставляет пользователю средства для того,чтобы быть совместимым,а не для того,чтобы быть совместимым самому по себе.</target>
        </trans-unit>
        <trans-unit id="074dbae85c16822f44b3981f3ee41b05515202d3" translate="yes" xml:space="preserve">
          <source>The table contains a 64-bit atomic variable of the last identifier used. Only the least significant bits will be used when actually creating the identifier. This identifier is where the search begin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25afd1e5876ef9e8eeb6a3459a04948d4b88d14d" translate="yes" xml:space="preserve">
          <source>The table content is placed in a &lt;code&gt;.DCD&lt;/code&gt; file on the disc. When the &lt;code&gt;Mnesia&lt;/code&gt; system is started, the RAM table is initially loaded with data from its &lt;code&gt;.DCD&lt;/code&gt; file.</source>
          <target state="translated">Содержимое таблицы помещается в файл &lt;code&gt;.DCD&lt;/code&gt; на диске. Когда система &lt;code&gt;Mnesia&lt;/code&gt; запускается, в таблицу RAM изначально загружаются данные из ее файла &lt;code&gt;.DCD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0aa2d29620215b66b862b74a258da9f0952597" translate="yes" xml:space="preserve">
          <source>The table identifier.</source>
          <target state="translated">Идентификатор таблицы.</target>
        </trans-unit>
        <trans-unit id="d6e8f6600b6898b285183c9a2efcd8e9919e547e" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;bag&lt;/code&gt; table, which can have many objects, but only one instance of each object, per key.</source>
          <target state="translated">Таблица - это таблица &lt;code&gt;bag&lt;/code&gt; , которая может иметь много объектов, но только один экземпляр каждого объекта для каждого ключа.</target>
        </trans-unit>
        <trans-unit id="1326636cb8d9d2c6e8abd48a67ecc64dc60e8dbf" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;duplicate_bag&lt;/code&gt; table, which can have many objects, including multiple copies of the same object, per key.</source>
          <target state="translated">Таблица представляет собой таблицу &lt;code&gt;duplicate_bag&lt;/code&gt; , в которой может быть много объектов, включая несколько копий одного и того же объекта для каждого ключа.</target>
        </trans-unit>
        <trans-unit id="f70ade515d71247538e9584965be02630fd1a515" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;ordered_set&lt;/code&gt; table: one key, one object, ordered in Erlang term order, which is the order implied by the &amp;lt; and &amp;gt; operators. Tables of this type have a somewhat different behavior in some situations than tables of other types. Most notably, the &lt;code&gt;ordered_set&lt;/code&gt; tables regard keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt;, not only when they match. This means that to an &lt;code&gt;ordered_set&lt;/code&gt; table, &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; and &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; are regarded as equal. This also means that the key used to lookup an element not necessarily &lt;strong&gt;matches&lt;/strong&gt; the key in the returned elements, if &lt;code&gt;float()&lt;/code&gt;'s and &lt;code&gt;integer()&lt;/code&gt;'s are mixed in keys of a table.</source>
          <target state="translated">Таблица представляет собой таблицу &lt;code&gt;ordered_set&lt;/code&gt; : один ключ, один объект, упорядоченные в порядке терминов Erlang, который является порядком, подразумеваемым операторами &amp;lt;и&amp;gt;. Таблицы этого типа в некоторых ситуациях ведут себя несколько иначе, чем таблицы других типов. В частности, таблицы &lt;code&gt;ordered_set&lt;/code&gt; рассматривают ключи как равные, когда они &lt;strong&gt;сравниваются равными&lt;/strong&gt; , а не только когда они совпадают. Это означает, что для таблицы &lt;code&gt;ordered_set&lt;/code&gt; &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; считаются равными. Это также означает, что ключ, используемый для поиска элемента, не обязательно &lt;strong&gt;совпадает&lt;/strong&gt; с ключом в возвращаемых элементах, если &lt;code&gt;float()&lt;/code&gt; и &lt;code&gt;integer()&lt;/code&gt; смешаны в ключах таблицы.</target>
        </trans-unit>
        <trans-unit id="272d7513098b30b16e878b3eb48399c3327cbbea" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;set&lt;/code&gt; table: one key, one object, no order among objects. This is the default table type.</source>
          <target state="translated">Таблица представляет собой &lt;code&gt;set&lt;/code&gt; таблицу: один ключ, один объект, без порядка между объектами. Это тип таблицы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b9f8a5943e8075893eb3b3474ba785f08fed2473" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match/1&lt;/code&gt;.</source>
          <target state="translated">Таблица всегда должна быть защищена с помощью &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; перед вызовом &lt;code&gt;match/3&lt;/code&gt; , иначе при вызове &lt;code&gt;match/1&lt;/code&gt; могут возникнуть ошибки .</target>
        </trans-unit>
        <trans-unit id="9881ec6398c8615af13073d22ceceab6e1d017fd" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match_object/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match_object/1&lt;/code&gt;.</source>
          <target state="translated">Перед вызовом &lt;code&gt;match_object/3&lt;/code&gt; таблица всегда должна быть защищена с помощью &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; , в противном случае при вызове &lt;code&gt;match_object/1&lt;/code&gt; могут возникнуть ошибки .</target>
        </trans-unit>
        <trans-unit id="e2da56b6127d8f8b1f1475a198ead6fa8576cef3" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;select/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;select/1&lt;/code&gt;.</source>
          <target state="translated">Перед вызовом &lt;code&gt;select/3&lt;/code&gt; таблица всегда должна быть защищена с помощью &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; , иначе при вызове &lt;code&gt;select/1&lt;/code&gt; могут возникнуть ошибки .</target>
        </trans-unit>
        <trans-unit id="a15b4f96977744e9f06d4a053061f2ae406c3cc5" translate="yes" xml:space="preserve">
          <source>The table is read or written in chunks of &lt;code&gt;?CHARS_PER_REC&lt;/code&gt;, overwriting when necessary. The implementation is clearly not efficient, it is just working.</source>
          <target state="translated">Таблица читается или записывается порциями по &lt;code&gt;?CHARS_PER_REC&lt;/code&gt; , при необходимости перезаписывая. Реализация явно неэффективная, просто рабочая.</target>
        </trans-unit>
        <trans-unit id="216abe432d30c693518496ed41d4537b67851e03" translate="yes" xml:space="preserve">
          <source>The table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. Option &lt;code&gt;n_objects&lt;/code&gt; determines the number of objects returned (the third argument of &lt;code&gt;select/3&lt;/code&gt;); the default is to return &lt;code&gt;100&lt;/code&gt; objects at a time. The &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; (the second argument of &lt;code&gt;select/3&lt;/code&gt;) is assembled by QLC: simple filters are translated into equivalent match specifications while more complicated filters must be applied to all objects returned by &lt;code&gt;select/3&lt;/code&gt; given a match specification that matches all objects.</source>
          <target state="translated">Перемещение по таблице осуществляется путем вызова &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; . Опция &lt;code&gt;n_objects&lt;/code&gt; определяет количество возвращаемых объектов (третий аргумент &lt;code&gt;select/3&lt;/code&gt; ); по умолчанию возвращается &lt;code&gt;100&lt;/code&gt; объектов за раз. Спецификация &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; (второй аргумент &lt;code&gt;select/3&lt;/code&gt; ) собирается QLC: простые фильтры преобразуются в эквивалентные спецификации соответствия, в то время как более сложные фильтры должны применяться ко всем объектам, возвращаемым &lt;code&gt;select/3&lt;/code&gt; ,с учетом спецификации соответствия, которая соответствует всем объектам.</target>
        </trans-unit>
        <trans-unit id="3e9b781613899199f74480c8df4e129f831967a1" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Таблица просматривается по одной клавише, вызывая &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b596d446b0a8770a2196be90fa1f23b7bdccfe0" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Таблица просматривается по одной клавише за раз, вызывая &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8716b30387dd883800492663d7d3d90e4516d46" translate="yes" xml:space="preserve">
          <source>The table may be used as an ordinary Mnesia table, using the Mnesia API internally in the application at the same time as it is visible through SNMP.</source>
          <target state="translated">Таблицу можно использовать как обычную таблицу Mnesia,используя внутри приложения API Mnesia,в то же время,как она видна через SNMP.</target>
        </trans-unit>
        <trans-unit id="3d172554a6c6306bf28a607a5a2963fa7455c502" translate="yes" xml:space="preserve">
          <source>The table must be created in Mnesia before the manager can use it. The table must be declared as type &lt;code&gt;snmp&lt;/code&gt;. This makes the table ordered in accordance with the lexicographical ordering rules of SNMP. The name of the Mnesia table must be identical to the SNMP table name. The types of the INDEX fields in the corresponding SNMP table must be specified.</source>
          <target state="translated">Таблица должна быть создана в Mnesia, прежде чем менеджер сможет ее использовать. Таблица должна быть объявлена ​​как тип &lt;code&gt;snmp&lt;/code&gt; . Это упорядочивает таблицу в соответствии с правилами лексикографического упорядочения SNMP. Имя таблицы Mnesia должно совпадать с именем таблицы SNMP. Необходимо указать типы полей INDEX в соответствующей таблице SNMP.</target>
        </trans-unit>
        <trans-unit id="75b5a69a501aab4ff4e7aeebea0d27ed7fcb4181" translate="yes" xml:space="preserve">
          <source>The table name, regardless of if it is a &lt;code&gt;named_table&lt;/code&gt; or not.</source>
          <target state="translated">Имя таблицы, независимо от того, является это &lt;code&gt;named_table&lt;/code&gt; или нет.</target>
        </trans-unit>
        <trans-unit id="905054fe1aefc5725eea1173de784dd765e8936b" translate="yes" xml:space="preserve">
          <source>The table name.</source>
          <target state="translated">Название таблицы.</target>
        </trans-unit>
        <trans-unit id="aba015ed958a70d6fa81d83ffe73faad038149fe" translate="yes" xml:space="preserve">
          <source>The table property &lt;code&gt;frag_properties&lt;/code&gt; can be read with the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt;. The fragmentation properties are a list of tagged tuples with arity 2. By default the list is empty, but when it is non-empty it triggers &lt;code&gt;Mnesia&lt;/code&gt; to regard the table as fragmented. The fragmentation properties are as follows:</source>
          <target state="translated">Свойство таблицы &lt;code&gt;frag_properties&lt;/code&gt; можно прочитать с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt; . Свойства фрагментации - это список помеченных кортежей с арностью 2. По умолчанию список пуст, но когда он не пуст, он заставляет &lt;code&gt;Mnesia&lt;/code&gt; рассматривать таблицу как фрагментированную. Свойства фрагментации следующие:</target>
        </trans-unit>
        <trans-unit id="d01afc3037ddbf804c41230f3010100787c86042" translate="yes" xml:space="preserve">
          <source>The table replicas can be backed up, either from RAM, or from disc if dumped there with this function.</source>
          <target state="translated">Резервное копирование реплик таблиц может быть выполнено либо из оперативной памяти,либо с диска,если они были дампованны туда с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="015f395b52e0bf9602a397e1f420732c71594a61" translate="yes" xml:space="preserve">
          <source>The table type is not &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">Тип таблицы не &lt;code&gt;set&lt;/code&gt; или не &lt;code&gt;ordered_set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e38c104619f1b370bd6dfa294f10929d5f26c0d" translate="yes" xml:space="preserve">
          <source>The table type, that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;dublicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">Тип таблицы, то есть &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; , &lt;code&gt;dublicate_bag&lt;/code&gt; или &lt;code&gt;ordered_set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2206ddd6a97bccbdb41e1737af06cd4da0bcb9" translate="yes" xml:space="preserve">
          <source>The table type.</source>
          <target state="translated">Тип таблицы.</target>
        </trans-unit>
        <trans-unit id="d1da328209adecc0d90374bccf49a5ac8565208f" translate="yes" xml:space="preserve">
          <source>The table-related events that can occur are as follows:</source>
          <target state="translated">Ниже приведены связанные с таблицей события,которые могут произойти:</target>
        </trans-unit>
        <trans-unit id="6b7e8b80ac770e54ad2093b66bc38848a1574359" translate="yes" xml:space="preserve">
          <source>The tables are backed up to external media using backup module &lt;code&gt;BackupMod&lt;/code&gt;. Tables with the local contents property are backed up as they exist on the current node. &lt;code&gt;BackupMod&lt;/code&gt; is the default backup callback module obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;. For information about the exact callback interface (the &lt;code&gt;mnesia_backup behavior&lt;/code&gt;), see the User's Guide.</source>
          <target state="translated">Резервное копирование таблиц на внешний носитель &lt;code&gt;BackupMod&lt;/code&gt; с помощью модуля резервного копирования BackupMod . Таблицы со свойством локального содержимого копируются в том виде, в каком они существуют на текущем узле. &lt;code&gt;BackupMod&lt;/code&gt; - это модуль обратного вызова резервного копирования по умолчанию, полученный &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; . Для получения информации о точном интерфейсе обратного вызова ( &lt;code&gt;mnesia_backup behavior&lt;/code&gt; ) см. Руководство пользователя.</target>
        </trans-unit>
        <trans-unit id="a50fefb12e96d03c248f13811ba0df12461ae0eb" translate="yes" xml:space="preserve">
          <source>The tables only documents the supported cryptos and key lengths. The user should not draw any conclusion on security from the supplied tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf13625217c16a91aadb6ca3932c666df7c246ce" translate="yes" xml:space="preserve">
          <source>The tag for the messages that are sent to the error logger in the Erlang runtime system</source>
          <target state="translated">Тэг для сообщений,которые отправляются в регистратор ошибок в системе исполнения Erlang.</target>
        </trans-unit>
        <trans-unit id="dea673760fa272778aeb2296bada6c28ed936886" translate="yes" xml:space="preserve">
          <source>The tags, their arguments and the contents of each corresponding section are as follows. Each section can occur multiple times unless otherwise specified. The order in which sections are specified is unimportant.</source>
          <target state="translated">Тэги,их аргументы и содержимое каждого соответствующего раздела выглядят следующим образом.Каждый раздел может встречаться несколько раз,если не указано иное.Порядок указания секций не имеет значения.</target>
        </trans-unit>
        <trans-unit id="043e9fad0f693d524a84cb1e4b574f9675842439" translate="yes" xml:space="preserve">
          <source>The tail variables &lt;code&gt;RestDgram&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; bind to binaries, as all tail variables do. Both can bind to empty binaries.</source>
          <target state="translated">Хвостовые переменные &lt;code&gt;RestDgram&lt;/code&gt; и &lt;code&gt;Data&lt;/code&gt; связываются с двоичными файлами, как и все хвостовые переменные. Оба могут связываться с пустыми двоичными файлами.</target>
        </trans-unit>
        <trans-unit id="7e9693ae2473d33274921bc96471864fb339cde4" translate="yes" xml:space="preserve">
          <source>The target data must exist in a configuration file. The connection can be associated with &lt;code&gt;Name&lt;/code&gt; and/or the returned &lt;code&gt;Handle&lt;/code&gt;. To allocate a name for the target, use one of the following alternatives:</source>
          <target state="translated">Целевые данные должны существовать в файле конфигурации. Соединение может быть связано с &lt;code&gt;Name&lt;/code&gt; и / или возвращенным &lt;code&gt;Handle&lt;/code&gt; . Чтобы присвоить имя цели, используйте одну из следующих альтернатив:</target>
        </trans-unit>
        <trans-unit id="bba902f624a3f363faa2c1c1baf548942d9ee3b6" translate="yes" xml:space="preserve">
          <source>The telnet end of line characters, from the FTP protocol definition, CRLF, for example, &quot;\\r\\n&quot; has been removed.</source>
          <target state="translated">Удален символ конца строки telnet из определения протокола FTP,CRLF,например,&quot;\\r\\n&quot;.</target>
        </trans-unit>
        <trans-unit id="85e11e994e429cc2b8651f58111eb62a63c0aeb2" translate="yes" xml:space="preserve">
          <source>The template describes how the formatted string is composed by combining different data values from the log event. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information about this.</source>
          <target state="translated">В шаблоне описывается составление форматированной строки путем объединения различных значений данных из события журнала. См. Описание типа &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="eb1a8be6676238f92f5d9b5d87374d91e2e26ce8" translate="yes" xml:space="preserve">
          <source>The template is a list of atoms, atom lists, tuples and strings. The atoms &lt;code&gt;level&lt;/code&gt; or &lt;code&gt;msg&lt;/code&gt;, are treated as placeholders for the severity level and the log message, respectively. Other atoms or atom lists are interpreted as placeholders for metadata, where atoms are expected to match top level keys, and atom lists represent paths to sub keys when the metadata is a nested map. For example the list &lt;code&gt;[key1,key2]&lt;/code&gt; is replaced by the value of the &lt;code&gt;key2&lt;/code&gt; field in the nested map below. The atom &lt;code&gt;key1&lt;/code&gt; on its own is replaced by the complete value of the &lt;code&gt;key1&lt;/code&gt; field. The values are converted to strings.</source>
          <target state="translated">Шаблон - это список атомов, списки атомов, кортежи и строки. Атомы &lt;code&gt;level&lt;/code&gt; или &lt;code&gt;msg&lt;/code&gt; , рассматриваются в качестве заполнителей для уровня серьезности и сообщения журнала, соответственно. Другие атомы или списки атомов интерпретируются как заполнители для метаданных, где ожидается, что атомы будут соответствовать ключам верхнего уровня, а списки атомов представляют пути к подключам, когда метаданные являются вложенной картой. Например, список &lt;code&gt;[key1,key2]&lt;/code&gt; заменяется значением поля &lt;code&gt;key2&lt;/code&gt; на вложенной карте ниже. Сам по себе атом &lt;code&gt;key1&lt;/code&gt; заменяется полным значением поля &lt;code&gt;key1&lt;/code&gt; . Значения преобразуются в строки.</target>
        </trans-unit>
        <trans-unit id="1689a0a33b1df848c6a808be824bdd29e81b6532" translate="yes" xml:space="preserve">
          <source>The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the &lt;code&gt;&lt;a href=&quot;terminology#the-term--user-&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8501f8ff2d84842e337cdcce3f99664ae391737b" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;&amp;lt;&amp;lt;42, 1:1&amp;gt;&amp;gt;&lt;/code&gt; was encoded as &lt;code&gt;{&amp;lt;&amp;lt;42, 128&amp;gt;&amp;gt;, 1}&lt;/code&gt;. The first element of the tuple is a binary and the second element denotes how many bits of the last bytes are part of the bit string. In this example only the most significant bit of the last byte (128) is part of the bit string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e28f12366708f6b889216805c88be5b281bf16" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;define&lt;/code&gt; introduces a constant that is used to replace the name &lt;code&gt;Constant&lt;/code&gt; with &lt;code&gt;Value&lt;/code&gt;, wherever it is found in the test specification. This replacement occurs during an initial iteration through the test specification. Constants can be used anywhere in the test specification, for example, in any lists and tuples, and even in strings and inside the value part of other constant definitions. A constant can also be part of a node name, but that is the only place where a constant can be part of an atom.</source>
          <target state="translated">Термин &amp;laquo; &lt;code&gt;define&lt;/code&gt; вводит константу, которая используется для замены имени &amp;laquo; &lt;code&gt;Constant&lt;/code&gt; на &amp;laquo; &lt;code&gt;Value&lt;/code&gt; , где бы оно ни было в спецификации теста. Эта замена происходит во время начальной итерации тестовой спецификации. Константы могут использоваться в любом месте спецификации теста, например, в любых списках и кортежах, и даже в строках и внутри значений других определений констант. Константа также может быть частью имени узла, но это единственное место, где константа может быть частью атома.</target>
        </trans-unit>
        <trans-unit id="f0ffe8b43fa9a9a57ebc915f442685927b0ceb78" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;fun lists:map/2&lt;/code&gt; was encoded as &lt;code&gt;{lists,map}&lt;/code&gt;. A tuple with the module, function and a missing arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33125cbeb164cf4f6a823b4bcb06baf40cb7cda" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;specs&lt;/code&gt; can be used to nest specifications, that is, have one specification include other specifications, which in turn include others, and so no</source>
          <target state="translated">Термин &lt;code&gt;specs&lt;/code&gt; можно использовать для вложения спецификаций, то есть одна спецификация включает другие спецификации, которые, в свою очередь, включают другие, и поэтому нет</target>
        </trans-unit>
        <trans-unit id="e318201a8b40a1dad67bec55bab55db8fcdcc917" translate="yes" xml:space="preserve">
          <source>The term is used differently in &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; and SSH in Erlang/OTP. The reason is the different environments and use cases that are not immediatly obvious.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1d039344650bb5818e83c555d5196b81ddbd6e" translate="yes" xml:space="preserve">
          <source>The term representing a collection of annotations. It is either a &lt;code&gt;location()&lt;/code&gt; or a list of key-value pairs.</source>
          <target state="translated">Термин, представляющий набор аннотаций. Это либо &lt;code&gt;location()&lt;/code&gt; либо список пар ключ-значение.</target>
        </trans-unit>
        <trans-unit id="206bdfd6f6a1886654062cc692aecc040226c259" translate="yes" xml:space="preserve">
          <source>The terms &lt;code&gt;incl_dirs_r&lt;/code&gt; and &lt;code&gt;excl_dirs_r&lt;/code&gt; tell &lt;code&gt;Common Test&lt;/code&gt; to search the specified directories recursively and include or exclude any module found during the search. The terms &lt;code&gt;incl_dirs&lt;/code&gt; and &lt;code&gt;excl_dirs&lt;/code&gt; result in a non-recursive search for modules (that is, only modules found in the specified directories are included or excluded).</source>
          <target state="translated">Термины &lt;code&gt;incl_dirs_r&lt;/code&gt; и &lt;code&gt;excl_dirs_r&lt;/code&gt; сообщают &lt;code&gt;Common Test&lt;/code&gt; о необходимости рекурсивного поиска в указанных каталогах и включения или исключения любого модуля, найденного во время поиска. Термины &lt;code&gt;incl_dirs&lt;/code&gt; и &lt;code&gt;excl_dirs&lt;/code&gt; приводят к нерекурсивному поиску модулей (то есть включаются или исключаются только модули, найденные в указанных каталогах).</target>
        </trans-unit>
        <trans-unit id="9ddcad5286af6cdd21c133d5d7ddb5de84e979bf" translate="yes" xml:space="preserve">
          <source>The test case can also be marked as failed without executing it by returning a tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; from &lt;code&gt;init_per_testcase&lt;/code&gt;.</source>
          <target state="translated">Тестовый пример также можно пометить как неудачный, не выполняя его, возвращая кортеж &lt;code&gt;{fail,Reason}&lt;/code&gt; из &lt;code&gt;init_per_testcase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6380cface8a9ffcf2f270eb92121974a48a9e6f" translate="yes" xml:space="preserve">
          <source>The test case function argument &lt;code&gt;Config&lt;/code&gt; is not to be confused with the information that can be retrieved from the configuration files (using &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt; ct:get_config/1/2&lt;/a&gt;&lt;/code&gt;). The test case argument &lt;code&gt;Config&lt;/code&gt; is to be used for runtime configuration of the test suite and the test cases, while configuration files are to contain data related to the SUT. These two types of configuration data are handled differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8af161d95302d88592feab6a61159ca646e5862" translate="yes" xml:space="preserve">
          <source>The test case function argument &lt;code&gt;Config&lt;/code&gt; is not to be confused with the information that can be retrieved from the configuration files (using &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt;). The test case argument &lt;code&gt;Config&lt;/code&gt; is to be used for runtime configuration of the test suite and the test cases, while configuration files are to contain data related to the SUT. These two types of configuration data are handled differently.</source>
          <target state="translated">Аргумент функции тестового примера &lt;code&gt;Config&lt;/code&gt; не следует путать с информацией, которую можно получить из файлов конфигурации (с помощью &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt; ). Аргумент тестового примера &lt;code&gt;Config&lt;/code&gt; должен использоваться для конфигурации во время выполнения набора тестов и тестовых примеров, в то время как файлы конфигурации должны содержать данные, относящиеся к SUT. Эти два типа данных конфигурации обрабатываются по-разному.</target>
        </trans-unit>
        <trans-unit id="22d7a935338112ce920c6d20731f07d69ad88ede" translate="yes" xml:space="preserve">
          <source>The test case function takes one argument, &lt;code&gt;Config&lt;/code&gt;, which contains configuration information such as &lt;code&gt;data_dir&lt;/code&gt; and &lt;code&gt;priv_dir&lt;/code&gt;. (For details about these, see section &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt;. The value of &lt;code&gt;Config&lt;/code&gt; at the time of the call, is the same as the return value from &lt;code&gt;init_per_testcase&lt;/code&gt;, mentioned earlier.</source>
          <target state="translated">Функция тестового примера принимает один аргумент, &lt;code&gt;Config&lt;/code&gt; , который содержит информацию о конфигурации, такую ​​как &lt;code&gt;data_dir&lt;/code&gt; и &lt;code&gt;priv_dir&lt;/code&gt; . (Подробнее об этом см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt; . Значение &lt;code&gt;Config&lt;/code&gt; во время вызова совпадает с возвращаемым значением из &lt;code&gt;init_per_testcase&lt;/code&gt; , упомянутым ранее.</target>
        </trans-unit>
        <trans-unit id="f3d78685ce4bc3a852ca4f95b85dea262a2dbfd5" translate="yes" xml:space="preserve">
          <source>The test case function.</source>
          <target state="translated">Функция тестового случая.</target>
        </trans-unit>
        <trans-unit id="772472b0e7495bb1b3ea5fe4354a4abec00b3983" translate="yes" xml:space="preserve">
          <source>The test case group information function, &lt;code&gt;group(GroupName)&lt;/code&gt;, serves the same purpose as the suite- and test case information functions previously described. However, the scope for the group information function, is all test cases and subgroups in the group in question (&lt;code&gt;GroupName&lt;/code&gt;).</source>
          <target state="translated">Информационная функция &lt;code&gt;group(GroupName)&lt;/code&gt; тестовых примеров, group (GroupName) , служит той же цели, что и функции информации о наборах и тестовых примерах, описанные ранее. Однако область действия функции информации о группе - это все тестовые примеры и подгруппы в рассматриваемой группе ( &lt;code&gt;GroupName&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e361a6c5d543d0ec29b4b4738869aef2ab9cb85" translate="yes" xml:space="preserve">
          <source>The test case group information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of a test case group (that is, its test cases and subgroups). Properties set by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; override properties with the same key that have been set previously by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2f40a449aa01ec3c8d9cd4d1b80e618a045844" translate="yes" xml:space="preserve">
          <source>The test case group information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of a test case group (that is, its test cases and subgroups). Properties set by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; override properties with the same key that have been set previously by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Информационная функция группы тестовых случаев. Предполагается, что он должен возвращать список помеченных кортежей, которые определяют различные свойства, связанные с выполнением группы тестовых примеров (то есть ее тестовых примеров и подгрупп). Свойства, установленные группой &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; , переопределяют свойства с тем же ключом, который был установлен ранее &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2a92c03b710e68d01915fb812b8e75a0b574d1" translate="yes" xml:space="preserve">
          <source>The test case information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of this particular test case. Properties set by &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Module:Testcase/0&lt;/a&gt;&lt;/code&gt; override properties set previously for the test case by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc2d22e0d7f34017553a5d0de008034c64289ba" translate="yes" xml:space="preserve">
          <source>The test case information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of this particular test case. Properties set by &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; override properties set previously for the test case by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Информационная функция тестового примера. Предполагается, что он возвращает список помеченных кортежей, которые определяют различные свойства, связанные с выполнением этого конкретного тестового примера. Свойства, заданные &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; , переопределяют свойства, ранее установленные для тестового примера &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c528968b61f60ab84b8bb693468a7bbe033dbb46" translate="yes" xml:space="preserve">
          <source>The test case is implemented as follows:</source>
          <target state="translated">Тестовый пример реализован следующим образом:</target>
        </trans-unit>
        <trans-unit id="561ea1ed4002a2f665fd14f2b18b980f0debbc51" translate="yes" xml:space="preserve">
          <source>The test case is skipped in the following two cases:</source>
          <target state="translated">Контрольный пример пропускается в следующих двух случаях:</target>
        </trans-unit>
        <trans-unit id="acb7aee40da2324bbced996f9d61c0d108e566ea" translate="yes" xml:space="preserve">
          <source>The test cases verify, by parsing a log file, that our SUT has performed a successful restart and that no unexpected errors are printed.</source>
          <target state="translated">Тестовые случаи проверяют,анализируя лог-файл,что наш SUT выполнил успешный рестарт и что не было напечатано никаких неожиданных ошибок.</target>
        </trans-unit>
        <trans-unit id="efc4c3530fced19d9cbc7b2225463ba3c8ff70fc" translate="yes" xml:space="preserve">
          <source>The test compares the following encoder/decoders:</source>
          <target state="translated">В ходе теста сравниваются следующие датчики/декодеры:</target>
        </trans-unit>
        <trans-unit id="1270d4393c0694cbb6ad986297c7c536eca317f0" translate="yes" xml:space="preserve">
          <source>The test group definition, as returned by &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;Module:groups/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3ccb28e1c0e973d6192fea8f8c8d2cd0b4ea0a" translate="yes" xml:space="preserve">
          <source>The test now fails with &lt;code&gt;{badmatch,24}&lt;/code&gt; because the atom &lt;code&gt;toy_table&lt;/code&gt; does not match the number returned for an unnamed table. So, the problem is found, the table is to be named, and the arguments supplied by the test program do not include &lt;code&gt;named_table&lt;/code&gt;. We rewrite the start function:</source>
          <target state="translated">Теперь проверка не выполняется с &lt;code&gt;{badmatch,24}&lt;/code&gt; , потому что атом &lt;code&gt;toy_table&lt;/code&gt; не соответствует номеру, возвращенному для безымянной таблицы. Итак, проблема обнаружена, таблица должна быть названа, а аргументы, предоставленные тестовой программой, не включают &lt;code&gt;named_table&lt;/code&gt; . Перепишем стартовую функцию:</target>
        </trans-unit>
        <trans-unit id="3bf97f87b41a6f29d2b30317c0ec60daf7647ab1" translate="yes" xml:space="preserve">
          <source>The test program runs 10000 decodes on the value, resulting in an output with the elapsed time in microseconds for the total number of decodes.</source>
          <target state="translated">Тестовая программа запускает 10000 декодов на величину,в результате чего получается вывод с истекшим временем в микросекундах для общего количества декодов.</target>
        </trans-unit>
        <trans-unit id="3633648c5d3cca8dc486b6dee36d903c368bcf6f" translate="yes" xml:space="preserve">
          <source>The test specification uses the same mechanism for specifying test case groups through names and paths, as explained in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt;, with the addition of element &lt;code&gt;GroupSpec&lt;/code&gt;.</source>
          <target state="translated">В спецификации теста используется тот же механизм для определения групп тестовых примеров через имена и пути, как описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt; тестовых примеров&amp;raquo; , с добавлением элемента &lt;code&gt;GroupSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="784058b40fd83e13e1f3df9bc88ef815cead679e" translate="yes" xml:space="preserve">
          <source>The test specifications used as input to &lt;code&gt;Common Test&lt;/code&gt; Master are fully compatible with the specifications used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The syntax is described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">Спецификации теста, используемые в качестве входных данных для &lt;code&gt;Common Test&lt;/code&gt; Master, полностью совместимы со спецификациями, используемыми в качестве входных данных для обычного сервера &lt;code&gt;Common Test&lt;/code&gt; . Синтаксис описан в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; в разделе &amp;laquo;Выполнение тестов и анализ результатов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ce12c5a86679e02b3e5d37feffd481cfa1a9e63a" translate="yes" xml:space="preserve">
          <source>The test suite definition, as returned by &lt;code&gt;&lt;a href=&quot;#Module:all-0&quot;&gt;Module:all/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15500e2662eb6cf2096b1c33acff5c731c7b2d5b" translate="yes" xml:space="preserve">
          <source>The test suite information function. Returns a list of tagged tuples specifying various properties related to the execution of this test suite (common for all test cases in the suite).</source>
          <target state="translated">Информационная функция тестового набора.Возвращает список тегированных кортежей с указанием различных свойств,связанных с выполнением данного набора тестов (общих для всех тестовых случаев в наборе).</target>
        </trans-unit>
        <trans-unit id="4ce6fe4d39f0fcb69c9b74055b99a80993ff6554" translate="yes" xml:space="preserve">
          <source>The test suite information, as returned by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Module:Testcase/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4bd482d9cff3e45eb13e9917fb381a5f26152b" translate="yes" xml:space="preserve">
          <source>The test suite module must conform to a &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; specified by the &lt;code&gt;Common Test&lt;/code&gt; test server. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Модуль набора тестов должен соответствовать &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; указанному тестовым сервером &lt;code&gt;Common Test&lt;/code&gt; . Подробности см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd0f930877592ca670db8a085bb70953a2a40661" translate="yes" xml:space="preserve">
          <source>The test suites overview page includes a link to the Unexpected I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt;, as well as captured system error- and progress reports, which cannot be associated with particular test cases and therefore cannot be written to individual test case log files. This occurs, for example, if a log printout is made from an external process (not a test case process), &lt;strong&gt;or&lt;/strong&gt; if an error- or progress report comes in, during a short interval while &lt;code&gt;Common Test&lt;/code&gt; is not executing a test case or configuration function, &lt;strong&gt;or&lt;/strong&gt; while &lt;code&gt;Common Test&lt;/code&gt; is currently executing a parallel test case group.</source>
          <target state="translated">На странице обзора наборов тестов есть ссылка на журнал непредвиденных операций ввода-вывода. В этом журнале &lt;code&gt;Common Test&lt;/code&gt; сохраняет распечатки, сделанные с помощью &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; , а также зарегистрированные системные ошибки и отчеты о ходе выполнения, которые не могут быть связаны с конкретными тестовыми примерами и, следовательно, не могут быть записаны в отдельные файлы журнала тестовых примеров. Это происходит, например, если распечатка журнала выполняется из внешнего процесса (не из процесса тестового примера), &lt;strong&gt;или&lt;/strong&gt; если поступает отчет об ошибке или о ходе выполнения в течение короткого интервала времени, когда &lt;code&gt;Common Test&lt;/code&gt; не выполняет тестовый пример или конфигурацию. функция, &lt;strong&gt;или&lt;/strong&gt; пока &lt;code&gt;Common Test&lt;/code&gt; в настоящее время выполняет группу параллельных тестовых примеров.</target>
        </trans-unit>
        <trans-unit id="8134f6c45a2f73ed264b68d4ba70993d25134c43" translate="yes" xml:space="preserve">
          <source>The tests can be read as documentation, typically showing both examples of correct and incorrect usage, along with the expected consequences.</source>
          <target state="translated">Тесты можно прочитать как документацию,обычно показывающую как примеры правильного,так и неправильного использования,наряду с ожидаемыми последствиями.</target>
        </trans-unit>
        <trans-unit id="ab59e3293af2eeab2e6a44396959211db748141a" translate="yes" xml:space="preserve">
          <source>The tests will be released into &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt;. After releasing the tests you have to install the tests on the build machine. You supply the same xcomp file as to &lt;code&gt;./otp_build&lt;/code&gt; in (9).</source>
          <target state="translated">Тесты будут выпущены в &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt; . После выпуска тестов вам необходимо установить тесты на сборочную машину. Вы предоставляете тот же файл xcomp, что и &lt;code&gt;./otp_build&lt;/code&gt; в (9).</target>
        </trans-unit>
        <trans-unit id="6461764795f9a7e6a1ca8fecef822585f15dd414" translate="yes" xml:space="preserve">
          <source>The text encoding config.</source>
          <target state="translated">Конфигурация кодировки текста.</target>
        </trans-unit>
        <trans-unit id="0912732fbe8b51c591e00170193eac6690100280" translate="yes" xml:space="preserve">
          <source>The text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt;, which is part of the source code, contains information about all OTP versions from OTP 17.0 up to the current OTP version. Each line contains information about application versions that are part of a specific OTP version, and has the following format:</source>
          <target state="translated">Текстовый файл &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt; , который является частью исходного кода, содержит информацию обо всех версиях OTP от OTP 17.0 до текущей версии OTP. Каждая строка содержит информацию о версиях приложения, которые являются частью определенной версии OTP, и имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="f468d3e883b219b9301214ec34fa66d1174c9bd6" translate="yes" xml:space="preserve">
          <source>The text given to a &lt;code&gt;?Q(Text)&lt;/code&gt; macro can be either a single string, or a list of strings. The latter is useful when you need to split a long expression over multiple lines, e.g.:</source>
          <target state="translated">Текст, передаваемый макросу &lt;code&gt;?Q(Text)&lt;/code&gt; может быть либо одной строкой, либо списком строк. Последнее полезно, когда вам нужно разбить длинное выражение на несколько строк, например:</target>
        </trans-unit>
        <trans-unit id="02aabeed8f889ebc3fe270b684693102faf40262" translate="yes" xml:space="preserve">
          <source>The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string.</source>
          <target state="translated">Текст,соответствующий подвыражению (помеченному круглыми скобками в регулярном выражении),вставляется в список результатов,где он был найден.Это означает,что конкатенирование результата дробления,когда регулярное выражение целиком является одним подвыражением (как в последнем примере),всегда приводит к исходной строке.</target>
        </trans-unit>
        <trans-unit id="522fb2d0051c3d9be5f7edef8910c5e365ade309" translate="yes" xml:space="preserve">
          <source>The third and final part -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f15d959ef8fc520df7e2a55f83ecd2a324cb0e0" translate="yes" xml:space="preserve">
          <source>The third argument is &lt;code&gt;Vsn&lt;/code&gt; or &lt;code&gt;{down,Vsn}&lt;/code&gt;, as described for &lt;code&gt;gen_server:code_change/3&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Третий аргумент - это &lt;code&gt;Vsn&lt;/code&gt; или &lt;code&gt;{down,Vsn}&lt;/code&gt; , как описано для &lt;code&gt;gen_server:code_change/3&lt;/code&gt; в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98495365dd14291e5d0887711f1c5c3436964748" translate="yes" xml:space="preserve">
          <source>The third argument is an integer that is used to identify a particular instance of a C node.</source>
          <target state="translated">Третий аргумент-целое число,которое используется для идентификации конкретного экземпляра узла C.</target>
        </trans-unit>
        <trans-unit id="b22885d6c6999fdcc81a99f8b75e55f5d786c841" translate="yes" xml:space="preserve">
          <source>The third argument is the full node name.</source>
          <target state="translated">Третий аргумент-полное имя узла.</target>
        </trans-unit>
        <trans-unit id="365807a93bdba62a0a00761a03b6e541034bb449" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;Code&lt;/code&gt;, is a list of digits, which is the correct unlock code that is passed to callback function &lt;code&gt;init/1&lt;/code&gt;.</source>
          <target state="translated">Третий аргумент, &lt;code&gt;Code&lt;/code&gt; , представляет собой список цифр, который представляет собой правильный код разблокировки, который передается в функцию обратного вызова &lt;code&gt;init/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4235e17037973516e425fe018a785d1dc11753" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">Третий аргумент, &lt;code&gt;[]&lt;/code&gt; , - это термин, который передается функции обратного вызова &lt;code&gt;init&lt;/code&gt; как есть . Здесь &lt;code&gt;init&lt;/code&gt; не требует никаких данных и игнорирует аргумент.</target>
        </trans-unit>
        <trans-unit id="2a25200e085552c647a791d385625d025a3908db" translate="yes" xml:space="preserve">
          <source>The third component is a term providing additional information about the cause of the error.</source>
          <target state="translated">Третий компонент-это термин,дающий дополнительную информацию о причине ошибки.</target>
        </trans-unit>
        <trans-unit id="263e38347244b9c29c16011be163dc8c74039614" translate="yes" xml:space="preserve">
          <source>The third element of the &lt;code&gt;update&lt;/code&gt; instruction is a tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;, which says that the affected processes are to do a state transformation before loading the new version of the module. This is done by the processes calling the callback function &lt;code&gt;code_change&lt;/code&gt; (see the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in STDLIB). The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to the function:</source>
          <target state="translated">Третий элемент инструкции &lt;code&gt;update&lt;/code&gt; - это кортеж &lt;code&gt;{advanced,Extra}&lt;/code&gt; , в котором говорится, что затронутые процессы должны выполнить преобразование состояния перед загрузкой новой версии модуля. Это делается процессами, вызывающими функцию обратного вызова &lt;code&gt;code_change&lt;/code&gt; (см. Справочную страницу gen_server &lt;code&gt;gen_server(3)&lt;/code&gt; в STDLIB). Термин &lt;code&gt;Extra&lt;/code&gt; , в данном случае &lt;code&gt;[]&lt;/code&gt; , передается функции как есть:</target>
        </trans-unit>
        <trans-unit id="ab1e993eaa153cf69b806d94010676be4ba79b9d" translate="yes" xml:space="preserve">
          <source>The third instruction, &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt;, works as follows:</source>
          <target state="translated">Третья инструкция, &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt; , работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="0c296204e008ff6b192a1e6549228a85ab543274" translate="yes" xml:space="preserve">
          <source>The third is the maximum value since the emulator was started.</source>
          <target state="translated">Третье-максимальное значение с момента запуска эмулятора.</target>
        </trans-unit>
        <trans-unit id="2f8559770f8f26c04a07a718464d482640f01d42" translate="yes" xml:space="preserve">
          <source>The thread has executed a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f336924d314b911c8bf63b44ab8037d465beb03f" translate="yes" xml:space="preserve">
          <source>The thread has returned from other code to a known state in the thread progress functionality, which is independent of any other code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53980cbfc9a30778a14bd5b2052c49935bce4336" translate="yes" xml:space="preserve">
          <source>The threads and states are subject to change without any prior notice.</source>
          <target state="translated">Резьбы и состояния могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="110848e2d40c2615a11026b769bd376100abd56b" translate="yes" xml:space="preserve">
          <source>The threads for long running I/O work. See &lt;code&gt;erl +SDio&lt;/code&gt; for more details.</source>
          <target state="translated">Потоки для длительного ввода-вывода работают. См. Более подробную информацию в &lt;code&gt;erl +SDio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86c3f72d097c7761a31ae09180cc6b2d4d48d019" translate="yes" xml:space="preserve">
          <source>The threads for long running cpu intensive work. See &lt;code&gt;erl +SDcpu&lt;/code&gt; for more details.</source>
          <target state="translated">Потоки для длительной работы с интенсивным процессором. См. &lt;code&gt;erl +SDcpu&lt;/code&gt; подробную информацию в erl + SDcpu .</target>
        </trans-unit>
        <trans-unit id="aece34de50ec637e00271fb64aadf70ca0063d4f" translate="yes" xml:space="preserve">
          <source>The three Erlang (&lt;code&gt;.erl&lt;/code&gt;) files in the messenger example are individually compiled into object code file (&lt;code&gt;.beam&lt;/code&gt;). The Erlang system loads and links these files into the system when they are referred to during execution of the code. In this case, they are simply put in our current working directory (that is, the place you have done &quot;cd&quot; to). There are ways of putting the &lt;code&gt;.beam&lt;/code&gt; files in other directories.</source>
          <target state="translated">Три &lt;code&gt;.erl&lt;/code&gt; Erlang ( .erl ) в примере программы обмена сообщениями индивидуально компилируются в файл объектного кода ( &lt;code&gt;.beam&lt;/code&gt; ). Система Erlang загружает и связывает эти файлы с системой при обращении к ним во время выполнения кода. В этом случае они просто помещаются в наш текущий рабочий каталог (то есть в то место, куда вы сделали &amp;laquo;cd&amp;raquo;). Есть способы поместить файлы &lt;code&gt;.beam&lt;/code&gt; в другие каталоги.</target>
        </trans-unit>
        <trans-unit id="3179e67fe382f9002d115e1d41e6ed750c972cbf" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated before the corresponding alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">Порог,в процентах от системной памяти,для того,какой объем системной памяти может быть выделен до того,как будет установлен соответствующий сигнал тревоги.По умолчанию 0,80 (80%).</target>
        </trans-unit>
        <trans-unit id="abb964e16a15aea3574dff337699e7babb0b88a4" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated by one Erlang process before the corresponding alarm is set. The default is 0.05 (5%).</source>
          <target state="translated">Порог,в процентах от системной памяти,для того,какой объем системной памяти может быть выделен одним процессом Erlang до установки соответствующего аварийного сигнала.По умолчанию 0,05 (5%).</target>
        </trans-unit>
        <trans-unit id="e98007a7e215201117e788dbb3276465ac6d78e0" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of total disk space, for how much disk can be utilized before the &lt;code&gt;disk_almost_full&lt;/code&gt; alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">Пороговое значение в процентах от общего дискового пространства, определяющее, сколько диска может быть использовано до установки &lt;code&gt;disk_almost_full&lt;/code&gt; сигнала disk_almost_full . По умолчанию 0,80 (80%).</target>
        </trans-unit>
        <trans-unit id="feab1aae2bdfc2e74927bee2d91bb36426d8246c" translate="yes" xml:space="preserve">
          <source>The time for calculating the length of a list is proportional to the length of the list, as opposed to &lt;code&gt;tuple_size/1&lt;/code&gt;, &lt;code&gt;byte_size/1&lt;/code&gt;, and &lt;code&gt;bit_size/1&lt;/code&gt;, which all execute in constant time.</source>
          <target state="translated">Время вычисления длины списка пропорционально длине списка, в отличие от &lt;code&gt;tuple_size/1&lt;/code&gt; , &lt;code&gt;byte_size/1&lt;/code&gt; и &lt;code&gt;bit_size/1&lt;/code&gt; , которые все выполняются за постоянное время.</target>
        </trans-unit>
        <trans-unit id="9fd990e3b9e2b09e602b014e1bf744386f4c5083" translate="yes" xml:space="preserve">
          <source>The time for file operations in the linked in driver distributes itself as 1 % for open, 11 % for write and 87 % for close. All data is probably buffered in the operating system until the close.</source>
          <target state="translated">Время файловых операций в связанном драйвере распределяется как 1 % для открытого,11 % для записи и 87 % для закрытого.Все данные,вероятно,буферизируются в операционной системе до закрытия.</target>
        </trans-unit>
        <trans-unit id="9a190b1ab4466c628fefcec59c8cb2184c9a131f" translate="yes" xml:space="preserve">
          <source>The time functions &lt;code&gt;local_time/0&lt;/code&gt; and &lt;code&gt;universal_time/0&lt;/code&gt; in this module both return date and time. The is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs &lt;code&gt;date/0&lt;/code&gt; and &lt;code&gt;time/0&lt;/code&gt;, and their use is strongly discouraged if a reliable date/time stamp is required.</source>
          <target state="translated">Функции времени &lt;code&gt;local_time/0&lt;/code&gt; и &lt;code&gt;universal_time/0&lt;/code&gt; в этом модуле возвращают дату и время. Это связано с тем, что отдельные функции для даты и времени могут привести к комбинации даты и времени, которая смещается на 24 часа. Это происходит, если одна из функций вызывается до полуночи, а другая - после полуночи. Эта проблема также относится к Erlang BIFs &lt;code&gt;date/0&lt;/code&gt; и &lt;code&gt;time/0&lt;/code&gt; , и их использование настоятельно не рекомендуется, если требуется надежная метка даты / времени.</target>
        </trans-unit>
        <trans-unit id="7e455cab1124e78b64c4ae934600680a5bd96fdf" translate="yes" xml:space="preserve">
          <source>The time functions &lt;code&gt;local_time/0&lt;/code&gt; and &lt;code&gt;universal_time/0&lt;/code&gt; in this module both return date and time. This is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs &lt;code&gt;date/0&lt;/code&gt; and &lt;code&gt;time/0&lt;/code&gt;, and their use is strongly discouraged if a reliable date/time stamp is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69208e9c32fc9f7e1bfe894a2034c5bf8bcec375" translate="yes" xml:space="preserve">
          <source>The time in seconds the web server waits between each chunk of data from the script. If the CGI script does not deliver any data before the timeout, the connection to the client is closed. Default is &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="translated">Время в секундах, в течение которого веб-сервер ожидает между каждым фрагментом данных из сценария. Если сценарий CGI не доставит никаких данных до истечения времени ожидания, соединение с клиентом закрывается. По умолчанию &lt;code&gt;15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83fde948bd1a784c99ccd55cd88c7ae69cfaa7fb" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic disk space check. The default is 30 minutes.</source>
          <target state="translated">Интервал времени в минутах для периодической проверки дискового пространства.По умолчанию 30 минут.</target>
        </trans-unit>
        <trans-unit id="f648e7e2912e2b6d60327d6a0acc64bb170e218b" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic memory check. The default is one minute.</source>
          <target state="translated">Интервал времени в минутах для периодической проверки памяти.По умолчанию-одна минута.</target>
        </trans-unit>
        <trans-unit id="6dc4a14921776a9a6e79ea069562a5ef16a83ecc" translate="yes" xml:space="preserve">
          <source>The time is specified as a fraction, in percent, of a full time-slice that a port is allowed to execute before it is to surrender the CPU to other runnable ports or processes. Valid range is &lt;code&gt;[1, 100]&lt;/code&gt;. The scheduling time-slice is not an exact entity, but can usually be approximated to about 1 millisecond.</source>
          <target state="translated">Время указывается как доля в процентах от полного временного интервала, который порт может выполнять, прежде чем он должен передать ЦП другим работающим портам или процессам. Допустимый диапазон: &lt;code&gt;[1, 100]&lt;/code&gt; . Временной интервал планирования не является точным, но обычно может быть приблизительно равен 1 миллисекунде.</target>
        </trans-unit>
        <trans-unit id="68613cc82c2c14fbfd127a4e01a552399427b53f" translate="yes" xml:space="preserve">
          <source>The time of the least number of consecutive &lt;code&gt;MTTI&lt;/code&gt;s to cover &lt;code&gt;TransitionPeriod&lt;/code&gt; seconds following the call to &lt;code&gt;set_net_ticktime/2&lt;/code&gt; (that is, ((&lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; milliseconds).</source>
          <target state="translated">Время наименьшего числа последовательных &lt;code&gt;MTTI&lt;/code&gt; , чтобы покрыть секунды &lt;code&gt;TransitionPeriod&lt;/code&gt; после вызова &lt;code&gt;set_net_ticktime/2&lt;/code&gt; (то есть (( &lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; миллисекунды).</target>
        </trans-unit>
        <trans-unit id="6e174adfced39af8e0e284588941d85b0bfefb31" translate="yes" xml:space="preserve">
          <source>The time offset can change at any time without limitations. That is, Erlang system time can perform time warps both forwards and backwards at &lt;strong&gt;any&lt;/strong&gt; time. As we align Erlang system time with OS system time by changing the time offset, we can enable a time correction that tries to adjust the frequency of the Erlang monotonic clock to be as correct as possible. This makes time measurements using Erlang monotonic time more accurate and precise.</source>
          <target state="translated">Смещение по времени можно изменить в любой момент без ограничений. Таким образом, системное время Erlang может выполнять преобразование времени как вперед, так и назад в &lt;strong&gt;любое&lt;/strong&gt; время. Когда мы выравниваем системное время Erlang с системным временем ОС, изменяя смещение времени, мы можем включить временную коррекцию, которая пытается настроить частоту монотонных часов Erlang, чтобы она была как можно более правильной. Это делает измерения времени с использованием монотонного времени Эрланга более точными и точными.</target>
        </trans-unit>
        <trans-unit id="d2d5aace605853ec8fe0539020e963801c0f8996" translate="yes" xml:space="preserve">
          <source>The time offset is determined at runtime system start and does not change later. This is the default behavior, but not because it is the best mode (which it is not). It is default &lt;strong&gt;only&lt;/strong&gt; because this is how the runtime system behaved until ERTS 7.0. Ensure that your Erlang code that can execute during a time warp is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; before enabling other modes.</source>
          <target state="translated">Смещение по времени определяется при запуске системы исполнения и не изменяется позже. Это поведение по умолчанию, но не потому, что это лучший режим (а это не так). Это значение по умолчанию &lt;strong&gt;только&lt;/strong&gt; потому, что именно так вела себя исполняющая система до ERTS 7.0. Перед включением других режимов убедитесь, что ваш код Erlang, который может выполняться во время деформации &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; деформации времени .</target>
        </trans-unit>
        <trans-unit id="07e55769f0c90da00308e78b47db1584a4fbdcad" translate="yes" xml:space="preserve">
          <source>The time offset is final. This either because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt; no time warp mode&lt;/a&gt;&lt;/code&gt; is used, or because the time offset have been finalized when &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a05290e0120252e64339359ca4738dbe7f2ecf8" translate="yes" xml:space="preserve">
          <source>The time offset is final. This either because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, or because the time offset have been finalized when &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Смещение по времени окончательное. Это либо потому, что &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; используется режим временной деформации , либо потому, что временное смещение было завершено при использовании &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0957ac47e0e7e0c4aad16f53fa2e9c24f33cc8d" translate="yes" xml:space="preserve">
          <source>The time offset is preliminary, and will be changed and finalized later. The preliminary time offset is used during the preliminary phase of the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75246e26b9078dfc246576a8981834ffa66ca0f1" translate="yes" xml:space="preserve">
          <source>The time offset is preliminary, and will be changed and finalized later. The preliminary time offset is used during the preliminary phase of the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Смещение по времени является предварительным и будет изменено и уточнено позже. Предварительное смещение времени используется во время предварительной фазы режима &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b00c96b81b3952f08dae1ef8d280a0739f7dec6" translate="yes" xml:space="preserve">
          <source>The time offset is volatile. That is, it can change at any time. This is because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt; multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a542b4a11973e3e77034a41b121ba9735a608c2b" translate="yes" xml:space="preserve">
          <source>The time offset is volatile. That is, it can change at any time. This is because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Смещение по времени непостоянно. То есть он может измениться в любой момент. Это потому, что используется &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe4b21df9a3383d5eec3e415625b8f307797fe41" translate="yes" xml:space="preserve">
          <source>The time offset may or may not change during operation depending on the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used.</source>
          <target state="translated">Смещение времени может изменяться или не меняться во время работы в зависимости от используемого &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5747e4d4272d9517822c11117ba6680478fe811f" translate="yes" xml:space="preserve">
          <source>The time offset, either a string or an integer, to be used when formatting the timestamp.</source>
          <target state="translated">Смещение времени,либо строка,либо целое число,используемое при форматировании метки времени.</target>
        </trans-unit>
        <trans-unit id="01e05d873bba0338059375e3eba7a363e13a9238" translate="yes" xml:space="preserve">
          <source>The time to start the Erlang node, in seconds. Defaults to 3 seconds. If the node is not pingable within this time, the result &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">Время запуска узла Erlang в секундах. По умолчанию 3 секунды. Если в течение этого времени узел не доступен для &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; результат {error, boot_timeout, NodeName} .</target>
        </trans-unit>
        <trans-unit id="c2b0569acb74ea5c562c3c099098eac517911fa3" translate="yes" xml:space="preserve">
          <source>The time to wait for the node until it calls the internal callback function informing master about a successful startup. Defaults to 1 second. In case of a timed out message, the result &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">Время ждать, пока узел не вызовет внутреннюю функцию обратного вызова, сообщающую мастеру об успешном запуске. По умолчанию 1 секунда. В случае сообщения &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; возвращается результат {error, init_timeout, NodeName} .</target>
        </trans-unit>
        <trans-unit id="6b1ed69df7a8c67ce8c0a0d212b6e1372ea7bd21" translate="yes" xml:space="preserve">
          <source>The time to wait until the node stops to run &lt;code&gt;StartupFunctions&lt;/code&gt;. Defaults to 1 second. If this time-out occurs, the result &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">Время ждать, пока узел не остановится, чтобы запустить &lt;code&gt;StartupFunctions&lt;/code&gt; . По умолчанию 1 секунда. Если этот тайм-аут возникает, возвращается результат &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa9c4628387e5d0232143d2f5ae73813eebb7d09" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">Тип времени, возвращаемый в &lt;code&gt;atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; и &lt;code&gt;ctime&lt;/code&gt; , зависит от типа времени, установленного в &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="025c3e1a1b5155e5b0e031d4135009cedb0e5183" translate="yes" xml:space="preserve">
          <source>The time type set in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; depends on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">Тип времени, установленный в &lt;code&gt;atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; и &lt;code&gt;ctime&lt;/code&gt; , зависит от типа времени, установленного в &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b611e039fc45e31859a16123e8fec64f9c4d2359" translate="yes" xml:space="preserve">
          <source>The time unit is the same as returned by &lt;code&gt; os:perf_counter/0&lt;/code&gt;. So, to convert it to milliseconds, you can do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4f9d85f1388b8c9748c712e4d020e326e2e9ee" translate="yes" xml:space="preserve">
          <source>The time unit is the same as returned by &lt;code&gt;os:perf_counter/0&lt;/code&gt;. So, to convert it to milliseconds, you can do something like this:</source>
          <target state="translated">Единица времени такая же, как возвращаемая &lt;code&gt;os:perf_counter/0&lt;/code&gt; . Итак, чтобы преобразовать его в миллисекунды, вы можете сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="12219f11b7eb31ef4590154a3caff4c692e2fc9c" translate="yes" xml:space="preserve">
          <source>The time unit of &lt;code&gt;Time&lt;/code&gt;. The default is &lt;code&gt;second&lt;/code&gt;. If some other unit is given (&lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, or &lt;code&gt;nanosecond&lt;/code&gt;), the formatted string includes a fraction of a second.</source>
          <target state="translated">Единица &lt;code&gt;Time&lt;/code&gt; . По умолчанию - &lt;code&gt;second&lt;/code&gt; . Если задана другая единица измерения ( &lt;code&gt;millisecond&lt;/code&gt; , &lt;code&gt;microsecond&lt;/code&gt; или &lt;code&gt;nanosecond&lt;/code&gt; ), форматированная строка включает доли секунды.</target>
        </trans-unit>
        <trans-unit id="392c6bce329c78bf91e4cd21377be4fb3bee4780" translate="yes" xml:space="preserve">
          <source>The time unit of &lt;code&gt;Time&lt;/code&gt;. The default is &lt;code&gt;second&lt;/code&gt;. If some other unit is given (&lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, or &lt;code&gt;nanosecond&lt;/code&gt;), the formatted string includes a fraction of a second. The number of fractional second digits is three, six, or nine depending on what time unit is chosen. Notice that trailing zeros are not removed from the fraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1430c59740c5ce36e77e21d493e646f47e818719" translate="yes" xml:space="preserve">
          <source>The time unit of the return value. The default is &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">Единица времени возвращаемого значения. По умолчанию - &lt;code&gt;second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6064d2834424e42c0c9064187c8cad80d5a77e73" translate="yes" xml:space="preserve">
          <source>The time warp made when finalizing the time offset can only be done forwards without encountering problems. This implies that the user must ensure that OS system time is set to a time earlier or equal to actual POSIX time before starting the Erlang runtime system.</source>
          <target state="translated">Искривление времени,сделанное при окончательной выверке смещения времени,может быть сделано только вперед без проблем.Это подразумевает,что перед запуском системы Erlang пользователь должен убедиться,что системное время операционной системы установлено на время более раннее или равное фактическому времени POSIX.</target>
        </trans-unit>
        <trans-unit id="d4fbb252f5f519e910d0858637bda3afb5fe08b3" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS.</source>
          <target state="translated">Часовой пояс и коррекция по летнему времени зависят от базовой операционной системы.</target>
        </trans-unit>
        <trans-unit id="46decb898c0ad74d50df552bed6180379c34d8f6" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS. Example:</source>
          <target state="translated">Часовой пояс и коррекция по летнему времени зависят от базовой операционной системы.Пример:</target>
        </trans-unit>
        <trans-unit id="c1ff4d23080563c54d4def9701098918387b1c59" translate="yes" xml:space="preserve">
          <source>The time-out (&lt;code&gt;after 5000&lt;/code&gt;) is started when &lt;code&gt;receive&lt;/code&gt; is entered. The time-out is canceled if &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is received. If &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is not received, the actions following the time-out are done after 5000 milliseconds. &lt;code&gt;after&lt;/code&gt; must be last in the &lt;code&gt;receive&lt;/code&gt;, that is, preceded by all other message reception specifications in the &lt;code&gt;receive&lt;/code&gt;. It is also possible to call a function that returned an integer for the time-out:</source>
          <target state="translated">Тайм-аут ( &lt;code&gt;after 5000&lt;/code&gt; ) начинается при вводе &lt;code&gt;receive&lt;/code&gt; . &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; -аут отменяется, если получен {ping, Ping_PID} . Если &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; не получен, действия после тайм-аута выполняются через 5000 миллисекунд. &lt;code&gt;after&lt;/code&gt; должно быть последним в &lt;code&gt;receive&lt;/code&gt; , то есть ему предшествуют все другие спецификации приема сообщения в &lt;code&gt;receive&lt;/code&gt; . Также можно вызвать функцию, которая вернула целое число для тайм-аута:</target>
        </trans-unit>
        <trans-unit id="a74551537c5a43771b2d27e385232c7f56d26101" translate="yes" xml:space="preserve">
          <source>The time-out is set in:</source>
          <target state="translated">Тайм-аут установлен:</target>
        </trans-unit>
        <trans-unit id="b43eb0e0eaef9c040d6d8272e488450d475f41d0" translate="yes" xml:space="preserve">
          <source>The time-out values that can be returned have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">Значения тайм-аута, которые могут быть возвращены, имеют ту же семантику, что и в &lt;code&gt;gen_server&lt;/code&gt; . Если истекает время ожидания, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; вызывается как &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23098336c20c6b0d05b70cb1a61cba6bfe7c35df" translate="yes" xml:space="preserve">
          <source>The time-outs are applied as follows:</source>
          <target state="translated">Тайм-ауты применяются следующим образом:</target>
        </trans-unit>
        <trans-unit id="a92d7be64c5181c10f9b9787e69692d9bd980a7b" translate="yes" xml:space="preserve">
          <source>The time-outs are not exact, but are &lt;strong&gt;at least&lt;/strong&gt; as long as requested.</source>
          <target state="translated">Тайм-ауты не точные, но &lt;strong&gt;по крайней&lt;/strong&gt; мере, столько, сколько требуется.</target>
        </trans-unit>
        <trans-unit id="15c1ab79429f67483e0c01a31557346bcc864b3f" translate="yes" xml:space="preserve">
          <source>The timeout is not active until channels are started, so it does not limit the time from the connection creation to the first channel opening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5997cb057fe175060411534263631407871803d" translate="yes" xml:space="preserve">
          <source>The timeout time can have the values: &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">Время ожидания может иметь следующие значения: &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e975fa79f9358d6848c00dddda11ae68d145e5e9" translate="yes" xml:space="preserve">
          <source>The timeout time is in milliseconds. A value of 0 (zero) means that the proxy process will exit directly after the reply has been delivered.</source>
          <target state="translated">Тайм-аут в миллисекундах.Значение 0 (ноль)означает,что процесс прокси завершается сразу после получения ответа.</target>
        </trans-unit>
        <trans-unit id="6942299da0c7028fdc30f81f96ae8da61dd1bd71" translate="yes" xml:space="preserve">
          <source>The timeout value in a &lt;code&gt;receive..after&lt;/code&gt; expression is evaluated to something else than an integer or &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Значение тайм-аута в выражении &lt;code&gt;receive..after&lt;/code&gt; оценивается не как целое число или &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a58b363626052caadeef7377d180027acba06268" translate="yes" xml:space="preserve">
          <source>The timeout values that can be returned by the callback functions have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">Значения тайм-аута, которые могут быть возвращены функциями обратного вызова, имеют ту же семантику, что и в &lt;code&gt;gen_server&lt;/code&gt; . Если истекает время ожидания, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; вызывается как &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="746fc091a3bbb9211a083b1f5ae06872c6f4470d" translate="yes" xml:space="preserve">
          <source>The timer associated with &lt;code&gt;Timeout&lt;/code&gt; only supervises IP resolution of &lt;code&gt;Addr&lt;/code&gt;.</source>
          <target state="translated">Таймер, связанный с &lt;code&gt;Timeout&lt;/code&gt; контролирует только IP-разрешение &lt;code&gt;Addr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09b399a5a75126e8cb452f47bf0a1a5174ce3ebb" translate="yes" xml:space="preserve">
          <source>The timer created using &lt;code&gt;dist_util:start_timer/1&lt;/code&gt;.</source>
          <target state="translated">Таймер, созданный с помощью &lt;code&gt;dist_util:start_timer/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e1cbb1460f78d41a3f7701791a14cffbd170fdb" translate="yes" xml:space="preserve">
          <source>The timer for a state time-out is automatically cancelled when the state machine changes states. You can restart a state time-out by setting it to a new time, which cancels the running timer and starts a new. This implies that you can cancel a state time-out by restarting it with time &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Таймер тайм-аута состояния автоматически отменяется, когда конечный автомат меняет состояния. Вы можете перезапустить тайм-аут состояния, установив для него новое время, которое отменяет текущий таймер и запускает новый. Это означает, что вы можете отменить тайм-аут состояния, перезапустив его с &lt;code&gt;infinity&lt;/code&gt; времени .</target>
        </trans-unit>
        <trans-unit id="784479951805b5cf7d975c9fc1d861e0d1536750" translate="yes" xml:space="preserve">
          <source>The timer for a state time-out is automatically cancelled when the state machine does a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64045eba1ed6044b87952089dc11046d257dec70" translate="yes" xml:space="preserve">
          <source>The timer is cancelled when a reply is received.</source>
          <target state="translated">Таймер отменяется при получении ответа.</target>
        </trans-unit>
        <trans-unit id="3e5d9243b241f9d1ac98de61c38151d7c0aed4f0" translate="yes" xml:space="preserve">
          <source>The timer is started with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;, so any trace patterns must be set up in advance. &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; always sets up all patterns before invoking &lt;code&gt;ttb:p/2&lt;/code&gt;.</source>
          <target state="translated">Таймер запускается с помощью &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; , поэтому любые шаблоны трассировки должны быть настроены заранее. &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; всегда устанавливает все шаблоны перед &lt;code&gt;ttb:p/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2045d1e31e58946973b89bfa19e30a90c88aef6e" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in a critical path, and can do other things while waiting for the result of this operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process is blocked until the operation has been performed.</source>
          <target state="translated">Служба таймера, которая управляет таймером, может быть совмещена с другим планировщиком, а не с планировщиком, в котором выполняется вызывающий процесс. В этом случае связь со службой таймера занимает гораздо больше времени, чем если бы она была расположена локально. Если вызывающий процесс находится на критическом пути и может делать другие вещи, ожидая результата этой операции, вы хотите использовать опцию &lt;code&gt;{async, true}&lt;/code&gt; . Если используется опция &lt;code&gt;{async, false}&lt;/code&gt; , вызывающий процесс блокируется до тех пор, пока операция не будет выполнена.</target>
        </trans-unit>
        <trans-unit id="ea274128cf86d631de77306142f2359eec7a59d8" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in critical path, and can do other things while waiting for the result of this operation, or is not interested in the result of the operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process blocks until the operation has been performed.</source>
          <target state="translated">Служба таймера, которая управляет таймером, может быть совмещена с другим планировщиком, а не с планировщиком, в котором выполняется вызывающий процесс. В этом случае связь со службой таймера занимает гораздо больше времени, чем если бы она была расположена локально. Если вызывающий процесс находится на критическом пути и может делать другие вещи, ожидая результата этой операции, или не интересуется результатом операции, вы хотите использовать опцию &lt;code&gt;{async, true}&lt;/code&gt; . Если используется опция &lt;code&gt;{async, false}&lt;/code&gt; , вызывающий процесс блокируется до тех пор, пока операция не будет выполнена.</target>
        </trans-unit>
        <trans-unit id="01c4aedfbe422c954419af25bc2a44ca29efec29" translate="yes" xml:space="preserve">
          <source>The title bar shows the name of the currently loaded crashdump.</source>
          <target state="translated">В строке заголовка отображается имя загруженного в данный момент crashdump.</target>
        </trans-unit>
        <trans-unit id="ab7219cf5f8f02500259c90d49cef81093f63f21" translate="yes" xml:space="preserve">
          <source>The token's text.</source>
          <target state="translated">Текст жетона.</target>
        </trans-unit>
        <trans-unit id="6e8012793487b53f45a7c5a13441809363cbd8df" translate="yes" xml:space="preserve">
          <source>The tokenization succeeded.</source>
          <target state="translated">Токенирование прошло успешно.</target>
        </trans-unit>
        <trans-unit id="e263b7ae6b2b75806ba8e04c9ad5e6232730c3db" translate="yes" xml:space="preserve">
          <source>The tokenizer &lt;code&gt;Function&lt;/code&gt; is either a fun or a tuple &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt;. The call &lt;code&gt;apply(Function, Args)&lt;/code&gt; or &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; is executed whenever a new token is needed. This, for example, makes it possible to parse from a file, token by token.</source>
          <target state="translated">Токенизатор &lt;code&gt;Function&lt;/code&gt; либо весело или кортеж &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt; . Вызов &lt;code&gt;apply(Function, Args)&lt;/code&gt; или &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; выполняется всякий раз, когда требуется новый токен. Это, например, позволяет выполнять синтаксический анализ файла токен за токеном.</target>
        </trans-unit>
        <trans-unit id="eecca73e115331e619af23f47c2166b9740b978b" translate="yes" xml:space="preserve">
          <source>The tokenizer used above has to be implemented so as to return one of the following:</source>
          <target state="translated">Токенайзер,используемый выше,должен быть реализован таким образом,чтобы возвращать одно из следующего:</target>
        </trans-unit>
        <trans-unit id="9fe8d55f2a73cae0cc9b243cca2beb4f78cc27a7" translate="yes" xml:space="preserve">
          <source>The tool contain four things:</source>
          <target state="translated">Инструмент содержит четыре вещи:</target>
        </trans-unit>
        <trans-unit id="fdec03acdbb06629e6819b263973cb293a015233" translate="yes" xml:space="preserve">
          <source>The tool is a textual based tool that asks some questions and generates &lt;code&gt;sys.config&lt;/code&gt; and &lt;code&gt;*.conf&lt;/code&gt; files.</source>
          <target state="translated">Инструмент представляет собой текстовый инструмент, который задает некоторые вопросы и генерирует &lt;code&gt;sys.config&lt;/code&gt; и &lt;code&gt;*.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cceab8c0f08bcd5eba3c48a52f4f32cc7451571" translate="yes" xml:space="preserve">
          <source>The tool makes it easy to dynamically extend an SNMP agent in run-time. MIBs can be loaded and unloaded at any time. It is also easy to change the implementation of an MIB in run-time, without having to recompile the MIB. The MIB implementation is clearly separated from the agent.</source>
          <target state="translated">Инструмент позволяет легко динамически расширять SNMP-агент во время выполнения.MIB можно загружать и выгружать в любое время.Также легко изменить реализацию MIB во время выполнения,без необходимости перекомпилировать MIB.Реализация MIB четко отделена от агента.</target>
        </trans-unit>
        <trans-unit id="c57eb5d97f3d1b93c6dc787ae451b8dff86780d1" translate="yes" xml:space="preserve">
          <source>The tool requires Erlang release 4.7 or later.</source>
          <target state="translated">Для работы инструмента требуется версия Erlang 4.7 или более поздняя.</target>
        </trans-unit>
        <trans-unit id="4074bd4d79edc126504be2941fab21e73161d7fa" translate="yes" xml:space="preserve">
          <source>The tool uses an installed Erlang/OTP system as input. &lt;code&gt;root_dir&lt;/code&gt; is the root directory of the analysed system and it defaults to the system executing Reltool. Applications may also be located outside &lt;code&gt;root_dir&lt;/code&gt;. &lt;code&gt;lib_dirs&lt;/code&gt; defines library directories where additional applications may reside and it defaults to the directories listed by the operating system environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. See the module &lt;code&gt;code&lt;/code&gt; for more info.</source>
          <target state="translated">Инструмент использует в качестве входных данных установленную систему Erlang / OTP. &lt;code&gt;root_dir&lt;/code&gt; - это корневой каталог анализируемой системы, по умолчанию это система, выполняющая Reltool. Приложения также могут находиться за пределами &lt;code&gt;root_dir&lt;/code&gt; . &lt;code&gt;lib_dirs&lt;/code&gt; определяет каталоги библиотеки, в которых могут находиться дополнительные приложения, и по умолчанию это каталоги, перечисленные в переменной среды операционной системы &lt;code&gt;ERL_LIBS&lt;/code&gt; . См. &lt;code&gt;code&lt;/code&gt; модуля для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="4ed25be45c8a83c834fb6f6c553fb74ad08b92fe" translate="yes" xml:space="preserve">
          <source>The tool(s) are located in the example/meas directory.</source>
          <target state="translated">Инструмент(ы)находятся в каталоге example/meas.</target>
        </trans-unit>
        <trans-unit id="32614a53fcfaa9dead51313db65f2664ea439d19" translate="yes" xml:space="preserve">
          <source>The toolkit allows different kinds of sub-agents at the same time. Accordingly, different MIBs can have different &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt; mechanisms.</source>
          <target state="translated">Инструментарий позволяет одновременно использовать разные типы субагентов. Соответственно, разные MIB могут иметь разные механизмы &lt;code&gt;set&lt;/code&gt; или &lt;code&gt;get&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a0a8edd61587bef6f837bb6b651cc3f7feb62a" translate="yes" xml:space="preserve">
          <source>The toolkit provides the following:</source>
          <target state="translated">Набор инструментов включает в себя следующее:</target>
        </trans-unit>
        <trans-unit id="faaee45e85eb745fc476496ed2d34dbbfaf2f6f6" translate="yes" xml:space="preserve">
          <source>The toolkit supports the use of different types of sub-agents, but not the construction of sub-agents.</source>
          <target state="translated">Инструментарий поддерживает использование различных типов субагентов,но не строительство субагентов.</target>
        </trans-unit>
        <trans-unit id="5eca4fd89becaf65e9a29ecebed7de54b42d7b29" translate="yes" xml:space="preserve">
          <source>The tools are further described in &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Инструменты более подробно описаны в &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ae2ecc76d77c89a869d00df8f45f0ef79d0325" translate="yes" xml:space="preserve">
          <source>The top directories &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;releases&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are treated differently from other files. All other files are by default copied to the target system. The &lt;code&gt;releases&lt;/code&gt; directory contains generated &lt;code&gt;rel&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, and &lt;code&gt;boot&lt;/code&gt; files. The &lt;code&gt;lib&lt;/code&gt; directory contains the applications. Which applications are included and if they should be customized (archived, stripped from debug info etc.) is specified with various configuration parameters. The files in the &lt;code&gt;bin&lt;/code&gt; directory are copied from the &lt;code&gt;erts-vsn/bin&lt;/code&gt; directory, but only those files that were originally included in the &lt;code&gt;bin&lt;/code&gt; directory of the source system.</source>
          <target state="translated">Верхние каталоги &lt;code&gt;bin&lt;/code&gt; , &lt;code&gt;releases&lt;/code&gt; и &lt;code&gt;lib&lt;/code&gt; обрабатываются иначе, чем другие файлы. Все остальные файлы по умолчанию копируются в целевую систему. &lt;code&gt;releases&lt;/code&gt; Каталог содержит генерироваться &lt;code&gt;rel&lt;/code&gt; , &lt;code&gt;script&lt;/code&gt; и &lt;code&gt;boot&lt;/code&gt; файлов. &lt;code&gt;lib&lt;/code&gt; каталог содержит приложение. Какие приложения включены и должны ли они быть настроены (заархивированы, удалены из отладочной информации и т. Д.) Указываются в различных параметрах конфигурации. Файлы в каталоге &lt;code&gt;bin&lt;/code&gt; копируются из &lt;code&gt;erts-vsn/bin&lt;/code&gt; , но только те файлы, которые изначально были включены в &lt;code&gt;bin&lt;/code&gt; каталог исходной системы.</target>
        </trans-unit>
        <trans-unit id="ccc5aad2efbe05e6d9003238cc37f069c3a6a12a" translate="yes" xml:space="preserve">
          <source>The top-level OTP MIB is called &lt;code&gt;OTP-REG&lt;/code&gt; and it is included in the SASL application. All other OTP MIBs import some objects from this MIB.</source>
          <target state="translated">MIB OTP верхнего уровня называется &lt;code&gt;OTP-REG&lt;/code&gt; и включается в приложение SASL. Все остальные MIB OTP импортируют некоторые объекты из этой MIB.</target>
        </trans-unit>
        <trans-unit id="cf7f727f503b613e132bb04bae92664656fb55cd" translate="yes" xml:space="preserve">
          <source>The top-level OTP MIB is called &lt;code&gt;OTP-REG&lt;/code&gt; and it is included in the SNMP application. All other OTP MIBs import some objects from this MIB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1305c8508861263b9b6e7fe0cb4ed0b43d358486" translate="yes" xml:space="preserve">
          <source>The total amount of memory (measured in bytes) used by all persistent terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84531a2a9183b1d9855e02a467fa0f45db6199b5" translate="yes" xml:space="preserve">
          <source>The total amount of memory available to the Erlang emulator, allocated and free. May or may not be equal to the amount of memory configured in the system.</source>
          <target state="translated">Общий объем памяти,доступный эмулятору Erlang,выделенный и свободный.Может быть равным или не равным количеству памяти,сконфигурированной в системе.</target>
        </trans-unit>
        <trans-unit id="21349daddbe9f78057ffe41633d03aeff5b4dfff" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for ETS tables. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">Общий объем памяти, выделенной в настоящее время для таблиц ETS. Эта память является частью памяти, представленной как &lt;code&gt;system&lt;/code&gt; память.</target>
        </trans-unit>
        <trans-unit id="95625ce6b2bc15c6368f74e2c9f00e33024f644c" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for Erlang code. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">Общий объем памяти, выделенной в настоящее время для кода Erlang. Эта память является частью памяти, представленной как &lt;code&gt;system&lt;/code&gt; память.</target>
        </trans-unit>
        <trans-unit id="92570f02d253003fe52d361898384d0a6cc00fde" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for atoms. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">Общий объем памяти, выделенной в настоящее время для атомов. Эта память является частью памяти, представленной как &lt;code&gt;system&lt;/code&gt; память.</target>
        </trans-unit>
        <trans-unit id="cc60a6cee6312a43f557d00bfccf3deeac83faed" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for binaries. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">Общий объем памяти, выделенной в настоящее время для двоичных файлов. Эта память является частью памяти, представленной как &lt;code&gt;system&lt;/code&gt; память.</target>
        </trans-unit>
        <trans-unit id="14e4c7529d5fddaff839bbeef6fdabaf59af1c55" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the Erlang processes.</source>
          <target state="translated">Общий объем памяти,выделенной в настоящее время для процессов Эрланга.</target>
        </trans-unit>
        <trans-unit id="dcd35c53d248b540387eb3145fc89f0c11b8c11e" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the emulator that is not directly related to any Erlang process. Memory presented as &lt;code&gt;processes&lt;/code&gt; is not included in this memory. &lt;code&gt; instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of what memory is part of this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35fa37b02db12b38c932bf76bd09f88b68c5aa2" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the emulator that is not directly related to any Erlang process. Memory presented as &lt;code&gt;processes&lt;/code&gt; is not included in this memory. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of what memory is part of this type.</source>
          <target state="translated">Общий объем памяти, выделенной в настоящий момент для эмулятора, не имеющий прямого отношения к какому-либо процессу Erlang. Память, представленная как &lt;code&gt;processes&lt;/code&gt; , не включается в эту память. &lt;code&gt;instrument(3)&lt;/code&gt; можно использовать для получения более подробной информации о том, какая память является частью этого типа.</target>
        </trans-unit>
        <trans-unit id="215b071b6a42f1da89b3697d1f496f661d6aa206" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated. This is the same as the sum of the memory size for &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">Общий объем памяти, выделенной на данный момент. Это то же самое, что и сумма размера памяти для &lt;code&gt;processes&lt;/code&gt; и &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a938e56ba158faaa85844dc2539f443bb5a124d9" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used by the Erlang processes. This is part of the memory presented as &lt;code&gt;processes&lt;/code&gt; memory.</source>
          <target state="translated">Общий объем памяти, используемый в настоящее время процессами Erlang. Это часть памяти, представленная как память &lt;code&gt;processes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdab624b2930e224876509f0c625e5e845b4ff1f" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used for atoms. This memory is part of the memory presented as &lt;code&gt;atom&lt;/code&gt; memory.</source>
          <target state="translated">Общий объем памяти, используемый в настоящее время для атомов. Эта память является частью памяти, представленной как память &lt;code&gt;atom&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b71f34e8c31d850375dfce0787bd29c0a726617" translate="yes" xml:space="preserve">
          <source>The total lack of memory barrier when reading &lt;code&gt;the_active_code_index&lt;/code&gt; has one interesting consequence however. Different processes may see the new code at different point in time depending on when different cores happen to refresh their hardware caches. This may sound unsafe but it actually does not matter. The only property we must guarantee is that the ability to see the new code must spread with process communication. After receiving a message that was triggered by new code, the receiver must be guaranteed to also see the new code. This will be guaranteed as all types of process communication involves memory barriers in order for the receiver to be sure to read what the sender has written. This implicit memory barrier will then also make sure that the receiver reads the new value of &lt;code&gt;the_active_code_index&lt;/code&gt; and thereby also sees the new code. This is true for all kinds of inter process communication (TCP, ETS, process name registering, tracing, drivers, NIFs, etc) not just Erlang messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73082f62676cad7da8a6972b89ea87b89c66b8f" translate="yes" xml:space="preserve">
          <source>The total memory used by this process, in bytes. This includes call stack, heap, and internal structures. Same as &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt; erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4493719e0d656453847edcf986d8ecdd8e5d76e" translate="yes" xml:space="preserve">
          <source>The total memory used by this process. This includes call stack, heap, and internal structures. Same as &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Общая память, используемая этим процессом. Это включает стек вызовов, кучу и внутренние структуры. То же, что и в &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87ecdfb27347e35b213d203586b4706d6725a207" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated, equivalent to &lt;code&gt;c:memory(total)&lt;/code&gt;.</source>
          <target state="translated">Общее количество выделенных байтов, эквивалентное &lt;code&gt;c:memory(total)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4aacb9a69b73478d5cf380558cf1c9d0f0a175d" translate="yes" xml:space="preserve">
          <source>The total number of bytes, including field &lt;code&gt;Size&lt;/code&gt;.</source>
          <target state="translated">Общее количество байтов, включая &lt;code&gt;Size&lt;/code&gt; поля .</target>
        </trans-unit>
        <trans-unit id="ade9bc9096e43152fdc50c7d93977a724953c2a8" translate="yes" xml:space="preserve">
          <source>The total number of items in all wrap log files.</source>
          <target state="translated">Общее количество элементов во всех лог-файлах обертки.</target>
        </trans-unit>
        <trans-unit id="e26f652c13c599e84a51a316ff52e72ae6c6a549" translate="yes" xml:space="preserve">
          <source>The total run-time of all threads in the system. This is what you get if you call &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt;</source>
          <target state="translated">Общее время выполнения всех потоков в системе. Это то, что вы получите, если &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a21c70804496cb28140caf8b69b9295c32be2b1" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual heap in the process before doing a garbage collection.</source>
          <target state="translated">Общий размер двоичных файлов,разрешенных в виртуальной куче,перед сбором мусора.</target>
        </trans-unit>
        <trans-unit id="d53cdb49b3477b983e3f0debbb9d2b84b083cc6a" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual old heap in the process before doing a garbage collection.</source>
          <target state="translated">Общий размер двоичных файлов,разрешенных в виртуальной старой куче в процессе,прежде чем делать сбор мусора.</target>
        </trans-unit>
        <trans-unit id="ebb9f6115c8a24e5086416d9ee44573eb18624a0" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process heap.</source>
          <target state="translated">Общий размер уникальных двоичных файлов,на которые ссылаются из технологической кучи.</target>
        </trans-unit>
        <trans-unit id="0b0eb863d44dbd5b8e589949207744e47251159f" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process old heap.</source>
          <target state="translated">Общий размер уникальных двоичных файлов,относящихся к старой куче.</target>
        </trans-unit>
        <trans-unit id="32449a2d53f2b352b6abd6b8f47cee02d2cabee9" translate="yes" xml:space="preserve">
          <source>The total space required is the result calculated from the information above, plus 1 more byte for a version identifier.</source>
          <target state="translated">Общий объем требуемого пространства-это результат,вычисленный из приведенной выше информации,плюс еще 1 байт для идентификатора версии.</target>
        </trans-unit>
        <trans-unit id="bd7a2f2d43f93a16c0153ab5248fa17162eed576" translate="yes" xml:space="preserve">
          <source>The total system memory reported under UNIX is the number of physical pages of memory times the page size, and the available memory is the number of available physical pages times the page size. This is a reasonable measure as swapping should be avoided anyway, but the task of defining total memory and available memory is difficult because of virtual memory and swapping.</source>
          <target state="translated">Общая системная память,сообщаемая под UNIX,представляет собой количество физических страниц в памяти,умноженное на размер страницы,а доступная память-количество доступных физических страниц,умноженное на размер страницы.Это разумная мера,так как все равно следует избегать подмены страниц,но задача определения общей и доступной памяти затруднена из-за виртуальной памяти и подмены страниц.</target>
        </trans-unit>
        <trans-unit id="933816d7250e3513ec4007a083bc6d450febc23e" translate="yes" xml:space="preserve">
          <source>The trace &lt;code&gt;Events&lt;/code&gt; that are hosted by the &lt;code&gt;Collector&lt;/code&gt; may be stored to file and later be loaded by selecting &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;load&lt;/code&gt; entries in the &lt;code&gt;Viewers&lt;/code&gt;&lt;code&gt;File&lt;/code&gt; menu or via the &lt;code&gt;et_collector&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Events&lt;/code&gt; трассировки , которые размещаются в &lt;code&gt;Collector&lt;/code&gt; , могут быть сохранены в файл и позже загружены, выбрав &lt;code&gt;save&lt;/code&gt; и &lt;code&gt;load&lt;/code&gt; записи в меню &lt;code&gt;Viewers&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; или через API &lt;code&gt;et_collector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="451f68a1cb2620369fda9754c56e9d6942f0eb42" translate="yes" xml:space="preserve">
          <source>The trace control word is a 32-bit unsigned integer intended for generic trace control. The trace control word can be tested and set both from within trace match specifications and with BIFs. This call is only allowed when tracing.</source>
          <target state="translated">Управляющее слово трассы-32-битное беззнаковое целое число,предназначенное для управления общими трассами.Управляющее слово трассы может быть проверено и задано как из спецификаций соответствия трассы,так и из BIF.Этот вызов разрешен только при трассировке.</target>
        </trans-unit>
        <trans-unit id="c3874cc2a63c677a77b05397368808af525c7352" translate="yes" xml:space="preserve">
          <source>The trace message is passed as the second argument (&lt;code&gt;Trace&lt;/code&gt;). The possible values of &lt;code&gt;Trace&lt;/code&gt; are the following:</source>
          <target state="translated">Сообщение трассировки передается как второй аргумент ( &lt;code&gt;Trace&lt;/code&gt; ). Возможные значения &lt;code&gt;Trace&lt;/code&gt; следующие:</target>
        </trans-unit>
        <trans-unit id="57fe6c1b5e0592fa7721c5593926798fe2d07b25" translate="yes" xml:space="preserve">
          <source>The trace token contains a component called &lt;code&gt;serial&lt;/code&gt;. It consists of two integers, &lt;code&gt;Previous&lt;/code&gt; and &lt;code&gt;Current&lt;/code&gt;. The purpose is to uniquely identify each traced event within a trace sequence, as well as to order the messages chronologically and in the different branches, if any.</source>
          <target state="translated">Маркер трассировки содержит компонент под названием &lt;code&gt;serial&lt;/code&gt; . Он состоит из двух целых чисел: &amp;laquo; &lt;code&gt;Previous&lt;/code&gt; и &amp;laquo; &lt;code&gt;Current&lt;/code&gt; . Цель состоит в том, чтобы однозначно идентифицировать каждое отслеживаемое событие в последовательности трассировки, а также упорядочить сообщения в хронологическом порядке и в различных ветвях, если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="ff16088c10d9e1f1e816f51d73d899ab7bb112e4" translate="yes" xml:space="preserve">
          <source>The trace token of a process is set each time the process matches a message in a receive statement, according to the trace token carried by the received message, empty or not.</source>
          <target state="translated">Токен трассировки процесса устанавливается каждый раз,когда процесс совпадает с сообщением в операторе получения,в соответствии с тем,какой маркер трассировки несет полученное сообщение,пустой или нет.</target>
        </trans-unit>
        <trans-unit id="ef85d34b0942f0b1907381b47e1d3cc50996d00f" translate="yes" xml:space="preserve">
          <source>The trace token of a process is set each time the process receives information. This is typically when the process matches a message in a receive statement, according to the trace token carried by the received message, empty or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87d83f502b06a08e3c1d588f50aebd3ae24bfd2" translate="yes" xml:space="preserve">
          <source>The trace token with &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt; is then passed along with the information passed to the other process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252314f7c0c5e289f2fcfda50b4df8414eb39ecb" translate="yes" xml:space="preserve">
          <source>The trace token with &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt; is then passed along with the message.</source>
          <target state="translated">Затем вместе с сообщением передается токен трассировки с &lt;code&gt;tprev&lt;/code&gt; и &lt;code&gt;tcurr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04a1f28d66267b53ccd9a52f89433c7d9b1ac837" translate="yes" xml:space="preserve">
          <source>The tracing process receives the &lt;strong&gt;trace messages&lt;/strong&gt; described in the following list. &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the traced process in which the traced event has occurred. The third tuple element is the message tag.</source>
          <target state="translated">Процесс трассировки получает &lt;strong&gt;сообщения трассировки,&lt;/strong&gt; описанные в следующем списке. &lt;code&gt;Pid&lt;/code&gt; - это идентификатор отслеживаемого процесса, в котором произошло отслеживаемое событие. Третий элемент кортежа - это тег сообщения.</target>
        </trans-unit>
        <trans-unit id="b59d7a5b365a7b486e7d3f659201ca1fdb7e58e1" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that a Fun, which is placed inside a transaction, does not interfere with operations embedded in other transactions when it executes a series of operations on tables.</source>
          <target state="translated">Обработчик транзакций гарантирует,что Fun,который размещается внутри транзакции,не будет вмешиваться в операции,встроенные в другие транзакции,когда он выполняет серию операций над таблицами.</target>
        </trans-unit>
        <trans-unit id="70062fd2b1013f2420ee7dc801bcf2c7a5b9ebce" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that either all operations in the transaction are performed successfully on all nodes atomically, or the transaction fails without permanent effect on any node.</source>
          <target state="translated">Обработчик транзакции гарантирует,что либо все операции в транзакции будут выполнены успешно на всех узлах атомарно,либо транзакция завершится неудачей без необратимого воздействия на любой узел.</target>
        </trans-unit>
        <trans-unit id="b86538eb6924e406301e4e0cc389da5c07adc8a0" translate="yes" xml:space="preserve">
          <source>The transaction sender is a process (one per connection), which handle all transaction sending, if so configured (see &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Отправитель транзакции - это процесс (по одному на соединение), который обрабатывает всю отправку транзакций, если так настроен (см. &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="713f769ddf2bd92a6f2c46e6fb622ca19e8a8704" translate="yes" xml:space="preserve">
          <source>The transformation is done _after_ the actual decode has been done.</source>
          <target state="translated">Преобразование выполняется _после_фактического декодирования.</target>
        </trans-unit>
        <trans-unit id="8ea5cd69dbba346421c19ed7295d3d9115fee3a0" translate="yes" xml:space="preserve">
          <source>The transformation module</source>
          <target state="translated">Модуль трансформации</target>
        </trans-unit>
        <trans-unit id="d3b5dbd701325ece1005f2efa209fdb4382b77de" translate="yes" xml:space="preserve">
          <source>The transient mode is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Переходный режим имеет мало практического применения, поскольку, когда дерево контроля завершается, причина устанавливается в &lt;code&gt;shutdown&lt;/code&gt; , а не в &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279a8ee545cd6d6b2240b842b45553a898172100" translate="yes" xml:space="preserve">
          <source>The translation from an SMIv1 MIB to an SNMPv2c or SNMPv3 reply is always very straightforward, but the translation from a v2 MIB to a v1 reply is somewhat more complicated. There is one data type in SMIv2, called &lt;code&gt;Counter64&lt;/code&gt;, that an SNMPv1 manager cannot decode correctly. Therefore, an agent may never send a &lt;code&gt;Counter64&lt;/code&gt; object to an SNMPv1 manager. The common practice in these situations is to simple ignore any &lt;code&gt;Counter64&lt;/code&gt; objects, when sending a reply or a trap to an SNMPv1 manager. For example, if an SNMPv1 manager tries to GET an object of type &lt;code&gt;Counter64&lt;/code&gt;, he will get a &lt;code&gt;noSuchName&lt;/code&gt; error, while an SNMPv2 manager would get a correct value.</source>
          <target state="translated">Преобразование из MIB SMIv1 в ответ SNMPv2c или SNMPv3 всегда очень простое, но преобразование из MIB v2 в ответ v1 несколько сложнее. В SMIv2 есть один тип данных, называемый &lt;code&gt;Counter64&lt;/code&gt; , который менеджер SNMPv1 не может правильно декодировать. Следовательно, агент никогда не может отправить объект &lt;code&gt;Counter64&lt;/code&gt; диспетчеру SNMPv1. Обычной практикой в ​​этих ситуациях является простое игнорирование любых объектов &lt;code&gt;Counter64&lt;/code&gt; при отправке ответа или прерывания диспетчеру SNMPv1. Например, если диспетчер SNMPv1 пытается ПОЛУЧИТЬ объект типа &lt;code&gt;Counter64&lt;/code&gt; , он получит ошибку &lt;code&gt;noSuchName&lt;/code&gt; , а диспетчер SNMPv2 получит правильное значение.</target>
        </trans-unit>
        <trans-unit id="d1002669f8eb3c39bdb5b7b84f078a3d57742186" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is accessed through the two &quot;pseudo functions&quot; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">Доступ к преобразованию funs в спецификации соответствия осуществляется с помощью двух &amp;laquo; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44fa72e8417ca847548609a0551ee3e367444c94" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is done at compile time, so runtime performance is not affected by using these pseudo functions.</source>
          <target state="translated">Перевод с funs на соответствующие спецификации выполняется во время компиляции,поэтому использование этих псевдофункций не влияет на производительность.</target>
        </trans-unit>
        <trans-unit id="2cc78b834cad87c9de51c585d4cf589e52c474cd" translate="yes" xml:space="preserve">
          <source>The transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; allows the user to implement their own methods. Ready support is provided for TCP, TCP/TLS, and SCTP, but not DTLS/SCTP.</source>
          <target state="translated">Транспортный интерфейс, задокументированный в &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; позволяет пользователю реализовать свои собственные методы. Готовая поддержка предоставляется для TCP, TCP / TLS и SCTP, но не для DTLS / SCTP.</target>
        </trans-unit>
        <trans-unit id="eaa2313e85adab97ab81e1b1e732d457a7d158cf" translate="yes" xml:space="preserve">
          <source>The traversal may fail with &lt;code&gt;badarg&lt;/code&gt; exception if keys are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3ad4b1a8b0a2c9907fe25c46b068e77d9c7a9" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{hwaddr,_}&lt;/code&gt; is not returned on Solaris, as the hardware address historically belongs to the link layer and it is not returned by the Solaris API function &lt;code&gt;getaddrinfo()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e689615a4328c7bb2be0d06728d745d0225ff3fd" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{hwaddr,_}&lt;/code&gt; is not returned on Solaris, as the hardware address historically belongs to the link layer and only the superuser can read such addresses.</source>
          <target state="translated">Кортеж &lt;code&gt;{hwaddr,_}&lt;/code&gt; не возвращается в Solaris, поскольку аппаратный адрес исторически принадлежит канальному уровню, и только суперпользователь может читать такие адреса.</target>
        </trans-unit>
        <trans-unit id="734c3a9accbed59c68b041ca30504d986c5e8330" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt; in &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">Кортеж &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; включается в &lt;code&gt;InfoList&lt;/code&gt; в сообщениях &lt;code&gt;nodedown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f43f11b1eaa009f61e78aef8e72ca0bfe4ae132" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</source>
          <target state="translated">Кортеж &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c413d0bf6ec66eace53dd4e7a39e8c1f75c0b563" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</source>
          <target state="translated">Кортеж &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93c35c8a52aab9fd8efd803c8922b473482b1bda" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Формат кортежа сохранен только для обратной совместимости. Карта предпочтительна; подробнее см. &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2050463a23b37d880e27e3e31bb499a655c1dd4d" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Формат кортежа сохранен только для обратной совместимости. Карта предпочтительна; подробнее см. &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c70d1de1443033613ebef26319653a179cc6b15" translate="yes" xml:space="preserve">
          <source>The tuple returned from one &lt;code&gt;setelement/3&lt;/code&gt; call must only be used in the subsequent call to &lt;code&gt;setelement/3&lt;/code&gt;.</source>
          <target state="translated">Кортеж, возвращенный одним &lt;code&gt;setelement/3&lt;/code&gt; должен использоваться только в последующем вызове &lt;code&gt;setelement/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2734d075420144dd036b93083d684214e1714fcd" translate="yes" xml:space="preserve">
          <source>The tuples &lt;code&gt;{addr,Addr}&lt;/code&gt;, &lt;code&gt;{netmask,Netmask}&lt;/code&gt;, and possibly &lt;code&gt;{broadaddr,Broadaddr}&lt;/code&gt; or &lt;code&gt;{dstaddr,Dstaddr}&lt;/code&gt; are repeated in the list if the interface has got multiple addresses. An interface may have multiple &lt;code&gt;{flag,_}&lt;/code&gt; tuples for example if it has different flags for different address families. Multiple &lt;code&gt;{hwaddr,Hwaddr}&lt;/code&gt; tuples is hard to say anything definite about, though. The tuple &lt;code&gt;{flag,Flags}&lt;/code&gt; is mandatory, all others are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ff128add1588c52d8394da93cf96f601027206" translate="yes" xml:space="preserve">
          <source>The tuples &lt;code&gt;{addr,Addr}&lt;/code&gt;, &lt;code&gt;{netmask,_}&lt;/code&gt;, and &lt;code&gt;{broadaddr,_}&lt;/code&gt; are repeated in the result list if the interface has multiple addresses. If you come across an interface with multiple &lt;code&gt;{flag,_}&lt;/code&gt; or &lt;code&gt;{hwaddr,_}&lt;/code&gt; tuples, you have a strange interface or possibly a bug in this function. The tuple &lt;code&gt;{flag,_}&lt;/code&gt; is mandatory, all others are optional.</source>
          <target state="translated">Кортежи &lt;code&gt;{addr,Addr}&lt;/code&gt; , &lt;code&gt;{netmask,_}&lt;/code&gt; и &lt;code&gt;{broadaddr,_}&lt;/code&gt; повторяются в списке результатов, если интерфейс имеет несколько адресов. Если вы встретите интерфейс с несколькими кортежами &lt;code&gt;{flag,_}&lt;/code&gt; или &lt;code&gt;{hwaddr,_}&lt;/code&gt; , у вас странный интерфейс или, возможно, ошибка в этой функции. Кортеж &lt;code&gt;{flag,_}&lt;/code&gt; является обязательным, все остальные - необязательными.</target>
        </trans-unit>
        <trans-unit id="bffca28a508475c37df7d5a78d73209432e6424e" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; give different possibilities and restrictions, with one common goal: to handle all possible combinations of events and states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c792192eae5af5df8655eee98e78f1050f5569af" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; give different possibilities and restrictions, with one common goal: to handle all possible combinations of events and states.</source>
          <target state="translated">Два &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; предоставляют разные возможности и ограничения с одной общей целью: обрабатывать все возможные комбинации событий и состояний.</target>
        </trans-unit>
        <trans-unit id="0298b22c480eceedcea59bf7361f3f9da67e49ce" translate="yes" xml:space="preserve">
          <source>The two flag values can be combined with bitwise OR. The resource type name is local to the calling module. Argument &lt;code&gt;module_str&lt;/code&gt; is not (yet) used and must be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;dtor&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt; if no destructor is needed.</source>
          <target state="translated">Два значения флага могут быть объединены с помощью побитового ИЛИ. Имя типа ресурса является локальным для вызывающего модуля. Аргумент &lt;code&gt;module_str&lt;/code&gt; (пока) не используется и должен иметь &lt;code&gt;NULL&lt;/code&gt; . &lt;code&gt;dtor&lt;/code&gt; может иметь &lt;code&gt;NULL&lt;/code&gt; если деструктор не нужен.</target>
        </trans-unit>
        <trans-unit id="d12cd5775794850530c69243a0b35a79255f52a0" translate="yes" xml:space="preserve">
          <source>The two following &lt;code&gt;setelement/3&lt;/code&gt; calls modify the tuple in place.</source>
          <target state="translated">Два следующих &lt;code&gt;setelement/3&lt;/code&gt; изменяют кортеж на месте.</target>
        </trans-unit>
        <trans-unit id="65274f8639b74e1c1addc358f6c4f02af0256408" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;until_newline/3&lt;/code&gt; and &lt;code&gt;until_enough/3&lt;/code&gt; are helpers used together with function &lt;code&gt;get_until/5&lt;/code&gt; to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; (inefficiently):</source>
          <target state="translated">Две функции &lt;code&gt;until_newline/3&lt;/code&gt; и &lt;code&gt;until_enough/3&lt;/code&gt; являются помощниками, используемыми вместе с функцией &lt;code&gt;get_until/5&lt;/code&gt; для реализации &lt;code&gt;get_chars&lt;/code&gt; и &lt;code&gt;get_line&lt;/code&gt; (неэффективно):</target>
        </trans-unit>
        <trans-unit id="66b4872540376e34796f1ec9e420e0053c6366ad" translate="yes" xml:space="preserve">
          <source>The two functions for reloading drivers are to be used together with corresponding load functions to support the two different behaviors concerning open ports:</source>
          <target state="translated">Две функции для перезагрузки драйверов должны использоваться вместе с соответствующими функциями загрузки для поддержки двух различных моделей поведения,касающихся открытых портов:</target>
        </trans-unit>
        <trans-unit id="9c0c4d47161e2b26102273194fa251a585e05de6" translate="yes" xml:space="preserve">
          <source>The two index search functions described here are automatically started when searching tables with &lt;code&gt;qlc&lt;/code&gt; list comprehensions and also when using the low-level &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; functions.</source>
          <target state="translated">Две функции поиска индекса , описанные здесь, автоматически запускается при поиске таблицы с &lt;code&gt;qlc&lt;/code&gt; списковых , а также при использовании низкого уровня &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="246d94548a4e439a2a10c8f1eb4458a0f48f069d" translate="yes" xml:space="preserve">
          <source>The two main interfaces for running tests with &lt;code&gt;Common Test&lt;/code&gt; are an executable program named &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; and the Erlang module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_run&lt;/code&gt; is compiled for the underlying operating system (for example, Unix/Linux or Windows) during the build of the Erlang/OTP system, and is installed automatically with other executable programs in the top level &lt;code&gt;bin&lt;/code&gt; directory of Erlang/OTP. The &lt;code&gt;ct&lt;/code&gt; interface functions can be called from the Erlang shell, or from any Erlang function, on any supported platform.</source>
          <target state="translated">Два основных интерфейса для запуска тестов с &lt;code&gt;Common Test&lt;/code&gt; - это исполняемая программа &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; и модуль Erlang &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ct_run&lt;/code&gt; компилируется для базовой операционной системы (например, Unix / Linux или Windows) во время сборки системы Erlang / OTP и автоматически устанавливается вместе с другими исполняемыми программами в каталоге &lt;code&gt;bin&lt;/code&gt; верхнего уровня Erlang / OTP. Функции интерфейса &lt;code&gt;ct&lt;/code&gt; можно вызывать из оболочки Erlang или из любой функции Erlang на любой поддерживаемой платформе.</target>
        </trans-unit>
        <trans-unit id="1eed66d650bf2a2472423671355f16a5f1ae975a" translate="yes" xml:space="preserve">
          <source>The two major components of the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; tool is a graphical sequence chart viewer (&lt;code&gt;et_viewer&lt;/code&gt;) and its backing storage (&lt;code&gt;et_collector&lt;/code&gt;). One &lt;code&gt;Collector&lt;/code&gt; may be used as backing storage for several simultaneous &lt;code&gt;Viewers&lt;/code&gt; where each one may display a different view of the same trace data.</source>
          <target state="translated">Два основных компонента инструмента &lt;code&gt;Event Tracer (ET)&lt;/code&gt; - это средство просмотра графической диаграммы последовательности ( &lt;code&gt;et_viewer&lt;/code&gt; ) и его резервное хранилище ( &lt;code&gt;et_collector&lt;/code&gt; ). Один &lt;code&gt;Collector&lt;/code&gt; может использоваться в качестве резервного хранилища для нескольких одновременно &lt;code&gt;Viewers&lt;/code&gt; где каждый может отображать разные представления одних и тех же данных трассировки.</target>
        </trans-unit>
        <trans-unit id="b0b98c5ee144a7e629e6a186d5b34f7dc5bb41d7" translate="yes" xml:space="preserve">
          <source>The two occurrences of &lt;code&gt;N&lt;/code&gt; are not related. The compiler will complain that the &lt;code&gt;N&lt;/code&gt; in the size field is unbound.</source>
          <target state="translated">Два появления &lt;code&gt;N&lt;/code&gt; не связаны. Компилятор будет жаловаться, что &lt;code&gt;N&lt;/code&gt; в поле размера не привязано.</target>
        </trans-unit>
        <trans-unit id="8c1e49fb3411cc8e5831e0be0f58277a39603aae" translate="yes" xml:space="preserve">
          <source>The two parts of the &lt;code&gt;convert&lt;/code&gt; function are called its clauses. As shown, &lt;code&gt;miles&lt;/code&gt; is not part of either of the clauses. The Erlang system cannot &lt;strong&gt;match&lt;/strong&gt; either of the clauses so an error message &lt;code&gt;function_clause&lt;/code&gt; is returned. The shell formats the error message nicely, but the error tuple is saved in the shell's history list and can be output by the shell command &lt;code&gt;v/1&lt;/code&gt;:</source>
          <target state="translated">Две части функции &lt;code&gt;convert&lt;/code&gt; называются ее предложениями. Как показано, &lt;code&gt;miles&lt;/code&gt; не входят ни в один из пунктов. Система Erlang не может &lt;strong&gt;сопоставить&lt;/strong&gt; ни одно из предложений, поэтому возвращается сообщение об ошибке &lt;code&gt;function_clause&lt;/code&gt; . Оболочка красиво форматирует сообщение об ошибке, но кортеж ошибок сохраняется в списке истории оболочки и может быть выведен с помощью команды оболочки &lt;code&gt;v/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef209651a9fdf27bee622b273ceb5f16c1a1ba01" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;BIT STRING&lt;/code&gt; can be used to model information that is made up of arbitrary length series of bits. It is intended to be used for selection of flags, not for binary files.</source>
          <target state="translated">Тип &lt;code&gt;BIT STRING&lt;/code&gt; может использоваться для моделирования информации, состоящей из серий битов произвольной длины. Он предназначен для выбора флагов, а не для двоичных файлов.</target>
        </trans-unit>
        <trans-unit id="ae16e6086ff80fdbd8c4ef671e6092d385270bd3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;CHOICE&lt;/code&gt; is a space saver and is similar to the concept of a 'union' in C.</source>
          <target state="translated">Тип &lt;code&gt;CHOICE&lt;/code&gt; позволяет сэкономить место и похож на концепцию объединения в C.</target>
        </trans-unit>
        <trans-unit id="965f2c85137cbf54f06adf43202eea3af0164d29" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;ENUMERATED&lt;/code&gt; can be used when the value you want to describe can only take one of a set of predefined values. Example:</source>
          <target state="translated">Тип &lt;code&gt;ENUMERATED&lt;/code&gt; можно использовать, когда значение, которое вы хотите описать, может принимать только одно из набора предопределенных значений. Пример:</target>
        </trans-unit>
        <trans-unit id="c0ca634710fd8cc8e3767efb8dc71dc3f784baaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;EXTERNAL&lt;/code&gt; had a slightly different associated type before 1994. X.691 states that encoding must follow the older associated type. So, generated encode/decode functions convert values of the newer format to the older format before encoding. This implies that it is allowed to use &lt;code&gt;EXTERNAL&lt;/code&gt; type values of either format for encoding. Decoded values are always returned in the newer format.</source>
          <target state="translated">Тип &lt;code&gt;EXTERNAL&lt;/code&gt; имел несколько другой связанный тип до 1994 года. X.691 утверждает, что кодирование должно следовать за более старым связанным типом. Таким образом, сгенерированные функции кодирования / декодирования преобразуют значения из более нового формата в более старый формат перед кодированием. Это означает, что для кодирования разрешено использовать значения типа &lt;code&gt;EXTERNAL&lt;/code&gt; любого формата. Декодированные значения всегда возвращаются в более новом формате.</target>
        </trans-unit>
        <trans-unit id="b96d9ad7628789a455a00e354d8f85bc83f8dcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;MACRO&lt;/code&gt; is not supported. It is no longer part of the ASN.1 standard.</source>
          <target state="translated">Тип &lt;code&gt;MACRO&lt;/code&gt; не поддерживается. Это больше не является частью стандарта ASN.1.</target>
        </trans-unit>
        <trans-unit id="aa57b7a761159ee02439dd9f7a7248614deec258" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;NULL&lt;/code&gt; is suitable where supply and recognition of a value is important but the actual value is not.</source>
          <target state="translated">Тип &lt;code&gt;NULL&lt;/code&gt; подходит для случаев, когда передача и распознавание значения важны, а фактическое значение - нет.</target>
        </trans-unit>
        <trans-unit id="8f171db85c218b70d6addcc8e6fc151a7cbbadd9" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is used whenever a unique identity is required. An ASN.1 module, a transfer syntax, and so on, is identified with an &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. Assume the following example:</source>
          <target state="translated">Тип &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; используется всякий раз, когда требуется уникальная идентичность. Модуль ASN.1, синтаксис передачи и т. Д. Идентифицируются &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; . Предположим следующий пример:</target>
        </trans-unit>
        <trans-unit id="9360300fbf341e9ae2dadc1fc262f79e78fb2fc1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TimeOut&lt;/code&gt; has the default value &lt;code&gt;infinity&lt;/code&gt;, so for instance:</source>
          <target state="translated">Тип &lt;code&gt;TimeOut&lt;/code&gt; имеет значение по умолчанию &lt;code&gt;infinity&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="25b9026ac150bd3535441298ee5fe811ce22b776" translate="yes" xml:space="preserve">
          <source>The type a port has when it is opened, but not bound to any file descriptor.</source>
          <target state="translated">Тип порта,когда он открыт,но не привязан ни к какому файловому дескриптору.</target>
        </trans-unit>
        <trans-unit id="92d522e36d256191ae801d58140abe1b10a81a7f" translate="yes" xml:space="preserve">
          <source>The type checking in the SEQUENCE construct is non-strict (i.e. subtypes may be specified). The reason for this is that some standard MIBs use this.</source>
          <target state="translated">Проверка типа в конструкции SEQUENCE не является жесткой (т.е.могут быть указаны подтипы).Причина этого заключается в том,что в некоторых стандартных MIB это используется.</target>
        </trans-unit>
        <trans-unit id="1be2df477daeda02d0883ed07f5157d20b6857d8" translate="yes" xml:space="preserve">
          <source>The type definition for a child specification is as follows:</source>
          <target state="translated">Определение типа для спецификации ребенка следующее:</target>
        </trans-unit>
        <trans-unit id="a191726a17db26ad276e59c3d2dbd9a5d58a79fa" translate="yes" xml:space="preserve">
          <source>The type definition of a child specification is as follows:</source>
          <target state="translated">Определение типа спецификации ребенка выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="6def97965eb0171fce707fed1d80f680f68afe44" translate="yes" xml:space="preserve">
          <source>The type name is the atom &lt;code&gt;my_struct_type&lt;/code&gt;, followed by parentheses. &lt;code&gt;Type&lt;/code&gt; is a type as defined in the previous section. A current restriction is that &lt;code&gt;Type&lt;/code&gt; can contain only predefined types, or user-defined types which are either of the following:</source>
          <target state="translated">Имя типа - это атом &lt;code&gt;my_struct_type&lt;/code&gt; , за которым следуют круглые скобки. &lt;code&gt;Type&lt;/code&gt; - это тип, определенный в предыдущем разделе. Текущее ограничение состоит в том, что &lt;code&gt;Type&lt;/code&gt; может содержать только предопределенные типы или определяемые пользователем типы, которые могут быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="309c924e1cd088d894f3ed5124531ce4037037e9" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">Тип &lt;code&gt;Val&lt;/code&gt; зависит от &lt;code&gt;Item&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55a401f10752570792b382f21d74eedbc9c46cc7" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">Тип &lt;code&gt;Val&lt;/code&gt; зависит от значения &lt;code&gt;Tag&lt;/code&gt; , дополнительную информацию см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88149033eb0717d0b52143637014a89740d11a73" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">Тип &lt;code&gt;Val&lt;/code&gt; зависит от значения &lt;code&gt;Tag&lt;/code&gt; , для получения дополнительной информации см. &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5d162e866719ba45f57bb291d7dab0d1fc5d64" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">Тип &lt;code&gt;Val&lt;/code&gt; зависит от значения &lt;code&gt;Tag&lt;/code&gt; , дополнительную информацию см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; о менеджере&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="329ae914482ca32cea66526a39a0dbcd107a797e" translate="yes" xml:space="preserve">
          <source>The type of the AVP as specified in the dictionary file in question (or one it inherits). Possible types are &lt;code&gt;undefined&lt;/code&gt; and the Diameter types: &lt;code&gt;OctetString&lt;/code&gt;, &lt;code&gt;Integer32&lt;/code&gt;, &lt;code&gt;Integer64&lt;/code&gt;, &lt;code&gt;Unsigned32&lt;/code&gt;, &lt;code&gt;Unsigned64&lt;/code&gt;, &lt;code&gt;Float32&lt;/code&gt;, &lt;code&gt;Float64&lt;/code&gt;, &lt;code&gt;Grouped&lt;/code&gt;, &lt;code&gt;Enumerated&lt;/code&gt;, &lt;code&gt;Address&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;UTF8String&lt;/code&gt;, &lt;code&gt;DiameterIdentity&lt;/code&gt;, &lt;code&gt;DiameterURI&lt;/code&gt;, &lt;code&gt;IPFilterRule&lt;/code&gt; and &lt;code&gt;QoSFilterRule&lt;/code&gt;.</source>
          <target state="translated">Тип AVP, указанный в рассматриваемом файле словаря (или в том, который он наследует). Возможные типы &lt;code&gt;undefined&lt;/code&gt; и типы Диаметр: &lt;code&gt;OctetString&lt;/code&gt; , &lt;code&gt;Integer32&lt;/code&gt; , &lt;code&gt;Integer64&lt;/code&gt; , &lt;code&gt;Unsigned32&lt;/code&gt; , &lt;code&gt;Unsigned64&lt;/code&gt; , &lt;code&gt;Float32&lt;/code&gt; , &lt;code&gt;Float64&lt;/code&gt; , &lt;code&gt;Grouped&lt;/code&gt; , &lt;code&gt;Enumerated&lt;/code&gt; , &lt;code&gt;Address&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;UTF8String&lt;/code&gt; , &lt;code&gt;DiameterIdentity&lt;/code&gt; , &lt;code&gt;DiameterURI&lt;/code&gt; , &lt;code&gt;IPFilterRule&lt;/code&gt; и &lt;code&gt;QoSFilterRule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4be47d081c9f00e1e008293842739b1e591c97" translate="yes" xml:space="preserve">
          <source>The type of the file.</source>
          <target state="translated">Тип файла.</target>
        </trans-unit>
        <trans-unit id="e102bd5c8529a3fcee9a46e71dac57efe0a0a2dd" translate="yes" xml:space="preserve">
          <source>The type of the padding as provided in the call ot &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0aaded2e1891fac9206e8409a5f01261f2d116" translate="yes" xml:space="preserve">
          <source>The type tag of a syntax tree node may also be used as a primary tag by the &lt;code&gt;erl_parse&lt;/code&gt; representation; in that case, the selector functions for that node type &lt;strong&gt;must&lt;/strong&gt; handle both the abstract syntax tree and the &lt;code&gt;erl_parse&lt;/code&gt; form. The function &lt;code&gt;type(T)&lt;/code&gt; should return the correct type tag regardless of the representation of &lt;code&gt;T&lt;/code&gt;, so that the user sees no difference between &lt;code&gt;erl_syntax&lt;/code&gt; and &lt;code&gt;erl_parse&lt;/code&gt; nodes.</source>
          <target state="translated">Тег типа узла синтаксического дерева может также использоваться в качестве основного тега в представлении &lt;code&gt;erl_parse&lt;/code&gt; ; в этом случае функции селектора для этого типа узла &lt;strong&gt;должны&lt;/strong&gt; обрабатывать как абстрактное синтаксическое дерево, так и форму &lt;code&gt;erl_parse&lt;/code&gt; . Тип функции &lt;code&gt;type(T)&lt;/code&gt; должен возвращать тег правильного типа независимо от представления &lt;code&gt;T&lt;/code&gt; , чтобы пользователь не видел разницы между &lt;code&gt;erl_syntax&lt;/code&gt; и &lt;code&gt;erl_parse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe3202d206f4f93d7d4689f53e891b3fc4e897bc" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt; have been removed from the standard since 1994. It is recommended not to use these types any more. They can, however, exist in some old ASN.1 modules. The idea with this type was to leave a &quot;hole&quot; in a definition where it was possible to put unspecified data of any kind, even non-ASN.1 data.</source>
          <target state="translated">Типы &lt;code&gt;ANY&lt;/code&gt; и &lt;code&gt;ANY DEFINED BY&lt;/code&gt; были удалены из стандарта с 1994 года. Рекомендуется больше не использовать эти типы. Однако они могут присутствовать в некоторых старых модулях ASN.1. Идея этого типа заключалась в том, чтобы оставить &amp;laquo;дыру&amp;raquo; в определении, куда можно было бы поместить неуказанные данные любого типа, даже данные, не относящиеся к ASN.1.</target>
        </trans-unit>
        <trans-unit id="7d97ad7fc3d758f8f7503253b112a82e8b959c1f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;EXTERNAL&lt;/code&gt;, &lt;code&gt;EMBEDDED PDV&lt;/code&gt;, and &lt;code&gt;CHARACTER STRING&lt;/code&gt; are used in presentation layer negotiation. They are encoded according to their associated type, see X.680.</source>
          <target state="translated">Типы &lt;code&gt;EXTERNAL&lt;/code&gt; , &lt;code&gt;EMBEDDED PDV&lt;/code&gt; и &lt;code&gt;CHARACTER STRING&lt;/code&gt; используются при согласовании уровня представления. Они кодируются в соответствии с их ассоциированным типом, см. X.680.</target>
        </trans-unit>
        <trans-unit id="31206f08c9e0b285f83486faa623acb15de23275" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt; correspond to the concept of an array in several programming languages. The Erlang syntax for both types is straightforward, for example:</source>
          <target state="translated">Типы &lt;code&gt;SET OF&lt;/code&gt; и &lt;code&gt;SEQUENCE OF&lt;/code&gt; соответствуют концепции массива в нескольких языках программирования. Синтаксис Erlang для обоих типов прост, например:</target>
        </trans-unit>
        <trans-unit id="b29412cfed4840e6735cd1786ded80d86e51e8fe" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt; specifies encoding/decoding of the &lt;strong&gt;Unicode Transformation Format&lt;/strong&gt;s UTF-8, UTF-16, and UTF-32, respectively.</source>
          <target state="translated">Типы &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; и &lt;code&gt;utf32&lt;/code&gt; определяют кодирование / декодирование &lt;strong&gt;форматов преобразования Unicode&lt;/strong&gt; UTF-8, UTF-16 и UTF-32 соответственно.</target>
        </trans-unit>
        <trans-unit id="45d28fc4f610ea2772ed9802ce16df2bd01cc6f6" translate="yes" xml:space="preserve">
          <source>The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt; relative_product/2&lt;/a&gt;&lt;/code&gt;, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397ab02499d0458aff045535e75d83bc31f4cbeb" translate="yes" xml:space="preserve">
          <source>The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt;, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.</source>
          <target state="translated">Типы используются для реализации различных условий, которым должны соответствовать наборы. В качестве примера рассмотрим относительное произведение двух множеств R и S и напомним, что относительное произведение R и S определено, если R - бинарное отношение к Y, а S - бинарное отношение из Y. Функция, реализующая относительное product, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt; , проверяет, что аргументы представляют бинарные отношения, сопоставляя [{A, B}] с типом первого аргумента (например, Arg1) и [{C, D}] с типом второго аргумента (например, Arg2). Тот факт, что [{A, B}] соответствует типу Arg1, следует интерпретировать как Arg1, представляющий бинарное отношение от X к Y, где X определяется как все наборы Set (x) для некоторого элемента x in Наборы типа который является A, и аналогично для Y. Таким же образом Arg2 интерпретируется как представление бинарного отношения от W к Z. Наконец, проверяется, что B соответствует C, что достаточно, чтобы гарантировать, что W равно Y. Нетипизированный пустой set обрабатывается отдельно: его тип, ['_'], соответствует типу любого неупорядоченного набора.</target>
        </trans-unit>
        <trans-unit id="92a2f2f4039eb9cab39f41c392f86d30d282c1cf" translate="yes" xml:space="preserve">
          <source>The types of errors that may occur can be divide into the following categories.</source>
          <target state="translated">Виды ошибок,которые могут возникнуть,можно разделить на следующие категории.</target>
        </trans-unit>
        <trans-unit id="ccc80a70996f3fb5f7ac83b02a6f6f55b6b8c98c" translate="yes" xml:space="preserve">
          <source>The types of record fields can be specified in the declaration of the record. The syntax for this is as follows:</source>
          <target state="translated">Типы полей записи могут быть указаны в объявлении записи.Синтаксис для этого следующий:</target>
        </trans-unit>
        <trans-unit id="b0b9fd9ae89eff0834b9b47daece1217c2da1a05" translate="yes" xml:space="preserve">
          <source>The types that follow do a type test of the operand at runtime; thus, they are generally more expensive in terms of runtime than the types described earlier. However, those operand types are needed to avoid a combinatorial explosion in the number of specific instructions and overall code size of &lt;code&gt;process_main()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b6e93a6a81ebbecd527612eefc77626b9faa25" translate="yes" xml:space="preserve">
          <source>The types that follows are all applied to an operand that has the &lt;code&gt;u&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015a6a68261fd2baee3f181670e406ef25582853" translate="yes" xml:space="preserve">
          <source>The typical round-trip of a message can be viewed as follows. Firstly we view the call flow on the originating side:</source>
          <target state="translated">Типичную поездку туда-обратно можно просмотреть следующим образом.Сначала мы рассматриваем поток звонка на исходной стороне:</target>
        </trans-unit>
        <trans-unit id="ffb34ce1e3c3b26351d07518729543600aa64ad5" translate="yes" xml:space="preserve">
          <source>The typical use case for &lt;code&gt;write_concurrency&lt;/code&gt; is when concurrent calls to &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#sub-3&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; toward the same counters are very frequent, while calls to &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;get &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;put&lt;/a&gt;&lt;/code&gt; are much less frequent. The lack of absolute read consistency must also be acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a092e2bd3b4745048655568b0b490cb79d98d82c" translate="yes" xml:space="preserve">
          <source>The unit of measurement is memory words. There exists both a 32-bit and a 64-bit implementation. A word is therefore 4 bytes or 8 bytes, respectively.</source>
          <target state="translated">Единицей измерения являются слова памяти.Существует как 32-битная,так и 64-битная реализация.Следовательно,слово составляет 4 байта или 8 байт соответственно.</target>
        </trans-unit>
        <trans-unit id="d78579febd40e018de674b923ab2dd8480cc6d1a" translate="yes" xml:space="preserve">
          <source>The unit size is given as &lt;code&gt;unit:IntegerLiteral&lt;/code&gt;. The allowed range is 1-256. It is multiplied by the &lt;code&gt;Size&lt;/code&gt; specifier to give the effective size of the segment. The unit size specifies the alignment for binary segments without size.</source>
          <target state="translated">Размер единицы задается как &lt;code&gt;unit:IntegerLiteral&lt;/code&gt; . Допустимый диапазон - 1-256. Он умножается на спецификатор &lt;code&gt;Size&lt;/code&gt; чтобы получить эффективный размер сегмента. Размер блока определяет выравнивание для двоичных сегментов без размера.</target>
        </trans-unit>
        <trans-unit id="5ee4d7b5711971b4db427f1d7dcb1848a313bcc2" translate="yes" xml:space="preserve">
          <source>The unload request is registered, but other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; still hold the driver. Notice that the term &lt;code&gt;pending_process&lt;/code&gt; can refer to the running process; there can be more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; in the same process.</source>
          <target state="translated">Запрос на выгрузку зарегистрирован, но другие &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; прежнему держат драйвер. Обратите внимание, что термин &lt;code&gt;pending_process&lt;/code&gt; может относиться к запущенному процессу; в одном процессе может быть более одного &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92c5b2b8040b8ecbc28851e51c3e75943648293" translate="yes" xml:space="preserve">
          <source>The unloading/loading is done as one atomic operation, blocking all processes in the system from using the driver in question while in progress.</source>
          <target state="translated">Разгрузка/выгрузка производится как одна атомная операция,блокируя все процессы в системе от использования данного драйвера в процессе работы.</target>
        </trans-unit>
        <trans-unit id="b2bb7ad491dec5db9c49126bb51367d385e40bcc" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt64&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt64&lt;/code&gt; are always 64 bits wide. They were introduced in ERTS 5.7.4.</source>
          <target state="translated">Целочисленный тип данных без знака &lt;code&gt;ErlDrvUInt64&lt;/code&gt; и целочисленный тип данных &lt;code&gt;ErlDrvSInt64&lt;/code&gt; со знаком всегда имеют ширину 64 бита. Они были введены в ERTS 5.7.4.</target>
        </trans-unit>
        <trans-unit id="06cd090adf77b790656c62fa3caa0f561db0b42b" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt&lt;/code&gt; are 64 bits wide on a 64-bit runtime system and 32 bits wide on a 32-bit runtime system. They were introduced in ERTS 5.6 and replaced some of the &lt;code&gt;int&lt;/code&gt; arguments in the list above.</source>
          <target state="translated">Целочисленный тип данных без знака &lt;code&gt;ErlDrvUInt&lt;/code&gt; и целочисленный тип данных &lt;code&gt;ErlDrvSInt&lt;/code&gt; со знаком имеют ширину 64 бита в 64-битной системе времени выполнения и 32 бита в 32-битной системе времени выполнения. Они были введены в ERTS 5.6 и заменили некоторые аргументы типа &lt;code&gt;int&lt;/code&gt; в приведенном выше списке.</target>
        </trans-unit>
        <trans-unit id="d4dbe8cb85a6484b8db2e5ddc4f7e81602e6c250" translate="yes" xml:space="preserve">
          <source>The unsigned integer value of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Беззнаковое целое значение &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="634b3eb0cccf55ffe20b68558982833221c90d25" translate="yes" xml:space="preserve">
          <source>The unsleeping reader may notice that the ACC times for &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; and &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; is not equal between the paragraphs above, even though it is easy to believe that &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; is just a passthrough function.</source>
          <target state="translated">Не спящий читатель может заметить, что времена ACC для &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; и &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; не равны между параграфами выше, хотя легко поверить, что &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; - это просто функция пересылки.</target>
        </trans-unit>
        <trans-unit id="53c140ed888506c0fa3ce30e4732a3ab8d9bef72" translate="yes" xml:space="preserve">
          <source>The upgrade is done in two phases: first the server is asked for permission to upgrade. Second, if the request is acknowledged, the upgrade to tls is performed.</source>
          <target state="translated">Обновление производится в два этапа:сначала серверу запрашивается разрешение на обновление.Во-вторых,если запрос подтвержден,обновление до tls выполняется.</target>
        </trans-unit>
        <trans-unit id="f1abe4219b1176145faaf51a5d5248cfe9c5cdbb" translate="yes" xml:space="preserve">
          <source>The upgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;upgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">Затем сценарий обновления можно оценить с помощью &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; . Вместо этого рекомендуется использовать &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; , но эта функция ( &lt;code&gt;upgrade_script&lt;/code&gt; ) полезна для проверки содержимого сценария.</target>
        </trans-unit>
        <trans-unit id="66b6bbe8cee241bbe5ef7774f674afa0a63f5765" translate="yes" xml:space="preserve">
          <source>The upgrade was refused by the LDAP server. The &lt;code&gt;ResponseFromServer&lt;/code&gt; is an atom delivered byt the LDAP server explained in section 2.3 of rfc 2830. The connection is not affected, so it is still un-encrypted.</source>
          <target state="translated">Сервер LDAP отказался от обновления. &lt;code&gt;ResponseFromServer&lt;/code&gt; представляет собой атом доставлены бет сервера LDAP описан в разделе 2.3 RFC 2830. соединения не влияют, так что это еще не-зашифровано.</target>
        </trans-unit>
        <trans-unit id="24e4c40c9265bed4ba5b9b42f433f1e4b84ab6f0" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the allocated block size histograms. Defaults to 128.</source>
          <target state="translated">Верхняя граница первого интервала в выделенных гистограммах размера блока.По умолчанию 128.</target>
        </trans-unit>
        <trans-unit id="cbc1809e93754ae11d777adddcabee5582e3ea4f" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the free block size histograms. Defaults to 512.</source>
          <target state="translated">Верхняя граница первого интервала на гистограммах свободного размера блока.По умолчанию 512.</target>
        </trans-unit>
        <trans-unit id="49138c2017ae769df1dbe3fdeaaab6a9e2775cc2" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval is provided by the function that returned the histogram, and the last interval has no upper bound.</source>
          <target state="translated">Верхняя граница первого интервала обеспечивается функцией,возвращающей гистограмму,а последний интервал не имеет верхней границы.</target>
        </trans-unit>
        <trans-unit id="0dc8cf3ce6b3c8880a720af10de4f0e69e030978" translate="yes" xml:space="preserve">
          <source>The uppercase escapes match the inverse sets of characters. Notice that \d matches only decimal digits, while \w matches any Unicode digit, any Unicode letter, and underscore. Notice also that &lt;code&gt;ucp&lt;/code&gt; affects \b and \B, as they are defined in terms of \w and \W. Matching these sequences is noticeably slower when &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">Прописные escape-символы соответствуют обратным наборам символов. Обратите внимание, что \ d соответствует только десятичным цифрам, а \ w соответствует любой цифре Unicode, любой букве Unicode и подчеркиванию. Также обратите внимание, что &lt;code&gt;ucp&lt;/code&gt; влияет на \ b и \ B, поскольку они определены в терминах \ w и \ W. Согласование этих последовательностей заметно медленнее, когда установлен &lt;code&gt;ucp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b043a2c5698c1e7d1fd873979502125e49e702d8" translate="yes" xml:space="preserve">
          <source>The use and effect of the actions are as follows:</source>
          <target state="translated">Использование и эффект от действий выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="ca7d622dd82e1d3aeae321fc0b43126901f71c4f" translate="yes" xml:space="preserve">
          <source>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is only a block of memory allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt; enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. A handle (&quot;safe pointer&quot;) to this memory block can then be returned to Erlang by the use of &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt; enif_make_resource&lt;/a&gt;&lt;/code&gt;. The term returned by &lt;code&gt;enif_make_resource&lt;/code&gt; is opaque in nature. It can be stored and passed between processes, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt; enif_get_resource&lt;/a&gt;&lt;/code&gt; and get back a pointer to the memory block, which is guaranteed to still be valid. A resource object is not deallocated until the last handle term is garbage collected by the VM and the resource is released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt; (not necessarily in that order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea64d7717e78cf5f593ec4e6046b9c45fcf5ca9f" translate="yes" xml:space="preserve">
          <source>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is only a block of memory allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. A handle (&quot;safe pointer&quot;) to this memory block can then be returned to Erlang by the use of &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;. The term returned by &lt;code&gt;enif_make_resource&lt;/code&gt; is opaque in nature. It can be stored and passed between processes, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; and get back a pointer to the memory block, which is guaranteed to still be valid. A resource object is not deallocated until the last handle term is garbage collected by the VM and the resource is released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; (not necessarily in that order).</source>
          <target state="translated">Использование объектов ресурсов - это безопасный способ возврата указателей на собственные структуры данных из NIF. Объект ресурса - это только блок памяти, выделенный с помощью &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; . Дескриптор (&amp;laquo;безопасный указатель&amp;raquo;) этого блока памяти может быть затем возвращен в Erlang с помощью &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; . Термин, возвращаемый &lt;code&gt;enif_make_resource&lt;/code&gt; , непрозрачен по своей природе. Его можно хранить и передавать между процессами, но единственное реальное конечное использование - это передать его в качестве аргумента NIF. Затем NIF может вызвать &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; и вернуть указатель на блок памяти, который гарантированно останется действительным. Объект ресурса не освобождается до тех пор, пока виртуальная машина не соберет последний элемент дескриптора, и ресурс не будет освобожден с &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; (не обязательно в таком порядке).</target>
        </trans-unit>
        <trans-unit id="7d704eb78317ca9acd08384d4f2bcb2bb1355fb7" translate="yes" xml:space="preserve">
          <source>The use of the &lt;code&gt;flags&lt;/code&gt; field is that any flag provided must exist for the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd42e11d00d705e28195f82bd49864a0d14541e" translate="yes" xml:space="preserve">
          <source>The use of the match operator is particularly useful for pulling apart Erlang terms and creating new ones.</source>
          <target state="translated">Использование оператора сравнения особенно полезно для разбора терминов Erlang и создания новых.</target>
        </trans-unit>
        <trans-unit id="9361a4a5f036e16a92bbb4fe0af3e2c751d37ab7" translate="yes" xml:space="preserve">
          <source>The use of this option has always been discouraged. As from R14A, it is an error to use it.</source>
          <target state="translated">Использование этой опции всегда было обескураживающим.Как и в случае с R14A,его использование является ошибкой.</target>
        </trans-unit>
        <trans-unit id="6184f0737f651dbcd0feb09612ee2a07afce0951" translate="yes" xml:space="preserve">
          <source>The use of this strategy of abandoning carriers with poor utilization and reusing them in allocator instances with an increased carrier demand is extremely effective and completely eliminates the problems that otherwise sometimes occurred when CPU load dropped while memory load did not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7051fa8cce86b7e9e63652f268c7db87c6180ee0" translate="yes" xml:space="preserve">
          <source>The used memory for all ETS tables.</source>
          <target state="translated">Использованная память для всех таблиц ETS.</target>
        </trans-unit>
        <trans-unit id="8f9be74fa1ece2bebb8a5ba0433d42158ebba618" translate="yes" xml:space="preserve">
          <source>The user &lt;code&gt;otptest&lt;/code&gt;, which has bash as default shell, uses the &lt;code&gt;ssh:shell/1&lt;/code&gt; client to connect to the &lt;strong&gt;openssh&lt;/strong&gt; daemon running on a host called &lt;strong&gt;tarlop&lt;/strong&gt;:</source>
          <target state="translated">Пользователь &lt;code&gt;otptest&lt;/code&gt; , у которого в качестве оболочки по умолчанию используется bash, использует клиент &lt;code&gt;ssh:shell/1&lt;/code&gt; для подключения к демону &lt;strong&gt;openssh&lt;/strong&gt; , запущенному на хосте &lt;strong&gt;tarlop&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d301c340a5de16be3a33995e9e04d1a25c73f970" translate="yes" xml:space="preserve">
          <source>The user can include this AVP as required.</source>
          <target state="translated">Пользователь может включить этот AVP по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="b476a06d8305252521da860471bca0c708d1246d" translate="yes" xml:space="preserve">
          <source>The user can provide a test specification including (for &lt;code&gt;Common Test&lt;/code&gt;) unrecognizable terms. If this is desired, use flag &lt;code&gt;-allow_user_terms&lt;/code&gt; when starting tests with &lt;code&gt;ct_run&lt;/code&gt;. This forces &lt;code&gt;Common Test&lt;/code&gt; to ignore unrecognizable terms. In this mode, &lt;code&gt;Common Test&lt;/code&gt; is not able to check the specification for errors as efficiently as if the scanner runs in default mode. If &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; is used for starting the tests, the relaxed scanner mode is enabled by tuple &lt;code&gt;{allow_user_terms,true}&lt;/code&gt;.</source>
          <target state="translated">Пользователь может предоставить спецификацию теста, включая (для &lt;code&gt;Common Test&lt;/code&gt; ) неузнаваемые термины. Если это желательно, используйте флаг &lt;code&gt;-allow_user_terms&lt;/code&gt; при запуске тестов с &lt;code&gt;ct_run&lt;/code&gt; . Это заставляет &lt;code&gt;Common Test&lt;/code&gt; игнорировать неузнаваемые термины. В этом режиме &lt;code&gt;Common Test&lt;/code&gt; не может проверить спецификацию на наличие ошибок так же эффективно, как если бы сканер работал в режиме по умолчанию. Если &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; используется для запуска тестов, расслабленный режим сканирования включается кортежем &lt;code&gt;{allow_user_terms,true}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aec8dfaf1d2231e245fe0cd75a270293f3d428b2" translate="yes" xml:space="preserve">
          <source>The user can request a range of characters that are to be considered printable in heuristic detection of strings by the shell and by the formatting functions. This is done by supplying &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; when starting Erlang.</source>
          <target state="translated">Пользователь может запросить диапазон символов, которые должны считаться печатаемыми при эвристическом обнаружении строк оболочкой и функциями форматирования. Для этого нужно указать &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; при запуске Erlang.</target>
        </trans-unit>
        <trans-unit id="5ae2400e1fce55a0b4d9b7318948b8627b3d6a40" translate="yes" xml:space="preserve">
          <source>The user can specify a specific group path with parameter &lt;code&gt;group_names_or_paths&lt;/code&gt;. With this type of specification execution of unwanted groups (in otherwise matching paths), and/or the execution of subgroups can be avoided. The command line syntax of the group path is a list of group names in the path, for example:</source>
          <target state="translated">Пользователь может указать конкретный путь к группе с помощью параметра &lt;code&gt;group_names_or_paths&lt;/code&gt; . С помощью этого типа спецификации можно избежать выполнения нежелательных групп (в противном случае совпадающих путей) и / или выполнения подгрупп. Синтаксис командной строки пути к группе - это список имен групп в пути, например:</target>
        </trans-unit>
        <trans-unit id="0130ad65a7625b17e035e835fe6eaf0679e0f246" translate="yes" xml:space="preserve">
          <source>The user can specify configuration data on a different format than key-value tuples in a text file, as described so far. The data can, for example, be read from any files, fetched from the web over HTTP, or requested from a user-specific process. To support this, &lt;code&gt;Common Test&lt;/code&gt; provides a callback module plugin mechanism to handle configuration data.</source>
          <target state="translated">Пользователь может указать данные конфигурации в формате, отличном от формата кортежей &quot;ключ-значение&quot; в текстовом файле, как описано выше. Данные могут, например, быть прочитаны из любых файлов, получены из Интернета через HTTP или запрошены из процесса, специфичного для пользователя. Для поддержки этого &lt;code&gt;Common Test&lt;/code&gt; предоставляет плагин модуля обратного вызова для обработки данных конфигурации.</target>
        </trans-unit>
        <trans-unit id="660461224293f1991c368482cebc005aee961e52" translate="yes" xml:space="preserve">
          <source>The user configures diameter with the identifiers to send at capabilities exchange, along with corresponding dictionaries defining the messages of the applications.</source>
          <target state="translated">Пользователь настраивает диаметр с идентификаторами для отправки при обмене возможностями,а также соответствующие словари,определяющие сообщения приложений.</target>
        </trans-unit>
        <trans-unit id="b475ffe342e790093cd964ba6cc829f6bd45785f" translate="yes" xml:space="preserve">
          <source>The user constructs application-specific messages, but diameter provides failed AVPs in message callbacks. Failed component AVPs are grouped within the relevant Grouped AVPs.</source>
          <target state="translated">Пользователь создает сообщения,специфичные для конкретного приложения,но диаметр обеспечивает отказоустойчивость AVP в ответах на сообщения.Сбойные компоненты AVP группируются в соответствующие сгруппированные AVP.</target>
        </trans-unit>
        <trans-unit id="3591203b72caf861e6110120cbe93c01af2b88a2" translate="yes" xml:space="preserve">
          <source>The user decides whether or not to process a request locally in the request callback from diameter.</source>
          <target state="translated">Пользователь решает,обрабатывать ли запрос локально в обратном вызове по диаметру.</target>
        </trans-unit>
        <trans-unit id="3464961bd356a69bfcff6ac160a461e76a93d25f" translate="yes" xml:space="preserve">
          <source>The user has explicitly cancelled the wait (megaco:cancel/2).</source>
          <target state="translated">Пользователь явно отменил ожидание (megaco:cancel/2).</target>
        </trans-unit>
        <trans-unit id="d18a93e929b37cd21f4c79e7536ff6532ff0f893" translate="yes" xml:space="preserve">
          <source>The user has logged off (the &quot;logoff&quot; message is removed).</source>
          <target state="translated">Пользователь вышел из системы (сообщение &quot;логотип&quot; удалено).</target>
        </trans-unit>
        <trans-unit id="66d08744fcbef8850f22e132fcee2b95959ddf93" translate="yes" xml:space="preserve">
          <source>The user keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Каталог пользовательских ключей можно изменить с помощью опции &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9960888cee8c9b6bfc6612c16d696a491bd6e28" translate="yes" xml:space="preserve">
          <source>The user keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf02e29035334a18d18c5e1b94c79095367bd56" translate="yes" xml:space="preserve">
          <source>The user may (for special purposes) create additional nodes with other type tags, using the &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Пользователь может (для специальных целей) создавать дополнительные узлы с тегами других типов, используя функцию &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddc2e0d09942d83a7b04fe20082be1f80957f4d6" translate="yes" xml:space="preserve">
          <source>The user must also be prepared to receive an abort message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f40f2ea6a4143c3ec3b1ecd54ea0fd079d720a" translate="yes" xml:space="preserve">
          <source>The user name of the OS process running the Erlang virtual machine (emulator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a184f2287a73fa0e22dbeefc3837ae54223d8d" translate="yes" xml:space="preserve">
          <source>The user name, public key and cryptographic data (a signature) that is sent by the client, are used as follows (some steps left out for clearity):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee238ea123b1d44a60398d5285952819fc3ede9" translate="yes" xml:space="preserve">
          <source>The user should implement a scanner that segments the input text, and turns it into one or more lists of tokens. Each token should be a tuple containing information about syntactic category, position in the text (e.g. line number), and the actual terminal symbol found in the text: &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt;.</source>
          <target state="translated">Пользователь должен реализовать сканер, который сегментирует вводимый текст и превращает его в один или несколько списков токенов. Каждый токен должен быть кортежем, содержащим информацию о синтаксической категории, позиции в тексте (например, номер строки) и фактический символ терминала, найденный в тексте: &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c7796fd10aeef2e76370d88ff426dec7a02695" translate="yes" xml:space="preserve">
          <source>The user tag is provided to the user probes triggered by calls top &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; as well as probes in the efile_driver. In the future, user tags might be added to more probes.</source>
          <target state="translated">Пользовательский тег предоставляется пользовательским зондам, запускаемым вызовами top &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; , а также зондам в efile_driver. В будущем пользовательские теги могут быть добавлены к большему количеству зондов.</target>
        </trans-unit>
        <trans-unit id="935cfbe6393df2b605ae54a72dfb24e180f2b45e" translate="yes" xml:space="preserve">
          <source>The user timetrap function can be used for two things as follows:</source>
          <target state="translated">Функция пользовательского расписания может быть использована для двух целей:</target>
        </trans-unit>
        <trans-unit id="2f2130a51941a7dd2f7d9af37266ecb1c20f0d79" translate="yes" xml:space="preserve">
          <source>The user timetrap function can return a time value after a delay. The effective timetrap time is then the delay time &lt;strong&gt;plus&lt;/strong&gt; the returned time.</source>
          <target state="translated">Пользовательская функция timetrap может возвращать значение времени после задержки. Эффективное время прерывания - это время задержки &lt;strong&gt;плюс&lt;/strong&gt; возвращенное время.</target>
        </trans-unit>
        <trans-unit id="b5ee7bda12decc24125202f276f6922f07234b3a" translate="yes" xml:space="preserve">
          <source>The user(s) register their agents.</source>
          <target state="translated">Пользователь(и)регистрирует своих агентов.</target>
        </trans-unit>
        <trans-unit id="1d94abedc5a45d3a00396f6b9115ee0199e9b2d1" translate="yes" xml:space="preserve">
          <source>The user-defined CPU topology can also be set by passing command-line argument &lt;code&gt;+sct&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Определяемую пользователем топологию ЦП также можно установить, передав аргумент командной строки &lt;code&gt;+sct&lt;/code&gt; в &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eac153a48412697b04bd3f7c3679f6e2cb43d77" translate="yes" xml:space="preserve">
          <source>The user-specific handler can be written to handle special configuration file formats. The parameter can be either file names or configuration strings (the empty list is valid).</source>
          <target state="translated">Пользовательский обработчик может быть написан для работы со специальными форматами конфигурационных файлов.Параметром могут быть как имена файлов,так и строки конфигурации (пустой список действителен).</target>
        </trans-unit>
        <trans-unit id="070ed6c048e93f78c36ea8f0ccfec711d97f3991" translate="yes" xml:space="preserve">
          <source>The user/operator can specify the order at will, and maybe a different execution order is sometimes more relevant or efficient.</source>
          <target state="translated">Пользователь/оператор может указывать ордер по своему усмотрению,и,возможно,другой ордер исполнения иногда более актуален или эффективен.</target>
        </trans-unit>
        <trans-unit id="816667b752baf90b5891d2f5483693ef98e188ca" translate="yes" xml:space="preserve">
          <source>The username used for authentication.</source>
          <target state="translated">Имя пользователя,используемое для аутентификации.</target>
        </trans-unit>
        <trans-unit id="32f031cef47e0932c6309630147b6b75921f94b2" translate="yes" xml:space="preserve">
          <source>The utilities are also suitable to use in system testing on large systems, where other tools have too much impact on the system performance. Some primitive support for sequential tracing is also included, see the &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">Утилиты также подходят для тестирования систем в больших системах, где другие инструменты слишком сильно влияют на производительность системы. Также включена некоторая примитивная поддержка последовательной трассировки, см. Раздел &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b998cc802660cc78a04365f6fb84a62e62e8e56" translate="yes" xml:space="preserve">
          <source>The utility &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; provides an alternate compilation interface.</source>
          <target state="translated">Утилита &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; предоставляет альтернативный интерфейс компиляции.</target>
        </trans-unit>
        <trans-unit id="88c9fe090556e5d2d20b460fae9afd89cea9e45c" translate="yes" xml:space="preserve">
          <source>The utility function &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; can be used to easily transform a string of text into a &lt;code&gt;par&lt;/code&gt; representation by splitting it into words.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; функцию text_par / 2 можно использовать для простого преобразования строки текста в представление &lt;code&gt;par&lt;/code&gt; путем разделения ее на слова.</target>
        </trans-unit>
        <trans-unit id="fd02acb46e123ade0af1cb132c81a7c98e6cbd55" translate="yes" xml:space="preserve">
          <source>The utility module &lt;code&gt;msacc(3)&lt;/code&gt; can be used to more easily analyse these statistics.</source>
          <target state="translated">&lt;code&gt;msacc(3)&lt;/code&gt; модуль msacc (3) может использоваться для более простого анализа этой статистики.</target>
        </trans-unit>
        <trans-unit id="86003c423491838636e87b46780a42310a82d73b" translate="yes" xml:space="preserve">
          <source>The valid configuration parameters are as follows:</source>
          <target state="translated">Действительные параметры конфигурации следующие:</target>
        </trans-unit>
        <trans-unit id="98a22ffb82809edcc4e94af08c6c5c821a27b003" translate="yes" xml:space="preserve">
          <source>The valid values are &lt;code&gt;0&lt;/code&gt; (&quot;normal&quot;) and &lt;code&gt;1&lt;/code&gt; (&quot;stderr&quot;), see &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#page/8&quot;&gt;RFC 4254, Section 5.2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb94796638387a4f1cb0c6ac15343b38548969a" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. See the &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; function for more info on the &lt;code&gt;Validate&lt;/code&gt; fun.</source>
          <target state="translated">&lt;code&gt;DateAndTime&lt;/code&gt; от проверки, &lt;code&gt;Validate&lt;/code&gt; , обеспечивает более &amp;laquo;гибкую&amp;raquo; проверку аргумента DateAndTime . Всякий раз, когда обнаруживается, что данные не соответствуют RFC2579, вызывается забава, чтобы обеспечить более &amp;laquo;слабую&amp;raquo; проверку. См. Функцию &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; для получения дополнительной информации о проверке &lt;code&gt;Validate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60c703f2c6b10b3e79aabc8eaf2dfdc52607c370" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. The input to the validation fun looks like this:</source>
          <target state="translated">&lt;code&gt;DateAndTime&lt;/code&gt; от проверки, &lt;code&gt;Validate&lt;/code&gt; , обеспечивает более &amp;laquo;гибкую&amp;raquo; проверку аргумента DateAndTime . Всякий раз, когда обнаруживается, что данные не соответствуют RFC2579, вызывается забава, чтобы обеспечить более &amp;laquo;слабую&amp;raquo; проверку. Входные данные для валидации выглядят так:</target>
        </trans-unit>
        <trans-unit id="58a5e20ed6c2d29e3e861f7702b4763df798e9a1" translate="yes" xml:space="preserve">
          <source>The validity of the options is &lt;strong&gt;not&lt;/strong&gt; checked by the HTTP client they are assumed to be correct and passed on to ssl application and inet driver, which may reject them if they are not correct.</source>
          <target state="translated">Достоверность параметров &lt;strong&gt;не&lt;/strong&gt; проверяется HTTP-клиентом, они считаются правильными и передаются в приложение ssl и драйвер inet, которые могут отклонить их, если они неверны.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
