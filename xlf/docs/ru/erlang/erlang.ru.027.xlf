<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d4dfea1ce63878f9ba8f72e4692fc1e8aa917a62" translate="yes" xml:space="preserve">
          <source>If the port command is aborted, &lt;code&gt;false&lt;/code&gt; is returned, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если команда порта прервана, возвращается &lt;code&gt;false&lt;/code&gt; , в противном случае - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1c15fb5c83bfc2a91269d248f12f67e81fee63b" translate="yes" xml:space="preserve">
          <source>If the port driver does not support synchronous control operations.</source>
          <target state="translated">Если драйвер порта не поддерживает операции синхронного управления.</target>
        </trans-unit>
        <trans-unit id="0d0817e3d68cbd798c7a2e44b1c69c87bcdb5eaf" translate="yes" xml:space="preserve">
          <source>If the port driver so decides for any reason (probably something wrong with &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt;).</source>
          <target state="translated">Если драйвер порта по какой-либо причине так решит (возможно, что-то не так с &lt;code&gt;Operation&lt;/code&gt; или &lt;code&gt;Data&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d151f89de14a3a981ce006759dc3e5172e69a5a" translate="yes" xml:space="preserve">
          <source>If the port has terminated for some reason.</source>
          <target state="translated">Если порт по какой-то причине остановился.</target>
        </trans-unit>
        <trans-unit id="478c30ae507a35c9772a0df1cd3d96a72d57ca57" translate="yes" xml:space="preserve">
          <source>If the port identified by &lt;code&gt;Port&lt;/code&gt; is not open, &lt;code&gt;undefined&lt;/code&gt; is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_info/2&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Если порт, указанный параметром &lt;code&gt;Port&lt;/code&gt; , не открыт, возвращается значение &lt;code&gt;undefined&lt;/code&gt; . Если порт закрыт и вызывающий процесс был ранее связан с этим портом, сигнал выхода из порта гарантированно будет доставлен до того, как &lt;code&gt;port_info/2&lt;/code&gt; вернет значение &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="853a76f0837b416b340a6bf46f68d0b7ffc26aa7" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy any more.</source>
          <target state="translated">Если порт занят,процесс вызова приостанавливается до тех пор,пока порт больше не будет занят.</target>
        </trans-unit>
        <trans-unit id="8e93ad76f9dc1354beffe48343ad7231e136396f" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy anymore.</source>
          <target state="translated">Если порт занят,процесс вызова приостанавливается до тех пор,пока порт больше не будет занят.</target>
        </trans-unit>
        <trans-unit id="6e75c78d0feb81a1196647eabb58d38723b98522" translate="yes" xml:space="preserve">
          <source>If the port program closes its &lt;code&gt;stdout&lt;/code&gt; without exiting, option &lt;code&gt;exit_status&lt;/code&gt; does not work.</source>
          <target state="translated">Если программа порта закрывает свой стандартный &lt;code&gt;stdout&lt;/code&gt; без выхода, опция &lt;code&gt;exit_status&lt;/code&gt; не работает.</target>
        </trans-unit>
        <trans-unit id="db113293208f7fe3c23990353c9eaabbd0d53db0" translate="yes" xml:space="preserve">
          <source>If the port program is to be updated, the code for the &lt;code&gt;gen_server&lt;/code&gt; can be extended with a &lt;code&gt;code_change&lt;/code&gt; function, which closes the old port and opens a new port. (If necessary, the &lt;code&gt;gen_server&lt;/code&gt; can first request data that must be saved from the port program and pass this data to the new port):</source>
          <target state="translated">Если программа порта должна быть обновлена, код для &lt;code&gt;gen_server&lt;/code&gt; может быть расширен с помощью функции &lt;code&gt;code_change&lt;/code&gt; , которая закрывает старый порт и открывает новый порт. (При необходимости &lt;code&gt;gen_server&lt;/code&gt; может сначала запросить данные, которые должны быть сохранены из программы порта, и передать эти данные в новый порт):</target>
        </trans-unit>
        <trans-unit id="38a0c5b075f7274afd3c7af203177b865a7ca3d6" translate="yes" xml:space="preserve">
          <source>If the process calling &lt;code&gt;erlang:resume_process/1&lt;/code&gt; had not previously increased the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt;.</source>
          <target state="translated">Если процесс, вызывающий &lt;code&gt;erlang:resume_process/1&lt;/code&gt; , ранее не увеличивал счетчик приостановки для процесса, указанного &lt;code&gt;Suspendee&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9584990023c5a96bcc22ea4479bca2d11aee6db9" translate="yes" xml:space="preserve">
          <source>If the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;Ret = {error, Reason}&lt;/code&gt; will be returned if the calling process traps exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dde4932a93f8e946ee90206f0656471a4679385" translate="yes" xml:space="preserve">
          <source>If the process does not exist, a &lt;code&gt;noproc&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если процесс не существует, &lt;code&gt;noproc&lt;/code&gt; исключение noproc .</target>
        </trans-unit>
        <trans-unit id="20b1fa7364ea436067720e9fd90a1b6ba70feb9e" translate="yes" xml:space="preserve">
          <source>If the process executing the call does not belong to any application, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Если процесс, выполняющий вызов, не принадлежит ни одному приложению, функция возвращает &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581efb60de5599bb6f030da89d279c27e9892d5a" translate="yes" xml:space="preserve">
          <source>If the process has any message in its message queue, the process is awakened immediately in the same way as described earlier.</source>
          <target state="translated">Если в очереди сообщений процесса есть какое-либо сообщение,то процесс пробуждается немедленно так же,как описано выше.</target>
        </trans-unit>
        <trans-unit id="084bfd0c081f4fee78443d764a32418d4196357e" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; has a registered name, also an &lt;code&gt;InfoTuple&lt;/code&gt; with item &lt;code&gt;registered_name&lt;/code&gt; is included.</source>
          <target state="translated">Если процесс идентифицируется &lt;code&gt;Pid&lt;/code&gt; имеет зарегистрированное название, также &lt;code&gt;InfoTuple&lt;/code&gt; с товаром &lt;code&gt;registered_name&lt;/code&gt; входит.</target>
        </trans-unit>
        <trans-unit id="b81261e08e1610fbb4a750870cfa04d7610f65e5" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local process.</source>
          <target state="translated">Если процесс, идентифицированный &lt;code&gt;Pid&lt;/code&gt; , не является существующим локальным процессом.</target>
        </trans-unit>
        <trans-unit id="6f56d002efe6106da3a84a3e2016c451482b68c7" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &amp;gt; 2,000,000,000 suspends and will never be lower.</source>
          <target state="translated">Если процесс, указанный параметром &lt;code&gt;Suspendee&lt;/code&gt; , был приостановлен вызывающим процессом больше раз, чем это может быть представлено текущими используемыми внутренними структурами данных. Системный лимит составляет&amp;gt; 2 000 000 000 приостановок и никогда не будет ниже.</target>
        </trans-unit>
        <trans-unit id="036dbfabe540cf1c1a2eb6e8693ac0992c59c911" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is greater than 2,000,000,000 suspends and will never be lower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6414a88b13aa6c8a9b8f6f5c8c66d946440583" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is not alive.</source>
          <target state="translated">Если процесс, идентифицированный &lt;code&gt;Suspendee&lt;/code&gt; , не работает.</target>
        </trans-unit>
        <trans-unit id="641aca5b56bf74307b3adf498b7c5e8e5c4b1259" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is the same process as the process calling &lt;code&gt;erlang:suspend_process/2&lt;/code&gt;.</source>
          <target state="translated">Если процесс, идентифицированный &lt;code&gt;Suspendee&lt;/code&gt; является тем же процессом, что и процесс, вызывающий &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651c23453333c69005cd277bbe1fcf8cf3b85f49" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; resides on another node.</source>
          <target state="translated">Если процесс, идентифицированный &lt;code&gt;Suspendee&lt;/code&gt; находится на другом узле.</target>
        </trans-unit>
        <trans-unit id="e4ca7dc0b151bb1f9cd8a2a4aff6bffd4a0444e4" translate="yes" xml:space="preserve">
          <source>If the process is alive and a single &lt;code&gt;Item&lt;/code&gt; is specified, the returned value is the corresponding &lt;code&gt;InfoTuple&lt;/code&gt;, unless &lt;code&gt;Item =:= registered_name&lt;/code&gt; and the process has no registered name. In this case, &lt;code&gt;[]&lt;/code&gt; is returned. This strange behavior is because of historical reasons, and is kept for backward compatibility.</source>
          <target state="translated">Если процесс &lt;code&gt;InfoTuple&lt;/code&gt; указан один &lt;code&gt;Item&lt;/code&gt; , возвращаемое значение является соответствующей инфо-подборкой , если только &lt;code&gt;Item =:= registered_name&lt;/code&gt; и процесс не имеет зарегистрированного имени. В этом случае возвращается &lt;code&gt;[]&lt;/code&gt; . Такое странное поведение объясняется историческими причинами и сохраняется для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="1a9a0fee2f5bd85201e0094b8e33070b42b45236" translate="yes" xml:space="preserve">
          <source>If the process is to replace its state using the fun &lt;code&gt;StateFun&lt;/code&gt;, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">Если процесс должен заменить свое состояние с помощью забавного &lt;code&gt;StateFun&lt;/code&gt; , &lt;code&gt;handle_system_msg&lt;/code&gt; вызывает:</target>
        </trans-unit>
        <trans-unit id="3df3174e4f4f8d76818b78c9db43318524d54225" translate="yes" xml:space="preserve">
          <source>If the process is to return its state, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">Если процесс должен вернуть свое состояние, &lt;code&gt;handle_system_msg&lt;/code&gt; вызывает:</target>
        </trans-unit>
        <trans-unit id="54575a5d04700d078536008be3d7a71568b2f2f0" translate="yes" xml:space="preserve">
          <source>If the process or port is already registered (already has a name).</source>
          <target state="translated">Если процесс или порт уже зарегистрирован (уже имеет имя).</target>
        </trans-unit>
        <trans-unit id="72499bc5509543fc3c3a1dc36c89e29a09a5bee5" translate="yes" xml:space="preserve">
          <source>If the process potentially can get many messages in its queue, you are advised to set the flag to &lt;code&gt;off_heap&lt;/code&gt;. This because a garbage collection with many messages placed on the heap can become extremely expensive and the process can consume large amounts of memory. Performance of the actual message passing is however generally better when not using flag &lt;code&gt;off_heap&lt;/code&gt;.</source>
          <target state="translated">Если процесс потенциально может получить много сообщений в своей очереди, рекомендуется установить флаг &lt;code&gt;off_heap&lt;/code&gt; . Это связано с тем, что сборка мусора с большим количеством сообщений, помещенных в кучу, может стать чрезвычайно дорогостоящим, а процесс может потреблять большие объемы памяти. Однако производительность фактической передачи сообщений, как правило, лучше, если не использовать флаг &lt;code&gt;off_heap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2977b37e3f3fa2bacc4a55c85d9c30b69a4999c8" translate="yes" xml:space="preserve">
          <source>If the process terminates with another reason than &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;shutdown&lt;/code&gt;, a crash report is generated. For more information about the crash report, see the SASL User's Guide.</source>
          <target state="translated">Если процесс завершается по другой причине, кроме &lt;code&gt;normal&lt;/code&gt; или &lt;code&gt;shutdown&lt;/code&gt; , создается отчет о сбое. Для получения дополнительной информации об отчете о сбоях см. Руководство пользователя SASL.</target>
        </trans-unit>
        <trans-unit id="24d7be87e875bc81d2fad8f3b3e621f25756c364" translate="yes" xml:space="preserve">
          <source>If the process was spawned using a fun, &lt;code&gt;initial_call/1&lt;/code&gt; no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (meaning that the fun was created in function &lt;code&gt;some_module:work/3&lt;/code&gt;). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.</source>
          <target state="translated">Если процесс был запущен с использованием развлечения, &lt;code&gt;initial_call/1&lt;/code&gt; больше не возвращает удовольствие, но модуль, функция для локальной функции, реализующей удовольствие, и арность, например, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (это означает, что веселье было создано в функции &lt;code&gt;some_module:work/3&lt;/code&gt; ). Причина в том, что веселье помешает обновлению кода модуля и может быть потрачено впустую значительный объем памяти.</target>
        </trans-unit>
        <trans-unit id="e063f0c97bd3b9f2ca10490b0726825eb1a13207" translate="yes" xml:space="preserve">
          <source>If the program is too large to be profiled by &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;, &lt;code&gt;cprof&lt;/code&gt; can be used to locate code parts that are to be more thoroughly profiled using &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;.</source>
          <target state="translated">Если программа слишком велика для профилирования с помощью &lt;code&gt;fprof&lt;/code&gt; или &lt;code&gt;eprof&lt;/code&gt; , &lt;code&gt;cprof&lt;/code&gt; можно использовать для поиска частей кода, которые необходимо более тщательно профилировать с помощью &lt;code&gt;fprof&lt;/code&gt; или &lt;code&gt;eprof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c014cbf0073f75ddbbd2b83b405b67fe36da992" translate="yes" xml:space="preserve">
          <source>If the provided public key is not found, the authentication fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62378f1f957382ee8a052b1c61d99645a009e49" translate="yes" xml:space="preserve">
          <source>If the pure encode/decode performance really is a serious issue, our erl_dist encoder could be used, as the encoding/decoding of the erlang distribution format is much faster than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">Если производительность чистого кодирования/декодирования действительно является серьезной проблемой,то можно использовать наш кодировщик erl_dist,так как кодирование/декодирование формата распределения erlang происходит намного быстрее,чем все другие альтернативы.Его основным недостатком является то,что он не был одобрен в качестве действительной кодировки сообщений Megaco/H.248.</target>
        </trans-unit>
        <trans-unit id="a4deb3a5f5f018b337b5754c6b3743ec42918472" translate="yes" xml:space="preserve">
          <source>If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism.</source>
          <target state="translated">Если квантификатор {0},то при совпадении утверждение никогда не подчиняется.Однако,оно может содержать внутренние захватывающие группы в скобках,которые вызываются отовсюду через подпрограммный механизм.</target>
        </trans-unit>
        <trans-unit id="15a112cbde0806d4bd82db516d60932759dd1e88" translate="yes" xml:space="preserve">
          <source>If the regular expression contains capturing subpatterns, like in:</source>
          <target state="translated">Если регулярное выражение содержит захватывающие подмаски,как в:</target>
        </trans-unit>
        <trans-unit id="53c05be9c33eb1a96dab74d00ca7378c333d60b5" translate="yes" xml:space="preserve">
          <source>If the regular expression is previously compiled, the option list can only contain the following options:</source>
          <target state="translated">Если регулярное выражение было скомпилировано ранее,то список опций может содержать только следующие опции:</target>
        </trans-unit>
        <trans-unit id="22619338e12940ef34ae589b0ca2c131b656f3a0" translate="yes" xml:space="preserve">
          <source>If the regular expression was previously compiled with option &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;Subject&lt;/code&gt; is to be provided as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise any &lt;code&gt;iodata()&lt;/code&gt; will do. If compilation is involved and option &lt;code&gt;unicode&lt;/code&gt; is specified, both &lt;code&gt;Subject&lt;/code&gt; and the regular expression are to be specified as valid Unicode &lt;code&gt;charlists()&lt;/code&gt;.</source>
          <target state="translated">Если регулярное выражение было ранее скомпилировано с опцией &lt;code&gt;unicode&lt;/code&gt; , &lt;code&gt;Subject&lt;/code&gt; должен быть предоставлен как действительный &lt;code&gt;charlist()&lt;/code&gt; символов Unicode () , в противном случае &lt;code&gt;iodata()&lt;/code&gt; любой iodata () . Если задействована компиляция и указана опция &lt;code&gt;unicode&lt;/code&gt; , и &lt;code&gt;Subject&lt;/code&gt; , и регулярное выражение должны быть указаны как допустимые &lt;code&gt;charlists()&lt;/code&gt; символов Unicode () .</target>
        </trans-unit>
        <trans-unit id="95cb6c73038fea5d38c77487c266df25c09c2a93" translate="yes" xml:space="preserve">
          <source>If the release is to be upgraded, it must also include the SASL application.</source>
          <target state="translated">Если релиз подлежит обновлению,он также должен включать приложение SASL.</target>
        </trans-unit>
        <trans-unit id="209b3e073d6604d9f31c31d6ea0d348f2a50c0c5" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;.</source>
          <target state="translated">Если пакет выпуска должен содержать новую систему времени выполнения Erlang, каталог &lt;code&gt;bin&lt;/code&gt; указанной системы времени выполнения &lt;code&gt;{erts,Dir}&lt;/code&gt; копируется в &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="363cb8688a551cced7d3018ac246f3d6efe48af3" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;. Some erts executables are not copied by default, if you want to include all executables you can give the &lt;code&gt;erts_all&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f636f7002f64f569ae3d458b76d340d2355447e2" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue, as this function spawns off a middleman process to act as (a void) destination for such an orphan reply. This feature also makes this function more expensive than &lt;code&gt;call/4&lt;/code&gt; at the caller's end.</source>
          <target state="translated">Если ответ приходит после истечения времени ожидания вызова, никакое сообщение не загрязняет очередь сообщений вызывающего абонента, поскольку эта функция порождает процесс-посредник, который действует как (недействительный) адресат для такого сиротского ответа. Эта функция также делает эту функцию более дорогой, чем &lt;code&gt;call/4&lt;/code&gt; на стороне вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="97bf926e93bf111383afef246646bb072493b10d" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72de28ff26e478c709ccef28f5ec9b72f45a4e23" translate="yes" xml:space="preserve">
          <source>If the report browser is used offline, the reports can be copied to another directory specified when starting the browser. If no such directory is specified, the browser reads reports from the SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt;.</source>
          <target state="translated">Если браузер отчетов используется в автономном режиме, отчеты можно скопировать в другой каталог, указанный при запуске браузера. Если такой каталог не указан, браузер читает отчеты из SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d403abf04385b59be919058fa57d3e12c76fe7b9" translate="yes" xml:space="preserve">
          <source>If the request functions for the SFTP channel return &lt;code&gt;{error, timeout}&lt;/code&gt;, no answer was received from the server within the expected time.</source>
          <target state="translated">Если функции запроса для канала SFTP возвращают &lt;code&gt;{error, timeout}&lt;/code&gt; , ответ не был получен от сервера в течение ожидаемого времени.</target>
        </trans-unit>
        <trans-unit id="68fcf1aa779848125b39efeaf9b8566022844620" translate="yes" xml:space="preserve">
          <source>If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, &lt;code&gt;httpd&lt;/code&gt; saves the absolute URI in this field. An Example of an absolute URI is &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</source>
          <target state="translated">Если запрос является запросом HTTP / 1.1, URI может быть в формате абсолютного URI. В этом случае &lt;code&gt;httpd&lt;/code&gt; сохраняет абсолютный URI в этом поле. Пример абсолютного URI: &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf8c6e0e4e32eeefc924406bd2971a4ed6ef9777" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the answer times out then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = timeout&lt;/code&gt;.</source>
          <target state="translated">Если запрос успешно закодирован и отправлен, но время ответа истекло, выполняется обратный вызов &lt;code&gt;handle_error/4&lt;/code&gt; с &lt;code&gt;Reason = timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d362d3cf60cb0af09ab64c13d49db2cee633e8f5" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = cancel&lt;/code&gt;.</source>
          <target state="translated">Если запрос успешно закодирован и отправлен, но рассматриваемая служба остановлена ​​до получения ответа, то выполняется обратный вызов &lt;code&gt;handle_error/4&lt;/code&gt; с &lt;code&gt;Reason = cancel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61d25df3bedf5d0be2cd7d314bbaa9b30da48753" translate="yes" xml:space="preserve">
          <source>If the request reached the peer, was handled and the response reached the requesting node the &lt;code&gt;&lt;a href=&quot;#type-req_status&quot;&gt;req_status()&lt;/a&gt;&lt;/code&gt; is the status reported from the peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9756cb158d71aee0a6ade83d17f9f5f0e83f232d" translate="yes" xml:space="preserve">
          <source>If the requested data is available, the subentry is associated with &lt;code&gt;Name&lt;/code&gt; so that the value of the element can be read with &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; provided &lt;code&gt;Name&lt;/code&gt; is used instead of the whole &lt;code&gt;Required&lt;/code&gt; term.</source>
          <target state="translated">Если запрошенные данные доступны, подстатью связывается с &lt;code&gt;Name&lt;/code&gt; так что значение элемента может быть прочитано с помощью &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; при условии, что &lt;code&gt;Name&lt;/code&gt; используется вместо всего &lt;code&gt;Required&lt;/code&gt; термина.</target>
        </trans-unit>
        <trans-unit id="5e0bd29420b56350fa2aea428f5bb429a285d8aa" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands &lt;code&gt;q()&lt;/code&gt; and &lt;code&gt;init:stop()&lt;/code&gt; is used as fallback.</source>
          <target state="translated">Если ограниченная оболочка активируется путем установки переменной STDLIB во время запуска эмулятора, а модуль обратного вызова не может быть загружен, ограниченная оболочка по умолчанию, разрешающая только команды &lt;code&gt;q()&lt;/code&gt; и &lt;code&gt;init:stop()&lt;/code&gt; , используется как резерв.</target>
        </trans-unit>
        <trans-unit id="724b8206454c6a949fb926da63637eb525b4710d" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt; start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe48dc12c1fe598f1a22c84e21f70cadbb61864" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">Если ограниченная оболочка активируется с помощью &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; и модуль обратного вызова не может быть загружен, отчет об ошибке отправляется регистратору ошибок, и вызов возвращает &lt;code&gt;{error,Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d723ff157f68fb866c4e720b4a0eacba9b30b870" translate="yes" xml:space="preserve">
          <source>If the result of the list comprehension will &lt;strong&gt;obviously&lt;/strong&gt; not be used, a list will not be constructed. For example, in this code:</source>
          <target state="translated">Если результат понимания списка &lt;strong&gt;явно&lt;/strong&gt; не будет использоваться, список не будет построен. Например, в этом коде:</target>
        </trans-unit>
        <trans-unit id="ef688930e9bc0a09ddfd80d412acb665d77d541c" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">Если система времени выполнения находится в режиме &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt; , смещение времени изменяется, когда система времени выполнения обнаруживает, что &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; изменилось. Однако исполняющая система не обнаруживает это сразу, когда это происходит. Задача, проверяющая смещение времени, планируется выполнять не реже одного раза в минуту, поэтому при нормальной работе это должно быть обнаружено в течение минуты, но при большой нагрузке это может занять больше времени.</target>
        </trans-unit>
        <trans-unit id="9ee5563a77256009bf8489bde46cade77b9f2b67" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">Если система времени выполнения находится в режиме &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; , смещение времени изменяется, когда система времени выполнения обнаруживает, что &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; изменилось. Однако исполняющая система не обнаружит это сразу, когда это произойдет. Задача, проверяющая смещение времени, планируется выполнять не реже одного раза в минуту; Таким образом, при нормальной работе это должно быть обнаружено в течение минуты, но при большой нагрузке это может занять больше времени.</target>
        </trans-unit>
        <trans-unit id="842b5ecda8b77bc83a3f2909c3c676e780a3ce01" translate="yes" xml:space="preserve">
          <source>If the same option is set at two different levels, the one at the highest level is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554e754ec098db2cf4c76a2930674bed5aa17796" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="translated">Если используется схема &lt;code&gt;https&lt;/code&gt; , необходимо запустить приложение &lt;code&gt;SSL&lt;/code&gt; . Когда &lt;code&gt;https&lt;/code&gt; - ссылки должны проходить через прокси, расширение метода CONNECT для HTTP-1.1 используется для установления туннеля, а затем соединение обновляется до TLS. Однако &amp;laquo;обновление TLS&amp;raquo; согласно &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt; не поддерживается.</target>
        </trans-unit>
        <trans-unit id="dd39ec873a6f1811f7fd75cdbff8a27a1e922646" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3e2a035a8c91596ec4431ba0d0a851882160c2" translate="yes" xml:space="preserve">
          <source>If the second operand for &lt;code&gt;is_number/2&lt;/code&gt; is a literal, it will be moved to X register 1023. Then &lt;code&gt;is_number/2&lt;/code&gt; will test whether the value stored in X register 1023 is a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c6f2a7a376dda13bb7ffd101ed27e0bb2c89e4" translate="yes" xml:space="preserve">
          <source>If the selected cipher needs to have the input data partioned into blocks of a certain size, the &lt;code&gt;init_fun()&lt;/code&gt; should return the second form of return value with the &lt;code&gt;chunk_size()&lt;/code&gt; set to the block size. If the &lt;code&gt;chunk_size()&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;chunk_size()&lt;/code&gt; is intended for block crypto. A &lt;code&gt;chunk_size()&lt;/code&gt; can be changed in the return from the &lt;code&gt;crypto_fun()&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d199b5f396cd79b8cc290ec04cb85c9575f0f8" translate="yes" xml:space="preserve">
          <source>If the sender would have to be suspended to do the send, &lt;code&gt;nosuspend&lt;/code&gt; is returned instead.</source>
          <target state="translated">Если отправитель должен быть приостановлен для отправки, вместо этого возвращается &lt;code&gt;nosuspend&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="603b5cbedb1c18808b9a489511a61b63ed3b0c0b" translate="yes" xml:space="preserve">
          <source>If the server changes callback module using any of the actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6d3e8ae70c643b6deb59daac018ce037067a9f" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если сервер не указан в файле конфигурации, используйте вместо него &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8838b36f111de63a4782ef1a364bbbead7e4773" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если сервер не указан в файле конфигурации, используйте вместо него &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70355032eca4c9d76df601e10da3a7d335f3ed0d" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in this module), use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если параметры сервера указаны в файле конфигурации или если именованный клиент необходим для ведения журнала (см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; в этом модуле&amp;raquo;), используйте вместо этого &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57f23c3daad60ed51515d51367aea45626c02cd9" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если параметры сервера указаны в файле конфигурации, используйте вместо этого &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dcdba9665f7f05be3244027d112ec31bf32434c" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the &lt;code&gt;sni_hosts&lt;/code&gt; option, the specific options for that host will override previously specified options. The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">Если сервер получает SNI (указание имени сервера) от клиента, соответствующего хосту, указанному в опции &lt;code&gt;sni_hosts&lt;/code&gt; , определенные опции для этого хоста переопределят ранее указанные опции. Опция &lt;code&gt;sni_fun&lt;/code&gt; и &lt;code&gt;sni_hosts&lt;/code&gt; являются взаимоисключающими.</target>
        </trans-unit>
        <trans-unit id="6872d76e7fd0c2b2043184ce306dcf6a44377861" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; list. The function should be defined as: fun(ServerName :: string()) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88346e63ca31b635eaa59afabe4ac1246f3dd96" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;[ssl_option()]&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;[ssl_option()]&lt;/code&gt;. The function should be defined as: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">Если сервер получает SNI (указание имени сервера) от клиента, данная функция будет вызвана для получения &lt;code&gt;[ssl_option()]&lt;/code&gt; для указанного сервера. Эти параметры будут объединены в предопределенный &lt;code&gt;[ssl_option()]&lt;/code&gt; . Функция должна быть определена как: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; и может быть определена как весело или имени &lt;code&gt;fun module:function/1&lt;/code&gt; Опция &lt;code&gt;sni_fun&lt;/code&gt; и &lt;code&gt;sni_hosts&lt;/code&gt; являются взаимоисключающими.</target>
        </trans-unit>
        <trans-unit id="37d0a58e6098abfba1624874ecb647d5100c0c46" translate="yes" xml:space="preserve">
          <source>If the size of the files is decreased, the change immediately affects the current log. It does not change the size of log files already full until the next time they are used.</source>
          <target state="translated">Если размер файлов уменьшится,то изменение сразу же повлияет на текущий журнал.При этом размер уже заполненных лог-файлов не изменяется до следующего их использования.</target>
        </trans-unit>
        <trans-unit id="48531719e2548f233ac5471f827038efdab7d452" translate="yes" xml:space="preserve">
          <source>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</source>
          <target state="translated">Если размер живых данных в процессе меньше минимального размера кучи,то первый сбор мусора,происходящий после пробуждения процесса,гарантирует,что размер кучи будет изменен на размер не меньше минимального размера кучи.</target>
        </trans-unit>
        <trans-unit id="55a92bc9b80ccffb05ef0f4d2b0d2c00367ee298" translate="yes" xml:space="preserve">
          <source>If the skipped test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">Если пропущенный тестовый пример принадлежит группе тестовых примеров, первым аргументом является кортеж &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; , в противном случае - только имя функции.</target>
        </trans-unit>
        <trans-unit id="a70f753063df0478c5593d2eec5283aea16d43ef" translate="yes" xml:space="preserve">
          <source>If the snmp agent is configured as a distributed Erlang application, it will during takeover try to load the same MIBs that were loaded at the old node. It uses the same filenames as the old node. If the MIBs are not located in the same paths at the different nodes, the MIBs must be loaded explicitly after takeover.</source>
          <target state="translated">Если агент snmp настроен как распределенное приложение Erlang,то во время поглощения он попытается загрузить те же MIB,которые были загружены на старом узле.Он использует те же имена файлов,что и старый узел.Если MIB-файлы не расположены одинаковыми путями на разных узлах,то MIB-файлы должны быть загружены явно после поглощения.</target>
        </trans-unit>
        <trans-unit id="512aa9feb42b459cd059aa3fe2168a1e5258567a" translate="yes" xml:space="preserve">
          <source>If the socket is a listen socket, we use a separate (regular) file for two purposes:</source>
          <target state="translated">Если сокет является сокетами для прослушивания,мы используем отдельный (обычный)файл для двух целей:</target>
        </trans-unit>
        <trans-unit id="fc7067034e5330d9330814dab9d3d85a46c9af7c" translate="yes" xml:space="preserve">
          <source>If the socket is closed, the following message is delivered:</source>
          <target state="translated">Если гнездо закрыто,то выдается следующее сообщение:</target>
        </trans-unit>
        <trans-unit id="4128dcf4e6f00732687760eccb66b0c9d45f8d7a" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;active&lt;/a&gt;&lt;/code&gt; mode data received data is delivered to the controlling process as messages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4248f996c2d366444661dd551e1e934e80a81f5" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode data can be received through the &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c734cf077ea6e84216c28020bf0dfe0c224786a4" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details) and its message counter drops to &lt;code&gt;0&lt;/code&gt;, the following message is delivered to indicate that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:</source>
          <target state="translated">Если сокет находится в режиме &lt;code&gt;{active, N}&lt;/code&gt; (подробности см. В &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; ) и его счетчик сообщений падает до &lt;code&gt;0&lt;/code&gt; , доставляется следующее сообщение, указывающее, что сокет перешел в пассивный режим ( &lt;code&gt;{active, false}&lt;/code&gt; ) Режим:</target>
        </trans-unit>
        <trans-unit id="bb22ea2f6ffe71f664a8e18b7f47a0d62e0aa24d" translate="yes" xml:space="preserve">
          <source>If the socket is in a busy state, the socket is set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4 kB.</source>
          <target state="translated">Если сокет находится в состоянии &quot;занято&quot;,то сокет устанавливается в состояние &quot;не занято&quot;,когда количество данных в очереди внутри реализации сокета ERTS опускается ниже этого предела.По умолчанию 4 кБ.</target>
        </trans-unit>
        <trans-unit id="0860cb89a1cd48e8809f57a8b0f0cb44187efe24" translate="yes" xml:space="preserve">
          <source>If the socket is not in an active mode, data can be retrieved through the &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; calls. Notice that arriving UDP packets that are longer than the receive buffer option specifies can be truncated without warning.</source>
          <target state="translated">Если сокет не находится в активном режиме, данные можно получить с помощью вызовов &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что прибывающие пакеты UDP, длина которых превышает длину, заданную параметром буфера приема, могут быть усечены без предупреждения.</target>
        </trans-unit>
        <trans-unit id="479b7a4579a072626569e57eba743d1c2936d55c" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfer is complete may cause this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886690ee1274e874585cd62a60964392f36c218d" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfere is complete may cause this.</source>
          <target state="translated">Если гнездо установлено в активный режим,то данная функция будет передавать любые сообщения в почтовом ящике вызывающего абонента в новый управляющий процесс.Если какой-либо другой процесс взаимодействует с сокетами во время передачи,то передача может работать некорректно,и сообщения могут оставаться в почтовом ящике вызывающего абонента.Например,изменение активного режима сокетов до завершения передачи может привести к этому.</target>
        </trans-unit>
        <trans-unit id="2ef7d7003c6284dd13030d6ae0c0a5544dc8ae67" translate="yes" xml:space="preserve">
          <source>If the socket message queue is in a busy state, the socket message queue is set in a not busy state when the amount of data queued in the message queue falls below this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 4 kB.</source>
          <target state="translated">Если очередь сообщений сокета находится в состоянии &quot;занято&quot;,то очередь сообщений сокета устанавливается в состояние &quot;не занято&quot;,когда количество данных в очереди сообщений опускается ниже этого предела.Обратите внимание,что этот предел касается только тех данных,которые еще не достигли реализации внутреннего сокета ERTS.По умолчанию 4 кБ.</target>
        </trans-unit>
        <trans-unit id="0489cec8cde9abcfab25b3cd056616ee2153c497" translate="yes" xml:space="preserve">
          <source>If the source file and/or the output file cannot be opened using &lt;code&gt;file:open/2&lt;/code&gt;, the function returns &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; where &lt;code&gt;File&lt;/code&gt; is the file name and &lt;code&gt;Reason&lt;/code&gt; is the error reason.</source>
          <target state="translated">Если исходный файл и / или выходной файл не могут быть открыты с помощью &lt;code&gt;file:open/2&lt;/code&gt; , функция возвращает &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; , где &lt;code&gt;File&lt;/code&gt; - имя файла, а &lt;code&gt;Reason&lt;/code&gt; - причина ошибки.</target>
        </trans-unit>
        <trans-unit id="8e799a198169d10fe4c08d9a95c18d2093196332" translate="yes" xml:space="preserve">
          <source>If the spawn operation succeeds, a new process is created on the node identified by &lt;code&gt;Node&lt;/code&gt;. When a spawn operation succeeds, the caller will by default be sent a message on the form &lt;code&gt;{ReplyTag, ReqId, ok, Pid}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. Such a message is referred to as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d585722d9492cc72567d38442d77e34fd8ab9264" translate="yes" xml:space="preserve">
          <source>If the special process is set to trap exits and if the parent process terminates, the expected behavior is to terminate with the same reason:</source>
          <target state="translated">Если специальный процесс настроен на ловушку выхода и если родительский процесс завершает свою работу,то ожидаемое поведение должно завершиться по той же причине:</target>
        </trans-unit>
        <trans-unit id="7455375f6d9089c7881123f4a8458dbe542389f7" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;SessionId&lt;/code&gt; is equal to the current session Id, an error is returned.</source>
          <target state="translated">Если указанный &lt;code&gt;SessionId&lt;/code&gt; равен текущему идентификатору сеанса, возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="d619307390edd39ec2b02ca669e7b364961dec45" translate="yes" xml:space="preserve">
          <source>If the specified allocator types are not enabled, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">Если указанные типы распределителей не включены, вызов завершится с &lt;code&gt;{error, not_enabled}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45c304ea9f8890bedad2957ce64c3d9052640688" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Если указанное приложение не загружено или процесс, выполняющий вызов, не принадлежит ни одному приложению, функция возвращает &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="661935b4fcb704bdedb21cd7cd8d1037467c6a3a" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, the function returns &lt;code&gt;undefined&lt;/code&gt;. If the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Если указанное приложение не загружено, функция возвращает &lt;code&gt;undefined&lt;/code&gt; . Если процесс, выполняющий вызов, не принадлежит ни одному приложению, функция возвращает &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee2eec511fb223edba405cd2c1e33b5dd8cf299" translate="yes" xml:space="preserve">
          <source>If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. If the event manager dies before or during the request this function returns &lt;code&gt;{error,{Reason, EventMgrRef}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a926434bb6d9a3523835439ccc5767bd6572dff3" translate="yes" xml:space="preserve">
          <source>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Если указанный процесс не принадлежит ни одному приложению, или если указанный процесс или модуль не существует, функция возвращает &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b16c97bb4dc09a19744a2eb9750dd2d9bb5ce54" translate="yes" xml:space="preserve">
          <source>If the startup procedure fails, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the cryptic tuple &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt;. To get more information about the start failure, use command-line arguments &lt;code&gt;-boot start_sasl&lt;/code&gt; as argument to the &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">Если процедура запуска завершается неудачно, функция &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; возвращает загадочный кортеж &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt; . Чтобы получить дополнительную информацию об &lt;code&gt;-boot start_sasl&lt;/code&gt; запуска, используйте аргументы командной строки -boot start_sasl в качестве аргумента сценария &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cbaf50d401e5c21095fb8f1fd28f9a45786128e" translate="yes" xml:space="preserve">
          <source>If the state changes, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">При изменении состояния сбрасывается очередь входящих событий,которая начинается со старейшего из отложенных.</target>
        </trans-unit>
        <trans-unit id="c8895677551ffa4a3c90ee4e7e492bffa6d9c323" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge. The challenge message can have two different formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cb412738e6e082151303db455deefb75f1506a" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge:</source>
          <target state="translated">Если статус был &lt;code&gt;ok&lt;/code&gt; или &lt;code&gt;ok_simultaneous&lt;/code&gt; , рукопожатие продолжается, и &lt;code&gt;B&lt;/code&gt; отправляет &lt;code&gt;A&lt;/code&gt; другое сообщение, запрос. Запрос содержит тот же тип информации, что и сообщение &amp;laquo;name&amp;raquo;, первоначально отправленное от &lt;code&gt;A&lt;/code&gt; к &lt;code&gt;B&lt;/code&gt; , плюс 32-битный запрос:</target>
        </trans-unit>
        <trans-unit id="beeeb7c98813879b37a7bf671f3521d70f7d4fcc" translate="yes" xml:space="preserve">
          <source>If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, that is, a disc-less node, &lt;code&gt;Mnesia&lt;/code&gt; does not use the disc on that particular node. The disc use is enabled by changing the storage type of table &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;disc_copies&lt;/code&gt;.</source>
          <target state="translated">Если тип хранения схемы - &lt;code&gt;ram_copies&lt;/code&gt; , то есть узел без диска, &lt;code&gt;Mnesia&lt;/code&gt; не использует диск на этом конкретном узле. Использование диска включается путем изменения типа хранения &lt;code&gt;schema&lt;/code&gt; таблицы на &lt;code&gt;disc_copies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c9602796f4ff2e2861a3fe314dbf863ef6f3fa" translate="yes" xml:space="preserve">
          <source>If the structured type has a component with an embedded &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; which embedded type in turn is a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, it gives a record with the &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; addition as in the following example:</source>
          <target state="translated">Если структурированный тип имеет компонент со встроенной &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; , встроенный тип которого, в свою очередь, является &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; , он дает запись с добавлением &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; , как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="3f062c1144e1678c566106b319cf580ce31c88b8" translate="yes" xml:space="preserve">
          <source>If the style sheet is installed as in this example, the categories are private to the suite in question. They can be used by all test cases in the suite, but cannot be used by other suites. A suite private style sheet, if specified, is used in favor of a global style sheet (one specified with flag &lt;code&gt;-stylesheet&lt;/code&gt;). A stylesheet tuple (as returned by &lt;code&gt;suite/0&lt;/code&gt; above) can also be returned from a test case information function. In this case the categories specified in the style sheet can only be used in that particular test case. A test case private style sheet is used in favor of a suite or global level style sheet.</source>
          <target state="translated">Если таблица стилей установлена, как в этом примере, категории являются частными для рассматриваемого набора. Они могут использоваться всеми тестовыми примерами в наборе, но не могут использоваться другими наборами. Приватная таблица стилей комплекта, если указана, используется вместо глобальной таблицы стилей (указанной с помощью flag &lt;code&gt;-stylesheet&lt;/code&gt; ). Кортеж таблицы стилей (возвращенный &lt;code&gt;suite/0&lt;/code&gt; выше) также может быть возвращен из информационной функции тестового примера. В этом случае категории, указанные в таблице стилей, могут использоваться только в этом конкретном тестовом примере. Приватная таблица стилей тестового примера используется вместо таблицы стилей набора или глобального уровня.</target>
        </trans-unit>
        <trans-unit id="5ef2b08f553195b967c4c1ec0d687b8410583635" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;.</source>
          <target state="translated">Если тема &quot;aaaaac...&quot;,то после неудачной попытки первого совпадения (начиная с первого символа в строке),стартовая точка пропускает,чтобы начать следующую попытку с &quot;c&quot;.Обратите внимание,что притягательный квантификатор не имеет того же эффекта,что и этот пример;хотя он будет подавлять обратное движение во время первой попытки совмещения,вторая попытка будет начинаться со второго символа вместо того,чтобы пропускать &quot;c&quot;.</target>
        </trans-unit>
        <trans-unit id="325365b23f57e117a3a5f1be4ba75e874fad7352" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.</source>
          <target state="translated">Если субъект &quot;abac&quot;,то Perl совпадает,но PCRE терпит неудачу,потому что (*COMMIT)во втором повторении группы действует.</target>
        </trans-unit>
        <trans-unit id="2a1b1d46006ae1cc02a5125b44f3a589d400f8b8" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.)</source>
          <target state="translated">Если объект-&quot;ба&quot;,то этот образец не совпадает.Так как .*?-это некрасиво,он изначально совпадает с нулевыми символами.Условие (?=a)затем не выполняется,символ &quot;b&quot; совпадает,а символ &quot;c&quot;-нет.На данный момент совпадение не возвращается в .*?,как можно ожидать от присутствия символа |.Условная подмаска является частью единственной альтернативы,состоящей из целого шаблона,и поэтому совпадение не удается.(Если бы был обратный путь в домен .*?,позволяющий ему соответствовать букве &quot;b&quot;,то совпадение было бы успешным).</target>
        </trans-unit>
        <trans-unit id="61ab084c99ad2f6aacca28fcd587b3400e6c929a" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.</source>
          <target state="translated">Если предмет-&quot;xyz123abc123&quot;,то точка соприкосновения-четвертый иероглиф.Поэтому такая деталь не является неявно закрепленной.</target>
        </trans-unit>
        <trans-unit id="f58702e52fe311a5928a0c529284a25593f9a63b" translate="yes" xml:space="preserve">
          <source>If the subsystems option is not present, the value of &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.</source>
          <target state="translated">Если параметр subsystems отсутствует, используется значение &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; . Это включает подсистему sftp по умолчанию. Для этого параметра можно установить пустой список, если вы не хотите, чтобы демон запускал какие-либо подсистемы.</target>
        </trans-unit>
        <trans-unit id="56f01b4c736d33d8a8e4b807a7321e237504b729" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully created (that is, if all child process start functions return &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;), the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the supervisor.</source>
          <target state="translated">Если супервизор и его дочерние процессы успешно созданы (то есть, если все функции запуска дочерних процессов возвращают &lt;code&gt;{ok,Child}&lt;/code&gt; , &lt;code&gt;{ok,Child,Info}&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; ), функция возвращает &lt;code&gt;{ok,Pid}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; это pid супервизора.</target>
        </trans-unit>
        <trans-unit id="ce27df4e7a72330922127644fc5b4154720386f2" translate="yes" xml:space="preserve">
          <source>If the supervisor bridge and the subsystem are successfully started, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is is the pid of the supervisor bridge.</source>
          <target state="translated">Если мост супервизора и подсистема успешно запущены, функция возвращает &lt;code&gt;{ok,Pid}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это pid моста супервизора.</target>
        </trans-unit>
        <trans-unit id="ee5bca92e596da338cae7a1a6835c08aaca7ab2c" translate="yes" xml:space="preserve">
          <source>If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the &lt;code&gt;pid()&lt;/code&gt; of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification identifier is specified instead of a &lt;code&gt;pid()&lt;/code&gt;, the function returns &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.</source>
          <target state="translated">Если супервизором является &lt;code&gt;simple_one_for_one&lt;/code&gt; , &lt;code&gt;Id&lt;/code&gt; должен быть &lt;code&gt;pid()&lt;/code&gt; дочернего процесса. Если указанный процесс активен, но не является потомком указанного супервизора, функция возвращает &lt;code&gt;{error,not_found}&lt;/code&gt; . Если вместо &lt;code&gt;pid()&lt;/code&gt; указан идентификатор дочерней спецификации , функция возвращает &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fde2c4d92373b2df91d47d89bec456be3c098325" translate="yes" xml:space="preserve">
          <source>If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; to remove the child specification.</source>
          <target state="translated">Если супервизор не является &lt;code&gt;simple_one_for_one&lt;/code&gt; , &lt;code&gt;Id&lt;/code&gt; должен быть идентификатором спецификации потомка. Процесс, если таковой имеется, завершается, и, если он не является временным потомком, его спецификация сохраняется супервизором. Позднее супервизор может перезапустить дочерний процесс. Дочерний процесс также можно перезапустить явно, вызвав &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt; . Используйте &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; , чтобы удалить дочернюю спецификацию.</target>
        </trans-unit>
        <trans-unit id="22f9e859ab134b7ee555cf61c0b88a7c31c26892" translate="yes" xml:space="preserve">
          <source>If the supervisor is not running, the function fails with the reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">Если супервизор не запущен, функция не работает по причине &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1a06a02433874f4dbf2fb6692571bffc468e3a" translate="yes" xml:space="preserve">
          <source>If the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is increased, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если счетчик приостановки для процесса, указанного параметром &lt;code&gt;Suspendee&lt;/code&gt; , увеличивается, возвращается значение &lt;code&gt;true&lt;/code&gt; , в противном случае - значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d5607c3dc66f8ee4fed4118cbb2c89a903f53e7" translate="yes" xml:space="preserve">
          <source>If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:</source>
          <target state="translated">Если синтаксис для рекурсивного вызова подмаскировки (по номеру или по имени)используется вне круглых скобок,на которые он ссылается,то он работает как подпрограмма на языке программирования.Вызываемая подмаска может быть определена до или после ссылки.Нумерованная ссылка может быть абсолютной или относительной,как в следующих примерах:</target>
        </trans-unit>
        <trans-unit id="2c95678de3724de5573a03d131e0386d7f73cde7" translate="yes" xml:space="preserve">
          <source>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, &lt;code&gt;sync_nodes&lt;/code&gt;, can be used to synchronize the release handler processes at a number of nodes, see the &lt;code&gt;appup(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">Если система состоит из нескольких узлов Erlang, каждый узел может использовать свою собственную версию выпуска. Обработчик выпуска - это локально зарегистрированный процесс, который должен вызываться на каждом узле, где требуется обновление или понижение версии. Инструкцию по обработке выпуска, &lt;code&gt;sync_nodes&lt;/code&gt; , можно использовать для синхронизации процессов обработчика выпуска на нескольких узлах, см. &lt;code&gt;appup(4)&lt;/code&gt; руководства appup (4) в SASL.</target>
        </trans-unit>
        <trans-unit id="5a9dfa8802f7c28fb7268599a87d430596fb7e4c" translate="yes" xml:space="preserve">
          <source>If the system is halted by the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt;, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message is enough to understand the problem, but some messages are described here. Notice that the suggested reasons for the crash are &lt;strong&gt;only suggestions&lt;/strong&gt;. The exact reasons for the errors can vary depending on the local applications and the underlying operating system.</source>
          <target state="translated">Если система останавливается с помощью команды BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; , слоган является строковым параметром, переданным в BIF, в противном случае это описание, созданное эмулятором или ядром (Erlang). Обычно сообщения достаточно, чтобы понять проблему, но некоторые сообщения описаны здесь. Обратите внимание, что предлагаемые причины сбоя являются &lt;strong&gt;только предположениями&lt;/strong&gt; . Точные причины ошибок могут различаться в зависимости от локальных приложений и базовой операционной системы.</target>
        </trans-unit>
        <trans-unit id="6a757ef96ac1cd490bb1c008318b2e3635c8724c" translate="yes" xml:space="preserve">
          <source>If the system is to be rebooted because of missing heartbeats, or a terminated Erlang runtime system, environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt; must be set before the system is started. If this variable is not set, a warning text is printed but the system does not reboot.</source>
          <target state="translated">Если система должна быть перезагружена из-за отсутствия &lt;code&gt;HEART_COMMAND&lt;/code&gt; или из-за остановки системы времени выполнения Erlang, перед запуском системы необходимо установить переменную среды HEART_COMMAND . Если эта переменная не задана, выводится текст предупреждения, но система не перезагружается.</target>
        </trans-unit>
        <trans-unit id="7201254cce87e2757d3c2088109f6b9433e91391" translate="yes" xml:space="preserve">
          <source>If the system upgrade fails, &lt;code&gt;Mnesia&lt;/code&gt; must be restarted on all &lt;code&gt;db_nodes&lt;/code&gt; to restore the old database. The fallback is automatically deinstalled after a successful startup. The function &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; can also be used to deinstall the fallback after a successful system upgrade. Again, this is a distributed operation that is either performed on all &lt;code&gt;db_nodes&lt;/code&gt; or none. Both the installation and deinstallation of fallbacks require Erlang to be operational on all &lt;code&gt;db_nodes&lt;/code&gt;, but it does not matter if &lt;code&gt;Mnesia&lt;/code&gt; is running or not.</source>
          <target state="translated">Если обновление системы не удалось , &lt;code&gt;Mnesia&lt;/code&gt; необходимо перезапустить на всех &lt;code&gt;db_nodes&lt;/code&gt; , чтобы восстановить старую базу данных. Резервный вариант автоматически удаляется после успешного запуска. Функцию &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; также можно использовать для удаления резервной копии после успешного обновления системы. Опять же, это распределенная операция, которая либо выполняется на всех &lt;code&gt;db_nodes&lt;/code&gt; , либо ни на одном из них. Как установка, так и удаление резервных &lt;code&gt;db_nodes&lt;/code&gt; требуют, чтобы Erlang работал на всех db_nodes , но не имеет значения , запущена &lt;code&gt;Mnesia&lt;/code&gt; или нет.</target>
        </trans-unit>
        <trans-unit id="820e07b72de8d7275e79b190e2ecc622e6ffa577" translate="yes" xml:space="preserve">
          <source>If the system uses release handling, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">Если система использует обработку релизов, это должно быть установлено в программе, подобной &lt;code&gt;start_erl.exe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d7a8bf37699409a1736ff33b25beed75456c38" translate="yes" xml:space="preserve">
          <source>If the table has been fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the time when the table was first fixed by a process, which either is or is not one of the processes it is fixed by now.</source>
          <target state="translated">Если таблица была исправлена ​​с помощью &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; , вызов возвращает кортеж, где &lt;code&gt;FixationTime&lt;/code&gt; - это время, когда таблица была впервые исправлена ​​процессом, который либо является, либо не является одним из процессов, исправленных к настоящему времени.</target>
        </trans-unit>
        <trans-unit id="28d80bca5a16b32c018007fa19be0d36c5975d0c" translate="yes" xml:space="preserve">
          <source>If the table identifier is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510048f902d277dbbdb552040e33a360934aad3f" translate="yes" xml:space="preserve">
          <source>If the table is a hash table, that is, if it is not an &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">Если таблица является хеш-таблицей, то есть если она не является &lt;code&gt;ordered_set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8586c3c8b193a91489791658c1ee464303da1bd1" translate="yes" xml:space="preserve">
          <source>If the table is a hash table. Contains statistics about the table, such as the maximum, minimum, and average chain length. Having a maximum much larger than the average, and a standard deviation much larger than the expected standard deviation is a sign that the hashing of the terms behaves badly for some reason.</source>
          <target state="translated">Если стол-это хэш-стол.Содержит статистику о таблице,такую как максимальная,минимальная и средняя длина цепочки.Наличие максимума,намного превышающего среднее,и стандартного отклонения,намного превышающего ожидаемое стандартное отклонение,является признаком того,что хэширование терминов по каким-то причинам ведет себя плохо.</target>
        </trans-unit>
        <trans-unit id="fcb4375c9095616a2c1fcb3c7937a674a11eced4" translate="yes" xml:space="preserve">
          <source>If the table is an &lt;code&gt;ordered_set&lt;/code&gt;. (The number of elements is the same as the number of objects in the table.)</source>
          <target state="translated">Если таблица - это &lt;code&gt;ordered_set&lt;/code&gt; . (Количество элементов такое же, как и количество объектов в таблице.)</target>
        </trans-unit>
        <trans-unit id="fe825b9dd24dc79930168b7d8e9410fc4ed428ff" translate="yes" xml:space="preserve">
          <source>If the table is deleted, the &lt;code&gt;tid()&lt;/code&gt; will be invalid even if another named table is created with the same name.</source>
          <target state="translated">Если таблица удалена, &lt;code&gt;tid()&lt;/code&gt; будет недействительным, даже если другая именованная таблица будет создана с тем же именем.</target>
        </trans-unit>
        <trans-unit id="8e50f5b3f9353a3565bdface1fd102e6a022cef3" translate="yes" xml:space="preserve">
          <source>If the table is empty, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Если таблица пуста, &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="060a5cb7c2a9190e262dad862fd197847d59b457" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt; ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3fb17408533c8e1e68861ca6b015faef26d511" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt; safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the last time when the table changed from unfixed to fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3adb98d90a256345bb402384863d0ffa16d7d03" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">Если таблица фиксируется с помощью &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; или какого-либо внутреннего механизма.</target>
        </trans-unit>
        <trans-unit id="ab8f1f3f8186f2a911707d67d645de8494934784" translate="yes" xml:space="preserve">
          <source>If the table is not fixed at all, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a1ad070d201f061059ad07a51c09a4b677d0c7" translate="yes" xml:space="preserve">
          <source>If the table never has been fixed, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если таблица никогда не была исправлена, вызов возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1106f60b23247fd532e1f3435b3e146b85e02356" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;ordered_set&lt;/code&gt; and the key of the inserted object &lt;strong&gt;compares equal&lt;/strong&gt; to the key of any object in the table, the old object is replaced.</source>
          <target state="translated">Если тип таблицы - &lt;code&gt;ordered_set&lt;/code&gt; а ключ вставленного объекта &lt;strong&gt;сравнивается&lt;/strong&gt; с ключом любого объекта в таблице, старый объект заменяется.</target>
        </trans-unit>
        <trans-unit id="4533fa2ede8fbfe73be80457c07b8f040691fe23" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">Если тип таблицы &lt;code&gt;set&lt;/code&gt; и существует более одного объекта с данным ключом, выбирается один из объектов. Это не обязательно последний объект с данным ключом в последовательности объектов, возвращаемых функциями ввода. Избегайте дублирования ключей, иначе файл станет излишне фрагментированным. Это справедливо также для дублированных объектов , хранящихся в таблицах типа &lt;code&gt;bag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56d2753779e61ff48cb39b5aa4b2593e74eb1601" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">Если тип таблицы &lt;code&gt;set&lt;/code&gt; и существует более одного объекта с данным ключом, выбирается один из объектов. Это не обязательно последний объект с данным ключом в последовательности объектов, возвращаемых функциями ввода. Это также относится к дублированным объектам, хранящимся в таблицах типа &lt;code&gt;bag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae4c49d2565269908072cf718d1492a11aec56f" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and the key of the inserted objects &lt;strong&gt;matches&lt;/strong&gt; the key of any object in the table, the old object is replaced.</source>
          <target state="translated">Если тип таблицы &lt;code&gt;set&lt;/code&gt; и ключ вставленных объектов &lt;strong&gt;совпадает&lt;/strong&gt; с ключом любого объекта в таблице, старый объект заменяется.</target>
        </trans-unit>
        <trans-unit id="a9fdebabfb947c83919e8f9a54708d4bc09db924" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt;, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt;, the function returns a list of arbitrary length.</source>
          <target state="translated">Если тип таблицы &lt;code&gt;set&lt;/code&gt; , функция возвращает либо пустой список, либо список с одним объектом, поскольку не может быть более одного объекта с данным ключом. Если тип таблицы - &lt;code&gt;bag&lt;/code&gt; или &lt;code&gt;duplicate_bag&lt;/code&gt; , функция возвращает список произвольной длины.</target>
        </trans-unit>
        <trans-unit id="52326346a5221b9ea31e1cab3b15e1198497f8cc" translate="yes" xml:space="preserve">
          <source>If the table uses &lt;code&gt;==/2&lt;/code&gt; when comparing keys for equality, the &lt;code&gt;qlc&lt;/code&gt; module looks up the constant regardless of which operator is used in the QLC. However, &lt;code&gt;==/2&lt;/code&gt; is to be preferred:</source>
          <target state="translated">Если таблица использует &lt;code&gt;==/2&lt;/code&gt; при сравнении ключей на равенство, модуль &lt;code&gt;qlc&lt;/code&gt; ищет константу независимо от того, какой оператор используется в QLC. Однако предпочтительнее использовать &lt;code&gt;==/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c174173c48e462e86139389a0e63bdc440243b08" translate="yes" xml:space="preserve">
          <source>If the table was compressed.</source>
          <target state="translated">Если бы стол был сжат.</target>
        </trans-unit>
        <trans-unit id="c18aa6aeb37dae91506c755f84a591f149b7a42e" translate="yes" xml:space="preserve">
          <source>If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows:</source>
          <target state="translated">Если целевой хост является &quot;специальным&quot; узлом,то FTP-адрес должен быть указан в конфигурационном файле следующим образом:</target>
        </trans-unit>
        <trans-unit id="ba53604fe2dbaeba0c697aca59ebed25bdd01e29" translate="yes" xml:space="preserve">
          <source>If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings):</source>
          <target state="translated">Если целевой хост-это что-то другое,например,UNIX-хост,то в конфигурационном файле также должны быть указаны имя пользователя и пароль (обе строки):</target>
        </trans-unit>
        <trans-unit id="df661b54e46a56f3d279f98bcc4be4b32bc0814f" translate="yes" xml:space="preserve">
          <source>If the test case function crashes or exits purposely, it is considered &lt;strong&gt;failed&lt;/strong&gt;. If it returns a value (no matter what value), it is considered successful. An exception to this rule is the return value &lt;code&gt;{skip,Reason}&lt;/code&gt;. If this tuple is returned, the test case is considered skipped and is logged as such.</source>
          <target state="translated">Если функция тестового примера аварийно завершает работу или завершается намеренно, она считается &lt;strong&gt;неудачной&lt;/strong&gt; . Если он возвращает значение (независимо от того, какое значение), он считается успешным. Исключением из этого правила является возвращаемое значение &lt;code&gt;{skip,Reason}&lt;/code&gt; . Если этот кортеж возвращается, тестовый пример считается пропущенным и регистрируется как таковой.</target>
        </trans-unit>
        <trans-unit id="4997e9150d0cf8e0e80015106a039f2b0f15d2c2" translate="yes" xml:space="preserve">
          <source>If the test case returns the tuple &lt;code&gt;{comment,Comment}&lt;/code&gt;, the case is considered successful and &lt;code&gt;Comment&lt;/code&gt; is printed in the overview log file. This is equal to calling &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если тестовый пример возвращает кортеж &lt;code&gt;{comment,Comment}&lt;/code&gt; , случай считается успешным, и &lt;code&gt;Comment&lt;/code&gt; печатается в файле журнала обзора. Это равносильно вызову &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60f08b0f13ca3dba151d2fa93224be6770ab9243" translate="yes" xml:space="preserve">
          <source>If the test is started with option &lt;code&gt;create_priv_dir&lt;/code&gt; set to &lt;code&gt;manual_per_tc&lt;/code&gt;, in order for the test case to use the private directory, it must first create it by calling this function.</source>
          <target state="translated">Если тест запущен с параметром &lt;code&gt;create_priv_dir&lt;/code&gt; , установленным на &lt;code&gt;manual_per_tc&lt;/code&gt; , для того, чтобы тестовый пример использовал частный каталог, он должен сначала создать его, вызвав эту функцию.</target>
        </trans-unit>
        <trans-unit id="ff477a5e0193222aeda2ed720ed9cd26684dd49a" translate="yes" xml:space="preserve">
          <source>If the test session is instead started with a call to &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt;, the result is that test &lt;code&gt;t1&lt;/code&gt; does not run on &lt;code&gt;ct_node@host_x&lt;/code&gt; (or any other node) while test &lt;code&gt;t3&lt;/code&gt; runs on both &lt;code&gt;ct_node@host_y&lt;/code&gt; and &lt;code&gt;ct_node@host_z&lt;/code&gt;.</source>
          <target state="translated">Если вместо этого тестовый сеанс запускается с вызова &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt; , в результате тест &lt;code&gt;t1&lt;/code&gt; не запускается на &lt;code&gt;ct_node@host_x&lt;/code&gt; (или любом другом узле), пока test &lt;code&gt;t3&lt;/code&gt; работает как на &lt;code&gt;ct_node@host_y&lt;/code&gt; и на &lt;code&gt;ct_node@host_z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66bd8e7ff485cff1898efb9a85ff8aa7af9d4928" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt; Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10a6be714753d43b2d04e3f31a9e74da2fca330" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">Если текст между круглыми скобками состоит из последовательности цифр, условие истинно, если ранее совпал подшаблон захвата этого числа. Если существует более одного захватывающего подшаблона с одинаковым номером (см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; ранее), условие истинно, если какой-либо из них совпал. Альтернативное обозначение - ставить перед цифрами знак плюс или минус. В этом случае номер подшаблона скорее относительный, чем абсолютный. На последние открытые круглые скобки можно ссылаться через (? (- 1), на следующие самые последние - через (? (- 2) и т. Д.). Внутри циклов также может иметь смысл ссылаться на последующие группы. Следующие круглые скобки к На открытие можно ссылаться как (? (+ 1) и т. д. (нулевое значение в любой из этих форм не используется; это вызывает ошибку времени компиляции).</target>
        </trans-unit>
        <trans-unit id="6ca3d61691a2fc7b57ea4b8b07508db553495848" translate="yes" xml:space="preserve">
          <source>If the timer is of type &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;, then for each intermediate timout, the reply will be resent (this is valid until the ack is received or the timer expires).</source>
          <target state="translated">Если таймер имеет тип &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; , то для каждого промежуточного таймаута ответ будет отправляться повторно (это действительно до получения подтверждения или до истечения срока действия таймера).</target>
        </trans-unit>
        <trans-unit id="0e94483da50a1b3ed8b94f80ddcd411d6145f16b" translate="yes" xml:space="preserve">
          <source>If the trace tuple has five elements, the fifth element will be sent as the &lt;code&gt;extra&lt;/code&gt; value in the &lt;code&gt;Opts&lt;/code&gt; maps.</source>
          <target state="translated">Если кортеж трассировки содержит пять элементов, пятый элемент будет отправлен как &lt;code&gt;extra&lt;/code&gt; значение в картах &lt;code&gt;Opts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce02e8f59bcb0c0b8b781eb7d69a7e655a35279" translate="yes" xml:space="preserve">
          <source>If the traced node is diskless, &lt;code&gt;ttb&lt;/code&gt; must be started from a trace control node with disk access, and option &lt;code&gt;file&lt;/code&gt; must be specified to function &lt;code&gt;tracer/2&lt;/code&gt; with value &lt;code&gt;{local, File}&lt;/code&gt;, for example:</source>
          <target state="translated">Если отслеживаемый узел бездисковый, &lt;code&gt;ttb&lt;/code&gt; должен запускаться с узла управления трассировкой с доступом к диску, а &lt;code&gt;file&lt;/code&gt; параметров должен быть указан для функции &lt;code&gt;tracer/2&lt;/code&gt; со значением &lt;code&gt;{local, File}&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="83ebb917b401f97bb196808428e528b58ff6d85f" translate="yes" xml:space="preserve">
          <source>If the tracing process/port dies or the tracer module returns &lt;code&gt;remove&lt;/code&gt;, the flags are silently removed.</source>
          <target state="translated">Если процесс / порт трассировки умирает или модуль трассировки возвращает команду &lt;code&gt;remove&lt;/code&gt; , флаги автоматически удаляются.</target>
        </trans-unit>
        <trans-unit id="73568089bc427934a8063420408d7fe082af563e" translate="yes" xml:space="preserve">
          <source>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt;. The tracing has to be stopped at a suitable later time using &lt;code&gt;fprof:trace(stop)&lt;/code&gt;.</source>
          <target state="translated">Если трассировка должна продолжаться после возврата из функции, например, если это функция запуска, которая порождает процессы для профилирования, вы можете использовать &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt; . Трассировку необходимо остановить в подходящее позднее время с помощью &lt;code&gt;fprof:trace(stop)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1df5baebd9c38dac3e2f05812c6dc531db1c4b38" translate="yes" xml:space="preserve">
          <source>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback rejects the candidates, then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = failover&lt;/code&gt;. If a peer is selected then a &lt;code&gt;prepare_retransmit/3&lt;/code&gt; callback takes place, after which the semantics are the same as following an initial &lt;code&gt;prepare_request/3&lt;/code&gt; callback.</source>
          <target state="translated">Если транспортное соединение с одноранговым узлом разрывается после того, как запрос был отправлен, но до того, как был получен ответ, делается попытка повторно отправить запрос альтернативному одноранговому узлу. Если такой одноранговый &lt;code&gt;pick_peer/4&lt;/code&gt; недоступен или если последующий обратный вызов pick_peer / 4 отклоняет кандидатов, то выполняется обратный вызов &lt;code&gt;handle_error/4&lt;/code&gt; с &lt;code&gt;Reason = failover&lt;/code&gt; . Если выбран одноранговый узел, то &lt;code&gt;prepare_retransmit/3&lt;/code&gt; обратный вызов prepare_retransmit / 3 , после чего семантика такая же, как после исходного обратного вызова &lt;code&gt;prepare_request/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a9657c264118b8bd17be6e7ec65d9a46f4bb3e" translate="yes" xml:space="preserve">
          <source>If the upgrade or downgrade fails, the application can end up in an inconsistent state.</source>
          <target state="translated">Если повышение или понижение рейтинга не удастся,приложение может оказаться в непоследовательном состоянии.</target>
        </trans-unit>
        <trans-unit id="dcf53bce4100d9193f2229bae322274401770092" translate="yes" xml:space="preserve">
          <source>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from &lt;code&gt;seq_trace:get_token/1&lt;/code&gt;) and include trace information in the message data sent to their respective ports.</source>
          <target state="translated">Если пользователь по какой-либо причине хочет передать токен трассировки на порт, это необходимо сделать вручную в коде процесса управления портом. Процессы управления портами должны проверять соответствующие параметры последовательной трассировки (полученные из &lt;code&gt;seq_trace:get_token/1&lt;/code&gt; ) и включать информацию трассировки в данные сообщения, отправленные на их соответствующие порты.</target>
        </trans-unit>
        <trans-unit id="7e2e034ddd571c04bf0e9592e1523dc28c51cfbb" translate="yes" xml:space="preserve">
          <source>If the user has configured transports &lt;strong&gt;with&lt;/strong&gt; options then those will take precedence over these options. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;agent information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b23a58d8baa9de2a26d48114ccdc0aba9a7898" translate="yes" xml:space="preserve">
          <source>If the user specifies a whole directory of test suites for the test, the execution order of the suites depends on how the files are listed by the operating system, which varies between systems.</source>
          <target state="translated">Если для теста пользователь указывает целый каталог тестовых комплектов,то порядок выполнения комплектов зависит от того,как в операционной системе перечислены файлы,которые различаются в разных системах.</target>
        </trans-unit>
        <trans-unit id="ec74a0aa34a3fff9b86b849a4c4f4303fc09ca09" translate="yes" xml:space="preserve">
          <source>If the user wants to run all test suites for a test object (or an OTP application) by specifying only the top directory (for example, with start flag/option &lt;code&gt;dir&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; primarily looks for test suite modules in a subdirectory named &lt;code&gt;test&lt;/code&gt;. If this subdirectory does not exist, the specified top directory is assumed to be the test directory, and test suites are read from there instead.</source>
          <target state="translated">Если пользователь хочет запустить все наборы тестов для тестового объекта (или приложения OTP), указав только верхний каталог (например, с флагом запуска / параметром &lt;code&gt;dir&lt;/code&gt; ), &lt;code&gt;Common Test&lt;/code&gt; в первую очередь ищет модули набора тестов в подкаталоге с именем &lt;code&gt;test&lt;/code&gt; , Если этот подкаталог не существует, предполагается, что указанный верхний каталог является тестовым каталогом, и вместо этого будут считываться наборы тестов.</target>
        </trans-unit>
        <trans-unit id="effd9156da460f544cefc46b3b70768d9f3c1b10" translate="yes" xml:space="preserve">
          <source>If the user wants to update the record, it is more efficient to use &lt;code&gt;write/sticky_write&lt;/code&gt; as the &lt;code&gt;LockKind&lt;/code&gt;. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</source>
          <target state="translated">Если пользователь хочет обновить запись, более эффективно использовать &lt;code&gt;write/sticky_write&lt;/code&gt; в качестве &lt;code&gt;LockKind&lt;/code&gt; . Если для таблицы активна проверка большинства, она проверяется при попытке блокировки записи. Это можно использовать для быстрого завершения, если не выполняется условие большинства.</target>
        </trans-unit>
        <trans-unit id="2a0e7330d21e34b34dfa69e0d3eeb795d5ed2f32" translate="yes" xml:space="preserve">
          <source>If the user wants to view load values as percentage of machine capacity, then this way of measuring presents a problem, because the load values are not restricted to a fixed interval. In this case, the following simple mathematical transformation can produce the load value as a percentage:</source>
          <target state="translated">Если пользователь хочет просмотреть значения нагрузки в процентах от производительности машины,то такой способ измерения представляет проблему,так как значения нагрузки не ограничены фиксированным интервалом.В этом случае следующее простое математическое преобразование может дать значение нагрузки в процентах:</target>
        </trans-unit>
        <trans-unit id="02fc968f89b25d7af28da18289c9216741ffd871" translate="yes" xml:space="preserve">
          <source>If the user's DSA, RSA or ECDSA key is protected by a passphrase, it can be supplied with thoose options.</source>
          <target state="translated">Если ключ пользователя DSA,RSA или ECDSA защищен парольной фразой,то он может быть снабжен опциями thoose.</target>
        </trans-unit>
        <trans-unit id="753352e4298655af61f31e670724bf4c6d758094" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;Value&lt;/code&gt; is equal to the value previously stored for the key, &lt;code&gt;put/2&lt;/code&gt; will do nothing and return quickly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf4ed00376d14751e45211a8a3a5480eebc775a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt; (passive mode), the process must explicitly receive incoming data by calling &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (depending on the type of socket).</source>
          <target state="translated">Если значение равно &lt;code&gt;false&lt;/code&gt; (пассивный режим), процесс должен явно получать входящие данные, вызывая &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (в зависимости от типа сокета. ).</target>
        </trans-unit>
        <trans-unit id="f8c0f324daf0fe9bcb732c8ba7fcf4c76dd808ad" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt;, Igor will read source files without passing them through the Erlang preprocessor (&lt;code&gt;epp&lt;/code&gt;), in order to avoid expansion of preprocessor directives such as &lt;code&gt;-include(...).&lt;/code&gt;, &lt;code&gt;-define(...).&lt;/code&gt; and &lt;code&gt;-ifdef(...)&lt;/code&gt;, and macro calls such as &lt;code&gt;?LINE&lt;/code&gt; and &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;, i.e., preprocessing is not done. (See the module &lt;code&gt;epp_dodger&lt;/code&gt; for details.)</source>
          <target state="translated">Если значение равно &lt;code&gt;false&lt;/code&gt; , Игорь будет читать исходные файлы, не передавая их через препроцессор Erlang ( &lt;code&gt;epp&lt;/code&gt; ), чтобы избежать расширения директив препроцессора, таких как &lt;code&gt;-include(...).&lt;/code&gt; , &lt;code&gt;-define(...).&lt;/code&gt; и &lt;code&gt;-ifdef(...)&lt;/code&gt; , а также вызовы макросов, такие как &lt;code&gt;?LINE&lt;/code&gt; и &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; , т. Е. Предварительная обработка не выполняется. (Подробнее см. Модуль &lt;code&gt;epp_dodger&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c37d2b8a16c01a498b8f51d057c13420aaeecac6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;once&lt;/code&gt; (&lt;code&gt;{active, once}&lt;/code&gt;), &lt;strong&gt;one&lt;/strong&gt; data message from the socket is sent to the process. To receive one more message, &lt;code&gt;setopts/2&lt;/code&gt; must be called again with option &lt;code&gt;{active, once}&lt;/code&gt;.</source>
          <target state="translated">Если значение равно &lt;code&gt;once&lt;/code&gt; ( &lt;code&gt;{active, once}&lt;/code&gt; ), процессу отправляется &lt;strong&gt;одно&lt;/strong&gt; сообщение с данными из сокета. Чтобы получить еще одно сообщение, необходимо снова &lt;code&gt;setopts/2&lt;/code&gt; с опцией &lt;code&gt;{active, once}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0edabfc9ae44692cbce9f0269af3098b558ce7c2" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all &lt;code&gt;-import(...)&lt;/code&gt; declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , все объявления &lt;code&gt;-import(...)&lt;/code&gt; в исходном коде будут расширены в результате; в противном случае будет сохранено максимально возможное количество исходных деклараций импорта. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ec9a61337586e188fec4ae4002aa86a696c3f2b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all import statements will be removed and calls to imported functions will be expanded to explicit remote calls. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , все операторы импорта будут удалены, а вызовы импортированных функций будут расширены до явных удаленных вызовов. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b8cea8ff6b46a563bc83a9fce55c5e6cf84c9e7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all information messages and warning messages will be suppressed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , все информационные сообщения и предупреждающие сообщения будут подавлены. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bccb9c8103eb8444c9724207cd93db68090eda5" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all matches &quot;&lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt;&quot; where &lt;code&gt;E&lt;/code&gt; is a case-, if- or receive-expression whose branches all return n-tuples (or explicitly throw exceptions) will be rewritten to bind and export the variables &lt;code&gt;V1&lt;/code&gt;, ..., &lt;code&gt;Vn&lt;/code&gt; directly. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , все совпадения &quot; &lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt; &quot;, где &lt;code&gt;E&lt;/code&gt; - выражение case-, if- или receive-выражение, все ветви которого возвращают n-кортежи (или явно генерируют исключения), будут переписаны. для непосредственного связывания и экспорта переменных &lt;code&gt;V1&lt;/code&gt; , ..., &lt;code&gt;Vn&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e252402ddfc7629809ad75d385749bf1c28429eb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all options that affect how the code is modified are set to &quot;no changes&quot;. For example, to only update guard tests, and nothing else, use the options &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt;. (Recall that options closer to the beginning of the list have higher precedence.)</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , все параметры, влияющие на способ изменения кода, устанавливаются на &amp;laquo;без изменений&amp;raquo;. Например, чтобы обновлять только тесты защиты и ничего больше, используйте параметры &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt; . (Напомним, что параметры, расположенные ближе к началу списка, имеют более высокий приоритет.)</target>
        </trans-unit>
        <trans-unit id="661aadd35dfccaaf93a78302865c3cfe6ab3529d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, calls to &lt;code&gt;lists:map/2&lt;/code&gt; and &lt;code&gt;lists:filter/2&lt;/code&gt; will be rewritten using list comprehensions. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , вызовы &lt;code&gt;lists:map/2&lt;/code&gt; и &lt;code&gt;lists:filter/2&lt;/code&gt; будут переписаны с использованием представлений списков. Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db560d66c74e2b5edc2b415e1318b63374234171" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the &lt;code&gt;backup_suffix&lt;/code&gt; option to the original name. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , существующие файлы будут переименованы перед открытием новых файлов для записи. Новые имена формируются путем добавления строки, заданной параметром &lt;code&gt;backup_suffix&lt;/code&gt; , к исходному имени. Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f45a2885644fae2f95e314f116a38cf230d32c75" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be changed to use the old names instead of the new ones, e.g. &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;false&lt;/code&gt;. This option overrides the &lt;code&gt;new_guard_tests&lt;/code&gt; option.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , тесты защиты будут изменены, чтобы использовать старые имена вместо новых, например, &amp;laquo; &lt;code&gt;integer(X)&lt;/code&gt; &amp;raquo; вместо &amp;laquo; &lt;code&gt;is_integer(X)&lt;/code&gt; &amp;raquo;. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; . Этот параметр переопределяет параметр &lt;code&gt;new_guard_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7cd8fb5c207c507a51e1775733171389edb7af" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be updated to use the new names, e.g. &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;true&lt;/code&gt;. See also &lt;code&gt;old_guard_tests&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , защитные тесты будут обновлены для использования новых имен, например, &amp;laquo; &lt;code&gt;is_integer(X)&lt;/code&gt; &amp;raquo; вместо &amp;laquo; &lt;code&gt;integer(X)&lt;/code&gt; &amp;raquo;. Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; . См. Также &lt;code&gt;old_guard_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3065ef5e6ab38f54db2ee2363766ab33259e9b9" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, instead of the file being written to disk it will be printed to stdout. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , вместо записи файла на диск он будет выведен на стандартный вывод. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54052ea83b3ce0b0af928cdbcc55b6fae8e4433d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , то в верхней части результирующего модуля не будет добавляться баннерный комментарий, даже если целевой модуль не имеет того же имени, что и какой-либо из модулей ввода. Вместо этого Игорь попытается сохранить внешний вид модуля, код которого находится в верхней части вывода. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f87660fc4a181394247f96baa377c54c6755f37" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , файлы не будут изменены. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df3ab32bc54bd17610cc1947d346139f4464db6e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified; this is typically most useful if the &lt;code&gt;verbose&lt;/code&gt; flag is enabled, to generate reports about the program files without affecting them. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , файлы не будут изменены; обычно это наиболее полезно, если включен флаг &lt;code&gt;verbose&lt;/code&gt; , для создания отчетов о файлах программы, не затрагивая их. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c857b2ddea91c4f1382dc10632fa790ebcc157d4" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is &lt;code&gt;false&lt;/code&gt;, which means that section headers are normally added whenever more than two or more modules are merged.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , комментарии заголовка не будут добавлены к результирующему модулю в начале каждого раздела кода, который исходит из определенного модуля ввода. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; , что означает, что заголовки разделов обычно добавляются при объединении более двух или более модулей.</target>
        </trans-unit>
        <trans-unit id="f7502caa9d0a180e8b6ee5deb22eb2a7558a013b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, preprocessing will be done when reading the source code. See &lt;code&gt;merge_files/4&lt;/code&gt; for details.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , предварительная обработка будет выполнена при чтении исходного кода. См. Подробности в &lt;code&gt;merge_files/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba203d3ce53c0ee7058adbf1504acdd24b9e757" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , прогресс сообщение будет выводиться в то время как программа работает, если &lt;code&gt;quiet&lt;/code&gt; вариант не является &lt;code&gt;true&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="915746ee8197f7425e23cffea24b153e1f1e18c8" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value when calling &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , прогресс сообщение будет выводиться в то время как программа работает, если &lt;code&gt;quiet&lt;/code&gt; вариант не является &lt;code&gt;true&lt;/code&gt; . Значение по умолчанию при вызове &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b91774a83e666475650d9139217c76fff02c41ca" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running; the default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , сообщения о ходе выполнения будут выводиться во время работы программы; значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87c71038a7138f9d28b15166013d2ec5e72ecbcc" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, source code comments in the original files will be preserved in the output. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , комментарии исходного кода в исходных файлах будут сохранены в выводе. Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40369b32150fd62bc05caf551bc811ec5c61e8d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , файлы модулей-заглушек будут автоматически сгенерированы для всех экспортируемых модулей, имя которых не совпадает с именем целевого модуля. Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9de1f4216e6f225a7647de788bed6302d6db97" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, subdirectories will be visited recursively. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , подкаталоги будут посещаться рекурсивно. Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8586c382194eee0170ba6e0221153350f302413e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, symbolic directory links will be followed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , будут следовать символические ссылки на каталоги. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3143c0f4c2f0487a47c16bc04f718d7c6ca270ba" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the resulting code will be processed using the &lt;code&gt;erl_tidy&lt;/code&gt; module, which removes unused functions and does general code cleanup. (See &lt;code&gt;erl_tidy:module/2&lt;/code&gt; for additional options.) The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , полученный код будет обработан с &lt;code&gt;erl_tidy&lt;/code&gt; модуля erl_tidy , который удаляет неиспользуемые функции и выполняет общую очистку кода. (См. Дополнительные параметры в &lt;code&gt;erl_tidy:module/2&lt;/code&gt; . ) Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d698e4a7611a1338e29756a796838536c672223" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, this is equivalent to listing all of the input modules in the &lt;code&gt;export&lt;/code&gt; option. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , это эквивалентно перечислению всех модулей ввода в опции &lt;code&gt;export&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="365ed702372c3b3974abae9c5b1bac335c2e40e6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, unused functions will not be removed from the code. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , неиспользуемые функции не будут удалены из кода. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c43f17f91393f09fcaccf937fae28a97b0723f0d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, which is the default, everything received from the socket is sent as messages to the receiving process.</source>
          <target state="translated">Если значение &lt;code&gt;true&lt;/code&gt; , что является значением по умолчанию, все, что получено из сокета, отправляется как сообщения принимающему процессу.</target>
        </trans-unit>
        <trans-unit id="8c39732459bb5c7d2ede3da9e66866784c1270ea" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, all file attributes &lt;code&gt;-file(...)&lt;/code&gt; in the input sources will be preserved in the resulting code. If the value is &lt;code&gt;comment&lt;/code&gt;, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is &lt;code&gt;no&lt;/code&gt;, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the &lt;code&gt;comment&lt;/code&gt; case. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;yes&lt;/code&gt; , все атрибуты файла &lt;code&gt;-file(...)&lt;/code&gt; в источниках ввода будут сохранены в результирующем коде. Если значением является &lt;code&gt;comment&lt;/code&gt; , они будут преобразованы в комментарии, но останутся на своих исходных позициях в коде относительно других форм исходного кода. Если значение равно &amp;laquo; &lt;code&gt;no&lt;/code&gt; , все атрибуты файла будут удалены из кода, если они не имеют прикрепленных комментариев, и в этом случае они будут обрабатываться так же, как и в случае &lt;code&gt;comment&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adbcfdf4ba5a2347d9fb627ce201117dc5c0ef19" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, comments will be inserted where important changes have been made in the code. If the value is &lt;code&gt;always&lt;/code&gt;, &lt;strong&gt;all&lt;/strong&gt; changes to the code will be commented. If the value is &lt;code&gt;no&lt;/code&gt;, changes will be made without comments. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &amp;laquo; &lt;code&gt;yes&lt;/code&gt; , комментарии будут вставлены там, где в код были внесены важные изменения. Если значение &lt;code&gt;always&lt;/code&gt; , &lt;strong&gt;все&lt;/strong&gt; изменения в коде будут комментироваться. Если значение &lt;code&gt;no&lt;/code&gt; , изменения будут внесены без комментариев. Значение по умолчанию - &lt;code&gt;yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6e4b8b19f612e8db0497538210759f4a802a7a" translate="yes" xml:space="preserve">
          <source>If the value is an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is &lt;code&gt;0&lt;/code&gt;. If a negative value is specified, and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to &lt;code&gt;0&lt;/code&gt;. Once the socket's message count reaches &lt;code&gt;0&lt;/code&gt;, either because of sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages &lt;code&gt;setopts/2&lt;/code&gt; must be called again to set the socket back into an active mode.</source>
          <target state="translated">Если значение представляет собой целое число &lt;code&gt;N&lt;/code&gt; в диапазоне от -32768 до 32767 (включительно), значение добавляется к счетчику сообщений с данными, отправленных сокету в управляющий процесс. Количество сообщений сокета по умолчанию равно &lt;code&gt;0&lt;/code&gt; . Если указано отрицательное значение, и его величина равна или больше текущего счетчика сообщений сокета, счетчик сообщений сокета устанавливается на &lt;code&gt;0&lt;/code&gt; . Когда счетчик сообщений сокета достигает &lt;code&gt;0&lt;/code&gt; , либо из-за отправки полученных сообщений с данными процессу, либо из-за того, что он явно установлен, процесс затем уведомляется специальным сообщением, специфичным для типа сокета, о том, что сокет перешел в пассивный режим. После того, как сокет перейдет в пассивный режим, для получения дополнительных сообщений &lt;code&gt;setopts/2&lt;/code&gt; необходимо вызвать снова, чтобы вернуть сокет в активный режим.</target>
        </trans-unit>
        <trans-unit id="1d64e50bdb357fa38cbabe7df4a1ba284de8e2a3" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is not changed. To reset unspecified data to default values, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5530eeda0dbd39b2cfac3192200b6c910a3a3fc5" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is set to default values. To update only specified data, and keep the existing configuration for the rest, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-3&quot;&gt; update_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ae6e2444bd7a3381110a92ec6a09bd736a61c" translate="yes" xml:space="preserve">
          <source>If the value is unreached, the socket closes for that connection.</source>
          <target state="translated">Если значение недостижимо,гнездо для этого соединения закрывается.</target>
        </trans-unit>
        <trans-unit id="f1873f4ce26bcbe85d55d9e02a463ab1ca24901c" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;keep_labels&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default, the &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; of vertices and edges of &lt;code&gt;Digraph&lt;/code&gt; are used for the subgraph as well. If the value is &lt;code&gt;false&lt;/code&gt;, default label &lt;code&gt;[]&lt;/code&gt; is used for the vertices and edges of the subgroup.</source>
          <target state="translated">Если значение опционного &lt;code&gt;keep_labels&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , что по умолчанию, &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; вершин и ребер &lt;code&gt;Digraph&lt;/code&gt; используются для подграфа , а также. Если значение равно &lt;code&gt;false&lt;/code&gt; , метка по умолчанию &lt;code&gt;[]&lt;/code&gt; используется для вершин и ребер подгруппы.</target>
        </trans-unit>
        <trans-unit id="4ff461d2c9c387ebf9328f2e5d5e82024d6aaa59" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc67adc4c7849178ee3be6d998ddde43abc28f4" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;digraph:new/1&lt;/code&gt;.</source>
          <target state="translated">Если значение опции &lt;code&gt;type&lt;/code&gt; является &lt;code&gt;inherit&lt;/code&gt; , который по умолчанию, тип &lt;code&gt;Digraph&lt;/code&gt; используется для подграфа , а также. В противном случае значение параметра &lt;code&gt;type&lt;/code&gt; используется в качестве аргумента для &lt;code&gt;digraph:new/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba47bdc09cc087bab1feb6d4f337fa682850229e" translate="yes" xml:space="preserve">
          <source>If the values listed in &lt;code&gt;os_mon.app&lt;/code&gt; do not suit your needs, do &lt;strong&gt;not&lt;/strong&gt; edit that file. Instead &lt;strong&gt;override&lt;/strong&gt; the values in a &lt;strong&gt;system configuration file&lt;/strong&gt;, the full pathname of which is given on the command line to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Если значения, перечисленные в &lt;code&gt;os_mon.app&lt;/code&gt; , не соответствуют вашим потребностям, &lt;strong&gt;не&lt;/strong&gt; редактируйте этот файл. Вместо этого &lt;strong&gt;переопределите&lt;/strong&gt; значения в &lt;strong&gt;файле конфигурации системы&lt;/strong&gt; , полный путь к которому указан в командной строке для &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637ddb8332f78117eadb8a8c376db3cd6652f59a" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;V&lt;/code&gt; is unbound, it becomes bound to the value associated with the key &lt;code&gt;K&lt;/code&gt;, which must exist in the map &lt;code&gt;M&lt;/code&gt;. If the variable &lt;code&gt;V&lt;/code&gt; is bound, it must match the value associated with &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Если переменная &lt;code&gt;V&lt;/code&gt; является несвязанной, он становится связанным со значением , связанным с ключом &lt;code&gt;K&lt;/code&gt; , который должен существовать в карте &lt;code&gt;M&lt;/code&gt; . Если переменная &lt;code&gt;V&lt;/code&gt; связана, он должен соответствовать значению , связанному с &lt;code&gt;K&lt;/code&gt; в &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e06ed1ef13287cb442c8f8b9883fc1684b5a4b49" translate="yes" xml:space="preserve">
          <source>If the variable is set to &lt;code&gt;0&lt;/code&gt; seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">Если для переменной установлено значение &lt;code&gt;0&lt;/code&gt; секунд, система времени выполнения даже не пытается записать файл аварийного дампа. Это только заканчивается. Это значение по умолчанию, если параметр &lt;code&gt;-heart&lt;/code&gt; передан в &lt;code&gt;erl&lt;/code&gt; , а &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; не установлен.</target>
        </trans-unit>
        <trans-unit id="259fac0804e610fe7290a6be7722e9d68bc70fed" translate="yes" xml:space="preserve">
          <source>If the variable is set to a positive value &lt;code&gt;S&lt;/code&gt;, wait for &lt;code&gt;S&lt;/code&gt; seconds to complete the crash dump file and then terminates the runtime system with a &lt;code&gt;SIGALRM&lt;/code&gt; signal.</source>
          <target state="translated">Если для переменной установлено положительное значение &lt;code&gt;S&lt;/code&gt; , подождите &lt;code&gt;S&lt;/code&gt; секунд, чтобы завершить создание файла аварийного дампа, а затем завершит работу системы времени выполнения сигналом &lt;code&gt;SIGALRM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ca06888e679b9ce4fb0be32462ee441fe3c9ca" translate="yes" xml:space="preserve">
          <source>If the verify callback fun always returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</source>
          <target state="translated">Если &lt;code&gt;{valid, UserState}&lt;/code&gt; обратного вызова verify всегда возвращает {valid, UserState} , рукопожатие TLS / DTLS не прекращается в связи с ошибками проверки и соединение устанавливается.</target>
        </trans-unit>
        <trans-unit id="719c8b9484d3005b5e9e676b6c959670afe78ad3" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</source>
          <target state="translated">Если функция обратного вызова verify возвращает &lt;code&gt;{fail, Reason}&lt;/code&gt; , процесс проверки немедленно останавливается, партнеру отправляется предупреждение, и квитирование TLS / DTLS завершается.</target>
        </trans-unit>
        <trans-unit id="cde2fb6c16d058822f25ed6337c5a200ce4ffc36" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped. If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process is continued. This can be used to accept specific path validation errors, such as &lt;code&gt;selfsigned_peer&lt;/code&gt;, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">Если функция обратного вызова verify возвращает &lt;code&gt;{fail, Reason}&lt;/code&gt; , процесс проверки немедленно останавливается. Если &lt;code&gt;{valid, UserState}&lt;/code&gt; обратного вызова verify возвращает {valid, UserState} , процесс проверки продолжается. Это можно использовать для принятия определенных ошибок проверки пути, таких как &lt;code&gt;selfsigned_peer&lt;/code&gt; , а также для проверки расширений для конкретных приложений. Если &lt;code&gt;{unknown, UserState}&lt;/code&gt; с расширением, неизвестным пользовательскому приложению, должно использоваться возвращаемое значение {unknown, UserState} .</target>
        </trans-unit>
        <trans-unit id="7ce417b1938b35d2181946cc1bbef96b4151dd19" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process continues.</source>
          <target state="translated">Если &lt;code&gt;{valid, UserState}&lt;/code&gt; обратного вызова verify возвращает {valid, UserState} , процесс проверки продолжается.</target>
        </trans-unit>
        <trans-unit id="0df79b705a85e7a2500ba7951bd6d85a1ee9ec5b" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">Если версия, прочитанная из файла &lt;code&gt;OTP_VERSION&lt;/code&gt; в системе разработки, имеет суффикс &lt;code&gt;**&lt;/code&gt; , система была исправлена ​​с &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; инструмента otp_patch_apply . В этом случае система состоит из версий приложения из нескольких версий OTP. Версия перед суффиксом &lt;code&gt;**&lt;/code&gt; соответствует версии OTP базовой системы, которая была исправлена. Обратите внимание, что если система разработки обновляется другим способом, кроме &lt;code&gt;otp_patch_apply&lt;/code&gt; , файл &lt;code&gt;OTP_VERSION&lt;/code&gt; может определить неправильную версию OTP.</target>
        </trans-unit>
        <trans-unit id="e21657b92f7a7a61994f9d4f2c34a81fd507ae44" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;otp_patch_apply&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f230a4391a7ac08d14e4fb4510c5ba298ff9d5d7" translate="yes" xml:space="preserve">
          <source>If the wrap log is not full because all files are not yet used, &lt;code&gt;{error, end_of_log}&lt;/code&gt; is returned if trying to step outside the log.</source>
          <target state="translated">Если журнал &lt;code&gt;{error, end_of_log}&lt;/code&gt; не заполнен, потому что все файлы еще не использованы, при попытке выйти за пределы журнала возвращается {error, end_of_log} .</target>
        </trans-unit>
        <trans-unit id="f46b1e432470475ec50697579521d2c2bae67ee6" translate="yes" xml:space="preserve">
          <source>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</source>
          <target state="translated">Если после этого загружается новый экземпляр модуля (например,из-за исправления ошибок),код предыдущего экземпляра становится &quot;старым&quot;,а все записи экспорта,относящиеся к предыдущему экземпляру,удаляются.После этого новый экземпляр загружается,как и в первый раз,и становится &quot;текущим&quot;.</target>
        </trans-unit>
        <trans-unit id="a1c29be5cd8e91fa1db97518d47656645435250e" translate="yes" xml:space="preserve">
          <source>If there already exists a child specification with the specified identifier, &lt;code&gt;ChildSpec&lt;/code&gt; is discarded, and the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt;, depending on if the corresponding child process is running or not.</source>
          <target state="translated">Если уже существует &lt;code&gt;ChildSpec&lt;/code&gt; спецификация с указанным идентификатором, ChildSpec отбрасывается, и функция возвращает &lt;code&gt;{error,already_present}&lt;/code&gt; или &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt; , в зависимости от того, запущен соответствующий дочерний процесс или нет.</target>
        </trans-unit>
        <trans-unit id="29f67842a562c035ba90f5d1c233372af3669459" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupBridgeName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">Если уже существует процесс с указанным &lt;code&gt;SupBridgeName&lt;/code&gt; , функция возвращает &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это pid этого процесса.</target>
        </trans-unit>
        <trans-unit id="b068d3b22b44bd5f6e7c211c147d05d61566b01d" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">Если уже существует процесс с указанным &lt;code&gt;SupName&lt;/code&gt; , функция возвращает &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это pid этого процесса.</target>
        </trans-unit>
        <trans-unit id="b8fb3b2e8b37c9a0306fd62b9b9f0fc3fa52b199" translate="yes" xml:space="preserve">
          <source>If there already is current code for the module, that code will remain current and can be called until the &lt;code&gt;on_load&lt;/code&gt; function has returned. If the &lt;code&gt;on_load&lt;/code&gt; function fails, the current code (if any) will remain current. If there is no current code for a module, any process that makes an external call to the module before the &lt;code&gt;on_load&lt;/code&gt; function has finished will be suspended until the &lt;code&gt;on_load&lt;/code&gt; function have finished.</source>
          <target state="translated">Если для модуля уже есть текущий код, этот код останется текущим и может быть вызван до тех пор, &lt;code&gt;on_load&lt;/code&gt; функция on_load не вернется. Если функция &lt;code&gt;on_load&lt;/code&gt; не работает, текущий код (если есть) останется текущим. Если для модуля нет текущего кода, любой процесс, который выполняет внешний вызов модуля до &lt;code&gt;on_load&lt;/code&gt; функции on_load , будет приостановлен до &lt;code&gt;on_load&lt;/code&gt; функции on_load .</target>
        </trans-unit>
        <trans-unit id="e6ff40b943ba1d358ca3fc56a993cb85906a59fb" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828714b66dcf56b96deedb054ba47d438cc6af67" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this list.</source>
          <target state="translated">Если есть события в очереди, &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; для возможного нового состояния вызывается с самым старым событием в очереди, и мы начинаем снова с начала этого списка.</target>
        </trans-unit>
        <trans-unit id="e9b0222c78d7e23a53bc0a01971716c3d93b0537" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt; erlang:garbage_collect/0 &lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44555dd341d5b0e52ff1661ee5eda131159416ee" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">Если есть добавленные в очередь события для обработки при запросе гибернации, это оптимизируется, не &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; спящий режим, а вместо этого вызывая erlang: garbage_collect / 0 для имитации того, что &lt;code&gt;gen_statem&lt;/code&gt; вошел в спящий режим и сразу же был разбужен событием из очереди.</target>
        </trans-unit>
        <trans-unit id="8322fe14ba9a9426d69e7f2423c508cc09e9ca48" translate="yes" xml:space="preserve">
          <source>If there are more than one modify_algorithms options, the result is undefined.</source>
          <target state="translated">Если имеется более одного параметра modify_algorithms,результат будет неопределен.</target>
        </trans-unit>
        <trans-unit id="3690ce212d6493d7841d406b4cec0802d81f2e96" translate="yes" xml:space="preserve">
          <source>If there are no more associations in the iterator, &lt;code&gt;none&lt;/code&gt; is returned.</source>
          <target state="translated">Если в итераторе больше нет ассоциаций, &lt;code&gt;none&lt;/code&gt; не возвращается.</target>
        </trans-unit>
        <trans-unit id="e9815b352e2d989c9ac48ca673c35c72745e841d" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is not recommended to use this atom as the key for any user records.</source>
          <target state="translated">Если в таблице нет записей, эта функция возвращает атом &lt;code&gt;'$end_of_table'&lt;/code&gt; . Не рекомендуется использовать этот атом в качестве ключа для каких-либо пользовательских записей.</target>
        </trans-unit>
        <trans-unit id="45cad60d0486a292ed0c0af70654056064441d58" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</source>
          <target state="translated">Если в таблице нет записей, эта функция возвращает атом &lt;code&gt;'$end_of_table'&lt;/code&gt; . Поэтому крайне нежелательно, но не запрещается использовать этот атом в качестве ключа для любых пользовательских записей.</target>
        </trans-unit>
        <trans-unit id="8503df3ac3ca7273d732e58802cad2a3a0dfc645" translate="yes" xml:space="preserve">
          <source>If there are no suitable peers, or if &lt;code&gt;pick_peer/4&lt;/code&gt; rejects them by returning &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;{error,no_connection}&lt;/code&gt; is returned. Otherwise &lt;code&gt;pick_peer/4&lt;/code&gt; is followed by a &lt;code&gt;prepare_request/3&lt;/code&gt; callback, the message is encoded and then sent.</source>
          <target state="translated">Если подходящих пиров нет или &lt;code&gt;pick_peer/4&lt;/code&gt; отклоняет их, возвращая &lt;code&gt;false&lt;/code&gt; , то возвращается &lt;code&gt;{error,no_connection}&lt;/code&gt; . В противном случае за &lt;code&gt;pick_peer/4&lt;/code&gt; следует обратный вызов &lt;code&gt;prepare_request/3&lt;/code&gt; , сообщение кодируется и затем отправляется.</target>
        </trans-unit>
        <trans-unit id="17bbd36158389d16f581ae00cabe7d0d4b0d0c37" translate="yes" xml:space="preserve">
          <source>If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если в соединении есть открытые сеансы NETCONF, они будут жестко прерваны. Чтобы этого избежать, закрывайте каждую сессию с помощью &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="744bfeb045fa800e48c24a368ddf960ab780e491" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">Если есть другие &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; драйвера, счетчики ссылок драйвера просто уменьшаются, так что вызывающий абонент больше не считается &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; драйвера. Сценарии использования см. В &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; в начале этого модуля.</target>
        </trans-unit>
        <trans-unit id="ad1eb612ef6dd4e45361d0987788045dfb4b5f75" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">Если есть другие &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; драйвера, счетчики ссылок на драйвер просто уменьшаются, так что вызывающий больше не считается &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; . Сценарии использования см. В &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; в начале этого модуля.</target>
        </trans-unit>
        <trans-unit id="3a3b63451c0aef92b5965292576792be22d886c0" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this driver, the function returns &lt;code&gt;{error, pending_process}&lt;/code&gt;, but if there are no other users, the function call hangs until all open ports are closed.</source>
          <target state="translated">Если есть другие &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; этого драйвера, функция возвращает &lt;code&gt;{error, pending_process}&lt;/code&gt; , но если других пользователей нет, вызов функции зависает, пока все открытые порты не будут закрыты.</target>
        </trans-unit>
        <trans-unit id="ddfc5d95528ec782f6cb446ae853ade32ce2c1f9" translate="yes" xml:space="preserve">
          <source>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</source>
          <target state="translated">Если есть две активные копии таблиц,вся информация остается доступной,если одна копия не удается.Это может быть важным свойством во многих приложениях.Более того,если реплика таблицы существует на двух определенных узлах,приложения,выполняющиеся на любом из этих узлов,могут читать данные из таблицы без доступа к сети.Сетевые операции значительно медленнее и потребляют больше ресурсов,чем локальные операции.</target>
        </trans-unit>
        <trans-unit id="4c985df66903880210d4fc66a0001c590df114fc" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;erase/1&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370b7e007fd730b4b67804cb8f3411b765c85a30" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;put/2&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a74b61b8a7a65ef993947d91f15d8fda49a9eb" translate="yes" xml:space="preserve">
          <source>If there has not been any exceptions in a process, the stacktrace is &lt;code&gt;[]&lt;/code&gt;. After a code change for the process, the stacktrace can also be reset to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Если в процессе не было никаких исключений, трассировка стека будет &lt;code&gt;[]&lt;/code&gt; . После изменения кода процесса трассировку стека также можно сбросить на &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="231307e5b86795ba02c3c7007a265d1b3815a9d6" translate="yes" xml:space="preserve">
          <source>If there is NO &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field will be checked. All &lt;code&gt;CN&lt;/code&gt; names will be compared to all hostnames</source>
          <target state="translated">Если нет поля &amp;laquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; поле &amp;laquo; &lt;code&gt;Subject&lt;/code&gt; будет проверено. Все имена &lt;code&gt;CN&lt;/code&gt; будут сравниваться со всеми именами хостов</target>
        </trans-unit>
        <trans-unit id="68e6d1b8204d4e4cbe66b0a3f70bd3fdbea57001" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;{uri_id,string()}&lt;/code&gt; in the function call will be compared to any &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; in the Certificate field. If the two &lt;code&gt;strings()&lt;/code&gt; are equal (case insensitive), there is a match. The same applies for any &lt;code&gt;{dns_id,string()}&lt;/code&gt; in the call which is compared with all &lt;code&gt;{dNSName,string()}&lt;/code&gt; in the Certificate field.</source>
          <target state="translated">Если есть поле &amp;laquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; , &lt;code&gt;{uri_id,string()}&lt;/code&gt; в вызове функции будет сравниваться с любым &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; в поле Certificate. Если две &lt;code&gt;strings()&lt;/code&gt; равны (без учета регистра), есть совпадение. То же самое относится к любому &lt;code&gt;{dns_id,string()}&lt;/code&gt; в вызове, который сравнивается со всеми &lt;code&gt;{dNSName,string()}&lt;/code&gt; в поле Сертификат.</target>
        </trans-unit>
        <trans-unit id="7f945a017af252bdab418ccd24ce5005c146d8f7" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt; such that &lt;code&gt;Pred(Value)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;{value, Value}&lt;/code&gt; for the first such &lt;code&gt;Value&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если есть &lt;code&gt;Value&lt;/code&gt; в &lt;code&gt;List&lt;/code&gt; такого , что &lt;code&gt;Pred(Value)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , возвращает &lt;code&gt;{value, Value}&lt;/code&gt; для первой такой &lt;code&gt;Value&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f55a97af173d19104e4db4d68ae43bf0a349635" translate="yes" xml:space="preserve">
          <source>If there is a garbage collection before the result is stored, the stack will move and if the &lt;code&gt;d&lt;/code&gt; operand refered to a Y register, the pointer will no longer be valid. (Y registers are stored on the stack.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37a03a5a10dfe3b584b5087ad2e3ee6b552e40a" translate="yes" xml:space="preserve">
          <source>If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).</source>
          <target state="translated">Если есть подходящий сбой справа,то обратный ход (*PRUNE)вызывает его срабатывание,и его действие выполняется.Никогда не может быть обратного хода (*COMMIT).</target>
        </trans-unit>
        <trans-unit id="772eaa5a9bb7c808e1d1ad944ded54de87cfcbf6" translate="yes" xml:space="preserve">
          <source>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</source>
          <target state="translated">Если где-то в тексте есть синтаксическая ошибка (как,например,отсутствующая точка с запятой во втором пункте выше),это позволяет Merl генерировать сообщение об ошибке,указывающее на точную строку в вашем исходном коде.(Просто не забудьте разделить строки в списке на запятые,иначе Erlang скомпонуетрует фрагменты строк так,как если бы они были одной строкой).</target>
        </trans-unit>
        <trans-unit id="eb988198b3b89a8ead41c2c06ba00583a45e57ec" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; option on some level the whole set is replaced by that in that option and &lt;strong&gt;all modify_algorithms are applied&lt;/strong&gt; in level ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8de65cd10bf00bba2999acc7df58c16d7692021" translate="yes" xml:space="preserve">
          <source>If there is data buffered in the socket port, the attempt to shutdown the socket is postponed until that data is written to the kernel socket send buffer. If any errors are encountered, the socket is closed and &lt;code&gt;{error, closed}&lt;/code&gt; is returned on the next &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если есть данные, буферизованные в порту сокета, попытка выключить сокет откладывается до тех пор, пока эти данные не будут записаны в буфер отправки сокета ядра. Если обнаружены какие-либо ошибки, сокет закрывается и &lt;code&gt;{error, closed}&lt;/code&gt; возвращается при следующем &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab5c589483e29b598b39704e5336b70db6c69642" translate="yes" xml:space="preserve">
          <source>If there is more than one subpattern with the same name, the earliest one is used.</source>
          <target state="translated">Если существует более одной подмаски с одним и тем же именем,используется самая ранняя.</target>
        </trans-unit>
        <trans-unit id="bbc551c6c725ba0dac8c61943a105b6a103c7e97" translate="yes" xml:space="preserve">
          <source>If there is no matching message in the mailbox, the timeout occurs immediately.</source>
          <target state="translated">Если в почтовом ящике нет соответствующего сообщения,таймаут происходит немедленно.</target>
        </trans-unit>
        <trans-unit id="cc738995866b9be8195d9f8399cccd32d281ee8b" translate="yes" xml:space="preserve">
          <source>If there is no matching pattern with a true guard sequence, a &lt;code&gt;case_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Если нет подходящего шаблона с истинной защитной последовательностью, возникает &lt;code&gt;case_clause&lt;/code&gt; выполнения case_clause .</target>
        </trans-unit>
        <trans-unit id="f5a0ffa17cfe9167811739038f7d8ac026fb1794" translate="yes" xml:space="preserve">
          <source>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys.</source>
          <target state="translated">При отсутствии открытого ключа указанного типа соответствующая запись игнорируется.Обратите внимание,что доступный набор зависит от лежащего в основе криптографического ключа и открытых ключей текущего пользователя.</target>
        </trans-unit>
        <trans-unit id="2104c47ce32bc96eff6c32dbc5479f514ba24093" translate="yes" xml:space="preserve">
          <source>If there is not enough space available on the heap to satisfy the &lt;code&gt;test_heap&lt;/code&gt; instructions request for memory, then a garbage collection is initiated. It may happen immediately in the &lt;code&gt;test_heap&lt;/code&gt; instruction, or it can be delayed until a later time depending on what state the process is in. If the garbage collection is delayed, any memory needed will be allocated in heap fragments. Heap fragments are extra memory blocks that are a part of the young heap, but are not allocated in the contigious area where terms normally reside. See &lt;code&gt;&lt;a href=&quot;#The-young-heap&quot;&gt;The young heap&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c43ed956f51818838543c55451a2fcd8d8fee88" translate="yes" xml:space="preserve">
          <source>If there was a supervised connection between &lt;code&gt;Handler1&lt;/code&gt; and a process &lt;code&gt;Pid&lt;/code&gt;, there is a supervised connection between &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Pid&lt;/code&gt; instead.</source>
          <target state="translated">Если существовало контролируемое соединение между &lt;code&gt;Handler1&lt;/code&gt; и &lt;code&gt;Pid&lt;/code&gt; процесса , вместо этого существует контролируемое соединение между &lt;code&gt;Handler2&lt;/code&gt; и &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c67211fc881043f6c0597b9ecfceb976f47baf4" translate="yes" xml:space="preserve">
          <source>If there was some bug in &lt;code&gt;lists:reverse/1&lt;/code&gt; that made it return something other than &lt;code&gt;[2,1]&lt;/code&gt; when it got &lt;code&gt;[1,2]&lt;/code&gt; as input, then the last test above would throw a &lt;code&gt;badmatch&lt;/code&gt; error. The first two (we assume they do not get a &lt;code&gt;badmatch&lt;/code&gt;) would simply return &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt;, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</source>
          <target state="translated">Если в &lt;code&gt;lists:reverse/1&lt;/code&gt; была какая-то ошибка, из-за которой он возвращал что-то отличное от &lt;code&gt;[2,1]&lt;/code&gt; , когда он получил &lt;code&gt;[1,2]&lt;/code&gt; в качестве входных данных, то последний тест, приведенный выше, &lt;code&gt;badmatch&lt;/code&gt; ошибку плохого соответствия . Первые два (мы предполагаем, что они не получают &lt;code&gt;badmatch&lt;/code&gt; ) просто вернут &lt;code&gt;[]&lt;/code&gt; и &lt;code&gt;[1]&lt;/code&gt; соответственно, так что оба будут успешными. (Обратите внимание, что EUnit не является экстрасенсом: если вы напишете тест, который возвращает значение, даже если это неправильное значение, EUnit будет считать его успешным. Вы должны убедиться, что тест написан так, что он вызывает сбой, если результат не такой, каким должен быть.)</target>
        </trans-unit>
        <trans-unit id="ac4dc8c4f9cc87ef06af906dc31bb54276084fd9" translate="yes" xml:space="preserve">
          <source>If these requirements are not fulfilled, the system may behave very bad.</source>
          <target state="translated">Если эти требования не будут выполнены,система может вести себя очень плохо.</target>
        </trans-unit>
        <trans-unit id="b741a6b0067d17a99e20727d386f0f44e405815c" translate="yes" xml:space="preserve">
          <source>If these return values are used from a &lt;strong&gt;state enter call&lt;/strong&gt; the &lt;code&gt;OldState&lt;/code&gt; does not change, but if used from an event handling &lt;strong&gt;state callback&lt;/strong&gt; the new &lt;strong&gt;state enter call's&lt;/strong&gt;&lt;code&gt;OldState&lt;/code&gt; will be the current state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e69ed9e46453ec19298157c854f6a3eaec0abc5" translate="yes" xml:space="preserve">
          <source>If this attribute is not specified, the version defaults to the MD5 checksum of the module.</source>
          <target state="translated">Если этот атрибут не указан,то по умолчанию версия имеет контрольную сумму MD5 модуля.</target>
        </trans-unit>
        <trans-unit id="aa0c65a5a17658e764f89aa9eb9e0a1ff2afe4bb" translate="yes" xml:space="preserve">
          <source>If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return &lt;code&gt;{State,Info}&lt;/code&gt;, where &lt;code&gt;Info&lt;/code&gt; says nothing but the fact that &lt;code&gt;format_status/2&lt;/code&gt; has crashed.</source>
          <target state="translated">Если этот обратный вызов экспортируется, но терпит неудачу, чтобы скрыть потенциально конфиденциальные данные, функция по умолчанию вместо этого вернет &lt;code&gt;{State,Info}&lt;/code&gt; , где &lt;code&gt;Info&lt;/code&gt; не говорит ничего, кроме того факта, что &lt;code&gt;format_status/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="714e5e0a8e521c47efda0340fa656dbd50e5c01b" translate="yes" xml:space="preserve">
          <source>If this configuration parameter is set, it replaces both the default report callback, and any report callback found in metadata. That is, all reports are converted by this configured function.</source>
          <target state="translated">Если этот параметр конфигурации установлен,он заменяет как вызов отчета по умолчанию,так и любой вызов отчета,найденный в метаданных.То есть все отчеты преобразуются этой настроенной функцией.</target>
        </trans-unit>
        <trans-unit id="1be583879f0eb7412bbdfda911217bb43a748c07" translate="yes" xml:space="preserve">
          <source>If this does not work on your system, the documentation is included as HTML in the Erlang/OTP release. You can also read the documentation as HTML or download it as PDF from either of the sites www.erlang.se (commercial Erlang) or www.erlang.org (open source). For example, for Erlang/OTP release R9B:</source>
          <target state="translated">Если это не работает в вашей системе,документация включается в качестве HTML в релиз Erlang/OTP.Вы также можете прочитать документацию в формате HTML или скачать ее в формате PDF с любого из сайтов www.erlang.se (коммерческий Erlang)или www.erlang.org (с открытым исходным кодом).Например,для Erlang/OTP-релиза R9B:</target>
        </trans-unit>
        <trans-unit id="a3eb530f2543acfe6aa144c1bf97c7dbef8076b8" translate="yes" xml:space="preserve">
          <source>If this feature is used while no such &lt;code&gt;TimeoutType&lt;/code&gt; is running then a time-out event is immediately delivered as when starting a &lt;code&gt;&lt;a href=&quot;#Time-Out%20Zero&quot;&gt;Time-Out Zero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ae399292df5e1214de0f1c430950be7c775936" translate="yes" xml:space="preserve">
          <source>If this flag is present, &lt;code&gt;global&lt;/code&gt; does not maintain a fully connected network of distributed Erlang nodes, and then global name registration cannot be used; see &lt;code&gt;global(3)&lt;/code&gt;.</source>
          <target state="translated">Если этот флаг присутствует, &lt;code&gt;global&lt;/code&gt; не поддерживает полностью подключенную сеть распределенных узлов Erlang, и тогда регистрация глобального имени не может использоваться; см. &lt;code&gt;global(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f07b81995e2058716b31282ea839a19974f67348" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; is returned when there are errors. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если этот флаг установлен, при возникновении ошибок возвращается &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; . По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5398762fceee6e07d9e93fb018e02eda7d682593" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; is returned when there are errors.</source>
          <target state="translated">Если этот флаг установлен, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; возвращается {error, ErrorList, WarningList} .</target>
        </trans-unit>
        <trans-unit id="6be13d0e071b42b8d41878615f2879c487393169" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field containing &lt;code&gt;Warnings&lt;/code&gt; is added to the tuple returned upon success. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если этот флаг установлен, к кортежу, возвращаемому в случае успеха, добавляется дополнительное поле, содержащее &lt;code&gt;Warnings&lt;/code&gt; . По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3313bf48f0cdfa74884b1da2da53a7543532d3d4" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field, containing &lt;code&gt;WarningList&lt;/code&gt;, is added to the tuples returned on success.</source>
          <target state="translated">Если этот флаг установлен, к кортежам, возвращаемым в случае успеха, добавляется дополнительное поле, содержащее &lt;code&gt;WarningList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4261f0fa61ea721311b8153168daa7bcae82ceb" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to process the action requests itself or to delegate the processing to this function.</source>
          <target state="translated">Если эта функция вызывается или не вызывается,то она управляется ответом с предыдущего вызова на handle_trans_request/3.Функция handle_trans_request/3 может принять решение об обработке запроса на выполнение действия самостоятельно или делегировать обработку этой функции.</target>
        </trans-unit>
        <trans-unit id="759c6aff89e36cb13b1929cdb56543f2723e5912" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not, is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to return {handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} meaning that you need an immediate acknowledgement of the reply and that this function should be invoked to handle the acknowledgement.</source>
          <target state="translated">Если эта функция вызывается или нет,то управляется ответом с предыдущего вызова на handle_trans_request/3.Функция handle_trans_request/3 может принять решение о возвращении {handle_ack,ack_data()}или {handle_sloppy_ack,ack_data()},что означает,что необходимо немедленное подтверждение ответа и что эта функция должна быть вызвана для обработки подтверждения.</target>
        </trans-unit>
        <trans-unit id="2db2202db664ddf13d01713aaa8bc9ba006f0ed4" translate="yes" xml:space="preserve">
          <source>If this function is called, it can only be called once and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt; library are called.</source>
          <target state="translated">Если эта функция вызывается, она может быть вызвана только один раз и должна быть вызвана перед вызовом любых других функций в библиотеке &lt;code&gt;ei&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63459ad5b8a5024794d9f8294a76e897d53d7890" translate="yes" xml:space="preserve">
          <source>If this function is called, it may only be called once directly after the call to function &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если эта функция вызывается, ее можно вызвать только один раз сразу после вызова функции &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd06471c1b7c9a2e79736c5c3baade29102ed76" translate="yes" xml:space="preserve">
          <source>If this function is called, it will be called again, either with &lt;code&gt;undo&lt;/code&gt; or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">Если эта функция вызывается, она будет вызвана снова либо с &lt;code&gt;undo&lt;/code&gt; либо с &lt;code&gt;set&lt;/code&gt; качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="57d5ad72a18485e89bafa2b5eeeeaab800a1356c" translate="yes" xml:space="preserve">
          <source>If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise.</source>
          <target state="translated">Если эта функция не вызывается,функция запуска возвращает кортеж ошибки (если используется ссылка и/или тайм-аут)или зависает иным образом.</target>
        </trans-unit>
        <trans-unit id="8c7cb778dcaeb301678f8381c719400450da4a70" translate="yes" xml:space="preserve">
          <source>If this function returns with a next state that does not match equal (&lt;code&gt;=/=&lt;/code&gt;) to the current state, all postponed events are retried in the next state.</source>
          <target state="translated">Если эта функция возвращается со следующим состоянием, которое не соответствует ( &lt;code&gt;=/=&lt;/code&gt; ) текущему состоянию, все отложенные события повторяются в следующем состоянии.</target>
        </trans-unit>
        <trans-unit id="3a0ed99dde48840d29c014e939552bc11b14d1d1" translate="yes" xml:space="preserve">
          <source>If this function's body does not return an inline constant value the callback module is doing something strange.</source>
          <target state="translated">Если тело этой функции не возвращает строчную константу,то модуль обратного вызова делает что-то странное.</target>
        </trans-unit>
        <trans-unit id="33d0e448805fb8a37d99a0aff84679f18601e686" translate="yes" xml:space="preserve">
          <source>If this is a &lt;strong&gt;state change&lt;/strong&gt;, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82460753c54ada648d7c9b05b35bd78eae8d83fe" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean use something like this:</source>
          <target state="translated">Если это проблема,для генерации булера используйте нечто подобное:</target>
        </trans-unit>
        <trans-unit id="c64d2ab7023f50eed11754a4818012e0a3833abd" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean with these algorithms use something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac87d883ad765b014bd68fa86e8b2ac8f132c75" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings.</source>
          <target state="translated">Если этот макрос определен,он переопределяет макрос NOASSERT,заставляя всегда включать макросы утверждения независимо от других настроек.</target>
        </trans-unit>
        <trans-unit id="ef12b2a17adab036f91ae1c37a457dabe1673cb6" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled.</source>
          <target state="translated">Если данный макрос определен,то он переопределяет макрос NODEBUG,заставляя включать отладочные макросы.</target>
        </trans-unit>
        <trans-unit id="f89fd4ecae86929dc6deae32a5e245a30ab74c60" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt;. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled.</source>
          <target state="translated">Если этот макрос определен, макросы assert не будут иметь никакого эффекта, когда тестирование также отключено. См. &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt; . Когда тестирование включено, макросы assert всегда включаются автоматически и не могут быть отключены.</target>
        </trans-unit>
        <trans-unit id="79358b57c58e42b823acfaf278614ec9c7ce54cc" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the automatic exporting or stripping of test functions will be disabled.</source>
          <target state="translated">Если данный макрос определен,автоматический экспорт или удаление функций тестирования будет отключен.</target>
        </trans-unit>
        <trans-unit id="6681ab5371316488374f8d3a60e956558c52d69e" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the debugging macros will have no effect. See &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NODEBUG&lt;/code&gt; also implies &lt;code&gt;NOASSERT&lt;/code&gt;, unless testing is enabled.</source>
          <target state="translated">Если этот макрос определен, отладочные макросы не действуют. См. &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;NODEBUG&lt;/code&gt; также подразумевает &lt;code&gt;NOASSERT&lt;/code&gt; , если не включено тестирование.</target>
        </trans-unit>
        <trans-unit id="781581d91da20944d9d397cd0ddb27951b613d6e" translate="yes" xml:space="preserve">
          <source>If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;, get much slower. The key element is not compressed.</source>
          <target state="translated">Если этот параметр присутствует, данные таблицы сохраняются в более компактном формате, чтобы потреблять меньше памяти. Однако это замедлит работу с таблицами. В частности, операции, требующие проверки целых объектов, такие как &lt;code&gt;match&lt;/code&gt; и &lt;code&gt;select&lt;/code&gt; , выполняются намного медленнее. Ключевой элемент не сжат.</target>
        </trans-unit>
        <trans-unit id="39baea08169404ce3fe44fe53586745d1c2f63db" translate="yes" xml:space="preserve">
          <source>If this option is present, the table is registered under its &lt;code&gt;Name&lt;/code&gt; which can then be used instead of the table identifier in subsequent operations.</source>
          <target state="translated">Если этот параметр присутствует, таблица регистрируется под своим &lt;code&gt;Name&lt;/code&gt; которое затем может использоваться вместо идентификатора таблицы в последующих операциях.</target>
        </trans-unit>
        <trans-unit id="ee4b6929098a40cbdbaf168a7fca6dd6bafa6ed5" translate="yes" xml:space="preserve">
          <source>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as &lt;code&gt;(?&amp;gt;&lt;/code&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as &lt;code&gt;{1,3}&lt;/code&gt;. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</source>
          <target state="translated">Если этот параметр установлен, большинство символов пробела в шаблоне полностью игнорируются, за исключением экранированных или внутри класса символов. Однако пробелы не допускаются ни в последовательностях, таких как &lt;code&gt;(?&amp;gt;&lt;/code&gt; , Которые вводят различные подшаблоны в скобках, ни в числовом квантификаторе, таком как &lt;code&gt;{1,3}&lt;/code&gt; . Однако игнорируемые пробелы разрешены между элементом и последующим квантификатором, а также между квантификатор и следующий +, указывающий на собственничество.</target>
        </trans-unit>
        <trans-unit id="fdc99f2839fcd867c278ae874f9e2a13c5e1d784" translate="yes" xml:space="preserve">
          <source>If this option is written in the source code, as a &lt;code&gt;-compile&lt;/code&gt; directive, the syntax &lt;code&gt;F/A&lt;/code&gt; can be used instead of &lt;code&gt;{F,A}&lt;/code&gt;, for example:</source>
          <target state="translated">Если этот параметр записан в исходном коде как директива &lt;code&gt;-compile&lt;/code&gt; , синтаксис &lt;code&gt;F/A&lt;/code&gt; может использоваться вместо &lt;code&gt;{F,A}&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="bd13526ac2fef0e27a961572d9dc8a9a077d1b66" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/hosts&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">Если этот параметр не задан, то по умолчанию &lt;code&gt;/etc/hosts&lt;/code&gt; , если переменная окружения &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; не установлен, который определяет каталог для этого файла для некоторых , может быть, кроме &lt;code&gt;/etc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1c08841ffeb7fe23cca25114d889442e8c01cb" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/resolv.conf&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">Если этот параметр не задан, то по умолчанию &lt;code&gt;/etc/resolv.conf&lt;/code&gt; , если переменная окружения &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; не установлен, который определяет каталог для этого файла , некоторые , может быть , кроме &lt;code&gt;/etc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45ec4c57907492a2ec83d9fdbff265e2b0072af9" translate="yes" xml:space="preserve">
          <source>If this pattern is embedded in a larger one, a relative reference can be used:</source>
          <target state="translated">Если эта деталь встроена в более крупную,можно использовать относительную ссылку:</target>
        </trans-unit>
        <trans-unit id="e8050ea746b1df5e9d9c36102bf42da460ef8d08" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file, which uses Apache-like syntax. The file must include all properties listed under mandatory properties. The Apache-like syntax is the property, written as one word where each new word begins with a capital, followed by a white-space, followed by the value, followed by a new line.</source>
          <target state="translated">Если это свойство определено, &lt;code&gt;Inets&lt;/code&gt; ожидает найти все другие свойства, определенные в этом файле, который использует синтаксис, подобный Apache. Файл должен включать все свойства, перечисленные в обязательных свойствах. Синтаксис, подобный Apache, - это свойство, записанное как одно слово, в котором каждое новое слово начинается с заглавной буквы, за которой следует пробел, за которым следует значение, за которым следует новая строка.</target>
        </trans-unit>
        <trans-unit id="09a2a375a69f2029267ac74ac850aabd642821a4" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties.</source>
          <target state="translated">Если это свойство определено, &lt;code&gt;Inets&lt;/code&gt; ожидает найти все другие свойства, определенные в этом файле. Файл должен включать все свойства, перечисленные в обязательных свойствах.</target>
        </trans-unit>
        <trans-unit id="fd3402a2f2f441f42f83cdd07b86e7ab04f0ace1" translate="yes" xml:space="preserve">
          <source>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</source>
          <target state="translated">Если такая ситуация неприемлема,то эту функцию можно использовать для переопределения стратегии алгоритма загрузки таблиц Мнезии.Это может привести к ситуации,когда в результате некоторые эффекты транзакций теряются при использовании несовместимой базы данных,но для некоторых приложений высокая доступность более важна,чем последовательные данные.</target>
        </trans-unit>
        <trans-unit id="059c4f891420c8ec95d1abb34b55edc8941662f6" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each mib- entry is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic mibentry name is used for different oid's.</source>
          <target state="translated">Если это значение ложное,то при загрузке мибра каждый ввод мибра проверяется перед установкой мибра.Цель проверки-предотвратить использование одного и того же символического названия мибритки для разных видов опухоли.</target>
        </trans-unit>
        <trans-unit id="d5be0ef33ffc0742762d89cfb5dcdc57978e4cec" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each trap is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic trap name is used for different trap's.</source>
          <target state="translated">Если это значение ложное,то при загрузке мибра каждый ловушка проверяется перед установкой мибра.Цель проверки-предотвратить использование одного и того же символического имени ловушки для разных ловушек.</target>
        </trans-unit>
        <trans-unit id="d93bdc2ebb6849c84f900f395d346a1101af31f5" translate="yes" xml:space="preserve">
          <source>If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:</source>
          <target state="translated">Если это часть более крупной детали,то не нужно будет повторять всю деталь,поэтому вместо этого можно использовать ее:</target>
        </trans-unit>
        <trans-unit id="739efd088e9bee0d304554cfa5fdd5c4e61ba305" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time can warp forwards or stop, or even freeze for extended periods of time. There are then no guarantees that the frequency of the Erlang monotonic clock is accurate or stable.</source>
          <target state="translated">Если временная коррекция отключена,то монотонное время Эрланга может искривляться вперед,останавливаться или даже замораживаться на длительный период времени.Тогда нет никаких гарантий,что частота монотонных часов Эрланга будет точной или стабильной.</target>
        </trans-unit>
        <trans-unit id="ffd673f8288d651f4732e547bc38b22a211807fc" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time leaps forward if OS system time leaps forward. If OS system time leaps backwards, Erlang monotonic time stops briefly, but it does not freeze for extended periods of time. This as the time offset is changed to align Erlang system time with OS system time.</source>
          <target state="translated">Если корректировка времени отключена,то монотонное время Эрланга прыгает вперёд,если системное время операционной системы прыгает вперёд.Если системное время ОС прыгает в обратном направлении,монотонное время Эрланга на короткое время останавливается,но не останавливается на продолжительное время.Это происходит потому,что смещение времени изменяется для выравнивания системного времени Эрланга с системным временем ОС.</target>
        </trans-unit>
        <trans-unit id="e95c3e3e415f307880ab62a824dbb61d407166b0" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, changes in OS system time affects the monotonic clock the same way as when the &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Если коррекция времени отключена, изменения системного времени ОС влияют на монотонные часы так же, как при использовании &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d01b0a13b53f09d09cc8091e67871a996e4027e2" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, adjustments to the Erlang monotonic clock are made to keep its frequency as correct as possible. However, &lt;strong&gt;no&lt;/strong&gt; adjustments are made trying to align Erlang system time and OS system time. That is, during the preliminary phase Erlang system time and OS system time can diverge from each other, and no attempt is made to prevent this.</source>
          <target state="translated">Если временная коррекция включена, монотонные часы Эрланга регулируются, чтобы поддерживать их частоту как можно более правильной. Однако &lt;strong&gt;никаких&lt;/strong&gt; корректировок не производится, пытаясь согласовать системное время Erlang и системное время ОС. То есть во время предварительной фазы системное время Erlang и системное время ОС могут отличаться друг от друга, и не предпринимается никаких попыток предотвратить это.</target>
        </trans-unit>
        <trans-unit id="d5d7906513f874fdde48593a22b63bd033c683a3" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, the Erlang runtime system makes use of both &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;, to adjust the frequency of the Erlang monotonic clock. Time correction ensures that &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; does not warp and that the frequency is relatively accurate. The type of frequency adjustments depends on the time warp mode used. Section &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; provides more details.</source>
          <target state="translated">Если коррекция времени включена, система выполнения Erlang использует как &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; , чтобы настроить частоту монотонных часов Erlang. Коррекция времени гарантирует, что &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; не искажается, а частота относительно точна. Тип настройки частоты зависит от используемого режима временной деформации. Раздел &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; содержит более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="86c57207a0af2011d419b53ca97897d73a612495" translate="yes" xml:space="preserve">
          <source>If time correction is not enabled, Erlang monotonic time freezes when OS system time leaps backwards. The freeze of monotonic time continues until OS system time catches up. The freeze can continue for a long time. When OS system time leaps forwards, Erlang monotonic time also leaps forward.</source>
          <target state="translated">Если временная коррекция не включена,монотонное время Эрланга замирает,когда системное время операционной системы прыгает назад.Замораживание монотонного времени продолжается до тех пор,пока системное время ОС не наверстает упущенное.Замораживание может продолжаться в течение длительного времени.Когда системное время ОС прыгает вперёд,монотонное время Эрланга также прыгает вперёд.</target>
        </trans-unit>
        <trans-unit id="ef091f899ba472aeda63ed1965cfed9d0bedc0a4" translate="yes" xml:space="preserve">
          <source>If trace mode is turned on this tells the ODBC driver to write a trace log to the file SQL.LOG that is placed in the current directory of the erlang emulator. This information may be useful if you suspect there might be a bug in the erlang ODBC application, and it might be relevant for you to send this file to our support. Otherwise you will probably not have much use of this.</source>
          <target state="translated">Если режим трассировки включен,то это говорит драйверу ODBC о записи журнала трассировки в файл SQL.LOG,который находится в текущей директории эмулятора erlang.Эта информация может быть полезной,если вы подозреваете,что в приложении ODBC erlang может быть ошибка,и для вас может быть уместно отправить этот файл в нашу поддержку.В противном случае вы,вероятно,не будете иметь особого смысла.</target>
        </trans-unit>
        <trans-unit id="06cb7989133609c0050ffc5dbb44bd39095de5a4" translate="yes" xml:space="preserve">
          <source>If tracing could be enabled for &lt;code&gt;P&lt;/code&gt; and all processes in &lt;code&gt;Rootset&lt;/code&gt;, the function returns &lt;code&gt;{ok,Value}&lt;/code&gt; when &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; returns with the value &lt;code&gt;Value&lt;/code&gt;, or &lt;code&gt;{error,Reason}&lt;/code&gt; if &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; fails with exit reason &lt;code&gt;Reason&lt;/code&gt;. Otherwise it returns &lt;code&gt;{error, Reason}&lt;/code&gt; immediately.</source>
          <target state="translated">Если трассировку можно было включить для &lt;code&gt;P&lt;/code&gt; и всех процессов в &lt;code&gt;Rootset&lt;/code&gt; , функция возвращает &lt;code&gt;{ok,Value}&lt;/code&gt; , когда &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; возвращает значение &lt;code&gt;Value&lt;/code&gt; , или &lt;code&gt;{error,Reason}&lt;/code&gt; , если &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; завершается неудачно с причиной выхода &lt;code&gt;Reason&lt;/code&gt; , В противном случае он немедленно возвращает &lt;code&gt;{error, Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="171abc361e25e3e1820951c40db50f386bc4e18d" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference.</source>
          <target state="translated">Если это так,используйте предпочтение сервера для выбора кривой ECC.Если опция ложна (по умолчанию),используйте предпочтения клиента.</target>
        </trans-unit>
        <trans-unit id="f6448c429179ffe9a0559b10e022f36f7d57c48b" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</source>
          <target state="translated">Если это так,используйте предпочтение сервера для выбора шифра.Если опция ложна (по умолчанию),используйте предпочтения клиента.</target>
        </trans-unit>
        <trans-unit id="93560debed8026dcf2a2983b09444126fc93994e" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Dates&lt;/code&gt; are specified, reports that occurred between those dates are returned.</source>
          <target state="translated">Если указаны две &lt;code&gt;Dates&lt;/code&gt; , возвращаются отчеты, которые произошли между этими датами.</target>
        </trans-unit>
        <trans-unit id="33b891be28a40228827989eecbc682bd1e8b9bf9" translate="yes" xml:space="preserve">
          <source>If two matching keys are declared, the latter key takes precedence.</source>
          <target state="translated">Если объявлены два совпадающих ключа,то последний имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="67258d8af06879035a6caf89796f47f253a79805" translate="yes" xml:space="preserve">
          <source>If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it.</source>
          <target state="translated">Если два процесса открывают одну и ту же таблицу,задавая одно и то же имя и аргументы,то в таблице есть два пользователя.Если один пользователь закрывает таблицу,она остается открытой до тех пор,пока второй не закроет ее.</target>
        </trans-unit>
        <trans-unit id="2c7260077a6430e57fb912e3299409f44a7a3f23" translate="yes" xml:space="preserve">
          <source>If two processes perform &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simultaneously, both updates take effect without the risk of losing one of the updates. The new value &lt;code&gt;NewVal&lt;/code&gt; of the counter is returned.</source>
          <target state="translated">Если два процесса выполняют &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; одновременно, оба обновления вступают в силу без риска потери одного из обновлений. &lt;code&gt;NewVal&lt;/code&gt; новое значение счетчика NewVal .</target>
        </trans-unit>
        <trans-unit id="b5c7e523459e9f766dca300b6ab1c5e2e9c17d90" translate="yes" xml:space="preserve">
          <source>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если используется на верхнем уровне в страже, он проверяет, является ли аргумент числом с плавающей запятой; для ясности используйте вместо этого &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1158bf11097606b6592798bf3682a97d2961056" translate="yes" xml:space="preserve">
          <source>If verification is turned on and the file was written with option &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt;, reading the file is slower and consumes radically more CPU time than otherwise.</source>
          <target state="translated">Если проверка включена и файл был записан с опцией &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt; , чтение файла происходит медленнее и потребляет значительно больше процессорного времени, чем в противном случае.</target>
        </trans-unit>
        <trans-unit id="79df61d77a356cef20daff35817557c31ea1feae" translate="yes" xml:space="preserve">
          <source>If warnings are turned on (option &lt;code&gt;report_warnings&lt;/code&gt; described earlier), the following options control what type of warnings that are generated.  Except from &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt;, the following options have two forms:</source>
          <target state="translated">Если предупреждения включены (опция &lt;code&gt;report_warnings&lt;/code&gt; , описанная ранее), следующие опции управляют типом генерируемых предупреждений. За исключением &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt; , следующие параметры имеют две формы:</target>
        </trans-unit>
        <trans-unit id="46f6514af342c03660ff3a127d8c0abce6e94d29" translate="yes" xml:space="preserve">
          <source>If we are connected (and if the connection handle is not &lt;code&gt;NULL&lt;/code&gt;), we log out from the database. We need to check if we should encode an &lt;code&gt;'ok'&lt;/code&gt;, as we can get here from function &lt;code&gt;stop&lt;/code&gt;, which does not return data to the emulator:</source>
          <target state="translated">Если мы подключены (и если дескриптор подключения не равен &lt;code&gt;NULL&lt;/code&gt; ), мы выходим из базы данных. Нам нужно проверить, должны ли мы кодировать &lt;code&gt;'ok'&lt;/code&gt; , поскольку мы можем попасть сюда из &lt;code&gt;stop&lt;/code&gt; функции , которая не возвращает данные в эмулятор:</target>
        </trans-unit>
        <trans-unit id="3e3531248524d3e767663c5b51a2a6884e4678a8" translate="yes" xml:space="preserve">
          <source>If we are not at security-level &lt;code&gt;noAuthNoPriv&lt;/code&gt;, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</source>
          <target state="translated">Если мы находимся не на уровне безопасности &lt;code&gt;noAuthNoPriv&lt;/code&gt; , это может быть сложно, поскольку затем агент перейдет к этапу 2, перед которым должны быть выполнены обновления, связанные с usm.</target>
        </trans-unit>
        <trans-unit id="5d4840bdbaaa7e01cbfc9ee43e1a031173374de2" translate="yes" xml:space="preserve">
          <source>If we are not connecting, we wait for results from a &lt;code&gt;PQsendQuery&lt;/code&gt;, so we get the result and return it. The encoding is done with the same functions as in the earlier example.</source>
          <target state="translated">Если мы не подключаемся, мы ждем результатов от &lt;code&gt;PQsendQuery&lt;/code&gt; , поэтому мы получаем результат и возвращаем его. Кодирование выполняется с помощью тех же функций, что и в предыдущем примере.</target>
        </trans-unit>
        <trans-unit id="337a2fc4e3a2d30ff212f197ed2e62e6a68516c6" translate="yes" xml:space="preserve">
          <source>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as &quot;safe&quot;, and all calls between them will become local. Note that if the target module itself is specified as safe, &quot;remote&quot; calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop.</source>
          <target state="translated">Если мы уверены,что такая ситуация не может возникнуть,мы можем указать задействованные модули как &quot;безопасные&quot;,и все вызовы между ними станут локальными.Обратите внимание,что если сам целевой модуль будет указан как &quot;безопасный&quot;,то &quot;удаленные&quot; вызовы к себе превратятся в локальные.Это уничтожит свойства замены кода,например,типичный цикл сервера.</target>
        </trans-unit>
        <trans-unit id="7b66416ada226ef11ca8c9b5f2f89c92815edf3c" translate="yes" xml:space="preserve">
          <source>If we disregard the contended cases, we will inevitably get a higher latency when scheduling signals for execution at a later time than by executing the signal immediately. In order to preserve the low latency we now first check if this is a contended case or not. If it is, we schedule the signal for later execution; otherwise, we execute the signal immediately. It is a contended case if other signals already are scheduled on the port, or if we fail to acquire the port lock. That is we will not block waiting for the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97b9f19e72ab9cc61b4cedbac5bd537174daa35" translate="yes" xml:space="preserve">
          <source>If we disregard the locking issues, the original solution is very appealing. The mapping from process identifier to index into the array is very fast, and this property is something we would like to keep. The vast majority of operations on these tables are lookups so optimizing for lookups is what we want to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9c359ef122e371e6ca40c1302512863ec587e1" translate="yes" xml:space="preserve">
          <source>If we have a result from a connect, indicated by having data in the &lt;code&gt;x&lt;/code&gt; buffer, we no longer need to select on output (&lt;code&gt;ready_output&lt;/code&gt;), so we remove this by calling &lt;code&gt;driver_select&lt;/code&gt;.</source>
          <target state="translated">Если у нас есть результат соединения, на который указывает наличие данных в буфере &lt;code&gt;x&lt;/code&gt; , нам больше не нужно выбирать на выходе ( &lt;code&gt;ready_output&lt;/code&gt; ), поэтому мы удаляем его, вызывая &lt;code&gt;driver_select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b39cddb5344c13a7bcee4c7a5972425c4aa9fc95" translate="yes" xml:space="preserve">
          <source>If we have forgotten the &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; there would be a message similar to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce67181f9dec94f63a49d2d4f68889369954004" translate="yes" xml:space="preserve">
          <source>If we now add the filter to the running &lt;code&gt;Collector&lt;/code&gt;:</source>
          <target state="translated">Если мы теперь добавим фильтр к работающему &lt;code&gt;Collector&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f3ffad68dd3aaa3ee27c0008bb99580f0a57f8f2" translate="yes" xml:space="preserve">
          <source>If we now send a message from the shell on the node &lt;code&gt;ant@stack&lt;/code&gt;, where all sends from the shell are traced:</source>
          <target state="translated">Если теперь мы отправим сообщение из оболочки в узел &lt;code&gt;ant@stack&lt;/code&gt; , где отслеживаются все отправления из оболочки:</target>
        </trans-unit>
        <trans-unit id="43717b37beb4229f520c407e6567fb6706951645" translate="yes" xml:space="preserve">
          <source>If we only want debug messages from a specific process it is possible to do this with a filter like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc29b0b458c2d8c07af3ed4af13280313ed829" translate="yes" xml:space="preserve">
          <source>If we only want to match operands of a certain type, we can use a type constraint. A type constraint consists of one or more lowercase letters, each specifying a type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0ecc6f7afe07e419db3c1ee4dc39311f3c9091" translate="yes" xml:space="preserve">
          <source>If we remove the &lt;code&gt;-no_next&lt;/code&gt; directive, the code would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71461022e8b1964785f01d0fea411534999fdbfe" translate="yes" xml:space="preserve">
          <source>If we run it like this: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; The result will be &lt;code&gt;result_xs.html&lt;/code&gt;. When the input file is of the same structure as the previous &quot;motorcycles&quot; XML files but it has a little more 'bike' elements and the 'manufacturer' elements are not in order.</source>
          <target state="translated">Если мы запустим его так: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; Результатом будет &lt;code&gt;result_xs.html&lt;/code&gt; . Когда входной файл имеет ту же структуру, что и предыдущие XML-файлы &amp;laquo;мотоциклов&amp;raquo;, но в нем немного больше элементов &amp;laquo;велосипед&amp;raquo;, а элементы &amp;laquo;производитель&amp;raquo; не в порядке.</target>
        </trans-unit>
        <trans-unit id="245971475847fb8e843dded9b9424bc7fe234a7a" translate="yes" xml:space="preserve">
          <source>If we would have had a huge amount of unique identifiers available, it would have tempting to drop or modify this ordering property as described above. The ordering property could for example be based on the scheduler performing the spawn operation. It would have been possible to reserve large ranges of identifiers exclusive for each scheduler thread which could be used minimizing the need for communication when allocating identifiers. The amount of identifiers we got to work with today is, however, not even close to be enough for such an approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8886cb75b357ed32d80a6eee9f949abb29be57" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; x, then x = y (&lt;code&gt;F&lt;/code&gt; is antisymmetric).</source>
          <target state="translated">Если x &lt;code&gt;F&lt;/code&gt; y и y &lt;code&gt;F&lt;/code&gt; x, то x = y ( &lt;code&gt;F&lt;/code&gt; антисимметричен).</target>
        </trans-unit>
        <trans-unit id="6b92816031334184272820ee86857aab64402f87" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; z, then x &lt;code&gt;F&lt;/code&gt; z (&lt;code&gt;F&lt;/code&gt; is transitive).</source>
          <target state="translated">Если x &lt;code&gt;F&lt;/code&gt; y и y &lt;code&gt;F&lt;/code&gt; z, то x &lt;code&gt;F&lt;/code&gt; z ( &lt;code&gt;F&lt;/code&gt; транзитивен).</target>
        </trans-unit>
        <trans-unit id="efd0edc2f934fb0989fdc0ef3a93bc0dc5861448" translate="yes" xml:space="preserve">
          <source>If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family.</source>
          <target state="translated">Если x-семейство от I до X,то x[i]обозначает значение функции в индексе i.Для такого семейства используется обозначение &quot;семейство в X&quot;.</target>
        </trans-unit>
        <trans-unit id="0460fccf75563cd103af603f5ff0df7bee5d29db" translate="yes" xml:space="preserve">
          <source>If x is a family of subsets of X, the union of the range of x is called the &lt;strong&gt;union of the family&lt;/strong&gt; x.</source>
          <target state="translated">Если x является семейством подмножеств X, объединение диапазона x называется &lt;strong&gt;объединением семейства&lt;/strong&gt; x.</target>
        </trans-unit>
        <trans-unit id="7f8b7662a485e830efd5dc24b42b4f66a23c755f" translate="yes" xml:space="preserve">
          <source>If x is non-empty (the index set is non-empty), the &lt;strong&gt;intersection of the family&lt;/strong&gt; x is the intersection of the range of x.</source>
          <target state="translated">Если x непусто (набор индексов не пуст), &lt;strong&gt;пересечение семейства&lt;/strong&gt; x является пересечением диапазона x.</target>
        </trans-unit>
        <trans-unit id="a742ef9245b7658b6ec0801964c4c0ea9a5eb508" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;must&lt;/strong&gt; return all data stored in the Ets table, you can use &lt;code&gt;ets:tab2list/1&lt;/code&gt;. However, usually you are only interested in a subset of the information in which case &lt;code&gt;ets:tab2list/1&lt;/code&gt; is expensive. If you only want to extract one field from each record, for example, the age of every person, then:</source>
          <target state="translated">Если вы &lt;strong&gt;должны&lt;/strong&gt; вернуть все данные, хранящиеся в таблице Ets, вы можете использовать &lt;code&gt;ets:tab2list/1&lt;/code&gt; . Однако обычно вас интересует только подмножество информации, и в этом случае &lt;code&gt;ets:tab2list/1&lt;/code&gt; стоит дорого. Если вы хотите извлечь только одно поле из каждой записи, например, возраст каждого человека, тогда:</target>
        </trans-unit>
        <trans-unit id="6695ce447118dd0e7ea4d4f74aa540c19c250112" translate="yes" xml:space="preserve">
          <source>If you are building Erlang/OTP from git you will need to run &lt;code&gt;./otp_build autoconf&lt;/code&gt; to generate the configure scripts.</source>
          <target state="translated">Если вы собираете Erlang / OTP из git, вам нужно будет запустить &lt;code&gt;./otp_build autoconf&lt;/code&gt; для генерации скриптов конфигурации.</target>
        </trans-unit>
        <trans-unit id="da52602929c7fc0635b8326b6c38bbbd66979f5f" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version of Erlang, you should set up PATHs etc a little differently. We have two templates to make things work in both Cygwin and MSYS but needs editing to work with MSYS2 (see the comments in the script). The following one is for 32 bits:</source>
          <target state="translated">Если вы собираете 64-битную версию Erlang,то вам следует настроить PATH и т.д.немного по-другому.У нас есть два шаблона,чтобы все работало как в Cygwin,так и в MSYS,но для работы с MSYS2 нужно их отредактировать (см.комментарии в скрипте).Следующий шаблон рассчитан на 32 бита:</target>
        </trans-unit>
        <trans-unit id="28fd7cee740e8f1e008d545c9af326623f6f2da9" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version, you supply &lt;code&gt;otp_build&lt;/code&gt; with an architecture parameter:</source>
          <target state="translated">Если вы создаете 64-битную версию, вы предоставляете &lt;code&gt;otp_build&lt;/code&gt; с параметром архитектуры:</target>
        </trans-unit>
        <trans-unit id="11d01d76312a6e1beca90d30f576e8ba920e3045" translate="yes" xml:space="preserve">
          <source>If you are building in &lt;code&gt;git&lt;/code&gt; you first need to generate the &lt;code&gt;configure&lt;/code&gt; scripts:</source>
          <target state="translated">Если вы строите в &lt;code&gt;git&lt;/code&gt; , вам сначала нужно сгенерировать скрипты &lt;code&gt;configure&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08ca29e8fc627bd8865e44b098a309f0c218de8e" translate="yes" xml:space="preserve">
          <source>If you are building in Git, you want to read the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section of &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">Если вы строите в Git, перед продолжением вы хотите прочитать раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; &amp;raquo; в &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="059356cb46cb61018f3078a8c089ba933432567b" translate="yes" xml:space="preserve">
          <source>If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:</source>
          <target state="translated">Если вы распространяете исходный код вашего приложения для компиляции и запуска другим людям,вы,вероятно,хотите убедиться,что код компилируется,даже если EUnit недоступен.Как и в предыдущем разделе,вы можете поместить следующие строки в общий заголовочный файл:</target>
        </trans-unit>
        <trans-unit id="3f548e035d4acfc541b42547c9972c54765ffd2c" translate="yes" xml:space="preserve">
          <source>If you are executing in a mode where time offset can change, and you want to get the actual Erlang system time when the event occurred, you can save the time offset as a third element in the tuple (the least significant element when comparing three-tuples).</source>
          <target state="translated">Если вы выполняетесь в режиме,в котором смещение времени может измениться,и хотите получить фактическое системное время Erlang при возникновении события,вы можете сохранить смещение времени в качестве третьего элемента кортежа (наименее значимого элемента при сравнении трех пар).</target>
        </trans-unit>
        <trans-unit id="65eab1decf1d5f02b76e57b9a0f013425229d73c" translate="yes" xml:space="preserve">
          <source>If you are going to build a 64bit Windows version, you should make sure to get MinGW's 64bit gcc installed with Cygwin. It's in one of the development packages.</source>
          <target state="translated">Если вы собираетесь собирать 64-битную версию Windows,убедитесь,что 64-битный gcc MinGW установлен с Cygwin.Это в одном из пакетов разработки.</target>
        </trans-unit>
        <trans-unit id="e873962d506d0453e258cd67b870cfcf9fdf56aa" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcce25aa490a7895d515f9ea238920455b90682" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">Если вас интересует системное время Erlang в то время, когда произошло событие, вы также можете сохранить смещение времени до или после сохранения событий, используя &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; . Монотонное время Эрланга, добавленное со смещением времени, соответствует системному времени Эрланга.</target>
        </trans-unit>
        <trans-unit id="2501e29b8883667aa63c6065f64ad533173ff055" translate="yes" xml:space="preserve">
          <source>If you are new to &lt;code&gt;gen_statem&lt;/code&gt; and want an overview of concepts and operation the section &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; located in the User's Guide &lt;code&gt; OTP Design Principles &lt;/code&gt; is recommended to read before this reference manual, possibly after the Description section you are reading here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec4906363d7f3a0f656197645460eb641bfd86b" translate="yes" xml:space="preserve">
          <source>If you are not familiar with Cygwin, MSYS, MSYS2 or a Unix environment, you&amp;rsquo;ll probably need to read up a bit on how that works. There are plenty of documentation about this online.</source>
          <target state="translated">Если вы не знакомы с Cygwin, MSYS, MSYS2 или средой Unix, вам, вероятно, потребуется немного прочитать, как это работает. В Интернете есть множество документации по этому поводу.</target>
        </trans-unit>
        <trans-unit id="79e81e9c6f10164072a2c4df28a3214be53b197f" translate="yes" xml:space="preserve">
          <source>If you are not sure that OS system time is correct, set it to a time that is guaranteed to be earlier than actual POSIX time before starting the Erlang runtime system, just to be safe.</source>
          <target state="translated">Если вы не уверены в правильности системного времени операционной системы,установите его на время,которое гарантированно будет раньше фактического времени POSIX перед запуском системы Erlang,просто для безопасности.</target>
        </trans-unit>
        <trans-unit id="139e4db82ce537b7ca402bb5648cb80768493b2d" translate="yes" xml:space="preserve">
          <source>If you are only interested in the age of all persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">Если вас интересует только возраст всех лиц по имени &quot;Брайан&quot;,то..:</target>
        </trans-unit>
        <trans-unit id="a4b3fb25184745a8c5de1f41ef693f7c3d65a1fb" translate="yes" xml:space="preserve">
          <source>If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</source>
          <target state="translated">Если вы работаете на платформе,поддерживающей HiPE,и не отключили HiPE,вы можете скомпилировать модуль в нативный код из оболочки Erlang:</target>
        </trans-unit>
        <trans-unit id="12bada1e7a2afb8d739c0b1c4888bc6d1de99967" translate="yes" xml:space="preserve">
          <source>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one &lt;code&gt;Common Test&lt;/code&gt; is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вы тестируете распределенное приложение Erlang, вполне вероятно, что код, который вы хотите включить в анализ покрытия кода, будет выполняться на другом узле Erlang, чем тот, на котором выполняется &lt;code&gt;Common Test&lt;/code&gt; . Если это так, вы должны указать эти другие узлы в файле спецификации обложки или добавить их динамически в набор узлов покрытия кода. Подробнее о последнем см. В модуле &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c864b6e67ea1285ed3a001c19cfbf05fe7b8b75d" translate="yes" xml:space="preserve">
          <source>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</source>
          <target state="translated">Если вы не уверены,правильно ли вы освободили термины,вы можете воспользоваться следующей функцией,чтобы увидеть статус аллокатора фиксированных сроков:</target>
        </trans-unit>
        <trans-unit id="785964c082f500e973ee23af1227a47d2e13719e" translate="yes" xml:space="preserve">
          <source>If you can edit and recompile the source code, it is convenient to insert &lt;code&gt;fprof:trace(start)&lt;/code&gt; and &lt;code&gt;fprof:trace(stop)&lt;/code&gt; before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt;.</source>
          <target state="translated">Если вы можете редактировать и перекомпилировать исходный код, удобно вставлять &lt;code&gt;fprof:trace(start)&lt;/code&gt; и &lt;code&gt;fprof:trace(stop)&lt;/code&gt; до и после кода, который нужно профилировать. Также отслеживаются все порожденные процессы. Если вам нужно другое имя файла, а не имя по умолчанию, попробуйте &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5adefb435e12cfcf7b44d388cd53353f9f445a0" translate="yes" xml:space="preserve">
          <source>If you combine catching exceptions from this function with &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt; for example in the event of network problems. So why not just let the calling process die by not catching the exception?</source>
          <target state="translated">Если вы объедините &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; исключений из этой функции с {dirty_timeout, T}, чтобы избежать остановки вызывающего процесса по истечении времени ожидания вызова, вы должны быть готовы обработать поздний ответ. Обратите внимание, что есть странная вероятность получить поздний ответ даже с &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; или &lt;code&gt;infinity&lt;/code&gt; например, в случае сетевых проблем. Так почему бы просто не позволить вызывающему процессу умереть, не перехватив исключение?</target>
        </trans-unit>
        <trans-unit id="926494dd9305a4cb191069b2570f8e16c82b75b1" translate="yes" xml:space="preserve">
          <source>If you compare with the code you will see there also that &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; was called only from &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; and itself, and called only &lt;code&gt;file:write/2&lt;/code&gt;, note the number of calls to &lt;code&gt;file:write/2&lt;/code&gt;. But here we see that &lt;code&gt;suspend&lt;/code&gt; was called a few times. This is a pseudo function that indicates that the process was suspended while executing in &lt;code&gt;foo:create_file_slow/3&lt;/code&gt;, and since there is no &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;erlang:yield/0&lt;/code&gt; in the code, it must be Erlang scheduling suspensions, or the trace file driver compensating for large file write operations (these are regarded as a schedule out followed by a schedule in to the same process).</source>
          <target state="translated">Если вы сравните с кодом, вы также увидите, что &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; был вызван только из &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; и самого себя и вызвал только &lt;code&gt;file:write/2&lt;/code&gt; , обратите внимание на количество обращений к &lt;code&gt;file:write/2&lt;/code&gt; . Но здесь мы видим, что &lt;code&gt;suspend&lt;/code&gt; несколько раз. Это &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; которая указывает, что процесс был приостановлен при выполнении в foo: create_file_slow / 3 , и, поскольку в коде нет &lt;code&gt;receive&lt;/code&gt; или &lt;code&gt;erlang:yield/0&lt;/code&gt; , это должно быть приостановка планирования Erlang или драйвер файла трассировки, компенсирующий для операций записи больших файлов (они рассматриваются как выход по расписанию, за которым следует расписание для того же процесса).</target>
        </trans-unit>
        <trans-unit id="4da979d104276d1b284d0d0ed5628a6c4ba8264c" translate="yes" xml:space="preserve">
          <source>If you compile with the following, the result is one merged module &lt;code&gt;MyModule.erl&lt;/code&gt; with the generated code from the three ASN.1 specs:</source>
          <target state="translated">Если вы компилируете со следующим, результатом будет один объединенный модуль &lt;code&gt;MyModule.erl&lt;/code&gt; со сгенерированным кодом из трех спецификаций ASN.1:</target>
        </trans-unit>
        <trans-unit id="229f423b538bb335420959949ffa6439771ff69b" translate="yes" xml:space="preserve">
          <source>If you compose your own &lt;code&gt;cipher_suites()&lt;/code&gt; make sure they are filtered for cryptolib support &lt;code&gt;&lt;a href=&quot;#filter_cipher_suites-2&quot;&gt; ssl:filter_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; Additionaly the functions &lt;code&gt;&lt;a href=&quot;#append_cipher_suites-2&quot;&gt; ssl:append_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#prepend_cipher_suites-2&quot;&gt; ssl:prepend_cipher_suites/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#suite_to_str-1&quot;&gt;ssl:suite_to_str/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#str_to_suite-1&quot;&gt;ssl:str_to_suite/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#suite_to_openssl_str-1&quot;&gt;ssl:suite_to_openssl_str/1&lt;/a&gt;&lt;/code&gt; also exist to help creating customized cipher suite lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2523acc9d9b699bb6e45fe3319252f79d5b73690" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip, Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34553151842c57d51c700a2176df03643a8e288f" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip,Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">Если вы все же решите не запускать тестовый пример, верните &lt;code&gt;{skip,Reason}&lt;/code&gt; . &lt;code&gt;Reason&lt;/code&gt; затем печатается в поле &lt;code&gt;Comment&lt;/code&gt; на странице результатов HTML.</target>
        </trans-unit>
        <trans-unit id="cc41ca02f8abc69bcba03c2039a4711eec766fcf" translate="yes" xml:space="preserve">
          <source>If you desire to also use some other general cover configuration together with this option you should insert the AppName in between the option and its value creating a three tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b5510ec0b67d605ceab6963978d04cd1ab40d6" translate="yes" xml:space="preserve">
          <source>If you develop linked-in drivers (shared library) you need to link using &lt;code&gt;gcc&lt;/code&gt; and the flags &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt;. You also include &lt;code&gt;-fno-common&lt;/code&gt; in &lt;code&gt;CFLAGS&lt;/code&gt; when compiling. Use &lt;code&gt;.so&lt;/code&gt; as the library suffix.</source>
          <target state="translated">Если вы разрабатываете связанные драйверы (общая библиотека), вам необходимо связать с помощью &lt;code&gt;gcc&lt;/code&gt; и флага &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt; . Вы также включаете &lt;code&gt;-fno-common&lt;/code&gt; в &lt;code&gt;CFLAGS&lt;/code&gt; при компиляции. Используйте &lt;code&gt;.so&lt;/code&gt; в качестве суффикса библиотеки.</target>
        </trans-unit>
        <trans-unit id="9af22866bc3303d3e5e15bb7da268298a32e5b69" translate="yes" xml:space="preserve">
          <source>If you do not have a complete binary of the file content, you can instead chunk through the file and check part by part. The return-tuple &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; from function &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; comes in handy. The incomplete rest from one chunk of data read from the file is prepended to the next chunk and we therefore avoid the problem of character boundaries when reading chunks of bytes in UTF-8 encoding:</source>
          <target state="translated">Если у вас нет полного двоичного файла содержимого файла, вы можете вместо этого выполнить фрагментный анализ файла и проверить его по частям. Пригодится возвращаемый кортеж &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; из функции &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; . Неполный остаток от одного фрагмента данных, считанных из файла, добавляется к следующему фрагменту, и поэтому мы избегаем проблемы границ символов при чтении фрагментов байтов в кодировке UTF-8:</target>
        </trans-unit>
        <trans-unit id="d69c0d8ff5a49420e5ccb90500698b1a5b852393" translate="yes" xml:space="preserve">
          <source>If you do not need the statistical quality of this function, there are faster algorithms in the &lt;code&gt;rand&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8d18a133f467591527f3dafe062626f3a3e3a8" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt; enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fdd3948b5b8d018a253264434e3fdb3b1f2c9e" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">Если вам не нужно перераспределять или поддерживать данные в &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; состоянии между вызовами NIF, рассмотрите возможность использования вместо этого enif_make_new_binary, поскольку он будет размещать небольшие двоичные файлы в куче процесса, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="0d84e01d642f906e2813071c9f195dfd3ff33506" translate="yes" xml:space="preserve">
          <source>If you do ordinary &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;receive&lt;/code&gt; trace on the system, you will only see ordinary message passing, not the other information transfers listed above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226c0c04d7fd8e63c97c31f497edc30ae0498fc" translate="yes" xml:space="preserve">
          <source>If you don't use X-windows, you might want to setup the Windows console window by selecting properties in the console system menu (upper left corner of the window, the Cygwin icon in the title bar). Especially setting a larger screen buffer size (lines) is useful as it gets you a scrollbar so you can see whatever error messages that might appear.</source>
          <target state="translated">Если вы не используете X-окна,вы можете настроить консольное окно Windows,выбрав свойства в системном меню консоли (верхний левый угол окна,значок Cygwin в строке заголовка).Особенно полезно установить больший размер буфера экрана (строк),так как это даст вам панель прокрутки,чтобы вы могли видеть любые сообщения об ошибках,которые могут появиться.</target>
        </trans-unit>
        <trans-unit id="c1c77e78076b1c45254b83e1685877227a58e370" translate="yes" xml:space="preserve">
          <source>If you explicitly want to set the program name in the argument vector, option &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">Если вы явно хотите установить имя программы в векторе аргументов, можно использовать параметр &lt;code&gt;arg0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f75fbec32c4686a4e8aec99dc351f8983616950b" translate="yes" xml:space="preserve">
          <source>If you fail to clear thread-specific data in an emulator thread before letting it out of your control, you might never be able to clear this data with later unexpected errors in other parts of the system as a result.</source>
          <target state="translated">Если вы не очистите данные в потоке эмулятора,прежде чем выпустить их из-под вашего контроля,вы,возможно,никогда не сможете очистить эти данные с последующими неожиданными ошибками в других частях системы.</target>
        </trans-unit>
        <trans-unit id="09268e829b124cfcf4bd5de6e9875906ac8513d6" translate="yes" xml:space="preserve">
          <source>If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions to our &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; and patches to our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; directories mostly. The &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; directory is for common code.</source>
          <target state="translated">Если вы чувствуете себя комфортно с окружающей средой и системой сборки и имеете все необходимые инструменты, у вас есть прекрасная возможность улучшить дистрибутив Erlang / OTP для Windows. Пожалуйста, отправляйте любые предложения в нашу &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; и исправления для нашего &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; чтобы они нашли свой путь в следующую версию Erlang. При внесении изменений в систему сборки (например, в файлы сборки и т. Д.) Имейте в виду, что те же файлы сборки используются в Unix / VxWorks, чтобы ваши изменения не нарушили работу других платформ. Это, конечно, относится и к C-коду; системный код в основном находится в &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; и &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; . &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; каталог для общего кода.</target>
        </trans-unit>
        <trans-unit id="c1e46734643c479e7f6063eb73e949cb06d69d85" translate="yes" xml:space="preserve">
          <source>If you find that some common Logger usage is missing from this guide, please open a pull request on github with the suggested addition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7e44c265926484064ef3996081db76eb5b3893" translate="yes" xml:space="preserve">
          <source>If you frequently do a lookup on a field that is not the key of the table, you lose performance using &quot;mnesia:select/match_object&quot; as this function traverses the whole table. You can create a secondary index instead and use &quot;mnesia:index_read&quot; to get faster access, however this requires more memory.</source>
          <target state="translated">Если вы часто делаете поиск по полю,которое не является ключом таблицы,то вы теряете производительность,используя &quot;mnesia:select/match_object&quot;,так как эта функция проходит через всю таблицу.Вместо этого можно создать вторичный индекс и использовать &quot;mnesia:index_read&quot;,чтобы получить более быстрый доступ,однако это требует больше памяти.</target>
        </trans-unit>
        <trans-unit id="d250cbc8ce8f103748e70e8012ae4812e69e6b6e" translate="yes" xml:space="preserve">
          <source>If you got a public key &lt;code&gt;PubKey&lt;/code&gt; and a related list of attributes &lt;code&gt;Attributes&lt;/code&gt; as returned by &lt;code&gt;ssh_decode/2&lt;/code&gt;, you can create a new SSH file, for example:</source>
          <target state="translated">Если у вас есть открытый ключ &lt;code&gt;PubKey&lt;/code&gt; и связанный список атрибутов &lt;code&gt;Attributes&lt;/code&gt; , возвращенный &lt;code&gt;ssh_decode/2&lt;/code&gt; , вы можете создать новый файл SSH, например:</target>
        </trans-unit>
        <trans-unit id="d64558ffe085d81fb4c2a7370d51643970e9b47a" translate="yes" xml:space="preserve">
          <source>If you hack the emulator, you can build the emulator executable by standing in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and do a simple</source>
          <target state="translated">Если вы взломаете эмулятор, вы можете создать исполняемый файл эмулятора, встав в &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; и выполнив простой</target>
        </trans-unit>
        <trans-unit id="57dee92dc02000c0c82e5fb9e2da62997a25dbd7" translate="yes" xml:space="preserve">
          <source>If you have Xcode 4.3, or later, you will also need to download &quot;Command Line Tools&quot; via the Downloads preference pane in Xcode.</source>
          <target state="translated">Если у вас есть Xcode 4.3,или более поздняя версия,вам также нужно загрузить &quot;Инструменты командной строки&quot; через панель параметров Downloads в Xcode.</target>
        </trans-unit>
        <trans-unit id="709a85ba273f4493deb19337d8dab86c17b51b44" translate="yes" xml:space="preserve">
          <source>If you have a list of lists &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt;, then you can sum the lengths of all the strings in &lt;code&gt;L&lt;/code&gt; as follows:</source>
          <target state="translated">Если у вас есть список списков &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt; , то вы можете просуммировать длины всех строк в &lt;code&gt;L&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="06562602ec1a77035c75bd6f06f61c39f1543c77" translate="yes" xml:space="preserve">
          <source>If you have added the declaration &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; to your module, as described above, you only need to compile the module, and run the automatically exported function &lt;code&gt;test()&lt;/code&gt;. For example, if your module was named &lt;code&gt;m&lt;/code&gt;, then calling &lt;code&gt;m:test()&lt;/code&gt; will run EUnit on all the tests defined in the module. You do not need to write &lt;code&gt;-export&lt;/code&gt; declarations for the test functions. This is all done by magic.</source>
          <target state="translated">Если вы добавили объявление &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; в свой модуль, как описано выше, вам нужно только скомпилировать модуль и запустить автоматически экспортируемую функцию &lt;code&gt;test()&lt;/code&gt; . Например, если ваш модуль назван &lt;code&gt;m&lt;/code&gt; , то вызов &lt;code&gt;m:test()&lt;/code&gt; запустит EUnit для всех тестов, определенных в модуле. Вам не нужно писать объявления &lt;code&gt;-export&lt;/code&gt; для тестовых функций. Все это делается по волшебству.</target>
        </trans-unit>
        <trans-unit id="144f513a5aa39876b81ef2c80a71c2be4b26f4ef" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;install&lt;/code&gt; target, install the documentation using the &lt;code&gt;install-docs&lt;/code&gt; target. Install locations determined by &lt;code&gt;configure&lt;/code&gt; will be used. &lt;code&gt;$DESTDIR&lt;/code&gt; can be used the same way as when doing &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">Если вы установили Erlang / OTP с использованием &lt;code&gt;install&lt;/code&gt; цели, установить документацию с помощью &lt;code&gt;install-docs&lt;/code&gt; цели. Будут использоваться места установки, определенные &lt;code&gt;configure&lt;/code&gt; . &lt;code&gt;$DESTDIR&lt;/code&gt; можно использовать так же, как и при выполнении &lt;code&gt;make install&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15d88801e622a2cdd2d2c7fe2a4a670f216ed9a" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;release&lt;/code&gt; target, install the documentation using the &lt;code&gt;release_docs&lt;/code&gt; target. You typically want to use the same &lt;code&gt;RELEASE_ROOT&lt;/code&gt; as when invoking &lt;code&gt;make release&lt;/code&gt;.</source>
          <target state="translated">Если вы установили Erlang / OTP, используя цель &lt;code&gt;release&lt;/code&gt; , установите документацию, используя цель &lt;code&gt;release_docs&lt;/code&gt; . Обычно вы хотите использовать тот же &lt;code&gt;RELEASE_ROOT&lt;/code&gt; , что и при вызове &lt;code&gt;make release&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56c20a2d676e8cfb31affcccb02e9255a03aa95c" translate="yes" xml:space="preserve">
          <source>If you have installed documentation in the OTP installation, also build the documentation:</source>
          <target state="translated">Если в установке OTP установлена документация,также создайте документацию:</target>
        </trans-unit>
        <trans-unit id="e2d1684e846a6a2121920a90b95e7857c8b4feb5" translate="yes" xml:space="preserve">
          <source>If you have just built Erlang/OTP in the current source tree, you have already ran &lt;code&gt;configure&lt;/code&gt; and do not need to do this again; otherwise, run &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">Если вы только что построили Erlang / OTP в текущем дереве исходных текстов, значит, вы уже запустили &lt;code&gt;configure&lt;/code&gt; и вам не нужно делать это снова; в противном случае запустите &lt;code&gt;configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="636ce5c9d1bb03f9748b5bbe5ec2f545e4d839b3" translate="yes" xml:space="preserve">
          <source>If you have many servers in one node and they have some state(s) in their lifetime in which the servers can be expected to idle for a while, and the amount of heap memory all these servers need is a problem, then the memory footprint of a server can be mimimized by hibernating it through &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">Если у вас много серверов в одном узле, и у них есть какое-то состояние (я) в течение своего жизненного цикла, в котором можно ожидать, что серверы будут простаивать какое-то время, и объем памяти кучи, необходимый всем этим серверам, является проблемой, тогда объем памяти сервера можно имитировать, переведя его в спящий режим с помощью &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cf69c3d3514b68c365fa229d8d36e057061c7ae" translate="yes" xml:space="preserve">
          <source>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; and related for the tracing step.</source>
          <target state="translated">Если у вас есть одна функция, которая выполняет задачу, которую вы хотите профилировать, и функция возвращается, когда профилирование должно быть остановлено, удобно использовать &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; и связанный с этапом трассировки.</target>
        </trans-unit>
        <trans-unit id="4add882c433457afa2edf542bb650cc29a895ccb" translate="yes" xml:space="preserve">
          <source>If you have public-key data and want to create a PEM file this can be done by calling functions &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; and &lt;code&gt;pem_encode/1&lt;/code&gt; and saving the result to a file. For example, assume that you have &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt;. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file (ASN.1 type &lt;code&gt;'RSAPublicKey'&lt;/code&gt;) or a PEM-&quot;PUBLIC KEY&quot; file (&lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 type).</source>
          <target state="translated">Если у вас есть данные с открытым ключом и вы хотите создать файл PEM, это можно сделать, вызвав функции &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; и &lt;code&gt;pem_encode/1&lt;/code&gt; и сохранив результат в файл. Например, предположим, что у вас &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt; . Затем вы можете создать файл &lt;code&gt;'RSAPublicKey'&lt;/code&gt; &amp;laquo;RSA PUBLIC KEY&amp;raquo; (тип ASN.1 &amp;laquo;RSAPublicKey&amp;raquo; ) или файл &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; &amp;laquo;PUBLIC KEY&amp;raquo; ( тип ASN.1 &amp;laquo;SubjectPublicKeyInfo&amp;raquo; ).</target>
        </trans-unit>
        <trans-unit id="bff364d7b744c7c80f16da3e2585cd7454157cd3" translate="yes" xml:space="preserve">
          <source>If you have system configuration data that is neither file-location-dependent nor site-dependent, it can be convenient to create &lt;code&gt;sys.config&lt;/code&gt; early, so it becomes part of the target system tar file created by &lt;code&gt;target_system:create/1&lt;/code&gt;. In fact, if you in the current directory create not only the file &lt;code&gt;mysystem.rel&lt;/code&gt;, but also file &lt;code&gt;sys.config&lt;/code&gt;, the latter file is tacitly put in the appropriate directory.</source>
          <target state="translated">Если у вас есть данные конфигурации системы, которые не зависят ни от расположения файла, ни от сайта, может быть удобно &lt;code&gt;sys.config&lt;/code&gt; создать sys.config , чтобы он стал частью tar-файла целевой системы, созданного с помощью &lt;code&gt;target_system:create/1&lt;/code&gt; . Фактически, если вы в текущем каталоге создаете не только файл &lt;code&gt;mysystem.rel&lt;/code&gt; , но и файл &lt;code&gt;sys.config&lt;/code&gt; , последний файл будет автоматически помещен в соответствующий каталог.</target>
        </trans-unit>
        <trans-unit id="dd12871aeecfcf251ad76c0f1867361b2f02e152" translate="yes" xml:space="preserve">
          <source>If you have your cross compilation configuration in a file, pass it using the &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; command line argument. If not, pass &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt;, and the configuration variables using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax on the command line (same as in (3)). Note that &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; have to be passed one way or the other; either by using &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; in the configuration file, or by using the &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, and &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; command line arguments.</source>
          <target state="translated">Если у вас есть конфигурация кросс-компиляции в файле, передайте ее с помощью аргумента командной строки &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; . Если нет, передайте &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; , &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; и переменные конфигурации, используя синтаксис &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; в командной строке (как в (3)). Обратите внимание, что &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; должны быть переданы тем или иным способом; либо используя &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; и &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; в файле конфигурации, либо используя аргументы командной строки &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; и &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="496f196f55a6fe378376abb5b448050f783c1628" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another &lt;strong&gt;state callback&lt;/strong&gt; of yours, you have not done a &lt;strong&gt;state change&lt;/strong&gt; and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a130450837fa7de4006e06dfdf6e7651f3519c93" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another state callback of yours, you have not changed states and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">Если вы в &lt;code&gt;gen_statem&lt;/code&gt; , например, откладываете событие в одном состоянии, а затем вызываете свой обратный вызов другого состояния, вы не изменили состояния и, следовательно, отложенное событие не повторяется, что логично, но может сбивать с толку.</target>
        </trans-unit>
        <trans-unit id="0b9dac884f6e658e0d27a929573db5f362853b18" translate="yes" xml:space="preserve">
          <source>If you instead receives the XML doc as a string you can parse it by &lt;code&gt;xmerl_scan:string/1&lt;/code&gt;. Both file/2 and string/2 exists where the second argument is a list of options to the parser, see the &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вместо этого вы получаете XML-документ в виде строки, вы можете проанализировать его с помощью &lt;code&gt;xmerl_scan:string/1&lt;/code&gt; . Существуют как file / 2, так и string / 2, где второй аргумент представляет собой список опций для синтаксического анализатора, см. &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3677b7b2be331958bb1cd558066c15e2ccbebc50" translate="yes" xml:space="preserve">
          <source>If you know that the binaries you return are always small, you are advised to use driver API calls that do not require a pre-allocated binary, for example, &lt;code&gt;driver_output()&lt;/code&gt; or &lt;code&gt;erl_drv_output_term()&lt;/code&gt;, using the &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; format, to allow the runtime to construct a heap binary.</source>
          <target state="translated">Если вы знаете, что возвращаемые вами двоичные файлы всегда имеют небольшой &lt;code&gt;erl_drv_output_term()&lt;/code&gt; , рекомендуется использовать вызовы API драйвера, для которых не требуется заранее выделенный двоичный файл, например, &lt;code&gt;driver_output()&lt;/code&gt; или erl_drv_output_term () , используя формат &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; , чтобы позволить среде выполнения для создания двоичного файла кучи.</target>
        </trans-unit>
        <trans-unit id="ec9a6635ce4a0b540125a17cac3147d60753ebe4" translate="yes" xml:space="preserve">
          <source>If you know the location of the &lt;code&gt;escript&lt;/code&gt; executable, the first line can directly give the path to &lt;code&gt;escript&lt;/code&gt;, for example:</source>
          <target state="translated">Если вы знаете местоположение исполняемого файла &lt;code&gt;escript&lt;/code&gt; , первая строка может напрямую &lt;code&gt;escript&lt;/code&gt; путь к escript , например:</target>
        </trans-unit>
        <trans-unit id="b659d556ba001a4273a3f6f58c5f3fae0a2ecf0c" translate="yes" xml:space="preserve">
          <source>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">Если вы оставите мьютекс заблокированным в потоке эмулятора, когда вы позволите потоку выйти из-под вашего контроля, вы, &lt;strong&gt;скорее всего,&lt;/strong&gt; заблокируете весь эмулятор.</target>
        </trans-unit>
        <trans-unit id="1b0a6367d887c72eef350e1e461ed2440088fd89" translate="yes" xml:space="preserve">
          <source>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">Если вы оставите rwlock заблокированным в потоке эмулятора, когда вы позволите потоку выйти из-под вашего контроля, вы, &lt;strong&gt;скорее всего,&lt;/strong&gt; заблокируете весь эмулятор.</target>
        </trans-unit>
        <trans-unit id="2051d057687b13e60280ea15afa70933db6bc2e6" translate="yes" xml:space="preserve">
          <source>If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. &lt;code&gt;erl_tar&lt;/code&gt; will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of &lt;code&gt;erl_tar&lt;/code&gt; or &lt;code&gt;tar&lt;/code&gt; which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually.</source>
          <target state="translated">Если вы должны оставаться совместимыми с форматом tar USTAR, вы должны убедиться, что пути к сохраняемым файлам не превышают 255 байт, а максимальная длина компонента имени файла составляет 100 байт. USTAR использует поле заголовка (префикс) в дополнение к полю имени и разделяет пути к файлам длиной более 100 байт на две части. Это разделение выполняется на границе каталога и выполняется таким образом, чтобы наилучшим образом использовать пространство, доступное в этих двух полях, но на практике это часто означает, что у вас меньше 255 байтов для пути. &lt;code&gt;erl_tar&lt;/code&gt; автоматически обновит формат до PAX для обработки более длинных имен файлов, поэтому это проблема только в том случае, если вам нужно распаковать архив с помощью более старой реализации &lt;code&gt;erl_tar&lt;/code&gt; или &lt;code&gt;tar&lt;/code&gt; .который не поддерживает PAX. В этом случае заголовки PAX будут извлечены как обычные файлы, и вам нужно будет применить их вручную.</target>
        </trans-unit>
        <trans-unit id="25dcb500f427185c223988b86fbacdec9413c19c" translate="yes" xml:space="preserve">
          <source>If you need all information stored in the Ets table about persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">Если вам нужна вся информация о лицах с именем &quot;Брайан&quot;,сохраненная в таблице Ets,то:</target>
        </trans-unit>
        <trans-unit id="f37451567abb8a5fc173c77a71ec77e3d5bec387" translate="yes" xml:space="preserve">
          <source>If you need cryptographically strong random numbers use &lt;code&gt;&lt;a href=&quot;#rand_seed_alg_s-1&quot;&gt;rand_seed_alg_s/1&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Alg =:= crypto&lt;/code&gt; or &lt;code&gt;Alg =:= crypto_cache&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0103403298226ace2d2d7dda7dc0c9b1cec0d2bd" translate="yes" xml:space="preserve">
          <source>If you need to access a relational database such as &lt;code&gt;sqlserver&lt;/code&gt;, &lt;code&gt;mysql&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt;, &lt;code&gt;cybase&lt;/code&gt; etc. from your erlang application using the Erlang ODBC interface is a good way to go about it.</source>
          <target state="translated">Если вам нужно получить доступ к реляционной базе данных, такой как &lt;code&gt;sqlserver&lt;/code&gt; , &lt;code&gt;mysql&lt;/code&gt; , &lt;code&gt;postgres&lt;/code&gt; , &lt;code&gt;oracle&lt;/code&gt; , &lt;code&gt;cybase&lt;/code&gt; и т. Д., Из вашего приложения на Erlang, использование интерфейса Erlang ODBC - хороший способ сделать это.</target>
        </trans-unit>
        <trans-unit id="062952594b89959967de93ea3f7d77ceb7f51d4f" translate="yes" xml:space="preserve">
          <source>If you need to be able to repeat the sequence use this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9153977b046897dff8af7e0a644f81df1265049" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that a time-out message cannot arrive after this, unless you have postponed it before (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may have arrived just before you cancelling it, so you may have to read out such a message from the process mailbox depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">Если вам нужно отменить таймер из-за какого-либо другого события, вы можете использовать &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; . Обратите внимание, что сообщение о тайм-ауте не может прийти после этого, если вы не отложили его раньше (см. Следующий раздел), поэтому убедитесь, что вы случайно не отложили такие сообщения. Также обратите внимание, что сообщение о тайм-ауте могло прибыть непосредственно перед его отменой, поэтому вам, возможно, придется зачитать такое сообщение из почтового ящика процесса в зависимости от возвращаемого значения из &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c795f2c3cb53282059f2c8f8a7e14a7e129d266c" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that no time-out message will arrive after this (because the timer has been explicitly canceled), unless you have already postponed one earlier (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may arrive during a &lt;strong&gt;state callback&lt;/strong&gt; that is cancelling the timer, so you may have to read out such a message from the process mailbox, depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62eb303efefa39c68fc73abc117f5184daeab26" translate="yes" xml:space="preserve">
          <source>If you need to define a new function that does garbage collection, you should give it the prefix &lt;code&gt;erts_gc_&lt;/code&gt;. If that is not possible you should update the regular expression so that it will match your new function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05af26e95eb9bb5371b21575710d131d97fecf50" translate="yes" xml:space="preserve">
          <source>If you need to perform configuration operations to run your test, you can implement configuration functions in your suite. The result from a configuration function is configuration data, or &lt;code&gt;Config&lt;/code&gt;. This is a list of key-value tuples that get passed from the configuration function to the test cases (possibly through configuration functions on &quot;lower level&quot;). The data flow looks as follows:</source>
          <target state="translated">Если вам нужно выполнить операции конфигурации для запуска теста, вы можете реализовать функции конфигурации в своем наборе. Результатом функции конфигурации являются данные конфигурации или &lt;code&gt;Config&lt;/code&gt; . Это список кортежей &quot;ключ-значение&quot;, которые передаются из функции конфигурации в тестовые примеры (возможно, через функции конфигурации на &amp;laquo;нижнем уровне&amp;raquo;). Поток данных выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="1580293999144403cc43337470ad032b5154d650" translate="yes" xml:space="preserve">
          <source>If you need to use Erlang code that is not &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;, and you need to start the Erlang runtime system before OS system time has been corrected, you may want to use the single time warp mode.</source>
          <target state="translated">Если вам нужно использовать код Erlang, который не является &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; , и вам нужно запустить систему времени выполнения Erlang до того, как системное время ОС будет исправлено, вы можете использовать режим однократной деформации времени.</target>
        </trans-unit>
        <trans-unit id="0e3af53f2c07526824c69b1abdb7517239318228" translate="yes" xml:space="preserve">
          <source>If you need to use thread-specific data in an emulator thread, only have the thread-specific data set while the thread is under your control, and clear the thread-specific data before you let the thread out of your control.</source>
          <target state="translated">Если в эмуляторном потоке необходимо использовать поток-специфические данные,то,пока поток находится под вашим контролем,вы должны иметь только набор данных для этого потока и очистить эти данные перед тем,как выпустить поток из-под вашего контроля.</target>
        </trans-unit>
        <trans-unit id="4f32b6b35644f5b16edce6c4d78753a25d38ebfb" translate="yes" xml:space="preserve">
          <source>If you need to verify the bootstrap beam files match the provided source files, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; to create a new commit that contains differences, if any exist.</source>
          <target state="translated">Если вам нужно убедиться, что файлы лучей начальной загрузки соответствуют предоставленным исходным файлам, используйте &lt;code&gt;./otp_build update_primary&lt;/code&gt; для создания новой фиксации, содержащей различия, если таковые существуют.</target>
        </trans-unit>
        <trans-unit id="a564a81cdbcd1f7df3fcca09ff995949d4ddcb79" translate="yes" xml:space="preserve">
          <source>If you or your system has special requirements please read the &lt;code&gt;Makefile&lt;/code&gt; for additional configuration information.</source>
          <target state="translated">Если у вас или вашей системы есть особые требования, пожалуйста, прочтите &lt;code&gt;Makefile&lt;/code&gt; для получения дополнительной информации о конфигурации.</target>
        </trans-unit>
        <trans-unit id="c9741cf8a267768b2bd92351adecbc979f0aa0dd" translate="yes" xml:space="preserve">
          <source>If you plan to change code without restarting your system, you must use an external fun (&lt;code&gt;fun Module:Function/Arity&lt;/code&gt;) as function &lt;code&gt;Resolve&lt;/code&gt;. If you use a local fun, you can never replace the code for the module that the fun belongs to.</source>
          <target state="translated">Если вы планируете изменить код без перезапуска системы, вы должны использовать внешнее развлечение ( &lt;code&gt;fun Module:Function/Arity&lt;/code&gt; ) как функцию &lt;code&gt;Resolve&lt;/code&gt; . Если вы используете локальное развлечение, вы никогда не сможете заменить код модуля, которому принадлежит игра.</target>
        </trans-unit>
        <trans-unit id="3d19108a84a5eb3bb48cef4ccb2f6536e5feabf9" translate="yes" xml:space="preserve">
          <source>If you read back the option value using &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; and get no value, the option does not exist in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.</source>
          <target state="translated">Если вы прочитали значение параметра с помощью &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; и не получили значения, значит, параметр не существует в операционной системе хоста. В этом случае поведение сокета IPv6 и IPv4, прослушивающего один и тот же порт, а также сокета IPv6, получающего трафик IPv4, больше нельзя предсказать.</target>
        </trans-unit>
        <trans-unit id="85b82b7060fb8d9f6ed2cb286e33072d08347f0f" translate="yes" xml:space="preserve">
          <source>If you really, really want to, you may call it &quot;Inga&quot;.</source>
          <target state="translated">Если ты очень,очень хочешь,можешь называть его &quot;Инга&quot;.</target>
        </trans-unit>
        <trans-unit id="0ad8b8f8006dc094fc060a805431e5051049c527" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;call&lt;/code&gt; trace flag, you also have to set a &lt;strong&gt;trace pattern&lt;/strong&gt; for the functions you want to trace:</source>
          <target state="translated">Если вы установите флаг трассировки &lt;code&gt;call&lt;/code&gt; , вы также должны установить &lt;strong&gt;шаблон трассировки&lt;/strong&gt; для функций, которые вы хотите отслеживать:</target>
        </trans-unit>
        <trans-unit id="593fb6e309e5d0f221339df106e191b090ca84ba" translate="yes" xml:space="preserve">
          <source>If you simply want to format a paragraph of plain text, you probably want to use the &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; function, as in the following example:</source>
          <target state="translated">Если вы просто хотите отформатировать абзац обычного текста, вы, вероятно, захотите использовать &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; , как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="da6562fe0a7c0b54c043b4d0278072613df57ef3" translate="yes" xml:space="preserve">
          <source>If you start this program with &lt;code&gt;code_lock:start([17])&lt;/code&gt; you can unlock with &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</source>
          <target state="translated">Если вы запустите эту программу с помощью &lt;code&gt;code_lock:start([17])&lt;/code&gt; вы можете разблокировать с помощью &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cace6db1c9825fe249b9c220bf578982c6ffbbda" translate="yes" xml:space="preserve">
          <source>If you successfully parse the XML file with the validation on as in: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; you know that the XML document is valid and has the structure according to the DTD.</source>
          <target state="translated">Если вы успешно проанализируете XML-файл с проверкой, как в: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; вы узнаете, что XML-документ действителен и имеет структуру в соответствии с DTD.</target>
        </trans-unit>
        <trans-unit id="d59053b915a39ff162dae55e7504e339f09a4e42" translate="yes" xml:space="preserve">
          <source>If you try to do the same again with another city, an error is returned:</source>
          <target state="translated">При повторной попытке сделать то же самое с другим городом возвращается ошибка:</target>
        </trans-unit>
        <trans-unit id="a798d01202205d436563f3b0bd17d64f51325641" translate="yes" xml:space="preserve">
          <source>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</source>
          <target state="translated">Если вы попытаетесь сохранить объект в реестре,и там есть существующий объект с тем же ключом,то новое значение заменит старое.Это делается независимо от того,имеет ли новый объект и старый одинаковый тип,поэтому вы можете,например,заменить строку на целое число.Если существующее значение является строкой или двоичным,оно освобождается перед присвоением нового значения.</target>
        </trans-unit>
        <trans-unit id="515a151c90cdd13d9e4906d959838a101ec214d6" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;erl_connect_init()&lt;/code&gt;, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead.</source>
          <target state="translated">Если вы используете &lt;code&gt;erl_connect_init()&lt;/code&gt; , ваш узел будет иметь короткое имя, то есть он не будет полностью определен. Если вам нужно использовать полностью определенные (длинные) имена, используйте вместо этого &lt;code&gt;erl_connect_xinit()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d834de6c7b4bcac9902d0548059107a16f86a8b" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the code for each application is placed in a separate directory following a pre-defined &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вы используете &lt;code&gt;systools&lt;/code&gt; , инструменты Erlang / OTP для упаковки кода (см. &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ), код для каждого приложения помещается в отдельный каталог, следуя заранее определенной &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dfdc592f173581c774f93af24400d86f856a5e1" translate="yes" xml:space="preserve">
          <source>If you use an old apace-like configuration file.</source>
          <target state="translated">Если вы используете старый конфигурационный файл,похожий на пробел.</target>
        </trans-unit>
        <trans-unit id="16a79b696fe4d902f78f4a9ec278a5c8cacbb001" translate="yes" xml:space="preserve">
          <source>If you use multiple CTHs, the first part of the return tuple is used as input for the next CTH. So in the previous example the next CTH can get &lt;code&gt;{fail,Reason}&lt;/code&gt; as the second parameter. If you have many CTHs interacting, do not let each CTH return &lt;code&gt;fail&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;. Instead, return that an action is to be taken through the &lt;code&gt;Config&lt;/code&gt; list and implement a CTH that, at the end, takes the correct action.</source>
          <target state="translated">Если вы используете несколько CTH, первая часть возвращаемого кортежа используется в качестве входных данных для следующего CTH. Итак, в предыдущем примере следующий CTH может получить &lt;code&gt;{fail,Reason}&lt;/code&gt; в качестве второго параметра. Если у вас много взаимодействующих CTH, не допускайте &lt;code&gt;fail&lt;/code&gt; или &lt;code&gt;skip&lt;/code&gt; каждого возврата CTH . Вместо этого верните, что действие должно быть выполнено через список &lt;code&gt;Config&lt;/code&gt; и реализовать CTH, который в конце выполняет правильное действие.</target>
        </trans-unit>
        <trans-unit id="930cef54ac87bd2c1ca6f2387bf6edcd93ce9313" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Erl_Interface&lt;/code&gt; functions in a threaded application based on POSIX threads or Solaris threads, then &lt;code&gt;Erl_Interface&lt;/code&gt; needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define &lt;code&gt;_REENTRANT&lt;/code&gt; and either &lt;code&gt;STHREADS&lt;/code&gt; or &lt;code&gt;PTHREADS&lt;/code&gt;. The default is to use POSIX threads if &lt;code&gt;_REENTRANT&lt;/code&gt; is specified.</source>
          <target state="translated">Если вы используете функции &lt;code&gt;Erl_Interface&lt;/code&gt; в многопоточном приложении, основанном на потоках POSIX или Solaris, тогда &lt;code&gt;Erl_Interface&lt;/code&gt; требует доступа к некоторым средствам синхронизации в вашем пакете потоков. Вы должны указать дополнительные флаги компилятора, чтобы указать, какой из пакетов вы используете. Определите &lt;code&gt;_REENTRANT&lt;/code&gt; и либо &lt;code&gt;STHREADS&lt;/code&gt; , либо &lt;code&gt;PTHREADS&lt;/code&gt; . По умолчанию используются потоки POSIX, если &lt;code&gt;_REENTRANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="918394c05671a0235e153985bd2840211574395e" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;ct_run&lt;/code&gt; program, you can start the Erlang shell and &lt;code&gt;Common Test&lt;/code&gt; in one go by using the flag &lt;code&gt;-shell&lt;/code&gt; and, optionally, flag &lt;code&gt;-config&lt;/code&gt; and/or &lt;code&gt;-userconfig&lt;/code&gt;.</source>
          <target state="translated">Если вы используете программу &lt;code&gt;ct_run&lt;/code&gt; , вы можете запустить оболочку Erlang и &lt;code&gt;Common Test&lt;/code&gt; за один раз, используя флаг &lt;code&gt;-shell&lt;/code&gt; и, необязательно, флаг &lt;code&gt;-config&lt;/code&gt; и / или &lt;code&gt;-userconfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3feb64f146fe919b2a69ce546c85439b7b8b28d7" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2153b220590bbe864e1f5e224d987fcb64330153" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">Если вы хотите, чтобы на узле Erlang с самого начала было активное удаленное задание (а не локальное задание по умолчанию), запустите Erlang с флагом &lt;code&gt;-remsh&lt;/code&gt; , например, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50de302c93e8bacbc69e071b7eec983f033e6a07" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#call-4&quot;&gt;erpc:call()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e8ce10cfe9321c8cbd6786fc123b13ea0a780a" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#multicall-4&quot;&gt;erpc:multicall()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f9444d15f637070cc1c5665eb79410298eb57c" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#send_request-4&quot;&gt;erpc:send_request()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead. This also gives you the ability retrieve the results in other useful ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4038140d6bff952f2f9f5f48acf2d27c3f6092b" translate="yes" xml:space="preserve">
          <source>If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; only (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the &lt;code&gt;Handle&lt;/code&gt; value.</source>
          <target state="translated">Если вы хотите, чтобы соединение было связано только с &lt;code&gt;Handle&lt;/code&gt; (если вам, например, нужно открыть несколько соединений с хостом), используйте &lt;code&gt;Key&lt;/code&gt; , имя переменной конфигурации, чтобы указать цель. Обратите внимание, что соединение без связанного имени цели может быть закрыто только со значением &lt;code&gt;Handle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c1ebb966c6523b3c1b7beffcce3bfa9b40caeb1" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt; erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c8c9a37ae2934ad0217ae03b7ce8edb49f913c" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если вам нужен тот же формат, что и возвращаемый &lt;code&gt;erlang:now/0&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="340edf748ea085618e9e02efc24d38acd583eead" translate="yes" xml:space="preserve">
          <source>If you want to add the information about a black Harley Davidsson 1200 cc Sportster motorcycle from 2003 that is in shape as new in the motorcycles.xml document you can put the data in a simple-form data structure like:</source>
          <target state="translated">Если вы хотите добавить информацию о черном мотоцикле Harley Davidsson 1200 cc Sportster 2003 года,который находится в форме как новый в документе motorcles.xml,вы можете поместить данные в простую структуру данных типа:</target>
        </trans-unit>
        <trans-unit id="76e13e233caef4d78d7dc7bb7c518cb87cbe184c" translate="yes" xml:space="preserve">
          <source>If you want to apply patches of multiple OTP applications that resides in different OTP versions, you have to apply these patches in multiple steps. It is only possible to apply multiple OTP applications from the same OTP version at once.</source>
          <target state="translated">Если вы хотите применить патчи для нескольких OTP-приложений,которые находятся в разных версиях OTP,вы должны применить эти патчи в несколько этапов.Можно применять патчи только к нескольким OTP-приложениям,находящимся в одной и той же версии OTP одновременно.</target>
        </trans-unit>
        <trans-unit id="42438cc3a906ec708300aa20929e7d2e6e66a173" translate="yes" xml:space="preserve">
          <source>If you want to build the &lt;code&gt;wx&lt;/code&gt; application, you will need to get wxWidgets-3.0 (&lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt;) or get it from github with bug fixes:</source>
          <target state="translated">Если вы хотите создать приложение &lt;code&gt;wx&lt;/code&gt; , вам необходимо получить wxWidgets-3.0 ( &lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt; ) или получить его с github с исправлением ошибок:</target>
        </trans-unit>
        <trans-unit id="60d473a6aa433acfb9c1c6ca737fe13eaf0848c9" translate="yes" xml:space="preserve">
          <source>If you want to build using a compatible Erlang/OTP system in the &lt;code&gt;$PATH&lt;/code&gt;, jump to (3).</source>
          <target state="translated">Если вы хотите построить с использованием совместимой системы Erlang / OTP в &lt;code&gt;$PATH&lt;/code&gt; , перейдите к (3).</target>
        </trans-unit>
        <trans-unit id="eb5df9d9054fc0c4d2d1fdf02282b9d140be554d" translate="yes" xml:space="preserve">
          <source>If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with &lt;code&gt;{source_name, SourceName}&lt;/code&gt;. If unset it will default to the name of the opened file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c541b95485f056deb59b7660fe1bc3263ea0c2c7" translate="yes" xml:space="preserve">
          <source>If you want to copy a library (an application) newly built, to a release area, you do like with the emulator:</source>
          <target state="translated">Если вы хотите скопировать библиотеку (приложение)только что построенного,в область релиза,вам понравится эмулятор:</target>
        </trans-unit>
        <trans-unit id="478802cbe47a5a6b031caf1a058324304adf72a9" translate="yes" xml:space="preserve">
          <source>If you want to do structured logging, but still want to have some control of how the final log message is formatted you can give a &lt;code&gt;report_cb&lt;/code&gt; as part of the metadata with your log event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af39ab464f4c4ad6184b7312f8ff3491ab00be0a" translate="yes" xml:space="preserve">
          <source>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).</source>
          <target state="translated">Если вы хотите вызвать сбой при совпадении в какой-то точке детали,то удобнее всего это сделать с помощью (?!),так как пустая строка всегда совпадает.Таким образом,утверждение,требующее,чтобы не было пустой строки,всегда должно давать сбой.Контрольный глагол (*FAIL)или (*F)является синонимом (?!).</target>
        </trans-unit>
        <trans-unit id="b53c1301abde2142a7a519277a4e352002bba7dc" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after a &lt;strong&gt;state change&lt;/strong&gt;, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d95e36a6d42c79b8d9f3cbb7ca6b72d1dfb12b0" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after the state has changed, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите проигнорировать конкретное событие в текущем состоянии и обработать его в будущем состоянии, вы можете отложить событие. &lt;code&gt;OldState =/= NewState&lt;/code&gt; событие повторяется после изменения состояния, то есть OldState = / = NewState .</target>
        </trans-unit>
        <trans-unit id="9b637ab1ccef72c8ef19f9dd28f47f58deee1a99" translate="yes" xml:space="preserve">
          <source>If you want to limit the size of the trace logs, you can use wrap logs. This works almost like a circular buffer. You can specify the maximum number of binary logs and the maximum size of each log. &lt;code&gt;ttb&lt;/code&gt; then creates a new binary log each time a log reaches the maximum size. When the maximum number of logs are reached, the oldest log is deleted before a new one is created.</source>
          <target state="translated">Если вы хотите ограничить размер журналов трассировки, вы можете использовать журналы переноса. Это работает почти как круговой буфер. Вы можете указать максимальное количество двоичных журналов и максимальный размер каждого журнала. &lt;code&gt;ttb&lt;/code&gt; создает новый двоичный журнал каждый раз, когда журнал достигает максимального размера. По достижении максимального количества журналов самый старый журнал удаляется перед созданием нового.</target>
        </trans-unit>
        <trans-unit id="3ba20665ef257abe2a78ab66aec5b8422b06c770" translate="yes" xml:space="preserve">
          <source>If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:</source>
          <target state="translated">Если необходимо сопоставить типичные палиндромные фразы,то образец должен игнорировать все несловесные символы,что можно сделать следующим образом:</target>
        </trans-unit>
        <trans-unit id="ecc0e9164bc34f28d81e7ffb4afcab4e5c0c14b8" translate="yes" xml:space="preserve">
          <source>If you want to only print run-time per thread type you can do:</source>
          <target state="translated">Если вы хотите распечатать только время выполнения для каждого типа потока,вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="be41c980691226fb7b2d6a9c0782adc2d56de58a" translate="yes" xml:space="preserve">
          <source>If you want to output the content of an XML element or an attribute you will get the value as a string by the &lt;code&gt;value_of&lt;/code&gt; function:</source>
          <target state="translated">Если вы хотите вывести содержимое элемента XML или атрибута, вы получите значение в виде строки с &lt;code&gt;value_of&lt;/code&gt; функции value_of :</target>
        </trans-unit>
        <trans-unit id="e7aef053601a6ea882918cfebb175091d4d52943" translate="yes" xml:space="preserve">
          <source>If you want to parse the XML file motorcycles.xml you run it in the Erlang shell like:</source>
          <target state="translated">Если вы хотите разобрать XML-файл motorcycles.xml,то запустите его в оболочке Erlang как:</target>
        </trans-unit>
        <trans-unit id="6e509b56bd064c6196e8412d4a6710ea854feb39" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f0b294d62ab97983874294bfe640932bf22f5a" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">Если вы хотите передать двоичный файл и еще не имеете его содержимого в &lt;code&gt;ErlDrvBinary&lt;/code&gt; , вы можете воспользоваться &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; вместо создания &lt;code&gt;ErlDrvBinary&lt;/code&gt; через &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; , а затем передать двоичный файл через &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; . Система времени выполнения часто распределяет двоичные файлы умнее, если используется &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; . Однако, если содержимое передаваемого двоичного &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; уже находится в &lt;code&gt;ErlDrvBinary&lt;/code&gt; , обычно лучше передать двоичный файл, используя ERL_DRV_BINARY и соответствующий &lt;code&gt;ErlDrvBinary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="480d25bad4b8ee292973eb9f4a96b57aec47c435" translate="yes" xml:space="preserve">
          <source>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named &lt;code&gt;m_tests&lt;/code&gt; (note: not &lt;code&gt;m_test&lt;/code&gt;), if your module is named &lt;code&gt;m&lt;/code&gt;. Then, whenever you ask EUnit to test the module &lt;code&gt;m&lt;/code&gt;, it will also look for the module &lt;code&gt;m_tests&lt;/code&gt; and run those tests as well. See &lt;code&gt;ModuleName&lt;/code&gt; in the section &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">Если вы хотите отделить свой тестовый код от обычного кода (по крайней мере, для тестирования экспортируемых функций), вы можете просто написать тестовые функции в модуле с именем &lt;code&gt;m_tests&lt;/code&gt; (примечание: не &lt;code&gt;m_test&lt;/code&gt; ), если ваш модуль называется &lt;code&gt;m&lt;/code&gt; . Затем, когда вы попросите EUnit протестировать модуль &lt;code&gt;m&lt;/code&gt; , он также будет искать модуль &lt;code&gt;m_tests&lt;/code&gt; и запускать эти тесты. См. &lt;code&gt;ModuleName&lt;/code&gt; в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7febab41e67d722699474affa70aca83861a7f64" translate="yes" xml:space="preserve">
          <source>If you want to tailor your Erlang/OTP build and installation, please read on for detailed information about the individual steps.</source>
          <target state="translated">Если вы хотите настроить вашу сборку и установку Erlang/OTP,пожалуйста,прочтите дальше для получения подробной информации об отдельных шагах.</target>
        </trans-unit>
        <trans-unit id="5c51074011b9826995f35f468d11eff897ad5c37" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите отслеживать вызовы функций (то есть, если у вас установлен &lt;code&gt;call&lt;/code&gt; флага трассировки для любого процесса), вы также должны установить шаблоны трассировки для требуемых функций с помощью &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; . Функция отслеживается только в том случае, если у нее есть шаблон трассировки. Шаблон трассировки указывает, как отслеживать функцию с помощью спецификаций соответствия. Технические характеристики соответствия описаны в &lt;code&gt;ERTS User's Guide&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c40a044ef678327852ece515ee5ae9954050c2e8" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#tp-2&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#tpl-2&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4204e5cb6bf67f77002e41cae41377b945558f43" translate="yes" xml:space="preserve">
          <source>If you want your systems logs to be printed to a file instead, you must configure the default handler to do so. The simplest way is to include the following in your &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите, чтобы ваши системные журналы вместо этого печатались в файл, вы должны настроить для этого обработчик по умолчанию. Самый простой способ - включить в &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt; следующее :</target>
        </trans-unit>
        <trans-unit id="bc1242f30c23d446d1188a6ac120aa5dbc4659e1" translate="yes" xml:space="preserve">
          <source>If you wish to exit the interactive mode (for example, to start an automated test run with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), call function &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt;. This shuts down the running &lt;code&gt;ct&lt;/code&gt; application. Associations between configuration names and data created with &lt;code&gt;require&lt;/code&gt; are consequently deleted. Function &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; takes you back into interactive mode, but the previous state is not restored.</source>
          <target state="translated">Если вы хотите выйти из интерактивного режима (например, чтобы запустить автоматический тестовый прогон с помощью &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; ), вызовите функцию &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt; . Это завершает работу запущенного приложения &lt;code&gt;ct&lt;/code&gt; . Соответственно, удаляются ассоциации между именами конфигурации и данными, созданными с помощью &lt;code&gt;require&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; возвращает вас в интерактивный режим, но предыдущее состояние не восстанавливается.</target>
        </trans-unit>
        <trans-unit id="e10f84ca92ffa048cba38c4e906ca1f626ae3a34" translate="yes" xml:space="preserve">
          <source>If you wish to store an arbitrary pointer in the registry, specify a &lt;code&gt;size&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;. In this case, the object itself is not transferred by an &lt;code&gt;ei_reg_dump()&lt;/code&gt; operation, only the pointer value.</source>
          <target state="translated">Если вы хотите сохранить произвольный указатель в реестре, указать &lt;code&gt;size&lt;/code&gt; от &lt;code&gt;0&lt;/code&gt; . В этом случае сам объект не передается &lt;code&gt;ei_reg_dump()&lt;/code&gt; , а только значение указателя.</target>
        </trans-unit>
        <trans-unit id="ebce7ca5b1598f3fc834609ac79ed9ef57b76a9b" translate="yes" xml:space="preserve">
          <source>If you're unable to produce back-ticks on your keyboard, you can use the ksh variant:</source>
          <target state="translated">Если вы не можете производить обратные вызовы на клавиатуре,вы можете использовать вариант ksh:</target>
        </trans-unit>
        <trans-unit id="898016192f939b5abb6e665e68d4a556cad78625" translate="yes" xml:space="preserve">
          <source>If you're using MinGW's MSYS instead, you need to change the &lt;code&gt;C_DRV&lt;/code&gt; setting, which would read:</source>
          <target state="translated">Если вместо этого вы используете MSYS MinGW, вам нужно изменить параметр &lt;code&gt;C_DRV&lt;/code&gt; , который будет выглядеть так :</target>
        </trans-unit>
        <trans-unit id="b80191fd2f2a93c0231ee04e580f333dbbc4b2c1" translate="yes" xml:space="preserve">
          <source>If you've upgraded the source with a patch you may need to clean up from previous builds before the new build. Make sure to read the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; section below before doing a &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">Если вы обновили исходный код патчем, вам может потребоваться очистить предыдущие сборки перед новой сборкой. Обязательно прочтите раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; &amp;raquo; ниже, прежде чем выполнять &lt;code&gt;make clean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94d3d2824c70cd2f197cb4a4e891f6adbf0d6555" translate="yes" xml:space="preserve">
          <source>If your application has multiple levels of supervision, then do not simply set the restart intensities to the same values on all levels. Keep in mind that the total number of restarts (before the top level supervisor gives up and terminates the application) will be the product of the intensity values of all the supervisors above the failing child process.</source>
          <target state="translated">Если ваша программа имеет несколько уровней контроля,то не стоит просто устанавливать интенсивность перезапуска на одинаковые значения на всех уровнях.Имейте в виду,что общее количество перезагрузок (до того,как супервайзер верхнего уровня откажется и прекратит приложение)будет произведено значениями интенсивности всех супервайзеров над неработающим дочерним процессом.</target>
        </trans-unit>
        <trans-unit id="8bdaa0464a895b83db580413a1dfb239d0cea7a3" translate="yes" xml:space="preserve">
          <source>If your driver supports scrollable cursors you have a little more freedom, and can do things like this.</source>
          <target state="translated">Если ваш драйвер поддерживает курсоры прокрутки,у вас есть немного больше свободы,и вы можете делать такие вещи.</target>
        </trans-unit>
        <trans-unit id="d4baf8bf70284fc593a0f0c3da52f4c0847c8447" translate="yes" xml:space="preserve">
          <source>If your process logic is convenient to describe as a state machine, and you want any of these &lt;code&gt;gen_statem&lt;/code&gt; key features:</source>
          <target state="translated">Если логику вашего процесса удобно описать как &lt;code&gt;gen_statem&lt;/code&gt; автомат, и вам нужна любая из этих ключевых функций gen_statem :</target>
        </trans-unit>
        <trans-unit id="3a769c81046d5475e30518ad57d42d8c20c63372" translate="yes" xml:space="preserve">
          <source>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the &lt;code&gt;user&lt;/code&gt; output stream, as in &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt;. The recommended way of doing this is to use the EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;, which make it much simpler.</source>
          <target state="translated">Если ваш тестовый код записывается в стандартный вывод, вы можете быть удивлены, увидев, что текст не отображается на консоли во время выполнения тестов. Это связано с тем, что EUnit захватывает все стандартные выходные данные тестовых функций (это также включает функции настройки и очистки, но не функции генератора), чтобы его можно было включить в отчет о тестировании в случае возникновения ошибок. Чтобы обойти EUnit и печатать текст непосредственно в консоли во время тестирования, вы можете записать в поток вывода &lt;code&gt;user&lt;/code&gt; , как в &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt; . Рекомендуемый способ сделать это - использовать макросы &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; EUnit , которые значительно упрощают его.</target>
        </trans-unit>
        <trans-unit id="7e46e774253b8a01c9e57b4a236314fe7c6f0933" translate="yes" xml:space="preserve">
          <source>If, for example, only information originating from the UNIX kernel is to be supervised, the line is to begin with &lt;code&gt;kern.LEVEL&lt;/code&gt;. For the possible values of &lt;code&gt;LEVEL&lt;/code&gt;, see &lt;code&gt;syslog.conf(5)&lt;/code&gt;.</source>
          <target state="translated">Если, например, нужно контролировать только информацию, исходящую от ядра UNIX, строка должна начинаться с &lt;code&gt;kern.LEVEL&lt;/code&gt; . Возможные значения &lt;code&gt;LEVEL&lt;/code&gt; см. В &lt;code&gt;syslog.conf(5)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e15af770ad74c816f0b9bed18089dc4b7b6949" translate="yes" xml:space="preserve">
          <source>If, however, the more brutal variant is preferred, the the release upgrade file can be handwritten using only the single upgrade instruction &lt;code&gt;restart_emulator&lt;/code&gt;. This instruction, in contrast to &lt;code&gt;restart_new_emulator&lt;/code&gt;, causes the emulator to restart with the new versions of &lt;strong&gt;all&lt;/strong&gt; applications.</source>
          <target state="translated">Однако, если предпочтительнее более жестокий вариант, файл обновления выпуска может быть &lt;code&gt;restart_emulator&lt;/code&gt; руки с использованием только одной инструкции обновления restart_emulator . Эта инструкция, в отличие от &lt;code&gt;restart_new_emulator&lt;/code&gt; , заставляет эмулятор перезапускаться с новыми версиями &lt;strong&gt;всех&lt;/strong&gt; приложений.</target>
        </trans-unit>
        <trans-unit id="8767a6609841ad161f8c8ba70fce614ffbb6d735" translate="yes" xml:space="preserve">
          <source>If, however, the profiling time is short, and the host machine OS does not support high resolution cpu time measurements, some few OS schedulings may show up as ridiculously long execution times for functions doing practically nothing. An example of a function more or less just composing a tuple in about 100 times the normal execution time has been seen, and when the tracing was repeated, the execution time became normal.</source>
          <target state="translated">Однако,если время профилирования невелико,а операционная система хост-машины не поддерживает измерения времени вычислений с высоким разрешением,некоторые из планируемых операционных систем могут показаться такими же нелепыми,как и длительное время выполнения функций,практически ничего не выполняющих.Пример функции,более или менее просто составляющей кортеж примерно в 100 раз больше обычного времени выполнения,и когда трассировка повторялась,время выполнения становилось нормальным.</target>
        </trans-unit>
        <trans-unit id="59b8380df4e4f344feb44d33018af07ce17468c9" translate="yes" xml:space="preserve">
          <source>Ifopts :: &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt;getifaddrs_ifopts()&lt;/a&gt;&lt;/code&gt;}]} |</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab139e8caa6336e1a75280870aaa88d194b8f0" translate="yes" xml:space="preserve">
          <source>Ignores the next term.</source>
          <target state="translated">Игнорирует следующий семестр.</target>
        </trans-unit>
        <trans-unit id="556c1293becdd2112a2dbef3ccdc8818c38e5526" translate="yes" xml:space="preserve">
          <source>Igor will look for terms &lt;code&gt;{igor, List}&lt;/code&gt; in the compile options, where &lt;code&gt;List&lt;/code&gt; is a list of Igor-specific options, as follows:</source>
          <target state="translated">Игорь будет искать термины &lt;code&gt;{igor, List}&lt;/code&gt; в параметрах компиляции, где &lt;code&gt;List&lt;/code&gt; - это список параметров Игоря, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="12b0ac37014df125334c7cd0aa5d1e3fd4b2112b" translate="yes" xml:space="preserve">
          <source>Igor: the Module Merger and Renamer.</source>
          <target state="translated">Игорь:Модуль Слияния и Ренамера.</target>
        </trans-unit>
        <trans-unit id="434e93d1be37385e2cb586a90949b6d54ba9fb45" translate="yes" xml:space="preserve">
          <source>Illegal record use</source>
          <target state="translated">Незаконное использование записи</target>
        </trans-unit>
        <trans-unit id="3e2e754eaf99ea7ee3f9e02b703f2ea22dce19f1" translate="yes" xml:space="preserve">
          <source>Imagine two nodes, &lt;code&gt;A&lt;/code&gt; that initiates the handshake and &lt;code&gt;B&lt;/code&gt; that accepts the connection.</source>
          <target state="translated">Представьте себе два узла: &lt;code&gt;A&lt;/code&gt; , который инициирует рукопожатие, и &lt;code&gt;B&lt;/code&gt; , который принимает соединение.</target>
        </trans-unit>
        <trans-unit id="8170de3694759bfa15c0e42d75a0e2dbd2eae04c" translate="yes" xml:space="preserve">
          <source>Immediately after &lt;code&gt;{addr,_}&lt;/code&gt; follows &lt;code&gt;{netmask,_}&lt;/code&gt;.</source>
          <target state="translated">Сразу после &lt;code&gt;{addr,_}&lt;/code&gt; следует &lt;code&gt;{netmask,_}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1bf55aaa279dcec7c69afe67e49a23edfac3d7b" translate="yes" xml:space="preserve">
          <source>Immediately closes a socket in one or two directions.</source>
          <target state="translated">Немедленно закрывает розетку в одном или двух направлениях.</target>
        </trans-unit>
        <trans-unit id="0146e3e7271e73fd4397519ed5ac080aa4266f79" translate="yes" xml:space="preserve">
          <source>Immediately thereafter follows &lt;code&gt;{broadaddr,_}&lt;/code&gt; if flag &lt;code&gt;broadcast&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; set and flag &lt;code&gt;pointtopoint&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; set.</source>
          <target state="translated">Сразу же после этого следует &lt;code&gt;{broadaddr,_}&lt;/code&gt; , если флаг &lt;code&gt;broadcast&lt;/code&gt; будет &lt;strong&gt;не&lt;/strong&gt; установлено и флаг &lt;code&gt;pointtopoint&lt;/code&gt; &lt;strong&gt;будет&lt;/strong&gt; установлен.</target>
        </trans-unit>
        <trans-unit id="cb29b93b7dda93ac46a90e113b640a73b1abac2b" translate="yes" xml:space="preserve">
          <source>Immediately thereafter may &lt;code&gt;{broadaddr,_}&lt;/code&gt; follow if &lt;code&gt;broadcast&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;, or &lt;code&gt;{dstaddr,_}&lt;/code&gt; if &lt;code&gt;pointtopoint&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;. Both &lt;code&gt;{dstaddr,_}&lt;/code&gt; and &lt;code&gt;{broadaddr,_}&lt;/code&gt; does not occur for the same &lt;code&gt;{addr,_}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="bc83afa84755c20a6573a25450865f22d16b7af9" translate="yes" xml:space="preserve">
          <source>Implement a User-Specific Handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3848d63613aeeb25bb34384b1787a4b8da6d6ff9" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;outputv&lt;/code&gt; callback (instead of an &lt;code&gt;output&lt;/code&gt; callback) in the driver. If a driver has an &lt;code&gt;outputv&lt;/code&gt; callback, refc binaries passed in an iolist in the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_command/2&lt;/code&gt; will be passed as references to the driver.</source>
          <target state="translated">Реализовать &lt;code&gt;outputv&lt;/code&gt; обратного вызова (вместо &lt;code&gt;output&lt;/code&gt; обратного вызова) в драйвере. Если у драйвера есть &lt;code&gt;outputv&lt;/code&gt; вызов outputv, двоичные файлы refc, переданные в iolist в аргументе &lt;code&gt;Data&lt;/code&gt; для &lt;code&gt;port_command/2&lt;/code&gt; , будут переданы как ссылки на драйвер.</target>
        </trans-unit>
        <trans-unit id="2550fab1130c47b29d0bf324dcd951c87cbd4c20" translate="yes" xml:space="preserve">
          <source>Implement the user(s).</source>
          <target state="translated">Реализуйте пользователя (пользователей).</target>
        </trans-unit>
        <trans-unit id="48c5877ca241f34b3f104510084da2e3f17d9449" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">Осуществление:Используется сбалансированное дерево бинарного поиска.Сложность по времени пропорциональна бревну N,где N-количество свободных блоков.</target>
        </trans-unit>
        <trans-unit id="986bf772c885393163838b577762f2d1f9c7f455" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</source>
          <target state="translated">Осуществление:Используется сбалансированное дерево бинарного поиска.Сложность по времени пропорциональна бревну N,где N-количество размеров свободных блоков.</target>
        </trans-unit>
        <trans-unit id="bd869e893b5f7a40f0a166908e0bc628120afba1" translate="yes" xml:space="preserve">
          <source>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">Осуществление:Используются сбалансированные деревья бинарного поиска.Сложность во времени пропорциональна бревну N,где N-количество свободных блоков.</target>
        </trans-unit>
        <trans-unit id="46bfb88bf9e53e73f8388ee9ed0d26c11b02304f" translate="yes" xml:space="preserve">
          <source>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</source>
          <target state="translated">Осуществление:Проверьте первый блок в свободном списке.Если он удовлетворяет запросу,он используется,в противном случае создается новый носитель.Реализация имеет постоянную временную сложность.</target>
        </trans-unit>
        <trans-unit id="c6a2194bfaf5e060ecf03c5376d35a554cce3c35" translate="yes" xml:space="preserve">
          <source>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Реализация: Реализация использует отдельные списки свободных мест с максимальной глубиной поиска блока (в каждом списке), чтобы быстро найти подходящие. Когда максимальная глубина поиска блока мала (по умолчанию 3), эта реализация имеет постоянную временную сложность. Максимальную глубину поиска блока можно настроить с помощью параметра &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa4a22b5053f3e953012b88774f1658cf1eb84b" translate="yes" xml:space="preserve">
          <source>Implementing a Manager Application.</source>
          <target state="translated">Внедрение приложения для менеджера.</target>
        </trans-unit>
        <trans-unit id="d1d356a99f2a68bb32f56a5afc4fc7243ac4c122" translate="yes" xml:space="preserve">
          <source>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and table operations, is generated without any programming.</source>
          <target state="translated">Реализация MIB может быть утомительной задачей. Скорее всего, необходимо протестировать агент до того, как будут реализованы все таблицы и переменные. В этом случае полезны функции инструментария по умолчанию. Инструментарий может генерировать инструментальные функции по умолчанию как для переменных, так и для таблиц. Следовательно, работающий агент-прототип, который может обрабатывать операции &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;get-next&lt;/code&gt; и table, создается без какого-либо программирования.</target>
        </trans-unit>
        <trans-unit id="5089bf216d6ab81557737c36828f21a117ecd8d4" translate="yes" xml:space="preserve">
          <source>Implementing support for Unicode character sets is an ongoing process. The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and specified a default encoding in binaries that all Unicode-aware modules are to handle in the future.</source>
          <target state="translated">Реализация поддержки наборов символов Юникода является непрерывным процессом.В Erlang Enhancement Proposal (EEP)10 изложены основы поддержки Юникода и указана кодировка по умолчанию в двоичных файлах,с которой в будущем будут работать все модули,поддерживающие Юникод.</target>
        </trans-unit>
        <trans-unit id="afb6d8666156732e31fdfd33a4e37fa8e0ff12b1" translate="yes" xml:space="preserve">
          <source>Implementing the MIB</source>
          <target state="translated">Внедрение MIB</target>
        </trans-unit>
        <trans-unit id="3598443bca8912627263e77be152abb2f8fea1d8" translate="yes" xml:space="preserve">
          <source>Implements &lt;strong&gt;call streams with promises&lt;/strong&gt;, a type of RPC that does not suspend the caller until the result is finished. Instead, a key is returned, which can be used later to collect the value. The key can be viewed as a promise to deliver the answer.</source>
          <target state="translated">Реализует &lt;strong&gt;потоки вызовов с обещаниями&lt;/strong&gt; , типом RPC, который не приостанавливает вызывающего абонента до тех пор, пока не будет завершен результат. Вместо этого возвращается ключ, который можно использовать позже для сбора значения. Ключ можно рассматривать как обещание дать ответ.</target>
        </trans-unit>
        <trans-unit id="701e88bfb66430bf554605afebb5bc817eba6c88" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt; ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5852555552878975a45593281d37fefa3026933d" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">Реализует внутренний кэш CRL (список отзыва сертификатов). В дополнение к реализации поведения &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; доступны следующие функции.</target>
        </trans-unit>
        <trans-unit id="b29c8d309278d1184cdf0686f160a939ff31d257" translate="yes" xml:space="preserve">
          <source>Implements global (repetitive) search (flag &lt;code&gt;g&lt;/code&gt; in Perl). Each match is returned as a separate &lt;code&gt;list()&lt;/code&gt; containing the specific match and any matching subexpressions (or as specified by option &lt;code&gt;capture&lt;/code&gt;. The &lt;code&gt;Captured&lt;/code&gt; part of the return value is hence a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s when this option is specified.</source>
          <target state="translated">Реализует глобальный (повторяющийся) поиск (флаг &lt;code&gt;g&lt;/code&gt; в Perl). Каждый матч возвращается в виде отдельного &lt;code&gt;list()&lt;/code&gt; , содержащей матч конкретные и любые совпадающие подвыражения (или как указано в опции &lt;code&gt;capture&lt;/code&gt; . &lt;code&gt;Captured&lt;/code&gt; часть возвращаемого значения является , следовательно, &lt;code&gt;list()&lt;/code&gt; из &lt;code&gt;list()&lt;/code&gt; S Если указана эта опция.</target>
        </trans-unit>
        <trans-unit id="d0d6b7b06bc0717a09a0609e9b93d5b110576e74" translate="yes" xml:space="preserve">
          <source>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is included in the source code.</source>
          <target state="translated">Реализует преобразование во время компиляции. Эта функция вызывается компилятором для преобразования исходного кода, если и когда заголовочный файл &lt;code&gt;ms_transform.hrl&lt;/code&gt; включен в исходный код.</target>
        </trans-unit>
        <trans-unit id="6edd4a0551006932a13f07152c0a0aa13d34aeb3" translate="yes" xml:space="preserve">
          <source>Implements the transformation when the &lt;code&gt;fun2ms/1&lt;/code&gt; functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as &lt;code&gt;BoundEnvironment&lt;/code&gt;. The result is a term, normalized, that is, not in abstract format.</source>
          <target state="translated">Реализует преобразование, когда функции &lt;code&gt;fun2ms/1&lt;/code&gt; вызываются из оболочки. В данном случае абстрактная форма предназначена для одного развлечения (анализируется оболочкой Erlang). Все импортированные переменные должны быть в списке &quot;ключ-значение&quot;, переданном как &lt;code&gt;BoundEnvironment&lt;/code&gt; . Результатом является нормализованный термин, то есть не в абстрактном формате.</target>
        </trans-unit>
        <trans-unit id="5157539667ba028bf842cb4d314ce494573a8908" translate="yes" xml:space="preserve">
          <source>Implicitly when a specific instruction is defined. This is by far the most common way. Whenever a specific instruction is created, &lt;strong&gt;beam_makeops&lt;/strong&gt; automatically creates an internal generic instruction if it does not previously exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b7c113ae3f8b579e4a0169b23cb527018f3cd218" translate="yes" xml:space="preserve">
          <source>Import configuration data (similar to &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt;).</source>
          <target state="translated">Импортируйте данные конфигурации (аналогично &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="64200c8515980ead3d6f6d1c54b72c0df1647038" translate="yes" xml:space="preserve">
          <source>Imported functions. Can be called the same way as local functions, that is, without any module prefix.</source>
          <target state="translated">Импортируемые функции.Может вызываться так же,как и локальные функции,то есть без префикса модуля.</target>
        </trans-unit>
        <trans-unit id="e96159a0570df1d76f4d6b6b63ad56985185ffc2" translate="yes" xml:space="preserve">
          <source>Imports coverage data from the file &lt;code&gt;ExportFile&lt;/code&gt; created with &lt;code&gt;cover:export/1,2&lt;/code&gt;. Any analysis performed after this will include the imported data.</source>
          <target state="translated">Импортирует данные покрытия из файла &lt;code&gt;ExportFile&lt;/code&gt; , созданного с помощью &lt;code&gt;cover:export/1,2&lt;/code&gt; . Любой анализ, выполненный после этого, будет включать импортированные данные.</target>
        </trans-unit>
        <trans-unit id="6293ff4a8408c9b4904b5c4c8135a7dbb83fe606" translate="yes" xml:space="preserve">
          <source>Improper use can seriously degrade system performance.</source>
          <target state="translated">Неправильное использование может серьезно ухудшить производительность системы.</target>
        </trans-unit>
        <trans-unit id="68545fd32c1a3f37a53bcab05bb6a3c24b6ca95e" translate="yes" xml:space="preserve">
          <source>In .emacs, the slash character &quot;/&quot; can be used as path separator. But if you decide to use the backslash character &quot;\&quot;, please not that you must use double backslashes, since they are treated as escape characters by Emacs.</source>
          <target state="translated">В .emacs косая черта &quot;/&quot; может быть использована в качестве разделителя путей.Но если вы решили использовать символ обратного слеша &quot;\&quot;,пожалуйста,не используйте двойной обратный слеш,так как Emacs считает его экранирующим символом.</target>
        </trans-unit>
        <trans-unit id="0f7795a31a2f6e68385e615d1e0b39534a4a427f" translate="yes" xml:space="preserve">
          <source>In 1994 the global tagging mode &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; was introduced. By putting &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; in the module header, the ASN.1 compiler automatically adds tags when needed. The following is the same specification in &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; mode:</source>
          <target state="translated">В 1994 году был введен режим глобальной маркировки &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; . Помещая &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; в заголовок модуля, компилятор ASN.1 автоматически добавляет теги при необходимости. Ниже приведены те же характеристики в режиме &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2eae1b23e89f4b197bf1ba45908178d3aa172d8" translate="yes" xml:space="preserve">
          <source>In 8-bit, non-UTF-8 mode, only the characters with code points &amp;lt; 256 are relevant.</source>
          <target state="translated">В 8-битном режиме, отличном от UTF-8, актуальны только символы с кодовыми точками &amp;lt;256.</target>
        </trans-unit>
        <trans-unit id="fcb066c655ce1aa010477f09bef3fac0ead37f56" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under Cygwin/MSYS/MSYS2.</source>
          <target state="translated">В &lt;code&gt;$ERL_TOP&lt;/code&gt; есть сценарий под названием &lt;code&gt;otp_build&lt;/code&gt; . Этот сценарий решает проблему предоставления всех правильных параметров для &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; а также помогает вам настроить правильные переменные среды для работы с источником Erlang в Cygwin / MSYS / MSYS2.</target>
        </trans-unit>
        <trans-unit id="38e9bf33d69940366928f0c1e758698b02736bd6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under WSL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e4870154b4a5f3a6bba7d020678f1436a7aad2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant; the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant; the rest are to be 0. See &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;ID&lt;/code&gt; значимы только 18 бит; остальные должны быть равны 0. В &lt;code&gt;Creation&lt;/code&gt; значимы только два бита; остальные должны быть 0. См. &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0025e78fbaf5c3757dcab01eedc653609a16493" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Mnesia&lt;/code&gt;, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property &lt;code&gt;record_name&lt;/code&gt;, the following code ensures that all records in the tables have the same name as the table:</source>
          <target state="translated">В &lt;code&gt;Mnesia&lt;/code&gt; все записи в таблице должны иметь одно и то же имя. Все записи должны быть экземплярами одного типа записи. Однако имя записи не обязательно должно совпадать с именем таблицы, хотя это так в большинстве примеров в данном Руководстве пользователя. Если таблица создается без свойства &lt;code&gt;record_name&lt;/code&gt; , следующий код гарантирует, что все записи в таблицах будут иметь то же имя, что и таблица:</target>
        </trans-unit>
        <trans-unit id="770b380d53bce026d82e5f70351df3a234e00dd1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Module:Name/Arity&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt;, and &lt;code&gt;Name&lt;/code&gt; are atoms and &lt;code&gt;Arity&lt;/code&gt; is an integer. Starting from Erlang/OTP R15, &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Arity&lt;/code&gt; can also be variables. A fun defined in this way refers to the function &lt;code&gt;Name&lt;/code&gt; with arity &lt;code&gt;Arity&lt;/code&gt; in the &lt;strong&gt;latest&lt;/strong&gt; version of module &lt;code&gt;Module&lt;/code&gt;. A fun defined in this way is not dependent on the code for the module in which it is defined.</source>
          <target state="translated">В &lt;code&gt;Module:Name/Arity&lt;/code&gt; , &lt;code&gt;Module&lt;/code&gt; и &lt;code&gt;Name&lt;/code&gt; - это атомы, а &lt;code&gt;Arity&lt;/code&gt; - целое число. Начиная с Erlang / OTP R15, &lt;code&gt;Module&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; и &lt;code&gt;Arity&lt;/code&gt; также могут быть переменными. Весело , определенные таким образом , относится к функции &lt;code&gt;Name&lt;/code&gt; с валентностью &lt;code&gt;Arity&lt;/code&gt; в &lt;strong&gt;последней&lt;/strong&gt; версии модуля &lt;code&gt;Module&lt;/code&gt; . Развлечение, определенное таким образом, не зависит от кода модуля, в котором оно определено.</target>
        </trans-unit>
        <trans-unit id="e5df66c12eaa68ca0a48283d550d16d991720df0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Name/Arity&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; is an atom and &lt;code&gt;Arity&lt;/code&gt; is an integer. &lt;code&gt;Name/Arity&lt;/code&gt; must specify an existing local function. The expression is syntactic sugar for:</source>
          <target state="translated">В &lt;code&gt;Name/Arity&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; представляет собой атом и &lt;code&gt;Arity&lt;/code&gt; представляет собой целое число. &lt;code&gt;Name/Arity&lt;/code&gt; должны указывать на существующую локальную функцию. Выражение является синтаксическим сахаром для:</target>
        </trans-unit>
        <trans-unit id="943fe69f8dfd82f02ed43163f6738a7b0394f445" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a472768ac00c2b862480bf36de83581f96978047" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Type_List&lt;/code&gt; the &quot;path&quot; from the top type to each undecoded subcomponents is described. The top type of the path is an atom, the name of it. The action on each component/type that follows is described by one of &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;Type_List&lt;/code&gt; описан &amp;laquo;путь&amp;raquo; от верхнего типа к каждому недекодированному подкомпоненту. Верхний тип пути - это атом, его имя. Действие для каждого компонента / типа, которое следует ниже, описывается одним из &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="893648209f7036a7f9ac95fdc3c4a7d64bef1838" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;allocate_heap&lt;/code&gt;, the last operand is the number of live registers. It will only be used if there is not enough heap space and a garbage collection must be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c54988a1f913bda4c57ecea3e6f820b07cee1aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;attr&lt;/code&gt; the attributes of the object are stored as the logical &lt;strong&gt;OR&lt;/strong&gt; of its type (one of &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_BIN&lt;/code&gt;, and &lt;code&gt;EI_STR&lt;/code&gt;), whether it is marked for deletion (&lt;code&gt;EI_DELET&lt;/code&gt;), and whether it has been modified since the last backup to &lt;code&gt;Mnesia&lt;/code&gt; (&lt;code&gt;EI_DIRTY&lt;/code&gt;).</source>
          <target state="translated">В &lt;code&gt;attr&lt;/code&gt; атрибуты объекта хранятся как логическое &lt;strong&gt;ИЛИ&lt;/strong&gt; его типа (один из &lt;code&gt;EI_INT&lt;/code&gt; , &lt;code&gt;EI_FLT&lt;/code&gt; , &lt;code&gt;EI_BIN&lt;/code&gt; и &lt;code&gt;EI_STR&lt;/code&gt; ), отмечен ли он для удаления ( &lt;code&gt;EI_DELET&lt;/code&gt; ) и был ли он изменен с момента последнего резервного копирования на &lt;code&gt;Mnesia&lt;/code&gt; ( &lt;code&gt;EI_DIRTY&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9643419e6aee2e17ffb863a8ef01b8323b347a6e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions are given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">В &lt;code&gt;ch1.erl&lt;/code&gt; выше ch1.erl и &lt;code&gt;ch2.erl&lt;/code&gt; реализация &lt;code&gt;channels/0&lt;/code&gt; , &lt;code&gt;alloc/1&lt;/code&gt; и &lt;code&gt;free/2&lt;/code&gt; была намеренно исключена, так как это не имеет отношения к примеру. Для полноты картины ниже приведен один из способов записи этих функций. Это только пример, реалистичная реализация должна уметь обрабатывать такие ситуации, как нехватка каналов для распределения и т. Д.</target>
        </trans-unit>
        <trans-unit id="27aabe06bd512676435ef4845535c23e8c05bacb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions is given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0d5c626ce8dc42f39e1abeabf7105631919c54" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, parameter &lt;code&gt;s&lt;/code&gt; is to point to a dynamically (malloc) allocated string of &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a &lt;code&gt;NULL&lt;/code&gt; pointer. The string can be reallocated (and &lt;code&gt;*s&lt;/code&gt; can be updated) by this function if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The string returned is &lt;code&gt;NULL&lt;/code&gt;-terminated.</source>
          <target state="translated">В &lt;code&gt;ei_s_print_term()&lt;/code&gt; параметр &lt;code&gt;s&lt;/code&gt; должен указывать на динамически (malloc) выделенную строку байтов &lt;code&gt;BUFSIZ&lt;/code&gt; или указатель &lt;code&gt;NULL&lt;/code&gt; . Эта функция может перераспределить строку (и &lt;code&gt;*s&lt;/code&gt; может быть обновлена), если результат превышает &lt;code&gt;BUFSIZ&lt;/code&gt; символов BUFSIZ . Возвращенная строка завершается &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a141cc5ac15d20e41285b60b7e1dbadddb212ee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;file_logger&lt;/code&gt;:</source>
          <target state="translated">В &lt;code&gt;file_logger&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7fbf17e1fc5bc4462fd00e9068033e131292be59" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;gen_statem&lt;/code&gt; we define a &lt;strong&gt;state change&lt;/strong&gt; as a &lt;strong&gt;state transition&lt;/strong&gt; in which the new state &lt;code&gt;S'&lt;/code&gt; is different from the current state &lt;code&gt;S&lt;/code&gt;, where &quot;different&quot; means Erlang's strict inequality: &lt;code&gt;=/=&lt;/code&gt; also known as &quot;does not match&quot;. &lt;code&gt;gen_statem&lt;/code&gt; does more things during &lt;strong&gt;state changes&lt;/strong&gt; than during other &lt;strong&gt;state transitions&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dd48fe409f725dfa23be2b6d97df3560da702c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;is_eq_exact&lt;/code&gt;, the failure address (the first operand) will only be used if the two register operands are not equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6953b7249dfd9871d1537ea03ef11de631fd526" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, filenames are bytewise encoded. This allows for list representation of all filenames in the system. However, a a file named &quot;&amp;Ouml;stersund.txt&quot;, appears in &lt;code&gt;file:list_dir/1&lt;/code&gt; either as &quot;&amp;Ouml;stersund.txt&quot; (if the filename was encoded in bytewise ISO Latin-1 by the program creating the file) or more probably as &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt;, which is a list containing UTF-8 bytes (not what you want). If you use Unicode filename translation on such a system, non-UTF-8 filenames are ignored by functions like &lt;code&gt;file:list_dir/1&lt;/code&gt;. They can be retrieved with function &lt;code&gt;file:list_dir_all/1&lt;/code&gt;, but wrongly encoded filenames appear as &quot;raw filenames&quot;.</source>
          <target state="translated">В режиме &lt;code&gt;latin1&lt;/code&gt; имена файлов кодируются побайтно. Это позволяет представить список всех имен файлов в системе. Однако файл с именем &amp;laquo;&amp;Ouml;stersund.txt&amp;raquo; отображается в &lt;code&gt;file:list_dir/1&lt;/code&gt; либо как &amp;laquo;&amp;Ouml;stersund.txt&amp;raquo; (если имя файла было закодировано побайтно в ISO Latin-1 программой, создавшей файл), либо, что более вероятно, как &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt; , который представляет собой список, содержащий байты UTF-8 (не то, что вам нужно). Если вы используете перевод имен файлов в Юникоде в такой системе, имена файлов, отличных от UTF-8, игнорируются такими функциями, как &lt;code&gt;file:list_dir/1&lt;/code&gt; . Их можно получить с помощью функции &lt;code&gt;file:list_dir_all/1&lt;/code&gt; , но неправильно закодированные имена файлов отображаются как &amp;laquo;сырые имена файлов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="116bd7f6b497e889e6e51bc1f52782d94cab61ab" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, the Erlang VM does not change the encoding of filenames. In &lt;code&gt;utf8&lt;/code&gt; mode, filenames can contain Unicode characters greater than 255 and the VM converts filenames back and forth to the native filename encoding (usually UTF-8, but UTF-16 on Windows).</source>
          <target state="translated">В режиме &lt;code&gt;latin1&lt;/code&gt; виртуальная машина Erlang не изменяет кодировку имен файлов. В режиме &lt;code&gt;utf8&lt;/code&gt; имена файлов могут содержать символы Unicode, превышающие 255, и виртуальная машина преобразует имена файлов в исходную кодировку файлов (обычно UTF-8, но UTF-16 в Windows).</target>
        </trans-unit>
        <trans-unit id="efaf4d06886c110e8f2a1c0d7f556c6c220cdc32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;list_max/2&lt;/code&gt;, you walk down the list and use &lt;code&gt;Head&lt;/code&gt; instead of &lt;code&gt;Result_so_far&lt;/code&gt; when &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;when&lt;/code&gt; is a special word used before the -&amp;gt; in the function to say that you only use this part of the function if the test that follows is true. A test of this type is called &lt;strong&gt;guard&lt;/strong&gt;. If the guard is false (that is, the guard fails), the next part of the function is tried. In this case, if &lt;code&gt;Head&lt;/code&gt; is not greater than &lt;code&gt;Result_so_far&lt;/code&gt;, then it must be smaller or equal to it. This means that a guard on the next part of the function is not needed.</source>
          <target state="translated">В &lt;code&gt;list_max/2&lt;/code&gt; вы проходите по списку и используете &lt;code&gt;Head&lt;/code&gt; вместо &lt;code&gt;Result_so_far&lt;/code&gt; , когда &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt; . &lt;code&gt;when&lt;/code&gt; - это специальное слово, используемое перед знаком -&amp;gt; в функции, чтобы сказать, что вы используете эту часть функции, только если следующий тест верен. Тест такого типа называется &lt;strong&gt;охранником&lt;/strong&gt; . Если защита ложна (то есть защита не работает), выполняется попытка следующей части функции. В этом случае, если &lt;code&gt;Head&lt;/code&gt; не больше &lt;code&gt;Result_so_far&lt;/code&gt; , то он должен быть меньше или равен ему. Это означает, что защита следующей части функции не нужна.</target>
        </trans-unit>
        <trans-unit id="5487ffcf59e4dcb4dda76a98d92b6b90dc718bb3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;macros.tab&lt;/code&gt;, there is a definition of &lt;code&gt;GC_REGEXP&lt;/code&gt;. It will be described in &lt;code&gt;&lt;a href=&quot;#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition&quot;&gt;a later section&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cb096eaff82424f4a89dbad61cc6a39bc0e575" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sort&lt;/code&gt; the fun is used:</source>
          <target state="translated">При &lt;code&gt;sort&lt;/code&gt; используется веселье:</target>
        </trans-unit>
        <trans-unit id="12c27e7f6632f170be6359162707f4b8a39d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;terminal_logger&lt;/code&gt;:</source>
          <target state="translated">В &lt;code&gt;terminal_logger&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bbd6fe570f64e2ea4d9df82e02a34c966281d919" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;unicode&lt;/code&gt; mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &amp;gt; 127) are treated as literals.</source>
          <target state="translated">В режиме &lt;code&gt;unicode&lt;/code&gt; только цифры и буквы ASCII имеют особое значение после обратной косой черты. Все остальные символы (в частности, те, чей код&amp;gt; 127) обрабатываются как литералы.</target>
        </trans-unit>
        <trans-unit id="3192c3cf3b67f79505ca334fb569ea62ed1d48cb" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and check the authenticity the &lt;code&gt;PlainText&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) using the &lt;code&gt;CipherTag&lt;/code&gt;. May return &lt;code&gt;error&lt;/code&gt; if the decryption or validation fail's</source>
          <target state="translated">В режиме AEAD (аутентифицированное шифрование со связанными данными) расшифруйте &lt;code&gt;CipherText&lt;/code&gt; в соответствии с блочным шифром &lt;code&gt;Type&lt;/code&gt; и проверьте подлинность &lt;code&gt;PlainText&lt;/code&gt; и &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) с помощью &lt;code&gt;CipherTag&lt;/code&gt; . Может возвращать &lt;code&gt;error&lt;/code&gt; если расшифровка или проверка завершились неудачно.</target>
        </trans-unit>
        <trans-unit id="11cacd0985503ba6b7aa7e02c729d4cf5d9ec8c0" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and calculate &lt;code&gt;CipherTag&lt;/code&gt; that also authenticates the &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data).</source>
          <target state="translated">В режиме AEAD (аутентифицированное шифрование со связанными данными) &lt;code&gt;CipherTag&lt;/code&gt; &lt;code&gt;PlainText&lt;/code&gt; в соответствии с блочным шифром &lt;code&gt;Type&lt;/code&gt; и вычислите CipherTag, который также аутентифицирует &lt;code&gt;AAD&lt;/code&gt; (связанные аутентифицированные данные).</target>
        </trans-unit>
        <trans-unit id="c038f0a7011f32aa3c2253ea59f81adb573ae04f" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is also possible to have components that are themselves structured types. For example, it is possible to have the following:</source>
          <target state="translated">В ASN.1 можно также иметь компоненты,которые сами по себе являются структурированными типами.Например,можно иметь следующее:</target>
        </trans-unit>
        <trans-unit id="1fd6892220150bfbf692aea6c817cdbc6b525af4" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is possible to have:</source>
          <target state="translated">В ASN.1 это возможно:</target>
        </trans-unit>
        <trans-unit id="ac981922e3d2be3099b7dd819f976f8cd431aa5c" translate="yes" xml:space="preserve">
          <source>In ASN.1, &lt;code&gt;BIT STRING&lt;/code&gt; definitions can look as follows:</source>
          <target state="translated">В ASN.1 определения &lt;code&gt;BIT STRING&lt;/code&gt; могут выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="e4c809e7fa181f22943bb3998e2675cc28fadeb7" translate="yes" xml:space="preserve">
          <source>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</source>
          <target state="translated">В Приложении А спецификации Megaco/H.248 (RFC 3525)имеется около 30 сообщений,показывающих репрезентативный поток вызовов.Мы также добавили несколько дополнительных сообщений версии 1,версии 2 и версии 3.Мы использовали эти сообщения в качестве основы для наших измерений.Наши данные не были взвешены в отношении того,как часто передаются различные типы сообщений между медиа-шлюзом и его контроллером.</target>
        </trans-unit>
        <trans-unit id="a6d6cb54546267c7ab63766eec09cee649711a31" translate="yes" xml:space="preserve">
          <source>In Erlang code it can look as follows:</source>
          <target state="translated">В коде Эрланга это может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="aba42f54367f97fea68495b7cac79db5d13869f6" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt; erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt; erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5807093e6d87fdc7a49890d975be36f4a0da6c" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">В Erlang BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; используется для преобразования термина во внешний формат. Чтобы преобразовать кодировку двоичных данных в термин, используется BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfeed77756208eb4d9dfb0d9a3e58ff900cc5da1" translate="yes" xml:space="preserve">
          <source>In Erlang the following can apply:</source>
          <target state="translated">В Эрланге может применяться следующее:</target>
        </trans-unit>
        <trans-unit id="55425998bade0d03c70bf896550329d58b5b495b" translate="yes" xml:space="preserve">
          <source>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</source>
          <target state="translated">В Erlang,Бин используется для построения двоичных файлов и сопоставления двоичных шаблонов.Мусорное ведро написано со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="27260c403bb29fda2001d4a6be0835230872a64b" translate="yes" xml:space="preserve">
          <source>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is, code point by code point, a subrange of the Unicode character set.</source>
          <target state="translated">В Эрланге строки представляют собой списки целых чисел.Строка была до тех пор,пока Erlang/OTP R13 не был определен как кодируемый в наборе символов ISO Latin-1 (ISO 8859-1),т.е.точка за точкой кода,поддиапазон набора символов Юникода.</target>
        </trans-unit>
        <trans-unit id="000d471cb67467678d1ade49d91a91cbdff773ac" translate="yes" xml:space="preserve">
          <source>In Erlang, the &lt;code&gt;SET&lt;/code&gt; type is used exactly as &lt;code&gt;SEQUENCE&lt;/code&gt;. Notice that if BER or DER encoding rules are used, decoding a &lt;code&gt;SET&lt;/code&gt; is slower than decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; because the components must be sorted.</source>
          <target state="translated">В Erlang тип &lt;code&gt;SET&lt;/code&gt; используется точно так же, как &lt;code&gt;SEQUENCE&lt;/code&gt; . Обратите внимание, что если используются правила кодирования BER или DER, декодирование &lt;code&gt;SET&lt;/code&gt; происходит медленнее, чем декодирование &lt;code&gt;SEQUENCE&lt;/code&gt; , поскольку компоненты должны быть отсортированы.</target>
        </trans-unit>
        <trans-unit id="111866cd1ba49a2b43af4850505bc155722873f8" translate="yes" xml:space="preserve">
          <source>In Erlang, the full UTF-16 range is supported when applicable, like in the &lt;code&gt;unicode&lt;/code&gt; module and in the bit syntax.</source>
          <target state="translated">В Erlang при необходимости поддерживается полный диапазон UTF-16, например, в модуле &lt;code&gt;unicode&lt;/code&gt; и в битовом синтаксисе.</target>
        </trans-unit>
        <trans-unit id="2a7efb592ded3e962f361d6c4ea93e492befd66f" translate="yes" xml:space="preserve">
          <source>In Erlang, there is no interface to retrieve a mark with &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt;, so only the secondary purpose is relevant to the Erlang programmer.</source>
          <target state="translated">В Erlang нет интерфейса для получения метки с &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; , поэтому для программиста Erlang важна только вторичная цель.</target>
        </trans-unit>
        <trans-unit id="2c60f9a05486134b501e5953f76c349e506d6f0f" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched to UTF-8.</source>
          <target state="translated">В Erlang/OTP 17.0 кодировка по умолчанию для исходных файлов Erlang была переключена на UTF-8.</target>
        </trans-unit>
        <trans-unit id="6916e39092e66107b55f61baa3016b3f04cf8426" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module names, application names, and node names are still restricted to the ISO Latin-1 range.</source>
          <target state="translated">В Erlang/OTP 20.0 атомы и функции могут содержать символы Юникода.Имена модулей,названия приложений и узлов все еще ограничены диапазоном ISO Latin-1.</target>
        </trans-unit>
        <trans-unit id="198d0d1078d6039827840866a4f6899fdbe8d43c" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 21.0, a new API for logging was added. The old &lt;code&gt;error_logger&lt;/code&gt; module can still be used by legacy code, but log events are redirected to the new Logger API. New code should use the Logger API directly.</source>
          <target state="translated">В Erlang / OTP 21.0 был добавлен новый API для ведения журнала. Старый модуль &lt;code&gt;error_logger&lt;/code&gt; все еще может использоваться устаревшим кодом, но события журнала перенаправляются в новый API Logger. Новый код должен напрямую использовать Logger API.</target>
        </trans-unit>
        <trans-unit id="e0d8b8d2cdbb6065786dcebb0086f01cf068b155" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R16B the syntax of Erlang tokens was extended to handle Unicode. The support was limited to string literals and comments. More about the usage of Unicode in Erlang source files can be found in &lt;code&gt;STDLIB's User's Guide&lt;/code&gt;.</source>
          <target state="translated">В Erlang / OTP R16B синтаксис токенов Erlang был расширен для обработки Unicode. Поддержка ограничивалась строковыми литералами и комментариями. Подробнее об использовании Unicode в исходных файлах Erlang можно найти в &lt;code&gt;STDLIB's User's Guide&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ca06e1e4890e17adbf7557eee37d1f56256f49" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_Interface application (3.2.1 in the recent example).</source>
          <target state="translated">В Erlang / OTP R5B и более поздних версиях OTP каталоги &lt;code&gt;include&lt;/code&gt; и &lt;code&gt;lib&lt;/code&gt; расположены в &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; , где &lt;code&gt;OTPROOT&lt;/code&gt; - это корневой каталог установки OTP ( &lt;code&gt;/usr/local/otp&lt;/code&gt; в последнем примере) и &lt;code&gt;VSN&lt;/code&gt; - это версия приложения Erl_Interface (3.2.1 в недавнем примере).</target>
        </trans-unit>
        <trans-unit id="36bdb9cf8a7d0b24c3ea497881807594aa4ad9c3" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_interface application (3.2.1 in the recent example).</source>
          <target state="translated">В Erlang / OTP R5B и более поздних версиях OTP каталоги &lt;code&gt;include&lt;/code&gt; и &lt;code&gt;lib&lt;/code&gt; расположены в &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; , где &lt;code&gt;OTPROOT&lt;/code&gt; - это корневой каталог установки OTP ( &lt;code&gt;/usr/local/otp&lt;/code&gt; в последнем примере) и &lt;code&gt;VSN&lt;/code&gt; - это версия приложения Erl_interface (3.2.1 в недавнем примере).</target>
        </trans-unit>
        <trans-unit id="e2c46173457c64237f426cb5d2c876573b902705" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R6B, a library similar to Erl_Interface for Java was added called &lt;strong&gt;jinterface&lt;/strong&gt;. It provides a tool for Java programs to communicate with Erlang nodes.</source>
          <target state="translated">В Erlang / OTP R6B была добавлена ​​библиотека, похожая на Erl_Interface для Java, под названием &lt;strong&gt;jinterface&lt;/strong&gt; . Он предоставляет программам на Java инструмент для связи с узлами Erlang.</target>
        </trans-unit>
        <trans-unit id="1be37b0c5d13632dad76da8a59a995e7c35b67e8" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP SSH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e5f8580820830244cd23f79a16074f3a89cc2a" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules &lt;code&gt;gen_tcp&lt;/code&gt; and &lt;code&gt;gen_udp&lt;/code&gt; in Kernel. Both are easy to use and do not require detailed knowledge about the socket concept.</source>
          <target state="translated">В Erlang / OTP доступ к &lt;code&gt;gen_tcp&lt;/code&gt; TCP / IP и UDP обеспечивается модулями gen_tcp и &lt;code&gt;gen_udp&lt;/code&gt; в ядре. Оба они просты в использовании и не требуют подробных знаний о концепции сокетов.</target>
        </trans-unit>
        <trans-unit id="d098b9b5017423de630d21112a6b6fdc9450e7b2" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception &lt;code&gt;error:notsup&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a321356801dc3e599cf50b6af4d5dd7265663386" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and throw exception &lt;code&gt;not_supported&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">В режиме FIPS все алгоритмы, несовместимые с FIPS, отключены и &lt;code&gt;not_supported&lt;/code&gt; исключение not_supported . Проверка &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; то, что в режиме FIPS возвращает ограниченный список доступных алгоритмов.</target>
        </trans-unit>
        <trans-unit id="9654a53fa988a8beebddaefffba6dff20182607b" translate="yes" xml:space="preserve">
          <source>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</source>
          <target state="translated">В режиме FIPS отключены непроверенные алгоритмы.Это может привести к неожиданным проблемам в приложении,полагающемся на криптографию.</target>
        </trans-unit>
        <trans-unit id="cfd282a1087eca416799317762a7b472853e3b7b" translate="yes" xml:space="preserve">
          <source>In German, the letter &quot;&amp;szlig;&quot; (sharp s) is in lower case, but the uppercase equivalent is &quot;SS&quot;.</source>
          <target state="translated">В немецком языке буква &amp;laquo;&amp;szlig;&amp;raquo; (диез) пишется в нижнем регистре, но ее эквивалент в верхнем регистре - &amp;laquo;SS&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b43a09972d3f89ca539f6f835ed50cfae17cb115" translate="yes" xml:space="preserve">
          <source>In Greek, the letter &quot;&amp;Sigma;&quot; has two different lowercase forms, &quot;&amp;sigmaf;&quot; in word-final position and &quot;&amp;sigma;&quot; elsewhere.</source>
          <target state="translated">В греческом языке буква &amp;laquo;&amp;Sigma;&amp;raquo; имеет две разные строчные формы: &amp;laquo;&amp;sigmaf;&amp;raquo; в конце слова и &amp;laquo;&amp;sigma;&amp;raquo; в другом месте.</target>
        </trans-unit>
        <trans-unit id="dbc72349c6922ca4db9e6cdf6ae70618450c536a" translate="yes" xml:space="preserve">
          <source>In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; Module:callback_mode/0 &lt;/a&gt;&lt;/code&gt; was introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e33a7d9a961a4a7fa95fde9918750cd7d701cd7" translate="yes" xml:space="preserve">
          <source>In OTP 20 it is desirable to remove all cipher suites that uses rsa kexchange (removed from default in 21)</source>
          <target state="translated">В OTP 20 желательно удалить все наборы шифров,использующие rsa kexchange (удалено из списка по умолчанию в 21)</target>
        </trans-unit>
        <trans-unit id="7d0e8cf6bf94176944af04a938b90942b47513e4" translate="yes" xml:space="preserve">
          <source>In OTP 20.0 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt; generic time-outs &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e2f6c474b1b1d220a10a173940715aea514162" translate="yes" xml:space="preserve">
          <source>In OTP 22.1 time-out content &lt;code&gt;&lt;a href=&quot;#type-timeout_update_action&quot;&gt; update &lt;/a&gt;&lt;/code&gt; and explicit time-out &lt;code&gt;&lt;a href=&quot;#type-timeout_cancel_action&quot;&gt; cancel &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622615c8bd1e5f7d554b06396b647aa8c7919009" translate="yes" xml:space="preserve">
          <source>In OTP 22.3 the possibility to change the callback module with actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, was added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dd0ef79035e7eb69969f59887721bb5f12a900" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All pids are now encoded using &lt;code&gt;NEW_PID_EXT&lt;/code&gt;, even external pids received as &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d163fad14d17015b8103733844b0e3f38ec8db" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All ports are now encoded using &lt;code&gt;NEW_PORT_EXT&lt;/code&gt;, even external ports received as &lt;code&gt;&lt;a href=&quot;#PORT_EXT&quot;&gt;PORT_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5fb5345ccfcb78e9b4e7ee07de85592dd8a9f4" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All references are now encoded using &lt;code&gt;NEWER_REFERENCE_EXT&lt;/code&gt;, even external references received as &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3265c64793aa53ad0a1577895b26f55843cba1fb" translate="yes" xml:space="preserve">
          <source>In OTP R16, modules are loaded without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire load operation. The code loading is carried out by a normal Erlang process that is scheduled like all the others. The load operation is completed by making the loaded code visible to all processes in a consistent way with one single atomic instruction. Non-blocking code loading will improve real-time characteristics when modules are loaded/upgraded on a running SMP system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e0125ea56af5dfd2fd2fd039ae24bfa32ef473" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, &lt;code&gt;uper&lt;/code&gt; or &lt;code&gt;jer&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8d7cdc42675f7eb3ae5329539c1c0357e28904" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, or &lt;code&gt;uper&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">В OTP R16 параметры были упрощены. &lt;code&gt;uper&lt;/code&gt; часть выбирается с помощью одного из вариантов: &lt;code&gt;ber&lt;/code&gt; , &lt;code&gt;per&lt;/code&gt; или uper . Параметры &lt;code&gt;optimize&lt;/code&gt; , &lt;code&gt;nif&lt;/code&gt; и параметры &lt;code&gt;driver&lt;/code&gt; больше не нужны (и компилятор ASN.1 выдает предупреждение, если они используются). Опции Опции &lt;code&gt;ber_bin&lt;/code&gt; , &lt;code&gt;per_bin&lt;/code&gt; и &lt;code&gt;uper_bin&lt;/code&gt; по- прежнему работают, но генерируют предупреждение.</target>
        </trans-unit>
        <trans-unit id="7beb2f37419ff75d8af6c1507fb66b318ae63c2b" translate="yes" xml:space="preserve">
          <source>In OTP R16, trace breakpoints are set in the code without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire operation. The same base technique is used as for code loading. A staging area of breakpoints is prepared and then made active with a single atomic operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d070e27ec63b672cbbc0cd22453c8a0bbd814f44" translate="yes" xml:space="preserve">
          <source>In OTP releases before R9C, the abstract code after some more processing was stored in the Beam file. The first element of the tuple would be either &lt;code&gt;abstract_v1&lt;/code&gt; (in OTP R7B) or &lt;code&gt;abstract_v2&lt;/code&gt; (in OTP R8B).</source>
          <target state="translated">В выпусках OTP до R9C абстрактный код после некоторой дополнительной обработки сохранялся в файле Beam. Первым элементом кортежа может быть &lt;code&gt;abstract_v1&lt;/code&gt; (в OTP R7B) или &lt;code&gt;abstract_v2&lt;/code&gt; (в OTP R8B).</target>
        </trans-unit>
        <trans-unit id="921af396e8f5461445f280e270dd2b5414708d3b" translate="yes" xml:space="preserve">
          <source>In OTP, &lt;strong&gt;application&lt;/strong&gt; denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with &lt;strong&gt;application controller&lt;/strong&gt;, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</source>
          <target state="translated">В OTP &lt;strong&gt;приложение&lt;/strong&gt; обозначает компонент, реализующий определенные функции, который можно запускать и останавливать как единое целое и который можно повторно использовать в других системах. Этот модуль взаимодействует с &lt;strong&gt;контроллером приложения&lt;/strong&gt; , процесс запускается в каждой исполняющей системе Erlang. Этот модуль содержит функции для управления приложениями (например, запуск и остановка приложений) и функции для доступа к информации о приложениях (например, параметры конфигурации).</target>
        </trans-unit>
        <trans-unit id="eca3632f8a0f156b49e9fa89891e0ee96a189926" translate="yes" xml:space="preserve">
          <source>In OTP, an &lt;strong&gt;event manager&lt;/strong&gt; is a named object to which events can be sent. An &lt;strong&gt;event&lt;/strong&gt; can be, for example, an error, an alarm, or some information that is to be logged.</source>
          <target state="translated">В OTP &lt;strong&gt;диспетчер событий&lt;/strong&gt; - это именованный объект, на который можно отправлять события. &lt;strong&gt;Событие&lt;/strong&gt; может быть, например, ошибка, тревога, или некоторая информация , которая должна быть авторизованы.</target>
        </trans-unit>
        <trans-unit id="457a0e3d6ddd599be8d5102b7c849920a5dc095d" translate="yes" xml:space="preserve">
          <source>In OTP-21 the default primary log level is &lt;code&gt;notice&lt;/code&gt;. The means that many log messages are by default not printed. This includes the progress reports of supervisors. In order to get progress reports you need to raise the primary log level to &lt;code&gt;info&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d287ac5001b044c81427ccf014f3ddfd35b4ee5b" translate="yes" xml:space="preserve">
          <source>In OpenSSH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90aedd16eab7e90ca5158413abefdf208107564" translate="yes" xml:space="preserve">
          <source>In PCRE, a subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number.</source>
          <target state="translated">В PCRE подшаблон может быть назван одним из трех способов: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; или &lt;code&gt;(?'name'...)&lt;/code&gt; как в Perl, или &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; как в Python. Ссылки на захват круглых скобок из других частей шаблона, таких как обратные ссылки, рекурсия и условия, могут быть сделаны по имени и по номеру.</target>
        </trans-unit>
        <trans-unit id="256aeea3c9968f0c93cc31456d90fd25ae389948" translate="yes" xml:space="preserve">
          <source>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value.</source>
          <target state="translated">В ПЦРЕ это совпадает с &quot;баб&quot;.Первые захватывающие скобки соответствуют букве &quot;b&quot;,затем во второй группе,когда обратная ссылка \1 не соответствует букве &quot;b&quot;,вторая альтернатива соответствует букве &quot;a&quot;,а затем возвращается.В рекурсии \1 теперь совпадает с буквой &quot;b&quot;,и таким образом все совпадение удается.В Perl шаблон не совпадает,потому что внутри рекурсивного вызова \1 не может получить доступ к внешнему значению.</target>
        </trans-unit>
        <trans-unit id="1bdbe179924ece7a6399c61e126213e1ec2fdb03" translate="yes" xml:space="preserve">
          <source>In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.</source>
          <target state="translated">В Perl последовательности \l,\L,\u и \U распознаются его обработчиком строк и используются для изменения регистра следующих символов.PCRE не поддерживает эти экранирующие последовательности.</target>
        </trans-unit>
        <trans-unit id="6c9f67deea2c96d4c87a2b517cca3a419aaafb51" translate="yes" xml:space="preserve">
          <source>In R4B and earlier versions of OTP, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are situated under &lt;code&gt;OTPROOT/usr&lt;/code&gt;.</source>
          <target state="translated">В R4B и более ранних версиях OTP &lt;code&gt;include&lt;/code&gt; и &lt;code&gt;lib&lt;/code&gt; находятся в &lt;code&gt;OTPROOT/usr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3afab8c285c30f15c650612a9e9a18aec7d293" translate="yes" xml:space="preserve">
          <source>In SNMP, the &lt;code&gt;set&lt;/code&gt; operation is atomic. Either all variables which are specified in a &lt;code&gt;set&lt;/code&gt; operation are changed, or none are changed. Therefore, the &lt;code&gt;set&lt;/code&gt; operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked:</source>
          <target state="translated">В SNMP операция &lt;code&gt;set&lt;/code&gt; является атомарной. Либо все переменные, которые указаны в операции &lt;code&gt;set&lt;/code&gt; , изменяются, либо ни одна не изменяется. Таким образом, &lt;code&gt;set&lt;/code&gt; делится на два этапа. На первом этапе новое значение каждой переменной проверяется на соответствие определению переменной в MIB. Проверяются следующие определения:</target>
        </trans-unit>
        <trans-unit id="021a1af44ce27aa9f05d1c38410af20ca7b60806" translate="yes" xml:space="preserve">
          <source>In SNMPv1 and SNMPv2c, the community string in the message was used for (at least) three different purposes:</source>
          <target state="translated">В SNMPv1 и SNMPv2c строка сообщества в сообщении использовалась как минимум для трех различных целей:</target>
        </trans-unit>
        <trans-unit id="02cb323587a2984dde2a87bd71f9d85e1a736a34" translate="yes" xml:space="preserve">
          <source>In SNMPv3, each of these usage areas has its own unique mechanism. A context is identified by the name of the SNMP entity, &lt;code&gt;contextEngineID&lt;/code&gt;, and the name of the context, &lt;code&gt;contextName&lt;/code&gt;. Each SNMPv3 message contains values for these two parameters.</source>
          <target state="translated">В SNMPv3 каждая из этих областей использования имеет свой уникальный механизм. Контекст идентифицируется по имени объекта SNMP &lt;code&gt;contextEngineID&lt;/code&gt; и имени контекста &lt;code&gt;contextName&lt;/code&gt; . Каждое сообщение SNMPv3 содержит значения этих двух параметров.</target>
        </trans-unit>
        <trans-unit id="c5e1bb8d75f3351aa564c900b00a6b87a8524ac7" translate="yes" xml:space="preserve">
          <source>In TLS 1.3 the session reuse is replaced by a new session tickets mechanism based on the pre shared key concept. This mechanism also obsoletes the session tickets from RFC5077, not implemented by this application. See also &lt;code&gt;Session Tickets and Session Resumption in TLS-1.3 &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5895f59f593a11e2ddc456b6ee6229093c87afb4" translate="yes" xml:space="preserve">
          <source>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case forms.</source>
          <target state="translated">В турецком языке в формах нижнего и верхнего регистра существуют как пунктирные,так и безточечные &quot;i&quot;.</target>
        </trans-unit>
        <trans-unit id="878884e2dc7ceb0c8586c874280425307fca0f37" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values &amp;gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.</source>
          <target state="translated">В режиме UTF-8 символы со значениями&amp;gt; 255 (0xffff) могут быть включены в класс как буквальная строка единиц данных или с помощью механизма экранирования \ x {.</target>
        </trans-unit>
        <trans-unit id="0723db02fb1375caa6de0f6695a31f67e99a568d" translate="yes" xml:space="preserve">
          <source>In Unicode filename mode, filenames given to BIF &lt;code&gt;open_port/2&lt;/code&gt; with option &lt;code&gt;{spawn_executable,...}&lt;/code&gt; are also interpreted as Unicode. So is the parameter list specified in option &lt;code&gt;args&lt;/code&gt; available when using &lt;code&gt;spawn_executable&lt;/code&gt;. The UTF-8 translation of arguments can be avoided using binaries, see section &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В режиме имени файла Unicode имена файлов, заданные BIF &lt;code&gt;open_port/2&lt;/code&gt; с опцией &lt;code&gt;{spawn_executable,...}&lt;/code&gt; , также интерпретируются как Unicode. Таким образом, список параметров, указанный в параметрах &lt;code&gt;args&lt;/code&gt; , доступен при использовании &lt;code&gt;spawn_executable&lt;/code&gt; . Преобразования аргументов в кодировку UTF-8 можно избежать, используя двоичные файлы, см. Раздел &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt; файлов .</target>
        </trans-unit>
        <trans-unit id="19f2c130abf603c133bbd0f5a1747bb0969bbb8c" translate="yes" xml:space="preserve">
          <source>In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).</source>
          <target state="translated">В режиме Юникода квантификаторы применяются к символам,а не к отдельным единицам данных.Так,например,\x{100}{2}соответствует двум символам,каждый из которых представлен 2-байтовой последовательностью в строке UTF-8.Аналогично,\X{3}соответствует трем юникодовым расширенным графемным кластерам,каждый из которых может быть длиной в несколько единиц данных (и они могут иметь разную длину).</target>
        </trans-unit>
        <trans-unit id="a58382bb2f1e4ec5560be47f72bd53dd8fd73e07" translate="yes" xml:space="preserve">
          <source>In Unicode mode, two more characters whose code points are &amp;gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.</source>
          <target state="translated">В режиме Unicode добавляются еще два символа с кодовыми точками&amp;gt; 255: LS (разделитель строк, U + 2028) и PS (разделитель абзацев, U + 2029). Для распознавания этих символов не требуется поддержка свойств символов Unicode.</target>
        </trans-unit>
        <trans-unit id="b9bcf8117b716659d525a533ec0fd6a684678ba1" translate="yes" xml:space="preserve">
          <source>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</source>
          <target state="translated">В Windows все разделители каталогов-это прямые косые черты,а буква диска-строчная.</target>
        </trans-unit>
        <trans-unit id="ad12d1518ecf9a65e8a75f2907c07a876915311c" translate="yes" xml:space="preserve">
          <source>In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В Windows все функции возвращают имена файлов только с косой чертой, даже если аргументы содержат обратную косую черту. Чтобы нормализовать имя файла, удалив избыточные разделители каталогов, используйте &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef00d820ea8134fdb18c86e4ae50113bc762dcc" translate="yes" xml:space="preserve">
          <source>In a .config file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd45d713b47049d2ce36151c1dc290fc396f5a95" translate="yes" xml:space="preserve">
          <source>In a CTH, behavior can be hooked in after the following functions:</source>
          <target state="translated">В КТГ поведение может быть подключено после следующих функций:</target>
        </trans-unit>
        <trans-unit id="0a4189b805358c6e1539d1f92304f2c6381b6deb" translate="yes" xml:space="preserve">
          <source>In a CTH, the behavior can be hooked in before the following functions:</source>
          <target state="translated">В КТГ поведение может быть подключено перед следующими функциями:</target>
        </trans-unit>
        <trans-unit id="effbd836389d7d8b463c9fd530b435aef42b51ae" translate="yes" xml:space="preserve">
          <source>In a KDE environment, select &lt;strong&gt;KDE Control Center (Personal Settings)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Accessibility&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard Layout&lt;/strong&gt;.</source>
          <target state="translated">В среде KDE выберите &lt;strong&gt;Центр управления KDE (Персональные настройки)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Региональные стандарты и специальные возможности&lt;/strong&gt; &amp;gt; &lt;strong&gt;Раскладка клавиатуры&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff429dd35571b630c89a291b69ebf06abbcfc55" translate="yes" xml:space="preserve">
          <source>In a Supervision Tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bc2d5f0d660142d0d63fc0df9ecd908613840a" translate="yes" xml:space="preserve">
          <source>In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and \R escapes, which can match different numbers of data units, are not permitted either.</source>
          <target state="translated">В UTF-режиме PCRE не допускает появления в утверждениях lookbehind экранирования \C (которое совпадает с единичным блоком данных даже в UTF-режиме),так как это делает невозможным вычисление длины lookbehind.Экраны \X и \R,которые могут совпадать с разным количеством единиц данных,также не разрешены.</target>
        </trans-unit>
        <trans-unit id="2c87d0f65600acbab54733adb07b3f71b63b4920" translate="yes" xml:space="preserve">
          <source>In a Unix (Bourne) shell, it can look as follows (line breaks are for readability, they are not to be there when typed):</source>
          <target state="translated">В оболочке Unix (Bourne)она может выглядеть следующим образом (разрывы строк предназначены для удобочитаемости,их не должно быть при наборе):</target>
        </trans-unit>
        <trans-unit id="9d1062a9134da719f643aea0a4d7fbb853ab2580" translate="yes" xml:space="preserve">
          <source>In a black-box testing scenario, &lt;code&gt;Common Test&lt;/code&gt;-based test programs connect to the target system(s) through standard O&amp;amp;M and CLI protocols. &lt;code&gt;Common Test&lt;/code&gt; provides implementations of, and wrapper interfaces to, some of these protocols (most of which exist as standalone components and applications in OTP). The wrappers simplify configuration and add verbosity for logging purposes. &lt;code&gt;Common Test&lt;/code&gt; is continously extended with useful support modules. However, notice that it is a straightforward task to use any Erlang/OTP component for testing purposes with &lt;code&gt;Common Test&lt;/code&gt;, without needing a &lt;code&gt;Common Test&lt;/code&gt; wrapper for it. It is as simple as calling Erlang functions. A number of target-independent interfaces are supported in &lt;code&gt;Common Test&lt;/code&gt;, such as Generic Telnet and FTP. These can be specialized or used directly for controlling instruments, traffic load generators, and so on.</source>
          <target state="translated">В сценарии тестирования &amp;laquo;черный ящик&amp;raquo; программы тестирования на основе &lt;code&gt;Common Test&lt;/code&gt; подключаются к целевой системе (ам) через стандартные протоколы O&amp;amp;M и CLI. &lt;code&gt;Common Test&lt;/code&gt; предоставляет реализации и интерфейсы-оболочки для некоторых из этих протоколов (большинство из которых существует как отдельные компоненты и приложения в OTP). Оболочки упрощают настройку и добавляют подробности для ведения журнала. &lt;code&gt;Common Test&lt;/code&gt; постоянно расширяется полезными модулями поддержки. Однако обратите внимание, что использовать любой компонент Erlang / OTP для тестирования с помощью &lt;code&gt;Common Test&lt;/code&gt; - несложная задача , без необходимости в оболочке &lt;code&gt;Common Test&lt;/code&gt; для этого. Это так же просто, как вызов функций Erlang. Несколько целевых независимых интерфейсов поддерживаются в &lt;code&gt;Common Test&lt;/code&gt; , такой как Generic Telnet и FTP. Они могут быть специализированными или использоваться непосредственно для управления приборами, генераторами нагрузки трафика и т. Д.</target>
        </trans-unit>
        <trans-unit id="c1500508d272e3e1ef6dd2792fe28503800aeebb" translate="yes" xml:space="preserve">
          <source>In a callback module:</source>
          <target state="translated">В модуле обратного вызова:</target>
        </trans-unit>
        <trans-unit id="87ab655f4b96d81d49f137e06e1185ae6b220c3d" translate="yes" xml:space="preserve">
          <source>In a debug-compiled emulator, &lt;code&gt;ASSERT(VALID_INSTR(next_pf));&lt;/code&gt; makes sure that &lt;code&gt;next_pf&lt;/code&gt; is a valid instruction (that is, that it points within the &lt;code&gt;process_main()&lt;/code&gt; function in &lt;code&gt;beam_emu.c&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b8b640abb829ff4cbfb271a5e40f88ec8ec137" translate="yes" xml:space="preserve">
          <source>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a &lt;strong&gt;hidden node&lt;/strong&gt; can be used.</source>
          <target state="translated">В распределенной системе Erlang иногда полезно подключиться к узлу, не подключаясь также ко всем остальным узлам. Примером может служить какая-то функция O&amp;amp;M, используемая для проверки состояния системы, не нарушая ее. Для этого можно использовать &lt;strong&gt;скрытый узел&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4aec9cfbd2b5a5b825d96878372130aac2263b76" translate="yes" xml:space="preserve">
          <source>In a distributed system with several Erlang nodes, it can be necessary to control applications in a distributed manner. If the node, where a certain application is running, goes down, the application is to be restarted at another node.</source>
          <target state="translated">В распределенной системе с несколькими узлами Erlang может потребоваться управление приложениями распределенным образом.Если узел,на котором запущено определенное приложение,падает,то приложение должно быть перезапущено на другом узле.</target>
        </trans-unit>
        <trans-unit id="23225511bfc3875384d2792bd043f1c701a2c0ca" translate="yes" xml:space="preserve">
          <source>In a future Erlang/OTP release, it might be implemented a way to (optionally) preserve sharing.</source>
          <target state="translated">В будущем релизе Erlang/OTP может быть реализован способ (опционально)сохранения совместного использования.</target>
        </trans-unit>
        <trans-unit id="4a6305081dfcb5f7cad2ca28aa531435457c8383" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Dir&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">В будущем выпуске неверный тип аргумента &lt;code&gt;Dir&lt;/code&gt; , вероятно, вызовет исключение.</target>
        </trans-unit>
        <trans-unit id="1a6542a84ddb6812f9a19d1cc7c1b8efff7c3a54" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Filename&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">В будущем выпуске неверный тип аргумента &lt;code&gt;Filename&lt;/code&gt; , вероятно, вызовет исключение.</target>
        </trans-unit>
        <trans-unit id="f07b31928724d837c06543b0d4ac70cbfb01f2cb" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e2eab173886fa1c16faadaf18c5a216f901d1c" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В будущих версиях эта функция может возвращать больше значений и диапазонов. Чтобы избежать проблем с совместимостью, рекомендуется использовать функцию &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab65a5239391014eb913ce30baf2efae7d72ed7b" translate="yes" xml:space="preserve">
          <source>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.</source>
          <target state="translated">В более крупной модели отслеживание чисел в скобках может быть непростым.Это облегчается использованием относительных ссылок.Вместо (?1)в приведенном выше шаблоне можно написать (?-2)для ссылки на вторые последние открытые круглые скобки,предшествующие рекурсии.То есть отрицательное число отсчитывает захват круглых скобок,оставленных слева от точки,в которой они встречены.</target>
        </trans-unit>
        <trans-unit id="521f7cdd5ab3fc62df36d3dfb682c92be20244f3" translate="yes" xml:space="preserve">
          <source>In a larger system with a user (in this case an MGC) distributed over several Erlang nodes, it looks a little bit different. Here the encoding is performed on the originating Erlang node (1) and the binary is forwarded to the node (2) with the physical network interface. When the potential message reply is received on the interface on node (2), it is decoded there and then different actions will be taken for each transaction in the message. The transaction reply will be forwarded in its decoded form to the originating node (1) while the other types of transactions will be handled locally on node (2).</source>
          <target state="translated">В более крупной системе с пользователем (в данном случае MGC),распределенным по нескольким узлам Erlang,выглядит несколько иначе.Здесь кодировка выполняется на исходящем узле Erlang (1),а двоичный файл пересылается на узел (2)с физическим сетевым интерфейсом.Когда потенциальный ответ на сообщение поступает на интерфейс на узле (2),он декодируется там,а затем для каждой транзакции в сообщении будут выполняться различные действия.Ответ на транзакцию в расшифрованном виде будет перенаправлен на исходящий узел (1),в то время как другие типы транзакций будут обрабатываться локально на узле (2).</target>
        </trans-unit>
        <trans-unit id="976ebf70f5a3964ad2dc1b919f7c060f1cb37e38" translate="yes" xml:space="preserve">
          <source>In a manner similar to the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, except that this function requires the following conditions:</source>
          <target state="translated">Подобно функции &lt;code&gt;mnesia:index_read/3&lt;/code&gt; , любая индексная информация может использоваться при попытке сопоставить записи. Эта функция принимает шаблон, который подчиняется тем же правилам, что и функция &lt;code&gt;mnesia:match_object/3&lt;/code&gt; , за исключением того, что для этой функции требуются следующие условия:</target>
        </trans-unit>
        <trans-unit id="4c4bc3edae976085e9a0d189975eeda0ad921051" translate="yes" xml:space="preserve">
          <source>In a monotonically increasing sequence of values, all values that have a predecessor are either larger than or equal to its predecessor.</source>
          <target state="translated">В монотонно возрастающей последовательности значений все значения,которые имеют предшественник,либо больше,либо равны его предшественнику.</target>
        </trans-unit>
        <trans-unit id="1ab70776fb35c924c17c1cd7488da7d1d0d285f9" translate="yes" xml:space="preserve">
          <source>In a new version of the release, the application &lt;code&gt;ch_app&lt;/code&gt; is to be included in &lt;code&gt;prim_app&lt;/code&gt;. That is, its topmost supervisor &lt;code&gt;ch_sup&lt;/code&gt; is to be started as a child process to &lt;code&gt;prim_sup&lt;/code&gt;.</source>
          <target state="translated">В новой версии релиза приложение &lt;code&gt;ch_app&lt;/code&gt; должно быть включено в &lt;code&gt;prim_app&lt;/code&gt; . То есть его самый верхний супервизор &lt;code&gt;ch_sup&lt;/code&gt; должен запускаться как дочерний процесс для &lt;code&gt;prim_sup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="274b316a1d6a226ddaa81a91a28524b871d26fde" translate="yes" xml:space="preserve">
          <source>In a pattern matching, a left-hand side &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; is matched against a right-hand side &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt;. If the matching succeeds, any unbound variables in the pattern become bound. If the matching fails, a run-time error occurs.</source>
          <target state="translated">В сопоставлении с образцом, левая сторона &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; сравниваются с боковой с правой &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt; . Если сопоставление прошло успешно, все несвязанные переменные в шаблоне становятся связанными. Если сопоставление не удается, возникает ошибка времени выполнения.</target>
        </trans-unit>
        <trans-unit id="a946839a1f3091d7ba3fdcd58b538b74992aa355" translate="yes" xml:space="preserve">
          <source>In a strictly monotonically increasing sequence of values, all values that have a predecessor are larger than its predecessor.</source>
          <target state="translated">В строго монотонно увеличивающейся последовательности значений,все значения,которые имеют предшественник,больше,чем у его предшественника.</target>
        </trans-unit>
        <trans-unit id="31ff33f4c7a5907d10bf958b213e55ba1dc343c7" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers such as error loggers.</source>
          <target state="translated">В дереве управления многие процессы имеют схожие структуры,они следуют схожим закономерностям.Например,по структуре супервайзеры похожи.Единственное различие между ними заключается в том,над какими дочерними процессами они работают.Многие из сотрудников являются серверами в соотношении сервер-клиент,машинами конечного состояния или обработчиками событий,такими как регистраторы ошибок.</target>
        </trans-unit>
        <trans-unit id="3efaceff063003bf44950693b3f902b21784c28f" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd210cc6dd528624657860bc47c1121fbe29a1ff" translate="yes" xml:space="preserve">
          <source>In a system implemented according to the OTP design principles, all processes, except system processes and special processes, reside in one of the behaviours &lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;. These belong to the STDLIB application and upgrading/downgrading normally requires an emulator restart.</source>
          <target state="translated">В системе осуществляется в соответствии с OTP принципами дизайна, все процессы, за исключением системных процессов и специальных процессов, проживают в одном из поведения &lt;code&gt;supervisor&lt;/code&gt; , &lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_fsm&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; или &lt;code&gt;gen_event&lt;/code&gt; . Они относятся к приложению STDLIB, и для обновления / понижения обычно требуется перезапуск эмулятора.</target>
        </trans-unit>
        <trans-unit id="554c457d1fb565b9a6393985044814faed4608a5" translate="yes" xml:space="preserve">
          <source>In a system of &lt;code&gt;Mnesia&lt;/code&gt; nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate &lt;code&gt;Mnesia&lt;/code&gt; data behaves identically regardless of where the data resides.</source>
          <target state="translated">В системе узлов &lt;code&gt;Mnesia&lt;/code&gt; каждый узел знает о текущем местоположении всех таблиц. В этом примере данные реплицируются на обоих узлах, а функции, управляющие данными в таблицах, могут выполняться на любом из двух узлов. Код, управляющий данными &lt;code&gt;Mnesia&lt;/code&gt; , ведет себя идентично независимо от того, где находятся данные.</target>
        </trans-unit>
        <trans-unit id="8b48851f5568a382a621cc92c48317c0fa23d6e3" translate="yes" xml:space="preserve">
          <source>In a system structured according to the OTP design principles, any process would be a child process belonging to a supervisor, see &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; in Changing a Supervisor.</source>
          <target state="translated">В системе, структурированной в соответствии с принципами проектирования OTP, любой процесс будет дочерним процессом, принадлежащим супервизору, см. &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; в разделе &amp;laquo; Смена супервизора&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="44ba56c896fa716f74253d95bcea0e44a23d8f58" translate="yes" xml:space="preserve">
          <source>In a system that use comparatively few processes, performance &lt;strong&gt;might&lt;/strong&gt; be improved by increasing the minimum heap size using either the &lt;code&gt;+h&lt;/code&gt; option for &lt;code&gt;erl&lt;/code&gt; or on a process-per-process basis using the &lt;code&gt;min_heap_size&lt;/code&gt; option for &lt;code&gt;spawn_opt/4&lt;/code&gt;.</source>
          <target state="translated">В системе, в которой используется сравнительно небольшое количество процессов, производительность &lt;strong&gt;может&lt;/strong&gt; быть улучшена путем увеличения минимального размера кучи с помощью параметра &lt;code&gt;+h&lt;/code&gt; для &lt;code&gt;erl&lt;/code&gt; или для каждого процесса с использованием параметра &lt;code&gt;min_heap_size&lt;/code&gt; для &lt;code&gt;spawn_opt/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f12319f42fd8dda78673d0ca45eab01cc78900" translate="yes" xml:space="preserve">
          <source>In a system with TCP-based distribution, this data is kept in the &lt;strong&gt;Erlang port mapper daemon&lt;/strong&gt; (&lt;code&gt;epmd&lt;/code&gt;), which is contacted when a distributed node starts. The lock file and a convention for the UDS listen socket's name remove the need for &lt;code&gt;epmd&lt;/code&gt; when using this distribution module. UDS is always restricted to one host, why avoiding a port mapper is easy.</source>
          <target state="translated">В системе с распределением на основе TCP эти данные хранятся в &lt;code&gt;epmd&lt;/code&gt; &lt;strong&gt;сопоставления портов Erlang&lt;/strong&gt; ( epmd ), с которым связываются при запуске распределенного узла. Файл блокировки и соглашение об имени сокета для прослушивания UDS устраняют необходимость в &lt;code&gt;epmd&lt;/code&gt; при использовании этого модуля распространения. UDS всегда ограничен одним хостом, поэтому легко избежать сопоставления портов.</target>
        </trans-unit>
        <trans-unit id="5ccaddcd0c823bd477d387b9058aa0fc21906850" translate="yes" xml:space="preserve">
          <source>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</source>
          <target state="translated">В таблице,контролируемой SNMP,все элементы должны быть целыми числами,строками или списками целых чисел.</target>
        </trans-unit>
        <trans-unit id="f62f7aaa3c520340c959fbaf0d8e529944b88886" translate="yes" xml:space="preserve">
          <source>In a target system, the release upgrade file is to be located in directory &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;.</source>
          <target state="translated">В целевой системе файл обновления выпуска должен находиться в каталоге &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac283a89487dcb253786b8bd6bb529084d29ffc" translate="yes" xml:space="preserve">
          <source>In a test suite, one must &lt;strong&gt;require&lt;/strong&gt; that a configuration variable (&lt;code&gt;CfgVarName&lt;/code&gt; in the previous definition) exists before attempting to read the associated value in a test case or configuration function.</source>
          <target state="translated">В наборе тестов необходимо &lt;strong&gt;потребовать,&lt;/strong&gt; чтобы переменная конфигурации ( &lt;code&gt;CfgVarName&lt;/code&gt; в предыдущем определении) существовала, прежде чем пытаться прочитать связанное значение в тестовом примере или функции конфигурации.</target>
        </trans-unit>
        <trans-unit id="4fb9fe0e283f20ff6583d865477e2f5797757ef1" translate="yes" xml:space="preserve">
          <source>In a tuple &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt;, if &lt;code&gt;CSSFile&lt;/code&gt; is specified with a path, for example, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt;, this full name is used to locate the file. However, if only the file name is specified, for example, &lt;code&gt;categories.css&lt;/code&gt;, the CSS file is assumed to be located in the data directory, &lt;code&gt;data_dir&lt;/code&gt;, of the suite. The latter use is recommended, as it is portable compared to hard coding path names in the suite.</source>
          <target state="translated">В кортеже &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt; , если &lt;code&gt;CSSFile&lt;/code&gt; указан с путем, например, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt; , это полное имя используется для поиска файла. Однако, если указано только имя файла, например, &lt;code&gt;categories.css&lt;/code&gt; , предполагается , что файл CSS должен быть расположен в каталоге данных, &lt;code&gt;data_dir&lt;/code&gt; , сюиты. Последнее использование рекомендуется, поскольку оно переносимо по сравнению с именами путей жесткого кодирования в наборе.</target>
        </trans-unit>
        <trans-unit id="1286250e203085fab759937a2009fa429066e481" translate="yes" xml:space="preserve">
          <source>In absence of spawn operation failures, atomically sets up a link between the calling process and the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#link-1&quot;&gt;link(Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7833417b997c143c87f40d58a519fc4541a0bf" translate="yes" xml:space="preserve">
          <source>In addition to specifying a type letter, the actual value for the type can be specified. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5578dc50a0864bd8d9d5138f6fed8f654dd2af" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;{Item,Value}&lt;/code&gt; pairs defined for &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, the following items are allowed:</source>
          <target state="translated">В дополнение к парам &lt;code&gt;{Item,Value}&lt;/code&gt; , определенным для &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; , разрешены следующие элементы:</target>
        </trans-unit>
        <trans-unit id="1a79ac5033930298cd0d6e70aec5390fc42e348e" translate="yes" xml:space="preserve">
          <source>In addition to the Call Graph there is a graph called the  &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt;. This is a graph of calls (From, To) such that there is a chain of calls from From to To in the Call Graph, and every From and To is an exported function or an unused local function. The vertices are the same as for the Call Graph.</source>
          <target state="translated">В дополнение к Графику вызовов существует график, который называется &lt;strong id=&quot;inter_call_graph&quot;&gt;Графиком вызовов&lt;/strong&gt; . Это график вызовов (From, To), в котором есть цепочка вызовов от From до To в графике вызовов, и каждый From и To является экспортируемой функцией или неиспользуемой локальной функцией. Вершины такие же, как у Графа вызовов.</target>
        </trans-unit>
        <trans-unit id="5ea131aa8ce39e0fad64d7f37053c449509534e3" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="translated">В дополнение к алгоритмам, согласованным набором шифров, используемым для обмена ключами, шифрования полезной нагрузки, аутентификации сообщений и псевдослучайных вычислений, можно использовать расширение алгоритма подписи TLS, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; , начиная с TLS 1.2, чтобы согласовать, какой алгоритм подписи для использования во время рукопожатия TLS. Если не поддерживаются версии TLS ниже 1.2, клиент отправит расширение алгоритма подписи TLS с алгоритмами, указанными в этой опции. По умолчанию</target>
        </trans-unit>
        <trans-unit id="08f56fb7610394014283a4c142a08a63d84be1ba" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8211e020ecaee607aa2a72d41a52382183c4a8b5" translate="yes" xml:space="preserve">
          <source>In addition to the collection algorithm described above, the Erlang garbage collector also provides generational garbage collection. An additional heap, called the old heap, is used where the long lived data is stored. The original heap is called the young heap, or sometimes the allocation heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfba226beccd4a1427fc9d1c6106071bf62f4d15" translate="yes" xml:space="preserve">
          <source>In addition to the documentation here Erlang is described in several recent books like:</source>
          <target state="translated">Наряду с документацией здесь Erlang описан в нескольких недавних книгах как:</target>
        </trans-unit>
        <trans-unit id="88d44d718b6e7d7989a95592c66be31f11e98097" translate="yes" xml:space="preserve">
          <source>In addition to the earlier:</source>
          <target state="translated">В дополнение к тому,что было раньше:</target>
        </trans-unit>
        <trans-unit id="890bb829697d00b41e1b4a5c52b5061881f7d784" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/2&lt;/code&gt; and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">В дополнение к обязательной функции обратного вызова &lt;code&gt;log/2&lt;/code&gt; модуль обработчика может экспортировать дополнительные функции обратного вызова &lt;code&gt;adding_handler/1&lt;/code&gt; , change_config &lt;code&gt;changing_config/2&lt;/code&gt; и remove_handler &lt;code&gt;removing_handler/1&lt;/code&gt; . См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; на странице руководства logger (3) для получения дополнительной информации об этой функции.</target>
        </trans-unit>
        <trans-unit id="4485e35d13b31a5f17e0ec8540bc97bc5f63738e" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/3&lt;/code&gt;, &lt;code&gt;filter_config/1&lt;/code&gt;, and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45082fc3acc3b9bc0e8feada04ef6474816b9ee7" translate="yes" xml:space="preserve">
          <source>In addition to the ordinary functions for receiving and sending files (see &lt;code&gt;recv/2&lt;/code&gt;, &lt;code&gt;recv/3&lt;/code&gt;, &lt;code&gt;send/2&lt;/code&gt;, and &lt;code&gt;send/3&lt;/code&gt;) there are functions for receiving remote files as binaries (see &lt;code&gt;recv_bin/2&lt;/code&gt;) and for sending binaries to be stored as remote files (see &lt;code&gt;send_bin/3&lt;/code&gt;).</source>
          <target state="translated">В дополнение к обычным функциям для получения и отправки файлов (см. &lt;code&gt;recv/2&lt;/code&gt; , &lt;code&gt;recv/3&lt;/code&gt; , &lt;code&gt;send/2&lt;/code&gt; и &lt;code&gt;send/3&lt;/code&gt; ) есть функции для получения удаленных файлов в виде двоичных файлов (см. &lt;code&gt;recv_bin/2&lt;/code&gt; ) и для отправки двоичных файлов в храниться как удаленные файлы (см. &lt;code&gt;send_bin/3&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af29f18311535fbae0f8e4ae58bbff8300a8115f" translate="yes" xml:space="preserve">
          <source>In addition to the representations described earlier, the following deprecated representations are available if the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;:</source>
          <target state="translated">В дополнение к представлениям, описанным ранее, следующие устаревшие представления доступны, если спецификация была скомпилирована с опцией &lt;code&gt;legacy_erlang_types&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86f6f7e492ba3b7949f4b38c0a7d47daec6054a6" translate="yes" xml:space="preserve">
          <source>In addition to the representations of forms, the list that represents a module declaration (as returned by functions in &lt;code&gt;epp(3)&lt;/code&gt; and &lt;code&gt;erl_parse(3)&lt;/code&gt;) can contain the following:</source>
          <target state="translated">Помимо представлений форм, список, представляющий объявление модуля (возвращаемый функциями в &lt;code&gt;epp(3)&lt;/code&gt; и &lt;code&gt;erl_parse(3)&lt;/code&gt; ), может содержать следующее:</target>
        </trans-unit>
        <trans-unit id="cd3b0823be609b58f269a346f9f2725dc8f84272" translate="yes" xml:space="preserve">
          <source>In addition to the signature_algorithms extension from TLS 1.2, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt;adds the signature_algorithms_cert extension which enables having special requirements on the signatures used in the certificates that differs from the requirements on digital signatures as a whole. If this is not required this extension is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7229ff36909ba7ebefb7b021baf2857202005046" translate="yes" xml:space="preserve">
          <source>In addition to the signature_algorithms extension from TLS 1.2, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt;adds the signature_algorithms_cert extension which enables having special requirements on the signatures used in the certificates that differs from the requirements on digital signatures as a whole. If this is not required this extension is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad8f4e74819a6f7578284e9cf32df82a24e4ca4" translate="yes" xml:space="preserve">
          <source>In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \w and \s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the &lt;code&gt;ucp&lt;/code&gt; option is passed. However, they can also be used explicitly. The properties are as follows:</source>
          <target state="translated">В дополнение к стандартным свойствам Unicode, описанным ранее, PCRE поддерживает еще четыре, которые позволяют преобразовывать традиционные escape-последовательности, такие как \ w и \ s, для использования свойств Unicode. PCRE использует эти нестандартные, не относящиеся к Perl свойства, когда &lt;code&gt;ucp&lt;/code&gt; опция ucp . Однако их также можно использовать явно. Свойства следующие:</target>
        </trans-unit>
        <trans-unit id="698d80c93fc7667e3d673153ab193877506b308a" translate="yes" xml:space="preserve">
          <source>In addition to the static supervision tree, dynamic child processes can be added to an existing supervisor with the following call:</source>
          <target state="translated">В дополнение к статическому дереву наблюдения,динамические дочерние процессы могут быть добавлены к существующему супервайзеру с помощью следующего вызова:</target>
        </trans-unit>
        <trans-unit id="58454c75737b607a068b4e77b1a88fd258a15b57" translate="yes" xml:space="preserve">
          <source>In addition to the trace log file(s), a file with extension &lt;code&gt;.ti&lt;/code&gt; is created when Trace Tool Builder is started. This is the trace information file. It is a binary file, which contains the process information, trace flags used, the name of the node to which it belongs, and all information written with function &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;.ti&lt;/code&gt; files are always fetched with other logs when the trace is stopped.</source>
          <target state="translated">В дополнение к файлам журнала трассировки при &lt;code&gt;.ti&lt;/code&gt; Trace Tool Builder создается файл с расширением .ti . Это файл с информацией о трассировке. Это двоичный файл, который содержит информацию о процессе, используемые флаги трассировки, имя узла, которому он принадлежит, и всю информацию, записанную с помощью функции &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; . Файлы &lt;code&gt;.ti&lt;/code&gt; всегда выбираются вместе с другими журналами, когда трассировка остановлена.</target>
        </trans-unit>
        <trans-unit id="ead83cfe423b6f87966ff81fd05657fc8c719fd4" translate="yes" xml:space="preserve">
          <source>In addition to these options, &lt;strong&gt;raw&lt;/strong&gt; option specifications can be used. The raw options are specified as a tuple of arity four, beginning with tag &lt;code&gt;raw&lt;/code&gt;, followed by the protocol level, the option number, and the option value specified as a binary. This corresponds to the second, third, and fourth arguments to the &lt;code&gt;setsockopt&lt;/code&gt; call in the C socket API. The option value must be coded in the native endianess of the platform and, if a structure is required, must follow the structure alignment conventions on the specific platform.</source>
          <target state="translated">В дополнение к этим параметрам можно использовать &lt;strong&gt;необработанные&lt;/strong&gt; спецификации параметров. Необработанные параметры указываются как кортеж с четвёртой арностью, начиная с тега &lt;code&gt;raw&lt;/code&gt; , за которым следуют уровень протокола, номер параметра и значение параметра, заданное как двоичное. Это соответствует второму, третьему и четвертому аргументу вызова &lt;code&gt;setsockopt&lt;/code&gt; в API сокета C. Значение опции должно быть закодировано с учетом естественного байта платформы и, если требуется структура, должно соответствовать соглашениям о выравнивании структуры на конкретной платформе.</target>
        </trans-unit>
        <trans-unit id="ae1cf5f2bfcd3b60ef15c86d1e7f135dfc63d587" translate="yes" xml:space="preserve">
          <source>In addition to these, the following fields are automatically inserted by Logger, values taken from the two first parameters to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">В дополнение к этому, следующие поля автоматически вставляются Logger, значения взяты из двух первых параметров в &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e583d04eef0dfd18104660d17dcc9b07446e62d3" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide contains the following chapters:</source>
          <target state="translated">В дополнение к этой вводной главе Руководство пользователя &lt;code&gt;Event Tracers&lt;/code&gt; содержит следующие главы:</target>
        </trans-unit>
        <trans-unit id="fd1509d104b7597ab782042099faae460d5ff6b5" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Megaco User's Guide contains the following chapters:</source>
          <target state="translated">В дополнение к этой вводной главе,Руководство пользователя Megaco содержит следующие главы:</target>
        </trans-unit>
        <trans-unit id="5ad3911ee58ff673506ee22db5a2de1ed84850c6" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Reltool User's Guide contains the following chapters:</source>
          <target state="translated">В дополнение к этой вводной главе,Руководство пользователя Reltool содержит следующие главы:</target>
        </trans-unit>
        <trans-unit id="7f5fdf190092c245c6414244e40560909cfcd608" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the SNMP User's Guide contains the following chapters:</source>
          <target state="translated">В дополнение к этой вводной главе Руководство пользователя SNMP содержит следующие главы:</target>
        </trans-unit>
        <trans-unit id="fb294dab84ef10ba93b7376a3a5eeb757826cec4" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;#Record.Name&lt;/code&gt; returns the index in the tuple representation of &lt;code&gt;Name&lt;/code&gt; of the record &lt;code&gt;Record&lt;/code&gt;.</source>
          <target state="translated">Кроме того, &lt;code&gt;#Record.Name&lt;/code&gt; возвращает индекс в кортежном представлении &lt;code&gt;Name&lt;/code&gt; записи &lt;code&gt;Record&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec4f051098dd6dcb667d9032abc1d31d3cca680" translate="yes" xml:space="preserve">
          <source>In addition, EUnit will also look for another module whose name is &lt;code&gt;ModuleName&lt;/code&gt; plus the suffix &lt;code&gt;_tests&lt;/code&gt;, and if it exists, all the tests from that module will also be added. (If &lt;code&gt;ModuleName&lt;/code&gt; already contains the suffix &lt;code&gt;_tests&lt;/code&gt;, this is not done.) E.g., the specification &lt;code&gt;{module, mymodule}&lt;/code&gt; will run all tests in the modules &lt;code&gt;mymodule&lt;/code&gt; and &lt;code&gt;mymodule_tests&lt;/code&gt;. Typically, the &lt;code&gt;_tests&lt;/code&gt; module should only contain test cases that use the public interface of the main module (and no other code).</source>
          <target state="translated">Кроме того, EUnit также будет искать другой модуль с именем &lt;code&gt;ModuleName&lt;/code&gt; плюс суффикс &lt;code&gt;_tests&lt;/code&gt; , и, если он существует, все тесты из этого модуля также будут добавлены. (Если &lt;code&gt;ModuleName&lt;/code&gt; уже содержит суффикс &lt;code&gt;_tests&lt;/code&gt; , это не делается.) Например, спецификация &lt;code&gt;{module, mymodule}&lt;/code&gt; будет запускать все тесты в модулях &lt;code&gt;mymodule&lt;/code&gt; и &lt;code&gt;mymodule_tests&lt;/code&gt; . Как правило, модуль &lt;code&gt;_tests&lt;/code&gt; должен содержать только тестовые примеры, которые используют открытый интерфейс основного модуля (и никакой другой код).</target>
        </trans-unit>
        <trans-unit id="ec506ee3c0304b67799c67e512b132d1927abb1c" translate="yes" xml:space="preserve">
          <source>In addition, table properties can be set and changed. For details, see &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Кроме того, можно задавать и изменять свойства таблицы. Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfbb12ad016ab1664756254ead2ae4c40b6031b7" translate="yes" xml:space="preserve">
          <source>In addition, the following three built-in types exist and can be thought as defined below, though strictly their &quot;type definition&quot; is not valid syntax according to the type language defined above.</source>
          <target state="translated">Кроме того,следующие три встроенных типа существуют и могут рассматриваться как определенные ниже,хотя строго их &quot;определение типа&quot; не является действительным синтаксисом согласно языку типов,определенному выше.</target>
        </trans-unit>
        <trans-unit id="2ba8529808e3d5d63f2c2cd138891fddd10121b3" translate="yes" xml:space="preserve">
          <source>In addition, the record fields can be further specified when using a record type by adding type information about the field as follows:</source>
          <target state="translated">Кроме того,поля записи могут быть дополнительно уточнены при использовании типа записи путем добавления информации о типе поля следующим образом:</target>
        </trans-unit>
        <trans-unit id="0c6af5a9419b35f362c885bc58714fd954a7c605" translate="yes" xml:space="preserve">
          <source>In addition, you'll probably want to familiarize yourself with the &lt;code&gt;dbg&lt;/code&gt; module and possibly &lt;code&gt;seq_trace&lt;/code&gt; module as well.</source>
          <target state="translated">Кроме того, вы, вероятно, захотите ознакомиться с модулем &lt;code&gt;dbg&lt;/code&gt; и, возможно, &lt;code&gt;seq_trace&lt;/code&gt; модулем seq_trace .</target>
        </trans-unit>
        <trans-unit id="fb5db34bbd4674c5c25f061b695fba808bb59735" translate="yes" xml:space="preserve">
          <source>In all functions errors, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt;, can be thrown, where &lt;code&gt;Reason&lt;/code&gt; describes the error.</source>
          <target state="translated">Во всех функциях могут возникать ошибки &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt; , где &lt;code&gt;Reason&lt;/code&gt; описывает ошибку.</target>
        </trans-unit>
        <trans-unit id="fe9689d5a6e2657c5f322d20399fbd839acfe486" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;code&gt;ReplyInfo&lt;/code&gt; has the following structure:</source>
          <target state="translated">Во всех этих случаях &lt;code&gt;ReplyInfo&lt;/code&gt; имеет следующую структуру:</target>
        </trans-unit>
        <trans-unit id="e5f12a8e126b9f100f177dad18ae6f54278d47be" translate="yes" xml:space="preserve">
          <source>In all other cases.</source>
          <target state="translated">Во всех остальных случаях.</target>
        </trans-unit>
        <trans-unit id="44ae32a10f43de59e7c1339560b615fa6de7f95e" translate="yes" xml:space="preserve">
          <source>In all other senses, the &lt;code&gt;_tmo&lt;/code&gt; functions inherit all the return values and the semantics from the functions without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">Во всех других смыслах функции &lt;code&gt;_tmo&lt;/code&gt; наследуют все возвращаемые значения и семантику от функций без суффикса &lt;code&gt;_tmo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd966c15dbde5c1d758c9f9740c69468c511589a" translate="yes" xml:space="preserve">
          <source>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</source>
          <target state="translated">Во всех вышеприведенных примерах объект должен существовать и иметь нужный тип для указанной операции.Если вы не знаете тип объекта,вы можете спросить:</target>
        </trans-unit>
        <trans-unit id="9216f7534e9c31fef68910373cd1fdb3e3fbdb95" translate="yes" xml:space="preserve">
          <source>In an OTP source code tree, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can be constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt;.</source>
          <target state="translated">В дереве исходного кода OTP версию OTP можно прочитать из текстового файла &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt; . Абсолютный путь к файлу можно создать, вызвав &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a595d061787336fdc6e9d2d4c2dc217d3ec6e25" translate="yes" xml:space="preserve">
          <source>In an earlier version of this API, the &lt;code&gt;lookup&lt;/code&gt; function received two arguments, omitting &lt;code&gt;Issuer&lt;/code&gt;. For compatibility, this is still supported: if there is no &lt;code&gt;lookup/3&lt;/code&gt; function in the callback module, &lt;code&gt;lookup/2&lt;/code&gt; is called instead.</source>
          <target state="translated">В более ранней версии этого API функция &lt;code&gt;lookup&lt;/code&gt; получала два аргумента, исключая &lt;code&gt;Issuer&lt;/code&gt; . Для совместимости это все еще поддерживается: если в модуле обратного вызова нет функции &lt;code&gt;lookup/3&lt;/code&gt; , вместо этого вызывается &lt;code&gt;lookup/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b323e21a2ec47acd1da236b19d4a2d70f45bb77d" translate="yes" xml:space="preserve">
          <source>In an embedded system, there is usually no interactive shell. However, an operator can attach to the Erlang system by command &lt;code&gt;to_erl&lt;/code&gt;. The operator is then connected to the Erlang shell and can give ordinary Erlang commands. All interaction with the system through this shell is logged in a special directory.</source>
          <target state="translated">Во встроенной системе интерактивная оболочка обычно отсутствует. Однако оператор может подключиться к системе Erlang с помощью команды &lt;code&gt;to_erl&lt;/code&gt; . Затем оператор подключается к оболочке Erlang и может давать обычные команды Erlang. Все взаимодействия с системой через эту оболочку регистрируются в специальном каталоге.</target>
        </trans-unit>
        <trans-unit id="6affeed9ea78db2ead1d48cc4e80d6afbfafb4eb" translate="yes" xml:space="preserve">
          <source>In an installed OTP development system, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can by constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;releases&quot;,&lt;/code&gt;&lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</source>
          <target state="translated">В установленной системе разработки OTP версию OTP можно прочитать из текстового файла &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt; . Абсолютный путь к файлу можно &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt; вызвав &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;releases&quot;,&lt;/code&gt; Release &quot;, erlang : system_info (otp_release) , &quot;OTP_VERSION&quot;]).</target>
        </trans-unit>
        <trans-unit id="a4061d8e63786063b3eeabb1b52df7fa369545be" translate="yes" xml:space="preserve">
          <source>In an interactive system, the code loader provides demand-driven code loading, but in an embedded system the code loader loads all code immediately. The same version of &lt;code&gt;code&lt;/code&gt; is used in both cases. The code server calls &lt;code&gt;init:get_argument(mode)&lt;/code&gt; to determine if it is to run in demand mode or non-demand driven mode.</source>
          <target state="translated">В интерактивной системе загрузчик кода обеспечивает загрузку кода по запросу, но во встроенной системе загрузчик кода загружает весь код немедленно. В обоих случаях используется одна и та же версия &lt;code&gt;code&lt;/code&gt; . Сервер кода вызывает &lt;code&gt;init:get_argument(mode)&lt;/code&gt; чтобы определить, должен ли он работать в режиме по запросу или в режиме без запроса.</target>
        </trans-unit>
        <trans-unit id="40c287b596d5b896af6235aa0ac1f4766bfd7a16" translate="yes" xml:space="preserve">
          <source>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</source>
          <target state="translated">В обоих случаях текущий токен установлен.В частности,если маркер полученного сообщения пуст,то текущий маркер процесса устанавливается пустым.</target>
        </trans-unit>
        <trans-unit id="6cb81d52aa37dc7833d69efc8ceea8d49076b214" translate="yes" xml:space="preserve">
          <source>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</source>
          <target state="translated">В обоих случаях должен быть возвращен первый доступный элемент таблицы.Поскольку ключевые столбцы недоступны,это означает,что третий столбец является первой строкой.</target>
        </trans-unit>
        <trans-unit id="c8bcfe99dfb6ce58aa580ed57d8b7b2260bf8c45" translate="yes" xml:space="preserve">
          <source>In both previous examples, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; resets the trace token immediately after the traced function to avoid many trace messages because of the printouts in the Erlang shell.</source>
          <target state="translated">В обоих предыдущих примерах &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; сбрасывает токен трассировки сразу после трассируемой функции, чтобы избежать множества сообщений трассировки из-за распечаток в оболочке Erlang.</target>
        </trans-unit>
        <trans-unit id="b04f25164a1486f33a08ec5a081e04f72ebc9e3b" translate="yes" xml:space="preserve">
          <source>In both storages, the documentation is written in the exactly same format: an Erlang term serialized to binary via &lt;code&gt; term_to_binary/1&lt;/code&gt;. The term may be optionally compressed when serialized. It must follow the type specification below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9979f7dc9c90d9448aea9a33897846d951ecc0" translate="yes" xml:space="preserve">
          <source>In brief, &lt;code&gt;Common Test&lt;/code&gt; supports:</source>
          <target state="translated">Вкратце, &lt;code&gt;Common Test&lt;/code&gt; поддерживает:</target>
        </trans-unit>
        <trans-unit id="219af38196dae5e5cf8e3928cdad6f56580aeb9d" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to do the following:</source>
          <target state="translated">Вкратце,CTH позволяет сделать следующее:</target>
        </trans-unit>
        <trans-unit id="7808f617380ab0dd07679578966aad4ed29b5be3" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to:</source>
          <target state="translated">Короче говоря,CTH позволяет:</target>
        </trans-unit>
        <trans-unit id="515fe8110084161af1176bfde998dc3668536ede" translate="yes" xml:space="preserve">
          <source>In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either &lt;strong&gt;succeeds&lt;/strong&gt;, by returning some value (which is ignored), or &lt;strong&gt;fails&lt;/strong&gt;, by throwing an exception.</source>
          <target state="translated">Вкратце, простой тестовый объект состоит из единственной функции, которая не принимает аргументов (возможно, снабженных некоторыми дополнительными метаданными, например, номером строки). Оценка функции либо &lt;strong&gt;завершается успешно&lt;/strong&gt; , возвращая какое-либо значение (которое игнорируется), либо &lt;strong&gt;терпит неудачу&lt;/strong&gt; , вызывая исключение.</target>
        </trans-unit>
        <trans-unit id="cf6c31b5ceac197ebb6de3ed74b4d965acf33272" translate="yes" xml:space="preserve">
          <source>In case of a &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; checking the user, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">В случае операции сопоставления между ReferenceID и значением CN из поля &lt;code&gt;Subject&lt;/code&gt; , первый аргумент fun - это извлеченное имя хоста из ReferenceID, а второй аргумент - это кортеж &lt;code&gt;{cn, string()}&lt;/code&gt; взятый из &lt;code&gt;Subject&lt;/code&gt; . поле. Это позволяет иметь отдельные правила сопоставления для представленных идентификаторов из поля &amp;laquo; &lt;code&gt;Subject&lt;/code&gt; и из поля &amp;laquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14abcc78e4a8808dcb7c6c248f2d73041919e75b" translate="yes" xml:space="preserve">
          <source>In case of a sftp request, an sftp server is started in with the user's rights. So it could read, write or delete files if allowed for that user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае ошибки (например, &lt;code&gt;addr_unreachable&lt;/code&gt; ) поле &lt;code&gt;error&lt;/code&gt; предоставляет дополнительную диагностику. В таких случаях событие &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; автоматически преобразуется в термин &lt;code&gt;error&lt;/code&gt; возвращаемый &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; . Значение поля &lt;code&gt;error&lt;/code&gt; можно преобразовать в строку с помощью &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">В случае ошибки все инструментальные функции могут возвращать либо код ошибки SNMPv1, либо код ошибки SNMPv2. Если он возвращает код SNMPv2, он преобразуется в код SNMPv1 перед отправкой менеджеру SNMPv1. Рекомендуется использовать коды ошибок SNMPv2 для всех инструментальных функций, поскольку они предоставляют более подробную информацию. См. &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; для описания преобразования кода ошибки.</target>
        </trans-unit>
        <trans-unit id="53574543ae936142434ad121e0424851d134f56f" translate="yes" xml:space="preserve">
          <source>In case of an sftp request, an sftp server is started with the rights of the user of the Erlang emulator's OS process. So with sftp the authenticated user does not influence the rights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">В случае списков используется только процентное кодирование. Однако в двоичных файлах следует рассматривать как двоичное кодирование, так и процентное кодирование. &lt;code&gt;transcode/2&lt;/code&gt; предоставляет средства для преобразования между поддерживаемыми кодировками, он принимает &lt;code&gt;uri_string()&lt;/code&gt; и список параметров, определяющих входящие и исходящие кодировки.</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">В случае загрузки мониторинг может быть запущен &lt;strong&gt;не&lt;/strong&gt; только с помощью опции &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; , но и в особых случаях, когда ошибка загрузки временная. Таким образом, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; должен использоваться практически во &lt;strong&gt;всех&lt;/strong&gt; реальных условиях.</target>
        </trans-unit>
        <trans-unit id="c09622d21ce9a9b2d2c2d392f9cbc9b05b57cfb1" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;&lt;a href=&quot;#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; is set, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a8bc8abb7f5d55980d9c87519b99d19822bd2d" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;{direct, exec_fun()}&lt;/code&gt; variant or no exec-option at all, all reads from &lt;code&gt;standard_input&lt;/code&gt; will be from the received data-events of type 0. Those are sent by the client. Similarily all writes to &lt;code&gt;standard_output&lt;/code&gt; will be sent as data-events to the client. An OS shell client like the command 'ssh' will usally use stdin and stdout for the user interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае, когда представленные идентификаторы выбираются из поля сертификата &lt;code&gt;Subject&lt;/code&gt; , имена могут содержать символы подстановки. Функция обрабатывает это, как определено в &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случаях, когда есть выбор между типами string () и binary () для OctetString () и производных типов, представление определяется значением &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">В случаях, когда известно, что строка темы не содержит символов новой строки, стоит установить &lt;code&gt;dotall&lt;/code&gt; для получения этой оптимизации или, альтернативно, использовать ^ для явного указания привязки.</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">В случаях, когда вы хотите перенаправить стандартный ввод и / или стандартный вывод или использовать Erlang в конвейере, &lt;code&gt;werl&lt;/code&gt; не подходит, и вместо него следует использовать программу &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">В некоторых выходных функциях и при выводе возвращаемых значений в оболочке Erlang пытается обнаружить строковые данные в списках и двоичных файлах эвристически.Обычно в такой ситуации вы увидите эвристическое обнаружение:</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">В определенных ситуациях, особенно при перенаправлении стандартного вывода, может быть удобен доступ к серверу ввода-вывода, предназначенному для сообщений об ошибках. Устройство ввода-вывода &lt;code&gt;standard_error&lt;/code&gt; можно использовать для направления вывода на то, что текущая операционная система считает подходящим устройством ввода-вывода для вывода ошибок. Пример в Unix-подобной операционной системе:</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">В сочетании с &lt;code&gt;{locations, true}&lt;/code&gt; этот параметр печатает исходный файл операций блокировки и точки входа с номерами строк, а также статистику для каждой записи.</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">В сочетании с опцией &lt;code&gt;-M&lt;/code&gt; или &lt;code&gt;-MF&lt;/code&gt; добавляет фиктивную цель для каждой зависимости.</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">В сочетании с опцией &lt;code&gt;-M&lt;/code&gt; или &lt;code&gt;-MF&lt;/code&gt; изменяет имя правила, передаваемого в &lt;code&gt;Target&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">В сочетании с опцией &lt;code&gt;-M&lt;/code&gt; или &lt;code&gt;-MF&lt;/code&gt; рассматривает отсутствующие заголовки как сгенерированные файлы и добавляет их в зависимости.</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">В отличие от RPC,многоадресный вызов-это RPC,который посылается одновременно с одного клиента на несколько серверов.Это полезно для сбора информации с набора узлов,или для вызова функции на наборе узлов для достижения некоторых побочных эффектов.С семантической точки зрения это то же самое,что делать серию RPC на всех узлах,но многоадресный вызов происходит быстрее,так как все запросы посылаются одновременно и собираются один за другим,когда они возвращаются.</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства других функций обратного вызова, &lt;code&gt;stop_select&lt;/code&gt; вызывается независимо от любого порта. Нет &lt;code&gt;ErlDrvData&lt;/code&gt; аргумент передается функции. Блокировка драйвера или блокировка порта не гарантируются. Порт, который вызвал &lt;code&gt;driver_select&lt;/code&gt; , может быть даже закрыт во время &lt;code&gt;stop_select&lt;/code&gt; . Но также может быть случай, когда &lt;code&gt;stop_select&lt;/code&gt; вызывается непосредственно &lt;code&gt;erl_driver:driver_select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">Напротив,вызов подпрограммы на пронумерованную подмасштабинку всегда относится к первой подмасштабинке с заданным номером.Следующий образец совпадает с &quot;abcabc&quot; или &quot;defabc&quot;:</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">В дампах падения опускается стек,сообщения и словарь процесса.</target>
        </trans-unit>
        <trans-unit id="f5b30e844f19c774b16c52548000fcb4af87d281" translate="yes" xml:space="preserve">
          <source>In decryption, the &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; removes such padding, if present. The &lt;code&gt;&lt;a href=&quot;#type-otp_padding&quot;&gt;otp_padding&lt;/a&gt;&lt;/code&gt; is not removed - it has to be done elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">В грязном контексте, то есть &lt;code&gt;sync_dirty&lt;/code&gt; или &lt;code&gt;async_dirty&lt;/code&gt; , измененные записи не сохраняются в локальной копии; вместо этого каждая запись обновляется отдельно. Это создает большой сетевой трафик, если таблица имеет реплику на другом узле и имеет все другие недостатки, присущие грязным операциям. Особенно для команд &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; применяются те же недостатки, что и для &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; , то есть во время итерации запись в таблицу не производится.</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">В каждом &lt;code&gt;Viewer&lt;/code&gt; активен только один фильтр, и все &lt;code&gt;Events&lt;/code&gt; трассировки, которые &lt;code&gt;Viewer&lt;/code&gt; получает от &lt;code&gt;Collector&lt;/code&gt; , проходят через этот фильтр. Написав умные фильтры, можно настроить, как &lt;code&gt;Events&lt;/code&gt; выглядеть в средстве просмотра. Следующий фильтр в &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; заменяет имена &lt;code&gt;mnesia_tm&lt;/code&gt; и &lt;code&gt;mnesia_locker&lt;/code&gt; и оставляет все остальное в записи как было:</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">В каждой итерации первые 8 бит в двоичном файле будут пропущены,а не сопоставлены.</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">В более ранних выпусках Erlang / OTP операции со слишком большими двоичными файлами обычно либо завершались ошибкой, либо давали неверные результаты. В будущих выпусках другие операции, создающие двоичные файлы (например, &lt;code&gt;list_to_binary/1&lt;/code&gt; ), вероятно, также будут применять такое же ограничение.</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">В любом случае агент ничего не сделает, но вернет полученный ManagerEngineID ( дополнительную информацию см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; ) и, возможно, продолжит этап 2 процесса обнаружения.</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">Во встроенном режиме весь код загружается при загрузке системы в соответствии с загрузочным скриптом.(Код также может быть загружен позже,явно поручив это кодовому серверу).</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">Во встроенном режиме сначала загружаются все модули. Затем &lt;code&gt;on_load&lt;/code&gt; все функции on_load . Система прекращает работу, если все функции &lt;code&gt;on_load&lt;/code&gt; не возвращают &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">Во встроенном режиме модули не загружаются автоматически.Попытка использовать не загруженный модуль приводит к ошибке.Этот режим рекомендуется,когда сценарий загрузки загружает все модули,как это обычно делается в релизах OTP.(Код все равно может быть загружен позже,явно поручив это кодовому серверу).</target>
        </trans-unit>
        <trans-unit id="a1f53217834ce9f061b0ce0f9fd6ed43fb29178a" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt; erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Во встроенных системах с ограниченным объемом оперативной памяти и без виртуальной памяти вы можете захотеть сохранить память, установив &lt;code&gt;Number&lt;/code&gt; равным нулю. (Значение можно установить глобально, см &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">По сути, функция выполняет ту же операцию, что и &lt;code&gt;ei_xreceive_msg&lt;/code&gt; , но вместо использования &lt;code&gt;ei_x_buff&lt;/code&gt; функция ожидает указатель на указатель символа ( &lt;code&gt;mbufp&lt;/code&gt; ), где указатель символа должен указывать на область памяти, выделенную &lt;code&gt;malloc&lt;/code&gt; . Аргумент &lt;code&gt;bufsz&lt;/code&gt; должен быть указателем на целое число, содержащее точный размер (в байтах) области памяти. Функция может перераспределить область памяти и в таких случаях поместит новый размер в &lt;code&gt;*bufsz&lt;/code&gt; и обновит &lt;code&gt;*mbufp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">В каждом каталоге под &lt;code&gt;DocumentRoot&lt;/code&gt; или под &lt;code&gt;Alias&lt;/code&gt; пользователь может разместить файл доступа. Файл доступа - это простой текстовый файл, в котором указываются ограничения, которые необходимо учитывать перед тем, как веб-сервер ответит на запрос. Если на пути к запрошенному активу имеется более одного файла доступа, используются директивы в файле доступа в каталоге, ближайшем к активу.</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">На самом деле,поскольку случайные данные кэшируются,некоторые числа могут быть воспроизведены при попытке,но это непредсказуемо.</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">В удачных случаях несоответствие видно только в таблицах,относящихся к конкретному приложению.Однако если операция по восстановлению схемы восстановлена непоследовательно из-за принудительного решения о восстановлении операции,последствия несоответствия могут быть фатальными.Однако,если более высоким приоритетом является доступность,а не согласованность,это может стоить риска.</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">Как правило, ошибки исправляются только в последнем &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; , а новые функции представлены в следующем выпуске, который находится в стадии разработки. Однако, когда мы по внутренним причинам исправим ошибки в старых выпусках, они также будут доступны и объявлены.</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">Как правило, подшаблоны, которым не было присвоено значение в совпадении, возвращаются как кортеж &lt;code&gt;{-1,0}&lt;/code&gt; , если &lt;code&gt;type&lt;/code&gt; является &lt;code&gt;index&lt;/code&gt; . Неназначенные подшаблоны возвращаются как пустой двоичный файл или список, соответственно, для других типов возвращаемых значений. Рассмотрим следующее регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="264b6524a328aed18af181468f92444ef5d0e1cd" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;ei&lt;/code&gt; library is guaranteed to be compatible with other Erlang/OTP components that are 2 major releases older or newer than the &lt;code&gt;ei&lt;/code&gt; library itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">В целом,существуют лучшие способы,чем использование тайм-аутов для контроля над частями распределенной системы Erlang.Тайм-ауты обычно подходят для наблюдения за внешними событиями,например,если вы ожидали сообщение от какой-то внешней системы в течение указанного времени.Например,тайм-аут может использоваться для выхода пользователя из системы обмена сообщениями,если он не получал к ней доступа,скажем,в течение десяти минут.</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">Как правило,кортежи используются там,где &quot;записи&quot; или &quot;структуры&quot; используются в других языках.Кроме того,списки используются,когда представляют вещи разного размера,то есть,когда связанные списки используются на других языках.</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">Как правило, версии могут состоять более чем из трех частей. Тогда версии заказываются только частично. Такие версии используются только в исключительных случаях. Когда к номеру версии добавляется дополнительная часть (из трех обычных), создается новая ветвь версий. Новая ветка имеет линейный порядок по сравнению с базовой версией. Однако версии в разных ветвях не имеют порядка, и поэтому можно только сделать вывод, что все они включают то, что входит в их ближайшего общего предка. Если ответвление несколько раз из одной и той же базовой версии, &lt;code&gt;0&lt;/code&gt; частей добавляются между базовой версией и наименее значимого &lt;code&gt;1&lt;/code&gt; части до тех пор , уникальная версия не будет найдена. Версии, имеющие порядок, можно сравнить, как описано в предыдущем абзаце.</target>
        </trans-unit>
        <trans-unit id="ba987c1f9181380720aed267fac74a6f9ee0f607" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used when branching off from another branch. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">В режиме глобальной трассировки коллектор автоматически начнет трассировку по всем подключенным узлам Эрланга.При подключении узла на этом узле будет запущен трассировщик портов,а на узле коллектора-соответствующий клиент трассировки.</target>
        </trans-unit>
        <trans-unit id="f00745ad8caa1afca6bdd4f2b710aba925b97dcb" translate="yes" xml:space="preserve">
          <source>In instructions that will not always execute the next instruction. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">В интерактивном режиме код динамически загружается при первом обращении.При вызове функции в модуле,когда модуль не загружен,сервер кода ищет путь к коду и загружает модуль в систему.</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">В интерактивном режиме сервер кода поддерживает путь поиска, обычно называемый &lt;strong&gt;путем кода&lt;/strong&gt; , состоящий из списка каталогов, в которых он последовательно выполняет поиск при попытке загрузить модуль.</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">В интерактивном режиме,который по умолчанию является интерактивным,во время запуска системы загружается только некоторый код,в основном модули,необходимые для работы системы.Другой код загружается динамически при первом обращении к нему.Когда происходит вызов функции в определенном модуле,и модуль не загружается,кодовый сервер ищет и пытается загрузить модуль.</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">В простейших формах &lt;code&gt;match_spec&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">В локальном режиме код интерпретируется только на текущем узле.В глобальном режиме код интерпретируется на всех известных узлах.Процессы на других узлах,выполняющие интерпретацию кода,автоматически отображаются в окне Монитор и могут быть подключены к ним,как и к любому другому отлаженному процессу.</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">В системах с низким объемом памяти (особенно без виртуальной памяти) установка значения &lt;code&gt;0&lt;/code&gt; может помочь сэкономить память.</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">Во многих приложениях накладные расходы,связанные с обработкой транзакции,могут привести к потере производительности.Грязные операции-это короткие промежутки времени,которые обходят большую часть обработки и увеличивают скорость транзакции.</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">Во многих системах переходные состояния перегруженных очередей являются нормальным явлением. Хотя эта функция возвращает &lt;code&gt;false&lt;/code&gt; , это не означает, что другой узел гарантированно не отвечает, это может быть временной перегрузкой. Кроме того, возвращаемое значение &lt;code&gt;true&lt;/code&gt; означает только то, что сообщение может быть отправлено по каналу (TCP) без блокировки; сообщение не гарантированно поступит на удаленный узел. Для отключенного неотвечающего узла возвращаемое значение - &lt;code&gt;true&lt;/code&gt; (имитирует поведение оператора &lt;code&gt;!&lt;/code&gt; ). Ожидаемое поведение и действия, которые следует предпринять, когда функция возвращает &lt;code&gt;false&lt;/code&gt; , зависят от приложения и оборудования.</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">При совпадении это значение по умолчанию действует только для последнего элемента.Все остальные битовые строки или двоичные элементы при совпадении должны иметь спецификацию размера.</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">Через микросекунды</target>
        </trans-unit>
        <trans-unit id="74df42bf134f27883f855d9ef2904cba9dbfb304" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">В режиме &lt;code&gt;verify_none&lt;/code&gt; поведение по умолчанию - разрешить все ошибки проверки x509-path. См. Также параметр &lt;code&gt;verify_fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">&lt;code&gt;erlang:hibernate/3&lt;/code&gt; более техническим языком, erlang: hibernate / 3 отбрасывает стек вызовов для процесса, а затем мусор собирает процесс. После этого все живые данные хранятся в одной непрерывной куче. Затем куча сжимается до того же размера, что и текущие данные, которые она хранит (даже если этот размер меньше минимального размера кучи для процесса).</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">В большинстве функций API, где вы можете использовать это семейство адресов, номер порта должен быть &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">В большинстве случаев параметр &lt;code&gt;RootDir&lt;/code&gt; должен быть установлен таким же, как параметр конфигурации &lt;code&gt;root_dir&lt;/code&gt; , используемый при вызове &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (или &lt;code&gt;code:root_dir()&lt;/code&gt; если параметр конфигурации не установлен). В некоторых случаях может быть полезно оценить одну и ту же целевую спецификацию для разных корневых каталогов. Однако это следует использовать с большой осторожностью, поскольку для этого требуются эквивалентные файловые структуры для всех корней.</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">В обычном режиме нажатия клавиш пользователем собираются и интерпретируются &lt;code&gt;tty&lt;/code&gt; . Поддерживается большинство команд редактирования строк &lt;strong&gt;Emacs&lt;/strong&gt; . Ниже приводится полный список поддерживаемых команд редактирования строки.</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">При нормальной работе вызовы &lt;code&gt;et:trace_me/4,5&lt;/code&gt; почти бесплатны. Когда трассировка необходима, вы можете активировать трассировку для этих функций явно. Или вы можете комбинировать использование &lt;code&gt;trace_global&lt;/code&gt; с использованием &lt;code&gt;trace_pattern&lt;/code&gt; . Если установлено, &lt;code&gt;trace_pattern&lt;/code&gt; будет автоматически активирован на всех подключенных узлах.</target>
        </trans-unit>
        <trans-unit id="eae1f10c8b9d4c5e175d3fc8937d4ffde9c0f51a" translate="yes" xml:space="preserve">
          <source>In order for an &lt;code&gt;erpc&lt;/code&gt; operation to succeed, the remote node also needs to support &lt;code&gt;erpc&lt;/code&gt;. Typically only ordinary Erlang nodes as of OTP 23 have &lt;code&gt;erpc&lt;/code&gt; support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">Для того,чтобы в реализации в полной мере использовать расширенные коды ошибок SNMPv2,необходимо,чтобы функции приборов всегда возвращали коды ошибок SNMPv2 в случае ошибки.При необходимости они транслируются агентом в соответствующие коды ошибок SNMPv1.</target>
        </trans-unit>
        <trans-unit id="91f9f99c50f34dfe6347f220890a64d23f9ce151" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">Чтобы API-интерфейс потока драйвера Erlang мог работать, в системе времени выполнения должна быть включена поддержка потоков. Драйвер Erlang может проверить, включена ли поддержка потоков, используя &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что некоторые функции в API драйвера Erlang являются потокобезопасными только в том случае, если система времени выполнения имеет поддержку SMP, также эту информацию можно получить через &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; . Также обратите внимание, что многие функции в API драйвера Erlang &lt;strong&gt;не&lt;/strong&gt; являются потокобезопасными, независимо от того, включена ли поддержка SMP или нет. Если функция не задокументирована как потокобезопасная, она &lt;strong&gt;не&lt;/strong&gt; является потокобезопасной.</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Для того, чтобы функция прерывания / продолжения работала, &lt;code&gt;Common Test&lt;/code&gt; должен освободить процесс оболочки, управляющий &lt;code&gt;stdin&lt;/code&gt; . Это делается путем установки запуска опции &lt;code&gt;release_shell&lt;/code&gt; к &lt;code&gt;true&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="6e5ab42b46c29034052cc72be40b7ac14c2d1e1e" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt; +sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Чтобы система времени выполнения могла связывать планировщики, должна быть известна топология ЦП. Если исполняющая система не может автоматически определить топологию ЦП, ее можно определить. Для получения дополнительной информации о том, как определить топологию ЦП, см. Флаг командной строки &lt;code&gt;+sct&lt;/code&gt; в &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">Для того,чтобы это работало правильно,пользователь должен обеспечить выполнение следующих двух требований:</target>
        </trans-unit>
        <trans-unit id="7316234f8d0404e7bccb8d56aec4837d25e8e904" translate="yes" xml:space="preserve">
          <source>In order to allow minimizing the performance loss, the &lt;code&gt;file_check&lt;/code&gt; parameter can be set to a positive integer value, &lt;code&gt;N&lt;/code&gt;. The handler will then skip reading the file information prior to writing, as long as no more than &lt;code&gt;N&lt;/code&gt; milliseconds have passed since it was last read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">Для того,чтобы добавить эти данные в конец документа motorcles.xml,необходимо разобрать файл и добавить данные в конец содержимого корневого элемента.</target>
        </trans-unit>
        <trans-unit id="1cc2af703c741622a9752f6130d1aed382c381ac" translate="yes" xml:space="preserve">
          <source>In order to avoid these situations we wanted to be able to do most of the fundamental operations on a process without having to acquire a lock on the process. Some examples of such fundamental operations are, moving a process between run queues, detecting if we need to insert it into a run queue or not, detecting if it is alive or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9606b78a849c5b14fbde9a528c5423519c626033" translate="yes" xml:space="preserve">
          <source>In order to be able to decide which run queue to use without having to lock any run queues, we moved all fixed balancing information out of the run queues into a global memory block. That is, migration paths and run queue limits. Information that need to be frequently updated, like for example maximum run queue length, were kept in the run queue, but instead of operating on this information under locks we now use atomic memory operations when accessing this information. This made it possible to first determine which run queue to use, without locking any run queues, and when decided, lock the chosen run queue and insert the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f9a3c32af1c0aebd8c724db9f1fd7c9cd27f7" translate="yes" xml:space="preserve">
          <source>In order to be able to detect when it is safe to deallocate a previously used process structure, reference counting of the structure was used. Also this was problematic, since simultaneous lookups needed to modify the reference counter which also caused contention on the cache line where the reference counter was located. This since all modifications needs to be communicated between all involved processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248b6946fb3d78aedfd7eb1945dab3d08fcb73b1" translate="yes" xml:space="preserve">
          <source>In order to be able to determine when all managed threads have reached the states that we are interested in we need to communicate between all involved threads. We of course want to minimize this communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21c20f0ab3dedd86e0307763e8d967cc669941c" translate="yes" xml:space="preserve">
          <source>In order to be able to remove a carrier from one allocator instance and add it to another we need to be able to move references to the free blocks of the carrier between the allocator instances. The allocator instance specific data structure referring to the free blocks it manages often refers to the same carrier from multiple places. For example, when the address order best-fit strategy is used this data structure is a binary search tree spanning all carriers that the allocator instance manages. Free blocks in one specific carrier can be referred to from potentially every other carrier that is managed, and the amount of such references can be huge. That is, the work of removing the free blocks of such a carrier from the search tree will be huge. One way of solving this could be not to migrate carriers that contain lots of free blocks, but this would prevent us from migrating carriers that potentially need to be migrated in order to solve the problem we set out to solve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">Чтобы скомпилировать код Erlang, должна быть создана небольшая система начальной загрузки Erlang или система Erlang / OTP того же выпуска, что и создаваемая, должна быть указана в &lt;code&gt;$PATH&lt;/code&gt; . Erlang / OTP для целевой системы будет построен с использованием этой системы Erlang вместе с предоставленными инструментами кросс-компиляции.</target>
        </trans-unit>
        <trans-unit id="33c36db64d09c1349048183a11365e092986cc43" translate="yes" xml:space="preserve">
          <source>In order to determine when the events has happened we use a global counter that is incremented when all managed threads have called &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; (or &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt;). This could naively be implemented using a &quot;thread confirmed&quot; counter. This would however cause an explosion of communication where all involved processors would need to communicate with each other at each update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8bd01b2e2143b89a5d070a42db3498a1a3a7f5" translate="yes" xml:space="preserve">
          <source>In order to ensure data integrity, mutex'es are taken when needed. So, do not call this function often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbb01425e78fa9829f765ceacdcbc84ac1251f2" translate="yes" xml:space="preserve">
          <source>In order to fit better into your existing logging infrastructure Logger can format its logging messages any way you want to. Either you can use the built-in formatter, or you can build your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">Для того,чтобы полностью понять внутреннюю форму,вы должны получить спецификацию ASN.1 для протокола Megaco/H.248 и применить правила,приведенные выше.Пожалуйста,ознакомьтесь с документацией компилятора ASN.1 в Erlang/OTP для получения более подробной информации о семантике в отображении между ASN.1 и соответствующей внутренней формой.</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">Чтобы еще больше упростить трассировку, вы можете использовать функции &lt;code&gt;et:trace_me/4,5&lt;/code&gt; . Эти функции предназначены для вызова из других приложений, когда в вашем приложении есть интересные &lt;code&gt;Events&lt;/code&gt; , которые необходимо выделить. Функции очень легкие, так как они ничего не делают, кроме возврата атома. Эти функции специально разработаны для отслеживания. Поскольку вызывающий объект явно предоставляет значения для полей &lt;code&gt;Event Record&lt;/code&gt; , &lt;code&gt;Collector Filter&lt;/code&gt; по умолчанию может автоматически предоставлять настроенную &lt;code&gt;Event Record&lt;/code&gt; без каких-либо пользовательских функций фильтрации.</target>
        </trans-unit>
        <trans-unit id="d72fdffcde207532623f4383c3bcc9252d8eb8ee" translate="yes" xml:space="preserve">
          <source>In order to implement delay of thread progress from unmanaged threads we use two reference counters. One being &lt;code&gt;current&lt;/code&gt; and one being &lt;code&gt;waiting&lt;/code&gt;. When an unmanaged thread wants to delay thread progress it increments &lt;code&gt;current&lt;/code&gt; and gets a handle back to the reference counter it incremented. When it later wants to enable continuation of thread progress it uses the handle to decrement the reference counter it previously incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fc72bd9eea1c19e5c0da63c18725fd1977b35e" translate="yes" xml:space="preserve">
          <source>In order to improve this, state information was re-organized in the port structer, so that we can access it using atomic memory operations. This together with the new port table implementation, enabled us to lookup the port and inspect the state before acquiring the port lock, which in turn made it possible to perform preparations of signal data before acquiring the port lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">Для того,чтобы сделать Xref простым в использовании,существуют предопределенные анализы,которые выполняют некоторые общие задачи.Как правило,модуль или релиз могут быть проверены на вызовы к неопределенным функциям.Для более продвинутого пользователя существует небольшой,но достаточно гибкий язык,который может быть использован для выбора частей анализируемой системы и для выполнения некоторого простого анализа графиков выбранных вызовов.</target>
        </trans-unit>
        <trans-unit id="aea5444714eb91d126874c6a93a730087a09d9a5" translate="yes" xml:space="preserve">
          <source>In order to migrate carriers between allocator instances we move them through a pool of carriers. In order for a carrier migration to complete, one scheduler needs to move the carrier into the pool, and another scheduler needs to take the carrier out of the pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">Для того,чтобы подготовить МП к отправке начального сообщения,надеюсь,запрос на изменение услуги,необходимо выполнить следующие действия:</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">Для того,чтобы подготовить МПК к приему исходного сообщения,надеюсь,запрос на изменение сервиса,необходимо выполнить следующее:</target>
        </trans-unit>
        <trans-unit id="45fb88d2abad8087318cf9186878fe028a795bdf" translate="yes" xml:space="preserve">
          <source>In order to prevent multiple schedulers from trying to execute signals to/from the same port simultaneously, we need to be able to ensure that all signals to/from a port are executed in sequence on one scheduler. More or less, the only way to do this is to schedule all types of signals. Signals corresponding to a port can then be executed in sequence by one single scheduler thread. If only one thread tries to execute the port, no contention will appear on the port lock. Besides getting rid of the contention, processes sending signals to the port can also continue execution of their own Erlang code on other schedulers at the same time as the signaling code is executing on another scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403d69677374c07e6c15d9b1403b168e3385a4f8" translate="yes" xml:space="preserve">
          <source>In order to prevent scenarios like this we've implemented support for migration of multi-block carriers between allocator instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">Для обеспечения решения масштабируемых реализаций MG и MGC,пользователь может быть распределен по нескольким узлам Erlang.Один из узлов Erlang подключен к физическому сетевому интерфейсу,но сообщения могут отправляться с других узлов,а ответы автоматически пересылаются обратно на исходный узел.</target>
        </trans-unit>
        <trans-unit id="9b7d500551c4dcb114f3424b88510f43e715d2cf" translate="yes" xml:space="preserve">
          <source>In order to reduce contention due to locking of allocator instances we introduced completely lock free instances tied to each scheduler thread, and an extra locked instance for other threads. The scheduler threads in the system is expected to do the major part of the work. Other threads may still be needed but should not perform any major and/or time critical work. The limited amount of contention that appears on the locked allocator instance can more or less be disregarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f092b8785b0c724e3673cc03096bbd3fea047bff" translate="yes" xml:space="preserve">
          <source>In order to retrieve keylog information on a TLS 1.3 connection, it must be configured in advance to keep the client_random and various handshake secrets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">Чтобы просмотреть подробные детали &lt;code&gt;Event&lt;/code&gt; вы можете щелкнуть по &lt;code&gt;Event&lt;/code&gt; , чтобы запустить средство &lt;code&gt;Contents Viewer&lt;/code&gt; для этого &lt;code&gt;Event&lt;/code&gt; . В &lt;code&gt;Contents Viewer&lt;/code&gt; также есть меню фильтров, которое позволяет просматривать &lt;code&gt;Event&lt;/code&gt; из других представлений, кроме того, которое выбрано в средстве просмотра. Щелчок на &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; вызовет &lt;code&gt;Contents Viewer&lt;/code&gt; окно выскочит, показывая &lt;code&gt;Event&lt;/code&gt; в &lt;code&gt;mgr_actors&lt;/code&gt; просмотр:</target>
        </trans-unit>
        <trans-unit id="dbccfc8cfa22ee2e381053c5b4b92eaa192ba4f4" translate="yes" xml:space="preserve">
          <source>In order to set a different socket path the &lt;code id=&quot;SOCKET_PATH&quot;&gt;socket_path&lt;/code&gt; option can be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ff9cab23ed1e1a7df0e6479aae0e38297e97c3" translate="yes" xml:space="preserve">
          <source>In order to solve this, we introduced a new busy feature, namely &quot;busy port queue&quot;. The port has a limit of &lt;code&gt;command&lt;/code&gt; data that is allowed to be enqueued in the task queue. When this limit is reached, the port will automatically enter a busy port queue state. When in this state, senders of &lt;code&gt;command&lt;/code&gt; signals will be suspended, but &lt;code&gt;command&lt;/code&gt; signals will still be delivered to the port unless it is also in a busy port state. This limit is known as the high limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e67fa06e1bd38aa13f81fc5e8041b9e05f7af4" translate="yes" xml:space="preserve">
          <source>In order to test modifications of the process table we ran a couple of benchmarks where lots of processes are spawned and terminated simultaneously, and got a speedup of between 150-200%. Running a similar benchmark but with ports we got a speedup of about 130%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать систему тегов, необходимо создать файл с именем &lt;code&gt;TAGS&lt;/code&gt; . Файл можно рассматривать как базу данных по всем функциям, записям и макросам во всех файлах проекта. &lt;code&gt;TAGS&lt;/code&gt; файл может быть создан с использованием двух различных методов Erlang. Первая - это стандартная утилита Emacs etags, вторая - с использованием &lt;code&gt;tags&lt;/code&gt; модуля Erlang .</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">В наших измерениях мы увидели,что между ASN.1 BER и компактным текстовым форматом нет значительных различий в размерах сообщений.Немного внимания следует уделить использованию красивого текстового стиля (который используется во всех примерах,включенных в спецификацию протокола,и предпочтительнее во время сеансов отладки),так как в этом случае сообщения могут быть довольно большими.Если размер сообщения действительно является серьезной проблемой,следует использовать наш кодировщик,так как формат ASN.1 PER намного компактнее,чем все другие альтернативы.Его основным недостатком является то,что он не был одобрен в качестве действительной кодировки сообщений Megaco/H.248.</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">На практике наборы объектов обычно объявляются расширяемыми,так что позже в набор можно будет добавить больше объектов.Расширяемость указывается следующим образом:</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">В предыдущих версиях &lt;code&gt;file&lt;/code&gt; режимы указывались как один из атомов &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; или &lt;code&gt;read_write&lt;/code&gt; вместо списка. Это все еще разрешено по причинам обратной совместимости, но не должно использоваться для нового кода. Также обратите внимание, что &lt;code&gt;read_write&lt;/code&gt; не допускается в списке режимов.</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">В принципе, эта функция вызывает функцию &lt;code&gt;process_received_message/4&lt;/code&gt; через &lt;code&gt;spawn&lt;/code&gt; для выполнения фактической обработки.</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">В протоколах, которые поддерживают инициируемое клиентом повторное согласование, стоимость ресурсов для такой операции выше для сервера, чем для клиента. Это может действовать как вектор для атак типа &amp;laquo;отказ в обслуживании&amp;raquo;. Приложение SSL уже принимает меры для противодействия таким попыткам, но инициируемое клиентом повторное согласование можно строго отключить, установив для этого параметра значение &lt;code&gt;false&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; . Обратите внимание, что отключение повторного согласования может привести к тому, что долгоживущие соединения станут непригодными для использования из-за ограничений на количество сообщений, которые базовый набор шифров может зашифровать.</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">В редких случаях эта функция может не работать на Unix.Она может произойти,если права на чтение не существует для родительских каталогов текущей директории.</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">В действительности модели данных редко полностью нормализуются. Реалистичной альтернативой нормализованной модели базы данных была бы модель данных, которая даже не находится в первой нормальной форме. &lt;code&gt;Mnesia&lt;/code&gt; подходит для таких приложений, как телекоммуникации, потому что в нем легко организовать данные гибким образом. &lt;code&gt;Mnesia&lt;/code&gt; база данных всегда организована в виде набора таблиц. Каждая таблица заполнена строками, объектами и записями. Что отличает &lt;code&gt;Mnesia&lt;/code&gt; ,так это то, что отдельные поля в записи могут содержать любой тип составных структур данных. Отдельное поле в записи может содержать списки, кортежи, функции и даже код записи.</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">В сценарии 1 процесс тестового примера завершается нормально после того, как &lt;code&gt;case A&lt;/code&gt; завершил выполнение своего тестового кода без обнаружения каких-либо ошибок. Функция тестового примера возвращает значение, а &lt;code&gt;Common Test&lt;/code&gt; регистрирует тестовый пример как успешный.</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">В сценарии 2 во время выполнения тестового &lt;code&gt;case B&lt;/code&gt; обнаруживается ошибка . Это приводит к тому, что функция тестового &lt;code&gt;case B&lt;/code&gt; генерирует исключение, и в результате процесс тестового примера завершается по иной причине, чем нормальная. &lt;code&gt;Common Test&lt;/code&gt; регистрирует это как неудачный (неуспешный) тестовый пример.</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В разделе о мифах был разоблачен следующий миф: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">Короче говоря, &lt;code&gt;DebugType&lt;/code&gt; предназначен только для отладки. Бревна в процессе производства лучше производить на стандартных лесозаготовительных установках Erlang.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">В некоторых приложениях игнорирование ответов из отдельных журналов может быть недопустимым. Альтернативой в таких ситуациях является использование нескольких журналов локального диска вместо одного журнала распределенного диска и реализация распределения без использования модуля &lt;code&gt;disk_log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">В некоторых аспектах компилятор Erlang MIB не следует и не реализует SMI полностью.Вот в чем разница:</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">В некоторых аспектах агент не реализует SNMP полностью.Вот в чем разница:</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">В некоторых случаях правила синтаксиса Эрланга делают невозможным размещение метапеременной непосредственно там,где вам хотелось бы.Например,вы не можете писать:</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">В некоторых случаях операции выбора / сопоставления не требуют сканирования всей таблицы. Например, если часть ключа связана при поиске в таблице &lt;code&gt;ordered_set&lt;/code&gt; , или если это таблица Mnesia и есть вторичный индекс в поле, которое выбрано / сопоставлено. Если ключ полностью привязан, нет смысла делать выбор / сопоставление, если у вас нет таблицы пакетов и вас интересует только подмножество элементов с определенным ключом.</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">В некоторых контекстах допускается только строка или целое число. Например, директива &lt;code&gt;-file(Name, Line)&lt;/code&gt; требует, чтобы &lt;code&gt;Name&lt;/code&gt; был строковым литералом, а &lt;code&gt;Line&lt;/code&gt; - целочисленным литералом:</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;locked&lt;/code&gt; состоянии , когда кнопка нажата, она собирается с последними нажатыми кнопками до длины правильного кода и сравнивается с правильным кодом. В зависимости от результата дверь либо разблокируется, и &lt;code&gt;gen_statem&lt;/code&gt; переходит в состояние &amp;laquo; &lt;code&gt;open&lt;/code&gt; , либо дверь остается в состоянии &amp;laquo; &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;open&lt;/code&gt; состоянии событие кнопки игнорируется, так как остается в том же состоянии. Это также можно сделать, вернув &lt;code&gt;{keep_state, Data}&lt;/code&gt; или, в этом случае, поскольку &lt;code&gt;Data&lt;/code&gt; изменились, даже путем возврата &lt;code&gt;keep_state_and_data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96ad0dfc8fa4580e2165853ef7429bd0d01832d6" translate="yes" xml:space="preserve">
          <source>In systems which create and delete &lt;strong&gt;many&lt;/strong&gt; sockets dynamically, it (the socket registry) could become a bottleneck. For such systems, there are a couple of ways to control the use of the socket registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">В системах с большим количеством процессов вычислительные задачи, которые выполняются в течение короткого времени, могут быть перенесены в новый процесс с более высоким минимальным размером кучи. Когда процесс завершен, он отправляет результат вычисления другому процессу и завершается. Если минимальный размер кучи рассчитан правильно, процессу, возможно, вообще не придется выполнять сборку мусора. &lt;strong&gt;Эту оптимизацию нельзя проводить без надлежащих измерений.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">В телекоммуникационных приложениях потребности отличаются от возможностей,предоставляемых традиционными СУБД.Приложения,реализованные в настоящее время в Erlang,нуждаются в сочетании широкого спектра возможностей,которые,как правило,не удовлетворяются традиционными СУБД.Mnesia разработана с учетом следующих требований:</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">В 32-битной реализации Erlang 536 870 911 байт - это самый большой двоичный файл, который может быть создан или сопоставлен с использованием битового синтаксиса. В 64-битной реализации максимальный размер составляет 2 305 843 009 213 693 951 байт. Если предел превышен, построение битового синтаксиса завершается ошибкой с исключением &lt;code&gt;system_limit&lt;/code&gt; , в то время как любая попытка сопоставить слишком большой двоичный файл терпит неудачу. Это ограничение действует начиная с R11B-4.</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">В &lt;code&gt;MatchBody&lt;/code&gt; и &lt;code&gt;MatchCondition&lt;/code&gt; можно использовать только ранее связанные переменные.</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">В &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; не разрешены никакие несвязанные переменные, поэтому &lt;code&gt;'_'&lt;/code&gt; интерпретируется как сам (атом). Переменные могут быть связаны только в части &lt;code&gt;MatchHead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">В &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; интерпретация в некоторой степени отличается. Литералы в этих частях могут быть записаны &amp;laquo;как есть&amp;raquo;, что работает для всех литералов, кроме кортежей, или с использованием специальной формы &lt;code&gt;{const, T}&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - любой терм Эрланга.</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">В части &lt;code&gt;MatchHead&lt;/code&gt; все литералы (кроме переменных выше) интерпретируются &amp;laquo;как есть&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="62822ca5758004378978f550b70109b8f746b1ba" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;compiler&lt;/code&gt; application, in the file &lt;code&gt;genop.tab&lt;/code&gt;, there is the following line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;do_perm&lt;/code&gt; мы выполняем работу, работая со структурой, которая была выделена на &lt;code&gt;output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;ets:fun2ms/1&lt;/code&gt; необходимо включить &lt;code&gt;ms_transform.hrl&lt;/code&gt; в исходный код, так как именно он запускает преобразование синтаксического анализа вызова &lt;code&gt;ets:fun2ms/1&lt;/code&gt; в допустимую спецификацию соответствия. Это также означает, что преобразование выполняется во время компиляции (кроме случаев, когда оно вызывается из оболочки) и поэтому не требует ресурсов во время выполнения. То есть, хотя вы используете более интуитивно понятный забавный синтаксис, он становится таким же эффективным во время выполнения, как и ручное написание спецификаций соответствия.</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">В &lt;code&gt;main&lt;/code&gt; функции программа C должна прослушивать сообщение от Erlang и, в соответствии с выбранной схемой кодирования / декодирования, использовать первый байт, чтобы определить, какую функцию вызывать, и второй байт в качестве аргумента функции. Результат вызова функции должен быть отправлен обратно в Erlang:</target>
        </trans-unit>
        <trans-unit id="a69877ecee07d6d60ef5a7f12b95eb172cfc8ddd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;option&lt;/code&gt; info tuple are only the options included that differs from the default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">В функции &lt;code&gt;ready_async&lt;/code&gt; вывод отправляется обратно в эмулятор. Мы используем формат термина драйвера вместо &lt;code&gt;ei&lt;/code&gt; . Это единственный способ отправить термины Erlang напрямую драйверу, не имея кода Erlang для вызова &lt;code&gt;binary_to_term/1&lt;/code&gt; . В простом примере это работает хорошо, и нам не нужно использовать &lt;code&gt;ei&lt;/code&gt; для обработки двоичного формата термина.</target>
        </trans-unit>
        <trans-unit id="262d5d76fc96e92282d6cd6556cb095d00a57bcd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ssh.app&lt;/code&gt; file, in the &lt;code&gt;env&lt;/code&gt; part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">В API Megaco пользователь может явно посылать запросы на действия,но генерация идентификаторов транзакций,кодировка и фактическая передача сообщения удаленному пользователю обрабатывается автоматически протокольным движком в соответствии с фактической конфигурацией соединения.Сообщения Megaco не отображаются в API.</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">В системе времени выполнения Erlang объекты выполняются параллельно только при наличии нескольких планировщиков. Поэтому &lt;code&gt;lcnt&lt;/code&gt; будет показывать больше конфликтных точек (и, следовательно, будет более полезен) в системах, использующих множество планировщиков на многих ядрах.</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">В приложении Kernel:</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">В таблицах Мнезии два ключевых столбца хранятся в виде кортежа с двумя элементами.Таким образом,arity таблицы 3.</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">В совместимой с POSIX.2 библиотеке, которая была включена в 4.4BSD Unix, уродливый синтаксис [[: &amp;lt;:]] и [[:&amp;gt;:]] используется для сопоставления &amp;laquo;начала слова&amp;raquo; и &amp;laquo;конца слова&amp;raquo;. PCRE рассматривает эти предметы следующим образом:</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">В PRF (псевдослучайная функция)для генерации кеинга материалов в наборах шифров,не использующих PFS.</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">В приложении SSL в качестве альтернативы можно использовать дополнительный модуль распространения, &lt;code&gt;inet_tls_dist&lt;/code&gt; . Все соединения распределения будут использовать TLS, и все участвующие узлы Erlang в распределенной системе должны использовать этот модуль распределения.</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">В приложении STDLIB:</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">В приведенном выше примере &amp;laquo;pong&amp;raquo; был впервые создан, чтобы иметь возможность идентифицировать &amp;laquo;pong&amp;raquo; при запуске &amp;laquo;ping&amp;raquo;. То есть каким-то образом &amp;laquo;ping&amp;raquo; должен иметь возможность узнать личность &amp;laquo;pong&amp;raquo;, чтобы иметь возможность отправить ему сообщение. Иногда процессы, которым необходимо знать личности друг друга, запускаются независимо друг от друга. Таким образом, Erlang предоставляет механизм для присвоения имен процессам, чтобы эти имена можно было использовать в качестве идентификаторов вместо идентификаторов. Это делается с помощью &lt;code&gt;register&lt;/code&gt; BIF:</target>
        </trans-unit>
        <trans-unit id="e32e6dd34c52e0e8f5c4ffcf8e60b4a055b8ae5e" translate="yes" xml:space="preserve">
          <source>In the above example, the small binary &lt;code&gt;B&lt;/code&gt; was copied while the larger binary &lt;code&gt;C&lt;/code&gt; references binary &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd30adfebd9b33e07add4e9cc9b71db937dd48cf" translate="yes" xml:space="preserve">
          <source>In the absence of spawn operation failures, atomically sets up a monitor to the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor(process, Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. The &lt;code&gt;ReqId&lt;/code&gt; returned by &lt;code&gt;spawn_request()&lt;/code&gt; is also used as monitor reference as if it was returned from &lt;code&gt;monitor(process, Pid)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">В базовом сценарии каждый пользователь загружает драйвер перед началом его использования и выгружает драйвер по окончании.Счетчик ссылок отслеживает процессы и количество загрузок по каждому процессу.Таким образом,драйвер выгружается только тогда,когда его никто не хочет (у него нет пользователя).Драйвер также отслеживает открытые для него порты.Это позволяет задержать выгрузку до тех пор,пока все порты не будут закрыты,или убить все порты,которые используют драйвер,когда он выгружается.</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">В вышеприведенном случае файл извлекается из того же каталога,что и все остальные файлы в примере мессенджера.(*manual*).</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">В случае обновления &lt;code&gt;OldVsn&lt;/code&gt; будет &lt;code&gt;Vsn&lt;/code&gt; , а в случае &lt;code&gt;OldVsn&lt;/code&gt; на более раннюю версию OldVsn будет &lt;code&gt;{down,Vsn}&lt;/code&gt; . &lt;code&gt;Vsn&lt;/code&gt; определяется атрибутом (ами) &lt;code&gt;vsn&lt;/code&gt; старой версии модуля обратного вызова &lt;code&gt;Module&lt;/code&gt; . Если такой атрибут не определен, версией является контрольная сумма файла BEAM.</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае ответа megaco отменит ответ, и информация об этом будет возвращена пользователю через вызов функции обратного вызова &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае запросов мегако отменит сообщение почти так же, как если бы было &lt;code&gt;megaco:cancel&lt;/code&gt; (после успешной отправки). Информация будет передаваться обратно пользователю по-разному, в зависимости от того, как были &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; запросы: для запросов, отправленных с помощью megaco: call , информация будет доставлена ​​в виде возвращаемого значения. Для запросов, &lt;code&gt;megaco:cast&lt;/code&gt; с использованием megaco: cast, информация будет доставлена ​​через вызов функции обратного вызова &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">В случае, если местом &lt;code&gt;Destination&lt;/code&gt; является &lt;code&gt;File&lt;/code&gt; , печатаемые события трассировки мегако будут напечатаны в файл &lt;code&gt;File&lt;/code&gt; с использованием простого &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">В случае, если &lt;code&gt;Destination&lt;/code&gt; - &lt;code&gt;io&lt;/code&gt; , печатаемые события трассировки мегако будут напечатаны на stdout с использованием простого &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3e58c5c2505dec49b18b9e8525ca602801333f" translate="yes" xml:space="preserve">
          <source>In the case when its not possible to immediately establish a connection, the function will return with the &lt;code&gt;&lt;a href=&quot;#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;, a subsequent call to connect will then establish the connection).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">В случае, когда тип pdu - &lt;code&gt;report&lt;/code&gt; , &lt;code&gt;MsgData&lt;/code&gt; либо в &lt;code&gt;ok&lt;/code&gt; либо &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42c6fc4cd12daba8d11cdd4982445015e66db822" translate="yes" xml:space="preserve">
          <source>In the case when there is no connections waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when a client connects (a subsequent call to accept will then return the socket).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b308070b86e9f2f5cfb71e46c5c56ad9f43c5a" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recv will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c310b42286356d0fc14eede396b80bde97e8a3eb" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvfrom will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a9e35d675f34065de5084906faf62c1cb4d28b" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvmsg will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79128b360c469ba004c95bafdca01e1b34773296" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to send will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a00bf019c9ad7cc3ae0aa6563d03144ab91886" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendmsg will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67338ab252943970a15e1afbfd3aa9bc7bd17164" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendto will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">Во фрагменте кода в начале этого раздела добавление в &lt;code&gt;Bin&lt;/code&gt; будет дешевым, а добавление в &lt;code&gt;Bin0&lt;/code&gt; вызовет создание нового двоичного &lt;code&gt;Bin0&lt;/code&gt; и копирование содержимого Bin0 .</target>
        </trans-unit>
        <trans-unit id="245dbc6eca2c173af60f0ff749e12a7fd20aabc1" translate="yes" xml:space="preserve">
          <source>In the configuration above we first raise the primary log level to max in order for the debug log events to get to the handlers. Then we configure the default handler to only log notice and below events, the default log level for a handler is &lt;code&gt;all&lt;/code&gt;. Then the debug handler is configured with a filter to stop any log message that is not a debug level message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">В файле спецификации обложки вы также можете указать необходимый вам уровень анализа покрытия кода; &lt;code&gt;details&lt;/code&gt; или &lt;code&gt;overview&lt;/code&gt; . В подробном режиме вы получаете страницу обзора покрытия, показывающую по модулям и общему проценту покрытия. Вы также получаете распечатанный HTML-файл для каждого модуля, включенного в анализ, с точным указанием того, какие части кода были выполнены во время теста. В режиме обзора печатается только страница обзора покрытия кода.</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">В текущей версии &lt;code&gt;Common Test&lt;/code&gt; функция &lt;code&gt;silent_connections&lt;/code&gt; работает только для подключений Telnet и SSH. Поддержка других типов подключения может быть добавлена ​​в будущих версиях &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В текущей реализации привязки Erlang / SCTP это событие внутренне преобразуется в термин &lt;code&gt;error&lt;/code&gt; возвращаемый &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">В текущей реализации каждая операция вставки и поиска объекта приводит к созданию его копии.</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">В текущей версии &lt;code&gt;CurVsn&lt;/code&gt; выпуска каталог приложения &lt;code&gt;myapp&lt;/code&gt; - это &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; . Новая версия &lt;code&gt;NewVsn&lt;/code&gt; распаковывается за пределами обработчика выпуска, и обработчик выпуска информируется об этом с помощью следующего вызова:</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">В каталоге данных &lt;code&gt;data_dir&lt;/code&gt; тестовый модуль имеет свои собственные файлы, необходимые для тестирования. Имя &lt;code&gt;data_dir&lt;/code&gt; - это имя набора тестов, за которым следует &lt;code&gt;&quot;_data&quot;&lt;/code&gt; . Например, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; имеет каталог данных &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; . Используйте этот каталог для переносимости, то есть, чтобы избежать жесткого кодирования имен каталогов в вашем наборе. Поскольку каталог данных хранится в том же каталоге, что и ваш набор тестов, вы можете полагаться на его существование во время выполнения, даже если путь к каталогу вашего набора тестов изменился между реализацией набора тестов и выполнением.</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">В приведенных ниже описаниях перечислена форма,которая используется для изменения значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">В окне подробной информации для узла отображаются все существующие связи и мониторы между процессами на исходном узле и подключенном узле. &lt;strong&gt;Дополнительная информация&lt;/strong&gt; может содержать отладочную информацию (то есть специальную информацию, записанную, если эмулятор компилируется отладкой) или информацию об ошибках.</target>
        </trans-unit>
        <trans-unit id="8ba5880443f43a3af428d4fbb8404826ac0d26fd" translate="yes" xml:space="preserve">
          <source>In the end, the C compiler will probably optimize this code to the same native code as the first version, but the first version is certainly much easier to read for human readers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e4ef55ecc440a106bcf9a15acab47c72a79a18" translate="yes" xml:space="preserve">
          <source>In the erl command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe10364408e4f6b1e20c24b12efb18fb322cbcc9" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period are to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">В диспетчере &lt;strong&gt;событий&lt;/strong&gt; установлено ноль, один или несколько &lt;strong&gt;обработчиков событий&lt;/strong&gt; . Когда диспетчер событий получает уведомление о событии, событие обрабатывается всеми установленными обработчиками событий. Например, в диспетчере событий для обработки ошибок по умолчанию может быть установлен обработчик, который записывает сообщения об ошибках в терминал. Если сообщения об ошибках в течение определенного периода также должны быть сохранены в файл, пользователь добавляет другой обработчик событий, который делает это. Когда регистрация в файл больше не требуется, этот обработчик событий удаляется.</target>
        </trans-unit>
        <trans-unit id="8841b315d1e28c3d331ee376f7a7d69baa5c6c9d" translate="yes" xml:space="preserve">
          <source>In the example above the &lt;code&gt; &lt;strong&gt;on_load&lt;/strong&gt;&lt;/code&gt; directive is used get function &lt;code&gt;init&lt;/code&gt; called automatically when the module is loaded. Function &lt;code&gt;init&lt;/code&gt; in turn calls &lt;code&gt;&lt;a href=&quot;erlang#load_nif-2&quot;&gt;erlang:load_nif/2&lt;/a&gt;&lt;/code&gt; which loads the NIF library and replaces the &lt;code&gt;hello&lt;/code&gt; function with its native implementation in C. Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">В приведенном выше примере допустимыми &lt;code&gt;keys&lt;/code&gt; могут быть &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; и &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; , тогда как &lt;code&gt;&quot;hi&quot;&lt;/code&gt; , &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; и &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; будет недействительным.</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">В примере ниже строки под номерами 2,4,6,8 и 11 являются исполняемыми:</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">В примере из предыдущего раздела &lt;code&gt;gen_server&lt;/code&gt; запускается путем вызова &lt;code&gt;ch3:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">В примере из предыдущего раздела &lt;code&gt;gen_statem&lt;/code&gt; запускается вызовом &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">В примере представлены идентификаторы &lt;code&gt;example.com&lt;/code&gt; , а также имена хостов, соответствующие &lt;code&gt;*.example.com&lt;/code&gt; . Например, &lt;code&gt;foo.example.com&lt;/code&gt; и &lt;code&gt;bar.example.com&lt;/code&gt; совпадают, но не &lt;code&gt;foo.bar.example.com&lt;/code&gt; . Имя &lt;code&gt;erlang.org&lt;/code&gt; не совпадает ни с одним, так как это не CN.</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">В этом примере &lt;code&gt;handle_debug&lt;/code&gt; вызывается для каждого входящего и исходящего сообщения. Функция форматирования &lt;code&gt;Func&lt;/code&gt; - это функция &lt;code&gt;ch4:write_debug/3&lt;/code&gt; , которая печатает сообщение с использованием &lt;code&gt;io:format/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В этом примере выбирается &lt;code&gt;number&lt;/code&gt; компонента первого из закодированных элементов в &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; . Это применимо к спецификации ASN.1 в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">В этом примере оператор &lt;code&gt;==/2&lt;/code&gt; обрабатывается точно так же, как и &lt;code&gt;=:=/2&lt;/code&gt; . Однако, если он не может быть определен во время компиляции , что некоторая константа не содержит целые числа, и таблицу использует &lt;code&gt;=:=/2&lt;/code&gt; при сравнении ключей для равенства (см варианта &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; ), то &lt;code&gt;qlc&lt;/code&gt; модуль не пытается искать постоянный , Причина в том, что в общем случае не существует верхнего предела количества значений ключа, которые могут быть сопоставлены с такой константой; необходимо искать каждую комбинацию целых чисел и чисел с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">В примере используется синхронный запуск. Процесс начинается с вызова &lt;code&gt;ch4:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">В этом примере простое имя узла - &lt;code&gt;c1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">В примере:</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">В примерах вы можете видеть, что оболочка Erlang по умолчанию интерпретирует только символы из диапазона ISO Latin1 как печатные и обнаруживает только списки или двоичные файлы с этими &amp;laquo;печатными&amp;raquo; символами как содержащие строковые данные. Действительный двоичный код UTF-8, содержащий русское слово &amp;laquo;Юникод&amp;raquo;, не печатается в виде строки. При запуске со всеми печатаемыми символами Unicode ( &lt;code&gt;+pc unicode&lt;/code&gt; ) оболочка выводит все, что содержит печатаемые данные Unicode (в двоичных файлах, в кодировке UTF-8 или побайтно) в виде строковых данных.</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">При обмене DH-параметрами в наборах шифров,обеспечивающих неанонимную PFS (совершенную прямую секретность).</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">В первой форме вызовов функций, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; , каждое из &lt;code&gt;ExprM&lt;/code&gt; и &lt;code&gt;ExprF&lt;/code&gt; должно быть атомом или выражением, которое оценивается как атом. Говорят, что функция вызывается с использованием &lt;strong&gt;полного имени функции&lt;/strong&gt; . Это часто называют &lt;strong&gt;удаленным&lt;/strong&gt; или &lt;strong&gt;внешним вызовом функции&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f6d99757df807bd06e120fa43c0767f20375e1c3" translate="yes" xml:space="preserve">
          <source>In the first section (&lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt;), actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that &lt;strong&gt;callback module&lt;/strong&gt;&lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">В первом разделе действия &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; упоминались как часть общей модели конечного автомата. Эти общие действия реализуются с помощью кода, который модуль обратного вызова &lt;code&gt;gen_statem&lt;/code&gt; выполняет в функции обратного вызова обработки событий перед возвратом в механизм &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">В первом слове (4 байта) &lt;code&gt;ID&lt;/code&gt; значимы только 18 бит, остальные должны быть равны 0. В &lt;code&gt;Creation&lt;/code&gt; значимы только два бита, остальные должны быть равны 0.</target>
        </trans-unit>
        <trans-unit id="5e047fa558c6b3687797900dae4cc1f9d07908ea" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest must be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">В следующих описаниях использование слова &amp;laquo; &lt;strong&gt;Точка&amp;raquo;&lt;/strong&gt; означает: &amp;laquo;Точку можно рассматривать как позицию курсора. Точнее, точка - это позиция между двумя символами, в то время как курсор наведен на символ, следующий за точкой&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">В следующих описаниях &lt;strong&gt;групповой узел&lt;/strong&gt; - это узел, принадлежащий той же глобальной группе, что и локальный узел.</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">В следующих описаниях все функции выходят из строя по причине &lt;code&gt;badarg&lt;/code&gt; , если &lt;code&gt;heart&lt;/code&gt; не запускается.</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">В следующем примере QLC &lt;code&gt;V2&lt;/code&gt; был вставлен, чтобы показать объединенные генераторы и выбранный метод объединения. Для соединения поиска используется соглашение: первый генератор ( &lt;code&gt;G2&lt;/code&gt; ) - это тот, который прошел, второй ( &lt;code&gt;G1&lt;/code&gt; ) - это таблица, в которой ищутся константы.</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">В следующем примере кэшированных результаты слияния перемещаются для каждого значения &lt;code&gt;A&lt;/code&gt; . Обратите внимание , что без опции &lt;code&gt;cache&lt;/code&gt; объединения будет проведено три раза, один раз для каждого значения &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">В следующем примере создаются два процесса,которые посылают сообщения друг другу несколько раз.</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">В следующем примере два простых QLC вставляются только для хранения опции &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">В следующем примере с помощью этой программы узлы запускаются на четырех разных компьютерах.Если в вашей сети не так много машин,вы можете запустить несколько узлов на одной машине.</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">В следующем примере &lt;code&gt;Common Test&lt;/code&gt; находит и выполняет два теста: один для пути от &lt;code&gt;top2&lt;/code&gt; к &lt;code&gt;sub2X2&lt;/code&gt; через &lt;code&gt;sub21&lt;/code&gt; , а &lt;code&gt;top2&lt;/code&gt; от top2 к &lt;code&gt;sub2X2&lt;/code&gt; через &lt;code&gt;sub22&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">В следующем примере &lt;code&gt;{Pid, hello_world}&lt;/code&gt; отправляется зарегистрированному процессу &lt;code&gt;my_server&lt;/code&gt; . Сообщение кодируется &lt;code&gt;erl_send()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b55abcde93dfcf59993923892aaa3fe74b62110" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">В следующем примере при указании уникального пути &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; только один тест. Второй возможный путь от &lt;code&gt;top2&lt;/code&gt; к &lt;code&gt;sub2X2&lt;/code&gt; (из предыдущего примера) отбрасывается:</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">В следующем примере функция &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; используется как триггер для последовательной трассировки:</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">В следующем примере строки 2,4,6,8 и 11 являются исполняемыми строками:</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">В следующем примере используются модули &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">В следующем примере BIF &lt;code&gt;self()&lt;/code&gt; возвращает pid вызывающего процесса:</target>
        </trans-unit>
        <trans-unit id="5409dc0e8a019858263b90292ca1f90716b01a8e" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies as Erlang messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">В следующем примере оболочка Erlang является клиентским процессом,который получает ответы по каналу.</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">В следующем примере используется эта спецификация ASN.1:</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">В следующем примере установлены два обработчика событий для теста &lt;code&gt;my_SUITE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">В следующем примере с использованием модуля &lt;code&gt;gb_table&lt;/code&gt; из раздела &amp;laquo; &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; можно найти шесть ключей: &lt;code&gt;{1,a}&lt;/code&gt; , &lt;code&gt;{1,b}&lt;/code&gt; , &lt;code&gt;{1,c}&lt;/code&gt; , &lt;code&gt;{2,a}&lt;/code&gt; , &lt;code&gt;{2,b}&lt;/code&gt; и &lt;code&gt;{2,c}&lt;/code&gt; . Причина в том, что два элемента ключа &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; сравниваются отдельно.</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">В следующих примерах мы используем XML-файл &quot;motorcycles.xml&quot; и соответствующий DTD &quot;motorcycles.dtd.&quot;,как выглядит enginecycles.xml:</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">На следующем рисунке только отмеченный элемент декодируется &lt;code&gt;selected_decode_Window2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">На следующем рисунке в квадратных ящиках изображены руководители,а в кружках-рабочие:</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">В следующем списке флаги инициализации помечены как &amp;laquo;(флаг инициализации)&amp;raquo;. Если не указано иное, все другие флаги являются пользовательскими флагами, значения которых можно получить, вызвав &lt;code&gt;init:get_argument/1&lt;/code&gt; . Обратите внимание, что список пользовательских флагов не является исчерпывающим, может быть больше специфических для приложения флагов, которые вместо этого описаны в соответствующей документации приложения.</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">В следующих разделах описываются эти темы:</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">В следующих разделах мы как можно подробнее описали установку необходимых инструментов.Как только инструменты установлены,построить их довольно просто.Мы также постарались сделать эти инструкции понятными для людей с ограниченным опытом работы с Unix.Cygwin/MSYS/MSYS2-это совершенно новое окружение для некоторых пользователей Windows,почему тщательное объяснение переменных окружения и т.д.казалось бы,было на месте.</target>
        </trans-unit>
        <trans-unit id="1fd2193cd39cfac6403a706b39a45fed6722ffda" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. WSL is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">В следующих ситуациях вы можете легко избежать вызовов &lt;code&gt;lists:flatten/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">В следующих таблицах примеров &lt;code&gt;Data&lt;/code&gt; должны быть списком ввода-вывода. Список ввода-вывода - это двоичный или (возможно, глубокий) список двоичных файлов или целых чисел в диапазоне 0..255:</target>
        </trans-unit>
        <trans-unit id="cded6a813afbe8a22f1a0d31c8b7cd61b0e5883b" translate="yes" xml:space="preserve">
          <source>In the following terms that may cause confusion are explained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">В функциях,определенных ниже,используются следующие типы:</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">В будущем функция отладки, вероятно, будет интегрирована с API потока драйвера Erlang. Все функции, которые создают объекты, принимают аргумент &lt;code&gt;name&lt;/code&gt; . В настоящее время аргумент &lt;code&gt;name&lt;/code&gt; не используется, но он будет использоваться при реализации функции отладки. Если вы правильно назовете все созданные объекты, функция отладки сможет предоставить вам более точные отчеты об ошибках.</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">В сгенерированном сценарии загрузки все каталоги приложений структурированы как &lt;code&gt;App-Vsn/ebin&lt;/code&gt; . Предполагается, что они находятся в &lt;code&gt;$ROOT/lib&lt;/code&gt; , где &lt;code&gt;$ROOT&lt;/code&gt; - корневой каталог установленной версии. Если указан параметр &lt;code&gt;local&lt;/code&gt; , вместо этого используются фактические каталоги, в которых были найдены приложения. Это полезный способ локально протестировать сгенерированный загрузочный скрипт.</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">В последнем примере модуль для анализа был задан в качестве аргумента для &lt;code&gt;m/1&lt;/code&gt; , а путь кода (неявно) использовался как &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; . В этом примере будет использоваться &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; , который позволяет анализировать приложения и выпуски, а также явно выбирать путь к библиотеке.</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">Обратите внимание, что в последней строке кортеж {256,10, -2} представляет собой действительное число 2,56 в специальной записи, которая кодируется быстрее, чем просто указание числа как &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; . Кортеж арности три - это &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; , то есть Мантисса * Основание ^ Экспонента.</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">В списках, которые разделены на две части для двух направлений (см. &lt;code&gt;cipher&lt;/code&gt; ), можно изменить оба направления одновременно:</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">В списках, которые разделены на две части для двух направлений (см. &lt;code&gt;cipher&lt;/code&gt; ), можно изменить только одно из направлений:</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">В цикле,в котором обрабатываются запросы,теперь могут быть обнаружены таймауты отправки:</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">В примере мессенджера не было сделано никаких предположений о том,что посылаемое сообщение.Это может быть любой действительный термин Эрланга.</target>
        </trans-unit>
        <trans-unit id="8edc784c5711aef4324569d61cb733c3b77cb091" translate="yes" xml:space="preserve">
          <source>In the modified lock free version of this approach we more or less do it the same way, but with some important modifications trying to avoid unnecessary contention when multiple schedulers create processes simultaneously. Since multiple threads might be trying to search for the next free slot at the same time from the same starting point we want subsequent slots to be located in different cache lines. Multiple schedulers simultaneously writing new pointers into the table are therefore very likely to write into adjacent slots. If adjacent slots are located in the same cache line all modification of this cache line needs to be communicated between all involved processors which will be very expensive and scale very poor. By locating adjacent slots in different cache lines only true conflicts will trigger communication between involved processors, i.e., avoiding false sharing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">В сообщении монитора &lt;code&gt;MonitorRef&lt;/code&gt; и &lt;code&gt;Type&lt;/code&gt; такие же, как описано ранее, и:</target>
        </trans-unit>
        <trans-unit id="6af58c3bd490620b572e86c6ee20f0568469a3cc" translate="yes" xml:space="preserve">
          <source>In the new design the old wheel was dropped and instead replaced by one struct (&lt;code&gt;GenericBp&lt;/code&gt;) to hold the data for all types of breakpoints for each instrumented function. A bit-flag field is used to indicate what different type of break actions that are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a775ef8f9dc8be5c9fdaee0cab605f0e25c280e" translate="yes" xml:space="preserve">
          <source>In the next garbage collection, any pointers to the old heap will be ignored and not scanned. This way the garbage collector does not have to scan the long-lived terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d0c33ad0d8698789ff1ce734a374e0b8dc46cb" translate="yes" xml:space="preserve">
          <source>In the next word the tagged atom &lt;code&gt;id&lt;/code&gt; is stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">В нормальном случае версия создается как &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; - наиболее значимая часть.</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">При наличии начальных значений для полей,тип должен быть объявлен после инициализации следующим образом:</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">В предыдущем примере нет указания, какие протоколы ожидаются. Таким образом, у клиента нет информации о том, является ли он веб-сервером, сервером ldap или, возможно, сервером sip, к которому он подключен. В сертификате есть поля, которые могут указать это. Чтобы быть более точным, гк представляет использование в &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; в &lt;code&gt;X509v3 extensions&lt;/code&gt; поля:</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">В предыдущем примере команды &amp;laquo;ping&amp;raquo; и &amp;laquo;pong&amp;raquo; запускались из оболочек двух отдельных узлов Erlang. &lt;code&gt;spawn&lt;/code&gt; также можно использовать для запуска процессов на других узлах.</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">В предыдущем примере, если &lt;code&gt;all/0&lt;/code&gt; возвращает ссылки на названия групп в порядке &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; , порядок функций конфигурации и тестовых примеров становится следующим (обратите внимание, что &lt;code&gt;init_per_testcase/2&lt;/code&gt; и &lt;code&gt;end_per_testcase/2:&lt;/code&gt; также всегда вызываются, но не включены в этот пример для упрощения):</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">В предыдущем примере супервизор запускается вызовом &lt;code&gt;ch_sup:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">В предыдущих примерах, используются новые имена переменных, вместо повторного использования старых: &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;TheRest&lt;/code&gt; , &lt;code&gt;E1&lt;/code&gt; , &lt;code&gt;E2&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; . Причина этого в том, что переменной может быть присвоено значение только один раз в ее контексте (области действия). Подробнее об этом позже.</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">В системе времени выполнения с поддержкой SMP драйверы заблокированы либо на уровне драйвера, либо на уровне порта (уровень экземпляра драйвера). По умолчанию будет использоваться блокировка на уровне драйвера, то есть только один поток эмулятора будет выполнять код в драйвере одновременно. Если используется блокировка на уровне порта, несколько потоков эмулятора могут выполнять код в драйвере одновременно. Однако только один поток одновременно будет вызывать обратные вызовы драйвера, соответствующие одному и тому же порту. Чтобы включить блокировку на уровне порта, установите &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; ERL_DRV_FLAG_USE_PORT_LOCKING в &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; используемом драйвером. Когда используется блокировка на уровне порта, разработчик драйвера отвечает за синхронизацию всех обращений к данным, совместно используемым портами (экземплярами драйверов).</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">Во втором примере мы используем функцию обработчика трассировки по умолчанию. Этот обработчик печатает на tty, отправляя запросы ввода-вывода &lt;code&gt;user&lt;/code&gt; процессу. Когда Erlang запускается в режиме oldshell, процесс оболочки будет иметь &lt;code&gt;user&lt;/code&gt; качестве лидера группы, как и процесс трассировки в этом примере. Поскольку &lt;code&gt;user&lt;/code&gt; вызывает функции в &lt;code&gt;lists&lt;/code&gt; мы попадаем в тупик, как только будет отправлен первый запрос ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">Во второй форме вызовов функций &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; , &lt;code&gt;ExprF&lt;/code&gt; должен быть атомом или оценивать как забаву.</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">На диаграмме последовательности актеры (которые символически выполнили &lt;code&gt;Event&lt;/code&gt; ) показаны в виде вертикальных полос с именами. Порядок действий актеров можно изменить, перетащив (удерживая кнопку мыши 1 нажатой во время операции) тег имени актера в другое место:</target>
        </trans-unit>
        <trans-unit id="7823fdfa2d6e99d8afc1d184adab525e34685552" translate="yes" xml:space="preserve">
          <source>In the setup of the SSH connection a secret cipher key is generated by co-operation of the client and the server. Keeping this key secret is crucial for keeping the communication secret. As time passes and encrypted messages are exchanged, the probability that a listener could guess that key increases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">В оболочке, если используется устройство ввода Unicode или в исходном коде, хранящемся в UTF-8, за &lt;code&gt;$&lt;/code&gt; может непосредственно следовать символ Unicode, дающий целое число. В следующем примере выводится кодовая точка кириллицы &lt;code&gt;с&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">В ситуации,когда узел потерял связи с другими узлами своей глобальной группы,но имеет связи с узлами других глобальных групп,запрос от другой глобальной группы может привести к неверному или вводящему в заблуждение результату.Например,изолированный узел может иметь неточную информацию о зарегистрированных именах в своей глобальной группе.</target>
        </trans-unit>
        <trans-unit id="45354ca6d5ea2475e4f281fd6c145d031cdf7187" translate="yes" xml:space="preserve">
          <source>In the supervisor &lt;code&gt;child specification&lt;/code&gt; there is a list of modules which is recommended to contain only the callback module. For a &lt;code&gt;gen_statem&lt;/code&gt; with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade &lt;strong&gt;that&lt;/strong&gt; module whenever a &lt;strong&gt;synchronized code replacement&lt;/strong&gt; is done. Then the release handler concludes that an upgrade that upgrades &lt;strong&gt;that&lt;/strong&gt; module needs to suspend, code change, and resume any server whose child specification declares that it is using &lt;strong&gt;that&lt;/strong&gt; module. And again; the &lt;strong&gt;current&lt;/strong&gt; callback module will get the &lt;code&gt;Module:code_change/4&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34787be2516bd25bc51ccdee0b0ac4c6d7eba78b" translate="yes" xml:space="preserve">
          <source>In the tail part of the data structure we find a pointer to the last element of the list, or at least something that is near the end of the list. In the uncontended case it will point to the end of the list, but when simultaneous insert operations are performed it will point to something near the end of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">В целевом каталоге читает файл &lt;code&gt;releases/start_erl.data&lt;/code&gt; чтобы найти версию системы времени выполнения Erlang (&amp;laquo;5.10.4&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">В кодировке текста у исполнителей есть выбор между короткими и длинными ключевыми словами.Также можно добавлять пробелы для улучшения читабельности.Мы используем термин compact для текстовых сообщений с как можно более короткими ключевыми словами и без необязательных пробельных символов,а термин pretty для хорошо отпечатанного текстового формата с использованием длинных ключевых слов и стиля отступов,как в текстовых примерах в спецификации Megaco/H.248).</target>
        </trans-unit>
        <trans-unit id="a5c95ea342ee7c08382d8806e33a6d11792130c7" translate="yes" xml:space="preserve">
          <source>In the traditional transport entries, when the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8436cdbd307ab8656dafbbaa0b4535513613e69" translate="yes" xml:space="preserve">
          <source>In the wake of this the function &lt;code&gt;sys:get_debug/3&lt;/code&gt; that returns data with undocumented and internal format (and therefore is practically useless) has been deprecated, and a new function &lt;code&gt;sys:get_log/1&lt;/code&gt; has been added, that hopefully does what the deprecated function was intended for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">В функциях xmerl_xs вы можете предоставить вызов select (String), который является функцией &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; . Для более подробной информации см xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19dcfcc4ae578c29ecc97aa13bb8ee0b043f878a" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">В этих случаях версия ProtocolVersion по умолчанию получается из конфигурации статического соединения:</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">В этой агентской системе есть два способа динамически устанавливать информацию управления. Самый распространенный способ - загрузить MIB в агент. Другой способ - использовать субагента, который управляется приложением и может регистрироваться и отменять регистрацию. Субагент может зарегистрироваться для управления поддеревом (не путать с &lt;code&gt;erlang:register&lt;/code&gt; ). Поддерево идентифицируется идентификатором объекта. Когда субагент зарегистрирован, он получает все запросы для этого конкретного поддерева и отвечает за них. Также следует отметить, что субагент может быть запущен и остановлен в любой момент.</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">В этом вызове &lt;code&gt;[1, 1]&lt;/code&gt; - это &lt;code&gt;RowIndex&lt;/code&gt; , где ключ 1 имеет значение 1, а ключ 2 имеет значение 1, а &lt;code&gt;[3, 5]&lt;/code&gt; - это список запрошенных столбцов. Теперь функция должна возвращать лексикографически следующие элементы:</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">В этом случае он получил новый компонент &lt;code&gt;b&lt;/code&gt; . Таким образом, входящие сообщения, которые декодируются, могут иметь больше или больше компонентов, чем это.</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">В этом случае оператор &lt;code&gt;ct_hooks&lt;/code&gt; в наборе тестов может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">В этом случае конфигурационный файл должен содержать,по крайней мере,данные:</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">В этом случае фильтр применяется ко всем возможным парам ответов на вопросы &lt;code&gt;QH1&lt;/code&gt; и &lt;code&gt;QH2&lt;/code&gt; , по одному. Если есть M ответов на &lt;code&gt;QH1&lt;/code&gt; и N ответов на &lt;code&gt;QH2&lt;/code&gt; , фильтр запускается M * N раз.</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">В этом случае &lt;code&gt;CTH&lt;/code&gt; может быть либо только именем модуля CTH, либо кортежем с именем модуля и начальными аргументами, а также необязательно приоритетом ловушки CTH. Например, одно из следующих:</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">В этом случае можно использовать параметр компилятора &lt;code&gt;encrypt_debug_info&lt;/code&gt; , см. Compile &lt;code&gt;compile(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">В этом случае все аргументы, кроме первого, игнорируются, и функция просто снова возвращает внутреннее состояние. Этого достаточно, если только код был расширен. Если вместо этого внутреннее состояние изменяется (аналогично примеру в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; ), это делается в этой функции и возвращается &lt;code&gt;{ok,Chs2}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">В этом случае одно или несколько &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; могут быть несвязанными переменными.</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">В этом случае простой замены кода недостаточно. Процесс должен явно преобразовать свое состояние с помощью функции обратного вызова &lt;code&gt;code_change&lt;/code&gt; перед переключением на новую версию модуля обратного вызова. Таким образом, используется синхронизированная замена кода.</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">В этом случае простой замены кода недостаточно.При загрузке новой версии резидентного модуля для специального процесса процесс должен полностью квалифицированно обратиться к своей функции цикла,чтобы переключиться на новый код.Таким образом,должна использоваться синхронизированная замена кода.</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">В этом случае процесс вызова является оболочкой,поэтому будет получен следующий результат:</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">В этом случае функция должна быть экспортирована из данного модуля.</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">В этом случае возвращается ключ &lt;code&gt;Key&lt;/code&gt; , который можно использовать в последующем вызове &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; для получения значения оценки &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; на узле &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">В этом случае новое состояние - это обновленный список доступных каналов &lt;code&gt;Chs2&lt;/code&gt; . &lt;code&gt;gen_server&lt;/code&gt; теперь готов к новым запросам.</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">В этом случае можно использовать платформу обработчика выпуска с автоматической упаковкой и распаковкой пакетов выпуска, автоматическим обновлением пути и т. Д. Без указания файлов &lt;code&gt;.appup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">В этом случае ответ - это выделенный канал &lt;code&gt;Ch&lt;/code&gt; , а новое состояние - это набор оставшихся доступных каналов &lt;code&gt;Chs2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">В этом случае супервайзер не регистрируется. Вместо этого должен использоваться его pid. Имя можно указать, вызвав &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; или &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">В этом случае вы освобождаете два термина независимо друг от друга. Порядок, в котором вы освобождаете термины &lt;code&gt;ep&lt;/code&gt; и &lt;code&gt;ep2&lt;/code&gt; , не важен, потому что библиотека &lt;code&gt;Erl_Interface&lt;/code&gt; использует подсчет ссылок, чтобы определить, когда безопасно удалять объекты.</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">В этом примере рассмотрим ситуацию,когда вы хотите изучить определенные данные в XML-файле.Например,вы хотите проверить,как долго каждый мотоцикл был записан.</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">В данном примере приложение Pea было изменено,как и приложения ERTS,Kernel,STDLIB и SASL.</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">В этом примере числа являются целыми числами, а аргументы функций в коде &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; и &lt;code&gt;Y&lt;/code&gt; называются переменными. Переменные должны начинаться с заглавной буквы (см. &lt;code&gt;Variables&lt;/code&gt; ). Примеры переменных: &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;ShoeSize&lt;/code&gt; и &lt;code&gt;Age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00141d9820384d0fe96047499c682c85df54a263" translate="yes" xml:space="preserve">
          <source>In this example we first create a new cons cell with an integer and a tuple with some text. Then a tuple of size three wrapping the other values with an atom tag is created and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">В этом примере вы просматриваете список, &quot;несущий&quot; значение, в данном случае &lt;code&gt;Result_so_far&lt;/code&gt; . &lt;code&gt;list_max/1&lt;/code&gt; просто предполагает, что максимальное значение списка является &lt;code&gt;list_max/2&lt;/code&gt; списка, и вызывает list_max / 2 с остальной частью списка и значением заголовка списка. В приведенном выше &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; это будет list_max ([2,3,4,5,7,4,3,2,1], 1) . Если вы попытаетесь использовать &lt;code&gt;list_max/1&lt;/code&gt; с пустым списком или попытаетесь использовать его с чем-то, что вообще не является списком, вы вызовете ошибку. Обратите внимание, что философия Erlang заключается не в том, чтобы обрабатывать ошибки этого типа в той функции, которую они вызывают, а в том, чтобы делать это в другом месте. Подробнее об этом позже.</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">В этом примере &lt;code&gt;suite/0&lt;/code&gt; сообщает &lt;code&gt;Common Test&lt;/code&gt; запретить распечатку из соединений Telnet и SSH. Это верно для всех тестовых случаев. Однако &lt;code&gt;my_testcase1/0&lt;/code&gt; указывает, что для этого тестового примера молчать должен только SSH. В результате &lt;code&gt;my_testcase1&lt;/code&gt; получает информацию Telnet (если есть), напечатанную в журнале, но не информацию SSH. &lt;code&gt;my_testcase2&lt;/code&gt; не получает информации ни от одного напечатанного соединения.</target>
        </trans-unit>
        <trans-unit id="f2f906325545f1417f1e6e7ea85883ce6305f126" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">В этом примере получено &lt;code&gt;{Pid, Something}&lt;/code&gt; . Полученный pid затем используется для возврата &lt;code&gt;{goodbye,Pid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">В этом примере от внешнего источника принимается серия байтов, а затем байты декодируются в действительный термин Эрланга. Это было достигнуто с помощью вызова &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; , который вернул значение Erlang типа &lt;code&gt;Person&lt;/code&gt; ASN.1 . Затем был построен и закодирован ответ с использованием &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; , который берет экземпляр определенного типа ASN.1 и преобразует его в двоичный файл в соответствии с правилами кодирования BER или PER.</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">В этом примере модуль трассировки с серверной частью NIF отправляет сообщение для каждого тега трассировки &lt;code&gt;send&lt;/code&gt; содержащего только отправителя и получателя. При использовании этого модуля трассировки используется гораздо более легкий трассировщик сообщений, который записывает только, кто кому отправил сообщения.</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">В этом примере система времени выполнения Erlang запускается с переменной среды &lt;code&gt;DISPLAY&lt;/code&gt; , установленной на &lt;code&gt;gin:0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">В этом примере была сделана попытка вывести одиночный символ 65 с помощью директивы форматирования строки &lt;code&gt;&quot;~s&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">В данном примере любой пользовательский тег,заданный в процессе вызова,будет распространен на I/O-сервер при выполнении вызова в формате io:format.</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">В этом примере,каждая исполнительная система имеет по два планировщика в режиме онлайн,и все планировщики в режиме онлайн будут работать на разных ядрах.Если мы переходим на один планировщик онлайн на одной системе выполнения,и три планировщика онлайн на другом,все планировщики онлайн все равно будет работать на разных ядрах.</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">В этом примере функция &lt;code&gt;terminate/3&lt;/code&gt; блокирует дверь, если она открыта, поэтому мы случайно не оставим дверь открытой, когда дерево надзора завершится:</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">В этом примере, если первый элемент был ключом, гораздо эффективнее сопоставить этот ключ в части &lt;code&gt;MatchHead&lt;/code&gt; , чем в части &lt;code&gt;MatchConditions&lt;/code&gt; . Пространство поиска таблиц ограничено в отношении &lt;code&gt;MatchHead&lt;/code&gt; , поэтому поиск выполняется только по объектам с совпадающим ключом.</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">В этом примере вместо того, чтобы игнорировать события кнопок в &lt;code&gt;open&lt;/code&gt; состоянии, мы можем отложить их, и они будут поставлены в очередь, а затем обработаны в &lt;code&gt;locked&lt;/code&gt; состоянии:</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">В данном примере выполняются следующие действия:</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">В этом примере используется та же спецификация ASN.1, что и в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; . Ниже приведена действительная инструкция выборочного декодирования:</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">В этом примере тестовые термины,определенные в файлах &quot;b.spec&quot; и &quot;c.spec&quot;,объединены с терминами в исходной спецификации &quot;a.spec&quot; (если таковая имеется).Включение спецификаций &quot;d.spec&quot; и &quot;e.spec&quot; приводит к двум отдельным и независимым прогонам тестов (по одному для каждой включенной спецификации).</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">В этом примере мы решили скопировать двоичный контент перед тем, как вставить его в &lt;code&gt;gb_sets:set()&lt;/code&gt; если он ссылается на двоичный файл, размер данных, который мы хотим сохранить, более чем в два раза превышает размер. Конечно, при копировании в разные программы действуют разные правила.</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">В этом примере мы помещаем &amp;laquo;diffie-hellman-group1-sha1&amp;raquo; первым, а также перемещаем &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; в конец списка kex, то есть &lt;code&gt;append&lt;/code&gt; его.</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">В этом примере мы используем оба варианта ( &lt;code&gt;preferred_algorithms&lt;/code&gt; и &lt;code&gt;modify_algorithms&lt;/code&gt; ), а также пытаемся добавить неподдерживаемый алгоритм. Любой неподдерживаемый алгоритм незаметно удаляется.</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">В этих примерах используются определения из следующей спецификации ASN.1:</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">В следующем примере пароль - &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">В этом режиме можно сделать следующее:</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">В этом модуле V может быть пустым. Полученный таким образом уникальный орграф называется &lt;strong id=&quot;empty_digraph&quot;&gt;пустым орграфом&lt;/strong&gt; . И вершины, и ребра представлены уникальными терминами Эрланга.</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">В данном модуле рассматриваются только семейства подмножеств некоторого множества X,далее для таких семейств подмножеств используется слово &quot;семейство&quot;.</target>
        </trans-unit>
        <trans-unit id="9df8795a77ab5095acba5e23497d16dae8d5c2f4" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the time-out since the time-out event is the only possible reason to do a &lt;strong&gt;state change&lt;/strong&gt; from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">В этом конкретном случае нам не нужно отменять тайм-аут, так как событие тайм-аута является единственной возможной причиной изменения состояния с &lt;code&gt;open&lt;/code&gt; на &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">В этом конкретном случае команда &lt;code&gt;i&lt;/code&gt; (&amp;laquo;прерывание&amp;raquo;) завершает программу цикла, а команда &lt;code&gt;c&lt;/code&gt; снова подключается к оболочке. Поскольку до того, как мы его убили, процесс работал в фоновом режиме, перед отображением сообщения &amp;laquo; &lt;code&gt;** exception exit: killed&lt;/code&gt; завершено&amp;raquo; выполняется больше распечаток .</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">В этом сценарии блокировка, которая защищает ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; , потратила большую часть своего ожидания. Это 1,8 секунды в 60-секундном тесте. Время также распределяется по восьми различным потокам планировщика.</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">В этом разделе поле &lt;code&gt;Domain&lt;/code&gt; является транспортным доменом, то есть одним из &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; или &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; , а поле &lt;code&gt;Addr&lt;/code&gt; - это кортеж &lt;code&gt;{&lt;/code&gt; IpAddr &lt;code&gt;,IpPort}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">В этом разделе поле &lt;code&gt;Address&lt;/code&gt; представляет собой кортеж &lt;code&gt;{Domain, Addr}&lt;/code&gt; где &lt;code&gt;Domain&lt;/code&gt; - это &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; или &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; , а &lt;code&gt;Addr&lt;/code&gt; - это &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; IpAddr &lt;code&gt;,IpPort}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">В этом разделе перечислены все допустимые выражения Erlang.При написании программ на Erlang также разрешается использовать макро-и записывающие выражения.Однако при компиляции эти выражения расширяются и в этом смысле не являются истинными выражениями Erlang.Выражения макросов и записей рассматриваются в отдельных разделах:</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">В этом разделе предполагается, что имя пользователя - &lt;code&gt;otpuser&lt;/code&gt; , а домашний каталог этого пользователя:</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">В этом разделе используется следующая терминология:</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">В этом простом случае первое выражение,вероятно,предпочтительнее с точки зрения читабельности.</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">Таким образом, вы можете соединить все процессы в транзакции вместе с помощью ссылок. Если один из процессов завершается ненормально, все процессы в транзакции прекращаются. Поскольку часто требуется создать процесс и связать с ним одновременно, существует специальный BIF, &lt;code&gt;spawn_link&lt;/code&gt; , который делает то же самое, что и &lt;code&gt;spawn&lt;/code&gt; , но также создает ссылку на порожденный процесс.</target>
        </trans-unit>
        <trans-unit id="04cd30a6181cf29b11e39620fc1e71c03e622ab5" translate="yes" xml:space="preserve">
          <source>In those circumstances, &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; must be invoked to set up the pointer again. &lt;strong&gt;beam_makeops&lt;/strong&gt; will notice if there is a call to a function that does a garbage collection and &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; is not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12987c6a024d031823b3213c0fb06e759b8cd0bf" translate="yes" xml:space="preserve">
          <source>In those functions the internal crypto state is first created and initialized with the cipher type, the key and possibly other data. Then the single binary is encrypted or decrypted, the crypto state is de-allocated and the result of the crypto operation is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">В традиционной терминологии реляционной базы данных эта операция называется выделением,за которым следует проекция.</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">В типе &lt;code&gt;StartMessage&lt;/code&gt; ограничение, следующее за &lt;code&gt;content&lt;/code&gt; поля, сообщает, что в значении типа &lt;code&gt;StartMessage&lt;/code&gt; значение в &lt;code&gt;content&lt;/code&gt; поля должно происходить из того же объекта, который выбран полем &lt;code&gt;msgId&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В версии 3 стандарта megaco был представлен пакет сегментации. Просто этот пакет определяет процедуру сегментирования мегасообщения (ответов транзакций) при использовании транспорта, который не делает этого автоматически (например, UDP). См. Также &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63b6f2d5cd37bdba6df81460e958046ee197cfa0" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard, the concept of &lt;code&gt;segmentation package&lt;/code&gt; was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">В какой версии OTP было представлено &lt;code&gt;kernel-3.0&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">В вашей собственной функции обработчика трассировки вызовите &lt;code&gt;erlang:display/1&lt;/code&gt; вместо функции &lt;code&gt;io&lt;/code&gt; или, если &lt;code&gt;user&lt;/code&gt; не используется в качестве лидера группы, напечатайте &lt;code&gt;user&lt;/code&gt; вместо лидера группы по умолчанию. Пример: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">Внутриполосная безопасность-ID AVP</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">Inband-Security-Id AVP (код 299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">Inband-Security-Id по умолчанию равен пустому списку,который эквивалентен списку,содержащему только 0 (NO_INBAND_SECURITY).Если указано 1 (TLS),то TLS выбирается в том случае,если CER/CEA,полученный от коллеги,предлагает его.</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">Входящая двоичная кодировка в двоичных файлах</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">Входящее процентное кодирование в списках и двоичных файлах</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">Между прочим, когда тестовый пример исправлен, действительно должна быть обнаружена ошибка в &lt;code&gt;channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">Включите &lt;code&gt;dir&lt;/code&gt; в путь для Erlang. Это полезно при анализе файлов с директивами &lt;code&gt;-include_lib()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae53151741eb56a1003fee69921d65824bcd040" translate="yes" xml:space="preserve">
          <source>Include Directories and Macro Definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Каталоги Include также можно указать в спецификациях тестов, см. &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">Включить файл</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">Включаемые файлы обычно используются для определений записей и макросов, которые совместно используются несколькими модулями. Для включаемых файлов рекомендуется использовать расширение имени файла &lt;code&gt;.hrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec71a4f09bb1029d3d4fb8244b9d00627d2bcc0" translate="yes" xml:space="preserve">
          <source>Include the correct tool's include file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">Включите текст токена в аннотацию к токену.Текст-это часть ввода,соответствующая токену.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
