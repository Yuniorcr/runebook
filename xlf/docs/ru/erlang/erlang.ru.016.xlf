<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="946db1924667eb983a11ec1edab5fe1131a72877" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;obj&lt;/code&gt; is pointer to the resource to hold the monitor and &lt;code&gt;*target_pid&lt;/code&gt; identifies the local process to be monitored.</source>
          <target state="translated">Аргумент &lt;code&gt;obj&lt;/code&gt; - это указатель на ресурс для хранения монитора, а &lt;code&gt;*target_pid&lt;/code&gt; идентифицирует локальный процесс, который нужно отслеживать.</target>
        </trans-unit>
        <trans-unit id="759c092e66e225d8bfb0ee95cc9263fb1d2744cd" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;percent&lt;/code&gt; must be an integer between 1 and 100. This function must only be called from a NIF-calling thread, and argument &lt;code&gt;env&lt;/code&gt; must be the environment of the calling process.</source>
          <target state="translated">&lt;code&gt;percent&lt;/code&gt; аргумента должен быть целым числом от 1 до 100. Эта функция должна вызываться только из потока, вызывающего NIF, а аргумент &lt;code&gt;env&lt;/code&gt; должен быть средой вызывающего процесса.</target>
        </trans-unit>
        <trans-unit id="f2c2f60e2d8ae32461ae1eadddd46c13583f534f" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;pid&lt;/code&gt; may be &lt;code&gt;NULL&lt;/code&gt; to indicate the calling process.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; аргумента может иметь &lt;code&gt;NULL&lt;/code&gt; чтобы указать вызывающий процесс.</target>
        </trans-unit>
        <trans-unit id="302f9a8d5949d2f9e3d699e1fadbaaf1fd2728b5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;ref&lt;/code&gt; must be either a reference obtained from &lt;code&gt;&lt;a href=&quot;erlang#make_ref-0&quot;&gt;erlang:make_ref/0&lt;/a&gt;&lt;/code&gt; or the atom &lt;code&gt;undefined&lt;/code&gt;. It will be passed as &lt;code&gt;Ref&lt;/code&gt; in the notifications. If a selective &lt;code&gt;receive&lt;/code&gt; statement is used to wait for the notification then a reference created just before the &lt;code&gt;receive&lt;/code&gt; will exploit a runtime optimization that bypasses all earlier received messages in the queue.</source>
          <target state="translated">Аргумент &lt;code&gt;ref&lt;/code&gt; должен быть либо ссылкой, полученной из &lt;code&gt;&lt;a href=&quot;erlang#make_ref-0&quot;&gt;erlang:make_ref/0&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;undefined&lt;/code&gt; атомом . В уведомлениях он будет передан как &lt;code&gt;Ref&lt;/code&gt; . Если для ожидания уведомления используется оператор выборочного &lt;code&gt;receive&lt;/code&gt; то ссылка, созданная непосредственно перед &lt;code&gt;receive&lt;/code&gt; будет использовать оптимизацию времени выполнения, которая обходит все ранее полученные сообщения в очереди.</target>
        </trans-unit>
        <trans-unit id="7193c5fbe44de78fcb734160bf05a4992363162d" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;reserved&lt;/code&gt; is intended for future use and is to be ignored.</source>
          <target state="translated">&lt;code&gt;reserved&lt;/code&gt; аргумент предназначен для использования в будущем и его следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="47a1b242d8b4376bd70073509fcf4806ebd02558" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;to_enc&lt;/code&gt; is ignored. As from Erlang/OTP 20 the encoding is always done in UTF-8 which is readable by nodes as old as Erlang/OTP R16.</source>
          <target state="translated">Аргумент &lt;code&gt;to_enc&lt;/code&gt; игнорируется. Начиная с Erlang / OTP 20, кодирование всегда выполняется в UTF-8, который читается такими же старыми узлами, как Erlang / OTP R16.</target>
        </trans-unit>
        <trans-unit id="765075133d0be0aa3a9dbc9bcb841e96fb89d790" translate="yes" xml:space="preserve">
          <source>Argument list for the &lt;code&gt;init&lt;/code&gt; function in the callback module.</source>
          <target state="translated">Список аргументов для функции &lt;code&gt;init&lt;/code&gt; в модуле обратного вызова.</target>
        </trans-unit>
        <trans-unit id="13185c544644b7f2a243ef918a03957be326a36d" translate="yes" xml:space="preserve">
          <source>Argument:</source>
          <target state="translated">Argument:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="565865945dd4be2b94783c9b5e4f90518f12be80" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Args&lt;/code&gt; are used in a call to &lt;code&gt;io_lib:format/2&lt;/code&gt; to create the comment string. The behavior of &lt;code&gt;comment/2&lt;/code&gt; is otherwise the same as function &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;code&gt;Format&lt;/code&gt; и &lt;code&gt;Args&lt;/code&gt; используются в вызове &lt;code&gt;io_lib:format/2&lt;/code&gt; для создания комментария строки. Поведение &lt;code&gt;comment/2&lt;/code&gt; в остальном такое же, как у функции &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="a853cd0dac3624d36b7ac915686a7bf9b68613c0" translate="yes" xml:space="preserve">
          <source>Arithmetic bitshift left</source>
          <target state="translated">арифметический сдвиг влево</target>
        </trans-unit>
        <trans-unit id="09257e94fa407278a59602ea81c51ef19d845892" translate="yes" xml:space="preserve">
          <source>Arithmetic bitwise XOR</source>
          <target state="translated">арифметический битумный XOR</target>
        </trans-unit>
        <trans-unit id="206db889fe395b01fcd9ea9b88e2747a6dbb4f32" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions</source>
          <target state="translated">арифметические выражения</target>
        </trans-unit>
        <trans-unit id="296f27747464dfd4585fc68aca14b6147fb87a9b" translate="yes" xml:space="preserve">
          <source>Arithmetics: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;rem&lt;/code&gt;</source>
          <target state="translated">Арифметика: &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;div&lt;/code&gt; , &lt;code&gt;rem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdadcc41e499fbe0cbed3e778cd50052fc53c2be" translate="yes" xml:space="preserve">
          <source>Arity ::= Number | &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">Арность :: = Число | &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="6c4709af989db804327c6ea436d6589b124f8253" translate="yes" xml:space="preserve">
          <source>Arranges documents horizontally or vertically, separated by whitespace. Returns a document representing two alternative layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents, such that either all elements in &lt;code&gt;Docs&lt;/code&gt; are concatenated horizontally, and separated by a space character, or all elements are concatenated vertically (without extra separation).</source>
          <target state="translated">Располагает документы по горизонтали или вертикали, разделяя их пробелами. Возвращает документ, представляющий два альтернативных макета (непустой) последовательности &lt;code&gt;Docs&lt;/code&gt; документов, так что либо все элементы в &lt;code&gt;Docs&lt;/code&gt; объединены по горизонтали и разделены пробелом, либо все элементы объединены по вертикали (без дополнительного разделения).</target>
        </trans-unit>
        <trans-unit id="cb6e8bc43bfadc15174aa7c7533ec25e49f627de" translate="yes" xml:space="preserve">
          <source>Arranges documents in a paragraph-like layout. Returns a document representing all possible left-aligned paragraph-like layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents. Elements in &lt;code&gt;Docs&lt;/code&gt; are separated horizontally by a single space character and vertically with a single line break. All lines following the first (if any) are indented to the same left column, whose indentation is specified by the optional &lt;code&gt;Offset&lt;/code&gt; parameter relative to the position of the first element in &lt;code&gt;Docs&lt;/code&gt;. For example, with an offset of -4, the following layout can be produced, for a list of documents representing the numbers 0 to 15:</source>
          <target state="translated">Размещает документы в виде абзацев. Возвращает документ, представляющий все возможные с выравниванием по левому краю макеты (непустой) последовательности &lt;code&gt;Docs&lt;/code&gt; с выравниванием по левому краю . Элементы в &lt;code&gt;Docs&lt;/code&gt; разделяются по горизонтали одним пробелом, а по вертикали - одним разрывом строки. Все строки, следующие за первым (если есть), имеют отступ до одного и того же левого столбца, отступ которого задается необязательным параметром &lt;code&gt;Offset&lt;/code&gt; относительно позиции первого элемента в &lt;code&gt;Docs&lt;/code&gt; . Например, со смещением -4 можно создать следующий макет для списка документов, представляющих числа от 0 до 15:</target>
        </trans-unit>
        <trans-unit id="2b0401c5dcd8acaf55fb3e4a1e292be99ca524e1" translate="yes" xml:space="preserve">
          <source>Arrays uses &lt;strong&gt;zero&lt;/strong&gt;-based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples.</source>
          <target state="translated">Массивы используют индексирование на основе &lt;strong&gt;нуля&lt;/strong&gt; . Это осознанный выбор дизайна и отличается от других структур данных Erlang, например, кортежей.</target>
        </trans-unit>
        <trans-unit id="8daa60e38c87072a49c49928224bef6c12c7e054" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; , но влияет на грязные планировщик процессора. По умолчанию &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="309dd2054ffb824320663f138850770c829b8b4e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; , но влияет на грязные планировщики ввода-вывода. По умолчанию &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b3946f390b5828658a54092e42e5c1aeb3b35f2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; , но влияет на грязные планировщики ЦП. По умолчанию &lt;code&gt;medium&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2e5d1e1ed3c38e858012a446291d2ee5eda343" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; , но влияет на грязные планировщики ввода-вывода. По умолчанию &lt;code&gt;medium&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc32ea3f593b79a1f69eaba316d39f23e652807c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt;, but the atom must exist.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt; , но атом должен существовать.</target>
        </trans-unit>
        <trans-unit id="434cd7266c5993b7f305995750735748f31955d2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;Subject&lt;/code&gt; is searched until exhausted and a list of all non-overlapping parts matching &lt;code&gt;Pattern&lt;/code&gt; is returned (in order).</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; , но &lt;code&gt;Subject&lt;/code&gt; ищется до тех пор, пока не будет исчерпан, и возвращается список всех неперекрывающихся частей, соответствующих &lt;code&gt;Pattern&lt;/code&gt; (по порядку).</target>
        </trans-unit>
        <trans-unit id="62392802bcfff15af67682cfdf06f0083a7bb98e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; , но не отправляет &lt;code&gt;hello&lt;/code&gt; сообщение.</target>
        </trans-unit>
        <trans-unit id="cb9ffdb93aadccde648214772c8fec53159cd3ed" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; , но не отправляет &lt;code&gt;hello&lt;/code&gt; сообщение.</target>
        </trans-unit>
        <trans-unit id="4fa21b36059529486327fb112773587da1a9d73d" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;S'&lt;/code&gt; depend only on &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, the kind of state machine described here is a Mealy machine (see, for example, the Wikipedia article &quot;Mealy machine&quot;).</source>
          <target state="translated">Поскольку &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;S'&lt;/code&gt; зависят только от &lt;code&gt;S&lt;/code&gt; и &lt;code&gt;E&lt;/code&gt; , описанный здесь вид конечного автомата является автоматом Мили (см., Например, статью в Википедии &amp;laquo;Машина Мили&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="b7f0ebcdeb2935048365b1b7688d80f3aa697b38" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Common Test&lt;/code&gt; always finishes at least the current test case, the time specified with &lt;code&gt;duration&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; is never definitive.</source>
          <target state="translated">Поскольку &lt;code&gt;Common Test&lt;/code&gt; всегда завершает, по крайней мере, текущий тестовый пример, время, указанное с помощью параметра &lt;code&gt;duration&lt;/code&gt; или &lt;code&gt;until&lt;/code&gt; , никогда не является окончательным.</target>
        </trans-unit>
        <trans-unit id="36e279355dc9b13486eb359a6a271e352bb9ca92" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_list/1&lt;/code&gt;, but returns a list of integers corresponding to the bytes from position &lt;code&gt;Start&lt;/code&gt; to position &lt;code&gt;Stop&lt;/code&gt; in &lt;code&gt;Binary&lt;/code&gt;. The positions in the binary are numbered starting from 1.</source>
          <target state="translated">Как &lt;code&gt;binary_to_list/1&lt;/code&gt; , но возвращает список целых чисел, соответствующих байтам от позиции &lt;code&gt;Start&lt;/code&gt; до позиции &lt;code&gt;Stop&lt;/code&gt; в &lt;code&gt;Binary&lt;/code&gt; . Позиции в двоичном формате нумеруются, начиная с 1.</target>
        </trans-unit>
        <trans-unit id="356a2faa4b1e013f3d85b59d1af52dcdb569daaf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_term/1&lt;/code&gt;, but takes these options:</source>
          <target state="translated">Как &lt;code&gt;binary_to_term/1&lt;/code&gt; , но принимает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="4a20cd1597bfd4ebe1b9bc83959a610632302a2c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt; execute on the same Erlang process as the test case, printouts from these configuration functions are included in the test case log file.</source>
          <target state="translated">Поскольку &lt;code&gt;init_per_testcase&lt;/code&gt; и &lt;code&gt;end_per_testcase&lt;/code&gt; выполняются в том же процессе Erlang, что и тестовый пример, распечатки этих функций конфигурации включаются в файл журнала тестового примера.</target>
        </trans-unit>
        <trans-unit id="077937866e1c72c70b5a0b14cb6e8cc697f67ab6" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;reload/2&lt;/code&gt; waits for the reloading to occur, a misbehaving process keeping open ports to the driver (or keeping the driver loaded) can cause infinite waiting for reload. Time-outs must be provided outside of the process demanding the reload or by using the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; in combination with driver monitors.</source>
          <target state="translated">Поскольку &lt;code&gt;reload/2&lt;/code&gt; ожидает перезагрузки, некорректный процесс, сохраняющий открытые порты для драйвера (или сохраняющий загруженный драйвер), может вызвать бесконечное ожидание перезагрузки. Тайм-ауты должны быть предоставлены вне процесса, требующего перезагрузки, или с помощью низкоуровневого интерфейса &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; в сочетании с мониторами драйверов.</target>
        </trans-unit>
        <trans-unit id="35dd6ddae6107d33b10d598d29bb9b8cf8efce75" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;{Unused,Binary}&lt;/code&gt; where &lt;code&gt;Unused&lt;/code&gt; denotes how many trailing zero-bits 0-7 that are unused in the least significant byte in &lt;code&gt;Binary&lt;/code&gt;. This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if &lt;code&gt;compact_bit_string&lt;/code&gt; has been given.</source>
          <target state="translated">Как &lt;code&gt;{Unused,Binary}&lt;/code&gt; , где &lt;code&gt;Unused&lt;/code&gt; обозначает количество завершающих нулевых битов 0-7, которые не используются в младшем значащем байте в &lt;code&gt;Binary&lt;/code&gt; . Этот формат принимается в качестве входных данных для функций кодирования, и &lt;code&gt;BIT STRING&lt;/code&gt; декодируется в этот формат, если &lt;code&gt;compact_bit_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40263cdf47a643660bd823252e4e54341b4e8e99" translate="yes" xml:space="preserve">
          <source>As Erl_Interface operates on the Erlang external term format, the port must be set to use binaries.</source>
          <target state="translated">Так как Erl_Interface работает с форматом внешних терминов Erlang,порт должен быть настроен на использование двоичных файлов.</target>
        </trans-unit>
        <trans-unit id="bf5866c25e866f9c6f9b119f63b598360bcc9ad6" translate="yes" xml:space="preserve">
          <source>As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific.</source>
          <target state="translated">Поскольку Erlang имеет фиксированное количество типов,программисту нет необходимости определять спецификацию для внешнего формата,используемого в каком-либо приложении.Все термины Erlang имеют внешнее представление,и интерпретация различных терминов специфична для конкретного приложения.</target>
        </trans-unit>
        <trans-unit id="c7e5143ee8610dc021b9a09e083dc533d485e207" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">Поскольку у супервизора &lt;code&gt;simple_one_for_one&lt;/code&gt; может быть много дочерних элементов, он асинхронно отключает их всех. Это означает, что дочерние элементы выполняют очистку параллельно, и поэтому порядок их остановки не определен.</target>
        </trans-unit>
        <trans-unit id="c2fd4a4764c6e535778fe8db9cbb1523710b87e3" translate="yes" xml:space="preserve">
          <source>As a NIF library is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang (alongside port drivers). Calling NIFs requires no context switches. But it is also the least safe, because a crash in a NIF brings the emulator down too.</source>
          <target state="translated">Так как библиотека NIF динамически связана с процессом эмулятора,то это самый быстрый способ вызова C-кода из Erlang (наряду с драйверами портов).Вызов NIF не требует переключения контекста.Но это также наименее безопасно,так как сбой в NIF тоже приводит к падению эмулятора.</target>
        </trans-unit>
        <trans-unit id="58e7b3f109198992ba59bec647e67726857b68a0" translate="yes" xml:space="preserve">
          <source>As a complement to the &lt;code&gt;set&lt;/code&gt; operation, it is possible to specify a test function. This function has the same syntax as the set operation above, except that the first argument is &lt;code&gt;is_set_ok&lt;/code&gt; instead of &lt;code&gt;set&lt;/code&gt;. This function is called before the variable is set. Its purpose is to ensure that it is permissible to set the variable to the new value.</source>
          <target state="translated">В дополнение к &lt;code&gt;set&lt;/code&gt; операции можно указать тестовую функцию. Эта функция имеет тот же синтаксис, что и операция set выше, за исключением того, что первым аргументом является &lt;code&gt;is_set_ok&lt;/code&gt; вместо &lt;code&gt;set&lt;/code&gt; . Эта функция вызывается перед установкой переменной. Его цель - убедиться, что допустимо установить для переменной новое значение.</target>
        </trans-unit>
        <trans-unit id="2948bceb43ecea497f0a445923a501687c512364" translate="yes" xml:space="preserve">
          <source>As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;. Thus, the following two patterns match the same set of strings:</source>
          <target state="translated">В качестве удобного сокращения,если в начале не захватывающей подмаски требуются какие-либо настройки опций,буквы опций могут появляться между &quot;?&quot; и &quot;:&quot;.Таким образом,следующие два шаблона соответствуют одному и тому же набору строк:</target>
        </trans-unit>
        <trans-unit id="f6848c0bdaadb93a4b8d51c18e19a86434987f9a" translate="yes" xml:space="preserve">
          <source>As a convention, all I/O servers handle both &lt;code&gt;{setopts, [binary]}&lt;/code&gt;, &lt;code&gt;{setopts, [list]}&lt;/code&gt;, and &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt;, hence the trick with &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; and &lt;code&gt;proplists:unfold/1&lt;/code&gt;. If invalid options are sent to us, we send &lt;code&gt;{error, enotsup}&lt;/code&gt; back to the client.</source>
          <target state="translated">По соглашению все серверы ввода-вывода обрабатывают как &lt;code&gt;{setopts, [binary]}&lt;/code&gt; , &lt;code&gt;{setopts, [list]}&lt;/code&gt; , и &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt; , отсюда и трюк с &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; и &lt;code&gt;proplists:unfold/1&lt;/code&gt; . Если нам отправлены недопустимые параметры, мы отправляем &lt;code&gt;{error, enotsup}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="493adbb575cc27e47dde3943edacdea5778a9cf8" translate="yes" xml:space="preserve">
          <source>As a final example we demonstrate the use of &lt;code&gt;driver_async&lt;/code&gt;. We also use the driver term interface. The driver is written in C++. This enables us to use an algorithm from STL. We use the &lt;code&gt;next_permutation&lt;/code&gt; algorithm to get the next permutation of a list of integers. For large lists (&amp;gt; 100,000 elements), this takes some time, so we perform this as an asynchronous task.</source>
          <target state="translated">В качестве последнего примера мы демонстрируем использование &lt;code&gt;driver_async&lt;/code&gt; . Мы также используем термин &amp;laquo;интерфейс драйвера&amp;raquo;. Драйвер написан на C ++. Это позволяет нам использовать алгоритм из STL. Мы используем алгоритм &lt;code&gt;next_permutation&lt;/code&gt; , чтобы получить следующую перестановку списка целых чисел. Для больших списков (&amp;gt; 100 000 элементов) это занимает некоторое время, поэтому мы выполняем это как асинхронную задачу.</target>
        </trans-unit>
        <trans-unit id="a1f3df7ed28f00795df09b73036126e4e8c30a4d" translate="yes" xml:space="preserve">
          <source>As a hexadecimal number (or an integer). Avoid this as it is easy to misinterpret a &lt;code&gt;BIT STRING&lt;/code&gt; value in this format.</source>
          <target state="translated">В виде шестнадцатеричного числа (или целого числа). Избегайте этого, поскольку значение &lt;code&gt;BIT STRING&lt;/code&gt; в этом формате легко неверно истолковать .</target>
        </trans-unit>
        <trans-unit id="7085268ee258ef21d5f659dd9a334d1661d8596c" translate="yes" xml:space="preserve">
          <source>As a last resort, the implementation solely based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__sync_*&lt;/code&gt; builtins. This will however cause lots of expensive and unnecessary memory barrier instructions to be issued. That is, performance will suffer. The &lt;code&gt;configure&lt;/code&gt; script will warn at the end of its execution if it cannot find any other alternative than this.</source>
          <target state="translated">В крайнем случае, реализация основана исключительно на встроенных &lt;code&gt;__sync_*&lt;/code&gt; &lt;code&gt;gcc&lt;/code&gt; __sync_ * . Однако это приведет к выдаче множества дорогостоящих и ненужных инструкций по ограничению памяти. То есть производительность пострадает. Сценарий &lt;code&gt;configure&lt;/code&gt; предупредит в конце своего выполнения, если не найдет другой альтернативы, кроме этой.</target>
        </trans-unit>
        <trans-unit id="ebe4b26b3285c31b7e66a15f34435eba521d186d" translate="yes" xml:space="preserve">
          <source>As a match specification can turn on sequential tracing, the combination of &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;seq_trace&lt;/code&gt; can be quite powerful. This brief example shows a session where sequential tracing is used:</source>
          <target state="translated">Поскольку спецификация соответствия может включать последовательную трассировку, комбинация &lt;code&gt;dbg&lt;/code&gt; и &lt;code&gt;seq_trace&lt;/code&gt; может быть довольно мощной. В этом кратком примере показан сеанс, в котором используется последовательная трассировка:</target>
        </trans-unit>
        <trans-unit id="57ca2c648144ecb05c83959a4bb6906fc7dba92e" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;add_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">В рамках процедуры &lt;code&gt;add_frag&lt;/code&gt; Mnesia перебирает все фрагменты, соответствующие номерам &lt;code&gt;IterFrags&lt;/code&gt; , и запускает &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; для каждой записи. Если новый фрагмент отличается от старого, запись перемещается в новый фрагмент.</target>
        </trans-unit>
        <trans-unit id="afa5aac0272b889e29ab3d3e2445e190b23afd3b" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;del_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">В рамках процедуры &lt;code&gt;del_frag&lt;/code&gt; Mnesia перебирает все фрагменты, соответствующие номерам &lt;code&gt;IterFrags&lt;/code&gt; , и запускает &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; для каждой записи. Если новый фрагмент отличается от старого, запись перемещается в новый фрагмент.</target>
        </trans-unit>
        <trans-unit id="e1a32b7616ffad81dc2a3990b12ee743d67d1150" translate="yes" xml:space="preserve">
          <source>As a port driver is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang. Calling functions in the port driver requires no context switches. But it is also the least safe way, because a crash in the port driver brings the emulator down too.</source>
          <target state="translated">Так как драйвер порта динамически связан с процессом эмулятора,это самый быстрый способ вызова C-кода из Erlang.Вызов функций в драйвере порта не требует переключения контекста.Но это также и наименее безопасный способ,так как сбой в драйвере порта приводит к падению и эмулятора.</target>
        </trans-unit>
        <trans-unit id="67c16b741f04ea5b7b054409fb35ff1c48cb01da" translate="yes" xml:space="preserve">
          <source>As a side effect, the function prints the name of each module it tries to compile. If compilation fails for a module, the make procedure stops and &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">В качестве побочного эффекта функция выводит имя каждого модуля, который пытается скомпилировать. Если компиляция модуля завершается неудачно, процедура make останавливается и возвращается &lt;code&gt;error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bef2be0aff2e7e47dd8199f96ca616049e6fbecf" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;{message, false}&lt;/code&gt; disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the &lt;code&gt;MatchBody&lt;/code&gt; part are desired.</source>
          <target state="translated">В качестве особого случая &lt;code&gt;{message, false}&lt;/code&gt; отключает отправку сообщений трассировки ('call' и 'return_to') для этого вызова функции, как если бы не совпала спецификация соответствия. Это может быть полезно, если желательны только побочные эффекты части &lt;code&gt;MatchBody&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc75067c89eb230d3aeaa930304e48d7ffc6b8ce" translate="yes" xml:space="preserve">
          <source>As a special case, drivers can be unloaded from processes that have done no corresponding call to &lt;code&gt;try_load/3&lt;/code&gt; if, and only if, there are &lt;strong&gt;no users of the driver at all&lt;/strong&gt;, which can occur if the process containing the last user dies.</source>
          <target state="translated">В качестве особого случая драйверы могут быть выгружены из процессов, которые не выполнили соответствующий вызов &lt;code&gt;try_load/3&lt;/code&gt; , если и только если &lt;strong&gt;нет пользователей драйвера вообще&lt;/strong&gt; , что может произойти, если процесс, содержащий последнего пользователя, умирает.</target>
        </trans-unit>
        <trans-unit id="b5a63aa06a92181b3a5ed95aec64c64b4bdd7c17" translate="yes" xml:space="preserve">
          <source>As a special case, the following apply in the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts:</source>
          <target state="translated">В качестве особого случая в &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; применяется следующее :</target>
        </trans-unit>
        <trans-unit id="03b85735e71929e52331dbf92e7f4188f735f3c7" translate="yes" xml:space="preserve">
          <source>As a test suite runs, all information (including output to &lt;code&gt;stdout&lt;/code&gt;) is recorded in many different log files. A minimum of information is displayed in the user console (only start and stop information, plus a note for each failed test case).</source>
          <target state="translated">При запуске набора тестов вся информация (включая вывод на стандартный &lt;code&gt;stdout&lt;/code&gt; ) записывается во множество различных файлов журналов. В пользовательской консоли отображается минимум информации (только информация о запуске и останове, а также примечания для каждого неудачного тестового примера).</target>
        </trans-unit>
        <trans-unit id="af27c23232c9332dfe458eed56f4e4ca1c250964" translate="yes" xml:space="preserve">
          <source>As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; functions, although Dets exports a similar interface.</source>
          <target state="translated">Поскольку все операции, выполняемые Dets, являются дисковыми, важно понимать, что одна операция поиска включает в себя серию операций поиска и чтения на диске. Поэтому функции Dets намного медленнее, чем соответствующие функции &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; , хотя Dets экспортирует аналогичный интерфейс.</target>
        </trans-unit>
        <trans-unit id="eb95848bc99a15bbb0e15871e436bb30c7e336fc" translate="yes" xml:space="preserve">
          <source>As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and &quot;Saturday&quot;.</source>
          <target state="translated">Так как альтернативные ветки пробуются слева направо,а опции не сбрасываются до конца подмаскировки,установка опций в одной ветке влияет на последующие ветки,поэтому вышеприведенные модели совпадают и с &quot;SUNDAY&quot;,и с &quot;Saturday&quot;.</target>
        </trans-unit>
        <trans-unit id="3c01043c234b4ec0c86a33f6ba721a734f751f6e" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;-pa&lt;/code&gt;, if several directories are to be prepended to the code path and the directories have a common parent directory, that parent directory can be specified in environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;-pa&lt;/code&gt; , если несколько каталогов должны быть добавлены к пути кода и каталоги имеют общий родительский каталог, этот родительский каталог может быть указан в переменной среды &lt;code&gt;ERL_LIBS&lt;/code&gt; ; см. &lt;code&gt;code(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88dc064e87e4d93064611ba4390a686486fbcb39" translate="yes" xml:space="preserve">
          <source>As an alternative to building a bootscript, you can explicitly add the path to the SSL &lt;code&gt;ebin&lt;/code&gt; directory on the command line. This is done with command-line option &lt;code&gt;-pa&lt;/code&gt;. This works as the SSL application does not need to be started for the distribution to come up, as a clone of the SSL application is hooked into the Kernel application. So, as long as the SSL application code can be reached, the distribution starts. The &lt;code&gt;-pa&lt;/code&gt; method is only recommended for testing purposes.</source>
          <target state="translated">В качестве альтернативы созданию сценария начальной загрузки вы можете явно добавить путь к &lt;code&gt;ebin&lt;/code&gt; SSL ebin в командной строке. Это делается с помощью параметра командной строки &lt;code&gt;-pa&lt;/code&gt; . Это работает, поскольку приложение SSL не нужно запускать для распространения, так как клон приложения SSL подключен к приложению ядра. Итак, пока доступен код приложения SSL, начинается распространение. Метод &lt;code&gt;-pa&lt;/code&gt; рекомендуется только в целях тестирования.</target>
        </trans-unit>
        <trans-unit id="99c43706bedf3f37ba2bc1f77eaef7f141bffa35" translate="yes" xml:space="preserve">
          <source>As an alternative to sorting files, a function of one argument can be specified as input. When called with argument &lt;code&gt;read&lt;/code&gt;, the function is assumed to return either of the following:</source>
          <target state="translated">В качестве альтернативы сортировке файлов в качестве входных данных может быть указана функция одного аргумента. Предполагается, что при вызове с аргументом &lt;code&gt;read&lt;/code&gt; функция возвращает одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="aa2f69a7cd9917454bfd5b22b175f310f6d2bfae" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-callback&lt;/code&gt; and &lt;code&gt;-optional_callbacks&lt;/code&gt; attributes you may directly implement and export &lt;code&gt;behaviour_info()&lt;/code&gt;:</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;-callback&lt;/code&gt; и &lt;code&gt;-optional_callbacks&lt;/code&gt; атрибутов может непосредственно осуществлять и экспорт &lt;code&gt;behaviour_info()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c35ac71302602496215802d2ceb07a268d8ab46b" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on the host at the other end of the TCP socket.</source>
          <target state="translated">В качестве альтернативы, уже открытый сокет TCP можно передать функции в &lt;code&gt;TcpSocket&lt;/code&gt; . Инициирование и согласование SSH будут инициированы на этом сервере, и, наконец, оболочка будет запущена на хосте на другом конце сокета TCP.</target>
        </trans-unit>
        <trans-unit id="310627ae72667d56b80e90bfe9262f70c174ac28" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one when an SSH starts at the other end of the TCP socket.</source>
          <target state="translated">В качестве альтернативы, уже открытый сокет TCP можно передать функции в &lt;code&gt;TcpSocket&lt;/code&gt; . Инициирование и согласование SSH будут инициированы на нем, когда SSH запускается на другом конце сокета TCP.</target>
        </trans-unit>
        <trans-unit id="273b6d8022e0a14e661c5ebb9acfcaf89acecfbc" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one with the SSH that should be at the other end.</source>
          <target state="translated">В качестве альтернативы, уже открытый сокет TCP можно передать функции в &lt;code&gt;TcpSocket&lt;/code&gt; . Инициирование и согласование SSH будут инициированы на том, с SSH, который должен быть на другом конце.</target>
        </trans-unit>
        <trans-unit id="b0d2d299871acdd7ed8b13c9605799bbdca8d746" translate="yes" xml:space="preserve">
          <source>As an example let's add the Diffie-Hellman Group1 first in the kex list. It is supported according to &lt;code&gt;Supported algoritms&lt;/code&gt;.</source>
          <target state="translated">В качестве примера давайте сначала добавим группу Diffie-Hellman Group1 в список kex. Поддерживается в соответствии с &lt;code&gt;Supported algoritms&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fed952b378ed463bdf14ff665fe8061e73af37b" translate="yes" xml:space="preserve">
          <source>As an example of analyzing indirect calls, the following Erlang function tries to answer the question: if we want to know which modules are used indirectly by some module(s), is it worth while using the &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; rather than the module graph? Recall that a module M1 is said to call a module M2 if there is some function in M1 that calls some function in M2. It would be nice if we could use the much smaller module graph, since it is available also in the light weight &lt;code&gt;modules&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of Xref servers.</source>
          <target state="translated">В качестве примера анализа косвенных вызовов следующая функция Erlang пытается ответить на вопрос: если мы хотим знать, какие модули косвенно используются каким-либо модулем (модулями), стоит ли использовать &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; а не график модулей? Напомним, что модуль M1 называется вызывающим модуль M2, если есть функция в M1, которая вызывает некоторую функцию из M2. Было бы хорошо , если бы мы могли бы использовать гораздо меньший модуль график, так как он доступен также в легком весе &lt;code&gt;modules&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; серверов перекодировки.</target>
        </trans-unit>
        <trans-unit id="c9dcf4f61625ae0867c30f6f2ec1a54ebcaa12ae" translate="yes" xml:space="preserve">
          <source>As an example of how the function can be used, we create an interpreted escript that uses &lt;code&gt;emu_args&lt;/code&gt; to set some emulator flag. In this case, it happens to disable the &lt;code&gt;smp_support&lt;/code&gt;. We also extract the different sections from the newly created script:</source>
          <target state="translated">В качестве примера того, как можно использовать функцию, мы создаем интерпретируемый эскрипт, который использует &lt;code&gt;emu_args&lt;/code&gt; для установки некоторого флага эмулятора. В этом случае происходит отключение &lt;code&gt;smp_support&lt;/code&gt; . Мы также извлекаем различные разделы из вновь созданного скрипта:</target>
        </trans-unit>
        <trans-unit id="93e8253d4bef52c01714100b16613baca9f2eb65" translate="yes" xml:space="preserve">
          <source>As an example of how to use function &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;, the implementation of a QLC table for the &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; module is given:</source>
          <target state="translated">В качестве примера использования функции &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; приведена реализация таблицы QLC для модуля &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d7686e8d3cae0d8b83f082414847869122b1c718" translate="yes" xml:space="preserve">
          <source>As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair &lt;code&gt;{3,4}&lt;/code&gt;, where character positions are zero-based, just as in offsets:</source>
          <target state="translated">В качестве примера поведения по умолчанию следующий вызов возвращает в качестве первой и единственной захваченной строки соответствующую часть объекта (&amp;laquo;abcd&amp;raquo; в середине) в виде пары индексов &lt;code&gt;{3,4}&lt;/code&gt; , где позиции символов равны нулю - на основе, как и в смещениях:</target>
        </trans-unit>
        <trans-unit id="1363c4916ced9b1c12e495d959e392b062a979b7" translate="yes" xml:space="preserve">
          <source>As an example of these rules, suppose you want to write the function &lt;code&gt;select&lt;/code&gt;, which selects certain elements from a list of tuples. Suppose you write &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; with the intention of extracting all tuples from &lt;code&gt;L&lt;/code&gt;, where the first item is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">В качестве примера этих правил предположим, что вы хотите написать функцию &lt;code&gt;select&lt;/code&gt; , которая выбирает определенные элементы из списка кортежей. Предположим, вы написали &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; с целью извлечения всех кортежей из &lt;code&gt;L&lt;/code&gt; , где первый элемент &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d77fac41d8f6ac13e4c80ca8e1c35a37d97d30a" translate="yes" xml:space="preserve">
          <source>As an example, assume that the old maximum number of files is 10 and that the new maximum number of files is 6. If the current file number is not greater than the new maximum number of files, files 7-10 are removed when file 6 is full and the log starts to write to file number 1 again. Otherwise, the files greater than the current file are removed when the current file is full (for example, if the current file is 8, files 9 and 10 are removed). The files between the new maximum number of files and the current file (that is, files 7 and 8) are removed the next time file 6 is full.</source>
          <target state="translated">В качестве примера предположим,что старое максимальное количество файлов равно 10,а новое максимальное количество файлов равно 6.Если текущий номер файла не больше нового максимального количества файлов,то файлы 7-10 удаляются,когда файл 6 заполнен и журнал снова начинает записываться в файл 1.В противном случае при заполнении текущего файла удаляются файлы больше текущего (например,если текущий файл 8,то удаляются файлы 9 и 10).Файлы между новым максимальным количеством файлов и текущим файлом (т.е.файлы 7 и 8)удаляются при следующем заполнении файла 6.</target>
        </trans-unit>
        <trans-unit id="6df1dd563dff5d559d5237ab7b1799899d2a4427" translate="yes" xml:space="preserve">
          <source>As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms.</source>
          <target state="translated">В качестве примера рассмотрим сортировку терминов в дисковом лог-файле.В качестве входного файла используется функция,которая считывает куски из дискового журнала и возвращает список двоичных файлов.Результаты собираются в список терминов.</target>
        </trans-unit>
        <trans-unit id="9ef05760a87925d5316892398ba7e6735c0cc668" translate="yes" xml:space="preserve">
          <source>As an example, consider the following record definition:</source>
          <target state="translated">В качестве примера рассмотрим следующее определение записи:</target>
        </trans-unit>
        <trans-unit id="0bace29d40d7981ee102e27dfe23de3fe372b080" translate="yes" xml:space="preserve">
          <source>As an example, contemplate the issue of converting between upper and lower case letters. Reading the standard makes you realize that there is not a simple one to one mapping in all scripts, for example:</source>
          <target state="translated">В качестве примера рассмотрим вопрос о конвертации между заглавными и строчными буквами.Читая стандарт,вы понимаете,что не существует простого отображения во всех скриптах,например:</target>
        </trans-unit>
        <trans-unit id="0e81b4992cba2b699d381459f734b8216213b6b3" translate="yes" xml:space="preserve">
          <source>As an example, list comprehensions can be used to simplify some of the functions in &lt;code&gt;lists.erl&lt;/code&gt;:</source>
          <target state="translated">В качестве примера, понимание списков может использоваться для упрощения некоторых функций в &lt;code&gt;lists.erl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1e3067854a4c9b6a2c74afda818dcdb334e651b" translate="yes" xml:space="preserve">
          <source>As an example, one can insert an object with &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; as a key in an &lt;code&gt;ordered_set&lt;/code&gt; and get the object returned as a result of doing a &lt;code&gt;lookup/2&lt;/code&gt; with &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; as the key to search for.</source>
          <target state="translated">Например, можно вставить объект с &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; в качестве ключа в &lt;code&gt;ordered_set&lt;/code&gt; и получить объект, возвращенный в результате выполнения &lt;code&gt;lookup/2&lt;/code&gt; с &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; в качестве ключа для поиска.</target>
        </trans-unit>
        <trans-unit id="66fc66c449548ea231626daea7c93210ea8cbc49" translate="yes" xml:space="preserve">
          <source>As an example, one can let trace messages be sent over the network to another Erlang node (preferably &lt;strong&gt;not&lt;/strong&gt; distributed), where the formatting occurs:</source>
          <target state="translated">Например, можно разрешить отправку сообщений трассировки по сети на другой узел Erlang (желательно &lt;strong&gt;не&lt;/strong&gt; распределенный), где происходит форматирование:</target>
        </trans-unit>
        <trans-unit id="e7c1111ab56bf671a69f40fa390abccb417d88d6" translate="yes" xml:space="preserve">
          <source>As an example, suppose that you want to start a slave node at host &lt;code&gt;H&lt;/code&gt; with node name &lt;code&gt;Name@H&lt;/code&gt; and want the slave node to have the following properties:</source>
          <target state="translated">В качестве примера предположим, что вы хотите запустить подчиненный узел на хосте &lt;code&gt;H&lt;/code&gt; с именем узла &lt;code&gt;Name@H&lt;/code&gt; и хотите, чтобы подчиненный узел имел следующие свойства:</target>
        </trans-unit>
        <trans-unit id="8f6e43ba50d78085627070b9be2ee7833e58261c" translate="yes" xml:space="preserve">
          <source>As an example, the I/O server for the interactive shell (in &lt;code&gt;group.erl&lt;/code&gt;) understands the following options:</source>
          <target state="translated">Например, сервер ввода-вывода для интерактивной оболочки (в &lt;code&gt;group.erl&lt;/code&gt; ) понимает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="d726847c4d6dbe66ba80230721adc5bfacc18e04" translate="yes" xml:space="preserve">
          <source>As an example, we will use the following function, that you may recognise as a slightly modified benchmark function from the manpage file(3):</source>
          <target state="translated">В качестве примера мы используем следующую функцию,которую вы можете распознать как слегка измененную функцию эталона из файла manpage(3):</target>
        </trans-unit>
        <trans-unit id="67171017e640943dfb29d4cbec09fb767fa51114" translate="yes" xml:space="preserve">
          <source>As an snmp adaption usually keeps the index for the whole of the systems lifetime, this is rarely a problem.</source>
          <target state="translated">Поскольку snmp-адаптация обычно сохраняет индекс на протяжении всего времени жизни системы,это редко является проблемой.</target>
        </trans-unit>
        <trans-unit id="319bb3abd29884b1375ba09774a3c06c1a190a13" translate="yes" xml:space="preserve">
          <source>As another example, consider concatenating the answers to two queries &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; while removing all duplicates. This is accomplished by using option &lt;code&gt;unique&lt;/code&gt;:</source>
          <target state="translated">В качестве другого примера рассмотрим объединение ответов на два запроса &lt;code&gt;QH1&lt;/code&gt; и &lt;code&gt;QH2&lt;/code&gt; при удалении всех дубликатов. Это достигается с помощью опции &lt;code&gt;unique&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="002e4414e669ace8432711f4ee7463efc45a9f68" translate="yes" xml:space="preserve">
          <source>As any other type of scripts, Erlang scripts do not work on Unix platforms if the execution bit for the script file is not set. (To turn on the execution bit, use &lt;code&gt;chmod +x script-name&lt;/code&gt;.)</source>
          <target state="translated">Как и любой другой тип сценариев, сценарии Erlang не работают на платформах Unix, если бит выполнения для файла сценария не установлен. (Чтобы включить бит выполнения, используйте &lt;code&gt;chmod +x script-name&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="66b2e146ed4ec9e49f678bedfee3350f88534599" translate="yes" xml:space="preserve">
          <source>As any variable that occurs in the head of a fun is considered a new variable, it is equally valid to write as follows:</source>
          <target state="translated">Так как любая переменная,возникающая в голове у веселья,считается новой переменной,то одинаково корректно записывать следующее:</target>
        </trans-unit>
        <trans-unit id="90f853228a72190e3c182428d8aa021055665aa1" translate="yes" xml:space="preserve">
          <source>As can be noted above, the parameter list can be matched against a single &lt;code&gt;MatchVariable&lt;/code&gt; or an &lt;code&gt;'_'&lt;/code&gt;. To replace the whole parameter list with a single variable is a special case. In all other cases the &lt;code&gt;MatchHead&lt;/code&gt; must be a &lt;strong&gt;proper&lt;/strong&gt; list.</source>
          <target state="translated">Как можно было заметить выше, список параметров может быть сопоставлен с одной &lt;code&gt;MatchVariable&lt;/code&gt; или &lt;code&gt;'_'&lt;/code&gt; . Замена всего списка параметров одной переменной - особый случай. Во всех остальных случаях &lt;code&gt;MatchHead&lt;/code&gt; должен быть &lt;strong&gt;правильным&lt;/strong&gt; списком.</target>
        </trans-unit>
        <trans-unit id="f45447aff436963dfcba66b79f762faf452d90b1" translate="yes" xml:space="preserve">
          <source>As can be seen from the figures above there is no real difference between a non-reentrant and an reentrant flex scanner when it comes to the decode times of an individual message.</source>
          <target state="translated">Как видно из рисунков выше,нет никакой реальной разницы между не входящим и возвращающимся флекс-сканером,когда речь идет о времени декодирования отдельного сообщения.</target>
        </trans-unit>
        <trans-unit id="5f43e75c9b3fbee4477b49b641a7fb630b3c13f5" translate="yes" xml:space="preserve">
          <source>As can be seen, the fun used with &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; takes a single list as parameter instead of a single tuple. The list matches a list of the parameters to the traced function. A single variable can also be used. The body of the fun expresses, in a more imperative way, actions to be taken if the fun head (and the guards) matches. &lt;code&gt;true&lt;/code&gt; is returned here, only because the body of a fun cannot be empty. The return value is discarded.</source>
          <target state="translated">Как можно видеть, &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; используемая с dbg: fun2ms / 1, принимает в качестве параметра один список вместо одного кортежа. Список соответствует списку параметров отслеживаемой функции. Также можно использовать одну переменную. Тело веселья более императивно выражает действия, которые необходимо предпринять, если голова веселья (и охранники) совпадают. Здесь возвращается &lt;code&gt;true&lt;/code&gt; только потому, что тело веселья не может быть пустым. Возвращаемое значение отбрасывается.</target>
        </trans-unit>
        <trans-unit id="606f60b3cba3318c2eecb57b2a49a6b6b1a39eb6" translate="yes" xml:space="preserve">
          <source>As can be seen, the functions above are just the type of functions that are to be provided in &lt;code&gt;get_until&lt;/code&gt; requests.</source>
          <target state="translated">Как видно, приведенные выше функции - это просто функции, которые должны быть предоставлены в запросах &lt;code&gt;get_until&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="191e8e1e5a9e73a6798b23edb476be7abc2c9de8" translate="yes" xml:space="preserve">
          <source>As default result sets are returned as a lists of tuples. The &lt;code&gt;TupleMode&lt;/code&gt; option still exists to keep some degree of backwards compatibility. If the option is set to off, result sets will be returned as a lists of lists instead of a lists of tuples.</source>
          <target state="translated">По умолчанию наборы результатов возвращаются в виде списков кортежей. Параметр &lt;code&gt;TupleMode&lt;/code&gt; все еще существует для сохранения некоторой степени обратной совместимости. Если этот параметр выключен, наборы результатов будут возвращаться как списки списков, а не списки кортежей.</target>
        </trans-unit>
        <trans-unit id="17700b7b2c5191dc7a064a620902163dd840f68f" translate="yes" xml:space="preserve">
          <source>As described in Robert's paper, I/O servers and clients communicate using &lt;code&gt;io_request&lt;/code&gt;/&lt;code&gt;io_reply&lt;/code&gt; tuples as follows:</source>
          <target state="translated">Как описано в статье Роберта, серверы ввода-вывода и клиенты взаимодействуют с использованием &lt;code&gt;io_request&lt;/code&gt; / &lt;code&gt;io_reply&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="d5e4f17183134fe62fa988455bb38a208a7f52d2" translate="yes" xml:space="preserve">
          <source>As documented, the election assumes knowledge of a peer's DiameterIdentity when initiating a connection, which diameter doesn't require. Connections will be accepted if configuration allows multiple connections per peer to be established or there is no existing connection. Note that the election process is only applicable when multiple connections per peer is disallowed.</source>
          <target state="translated">Как документально подтверждено,выборы предполагают знание DiameterIdentity (Диаметр равны),когда инициируется соединение,диаметр которого не требует.Соединения будут приниматься,если конфигурация позволяет установить несколько соединений на один равный,или если соединение не существует.Обратите внимание,что избирательный процесс применим только в том случае,если несколько соединений на однообразную группу запрещено.</target>
        </trans-unit>
        <trans-unit id="5435f11ff35ae6054509834ff9cbbd3dacb50a82" translate="yes" xml:space="preserve">
          <source>As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. &lt;code&gt;gen_event&lt;/code&gt; is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with &lt;code&gt;Reason&lt;/code&gt;, or returns a bad value &lt;code&gt;Term&lt;/code&gt;, the event manager does not fail. It deletes the event handler by calling callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt;, giving as argument &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. No other event handler is affected.</source>
          <target state="translated">Поскольку каждый обработчик событий представляет собой один модуль обратного вызова, диспетчер событий имеет множество модулей обратного вызова, которые добавляются и удаляются динамически. &lt;code&gt;gen_event&lt;/code&gt; более терпим к ошибкам модуля обратного вызова, чем другие варианты поведения. Если функция обратного вызова для установленного обработчика событий дает сбой с &lt;code&gt;Reason&lt;/code&gt; или возвращает неверное значение &lt;code&gt;Term&lt;/code&gt; , диспетчер событий не дает сбой. Он удаляет обработчик событий, вызывая функцию обратного вызова &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; , передавая в качестве аргумента &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; или &lt;code&gt;{error,Term}&lt;/code&gt; соответственно. Никакой другой обработчик событий не затронут.</target>
        </trans-unit>
        <trans-unit id="cf9e38f9c03cb4cfe6ebeed4a9cd9c1754bcff3e" translate="yes" xml:space="preserve">
          <source>As evaluating this function causes the process to terminate, it has no return value unless the arguments are invalid, in which case the function &lt;strong&gt;returns the error reason&lt;/strong&gt;&lt;code&gt;badarg&lt;/code&gt;. If you want to be sure not to return, you can call &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; and hope to distinguish exceptions later.</source>
          <target state="translated">Поскольку оценка этой функции приводит к завершению процесса, она не имеет возвращаемого значения, если аргументы не являются недопустимыми, и в этом случае функция &lt;strong&gt;возвращает причину ошибки &lt;/strong&gt; &lt;code&gt;badarg&lt;/code&gt; . Если вы хотите быть уверены, что не вернетесь, вы можете вызвать &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; и надеяться позже распознавать исключения.</target>
        </trans-unit>
        <trans-unit id="2842aa39be48bf38b0c0560d59180375acac20be" translate="yes" xml:space="preserve">
          <source>As everyone trying to use &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;dbg&lt;/code&gt; seems to end up reading this manual page, this description is an introduction to the concept of match specifications.</source>
          <target state="translated">Поскольку все, кто пытается использовать &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;dbg&lt;/code&gt; , похоже, в конечном итоге читают эту страницу руководства, это описание является введением в концепцию спецификаций соответствия.</target>
        </trans-unit>
        <trans-unit id="91ed2cd090a035beba9495ca5c354901e71094c0" translate="yes" xml:space="preserve">
          <source>As expected, double of 10 is 20.</source>
          <target state="translated">Как и ожидалось,удвоение 10-20.</target>
        </trans-unit>
        <trans-unit id="4e58a012dddf03e3db23dd481662a4b03cf78027" translate="yes" xml:space="preserve">
          <source>As far as we know by the time of writing, it is infeasible to break &lt;code&gt;des3_cbc&lt;/code&gt; encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information &lt;strong&gt;should&lt;/strong&gt; be safe from intruders.</source>
          <target state="translated">Насколько нам известно на момент написания, невозможно взломать шифрование &lt;code&gt;des3_cbc&lt;/code&gt; , не зная ключа. Следовательно, до тех пор, пока ключ хранится в безопасности и не поддается распознаванию, зашифрованная отладочная информация &lt;strong&gt;должна&lt;/strong&gt; быть защищена от злоумышленников.</target>
        </trans-unit>
        <trans-unit id="9f24794a82149383ffae0568581aa4a52378ab67" translate="yes" xml:space="preserve">
          <source>As file times are stored in POSIX time on most OS, it is faster to query file information with option &lt;code&gt;posix&lt;/code&gt;.</source>
          <target state="translated">Поскольку время файла хранится во времени POSIX в большинстве ОС, быстрее запрашивать информацию о файле с опцией &lt;code&gt;posix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61df7f84fe1d4826c5be72f8b4bc768821e8d381" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;i/1&lt;/code&gt; and &lt;code&gt;ni/1&lt;/code&gt;, a module can be specified by its module name or filename.</source>
          <target state="translated">Что касается &lt;code&gt;i/1&lt;/code&gt; и &lt;code&gt;ni/1&lt;/code&gt; , модуль можно указать по имени или имени файла.</target>
        </trans-unit>
        <trans-unit id="3a8f23a48e1867cb7be6b7e031f9615ed3dd2a0d" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;select&lt;/code&gt;, the table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</source>
          <target state="translated">Что касается &lt;code&gt;select&lt;/code&gt; , таблица просматривается путем вызова &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; . Разница в том, что спецификация соответствия указывается явно. Таким образом можно указать спецификации соответствия, которые нельзя легко выразить в синтаксисе QLC.</target>
        </trans-unit>
        <trans-unit id="f0387e8c16bce6477d55e9ca9b7e7cb6c002c7dd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</source>
          <target state="translated">Как и в ERTS 5.10,все сигналы от процессов к портам поступают действительно асинхронно.</target>
        </trans-unit>
        <trans-unit id="e9113f3079af7b202922889fc7baf1985e8c3b0f" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Начиная с ERTS 5.5 (Erlang / OTP R11B), это значение не включает сокращения, выполненные в текущих квантах времени текущих запланированных процессов. Если требуется точное значение, используйте &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9466fb03b2f8f448def70765eb14302f05b1d4a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</source>
          <target state="translated">Как и в ERTS 5.5.2,сигналы выхода к процессам поступают действительно асинхронно.</target>
        </trans-unit>
        <trans-unit id="0d8b23980173959043ec4b6b8e4640034ae1c36c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="translated">Начиная с ERTS 5.5.3 интерфейс драйвера был расширен (см. &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt; ). Расширенный интерфейс представляет собой &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; , возможность передавать флаги возможностей (см. &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt; ) в систему времени выполнения при инициализации драйвера и некоторые новые функции API драйвера.</target>
        </trans-unit>
        <trans-unit id="19ca09aeee3e5a4978501284aa2a30557b389ea8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Начиная с ERTS 5.5.3 интерфейс драйвера был расширен контролем версий и возможностью передачи информации о возможностях. Флаги возможностей присутствуют в строке 48. Начиная с ERTS 5.7.4, флаг &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; требуется для драйверов, которые должны использоваться дистрибутивом. Флаг мягкой занятости подразумевает, что драйвер может обрабатывать вызовы &lt;code&gt;outputv&lt;/code&gt; вызовов &lt;code&gt;output&lt;/code&gt; и outputv, хотя он пометил себя как занятый. Это всегда было требованием к драйверам, используемым дистрибутивом, но ранее информация о возможностях не была доступна. Чтобы получить больше информации. см. &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a78fa09b1376522e4bce196c1fb535907b82e7d" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.4.3 the default stack size for threads in the async-thread pool is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the amount of async-threads can be quite large. The default stack size is enough for drivers delivered with Erlang/OTP, but is possibly not sufficiently large for other dynamically linked-in drivers that use the &lt;code&gt;driver_async&lt;/code&gt; functionality. A suggested stack size for threads in the async-thread pool can be configured through command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Начиная с ERTS 5.5.4.3 размер стека по умолчанию для потоков в пуле асинхронных потоков составляет 16 килобайт, то есть 64 килобайта на 32-битных архитектурах. Этот небольшой размер по умолчанию был выбран потому, что количество асинхронных потоков может быть довольно большим. Размер стека по умолчанию достаточен для драйверов, поставляемых с Erlang / OTP, но, возможно, недостаточно велик для других динамически подключаемых драйверов, которые используют функциональность &lt;code&gt;driver_async&lt;/code&gt; . Предлагаемый размер стека для потоков в пуле асинхронных потоков можно настроить с помощью аргумента командной строки &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6e9cd2bd7de01214fb3ff560ba3219fdc3a33fd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than &lt;code&gt;temp_alloc&lt;/code&gt;. This because it only causes problems for other allocators.</source>
          <target state="translated">Начиная с ERTS 5.6.1 эмулятор отказывается использовать эту стратегию в других распределителях, кроме &lt;code&gt;temp_alloc&lt;/code&gt; . Это потому, что это вызывает проблемы только для других распределителей.</target>
        </trans-unit>
        <trans-unit id="c9cdb7d3c60a1b802e1be9fa56092fa96daa0110" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; requires that all &lt;code&gt;erts_alloc(3)&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">Начиная с ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; требует, чтобы были &lt;code&gt;erts_alloc(3)&lt;/code&gt; все распределители erts_alloc (3) (поведение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="0648017001664f8866e87e3887eab6500d7d8d5c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; requires that all &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">Начиная с ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; требует, чтобы были &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; все распределители erts_alloc (3) (поведение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="03c3044d6f35884274a0ea9ce93bcb4a6dd2e7b8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This protocol introduced the distribution header. Nodes with an ERTS version earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache are used.</source>
          <target state="translated">Начиная с версии ERTS 5.7.2,старый протокол атомного кэша был удален,а новый был представлен.Этот протокол ввел дистрибутивный заголовок.Узлы с версией ERTS ранее 5.7.2 все еще могут взаимодействовать с новыми узлами,но при этом не используется заголовок дистрибутива и атомный кэш.</target>
        </trans-unit>
        <trans-unit id="d0bf3fb747dbb4638699932cce5b52da0fd8c732" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the runtime system passes a distribution flag in the handshake stage that enables the use of a &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; on all messages passed. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">Начиная с ERTS 5.7.2, исполняющая система передает флаг распределения на этапе установления связи, который позволяет использовать &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; для всех переданных сообщений. Сообщения, передаваемые между узлами, в этом случае имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="32ca42b8d63db763c29dc94fc4d01b222bd06006" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Начиная с ERTS 5.9 (Erlang / OTP R15B) интерфейс драйвера был изменен на более крупные типы для &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; обратных вызовов . См. &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; драйверов в erl_driver .</target>
        </trans-unit>
        <trans-unit id="ed0ea6cc1d812d63e5d244adc339b28e36e76666" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors. For more information, see system flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Начиная с ERTS 5.9 (Erlang / OTP R15B), исполняющая система по умолчанию &lt;strong&gt;не&lt;/strong&gt; связывает планировщики с логическими процессорами. Для получения дополнительной информации см системного флага &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90a69eabde7b774111db809b2a3f8cd2e6d93bb9" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Начиная с ERTS 5.9 старые драйверы необходимо перекомпилировать и использовать расширенный интерфейс. Они также должны быть настроены на &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt; с поддержкой 64-разрядной версии .</target>
        </trans-unit>
        <trans-unit id="d18bc1c72ccf3f56d64803c503d7a9ae14a8c4e0" translate="yes" xml:space="preserve">
          <source>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes that still execute the old code is killed by this function. In earlier versions, such incorrect use could cause much more fatal failures, like emulator crash.</source>
          <target state="translated">Начиная с ERTS 8.0 (Erlang/OTP 19),эта функция убивает любые затянувшиеся процессы,которые все еще выполняют старый код.В более ранних версиях такое некорректное использование могло привести к гораздо более фатальным отказам,например,к аварийному завершению работы эмулятора.</target>
        </trans-unit>
        <trans-unit id="eaa0884ce96d8d06eafbfe246ea264efc463f164" translate="yes" xml:space="preserve">
          <source>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode characters and are always encoded using the UTF-8 external formats &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;. The old Latin-1 formats &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; are deprecated and are only kept for backward compatibility when decoding terms encoded by older nodes.</source>
          <target state="translated">Начиная с ERTS 9.0 (OTP 20), атомы могут содержать любые символы Unicode и всегда кодируются с использованием внешних форматов UTF-8 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; . Старые форматы Latin-1 &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; не рекомендуются и сохраняются только для обратной совместимости при декодировании терминов, закодированных более старыми узлами.</target>
        </trans-unit>
        <trans-unit id="432b2e5b8c0948df031dfa90355327eda74cb917" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt;System principles&lt;/code&gt; in System Documentation.</source>
          <target state="translated">Начиная с Erlang / OTP 17, номер версии OTP соответствует основному номеру версии OTP. Нет &lt;code&gt;erlang:system_info()&lt;/code&gt; аргумент дает точную версию OTP. Это связано с тем, что точную версию OTP в общем случае определить сложно. Дополнительные сведения см. В описании версий в разделе &amp;laquo; &lt;code&gt;System principles&lt;/code&gt; системы&amp;raquo; в документации по системе.</target>
        </trans-unit>
        <trans-unit id="a73c626964af738d0bf5772ed44b01c65f1937d2" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 18 (ERTS 7.0) the time functionality has been extended. This includes a &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; for time and &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; that change the system behavior when system time changes.</source>
          <target state="translated">Начиная с Erlang / OTP 18 (ERTS 7.0) функциональность времени была расширена. Это включает &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; времени и временной деформации, которые изменяют поведение системы при изменении системного времени.</target>
        </trans-unit>
        <trans-unit id="ecb4c90c54fe542574fe5a3d1dc6ac0bee28192e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;String&lt;/code&gt; may contain any Unicode character. Earlier versions allowed only ISO-latin-1 characters as the implementation did not allow Unicode characters above 255. For more information on Unicode support in atoms, see &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">Начиная с Erlang / OTP 20, &lt;code&gt;String&lt;/code&gt; может содержать любой символ Unicode. Более ранние версии допускали только символы ISO-latin-1, поскольку реализация не допускала символы Unicode выше 255. Для получения дополнительной информации о поддержке Unicode в атомах см. &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; в кодировке UTF-8 в разделе &amp;laquo;Внешний формат термина&amp;raquo; в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="a96169a26804822b5af1efdb6e68b574110fb9b3" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; is capable of encoding any Unicode character. Earlier versions would fail if the binary contained Unicode characters &amp;gt; 255. For more information about Unicode support in atoms, see the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">Начиная с Erlang / OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; может кодировать любой символ Unicode. Более ранние версии завершились ошибкой, если двоичный файл содержал символы Unicode&amp;gt; 255. Для получения дополнительной информации о поддержке Unicode в атомах см. &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; в кодировке UTF-8 в разделе &amp;laquo;Формат внешнего термина&amp;raquo; в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="880a395a4cc835daf564a6c2cb8b779237ad447e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, atoms can contain any Unicode character and &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; may fail if the text representation for &lt;code&gt;Atom&lt;/code&gt; contains a Unicode character &amp;gt; 255.</source>
          <target state="translated">Начиная с Erlang / OTP 20, атомы могут содержать любой символ Unicode, а &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; может завершиться ошибкой, если текстовое представление для &lt;code&gt;Atom&lt;/code&gt; содержит символ Unicode&amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="05e99f10299c611eb38d2e60ef290380c488aab4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 21.0, a field width of value &lt;code&gt;0&lt;/code&gt; can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example:</source>
          <target state="translated">Начиная с Erlang / OTP 21.0, ширина поля со значением &lt;code&gt;0&lt;/code&gt; может использоваться для указания того, что строка является бесконечно длинной, что означает, что разрывы строк не вставляются. Например:</target>
        </trans-unit>
        <trans-unit id="201cedcfe08f8b8dd67e3f18b939fb9656e57837" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="translated">Начиная с Erlang / OTP R13A, данные, передаваемые в функцию &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; , должны быть в формате &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; . Это означает, что программы, предоставляющие двоичные файлы для этой функции, должны преобразовать их в UTF-8, прежде чем пытаться вывести данные на устройство ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="d33e90079df692505b294a1290c3639aac4d952d" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_close/1&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Начиная с Erlang / OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; действительно асинхронный. Обратите внимание, что эта операция всегда документировалась как асинхронная операция, в то время как основная реализация была синхронной. &lt;code&gt;port_close/1&lt;/code&gt; по-прежнему полностью синхронен из-за его поведения при ошибках.</target>
        </trans-unit>
        <trans-unit id="847e19f07a1da0af86460018529c6ed10c09d277" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_command/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Начиная с Erlang / OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; действительно асинхронный. Обратите внимание, что эта операция всегда документировалась как асинхронная операция, в то время как основная реализация была синхронной. &lt;code&gt;port_command/2&lt;/code&gt; , однако, по-прежнему полностью синхронен из-за его поведения при ошибках.</target>
        </trans-unit>
        <trans-unit id="5ca95bf5c29d60d3f435edb308337e14ca27dfa7" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_connect/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Начиная с Erlang / OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; действительно асинхронный. Обратите внимание, что эта операция всегда документировалась как асинхронная операция, в то время как основная реализация была синхронной. &lt;code&gt;port_connect/2&lt;/code&gt; по-прежнему полностью синхронен из-за его поведения при ошибках.</target>
        </trans-unit>
        <trans-unit id="72f6bdc7a49b76220d72f254a24c40ac2103b81f" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, Erlang source files can be written in UTF-8 or bytewise (&lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt;) encoding. For information about how to state the encoding of an Erlang source file, see the &lt;code&gt;epp(3)&lt;/code&gt; module. As from Erlang/OTP R16, strings and comments can be written using Unicode. As from Erlang/OTP 20, also atoms and functions can be written using Unicode. Modules, applications, and nodes must still be named using characters from the ISO Latin-1 character set. (These restrictions in the language are independent of the encoding of the source file.)</source>
          <target state="translated">Начиная с Erlang / OTP R16, исходные файлы Erlang могут быть написаны в кодировке UTF-8 или побайтно ( &lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt; ). Для получения информации о том, как указать кодировку исходного файла Erlang, см. Модуль &lt;code&gt;epp(3)&lt;/code&gt; . Начиная с Erlang / OTP R16, строки и комментарии могут быть написаны с использованием Unicode. Начиная с Erlang / OTP 20, атомы и функции могут быть написаны с использованием Unicode. Модули, приложения и узлы должны по-прежнему называться с использованием символов из набора символов ISO Latin-1. (Эти ограничения на языке не зависят от кодировки исходного файла.)</target>
        </trans-unit>
        <trans-unit id="7886b46a773db0e50442aecaebbaf32b222b9fd4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the whole Unicode range by supplying startup flag &lt;code&gt;+pc latin1&lt;/code&gt; or &lt;code&gt;+pc unicode&lt;/code&gt;, respectively. For backward compatibility, &lt;code&gt;latin1&lt;/code&gt; is default. This only controls how heuristic string detection is done. More ranges are expected to be added in the future, enabling tailoring of the heuristics to the language and region relevant to the user.</source>
          <target state="translated">Начиная с Erlang / OTP R16B, вы можете выбрать диапазон ISO Latin-1 или весь диапазон Unicode, указав флаг запуска &lt;code&gt;+pc latin1&lt;/code&gt; или &lt;code&gt;+pc unicode&lt;/code&gt; соответственно. Для обратной совместимости по умолчанию используется &lt;code&gt;latin1&lt;/code&gt; . Это только контролирует, как выполняется эвристическое обнаружение строк. Ожидается, что в будущем будет добавлено больше диапазонов, что позволит адаптировать эвристику к языку и региону, актуальным для пользователя.</target>
        </trans-unit>
        <trans-unit id="716bfb66439cef7ad7bad31829606da528f05b26" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R9C, the &lt;code&gt;abstract_code&lt;/code&gt; chunk contains &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt;, where &lt;code&gt;AbstractCode&lt;/code&gt; is the abstract code as described in this section.</source>
          <target state="translated">Начиная с Erlang / OTP R9C, блок &lt;code&gt;abstract_code&lt;/code&gt; содержит &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt; , где &lt;code&gt;AbstractCode&lt;/code&gt; - абстрактный код, как описано в этом разделе.</target>
        </trans-unit>
        <trans-unit id="79439af412211da1e82f500e663913d9e02afa8d" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, and ERTS version 5.5.4, the following is guaranteed:</source>
          <target state="translated">Начиная с версии ядра 2.11.4,и ERTS версии 5.5.4,гарантируется следующее:</target>
        </trans-unit>
        <trans-unit id="e6086f606b9a19f3992ba56f0349c22f46bc841b" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, subscriptions can also be made before the &lt;code&gt;net_kernel&lt;/code&gt; server is started, that is, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; does not return &lt;code&gt;ignored&lt;/code&gt;.</source>
          <target state="translated">Начиная с версии ядра 2.11.4, подписки также могут быть сделаны до &lt;code&gt;net_kernel&lt;/code&gt; сервера net_kernel , то есть &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; не возвращает &lt;code&gt;ignored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12edcd68388680c33d418efadc851c1c0e7b367" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.13, and ERTS version 5.7, the following is guaranteed:</source>
          <target state="translated">Начиная с версии ядра 2.13 и ERTS версии 5.7 гарантируется следующее:</target>
        </trans-unit>
        <trans-unit id="2c683a693696d1ac1e9f3a076bd2cf07e0602bc8" translate="yes" xml:space="preserve">
          <source>As from R14A and forward, the compiler resolves calls without module prefix to local or imported functions before trying with auto-imported BIFs. If the BIF is to be called, use the &lt;code&gt;erlang&lt;/code&gt; module prefix in the call, not &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt;.</source>
          <target state="translated">Начиная с R14A и более поздних версий, компилятор разрешает вызовы без префикса модуля к локальным или импортированным функциям, прежде чем пытаться использовать автоматически импортированные BIF. Если БИФ будет называться, используйте &lt;code&gt;erlang&lt;/code&gt; модуль префикс в вызове, а не &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23bc1a56d40682c98cebd327d476b5499f2bfa45" translate="yes" xml:space="preserve">
          <source>As from beginning with R14A, the compiler no longer calls the auto-imported BIF if the name clashes with a local or explicitly imported function, and a call without explicit module name is issued. Instead, the local or imported function is called. Still accepting &lt;code&gt;nowarn_bif_clash&lt;/code&gt; would make a module calling functions clashing with auto-imported BIFs compile with both the old and new compilers, but with completely different semantics. This is why the option is removed.</source>
          <target state="translated">Начиная с R14A, компилятор больше не вызывает автоматически импортируемый BIF, если имя конфликтует с локальной или явно импортированной функцией, и выполняется вызов без явного имени модуля. Вместо этого вызывается локальная или импортированная функция. Тем не менее принятие &lt;code&gt;nowarn_bif_clash&lt;/code&gt; бы модуль вызова функций сталкивающихся с автоматическим импортирован BIFS компилировать с обеими старыми и новыми компиляторами, но с совершенно другой семантикой. Вот почему опция удалена.</target>
        </trans-unit>
        <trans-unit id="8624ad0f786ca708e353d31a82300424a2da173c" translate="yes" xml:space="preserve">
          <source>As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well.</source>
          <target state="translated">Поскольку функции являются отношениями,определения последнего элемента (домена,диапазона и т.д.)применяются и к функциям.</target>
        </trans-unit>
        <trans-unit id="07695f74f1c383a64bbc45b6016faa64c5986911" translate="yes" xml:space="preserve">
          <source>As illustrated, properties can be combined. If, for example, &lt;code&gt;shuffle&lt;/code&gt;, &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, and &lt;code&gt;sequence&lt;/code&gt; are all specified, the test cases in the group are executed repeatedly, and in random order, until a test case fails. Then execution is immediately stopped and the remaining cases are skipped.</source>
          <target state="translated">Как показано, свойства можно комбинировать. Если, например, &lt;code&gt;repeat_until_any_fail&lt;/code&gt; &lt;code&gt;shuffle&lt;/code&gt; , repeat_until_any_fail и &lt;code&gt;sequence&lt;/code&gt; , тестовые случаи в группе выполняются повторно и в случайном порядке, пока тестовый пример не завершится неудачно. Затем выполнение немедленно останавливается, а оставшиеся случаи пропускаются.</target>
        </trans-unit>
        <trans-unit id="68fe7148f0f6ccc13bf1a24fdc690584b0a600f5" translate="yes" xml:space="preserve">
          <source>As illustrated, the two directories reside on different nodes, because &lt;code&gt;/ldisc/scratch&lt;/code&gt; (the &quot;local&quot; disc) exists on the two different nodes.</source>
          <target state="translated">Как показано, два каталога находятся на разных узлах, поскольку &lt;code&gt;/ldisc/scratch&lt;/code&gt; (&amp;laquo;локальный&amp;raquo; диск) существует на двух разных узлах.</target>
        </trans-unit>
        <trans-unit id="b2998e8a048230bd280f5294610d17bc1bd53ffb" translate="yes" xml:space="preserve">
          <source>As in &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to be specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">Как и в &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;mp()&lt;/code&gt; скомпилированный с опцией &lt;code&gt;unicode&lt;/code&gt; , требует, чтобы &lt;code&gt;Subject&lt;/code&gt; был &lt;code&gt;charlist()&lt;/code&gt; символов Unicode () . Если компиляция выполняется неявно и для этой функции указана опция компиляции &lt;code&gt;unicode&lt;/code&gt; , то и регулярное выражение, и &lt;code&gt;Subject&lt;/code&gt; должны быть указаны как допустимые Unicode &lt;code&gt;charlist()&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="466e0ad8d0c7cbd5f38b33d59e9622626664550d" translate="yes" xml:space="preserve">
          <source>As in Erlang, messages can be sent to a pid or to a registered name. It is easier to send a message to a registered name, as it avoids the problem of finding a suitable pid.</source>
          <target state="translated">Как и в случае с Erlang,сообщения могут быть отправлены на пид или на зарегистрированное имя.Проще отправить сообщение на зарегистрированное имя,так как это позволяет избежать проблем с поиском подходящего пида.</target>
        </trans-unit>
        <trans-unit id="a4d88e181201a03cc3fb7ded4e3d176b1c280bd5" translate="yes" xml:space="preserve">
          <source>As in construction, the order in which the key and value expressions are evaluated is not defined. The syntactic order of the key-value pairs in the update is of no relevance, except in the case where two keys match. In that case, the latter value is used.</source>
          <target state="translated">Как и в конструкции,порядок,в котором оцениваются выражения ключа и значения,не определен.Синтаксический порядок пар ключ-значение в обновлении не имеет значения,за исключением случая,когда два ключа совпадают.В этом случае используется последнее значение.</target>
        </trans-unit>
        <trans-unit id="bc2ecf4ab7dc9e0eae158ae04299a70b115b03c8" translate="yes" xml:space="preserve">
          <source>As in function &lt;code&gt;run/3&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">Как и в случае с функцией &lt;code&gt;run/3&lt;/code&gt; , &lt;code&gt;mp()&lt;/code&gt; скомпилированный с опцией &lt;code&gt;unicode&lt;/code&gt; , требует, чтобы &lt;code&gt;Subject&lt;/code&gt; был &lt;code&gt;charlist()&lt;/code&gt; символов Unicode () . Если компиляция выполняется неявно и для этой функции указана опция компиляции &lt;code&gt;unicode&lt;/code&gt; , то и регулярное выражение, и &lt;code&gt;Subject&lt;/code&gt; должны быть указаны как допустимые Unicode &lt;code&gt;charlist()&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="3af4e7ec9b32aca75bcf09376c862c57bf6062d9" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как и в обычном сопоставлении Erlang, вы можете привязать переменную ко всему сопоставленному объекту, используя &amp;laquo;совпадение внутри совпадения&amp;raquo;, то есть a &lt;code&gt;=&lt;/code&gt; . К сожалению, в funs, переведенных в соответствии со спецификациями, это разрешено только на &amp;laquo;верхнем уровне&amp;raquo;, то есть сопоставление &lt;strong&gt;всего&lt;/strong&gt; объекта, поступающего для сопоставления, с отдельной переменной. Если вы привыкли писать спецификации соответствия вручную, отметим, что переменная A просто переводится в '$ _'. В качестве альтернативы, псевдофункция &lt;code&gt;object/0&lt;/code&gt; также возвращает весь согласованный объект, см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c43013c670a4d6155374f58258fab04f5fbbc072" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;erl_free_compound()&lt;/code&gt; ensures that the complete term pointed to by &lt;code&gt;ep&lt;/code&gt; is released. This is necessary because the pointer from the second call to &lt;code&gt;erl_format&lt;/code&gt; is lost.</source>
          <target state="translated">Как и в предыдущих примерах, вы несете ответственность за освобождение памяти, выделенной для терминов Erlang. В этом примере &lt;code&gt;erl_free_compound()&lt;/code&gt; гарантирует, что освобождается полный термин, на который указывает &lt;code&gt;ep&lt;/code&gt; . Это необходимо, потому что указатель от второго вызова &lt;code&gt;erl_format&lt;/code&gt; потерян.</target>
        </trans-unit>
        <trans-unit id="d26ac3436bd27f40dd7ea34e33f65a20575923b6" translate="yes" xml:space="preserve">
          <source>As in the previous section the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="translated">Как и в предыдущем разделе, файл PEM &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; содержит как сертификат сервера, так и его закрытый ключ.</target>
        </trans-unit>
        <trans-unit id="debb8560047fb0b42a46cc59f3c825a91b4209ba" translate="yes" xml:space="preserve">
          <source>As indicated by the name, emulator flags control the behavior of the emulator.</source>
          <target state="translated">Как указано в названии,флаги эмулятора управляют поведением эмулятора.</target>
        </trans-unit>
        <trans-unit id="6f49bed7fb11b494819d4e36cc0258b2b542e095" translate="yes" xml:space="preserve">
          <source>As long as all character sets were limited to 256 characters, each character could be stored in one single byte, so there was more or less only one practical encoding for the characters. Encoding each character in one byte was so common that the encoding was not even named. With the Unicode system there are much more than 256 characters, so a common way is needed to represent these. The common ways of representing the code points are the encodings. This means a whole new concept to the programmer, the concept of character representation, which was a non-issue earlier.</source>
          <target state="translated">До тех пор,пока все наборы символов были ограничены 256 символами,каждый символ мог храниться в одном единственном байте,поэтому существовала более или менее одна практичная кодировка для символов.Кодирование каждого символа в один байт было настолько распространено,что кодировка даже не называлась.В системе Юникод существует гораздо больше 256 символов,поэтому необходим общий способ их представления.Общим способом представления точек кода являются кодировки.Для программиста это означает совершенно новое понятие-понятие представления символов,которое раньше не было актуальным.</target>
        </trans-unit>
        <trans-unit id="9b7153107281cf1e02599d91bf8553499b75800f" translate="yes" xml:space="preserve">
          <source>As long as real identifiers are correct, it is OK to pass a CPU topology that is not a correct description of the CPU topology. When used with care this can be very useful. This to trick the emulator to bind its schedulers as you want. For example, if you want to run multiple Erlang runtime systems on the same machine, you want to reduce the number of schedulers used and manipulate the CPU topology so that they bind to different logical CPUs. An example, with two Erlang runtime systems on a quad core machine:</source>
          <target state="translated">До тех пор,пока реальные идентификаторы корректны,можно передавать топологию процессора,которая не является правильным описанием топологии процессора.При аккуратном использовании это может быть очень полезно.Это для того,чтобы обмануть эмулятор и привязать его планировщики так,как вы хотите.Например,если вы хотите запустить несколько систем Erlang на одной машине,вы хотите уменьшить количество используемых планировщиков и манипулировать процессорной топологией так,чтобы они привязывались к разным логическим процессорам.Например,с двумя исполнительными системами Erlang на четырехъядерной машине:</target>
        </trans-unit>
        <trans-unit id="3a4531be2cf765e3ef8b54b63b05d246b380ee1c" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;ftp&lt;/code&gt; application is operational, the FTP sessions are supervised and can be soft code upgraded.</source>
          <target state="translated">Пока приложение &lt;code&gt;ftp&lt;/code&gt; работает, сеансы FTP контролируются и могут обновляться программным кодом.</target>
        </trans-unit>
        <trans-unit id="b05ddb8fa8f81edfa35269196a6d393612d35a2a" translate="yes" xml:space="preserve">
          <source>As long as the data is always lists, modifier &lt;code&gt;t&lt;/code&gt; can be used for any string, but when binary data is involved, care must be taken to make the correct choice of formatting characters. A bytewise-encoded binary is also interpreted as a string, and printed even when using &lt;code&gt;~ts&lt;/code&gt;, but it can be mistaken for a valid UTF-8 string. Avoid therefore using the &lt;code&gt;~ts&lt;/code&gt; control if the binary contains bytewise-encoded characters and not UTF-8.</source>
          <target state="translated">Пока данные всегда являются списками, модификатор &lt;code&gt;t&lt;/code&gt; может использоваться для любой строки, но когда речь идет о двоичных данных, необходимо позаботиться о правильном выборе символов форматирования. Бинарный файл с побайтной кодировкой также интерпретируется как строка и печатается даже при использовании &lt;code&gt;~ts&lt;/code&gt; , но его можно принять за действительную строку UTF-8. Поэтому избегайте использования элемента управления &lt;code&gt;~ts&lt;/code&gt; если двоичный файл содержит символы с побайтной кодировкой, а не UTF-8.</target>
        </trans-unit>
        <trans-unit id="38beb3decd97936c9d002a776141659553006a04" translate="yes" xml:space="preserve">
          <source>As long as the length of the message queue is lower than this value, all log events are handled asynchronously. This means that the client process sending the log event, by calling a log function in the &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt;, does not wait for a response from the handler but continues executing immediately after the event is sent. It is not affected by the time it takes the handler to print the event to the log device. If the message queue grows larger than this value, the handler starts handling log events synchronously instead, meaning that the client process sending the event must wait for a response. When the handler reduces the message queue to a level below the &lt;code&gt;sync_mode_qlen&lt;/code&gt; threshold, asynchronous operation is resumed. The switch from asynchronous to synchronous mode can slow down the logging tempo of one, or a few, busy senders, but cannot protect the handler sufficiently in a situation of many busy concurrent senders.</source>
          <target state="translated">Пока длина очереди сообщений меньше этого значения, все события журнала обрабатываются асинхронно. Это означает, что клиентский процесс, отправляющий событие журнала, путем вызова функции журнала в &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; не ждет ответа от обработчика, а продолжает выполнение сразу после отправки события. На это не влияет время, необходимое обработчику для печати события на устройстве журнала. Если очередь сообщений становится больше этого значения, обработчик вместо этого начинает синхронно обрабатывать события журнала, что означает, что клиентский процесс, отправляющий событие, должен ждать ответа. Когда обработчик уменьшает очередь сообщений до уровня ниже &lt;code&gt;sync_mode_qlen&lt;/code&gt; порог, асинхронная работа возобновляется. Переключение из асинхронного режима в синхронный может замедлить темп ведения журнала одного или нескольких занятых отправителей, но не может защитить обработчик в достаточной степени в ситуации, когда много одновременно занятых отправителей.</target>
        </trans-unit>
        <trans-unit id="cb54073b5c596b75c4d1032a2bc0e471288f7302" translate="yes" xml:space="preserve">
          <source>As long as there are no more than 16 schedulers, there will never be any lock contention on the port lock for the driver.</source>
          <target state="translated">До тех пор,пока существует не более 16 планировщиков,никогда не будет никаких претензий к блокировке порта для водителя.</target>
        </trans-unit>
        <trans-unit id="e4b29322baa56d4c7a0700a6dec611b4da2d64c8" translate="yes" xml:space="preserve">
          <source>As many options are silently discarded by the stack if they are specified out of range; it can be a good idea to check that a raw option is accepted. The following code places the value in variable &lt;code&gt;TcpLinger2:&lt;/code&gt;</source>
          <target state="translated">Какое количество параметров автоматически отбрасывается стеком, если они указаны вне диапазона; может быть хорошей идеей проверить, принят ли необработанный вариант. Следующий код помещает значение в переменную &lt;code&gt;TcpLinger2:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cde1dbb415595f7822eb3d191139162bdd23a109" translate="yes" xml:space="preserve">
          <source>As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as</source>
          <target state="translated">По мере того,как совпадение идет слева направо,PCRE ищет каждую &quot;а&quot; в объекте,а затем смотрит,совпадает ли то,что следует за этим,с оставшимся шаблоном.Если шаблон указан как</target>
        </trans-unit>
        <trans-unit id="6ca1c79babb9a0075f407b28d68680d2a199070e" translate="yes" xml:space="preserve">
          <source>As md5 is not available in FIPS mode it is only possible to use certificates that were signed using sha hashing. When validating an entire certificate chain all certificates (including the root CA's) must comply with this rule.</source>
          <target state="translated">Так как md5 не доступен в режиме FIPS,то можно использовать только сертификаты,которые были подписаны с помощью хеширования бритья.При проверке всей цепочки сертификатов все сертификаты (включая корневые CA)должны соответствовать этому правилу.</target>
        </trans-unit>
        <trans-unit id="f7c08fa4650f0a0fe94395e21e9822cf60a9f2f7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a script can contains precompiled &lt;code&gt;beam&lt;/code&gt; code. In a precompiled script, the interpretation of the script header is the same as in a script containing source code. This means that you can make a &lt;code&gt;beam&lt;/code&gt; file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In a precompiled script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported.</source>
          <target state="translated">Как упоминалось ранее, сценарий может содержать предварительно скомпилированный код &lt;code&gt;beam&lt;/code&gt; . В предварительно скомпилированном сценарии интерпретация заголовка сценария такая же, как и в сценарии, содержащем исходный код. Это означает, что вы можете сделать файл &lt;code&gt;beam&lt;/code&gt; исполняемым, добавив к файлу строки, начинающиеся с &lt;code&gt;#!&lt;/code&gt; и &lt;code&gt;%%!&lt;/code&gt; упомянутое выше. В предварительно скомпилированном скрипте функция &lt;code&gt;main/1&lt;/code&gt; должна быть экспортирована.</target>
        </trans-unit>
        <trans-unit id="64feb9f4a1acc565bd79ae07225ce3ec20e86066" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt;List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="translated">Как упоминалось ранее, запросы выражаются в синтаксисе понимания списка, как описано в разделе &amp;laquo; &lt;code&gt;Expressions&lt;/code&gt; справочного руководства Erlang. Далее предполагается некоторое знакомство с пониманием списков. Примеры в разделе &amp;laquo;Составление &lt;code&gt;List Comprehensions&lt;/code&gt; в примерах программирования&amp;raquo; могут помочь вам начать работу. Обратите внимание, что составление списков не увеличивает вычислительную мощность языка; все, что можно сделать с помощью списков, можно сделать и без них. Но они добавляют синтаксис для описания простых задач поиска, который становится компактным и понятным после того, как вы к нему привыкнете.</target>
        </trans-unit>
        <trans-unit id="dcc63d308b096795c5804a0be71fa661e287ba90" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, segments have the following general syntax:</source>
          <target state="translated">Как упоминалось ранее,сегменты имеют следующий общий синтаксис:</target>
        </trans-unit>
        <trans-unit id="68d171b0ef9d17830114bdb2e45fbb538d0990d4" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="translated">Как упоминалось в тексте &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; в начале этого раздела, жизненно важно, чтобы обратный вызов драйвера возвращался относительно быстро. Трудно указать точное максимальное время, в течение которого обратный вызов драйвера может работать, но обычно обратный вызов драйвера с хорошим поведением должен возвращаться в течение 1 миллисекунды. Этого можно добиться разными подходами. Если у вас есть полный контроль над кодом для выполнения в обратном вызове драйвера, лучший подход - разделить работу на несколько частей и инициировать множественные вызовы &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; с тайм-аутом, используя нулевые тайм-ауты. Функция &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; может быть полезно определить, когда запускать такие вызовы обратного вызова с тайм-аутом. Однако иногда это невозможно реализовать таким образом, например, при вызове сторонних библиотек. В этом случае вы обычно хотите передать работу другому потоку. Информация о примитивах потоков представлена ​​ниже.</target>
        </trans-unit>
        <trans-unit id="870908039e217eddb9cd9dd34c7a2a0d9565d41f" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this manual page, it is of &lt;strong&gt;vital importance&lt;/strong&gt; that a native function returns relatively fast. It is difficult to give an exact maximum amount of time that a native function is allowed to work, but usually a well-behaving native function is to return to its caller within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times. This is, however, not always possible, for example when calling third-party libraries.</source>
          <target state="translated">Как упоминалось в тексте &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; в начале этой страницы руководства, &lt;strong&gt;жизненно важно,&lt;/strong&gt; чтобы встроенная функция возвращалась относительно быстро. Трудно указать точное максимальное количество времени, в течение которого нативная функция может работать, но обычно нормальная нативная функция должна вернуться к вызывающей стороне в течение 1 миллисекунды. Этого можно добиться разными подходами. Если у вас есть полный контроль над кодом для выполнения в нативной функции, лучший подход - разделить работу на несколько частей и вызвать нативную функцию несколько раз. Однако это не всегда возможно, например, при вызове сторонних библиотек.</target>
        </trans-unit>
        <trans-unit id="0d72cf22161ff39dc24cc56c84b763eb1ee94488" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are exists other erlang open source alternatives.</source>
          <target state="translated">Начиная с &lt;code&gt;Inets&lt;/code&gt; 5.0, HTTP-сервер легко запускать / останавливать и настраивать веб-сервер, обеспечивающий самые основные функции веб-сервера. Inets разработан для встраиваемых систем, и если вам нужен полноценный веб-сервер, существуют другие альтернативы erlang с открытым исходным кодом.</target>
        </trans-unit>
        <trans-unit id="0209ca89965504887d9fa6f1d52589a2103d8bad" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retranspissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="translated">В ERTS версии 10.0 добавлена ​​поддержка процессов контроллера распределения. То есть трафиком по каналу распределения может управлять процесс, а не только порт. Это позволяет реализовать большую часть логики в коде Erlang, и вам, возможно, даже не понадобится новый драйвер для протокола. Одним из примеров может быть распространение Erlang по UDP с использованием &lt;code&gt;gen_udp&lt;/code&gt; (в этом примере ваш код Erlang, конечно, должен позаботиться о повторных передачах и т. Д.). То есть, в зависимости от того, что вы хотите сделать, возможно, вам вообще не нужно внедрять драйвер, и вы можете пропустить разделы, связанные с драйверами ниже. &lt;code&gt;gen_tcp_dist&lt;/code&gt; пример , описанный в &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; В разделе используются процессы контроллера распределения, и стоит взглянуть на него, если вы хотите использовать процессы контроллера распределения.</target>
        </trans-unit>
        <trans-unit id="c85a6ebe0161eb5757b5cd028db5ba4081c57741" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of &lt;code&gt;erlang:check_process_code/3&lt;/code&gt;, which is used in order to determine this.</source>
          <target state="translated">Начиная с версии 9.0 ERTS, процесс считается задерживающимся в коде, только если он имеет прямые ссылки на код. Для получения дополнительной информации см. Документацию к &lt;code&gt;erlang:check_process_code/3&lt;/code&gt; , которая используется для определения этого.</target>
        </trans-unit>
        <trans-unit id="990b2f43003907f6ffa2fd600f8b8c5f6d4c0c81" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Начиная с версии 9.0 ERTS, в результат также будут включены грязные планировщики ЦП. То есть все потоки планировщика, которые должны обрабатывать работу, связанную с процессором. Если вам также нужна информация о планировщиках грязного ввода-вывода, используйте вместо этого &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="924b8134638ed9edf16b9abf6ee2f7cc8660dc0a" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the Erlang runtime system will as default have more schedulers than logical processors. This due to the dirty schedulers.</source>
          <target state="translated">Начиная с версии 9.0,система исполнения Erlang по умолчанию будет иметь больше планировщиков,чем логических процессоров.Это связано с грязными планировщиками.</target>
        </trans-unit>
        <trans-unit id="cf90680c064454d2c96d45dd08744df7108b0b29" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the check process code operation only checks for direct references to the code. Indirect references via &lt;code&gt;fun&lt;/code&gt;s will be ignored. If such &lt;code&gt;fun&lt;/code&gt;s exist and are used after a purge of the old code, an exception will be raised upon usage (same as the case when the &lt;code&gt;fun&lt;/code&gt; is received by the process after the purge). Literals will be taken care of (copied) at a later stage. This behavior can as of ERTS version 8.1 be enabled when &lt;code&gt;building OTP&lt;/code&gt;, and will automatically be enabled if dirty scheduler support is enabled.</source>
          <target state="translated">Начиная с ERTS версии 9.0, операция кода процесса проверки проверяет только прямые ссылки на код. Косвенные ссылки через &lt;code&gt;fun&lt;/code&gt; будут игнорироваться. Если такие &lt;code&gt;fun&lt;/code&gt; существуют и используются после очистки старого кода, при использовании возникает исключение (как и в случае, когда &lt;code&gt;fun&lt;/code&gt; получено процессом после очистки). О литералах мы позаботимся (скопируем) на более позднем этапе. Это поведение может быть включено в ERTS версии 8.1 при &lt;code&gt;building OTP&lt;/code&gt; и будет автоматически включено, если включена поддержка грязного планировщика.</target>
        </trans-unit>
        <trans-unit id="f4e1d3eb137cab5087aa6346ca40170ec41e8ce0" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 17, most applications deliver a valid application upgrade file (&lt;code&gt;appup&lt;/code&gt;). In earlier releases, a majority of the applications in Erlang/OTP did not support upgrade. Many of the applications use the &lt;code&gt;restart_application&lt;/code&gt; instruction. These are applications for which it is not crucial to support real soft upgrade, for example, tools and library applications. The &lt;code&gt;restart_application&lt;/code&gt; instruction ensures that all modules in the application are reloaded and thereby running the new code.</source>
          <target state="translated">Начиная с Erlang / OTP 17, большинство приложений предоставляют действительный файл обновления приложения ( &lt;code&gt;appup&lt;/code&gt; ). В более ранних выпусках большинство приложений на Erlang / OTP не поддерживали обновление. Многие приложения используют инструкцию &lt;code&gt;restart_application&lt;/code&gt; . Это приложения, для которых не является критичной поддержка реального программного обновления, например, инструменты и библиотечные приложения. &lt;code&gt;restart_application&lt;/code&gt; инструкция гарантирует , что все модули приложения перегружают и , таким образом , работает новый код.</target>
        </trans-unit>
        <trans-unit id="3896e9860076cb6efc826bd1af4282cf215a66b2" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 21.0, the concept of SASL reports is removed, meaning that the default behaviour is as follows:</source>
          <target state="translated">Начиная с Erlang/OTP 21.0,понятие SASL отчетов удалено,что означает,что поведение по умолчанию следующее:</target>
        </trans-unit>
        <trans-unit id="5156993619ca489fb8cfd9ed4a3335d7b4428f29" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP R16, messages sent to ports are delivered truly asynchronously. The underlying implementation previously delivered messages to ports synchronously. Message passing has however always been documented as an asynchronous operation. Hence, this is not to be an issue for an Erlang program communicating with ports, unless false assumptions about ports have been made.</source>
          <target state="translated">Начиная с Erlang/OTP R16,сообщения,отправляемые на порты,доставляются действительно асинхронно.Базовая реализация ранее доставляла сообщения на порты синхронно.Однако передача сообщений всегда документировалась как асинхронная операция.Следовательно,это не должно быть проблемой для программы Erlang,взаимодействующей с портами,если только не было сделано ложных предположений о портах.</target>
        </trans-unit>
        <trans-unit id="db7deccbe166e540f0b707dd76ed8fd8300520de" translate="yes" xml:space="preserve">
          <source>As of OTP 17.0 application versions use the same &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; as the OTP version. Application versions part of a release candidate will however not have an &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; suffix as the OTP version. Also note that a major increment in an application version does not necessarily imply a major increment of the OTP version. This depends on whether the major change in the application is considered as a major change for OTP as a whole or not.</source>
          <target state="translated">Начиная с версии приложения OTP 17.0 используется та же &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; что и в версии OTP. Однако версии приложения, входящие в состав кандидата на выпуск, не будут иметь &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; в качестве версии OTP. Также обратите внимание, что значительное увеличение версии приложения не обязательно подразумевает значительное увеличение версии OTP. Это зависит от того, считается ли основное изменение в приложении серьезным изменением для OTP в целом или нет.</target>
        </trans-unit>
        <trans-unit id="e6a68f9772c180bbf4b9650571adc55b4582fbcd" translate="yes" xml:space="preserve">
          <source>As of OTP release 17, the OTP release number corresponds to the major part of the OTP version. The OTP version as a concept was introduced in OTP 17. The version scheme used is described in detail in &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Начиная с версии OTP 17, номер версии OTP соответствует большей части версии OTP. Версия OTP как концепция была представлена ​​в OTP 17. Используемая схема версий подробно описана в &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2be4113be53a8f180a26c5c4f8137c8f0b13cc" translate="yes" xml:space="preserve">
          <source>As of R15B01, the dynamic trace code is included in the OTP source distribution, although it's considered experimental. The main development of the dtrace code still happens outside of Ericsson, but there is no need to fetch a patched version of the OTP source to get the basic functionality.</source>
          <target state="translated">Начиная с R15B01,динамический код трассы включается в исходный дистрибутив OTP,хотя и считается экспериментальным.Основное развитие кода динамических трасс все еще происходит за пределами Ericsson,но для получения базовой функциональности нет необходимости в получении исправленной версии исходного кода OTP.</target>
        </trans-unit>
        <trans-unit id="3175e151baddb9462eaca8a3103721b845c4be90" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. This function is used to convert to the old (pre-4.4) info format.</source>
          <target state="translated">Начиная с версии 4.4 формат информации был изменен.Эта функция используется для конвертирования в старый (до 4.4)информационный формат.</target>
        </trans-unit>
        <trans-unit id="bc18a1e131252e89f07716dc1f6c84f4f113e552" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. To convert the info to the old format, call the &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Начиная с версии 4.4 формат информации был изменен. Чтобы преобразовать информацию в старый формат, вызовите функцию &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0806b3a57271c3368eb538cbf78e42f66a7befe" translate="yes" xml:space="preserve">
          <source>As operators are not terms in their own right, when operators are mentioned below, the representation of an operator is to be taken to be the atom with a printname consisting of the same characters as the operator.</source>
          <target state="translated">Поскольку операторы сами по себе не являются терминами,когда операторы упоминаются ниже,под представлением оператора следует понимать атом с именем печати,состоящим из тех же символов,что и оператор.</target>
        </trans-unit>
        <trans-unit id="27aa2715207bd314b837c8f9f949d9e43e3fe153" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-M&lt;/code&gt;, except that the Makefile is written to &lt;code&gt;Makefile&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">Как вариант &lt;code&gt;-M&lt;/code&gt; , за исключением того, что Makefile записывается в &lt;code&gt;Makefile&lt;/code&gt; . Объектный файл не создается.</target>
        </trans-unit>
        <trans-unit id="3d10554b44799b09a5d688a7590a7e6f973d1129" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-MT&lt;/code&gt;, except that characters special to &lt;code&gt;make/1&lt;/code&gt; are quoted.</source>
          <target state="translated">В качестве опции &lt;code&gt;-MT&lt;/code&gt; , за исключением того, что символы, специально предназначенные для &lt;code&gt;make/1&lt;/code&gt; , заключаются в кавычки.</target>
        </trans-unit>
        <trans-unit id="b8f789d4c76adaa6e3ad489f09dfb73a7ef05683" translate="yes" xml:space="preserve">
          <source>As parameter &lt;code&gt;Config&lt;/code&gt; is a list of key-value tuples, that is, a data type called a property list, it can be handled by the &lt;code&gt;proplists&lt;/code&gt; module. A value can, for example, be searched for and returned with function &lt;code&gt;proplists:get_value/2&lt;/code&gt;. Also, or alternatively, the general &lt;code&gt;lists&lt;/code&gt; module contains useful functions. Normally, the only operations performed on &lt;code&gt;Config&lt;/code&gt; is insert (adding a tuple to the head of the list) and lookup. &lt;code&gt;Common Test&lt;/code&gt; provides a simple macro named &lt;code&gt;?config&lt;/code&gt;, which returns a value of an item in &lt;code&gt;Config&lt;/code&gt; given the key (exactly like &lt;code&gt;proplists:get_value&lt;/code&gt;). Example: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt;.</source>
          <target state="translated">Поскольку параметр &lt;code&gt;Config&lt;/code&gt; представляет собой список кортежей &quot;ключ-значение&quot;, то есть тип данных, называемый списком свойств, он может обрабатываться модулем &lt;code&gt;proplists&lt;/code&gt; . Например, значение можно найти и вернуть с помощью &lt;code&gt;proplists:get_value/2&lt;/code&gt; функции : get_value / 2 . Также или альтернативно, модуль общих &lt;code&gt;lists&lt;/code&gt; содержит полезные функции. Обычно с &lt;code&gt;Config&lt;/code&gt; выполняются только операции вставки (добавление кортежа в заголовок списка) и поиск. &lt;code&gt;Common Test&lt;/code&gt; предоставляет простой макрос с именем &lt;code&gt;?config&lt;/code&gt; , который возвращает значение элемента в &lt;code&gt;Config&lt;/code&gt; с учетом ключа (точно так же, как &lt;code&gt;proplists:get_value&lt;/code&gt; ). Пример: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e768910eb46b5bf1b56cc0b04701d6e5fb8dd7f" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Как описано ранее, функциональный объект (Fun), выполняющий операции доступа к таблице, как указано здесь, может быть передан в качестве аргументов функции &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="697d56b55fb0573091be8112b03dc468b6978a3a" translate="yes" xml:space="preserve">
          <source>As previously explained, this specification can also be provided by an entry like the following in a configuration file:</source>
          <target state="translated">Как уже объяснялось ранее,эта спецификация может быть также представлена в конфигурационном файле записью,подобной следующей:</target>
        </trans-unit>
        <trans-unit id="5b4c831da626efb451c44f834caf79dfb78dcdf6" translate="yes" xml:space="preserve">
          <source>As previously stated, the locking strategy used by &lt;code&gt;Mnesia&lt;/code&gt; is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use &lt;code&gt;Mnesia&lt;/code&gt; mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</source>
          <target state="translated">Как указывалось ранее, стратегия блокировки, используемая &lt;code&gt;Mnesia&lt;/code&gt; , заключается в блокировании одной записи при чтении записи и блокировке всех реплик записи при записи записи. Однако некоторые приложения используют &lt;code&gt;Mnesia&lt;/code&gt; в основном из-за его отказоустойчивости. Эти приложения могут быть сконфигурированы с одним узлом, выполняющим всю тяжелую работу, и резервным узлом, готовым взять на себя управление в случае отказа основного узла. Таким приложениям может быть выгодно использовать липкие блокировки вместо обычной схемы блокировки.</target>
        </trans-unit>
        <trans-unit id="9d595490ab4714d8a9871d8a09a973dfea9d0d3d" translate="yes" xml:space="preserve">
          <source>As received in the &lt;code&gt;stream_start message&lt;/code&gt;</source>
          <target state="translated">Как получено в &lt;code&gt;stream_start message&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd5870133105312565312c6b2ab7ff3fd841d30a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращается командами &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b46cebaae7c70180ee044bb55a1784247c2f3b67" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как возвращаемый &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6563f22087e6266633a8cc2568e501f807ea6a94" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращено &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="613b92ac4a60557f480687125ac1a95cb659b564" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращено &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ba5543136150606738a5ee102fcd04508cc21b" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращено &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="863aff4e4c6e39a97f1c4df4bc54ef46a778c1ae" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;pid()&lt;/code&gt; is a process handling I/O-protocols.</source>
          <target state="translated">Возвращено &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;pid()&lt;/code&gt; - это процесс, обрабатывающий протоколы ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="b4c95d43e70076905f6c54f0f92a6860693a2f6a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Как возвращаемый &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90363fa78582864ae9fe09932744a0fa77aa02f7" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a102b38b674404b91761c097130f2c6e8ca2119" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как возвращено &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d84d9f434fd43a7bcd5371be1f74578362aa6337" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как возвращается &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; Как возвращается &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66acc65c2b1802196c6e3511e7c37cac12a600c6" translate="yes" xml:space="preserve">
          <source>As seen in the help text -- unless you have not upgraded your Emacs yet (well, what are you waiting around here for? Off you go and upgrade!) -- &lt;code&gt;etags&lt;/code&gt; associate the file extensions &lt;code&gt;.erl&lt;/code&gt; and &lt;code&gt;.hrl&lt;/code&gt; with Erlang.</source>
          <target state="translated">Как видно из текста справки - если вы еще не обновили свой Emacs (ну, чего вы здесь ждете? Идите и обновляйтесь!) - &lt;code&gt;etags&lt;/code&gt; связывает расширения файлов &lt;code&gt;.erl&lt;/code&gt; и &lt;code&gt;.hrl&lt;/code&gt; с Erlang.</target>
        </trans-unit>
        <trans-unit id="5f01e0b8a20288a5e48191d860785e7700a74b5b" translate="yes" xml:space="preserve">
          <source>As seen, the basic syntax of a type is an atom followed by closed parentheses. New types are declared using &lt;code&gt;-type&lt;/code&gt; and &lt;code&gt;-opaque&lt;/code&gt; attributes as in the following:</source>
          <target state="translated">Как видно, основной синтаксис типа - это атом, за которым следуют закрытые круглые скобки. Новые типы объявляются с помощью &lt;code&gt;-type&lt;/code&gt; и &lt;code&gt;-opaque&lt;/code&gt; атрибутов , как в следующем:</target>
        </trans-unit>
        <trans-unit id="a3fd03dc2b283a58adbff3d43946bbc1c68e036d" translate="yes" xml:space="preserve">
          <source>As shown above, some files have extension &lt;code&gt;.hrl&lt;/code&gt;. These are header files that are included in the &lt;code&gt;.erl&lt;/code&gt; files by:</source>
          <target state="translated">Как показано выше, некоторые файлы имеют расширение &lt;code&gt;.hrl&lt;/code&gt; . Это файлы заголовков, которые включаются в файлы &lt;code&gt;.erl&lt;/code&gt; следующими способами :</target>
        </trans-unit>
        <trans-unit id="644b5188f948ac22e42edad7ffd5f78d4eae0359" translate="yes" xml:space="preserve">
          <source>As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well.</source>
          <target state="translated">Как видно из примера,функция может быть вызвана и из оболочки.Веселье должно быть буквально в вызове,когда используется и из оболочки.</target>
        </trans-unit>
        <trans-unit id="81045d7eeb4cf703574814aab4af0c68ba1e701f" translate="yes" xml:space="preserve">
          <source>As shown in section &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;, the test suite module implements &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (mandatory or optional) for various purposes, for example:</source>
          <target state="translated">Как показано в разделе &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; тестирования, модуль набора тестов реализует &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (обязательные или необязательные) для различных целей, например:</target>
        </trans-unit>
        <trans-unit id="030eefb3aa3439bedecb7d423ba21572f508483d" translate="yes" xml:space="preserve">
          <source>As shown, first it is checked if a year is leap. If a year is divisible by 400, it is a leap year. To determine this, first divide the year by 400 and use the BIF &lt;code&gt;trunc&lt;/code&gt; (more about this later) to cut off any decimals. Then multiply by 400 again and see if the same value is returned again. For example, year 2004:</source>
          <target state="translated">Как показано, сначала проверяется, является ли год високосным. Если год делится на 400, это високосный год. Чтобы определить это, сначала разделите год на 400 и используйте &lt;code&gt;trunc&lt;/code&gt; BIF (подробнее об этом позже), чтобы отсечь все десятичные дроби. Затем снова умножьте на 400 и посмотрите, возвращается ли то же значение снова. Например, 2004 год:</target>
        </trans-unit>
        <trans-unit id="732c6e940059e650b01cb8f7c64bf6533a984dc1" translate="yes" xml:space="preserve">
          <source>As shown, the Erlang shell numbers the lines that can be entered, (as 1&amp;gt; 2&amp;gt;) and that it correctly says that 2 + 5 is 7. If you make writing mistakes in the shell, you can delete with the backspace key, as in most shells. There are many more editing commands in the shell (see &lt;code&gt;tty - A command line interface&lt;/code&gt; in ERTS User's Guide).</source>
          <target state="translated">Как показано, оболочка Erlang нумерует строки, которые можно вводить (как 1&amp;gt; 2&amp;gt;), и правильно говорит, что 2 + 5 равно 7. Если вы допустили ошибки при записи в оболочке, вы можете удалить их с помощью клавиши Backspace, как и в большинстве снарядов. В оболочке есть еще много команд редактирования (см. &lt;code&gt;tty - A command line interface&lt;/code&gt; в Руководстве пользователя ERTS).</target>
        </trans-unit>
        <trans-unit id="e71ec6804a29b4599e20b3e464961470ccc68635" translate="yes" xml:space="preserve">
          <source>As shown, the function &lt;code&gt;say_something&lt;/code&gt; writes its first argument the number of times specified by second argument. The function &lt;code&gt;start&lt;/code&gt; starts two Erlang processes, one that writes &quot;hello&quot; three times and one that writes &quot;goodbye&quot; three times. Both processes use the function &lt;code&gt;say_something&lt;/code&gt;. Notice that a function used in this way by &lt;code&gt;spawn&lt;/code&gt;, to start a process, must be exported from the module (that is, in the &lt;code&gt;-export&lt;/code&gt; at the start of the module).</source>
          <target state="translated">Как показано, функция &lt;code&gt;say_something&lt;/code&gt; записывает свой первый аргумент количество раз, указанное вторым аргументом. Функция &lt;code&gt;start&lt;/code&gt; запускает два процесса Erlang, один из которых трижды пишет &amp;laquo;привет&amp;raquo;, а второй - &amp;laquo;до свидания&amp;raquo;. Оба процесса используют функцию &lt;code&gt;say_something&lt;/code&gt; . Обратите внимание, что функция, используемая таким образом &lt;code&gt;spawn&lt;/code&gt; для запуска процесса, должна быть экспортирована из модуля (то есть в &lt;code&gt;-export&lt;/code&gt; в начале модуля).</target>
        </trans-unit>
        <trans-unit id="b8dddde7bbb47337791588e9c259e08ddee9bc47" translate="yes" xml:space="preserve">
          <source>As shown, the ping pong program has run. On the &quot;pong&quot; side:</source>
          <target state="translated">Как видно,программа для пинг-понга запущена.Со стороны &quot;пинг-понг&quot;:</target>
        </trans-unit>
        <trans-unit id="ad4c171e5c21c103c918431cb469ba42140798d7" translate="yes" xml:space="preserve">
          <source>As stated earlier, changing child specifications does not affect existing child processes. New child specifications are automatically added, but not deleted. Child processes are not automatically started or terminated, this must be done using &lt;code&gt;apply&lt;/code&gt; instructions.</source>
          <target state="translated">Как было сказано ранее, изменение дочерних спецификаций не влияет на существующие дочерние процессы. Новые дочерние спецификации добавляются автоматически, но не удаляются. Дочерние процессы не запускаются и не завершаются автоматически, это необходимо делать с помощью инструкций по &lt;code&gt;apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bab58f9f01e2ec9b0aff4a10808faf716038fb5e" translate="yes" xml:space="preserve">
          <source>As stated earlier, instruction &lt;code&gt;restart_new_emulator&lt;/code&gt; causes the emulator to be restarted with new versions of ERTS&amp;gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">Как указывалось ранее, инструкция &lt;code&gt;restart_new_emulator&lt;/code&gt; вызывает перезапуск эмулятора с новыми версиями ERTS&amp;gt;, Kernel, STDLIB и SASL. Однако все другие приложения при запуске запускают свои старые версии в этом новом эмуляторе. Обычно это не проблема, но время от времени в основных приложениях происходят несовместимые изменения, которые могут вызвать проблемы в этой настройке. Таким несовместимым изменениям (когда функции удаляются) обычно предшествует отказ от поддержки двух основных выпусков. Чтобы гарантировать, что ваше приложение не выйдет из строя из-за несовместимого изменения, всегда удаляйте все вызовы устаревших функций как можно скорее.</target>
        </trans-unit>
        <trans-unit id="d2f8b1ba1c67fb67671d7cb5d1f4c6ff846076c9" translate="yes" xml:space="preserve">
          <source>As stated earlier, the order of the instructions is important. When upgrading, &lt;code&gt;m1&lt;/code&gt; must be loaded, and the supervisor child specification changed, before the new child process can be started. When downgrading, the child process must be terminated before the child specification is changed and the module is deleted.</source>
          <target state="translated">Как указывалось ранее, важен порядок инструкций. При обновлении перед запуском нового дочернего процесса необходимо загрузить &lt;code&gt;m1&lt;/code&gt; и изменить спецификацию дочернего супервизора. При переходе на более раннюю версию дочерний процесс должен быть завершен до изменения дочерней спецификации и удаления модуля.</target>
        </trans-unit>
        <trans-unit id="b7ff2d94dd69653efaa6f0e2b153be55d281f264" translate="yes" xml:space="preserve">
          <source>As such a client cannot read a new &lt;code&gt;start_erl.data&lt;/code&gt; file (the file cannot be changed dynamically). The boot and config files are always fetched from the same place (but with new contents if a new release has been installed).</source>
          <target state="translated">Таким образом, клиент не может прочитать новый файл &lt;code&gt;start_erl.data&lt;/code&gt; (файл не может быть изменен динамически). Файлы загрузки и конфигурации всегда загружаются из одного и того же места (но с новым содержимым, если была установлена ​​новая версия).</target>
        </trans-unit>
        <trans-unit id="1714bc6ebf672752fb654342a2c562571522eab2" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;++&lt;/code&gt; operator copies its left operand, the result is copied repeatedly, leading to quadratic complexity.</source>
          <target state="translated">Поскольку оператор &lt;code&gt;++&lt;/code&gt; копирует свой левый операнд, результат многократно копируется, что приводит к квадратичной сложности.</target>
        </trans-unit>
        <trans-unit id="2e226d4cd051311bceb315b8997b69c3409b32fc" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;add_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">Поскольку процедура &lt;code&gt;add_frag&lt;/code&gt; является частью транзакции схемы, Mnesia устанавливает блокировки записи для затронутых таблиц. То есть, как фрагменты , соответствующие &lt;code&gt;IterFrags&lt;/code&gt; и те , которые соответствуют &lt;code&gt;AdditionalLockFrags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8afd221610cfbc0c004b3e80d9cc06e7451e3b4" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;address&lt;/code&gt; field was omitted, its default value is used.</source>
          <target state="translated">Поскольку поле &lt;code&gt;address&lt;/code&gt; было опущено, используется его значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="13444681318a2f85bf718682f9be9c04d867f14f" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;del_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">Поскольку процедура &lt;code&gt;del_frag&lt;/code&gt; является частью транзакции схемы, Mnesia устанавливает блокировки записи на затронутые таблицы. То есть, как фрагменты , соответствующие &lt;code&gt;IterFrags&lt;/code&gt; и те , которые соответствуют &lt;code&gt;AdditionalLockFrags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="996b8c87675fcbf684c10ebd80b9cfdfdf3cae34" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;total&lt;/code&gt; value is the sum of &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;, the error in &lt;code&gt;system&lt;/code&gt; propagates to the &lt;code&gt;total&lt;/code&gt; value.</source>
          <target state="translated">Поскольку &lt;code&gt;total&lt;/code&gt; значение является суммой &lt;code&gt;processes&lt;/code&gt; и &lt;code&gt;system&lt;/code&gt; , ошибка в &lt;code&gt;system&lt;/code&gt; распространяется на &lt;code&gt;total&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="4195fa76015f84a5df8be91ff120efd14a713307" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application is dependent on third party products there are a few administrative things that needs to be done before you can get things up and running.</source>
          <target state="translated">Так как приложение ODBC от Erlang зависит от продуктов сторонних производителей,есть несколько административных вещей,которые необходимо сделать,прежде чем вы сможете запустить их.</target>
        </trans-unit>
        <trans-unit id="20c8404a5de3c59614d50e29989cfead97f57ced" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application relies on third party products and communicates with a database that probably runs on another computer in the network there are plenty of things that might go wrong. To fully understand the things that might happen it facilitate to know the design of the Erlang ODBC application, hence here follows a short description of the current design.</source>
          <target state="translated">Поскольку приложение Erlang ODBC полагается на продукты сторонних производителей и взаимодействует с базой данных,которая,вероятно,работает на другом компьютере в сети,есть много вещей,которые могут пойти не так.Чтобы полностью понять,что может произойти,полезно знать дизайн ODBC приложения Erlang,поэтому здесь следует краткое описание текущего дизайна.</target>
        </trans-unit>
        <trans-unit id="3558041c42459c9de0de1dcf3a8814d6434e5a6c" translate="yes" xml:space="preserve">
          <source>As the UTF-8 encoding is widely spread and provides some backward compatibility in the 7-bit ASCII range, it is selected as the standard encoding for Unicode characters in binaries for Erlang.</source>
          <target state="translated">Поскольку кодировка UTF-8 широко распространена и обеспечивает некоторую обратную совместимость в 7-битном диапазоне ASCII,она выбрана в качестве стандартной кодировки для символов Unicode в двоичных файлах для Erlang.</target>
        </trans-unit>
        <trans-unit id="bdb9f25861a28ac570dd99575f72b2d8ad54d3fa" translate="yes" xml:space="preserve">
          <source>As the driver is a shared module, not a program, no main function is present. All function pointers are not used in this example, and the corresponding fields in the &lt;code&gt;driver_entry&lt;/code&gt; structure are set to NULL.</source>
          <target state="translated">Поскольку драйвер является общим модулем, а не программой, основная функция отсутствует. Все указатели на функции не используются в этом примере, а соответствующие поля в структуре &lt;code&gt;driver_entry&lt;/code&gt; установлены в NULL.</target>
        </trans-unit>
        <trans-unit id="8406821028c9ff87cf4b1f089c352e4449600154" translate="yes" xml:space="preserve">
          <source>As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms.</source>
          <target state="translated">Так как исполнение и структура спецификаций матча похожи на забаву,проще написать их,используя знакомый синтаксис забавы,и автоматически перевести их в спецификацию матча.Реальное удовольствие,безусловно,более мощным,чем матч-спецификации позволяют,но с учетом матч-спецификации в виду,и что они могут сделать,это все равно более удобно,чтобы написать все это как весело.Этот модуль содержит код,который транслирует синтаксис fun в условия спецификации соответствия.</target>
        </trans-unit>
        <trans-unit id="500258296a887dd562c74c1baf7dab1768136ec5" translate="yes" xml:space="preserve">
          <source>As the execution of the test suites proceed, events are logged in the following four different ways:</source>
          <target state="translated">По мере выполнения тестовых комплектов события регистрируются следующими четырьмя различными способами:</target>
        </trans-unit>
        <trans-unit id="2b99f096c11009199607e528c1ab4fde76715836" translate="yes" xml:space="preserve">
          <source>As the message is an &lt;code&gt;ETERM&lt;/code&gt; struct, Erl_Interface functions can be used to manipulate it. In this case, the message becomes a 3-tuple, because that is how the Erlang code is written. The second element will be the pid of the caller and the third element will be the tuple &lt;code&gt;{Function,Arg}&lt;/code&gt; determining which function to call, and with which argument. The result of calling the function is made into an &lt;code&gt;ETERM&lt;/code&gt; struct as well and sent back to Erlang using &lt;code&gt;erl_send()&lt;/code&gt;, which takes the open file descriptor, a pid, and a term as arguments:</source>
          <target state="translated">Поскольку сообщение является &lt;code&gt;ETERM&lt;/code&gt; структура, функции Erl_Interface могут быть использованы для управления им. В этом случае сообщение становится трехкортежным, потому что именно так написан код Erlang. Второй элемент будет pid вызывающего, а третий элемент будет кортежем &lt;code&gt;{Function,Arg}&lt;/code&gt; , определяющим, какую функцию вызывать и с каким аргументом. Результат вызова функции также &lt;code&gt;ETERM&lt;/code&gt; структуру ETERM и отправляется обратно в Erlang с помощью &lt;code&gt;erl_send()&lt;/code&gt; , которая принимает в качестве аргументов дескриптор открытого файла, pid и термин:</target>
        </trans-unit>
        <trans-unit id="7146c7ac731941ac40a19a992206ba27e74fa230" translate="yes" xml:space="preserve">
          <source>As the position is specified as a byte-offset, take special caution when working with files where &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, as not every byte position is a valid character boundary on such a file.</source>
          <target state="translated">Поскольку позиция указывается как байтовое смещение, будьте особенно осторожны при работе с файлами, в которых для &lt;code&gt;encoding&lt;/code&gt; установлено значение, &lt;code&gt;latin1&lt;/code&gt; от latin1 , поскольку не каждая байтовая позиция является допустимой границей символа в таком файле.</target>
        </trans-unit>
        <trans-unit id="f76a9267a5d5f392fb58b458fb3bf07880270ba9" translate="yes" xml:space="preserve">
          <source>As the runtime system handles the optimization (instead of the compiler), there are very few circumstances in which the optimization does not work.</source>
          <target state="translated">Так как runtime-система обрабатывает оптимизацию (а не компилятор),есть очень мало обстоятельств,при которых оптимизация не работает.</target>
        </trans-unit>
        <trans-unit id="b697dde1f8ec4fdc0c53e1bd6391f4323555d01f" translate="yes" xml:space="preserve">
          <source>As the source code is distributed, it can easily be modified to accept other options. The program must still accept option &lt;code&gt;-data&lt;/code&gt; with the semantics described above for the release handler to work correctly.</source>
          <target state="translated">Поскольку исходный код распространяется, его можно легко изменить, чтобы принять другие параметры. Программа должна по-прежнему принимать параметр &lt;code&gt;-data&lt;/code&gt; с семантикой, описанной выше, чтобы обработчик выпуска работал правильно.</target>
        </trans-unit>
        <trans-unit id="8795a3307568900a68fbd017733b56af3116954b" translate="yes" xml:space="preserve">
          <source>As the time offset is not allowed to change, time correction must adjust the frequency of the Erlang monotonic clock to align Erlang system time with OS system time smoothly. A significant downside of this approach is that we on purpose will use a faulty frequency on the Erlang monotonic clock if adjustments are needed. This error can be as large as 1%. This error will show up in all time measurements in the runtime system.</source>
          <target state="translated">Так как смещение по времени не допускается,коррекция по времени должна регулировать частоту монотонных часов Эрланга,чтобы выровнять системное время Эрланга с системным временем ОС плавно.Существенным недостатком такого подхода является то,что мы специально используем ошибочную частоту на монотонных часах Эрланга,если потребуется корректировка.Эта погрешность может достигать 1%.Эта ошибка будет проявляться во всех измерениях времени в системе исполнения.</target>
        </trans-unit>
        <trans-unit id="c394e9d8956e53ffa12dda34b51f038d61fe77cf" translate="yes" xml:space="preserve">
          <source>As the two alternatives are inside a &lt;code&gt;(?|&lt;/code&gt; group, both sets of capturing parentheses are numbered one. Thus, when the pattern matches, you can look at captured substring number one, whichever alternative matched. This construct is useful when you want to capture a part, but not all, of one of many alternatives. Inside a &lt;code&gt;(?|&lt;/code&gt; group, parentheses are numbered as usual, but the number is reset at the start of each branch. The numbers of any capturing parentheses that follow the subpattern start after the highest number used in any branch. The following example is from the Perl documentation; the numbers underneath show in which buffer the captured content is stored:</source>
          <target state="translated">Поскольку две альтернативы находятся внутри группы &lt;code&gt;(?|&lt;/code&gt; , Оба набора захватывающих скобок нумеруются один. Таким образом, когда шаблон совпадает, вы можете посмотреть захваченную подстроку номер один, какая бы альтернатива ни совпадала. Эта конструкция полезна, когда вы хотите захватить часть, но не все, одной из многих альтернатив. Внутри группы &lt;code&gt;(?|&lt;/code&gt; круглые скобки нумеруются как обычно, но номер сбрасывается в начале каждой ветви. Номера любых захватывающих скобок, следующих за подшаблоном, начинаются после наибольшее число, используемое в любой ветке. Следующий пример взят из документации Perl; числа под ним показывают, в каком буфере хранится захваченный контент:</target>
        </trans-unit>
        <trans-unit id="6b1ff2bd85ad93af178cdc629f19b070b543117b" translate="yes" xml:space="preserve">
          <source>As there can be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If option &lt;code&gt;extended&lt;/code&gt; is set, this can be whitespace. Otherwise an empty comment (see section &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt;) can be used.</source>
          <target state="translated">Поскольку в шаблоне может быть много захватывающих круглых скобок, все цифры, следующие за обратной косой чертой, считаются частью потенциального обратного ссылочного номера. Если шаблон продолжается с помощью символа цифры, необходимо использовать некоторый разделитель для завершения обратной ссылки. Если установлен параметр &lt;code&gt;extended&lt;/code&gt; , это может быть пробел. В противном случае можно использовать пустой комментарий (см. Раздел &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a74c4cf2304eafd1772e4800b2c34ab0218b1011" translate="yes" xml:space="preserve">
          <source>As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option &lt;code&gt;group&lt;/code&gt;, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</source>
          <target state="translated">Поскольку для последней части примера (&quot;g&quot;) нет подходящего подвыражения, после этого ничего не вставляется. Чтобы сделать группу строк и части, соответствующие подвыражениям, более очевидными, можно использовать &lt;code&gt;group&lt;/code&gt; опций , которая группирует вместе часть строки темы с частями, соответствующими подвыражениям, когда строка была разделена:</target>
        </trans-unit>
        <trans-unit id="9e2c8ed56878a9d0ce4d6f8c64f1107a4ec68580" translate="yes" xml:space="preserve">
          <source>As these are the C library, the same limitations apply.</source>
          <target state="translated">Поскольку это библиотека на языке Си,применяются те же ограничения.</target>
        </trans-unit>
        <trans-unit id="c163dd9740f51616c09627b0819df111304b0a64" translate="yes" xml:space="preserve">
          <source>As this interface implies that ports are killed when the last user disappears, the function does not hang waiting for ports to get closed.</source>
          <target state="translated">Так как этот интерфейс подразумевает,что порты убиваются при исчезновении последнего пользователя,функция не зависает в ожидании закрытия портов.</target>
        </trans-unit>
        <trans-unit id="269a4f9e2c4144f24e95fc48fbc36000ea30889f" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">Поскольку этот модуль представляет интерес только для разработчиков компилятора, и чтобы избежать одного и того же описания в двух местах, элементы &lt;code&gt;Options&lt;/code&gt; , управляющие предупреждениями, описаны только в модуле &lt;code&gt;compile(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4808daf64c94ffd2d15ac09bfa7bb9ffab8a8096" translate="yes" xml:space="preserve">
          <source>As was mentioned before, the graph analyses operate on the &lt;code&gt;digraph&lt;/code&gt; representation of graphs. By default, the &lt;code&gt;digraph&lt;/code&gt; representation is created when needed (and deleted when no longer used), but it can also be created explicitly by use of the &lt;code&gt;closure&lt;/code&gt; operator:</source>
          <target state="translated">Как уже упоминалось выше, анализ графиков действуют на &lt;code&gt;digraph&lt;/code&gt; представления графов. По умолчанию представление &lt;code&gt;digraph&lt;/code&gt; создается при необходимости (и удаляется, когда оно больше не используется), но его также можно создать явно с помощью оператора &lt;code&gt;closure&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08da2b535fd9c3da81a12df0eca527a12e4f65fc" translate="yes" xml:space="preserve">
          <source>As was mentioned in the previous section, &lt;code&gt;start_erl&lt;/code&gt; requires a &lt;code&gt;sys.config&lt;/code&gt; in the release version directory (&lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt;). If there is no such file, the system start fails. Such a file must therefore also be added.</source>
          <target state="translated">Как упоминалось в предыдущем разделе, для &lt;code&gt;start_erl&lt;/code&gt; требуется &lt;code&gt;sys.config&lt;/code&gt; в каталоге версии выпуска ( &lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt; ). Если такого файла нет, запуск системы завершится ошибкой. Следовательно, такой файл также должен быть добавлен.</target>
        </trans-unit>
        <trans-unit id="9f5cac0dfe306d70277c63b5386d001ed67533ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как и в случае с &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; , передача права собственности не выполняется. Ресурс еще нужно освободить с помощью &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86dd8791c9b5f5dca561254006fe497e2d3994c7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt;: use with extreme care.</source>
          <target state="translated">Как и в случае с &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt; : используйте с особой осторожностью.</target>
        </trans-unit>
        <trans-unit id="efe69f566993703e5412e0783db54d43802e91bd" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;run/3&lt;/code&gt;, compilation errors raise the &lt;code&gt;badarg&lt;/code&gt; exception. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; can be used to get more information about the error.</source>
          <target state="translated">Как и в случае с &lt;code&gt;run/3&lt;/code&gt; , ошибки компиляции вызывают исключение &lt;code&gt;badarg&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; можно использовать для получения дополнительной информации об ошибке.</target>
        </trans-unit>
        <trans-unit id="65ddbc78ec2288effbfbc27dc2887832b0da7683" translate="yes" xml:space="preserve">
          <source>As with all other functions starting with &lt;code&gt;ei_&lt;/code&gt;, you are &lt;strong&gt;not&lt;/strong&gt; expected to put the socket in non-blocking mode yourself in the program. Every use of non-blocking mode is embedded inside the time-out functions. The socket will always be back in blocking mode after the operations are completed (regardless of the result). To avoid problems, leave the socket options alone. &lt;code&gt;ei&lt;/code&gt; handles any socket options that need modification.</source>
          <target state="translated">Как и в случае со всеми другими функциями, начинающимися с &lt;code&gt;ei_&lt;/code&gt; , от вас &lt;strong&gt;не&lt;/strong&gt; ожидается , что вы сами переведете сокет в неблокирующий режим в программе. Каждое использование неблокирующего режима встроено в функции тайм-аута. После завершения операций сокет всегда возвращается в режим блокировки (независимо от результата). Чтобы избежать проблем, оставьте параметры розетки в покое. &lt;code&gt;ei&lt;/code&gt; обрабатывает любые параметры сокета, которые требуют модификации.</target>
        </trans-unit>
        <trans-unit id="c3c8339b0d633ff7f739e39a8bb36a1648a7db29" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process is lost if the supervisor itself restarts.</source>
          <target state="translated">Как и в случае динамически добавляемых дочерних процессов,эффект удаления статического дочернего процесса теряется при перезапуске самого супервизора.</target>
        </trans-unit>
        <trans-unit id="ec50db8f3e13bb5768f12bc8a6a3b1ddcd9124a9" translate="yes" xml:space="preserve">
          <source>As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity.</source>
          <target state="translated">Как и в случае с обычными древовидными структурами,поиск (тестирование членства),вставка и удаление имеют логарифмическую сложность.</target>
        </trans-unit>
        <trans-unit id="96a345435dd16a7fc2f73434205466252ddf7e39" translate="yes" xml:space="preserve">
          <source>As with process monitors, each driver monitor set only generates &lt;strong&gt;one single message&lt;/strong&gt;. The monitor is &quot;destroyed&quot; after the message is sent, so it is then not needed to call &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как и в случае с мониторами процессов, каждый набор мониторов драйверов генерирует только &lt;strong&gt;одно сообщение&lt;/strong&gt; . После отправки сообщения монитор &quot;уничтожается&quot;, поэтому в этом случае нет необходимости вызывать &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2467dbec656f95127f4a0e7d30ecc8a6ad6234f" translate="yes" xml:space="preserve">
          <source>As you can see by the example, the function can be called from the shell too. The &lt;code&gt;fun()&lt;/code&gt; needs to be literally in the call when used from the shell as well. Other means than the parse_transform are used in the shell case, but more or less the same restrictions apply (the exception being records, as they are not handled by the shell).</source>
          <target state="translated">Как видно из примера, функцию можно вызывать и из оболочки. &lt;code&gt;fun()&lt;/code&gt; должно быть буквально в вызове при использовании из командной строки , а также. В случае оболочки используются другие средства, кроме parse_transform, но применяются более или менее те же ограничения (исключение составляют записи, поскольку они не обрабатываются оболочкой).</target>
        </trans-unit>
        <trans-unit id="2b8232bbed24ef8f629ce1816536b7c03bfad7c6" translate="yes" xml:space="preserve">
          <source>As you can understand from the illustration, &lt;code&gt;Common Test&lt;/code&gt; requires a test case to generate a runtime error to indicate failure (for example, by causing a bad match error or by calling &lt;code&gt;exit/1&lt;/code&gt;, preferably through the help function &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt;). A successful execution is indicated by a normal return from the test case function.</source>
          <target state="translated">Как вы можете понять из иллюстрации, &lt;code&gt;Common Test&lt;/code&gt; требует, чтобы тестовый пример генерировал ошибку времени выполнения, чтобы указать на сбой (например, вызывая ошибку неправильного совпадения или вызывая &lt;code&gt;exit/1&lt;/code&gt; , предпочтительно через функцию справки &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; ). Об успешном выполнении свидетельствует нормальный возврат из функции тестового примера.</target>
        </trans-unit>
        <trans-unit id="9b635d527fabae96e027fa225db3c0e9bac328ef" translate="yes" xml:space="preserve">
          <source>As you have seen, it is possible to use the &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; functions explicitly. By using those functions you can write your own trace client that reads trace data from any source stored in any format and just feed the &lt;code&gt;Collector&lt;/code&gt; with it. You may replace the default &lt;code&gt;Collector Filter&lt;/code&gt; with a filter that converts new exciting trace data formats to &lt;code&gt;Event Records&lt;/code&gt; or you may convert it to an &lt;code&gt;Event Record&lt;/code&gt; before you invoke &lt;code&gt;et_collector:report/2&lt;/code&gt; and then rely on the default &lt;code&gt;Collector Filter&lt;/code&gt; to handle the new format.</source>
          <target state="translated">Как вы видели, можно явно использовать функции &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; . Используя эти функции, вы можете написать свой собственный клиент трассировки, который считывает данные трассировки из любого источника, хранящегося в любом формате, и просто загружает их в &lt;code&gt;Collector&lt;/code&gt; . Вы можете заменить &lt;code&gt;Collector Filter&lt;/code&gt; по умолчанию фильтром, который преобразует новые захватывающие форматы данных трассировки в записи &lt;code&gt;Event Records&lt;/code&gt; или вы можете преобразовать его в &lt;code&gt;Event Record&lt;/code&gt; перед &lt;code&gt;et_collector:report/2&lt;/code&gt; и затем полагаться на &lt;code&gt;Collector Filter&lt;/code&gt; по умолчанию для обработки нового формата ,</target>
        </trans-unit>
        <trans-unit id="d261c2679b68d55f3f5768006262a218d859a604" translate="yes" xml:space="preserve">
          <source>Ask them to transform the internal state format and switch to the new version of the module.</source>
          <target state="translated">Попросите их преобразовать внутренний формат состояния и перейти на новую версию модуля.</target>
        </trans-unit>
        <trans-unit id="7ccd30300261a4eca3d0f1af0fcf77d29e731e3c" translate="yes" xml:space="preserve">
          <source>Asking for and inspecting raw socket options require low-level information about the current operating system and TCP stack.</source>
          <target state="translated">Для запроса и проверки опций сырых сокетов требуется низкоуровневая информация о текущей операционной системе и TCP-стеке.</target>
        </trans-unit>
        <trans-unit id="0599d793007329beb80221bb5065e2bf255ef6e5" translate="yes" xml:space="preserve">
          <source>Assert end of string (or line, in multiline mode)</source>
          <target state="translated">Установить конец строки (или строки,в многострочном режиме)</target>
        </trans-unit>
        <trans-unit id="cf59339e55d5c656acd77a3516f63cf3ff15de3e" translate="yes" xml:space="preserve">
          <source>Assert start of string (or line, in multiline mode)</source>
          <target state="translated">Установка начала строки (или строки,в многострочном режиме)</target>
        </trans-unit>
        <trans-unit id="18d329141ee34e40c36d7b169bb7a159eb5aeb08" translate="yes" xml:space="preserve">
          <source>Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.)</source>
          <target state="translated">Вложенные подмаски не захватывают подмаски.Если такое утверждение содержит захватывающие подмаски внутри него,то они учитываются для нумерации захватывающих подмастерн по всей детали.Однако захват подмаски производится только для положительных утверждений.(Perl иногда,но не всегда,выполняет захват в отрицательных утверждениях).</target>
        </trans-unit>
        <trans-unit id="dc3e91b0be656a68c41466178566755f49840e06" translate="yes" xml:space="preserve">
          <source>Assertions can be nested in any combination. For example, the following matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded by &quot;foo&quot;:</source>
          <target state="translated">Утверждения могут быть вложены в любую комбинацию.Например,следующему соответствует появление &quot;baz&quot;,которому предшествует &quot;bar&quot;,которому,в свою очередь,не предшествует &quot;foo&quot;:</target>
        </trans-unit>
        <trans-unit id="8383a156cd04a5d92aafffd1ec55eeaa8e37c727" translate="yes" xml:space="preserve">
          <source>Assigning a value to type &lt;code&gt;Operational&lt;/code&gt; in Erlang is possible by using the following Erlang code:</source>
          <target state="translated">Присвоение значения типу &lt;code&gt;Operational&lt;/code&gt; в Erlang возможно с помощью следующего кода Erlang:</target>
        </trans-unit>
        <trans-unit id="4ad8afb43e64d75a730687d995308551590810c9" translate="yes" xml:space="preserve">
          <source>Assignment ::= Variable &lt;code&gt;:=&lt;/code&gt; Expression | Variable &lt;code&gt;=&lt;/code&gt; Expression</source>
          <target state="translated">Присвоение :: = Переменная &lt;code&gt;:=&lt;/code&gt; Выражение | Переменная &lt;code&gt;=&lt;/code&gt; Выражение</target>
        </trans-unit>
        <trans-unit id="31732955b5b879b8595ccb4012494c26bfc62323" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt;.</source>
          <target state="translated">Назначает новый &lt;code&gt;Pid&lt;/code&gt; процесса управления для &lt;code&gt;Socket&lt;/code&gt; . Та же реализация, что и &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="750263088fcf3a705a426666d4ba4253060235cc" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. The controlling process is the process that receives messages from the socket. If called by any other process than the current controlling process, &lt;code&gt;{error, not_owner}&lt;/code&gt; is returned. If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local pid, &lt;code&gt;{error, badarg}&lt;/code&gt; is returned. &lt;code&gt;{error, badarg}&lt;/code&gt; may also be returned in some cases when &lt;code&gt;Socket&lt;/code&gt; is closed during the execution of this function.</source>
          <target state="translated">Назначает новый &lt;code&gt;Pid&lt;/code&gt; процесса управления для &lt;code&gt;Socket&lt;/code&gt; . Управляющий процесс - это процесс, который получает сообщения от сокета. Если &lt;code&gt;{error, not_owner}&lt;/code&gt; любым другим процессом, кроме текущего контролирующего процесса, возвращается {error, not_owner} . Если процесс, идентифицированный &lt;code&gt;Pid&lt;/code&gt; , не является существующим локальным pid, возвращается &lt;code&gt;{error, badarg}&lt;/code&gt; . &lt;code&gt;{error, badarg}&lt;/code&gt; также может возвращаться в некоторых случаях, когда &lt;code&gt;Socket&lt;/code&gt; закрыт во время выполнения этой функции.</target>
        </trans-unit>
        <trans-unit id="83e6ee60d090046ec0df21d8f20b308779b0123e" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process to the SSL socket. A controlling process is the owner of an SSL socket, and receives all messages from the socket.</source>
          <target state="translated">Назначает новый управляющий процесс для SSL-сокета.Управляющий процесс является владельцем SSL-сокета и получает все сообщения от него.</target>
        </trans-unit>
        <trans-unit id="e2015efa67c45a84e357363963f8ef7cc19116af" translate="yes" xml:space="preserve">
          <source>Associate a result set containing the whole table &lt;code&gt;EMPLOYEE&lt;/code&gt; to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">&lt;code&gt;EMPLOYEE&lt;/code&gt; с соединением набор результатов, содержащий всю таблицу EMPLOYEE . Возвращается количество строк в наборе результатов.</target>
        </trans-unit>
        <trans-unit id="c01c817bd8220a9e426732586a19782a2ec8dae2" translate="yes" xml:space="preserve">
          <source>Associate a result set that contains the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">&lt;code&gt;FIRSTNAME&lt;/code&gt; с соединением набор результатов, содержащий поля FIRSTNAME и &lt;code&gt;NR&lt;/code&gt; для всех сотрудников-женщин. Возвращается количество строк в наборе результатов.</target>
        </trans-unit>
        <trans-unit id="e682a3847cd3fad46ea3e5c2bf3acec87c695369" translate="yes" xml:space="preserve">
          <source>Associates &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; and inserts the association into map &lt;code&gt;Map2&lt;/code&gt;. If key &lt;code&gt;Key&lt;/code&gt; already exists in map &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new association and the old associations in &lt;code&gt;Map1&lt;/code&gt;.</source>
          <target state="translated">Associates &lt;code&gt;Key&lt;/code&gt; со значением &lt;code&gt;Value&lt;/code&gt; и вставляет связь в карте &lt;code&gt;Map2&lt;/code&gt; . Если ключ &lt;code&gt;Key&lt;/code&gt; уже существует на карте &lt;code&gt;Map1&lt;/code&gt; , старое связанное значение заменяется значением &lt;code&gt;Value&lt;/code&gt; . Функция возвращает новую карту &lt;code&gt;Map2&lt;/code&gt; , содержащую новую ассоциацию и старые ассоциации в &lt;code&gt;Map1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe25fda4b17970a0ef529403d3f726c24aae538c" translate="yes" xml:space="preserve">
          <source>Associates a UDP port number (&lt;code&gt;Port&lt;/code&gt;) with the calling process.</source>
          <target state="translated">Связывает номер порта UDP ( &lt;code&gt;Port&lt;/code&gt; ) с вызывающим процессом.</target>
        </trans-unit>
        <trans-unit id="f1f8648a03de87c0a9794d9b8e650c32fee361c7" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;Name&lt;/code&gt;, an atom, with the process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Связывает имя &lt;code&gt;Name&lt;/code&gt; , атом, с процессом &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adba476945469569c82884884c1c62b87ee5beca" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;RegName&lt;/code&gt; with a process identifier (pid) or a port identifier. &lt;code&gt;RegName&lt;/code&gt;, which must be an atom, can be used instead of the pid or port identifier in send operator (&lt;code&gt;RegName ! Message&lt;/code&gt;). Example:</source>
          <target state="translated">&lt;code&gt;RegName&lt;/code&gt; имя RegName с идентификатором процесса (pid) или идентификатором порта. &lt;code&gt;RegName&lt;/code&gt; , которое должно быть атомом, может использоваться вместо идентификатора pid или порта в операторе отправки ( &lt;code&gt;RegName ! Message&lt;/code&gt; ). Пример:</target>
        </trans-unit>
        <trans-unit id="41bb0af24396833201992ca15a0ccfba7ee7f093" translate="yes" xml:space="preserve">
          <source>Associates the test run with a name that gets printed in the overview HTML log files.</source>
          <target state="translated">Сопоставляет прогон теста с именем,которое печатается в HTML-файлах журнала обзора.</target>
        </trans-unit>
        <trans-unit id="a929bb502012d59c211ba29e792fdfc1bcec65b6" translate="yes" xml:space="preserve">
          <source>Association is successfully established. This indicates a successful completion of &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">Ассоциация успешно создана. Это указывает на успешное завершение &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd321e5d28d57fcf199c5a0fe6ae644a0f00e982" translate="yes" xml:space="preserve">
          <source>Assume that a module is extended by adding an interface function, as in the example in &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;, where a function &lt;code&gt;available/0&lt;/code&gt; is added to &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">Предположим, что модуль расширен за счет добавления интерфейсной функции, как в примере в &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; , где функция &lt;code&gt;available/0&lt;/code&gt; добавляется к &lt;code&gt;ch3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81e67a14a83897861024d39ef25a7c52fdc905a0" translate="yes" xml:space="preserve">
          <source>Assume that a test case for the following program should be verified:</source>
          <target state="translated">Предположим,что необходимо проверить тестовый случай для следующей программы:</target>
        </trans-unit>
        <trans-unit id="71a8953ab141a80996cc4c7f627c6481c2d38dca" translate="yes" xml:space="preserve">
          <source>Assume that a user does not want Erlang to use the native lookup method, but wants Erlang to read all information necessary from start and use that for resolving names and addresses. If lookup fails, Erlang is to request the data from a nameserver (using the Erlang DNS client, set to use EDNS allowing larger responses). The resolver configuration is updated when its configuration file changes. Also, DNS records are never to be cached. The user configuration file (in this example named &lt;code&gt;erl_inetrc&lt;/code&gt;, stored in directory &lt;code&gt;./cfg_files&lt;/code&gt;) can then look as follows (Unix):</source>
          <target state="translated">Предположим, что пользователь не хочет, чтобы Erlang использовал собственный метод поиска, но хочет, чтобы Erlang читал всю необходимую информацию с самого начала и использовал ее для разрешения имен и адресов. Если поиск завершился неудачно, Erlang должен запросить данные с сервера имен (используя DNS-клиент Erlang, настроенный на использование EDNS, позволяющего получать более крупные ответы). Конфигурация резолвера обновляется при изменении его файла конфигурации. Кроме того, никогда нельзя кэшировать записи DNS. Файл конфигурации пользователя (в этом примере с именем &lt;code&gt;erl_inetrc&lt;/code&gt; , хранящийся в каталоге &lt;code&gt;./cfg_files&lt;/code&gt; ) может выглядеть следующим образом (Unix):</target>
        </trans-unit>
        <trans-unit id="2d48df2f1a8f0fd07793d2b425e8df418ef5bfad" translate="yes" xml:space="preserve">
          <source>Assume that nothing happens when tracing in this way. The function is never called with these parameters. We conclude that someone else (some other module) is doing it and realize that we must trace on &lt;code&gt;ets:insert/2&lt;/code&gt; and want to see the calling function. The calling function can be retrieved using the match specification function &lt;code&gt;caller&lt;/code&gt;. To get it into the trace message, the match specification function &lt;code&gt;message&lt;/code&gt; must be used. The filter call looks like this (looking for calls to &lt;code&gt;ets:insert/2&lt;/code&gt;):</source>
          <target state="translated">Предположим, что при такой трассировке ничего не происходит. Функция никогда не вызывается с этими параметрами. Мы заключаем, что это делает кто-то другой (какой-то другой модуль), и понимаем, что мы должны отслеживать &lt;code&gt;ets:insert/2&lt;/code&gt; и хотим видеть вызывающую функцию. Вызывающую функцию можно получить с помощью &lt;code&gt;caller&lt;/code&gt; функции спецификации соответствия . Чтобы поместить его в сообщение трассировки, необходимо использовать &lt;code&gt;message&lt;/code&gt; функции спецификации соответствия. Вызов фильтра выглядит так (ищем вызовы &lt;code&gt;ets:insert/2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="997882ed021f898e3c4711038cfd690fedaa8231" translate="yes" xml:space="preserve">
          <source>Assume that the module now passes all testing and goes into the system. After a while, it is found that table &lt;code&gt;toy_table&lt;/code&gt; grows while the system is running and that there are many elements with atoms as keys. We expected only integer keys and so does the rest of the system, but clearly not the entire system. We turn on call tracing and try to see calls to the module with an atom as the key:</source>
          <target state="translated">Предположим, что модуль теперь проходит все проверки и входит в систему. Через некоторое время обнаруживается, что таблица &lt;code&gt;toy_table&lt;/code&gt; растет во время работы системы и что есть много элементов с атомами в качестве ключей. Мы ожидали только целочисленных ключей, как и вся остальная система, но явно не всей системы. Включаем трассировку вызовов и пытаемся увидеть вызовы модуля с атомом в качестве ключа:</target>
        </trans-unit>
        <trans-unit id="f89a940266dfec94c78b06cb601b527f92f04417" translate="yes" xml:space="preserve">
          <source>Assume that the suite contains the test case &lt;code&gt;get_resource_status&lt;/code&gt; that is independent of the other two cases, then function &lt;code&gt;all&lt;/code&gt; can look as follows:</source>
          <target state="translated">Предположим, что набор содержит тестовый пример &lt;code&gt;get_resource_status&lt;/code&gt; , который не зависит от двух других случаев, тогда функция &lt;code&gt;all&lt;/code&gt; может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="d831964edca879d5d90599f59a999703ad024ad1" translate="yes" xml:space="preserve">
          <source>Assume that there are two systems, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, that are tested in separate test runs. System &lt;code&gt;s1&lt;/code&gt; contains a library module &lt;code&gt;m1&lt;/code&gt; tested by test run &lt;code&gt;s1&lt;/code&gt; and is included in the cover specification of &lt;code&gt;s1&lt;/code&gt; as follows:</source>
          <target state="translated">Предположим, что есть две системы, &lt;code&gt;s1&lt;/code&gt; и &lt;code&gt;s2&lt;/code&gt; , которые тестируются в отдельных тестовых прогонах. Система &lt;code&gt;s1&lt;/code&gt; содержит библиотечный модуль &lt;code&gt;m1&lt;/code&gt; , протестированный тестовым запуском &lt;code&gt;s1&lt;/code&gt; , и включен в спецификацию обложки &lt;code&gt;s1&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="0a42279cd9be030fbaa5a2fcc34c767220fae2bb" translate="yes" xml:space="preserve">
          <source>Assume that there is a network application that receives instances of the ASN.1 defined type &lt;code&gt;Person&lt;/code&gt;, modifies, and sends them back again:</source>
          <target state="translated">Предположим, что существует сетевое приложение, которое получает экземпляры определенного типа ASN.1 &lt;code&gt;Person&lt;/code&gt; , изменяет и отправляет их обратно:</target>
        </trans-unit>
        <trans-unit id="33069b991dada2eb5da77ef53b4f64ef6b97abaa" translate="yes" xml:space="preserve">
          <source>Assume that there is an index on position &lt;code&gt;Pos&lt;/code&gt; for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table &lt;code&gt;person&lt;/code&gt;, the call &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; returns a list of all persons with age 36. &lt;code&gt;Pos&lt;/code&gt; can also be an attribute name (atom), but if the notation &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; is used, the field position is searched for in runtime, for each call.</source>
          <target state="translated">Предположим, что есть индекс позиции &lt;code&gt;Pos&lt;/code&gt; для определенного типа записи. Эту функцию можно использовать для чтения записей, не зная фактического ключа записи. Например, с индексом в позиции 1 таблицы &lt;code&gt;person&lt;/code&gt; вызов &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; возвращает список всех лиц в возрасте 36 лет. &lt;code&gt;Pos&lt;/code&gt; также может быть именем атрибута (atom), но если используется обозначение &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; , позиция поля ищется во время выполнения для каждого вызова.</target>
        </trans-unit>
        <trans-unit id="829ce164f6e9881978858a93ac53473e3de7a2fe" translate="yes" xml:space="preserve">
          <source>Assume that we have not found the problem yet, and want to see what &lt;code&gt;ets:new/2&lt;/code&gt; returns. We use a slightly different trace pattern:</source>
          <target state="translated">Предположим, что мы еще не нашли проблему и хотим узнать, что возвращает &lt;code&gt;ets:new/2&lt;/code&gt; . Мы используем немного другой узор трассировки:</target>
        </trans-unit>
        <trans-unit id="58d7492d43f93e533d2fc8b2893194dfb95c91d5" translate="yes" xml:space="preserve">
          <source>Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier:</source>
          <target state="translated">Предположим,что мы хотим,чтобы весь объект совпадал,а не только один элемент.Одна из альтернатив-назначить переменную каждой части записи и построить ее еще раз в теле забавы,но следующее проще:</target>
        </trans-unit>
        <trans-unit id="d1bf62160b9303fd32fdad0cd34b9da4d1aef481" translate="yes" xml:space="preserve">
          <source>Assume that we want to get all the employee numbers of employees hired before year 2000. Using &lt;code&gt;ets:match/2&lt;/code&gt; is not an alternative here, as relational operators cannot be expressed there. Once again, &lt;code&gt;ets:foldr/3&lt;/code&gt; can do it (slowly, but correct):</source>
          <target state="translated">Предположим, что мы хотим получить все числа сотрудников, нанятых до 2000 года. Использование &lt;code&gt;ets:match/2&lt;/code&gt; здесь не альтернатива, поскольку там нельзя выразить реляционные операторы. И снова &lt;code&gt;ets:foldr/3&lt;/code&gt; может это сделать (медленно, но правильно):</target>
        </trans-unit>
        <trans-unit id="1ba39d9d328d97a989e24d8ac3124b4d21b0636f" translate="yes" xml:space="preserve">
          <source>Assume that you have an initiating process with &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="translated">Предположим, у вас есть инициирующий процесс с &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="59beb2deb0d2bf3ac19ece9f2db7b475398662e6" translate="yes" xml:space="preserve">
          <source>Assume that you want to calculate the factorial for 1:</source>
          <target state="translated">Предположим,что вы хотите рассчитать факториал для 1:</target>
        </trans-unit>
        <trans-unit id="81e6855c42a523802dad6f1c6e5e336c4662d743" translate="yes" xml:space="preserve">
          <source>Assume that you want to transform the &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; document to HTML. If you want the same structure and tags of the resulting HTML document as of the XML document then you can use the &lt;code&gt;xmerl:export/2&lt;/code&gt; function. The following:</source>
          <target state="translated">Предположим, вы хотите преобразовать документ &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; в HTML. Если вам нужна такая же структура и теги результирующего документа HTML, что и у документа XML, вы можете использовать &lt;code&gt;xmerl:export/2&lt;/code&gt; . Последующий:</target>
        </trans-unit>
        <trans-unit id="42a5d8a52feabf03d2cc601350c97037810f3131" translate="yes" xml:space="preserve">
          <source>Assume the following:</source>
          <target state="translated">Предположим следующее:</target>
        </trans-unit>
        <trans-unit id="b4dd172e924a451d443d3ebe731fdc5eb7eae97d" translate="yes" xml:space="preserve">
          <source>Assume we want to check the following module:</source>
          <target state="translated">Допустим,мы хотим проверить следующий модуль:</target>
        </trans-unit>
        <trans-unit id="a1917e9bb4b3ba3244f0149508301240f3ef84a5" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each location &lt;code&gt;L&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">Предполагает, что &lt;code&gt;Term&lt;/code&gt; - это термин с той же структурой, что и дерево &lt;code&gt;erl_parse&lt;/code&gt; , но с &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; где дерево &lt;code&gt;erl_parse&lt;/code&gt; имеет коллекции аннотаций. Возвращает дерево &lt;code&gt;erl_parse&lt;/code&gt; ,в котором каждое местоположение &lt;code&gt;L&lt;/code&gt; заменяется значением, возвращаемым &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt; . Термин &lt;code&gt;Term&lt;/code&gt; вводится слева направо в глубину.</target>
        </trans-unit>
        <trans-unit id="b7cafb7be7f1db85e6934ccfbc9df1141dff9353" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">Предполагает, что &lt;code&gt;Term&lt;/code&gt; - это термин с той же структурой, что и дерево &lt;code&gt;erl_parse&lt;/code&gt; , но с терминами, скажем &lt;code&gt;T&lt;/code&gt; , где дерево &lt;code&gt;erl_parse&lt;/code&gt; имеет коллекции аннотаций. Возвращает дерево &lt;code&gt;erl_parse&lt;/code&gt; ,в котором каждый термин &lt;code&gt;T&lt;/code&gt; заменяется значением, возвращаемым &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt; . Термин &lt;code&gt;Term&lt;/code&gt; вводится слева направо в глубину.</target>
        </trans-unit>
        <trans-unit id="0867c9c6c98bb1857eef83b5370df89b6931896a" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;Forms&lt;/code&gt; represents a program (or any sequence of &quot;program forms&quot;), any comments whose first lines are not directly associated with a specific program form will become standalone comments inserted between the neighbouring program forms. Furthermore, comments whose column position is less than or equal to one will not be attached to a program form that begins at a conflicting line number (this can happen with preprocessor-generated &lt;code&gt;line&lt;/code&gt;-attributes).</source>
          <target state="translated">Предполагая, что &lt;code&gt;Forms&lt;/code&gt; представляет программу (или любую последовательность &amp;laquo;программных форм&amp;raquo;), любые комментарии, первые строки которых не связаны напрямую с конкретной формой программы, станут автономными комментариями, вставленными между соседними программными формами. Кроме того, комментарии, позиция столбца которых меньше или равна единице, не будут прикреплены к форме программы, которая начинается с конфликтующего номера строки (это может произойти с атрибутами &lt;code&gt;line&lt;/code&gt; созданными препроцессором ).</target>
        </trans-unit>
        <trans-unit id="85756eb2ccf84d68d4412ebf0e79850cfd5d276b" translate="yes" xml:space="preserve">
          <source>Assuming an Erlang system called ping (but not the &quot;ping&quot; process) has already been started on kosken, then on gollum this is done:</source>
          <target state="translated">Если предположить,что на kosken уже запущена система Erlang под названием ping (но не процесс &quot;ping&quot;),то на gollum это делается:</target>
        </trans-unit>
        <trans-unit id="10a82aabb0e61cdb059228faa6975a490d22e3b9" translate="yes" xml:space="preserve">
          <source>Assuming an Ets table that uses &lt;code&gt;idno&lt;/code&gt; as key and contains the following:</source>
          <target state="translated">Предполагая, что таблица Ets использует &lt;code&gt;idno&lt;/code&gt; в качестве ключа и содержит следующее:</target>
        </trans-unit>
        <trans-unit id="18d8e312811328614a25350d0eb0a85b61ed61f9" translate="yes" xml:space="preserve">
          <source>Assuming that both the arguments and the results from the C functions are less than 256, a simple encoding/decoding scheme is employed. In this scheme, &lt;code&gt;foo&lt;/code&gt; is represented by byte 1, &lt;code&gt;bar&lt;/code&gt; is represented by 2, and the argument/result is represented by a single byte as well:</source>
          <target state="translated">Предполагая, что и аргументы, и результаты функций C меньше 256, используется простая схема кодирования / декодирования. На этой схеме &lt;code&gt;foo&lt;/code&gt; представлен байтом 1, &lt;code&gt;bar&lt;/code&gt; представлен байтом 2, а аргумент / результат также представлен одним байтом:</target>
        </trans-unit>
        <trans-unit id="a66845ce6e93230866ff8e0772d20b4798a32003" translate="yes" xml:space="preserve">
          <source>Assuming that environment variables has been correctly set, a strings containing valid characters on the specific OS for environment variable names and values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. The first &lt;code&gt;$=&lt;/code&gt; characters appearing in the string separates environment variable name (on the left) from environment variable value (on the right).</source>
          <target state="translated">Предполагая, что переменные среды были установлены правильно, строки, содержащие допустимые символы в конкретной ОС для имен и значений переменных среды, с использованием кодировки &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; . Первые символы &lt;code&gt;$=&lt;/code&gt; появляющиеся в строке, отделяют имя переменной среды (слева) от значения переменной среды (справа).</target>
        </trans-unit>
        <trans-unit id="0a6f58980048155b748b7c9405f322e65c5a9184" translate="yes" xml:space="preserve">
          <source>Assuming that the call to &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; does not find any schema to read on the disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</source>
          <target state="translated">Предполагая, что вызов &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; не находит никакой схемы для чтения на диске, &lt;code&gt;Mnesia&lt;/code&gt; запускается как бездисковый узел, а затем меняет его на узел, который использует диск для локального хранения схемы.</target>
        </trans-unit>
        <trans-unit id="d6872420cefd05df68dce4eed3bc63d15db4f598" translate="yes" xml:space="preserve">
          <source>Assuming that the node has been started as follows:</source>
          <target state="translated">Предполагая,что узел был запущен следующим образом:</target>
        </trans-unit>
        <trans-unit id="8499608ce735317421447e4bbbb5e480084db254" translate="yes" xml:space="preserve">
          <source>Assuming that these requirements are fulfilled, time correction is enabled, and OS system time is adjusted using a time adjustment protocol such as NTP, only small adjustments of Erlang monotonic time are needed to keep system times aligned after finalization. As long as the system is not suspended, the largest adjustments needed are for inserted (or deleted) leap seconds.</source>
          <target state="translated">При условии выполнения этих требований,включения коррекции времени и корректировки системного времени операционной системы с использованием протокола коррекции времени,такого как NTP,требуется лишь небольшая корректировка монотонного времени Эрланга для поддержания системного времени в норме после окончательной доработки.До тех пор,пока система не будет приостановлена,самые большие корректировки необходимы для вставленных (или удаленных)прыжковых секунд.</target>
        </trans-unit>
        <trans-unit id="03367feb887591c7e80f18fd1145673d7dcffe3e" translate="yes" xml:space="preserve">
          <source>Assuming that these types are exported from module &lt;code&gt;'mod'&lt;/code&gt;, you can refer to them from other modules using remote type expressions like the following:</source>
          <target state="translated">Предполагая, что эти типы экспортируются из модуля &lt;code&gt;'mod'&lt;/code&gt; , вы можете ссылаться на них из других модулей, используя выражения удаленного типа, такие как следующие:</target>
        </trans-unit>
        <trans-unit id="26267ff052ff06ed2dce21d69453c5f440474929" translate="yes" xml:space="preserve">
          <source>Assuming that we want the employee numbers of everyone in the sales department, there are several ways.</source>
          <target state="translated">Если предположить,что нам нужны номера сотрудников каждого отдела продаж,то есть несколько способов.</target>
        </trans-unit>
        <trans-unit id="266f66badd0d0b518b2e5df463ab8847e52c02bb" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;.rel file&lt;/code&gt; is stored in a file &lt;code&gt;start_ssl.rel&lt;/code&gt; in the current directory, a boot script can be built as follows:</source>
          <target state="translated">Предполагая, что &lt;code&gt;.rel file&lt;/code&gt; хранится в файле &lt;code&gt;start_ssl.rel&lt;/code&gt; в текущем каталоге, сценарий загрузки может быть построен следующим образом:</target>
        </trans-unit>
        <trans-unit id="6fce84ccb66529fc8ed6e1c0f38776816b583ca0" translate="yes" xml:space="preserve">
          <source>Assuming the same &lt;code&gt;CLIENTDIR&lt;/code&gt; as above, the last line is to look like:</source>
          <target state="translated">Предполагая тот же &lt;code&gt;CLIENTDIR&lt;/code&gt; , что и выше, последняя строка должна выглядеть так:</target>
        </trans-unit>
        <trans-unit id="3a0c79afff9d3483a1ae5e8cbc8205664dba4b83" translate="yes" xml:space="preserve">
          <source>Assuming there is an operational target system with installation root directory &lt;code&gt;$ROOT&lt;/code&gt;, the release package with the new version of the release is to be copied to &lt;code&gt;$ROOT/releases&lt;/code&gt;.</source>
          <target state="translated">Предполагая, что существует рабочая целевая система с корневым каталогом установки &lt;code&gt;$ROOT&lt;/code&gt; , пакет выпуска с новой версией выпуска должен быть скопирован в &lt;code&gt;$ROOT/releases&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7c30a0e4666f7264a0489fe55f811dceafac52d" translate="yes" xml:space="preserve">
          <source>Assuming these definitions:</source>
          <target state="translated">Предполагая эти определения:</target>
        </trans-unit>
        <trans-unit id="f4b10ac30756395c83923e7cf3c7d80acae92175" translate="yes" xml:space="preserve">
          <source>Async queue length is not defined for &lt;code&gt;put&lt;/code&gt; operations.</source>
          <target state="translated">Длина очереди Асинхронная не определена для &lt;code&gt;put&lt;/code&gt; операций.</target>
        </trans-unit>
        <trans-unit id="3988dd15a01716f5457aa8c6239f3feeb9605755" translate="yes" xml:space="preserve">
          <source>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See &lt;code&gt;erl +A&lt;/code&gt; for more details.</source>
          <target state="translated">Асинхронные потоки используются различными связанными драйверами (в основном файловыми драйверами), чтобы разгружать работу, не требующую интенсивного использования ЦП. См. &lt;code&gt;erl +A&lt;/code&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="1f2ff86b0c85c68964cf97af02073f12b82e6dee" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="translated">Асинхронный &lt;code&gt;get-bulk-request&lt;/code&gt; get (см. RFC1905).</target>
        </trans-unit>
        <trans-unit id="3284d2626e5dc0e20ecd8465f9256541f56870e5" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="translated">Асинхронный &lt;code&gt;get-next-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce12675017eba1aad96dc4af8158e8ade8a6e141" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="translated">Асинхронный &lt;code&gt;get-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07690d2c187b7cfafc60389b63d0ee62b7cd3c1c" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="translated">Асинхронный &lt;code&gt;set-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c4f45c7554c3415b2762a3d8f5669acc6525702" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Время очистки асинхронного запроса. Для каждого запроса некоторая информация хранится внутри, чтобы иметь возможность доставить ответ (когда он поступит) в нужное место назначения. Если ответ придет, эта информация будет удалена. Но если нет ответа (вовремя), информация должна быть удалена по прошествии &lt;strong&gt;лучшего&lt;/strong&gt; времени. Эта очистка будет выполняться через регулярные промежутки времени, определяемые &lt;code&gt;server_timeout()&lt;/code&gt; . Эта информация будет иметь &lt;strong&gt;лучшую , прежде чем&lt;/strong&gt; время, определяемое &lt;code&gt;Expire&lt;/code&gt; время , отведенное при вызове функции запроса (см &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f4ef40b42e8c28e77390dcc6fa14ba97907a734" translate="yes" xml:space="preserve">
          <source>Asynchronous request for cancellation. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the cancellation to be performed synchronously. When &lt;code&gt;Async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the cancel operation is performed asynchronously. That is, &lt;code&gt;cancel_timer()&lt;/code&gt; sends an asynchronous request for cancellation to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">Асинхронный запрос на отмену. &lt;code&gt;Async&lt;/code&gt; по умолчанию имеет значение &lt;code&gt;false&lt;/code&gt; , что приводит к синхронному выполнению отмены. Если &lt;code&gt;Async&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , операция отмены выполняется асинхронно. То есть &lt;code&gt;cancel_timer()&lt;/code&gt; отправляет асинхронный запрос на отмену службе таймера, которая управляет таймером, а затем возвращает &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95fd03b1444c479be3c52aee359cb2dfca32c856" translate="yes" xml:space="preserve">
          <source>Asynchronous request for state information. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the operation to be performed synchronously. In this case, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:read_timer&lt;/code&gt;. When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;erlang:read_timer&lt;/code&gt; sends an asynchronous request for the state information to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;. A message on the format &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:read_timer&lt;/code&gt; when the operation has been processed.</source>
          <target state="translated">Асинхронный запрос информации о состоянии. &lt;code&gt;Async&lt;/code&gt; по умолчанию имеет значение &lt;code&gt;false&lt;/code&gt; , что приводит к синхронному выполнению операции. В этом случае &lt;code&gt;Result&lt;/code&gt; возвращается &lt;code&gt;erlang:read_timer&lt;/code&gt; . Если &lt;code&gt;Async&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;erlang:read_timer&lt;/code&gt; отправляет асинхронный запрос информации о состоянии службе таймера, которая управляет таймером, а затем возвращает &lt;code&gt;ok&lt;/code&gt; . Сообщение в формате &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; отправляется вызывающему &lt;code&gt;erlang:read_timer&lt;/code&gt; , когда операция была обработана.</target>
        </trans-unit>
        <trans-unit id="6ca776a5d287d8b2a7dc6071e248dbb73c2d391b" translate="yes" xml:space="preserve">
          <source>Asynchronously append a list of items to a disk log. &lt;code&gt;alog_terms/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog_terms/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog_terms/2&lt;/code&gt; can also be used for internally formatted logs if the binaries are constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">Асинхронно добавить список элементов в дисковый журнал. &lt;code&gt;alog_terms/2&lt;/code&gt; используется для журналов внутреннего формата, а &lt;code&gt;balog_terms/2&lt;/code&gt; - для журналов внешнего формата. &lt;code&gt;balog_terms/2&lt;/code&gt; также можно использовать для журналов с внутренним форматированием, если двоичные файлы созданы с вызовами &lt;code&gt;term_to_binary/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5375e7ef1ea5eaaf79230eafedb013e5c6183e" translate="yes" xml:space="preserve">
          <source>Asynchronously append an item to a disk log. &lt;code&gt;alog/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog/2&lt;/code&gt; can also be used for internally formatted logs if the binary is constructed with a call to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">Асинхронно добавить элемент в журнал диска. &lt;code&gt;alog/2&lt;/code&gt; используется для журналов внутреннего форматирования, а &lt;code&gt;balog/2&lt;/code&gt; - для журналов внешнего форматирования. &lt;code&gt;balog/2&lt;/code&gt; также может использоваться для журналов с внутренним форматированием, если двоичный файл создается с помощью вызова &lt;code&gt;term_to_binary/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4919029fc256c29ef79f5f904616a2c8e94c3f2" translate="yes" xml:space="preserve">
          <source>At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for recursive patterns is described below.</source>
          <target state="translated">На &quot;верхнем уровне&quot; все эти условия рекурсивного теста являются ложными.Синтаксис рекурсивных паттернов описан ниже.</target>
        </trans-unit>
        <trans-unit id="f43d3dd154d77c634c392d671f75757f296a087e" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; contains a list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">При &lt;code&gt;success()&lt;/code&gt; , то &lt;code&gt;UserReply&lt;/code&gt; содержит список записей &amp;laquo;ActionReply&amp;raquo; , возможно , содержащих признаки ошибок.</target>
        </trans-unit>
        <trans-unit id="3d45243ad2c3b8770cad6640db0cb04483b46411" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; either contains:</source>
          <target state="translated">При &lt;code&gt;success()&lt;/code&gt; , то &lt;code&gt;UserReply&lt;/code&gt; либо содержит:</target>
        </trans-unit>
        <trans-unit id="a23e179a407d51751e1caa4f70ab6a111682bb8b" translate="yes" xml:space="preserve">
          <source>At any time, the current Erlang Top display can be dumped to a text file with function &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В любой момент текущий дисплей Erlang Top можно &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt; в текстовый файл с помощью функции etop: dump / 1 .</target>
        </trans-unit>
        <trans-unit id="4f1d3d95e4cd84ec49bb6d5fe0b90a58ea62ba48" translate="yes" xml:space="preserve">
          <source>At any time, to get the current status of the test nodes, call function &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В любой момент, чтобы получить текущий статус тестовых узлов, вызовите функцию &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd91a4b48e4394db081304cf8a7e752960166fb5" translate="yes" xml:space="preserve">
          <source>At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</source>
          <target state="translated">На каждой итерации подмаски,обратная ссылка соответствует строке символов,соответствующей предыдущей итерации.Для того,чтобы это сработало,шаблон должен быть таким,чтобы первая итерация не совпадала с обратной ссылкой.Это можно сделать с помощью чередования,как в примере выше,или с помощью квантификатора с минимумом нуля.</target>
        </trans-unit>
        <trans-unit id="b373a9f8122a8a2b8c68bd7132b1ca7c2848e49f" translate="yes" xml:space="preserve">
          <source>At each record access, &lt;code&gt;mnesia_frag&lt;/code&gt; first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</source>
          <target state="translated">При каждом доступе к записи &lt;code&gt;mnesia_frag&lt;/code&gt; сначала вычисляет хеш-значение из ключа записи. Во-вторых, имя фрагмента таблицы определяется по хеш-значению. Наконец, фактический доступ к таблицам выполняется теми же функциями, что и для нефрагментированных таблиц. Если ключ заранее не известен, выполняется поиск совпадающих записей во всех фрагментах.</target>
        </trans-unit>
        <trans-unit id="e791bb91b86137f009adcbd36f18e163d6c841d5" translate="yes" xml:space="preserve">
          <source>At least one other identifier type besides &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; must also have a list of identifiers.</source>
          <target state="translated">По крайней мере, еще один тип идентификатора, помимо &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; , также должен иметь список идентификаторов.</target>
        </trans-unit>
        <trans-unit id="f6e34fe0dc564614befa189e8748c8b5b71f49e4" translate="yes" xml:space="preserve">
          <source>At present only the default module is provided with the agent, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt;.</source>
          <target state="translated">В настоящее время с агентом &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; только модуль по умолчанию, snmpa_mib_data_tttn .</target>
        </trans-unit>
        <trans-unit id="52b6928d79b0ae8a32944a5857ee7a65e4d13aa4" translate="yes" xml:space="preserve">
          <source>At start-up, a node has a random atom assigned as its magic cookie and the cookie of other nodes is assumed to be &lt;code&gt;nocookie&lt;/code&gt;. The first action of the Erlang network authentication server (&lt;code&gt;auth&lt;/code&gt;) is then to read a file named &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt;. If the file does not exist, it is created. The UNIX permissions mode of the file is set to octal 400 (read-only by user) and its contents are a random string. An atom &lt;code&gt;Cookie&lt;/code&gt; is created from the contents of the file and the cookie of the local node is set to this using &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt;. This also makes the local node assume that all other nodes have the same cookie &lt;code&gt;Cookie&lt;/code&gt;.</source>
          <target state="translated">При пуске, узел имеет случайный атом назначен в качестве волшебного печенья и печенье из других узлов предполагаются &lt;code&gt;nocookie&lt;/code&gt; . Первым действием сервера сетевой аутентификации ( &lt;code&gt;auth&lt;/code&gt; ) Erlang является чтение файла с именем &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt; . Если файл не существует, он создается. Режим разрешений UNIX для файла установлен в восьмеричное число 400 (только для чтения пользователем), а его содержимое представляет собой случайную строку. Atom &lt;code&gt;Cookie&lt;/code&gt; создается из содержимого файла, и cookie локального узла устанавливается на это с помощью &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt; . Это также делает локальный узел считать , что все остальные узлы имеют одинаковые печенья &lt;code&gt;Cookie&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="518744e98c40235fc6bb7d9cc4f9e7b8cd708382" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; assumes that its local replica is the most recent version and loads the table from disc if either of the following situations is detected:</source>
          <target state="translated">При запуске &lt;code&gt;Mnesia&lt;/code&gt; предполагает, что его локальная реплика является самой последней версией, и загружает таблицу с диска, если обнаружена одна из следующих ситуаций:</target>
        </trans-unit>
        <trans-unit id="e5838a6fe5958edaad5f512813e7c830bd8af3cc" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, &lt;code&gt;Mnesia&lt;/code&gt; performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise &lt;code&gt;Mnesia&lt;/code&gt; shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</source>
          <target state="translated">При запуске &lt;code&gt;Mnesia&lt;/code&gt; соединяет разные узлы друг с другом, затем они обмениваются определениями таблиц друг с другом, и определения таблиц объединяются. Во время процедуры слияния &lt;code&gt;Mnesia&lt;/code&gt; выполняет тест на работоспособность, чтобы убедиться, что определения таблиц совместимы друг с другом. Если таблица существует на нескольких узлах, cookie должен быть одинаковым, в противном случае &lt;code&gt;Mnesia&lt;/code&gt; отключит один из узлов. Эта неприятная ситуация возникает, если таблица была создана на двух узлах независимо друг от друга, когда они были отключены. Чтобы решить эту проблему, необходимо удалить одну из таблиц (поскольку файлы cookie различаются, это считается двумя разными таблицами, даже если они имеют одинаковое имя).</target>
        </trans-unit>
        <trans-unit id="a627688b56cf27035c1a223f76b7c1a970186939" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; loads tables to make them accessible for its applications. Sometimes &lt;code&gt;Mnesia&lt;/code&gt; decides to load all tables that reside locally, and sometimes the tables are not accessible until &lt;code&gt;Mnesia&lt;/code&gt; brings a copy of the table from another node.</source>
          <target state="translated">При запуске &lt;code&gt;Mnesia&lt;/code&gt; загружает таблицы, чтобы сделать их доступными для своих приложений. Иногда &lt;code&gt;Mnesia&lt;/code&gt; решает загрузить все таблицы, которые находятся локально, а иногда таблицы недоступны, пока &lt;code&gt;Mnesia&lt;/code&gt; не принесет копию таблицы с другого узла.</target>
        </trans-unit>
        <trans-unit id="d42e266b7e766640fca49bd15e785ddd09a12678" translate="yes" xml:space="preserve">
          <source>At startup, Mnesia always loads &lt;code&gt;read_only&lt;/code&gt; table locally regardless of when and if Mnesia is terminated on other nodes. This argument returns the access mode of the table. The access mode can be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="translated">При запуске Mnesia всегда загружает таблицу &lt;code&gt;read_only&lt;/code&gt; локально, независимо от того, когда и если Mnesia завершается на других узлах. Этот аргумент возвращает режим доступа к таблице. Режим доступа может быть &lt;code&gt;read_only&lt;/code&gt; или &lt;code&gt;read_write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd3b6f4ef0dfb0e46121f11afdceab8754106c9b" translate="yes" xml:space="preserve">
          <source>At startup, notice that all tables residing on nodes without a &lt;code&gt;mnesia_down&lt;/code&gt; entry can have fresher replicas. Their replicas can have been updated after the termination of &lt;code&gt;Mnesia&lt;/code&gt; on the current node. To catch up with the latest updates, transfer a copy of the table from one of these other &quot;fresh&quot; nodes. If you are unlucky, other nodes can be down and you must wait for the table to be loaded on one of these nodes before receiving a fresh copy of the table.</source>
          <target state="translated">При запуске обратите внимание, что все таблицы, находящиеся на узлах без записи &lt;code&gt;mnesia_down&lt;/code&gt; , могут иметь более свежие реплики. Их реплики могут быть обновлены после завершения работы &lt;code&gt;Mnesia&lt;/code&gt; на текущем узле. Чтобы быть в курсе последних обновлений, перенесите копию таблицы с одного из этих &amp;laquo;свежих&amp;raquo; узлов. Если вам не повезло, другие узлы могут быть недоступны, и вы должны дождаться загрузки таблицы на одном из этих узлов, прежде чем получить новую копию таблицы.</target>
        </trans-unit>
        <trans-unit id="cebd2da32e4452b268c6c9625fdcaae6da724209" translate="yes" xml:space="preserve">
          <source>At startup, the &lt;code&gt;Mnesia&lt;/code&gt; normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of potential &lt;code&gt;mnesia_down&lt;/code&gt; entries in the log. &lt;code&gt;Nodes&lt;/code&gt; can only contain nodes where the table has a replica. If &lt;code&gt;Nodes&lt;/code&gt; is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">При запуске алгоритм нормальной загрузки таблицы &lt;code&gt;Mnesia&lt;/code&gt; игнорируется, и таблица загружается с одного из главных узлов, определенных для таблицы, независимо от потенциальных записей &lt;code&gt;mnesia_down&lt;/code&gt; в журнале. &lt;code&gt;Nodes&lt;/code&gt; могут содержать только узлы, в которых таблица имеет реплику. Если &lt;code&gt;Nodes&lt;/code&gt; пуст, механизм восстановления главного узла для конкретной таблицы сбрасывается, и при следующем перезапуске используется обычный механизм загрузки.</target>
        </trans-unit>
        <trans-unit id="a6322370642204a58e29b000b086020c58026493" translate="yes" xml:space="preserve">
          <source>At system start, Logger is configured through Kernel configuration parameters. The parameters that apply to Logger are described in section &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt;. Examples are found in section &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При запуске системы Logger настраивается с помощью параметров конфигурации ядра. Параметры, которые применяются к Регистратору, описаны в разделе &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt; . Примеры можно найти в разделе &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d12c0011c249bb23aab720fbf3331a64e7f920" translate="yes" xml:space="preserve">
          <source>At the Media Gateway Controller (MGC) side it is possible to reject a connection request (and send a message error reply to the gateway) by returning &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; or simply &lt;code&gt;error&lt;/code&gt; which generates an error descriptor with code 402 (unauthorized) and reason &quot;Connection refused by user&quot; (this is also the case for all unknown results, such as exit signals or throw).</source>
          <target state="translated">На стороне контроллера медиашлюза (MGC) можно отклонить запрос на соединение (и отправить на шлюз сообщение об ошибке), вернув &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; или просто &lt;code&gt;error&lt;/code&gt; которая генерирует дескриптор ошибки с кодом 402 (неавторизованный) и причина &amp;laquo;Соединение отклонено пользователем&amp;raquo; (это также относится ко всем неизвестным результатам, таким как сигналы выхода или выброс).</target>
        </trans-unit>
        <trans-unit id="082190436d06dd5d49208af168f795454a1d2c3e" translate="yes" xml:space="preserve">
          <source>At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against</source>
          <target state="translated">В конце матча значения захватывающих скобок-это значения с самого внешнего уровня.Если вышеприведенный шаблон совпадает с</target>
        </trans-unit>
        <trans-unit id="a0bd3386c01848e616038cd3be0a42aca1ff92e4" translate="yes" xml:space="preserve">
          <source>At the end of phase one, the user defined &lt;code&gt;is_set_ok&lt;/code&gt; functions are called for each scalar variable, and for each group of table operations.</source>
          <target state="translated">В конце первой фазы определенные пользователем функции &lt;code&gt;is_set_ok&lt;/code&gt; вызываются для каждой скалярной переменной и для каждой группы табличных операций.</target>
        </trans-unit>
        <trans-unit id="e7141009a47e03284bdfb55bb6f57dbdb2f6af74" translate="yes" xml:space="preserve">
          <source>At the end of the file the following call is made to indicate the end of the transfer:</source>
          <target state="translated">В конце файла делается следующий звонок для указания конца передачи:</target>
        </trans-unit>
        <trans-unit id="8f5e152a75003f4c0eecbf24783ff86692b5ac63" translate="yes" xml:space="preserve">
          <source>At the moment this is always an empty list as policies are not currently supported.</source>
          <target state="translated">На данный момент это всегда пустой список,так как на данный момент политики не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="ffb7455412e52bcc56b05d38e6e5253be2bc9d2d" translate="yes" xml:space="preserve">
          <source>At the other end, a server is listening on port 5678, accepts the connection, and receives the binary:</source>
          <target state="translated">На другом конце сервер прослушивает порт 5678,принимает соединение и получает двоичный файл:</target>
        </trans-unit>
        <trans-unit id="a2ee7dea7134049488781051edab25bd2f008623" translate="yes" xml:space="preserve">
          <source>At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are not part of the recursion.)</source>
          <target state="translated">На верхнем уровне первый символ совпадает,но так как он не в конце строки,первая альтернатива не удается,вторая альтернатива берется,и начинается рекурсия.Реккурсивный вызов подмаски 1 успешно совпадает со следующим символом (&quot;b&quot;).(Обратите внимание,что проверка начала и конца строки не является частью рекурсии).</target>
        </trans-unit>
        <trans-unit id="ed2220b4de1fb3635d6a43309a72686050501dc1" translate="yes" xml:space="preserve">
          <source>At this point it would make sense to create a &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt;, but in this particular example the compiler sees that there will soon be a call to a function (in this case, to &lt;code&gt;my_binary_to_list/1&lt;/code&gt; itself) that immediately will create a new match context and discard the sub binary.</source>
          <target state="translated">На этом этапе имеет смысл создать &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt; , но в этом конкретном примере компилятор видит, что скоро произойдет вызов функции (в данном случае самого &lt;code&gt;my_binary_to_list/1&lt;/code&gt; ), которая немедленно создаст новый контекст соответствия и отбросьте суб-двоичный файл.</target>
        </trans-unit>
        <trans-unit id="2a5d6ede3e3967bfd759ea91b6f59bd9213c0242" translate="yes" xml:space="preserve">
          <source>At this stage when we have a couple of &lt;code&gt;Events&lt;/code&gt;, it is time to show how it looks like in the graphical interface of &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="translated">На этом этапе, когда у нас есть пара &lt;code&gt;Events&lt;/code&gt; , пора показать, как это выглядит в графическом интерфейсе &lt;code&gt;et_viewer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="c3c309f16bf4b6076b8eb93fd32be986ed93ed91" translate="yes" xml:space="preserve">
          <source>Atom ::= - same as Erlang atoms -</source>
          <target state="translated">Атом ::=-то же самое,что и атомы Эрланга -</target>
        </trans-unit>
        <trans-unit id="51343a15868219ae0470e742ba631bc7eec26597" translate="yes" xml:space="preserve">
          <source>Atom is another data type in Erlang. Atoms start with a small letter (see &lt;code&gt;Atom&lt;/code&gt;), for example, &lt;code&gt;charles&lt;/code&gt;, &lt;code&gt;centimeter&lt;/code&gt;, and &lt;code&gt;inch&lt;/code&gt;. Atoms are simply names, nothing else. They are not like variables, which can have a value.</source>
          <target state="translated">Atom - это еще один тип данных в Erlang. Атомы начинаются с маленькой буквы (см. &lt;code&gt;Atom&lt;/code&gt; ), например, &lt;code&gt;charles&lt;/code&gt; , &lt;code&gt;centimeter&lt;/code&gt; и &lt;code&gt;inch&lt;/code&gt; . Атомы - это просто имена, ничего больше. Они не похожи на переменные, которые могут иметь значение.</target>
        </trans-unit>
        <trans-unit id="7195f879141a5a8ba030248689c692d5148b0ee2" translate="yes" xml:space="preserve">
          <source>AtomConst ::= Application | Module | Release</source>
          <target state="translated">AtomConst ::=Приложение | Модуль | Релиз</target>
        </trans-unit>
        <trans-unit id="1c66839560fb43e9f121274907f35e59ef182189" translate="yes" xml:space="preserve">
          <source>Atomic Memory Operations and the VM</source>
          <target state="translated">Операции с атомной памятью и VM</target>
        </trans-unit>
        <trans-unit id="285aeb96eeef706de92b804eae05d172e8e0a60b" translate="yes" xml:space="preserve">
          <source>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both \d+ and \d+? are prepared to adjust the number of digits they match to make the remaining pattern match, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; can only match an entire sequence of digits.</source>
          <target state="translated">Подшаблоны атомарной группировки не захватывают подшаблоны. Простые случаи, такие как приведенный выше пример, можно рассматривать как максимальное повторение, которое должно поглотить все, что можно. Итак, а как \ d + и \ d +? готовы настроить количество совпадающих цифр, чтобы оставшееся совпадение с шаблоном соответствовало, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; может соответствовать только всей последовательности цифр.</target>
        </trans-unit>
        <trans-unit id="70263cc27057f40aecb08445d5e4246aa30c686a" translate="yes" xml:space="preserve">
          <source>Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &quot;possessive quantifier&quot; can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as</source>
          <target state="translated">Атомные группы в целом могут содержать любые сложные подмаски и могут быть вложены.Однако,когда подмаскадка для атомной группы является всего лишь единичным повторяющимся элементом,как в примере выше,может быть использована более простая нотация,называемая &quot;собственническим квантификатором&quot;.Она состоит из лишнего символа +,следующего за квантификатором.Используя эту нотацию,предыдущий пример можно переписать как</target>
        </trans-unit>
        <trans-unit id="3d74d1749d4da9ae8e4ba38276cc8935928009a4" translate="yes" xml:space="preserve">
          <source>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction.</source>
          <target state="translated">Атомные операции.Ряд табличных манипуляционных операций можно сгруппировать в одну атомную транзакцию.</target>
        </trans-unit>
        <trans-unit id="e24ad40d30afa103adc1e00c3958d38ebb6700ca" translate="yes" xml:space="preserve">
          <source>Atomically changes the registered name &lt;code&gt;Name&lt;/code&gt; on all nodes to refer to &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Атомно изменяет зарегистрированное имя &lt;code&gt;Name&lt;/code&gt; на всех узлах, чтобы оно ссылалось на &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee048f7e55224c5c36ed6495f528ec9c74109599" translate="yes" xml:space="preserve">
          <source>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function &lt;code&gt;raise/2&lt;/code&gt;, shown in the previous example, writes one record only. The function &lt;code&gt;insert_emp/3&lt;/code&gt;, shown in the program listing in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, writes the record &lt;code&gt;employee&lt;/code&gt; as well as employee relations, such as &lt;code&gt;at_dep&lt;/code&gt; and &lt;code&gt;in_proj&lt;/code&gt;, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</source>
          <target state="translated">Атомарность важна, когда необходимо атомарно записать более одной записи в одной транзакции. Функция &lt;code&gt;raise/2&lt;/code&gt; , показанная в предыдущем примере, записывает только одну запись. Функция &lt;code&gt;insert_emp/3&lt;/code&gt; , показанная в листинге программы в &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; , записывает &lt;code&gt;employee&lt;/code&gt; записи, а также отношения сотрудников, такие как &lt;code&gt;at_dep&lt;/code&gt; и &lt;code&gt;in_proj&lt;/code&gt; , в базу данных. Если последний код выполняется внутри транзакции, обработчик транзакции гарантирует, что транзакция либо завершится успешно, либо не завершится вовсе.</target>
        </trans-unit>
        <trans-unit id="9e7bf26b3574db121c0f9c2d5135066a290bba9b" translate="yes" xml:space="preserve">
          <source>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</source>
          <target state="translated">Атомарность означает,что изменения в базе данных,которые выполняются транзакцией,вступают в силу на всех задействованных узлах или ни на одном из них.То есть,транзакция либо полностью завершается успехом,либо терпит неудачу.</target>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="8b4ce0020874da6c44e911622f2debe1461e0f0d" translate="yes" xml:space="preserve">
          <source>Atoms and variables can use all Latin-1 letters.</source>
          <target state="translated">Атомы и переменные могут использовать все латинские 1 букву.</target>
        </trans-unit>
        <trans-unit id="8e89bc7b897d5b27ce2d498db94d099bf846c461" translate="yes" xml:space="preserve">
          <source>Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached.</source>
          <target state="translated">Атомы не собирают мусор.Как только атом создан,он никогда не удаляется.Эмулятор прекращает работу,если достигнут лимит на количество атомов (по умолчанию 1,048,576).</target>
        </trans-unit>
        <trans-unit id="53953ef0095a671ea4007a14634a7ef6dcdd0975" translate="yes" xml:space="preserve">
          <source>Atoms starting with &lt;code&gt;@&lt;/code&gt;, for example &lt;code&gt;'@foo'&lt;/code&gt; or &lt;code&gt;'@Foo'&lt;/code&gt;</source>
          <target state="translated">Атомы, начинающиеся с &lt;code&gt;@&lt;/code&gt; , например &lt;code&gt;'@foo'&lt;/code&gt; или &lt;code&gt;'@Foo'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1f2e1b1dd67aa033d9dce573a905b7f9461d62" translate="yes" xml:space="preserve">
          <source>Attaches comments to a syntax tree. The result is a pair &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; where &lt;code&gt;NewTree&lt;/code&gt; is the given &lt;code&gt;Tree&lt;/code&gt; where comments from the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places. &lt;code&gt;Remainder&lt;/code&gt; is the list of entries in &lt;code&gt;Comments&lt;/code&gt; which have not been inserted, because their line numbers are greater than those of any node in the tree. The entries in &lt;code&gt;Comments&lt;/code&gt; are inserted in order; if two comments become attached to the same node, they will appear in the same order in the program text.</source>
          <target state="translated">Добавляет комментарии к синтаксическому дереву. Результатом является пара &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; где &lt;code&gt;NewTree&lt;/code&gt; - это заданное &lt;code&gt;Tree&lt;/code&gt; котором комментарии из списка &lt;code&gt;Comments&lt;/code&gt; были прикреплены в нужных местах. &lt;code&gt;Remainder&lt;/code&gt; - это список записей в &lt;code&gt;Comments&lt;/code&gt; которые не были вставлены, потому что их номера строк больше, чем у любого узла в дереве. Записи в &lt;code&gt;Comments&lt;/code&gt; вставляются по порядку; если два комментария будут прикреплены к одному и тому же узлу, они появятся в тексте программы в том же порядке.</target>
        </trans-unit>
        <trans-unit id="d2ceee4cae7cbba986c24f620add3c4dd9b79139" translate="yes" xml:space="preserve">
          <source>Attaches comments to the syntax tree/trees representing a program. The given &lt;code&gt;Forms&lt;/code&gt; should be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. The syntax trees must contain valid position information (for details, see &lt;code&gt;recomment_tree/2&lt;/code&gt;). The result is a corresponding syntax tree of type &lt;code&gt;form_list&lt;/code&gt; in which all comments in the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places.</source>
          <target state="translated">Добавляет комментарии к синтаксическому дереву / деревьям, представляющим программу. Данные &lt;code&gt;Forms&lt;/code&gt; должны быть единым синтаксическим деревом типа &lt;code&gt;form_list&lt;/code&gt; или списком синтаксических деревьев, представляющих &amp;laquo;программные формы&amp;raquo;. Деревья синтаксиса должны содержать действительную информацию о положении (подробности см. В файле &lt;code&gt;recomment_tree/2&lt;/code&gt; ). Результатом является соответствующее синтаксическое дерево типа &lt;code&gt;form_list&lt;/code&gt; , в котором все комментарии в списке &lt;code&gt;Comments&lt;/code&gt; были прикреплены в нужных местах.</target>
        </trans-unit>
        <trans-unit id="08f3c18f1ef82b85d187f359be8053ba60fcff3a" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. An Attach Process window is opened for the process.</source>
          <target state="translated">Присоединяется к отлаживаемому процессу &lt;code&gt;Pid&lt;/code&gt; . Для процесса открывается окно Присоединить процесс.</target>
        </trans-unit>
        <trans-unit id="e858ba60db5ffa465fde04178472518163ea425c" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. The interpreter calls &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (and ignores the result).</source>
          <target state="translated">Присоединяется к отлаживаемому процессу &lt;code&gt;Pid&lt;/code&gt; . Интерпретатор вызывает &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (и игнорирует результат).</target>
        </trans-unit>
        <trans-unit id="dc33862cfcafa306527c136f22aeb55fbb46ae26" translate="yes" xml:space="preserve">
          <source>Attaches to the process and open an &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Присоединяется к процессу и открывает &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a27b2860df5ad784c2a072eec792bd3ddbfbbcf2" translate="yes" xml:space="preserve">
          <source>Attempt to delete the current directory. On some platforms, &lt;code&gt;eacces&lt;/code&gt; is returned instead.</source>
          <target state="translated">Попытка удалить текущий каталог. На некоторых платформах вместо этого возвращается &lt;code&gt;eacces&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd873defa6a2d59737d4e84f136645c52891193" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can also be used for turning on warnings. For example, if a module has been fixed regarding unmatched returns, adding the following line can help in assuring that no new unmatched return warnings are introduced:</source>
          <target state="translated">Атрибут &lt;code&gt;-dialyzer()&lt;/code&gt; также можно использовать для включения предупреждений. Например, если модуль был исправлен в отношении несопоставленных возвратов, добавление следующей строки может помочь гарантировать, что не появятся новые предупреждения о несоответствующих возвратах:</target>
        </trans-unit>
        <trans-unit id="94a2d033077fb7d4c11be4d28e975e8f7fa67d5d" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can be used for turning off warnings in a module by specifying functions or warning options. For example, to turn off all warnings for the function &lt;code&gt;f/0&lt;/code&gt;, include the following line:</source>
          <target state="translated">Атрибут &lt;code&gt;-dialyzer()&lt;/code&gt; может использоваться для отключения предупреждений в модуле путем указания функций или параметров предупреждений. Например, чтобы отключить все предупреждения для функции &lt;code&gt;f/0&lt;/code&gt; , добавьте следующую строку:</target>
        </trans-unit>
        <trans-unit id="3bb46baccc6ddbcfec9893a911a5598494b5fa7f" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; is allowed after function declarations. Lists of warning options or functions are allowed:</source>
          <target state="translated">Атрибут &lt;code&gt;-dialyzer()&lt;/code&gt; разрешен после объявления функции. Списки вариантов предупреждений или разрешенных функций:</target>
        </trans-unit>
        <trans-unit id="20497f389e60747b76a9f4c282fe115ff9e65b81" translate="yes" xml:space="preserve">
          <source>Attribute = {atom(), term()}</source>
          <target state="translated">Атрибут={atom(),term()}</target>
        </trans-unit>
        <trans-unit id="56cec620065c043a2c53d113a84f30cf04a24bfc" translate="yes" xml:space="preserve">
          <source>Attributes = [{Name, Value}| #xmlAttribute{}]</source>
          <target state="translated">Атрибуты=[{Имя,значение}| #xmlAttribute{}]</target>
        </trans-unit>
        <trans-unit id="8196898f60a411611bff755ce53bcb927eed9bf5" translate="yes" xml:space="preserve">
          <source>Audit Trail Logging</source>
          <target state="translated">Регистрация контрольных журналов</target>
        </trans-unit>
        <trans-unit id="e7a0dac799c2ac1aee5c36d21a89de6463f1070c" translate="yes" xml:space="preserve">
          <source>Auth-Application-Id AVP</source>
          <target state="translated">Авто-приложение-Ид AVP</target>
        </trans-unit>
        <trans-unit id="6f57677bc7cc52df8c3d26defd5359054852e0c9" translate="yes" xml:space="preserve">
          <source>Auth-Grace-Period AVP</source>
          <target state="translated">Auth-Grace-Period AVP</target>
        </trans-unit>
        <trans-unit id="ffad30279d0dbdebdba0995b72cf095104751ce5" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP</source>
          <target state="translated">Автоматические вопросы-тип AVP</target>
        </trans-unit>
        <trans-unit id="bab9dd08fa19bdf6f1b4cf6e9f78668ae505c80e" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP Values</source>
          <target state="translated">Автоматический запрос-Тип AVP Значения</target>
        </trans-unit>
        <trans-unit id="d8ff104e64da7ae152dbd68cb8bb5ac85c8606c8" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP</source>
          <target state="translated">Авт-Сессия-Государство АВП</target>
        </trans-unit>
        <trans-unit id="52aa2478028e9ddcf53894d8996729bb4145d0b1" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP Values</source>
          <target state="translated">Авто-сессия-Государство Значения AVP</target>
        </trans-unit>
        <trans-unit id="b01542a7f0aa1f0864e6a230526030dbd833afdd" translate="yes" xml:space="preserve">
          <source>Authenticate the connection using simple authentication.</source>
          <target state="translated">Аутентифицируйте соединение,используя простую аутентификацию.</target>
        </trans-unit>
        <trans-unit id="efdb86330764c8fbe68da0d4b6819ef23c162680" translate="yes" xml:space="preserve">
          <source>Authenticating the integrity of the handshake messages.</source>
          <target state="translated">Подтверждение целостности сообщений о рукопожатии.</target>
        </trans-unit>
        <trans-unit id="7a30fd25c7a3f93a7b30740a0a98229a0638bb08" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt;net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="translated">Аутентификация (выполняется &lt;code&gt;net_kernel(3)&lt;/code&gt; ) (3)</target>
        </trans-unit>
        <trans-unit id="dc6b01190c75db5a643cf18f6685ef326b9bb4bb" translate="yes" xml:space="preserve">
          <source>Authentication determines which nodes are allowed to communicate with each other. In a network of different Erlang nodes, it is built into the system at the lowest possible level. Each node has its own &lt;strong&gt;magic cookie&lt;/strong&gt;, which is an Erlang atom.</source>
          <target state="translated">Аутентификация определяет, каким узлам разрешено общаться друг с другом. В сети из разных узлов Erlang он встроен в систему на самом низком уровне. Каждый узел имеет свой собственный &lt;strong&gt;волшебный файл cookie&lt;/strong&gt; , который представляет собой атом Эрланга.</target>
        </trans-unit>
        <trans-unit id="b69c9c9364edcba7a03ffefeefa382cf82287356" translate="yes" xml:space="preserve">
          <source>Authentication of the peer is done by public key path validation as defined in RFC 3280. This means basically the following:</source>
          <target state="translated">Аутентификация равный-равному осуществляется путем проверки пути к публичному ключу,как определено в RFC 3280.В основном это означает следующее:</target>
        </trans-unit>
        <trans-unit id="65b45c1a860b3348b9833c0a96364a1acd14c2b7" translate="yes" xml:space="preserve">
          <source>Authentication/access checks.</source>
          <target state="translated">Проверка подлинности/доступа.</target>
        </trans-unit>
        <trans-unit id="1ba9c0e85dda9702580d19335be06fa7a8c504cb" translate="yes" xml:space="preserve">
          <source>Authorization Session State Machine</source>
          <target state="translated">Авторизационный сеанс Государственная машина</target>
        </trans-unit>
        <trans-unit id="cd708bd6499f399dc5b86474d073a1c2f25376ad" translate="yes" xml:space="preserve">
          <source>Authorization and accounting AVPs are defined in provided dictionaries. Their proper use is the responsibility of the user.</source>
          <target state="translated">Авторизация и учет AVP определяются в предоставляемых словарях.Ответственность за их правильное использование несет пользователь.</target>
        </trans-unit>
        <trans-unit id="f163341ede12f9adebdea0335c91c64ca9f864cb" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user.</source>
          <target state="translated">Ответственность за авторизацию несет пользователь.</target>
        </trans-unit>
        <trans-unit id="50b27cabe4dbb1d4ad17bfe9e56741a4affc2eea" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">Авторизация является обязанностью пользователя:диаметр не реализует эту государственную машину.</target>
        </trans-unit>
        <trans-unit id="30ed2a3e728e1f003c2a2c8e103841be8b0ec854" translate="yes" xml:space="preserve">
          <source>Authorization-Lifetime AVP</source>
          <target state="translated">Авторизация-AVP на протяжении всей жизни</target>
        </trans-unit>
        <trans-unit id="edd7b5046b035f96ef22223b25da57cd6e60a20a" translate="yes" xml:space="preserve">
          <source>Authorized keys - OpenSSH format looks as follows:</source>
          <target state="translated">Авторизованные ключи-Формат OpenSSH выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a574cde3f8131fcb2c5ef5b3ac87763f839e4628" translate="yes" xml:space="preserve">
          <source>Auto-imported BIFs are listed without module prefix. BIFs listed with module prefix are not auto-imported.</source>
          <target state="translated">Автоматически импортируемые BIF-файлы перечислены без префикса модуля.BIF-файлы,перечисленные с префиксом модуля,не импортируются автоматически.</target>
        </trans-unit>
        <trans-unit id="c5883a7e0cca29e11fe6124ccc75bacf71f8b9f1" translate="yes" xml:space="preserve">
          <source>Automated execution of test suites (sets of test cases)</source>
          <target state="translated">Автоматизированное выполнение тестовых комплектов (наборов тестовых корпусов)</target>
        </trans-unit>
        <trans-unit id="d436c113d37a4bf9ab8a69c9c589f736a5417312" translate="yes" xml:space="preserve">
          <source>Automatic compilation of test suites (and help modules)</source>
          <target state="translated">Автоматическая компиляция наборов тестов (и справочных модулей)</target>
        </trans-unit>
        <trans-unit id="fccc42c97a2ffc422d0e26337a4e4d5dff20a9b3" translate="yes" xml:space="preserve">
          <source>Automatic send transaction ack when the transaction reply has been received (see &lt;code&gt;trans_ack&lt;/code&gt; below).</source>
          <target state="translated">&lt;code&gt;trans_ack&lt;/code&gt; автоматической отправки транзакции после получения ответа на транзакцию (см. Trans_ack ниже).</target>
        </trans-unit>
        <trans-unit id="ca478c0ab639849e3541da90cb17a860b5490d08" translate="yes" xml:space="preserve">
          <source>Automatic send transaction pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">Автоматическая отправка транзакции в ожидании,если таймер истекает до отправки ответа на транзакцию.Этот таймер также называется таймером предварительного ответа.</target>
        </trans-unit>
        <trans-unit id="93da85ea44d26c2624d1e105b7f890bc46bd09ba" translate="yes" xml:space="preserve">
          <source>Automatic state enter calls</source>
          <target state="translated">Автоматические входные вызовы состояния</target>
        </trans-unit>
        <trans-unit id="2a89768431c505706353574d66358c32a869dccc" translate="yes" xml:space="preserve">
          <source>Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">Автоматическое преобразование типов, вероятно, делает эти изменения необходимыми только для драйвера, размер которого превышает 32 бита.</target>
        </trans-unit>
        <trans-unit id="3ef94894ba2f4eb73cf0fd7bdecec218163555bf" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;HandlerId&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">Автоматически вставляется Регистратором. Значение совпадает с &lt;code&gt;HandlerId&lt;/code&gt; указанным при добавлении обработчика, и его нельзя изменить.</target>
        </trans-unit>
        <trans-unit id="77c6bd373dea25df6392c697b76ebb783fd68b3e" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;Module&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">Автоматически вставляется Регистратором. Значение такое же, как у &lt;code&gt;Module&lt;/code&gt; указанного при добавлении обработчика, и его нельзя изменить.</target>
        </trans-unit>
        <trans-unit id="32d8c661feaa1a96e94bb053c82356a83532060b" translate="yes" xml:space="preserve">
          <source>Automatically send pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">Автоматически отправлять в ожидании,если таймер истекает до отправки ответа на транзакцию.Этот таймер также называется таймером предварительного ответа.</target>
        </trans-unit>
        <trans-unit id="18da0ae80b2a3d06e9335371a77bc11e953c941d" translate="yes" xml:space="preserve">
          <source>Autoresume</source>
          <target state="translated">Autoresume</target>
        </trans-unit>
        <trans-unit id="440311567fa2e46e6495460ee5e7f6ca1160021b" translate="yes" xml:space="preserve">
          <source>Available only in some POSIX systems, this call results in a call to &lt;code&gt;fsync()&lt;/code&gt;, or has no effect in systems not providing the &lt;code&gt;fdatasync()&lt;/code&gt; syscall.</source>
          <target state="translated">Доступный только в некоторых системах POSIX, этот вызов приводит к вызову &lt;code&gt;fsync()&lt;/code&gt; или не действует в системах, не предоставляющих системный вызов &lt;code&gt;fdatasync()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5325c58f3190f03981f3d4b6e263a0fcae8b5bc" translate="yes" xml:space="preserve">
          <source>Available options are:</source>
          <target state="translated">Доступны различные варианты:</target>
        </trans-unit>
        <trans-unit id="057b4b33c8569c09b413019743ff85bf2e11c330" translate="yes" xml:space="preserve">
          <source>Available options:</source>
          <target state="translated">Доступные варианты:</target>
        </trans-unit>
        <trans-unit id="4e9d1b7f151f31fb76e5b9ef9857c7c1cae6dcf2" translate="yes" xml:space="preserve">
          <source>Available properties are the same as the start options of the server, but the properties &lt;code&gt;bind_address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; cannot be changed.</source>
          <target state="translated">Доступные свойства такие же, как параметры запуска сервера, но свойства &lt;code&gt;bind_address&lt;/code&gt; и &lt;code&gt;port&lt;/code&gt; не могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="ef104ec434506c3596f5487f13a01379d4ba6bd2" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;'receive'&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступно через &lt;code&gt;erlang:trace/3&lt;/code&gt; с флагом трассировки &lt;code&gt;'receive'&lt;/code&gt; и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассировки.</target>
        </trans-unit>
        <trans-unit id="27f7db47a04206f9b18980fb6fca2934f7e7d231" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступно через &lt;code&gt;erlang:trace/3&lt;/code&gt; с &lt;code&gt;call&lt;/code&gt; флага трассировки и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассировки.</target>
        </trans-unit>
        <trans-unit id="ec9c72570d3ed2f9817e1e27636799b0c17600b7" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;return_to&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступно через &lt;code&gt;erlang:trace/3&lt;/code&gt; с &lt;code&gt;call&lt;/code&gt; флага трассировки или &lt;code&gt;return_to&lt;/code&gt; и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассировки.</target>
        </trans-unit>
        <trans-unit id="19369e2b69d2d29bcf7d2b110bd632c0497eadc1" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;garbage_collection&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступно через &lt;code&gt;erlang:trace/3&lt;/code&gt; с флагом трассировки &lt;code&gt;garbage_collection&lt;/code&gt; и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассировки.</target>
        </trans-unit>
        <trans-unit id="0b14892085d0235611acf16621043bf554272c4b" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступно через &lt;code&gt;erlang:trace/3&lt;/code&gt; с &lt;code&gt;ports&lt;/code&gt; флага трассировки и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассировки.</target>
        </trans-unit>
        <trans-unit id="98fc651851a4575e9edd1b04d22bca4d2ff1533e" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;procs&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступный через &lt;code&gt;erlang:trace/3&lt;/code&gt; с флагом трассировки &lt;code&gt;procs&lt;/code&gt; и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассирующей.</target>
        </trans-unit>
        <trans-unit id="3f46a50dcc99ab759ab69e8cdf416560bd6713f8" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступно через &lt;code&gt;erlang:trace/3&lt;/code&gt; с &lt;code&gt;running&lt;/code&gt; флагом трассировки и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассировки.</target>
        </trans-unit>
        <trans-unit id="04747a5c4337891e1a74cc42657f396a199e1343" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Доступно через &lt;code&gt;erlang:trace/3&lt;/code&gt; с &lt;code&gt;send&lt;/code&gt; флага трассировки и &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; в качестве модуля трассировки.</target>
        </trans-unit>
        <trans-unit id="0979e25ae12ecf75e6954405c51afc218144f433" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, received by the socket.</source>
          <target state="translated">Среднее отклонение размера пакета в байтах,полученного сокета.</target>
        </trans-unit>
        <trans-unit id="24a6380cb9d560f221f5bab0ac3ac216888c3989" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, sent from the socket.</source>
          <target state="translated">Среднее отклонение размера пакета в байтах,отправляемого из сокета.</target>
        </trans-unit>
        <trans-unit id="ba5da32502768a08b71f47f54787f1a18d984da2" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, received by the socket.</source>
          <target state="translated">Средний размер пакетов в байтах,полученных сокетами.</target>
        </trans-unit>
        <trans-unit id="a548c980c935b270267b69573bc6d8a367a0ccd7" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, sent from the socket.</source>
          <target state="translated">Средний размер пакетов в байтах,отправляемых из сокета.</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="7666ec90c7fb3e6a7737d1ce78d04e16a63f834f" translate="yes" xml:space="preserve">
          <source>Avoid calling this on the root keys, as it can be slow.</source>
          <target state="translated">Избегайте называть это на корневых клавишах,так как это может быть медленным.</target>
        </trans-unit>
        <trans-unit id="8eebcbcc17ab43565fe594806f1d03745ee4ec86" translate="yes" xml:space="preserve">
          <source>Avoid mixing multiple &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; with driver reload requests.</source>
          <target state="translated">Избегайте смешивания нескольких &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; с запросами на перезагрузку драйвера.</target>
        </trans-unit>
        <trans-unit id="98289f5c4b0096f8495ef524df96672c88d3f383" translate="yes" xml:space="preserve">
          <source>Avoid the following values of &lt;code&gt;ResourceId&lt;/code&gt;, otherwise Erlang/OTP does not work properly:</source>
          <target state="translated">Избегайте следующих значений &lt;code&gt;ResourceId&lt;/code&gt; , иначе Erlang / OTP не будет работать должным образом:</target>
        </trans-unit>
        <trans-unit id="2ebd07d23bcd301e7132f885cb8e225fce4de1c1" translate="yes" xml:space="preserve">
          <source>Avoiding common mistakes:</source>
          <target state="translated">Избегая обычных ошибок:</target>
        </trans-unit>
        <trans-unit id="8677c671e8bfb9480004f697032e107bf2d89ade" translate="yes" xml:space="preserve">
          <source>B/SFR</source>
          <target state="translated">B/SFR</target>
        </trans-unit>
        <trans-unit id="d6a2b7b76ae3b1331d97630c6fbdfda1e2e20faf" translate="yes" xml:space="preserve">
          <source>BEAM is a register-based virtual machine. It has 1024 virtual registers that are used for holding temporary values and for passing arguments when calling functions. Variables that need to survive a function call are saved to the stack.</source>
          <target state="translated">BEAM-это виртуальная машина на основе реестра.Она имеет 1024 виртуальных регистра,которые используются для хранения временных значений и передачи аргументов при вызове функций.Переменные,которые должны выдержать вызов функции,сохраняются в стеке.</target>
        </trans-unit>
        <trans-unit id="4e374de82335c7a8d86c8e4d74077c948da138e0" translate="yes" xml:space="preserve">
          <source>BEAM is a threaded-code interpreter. Each instruction is word pointing directly to executable C-code, making instruction dispatching very fast.</source>
          <target state="translated">BEAM-это поточный интерпретатор кода.Каждая команда представляет собой слово,указывающее непосредственно на исполняемый C-код,что делает отправку команд очень быстрой.</target>
        </trans-unit>
        <trans-unit id="7efce4656362191b2f6893e9594afff40994fed8" translate="yes" xml:space="preserve">
          <source>BIFs are functions that for some reason are built-in to the Erlang virtual machine. BIFs often implement functionality that is impossible or is too inefficient to implement in Erlang. Some BIFs can be called using the function name only but they are by default belonging to the &lt;code&gt;erlang&lt;/code&gt; module. For example, the call to the BIF &lt;code&gt;trunc&lt;/code&gt; below is equivalent to a call to &lt;code&gt;erlang:trunc&lt;/code&gt;.</source>
          <target state="translated">BIF - это функции, которые по какой-то причине встроены в виртуальную машину Erlang. BIF часто реализуют функции, которые невозможно или слишком неэффективно реализовать в Erlang. Некоторые BIF-файлы можно вызывать только с использованием имени функции, но по умолчанию они принадлежат модулю &lt;code&gt;erlang&lt;/code&gt; . Например, приведенный ниже вызов &lt;code&gt;trunc&lt;/code&gt; BIF эквивалентен вызову &lt;code&gt;erlang:trunc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="890c2ec47feac80bf8654b893be74f130c02facf" translate="yes" xml:space="preserve">
          <source>BIFs are implemented in C code in the runtime system. BIFs do things that are difficult or impossible to implement in Erlang. Most of the BIFs belong to the module &lt;code&gt;erlang&lt;/code&gt; but there are also BIFs belonging to a few other modules, for example &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;ets&lt;/code&gt;.</source>
          <target state="translated">BIF реализованы в коде C в системе времени выполнения. BIF делают вещи, которые сложно или невозможно реализовать в Erlang. Большинство BIFS принадлежит к модулю &lt;code&gt;erlang&lt;/code&gt; , но есть также BIFS , принадлежащие к нескольким другим модулям, например , &lt;code&gt;lists&lt;/code&gt; и &lt;code&gt;ets&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42278b69b892fd26dcff3099719503a85d2ed515" translate="yes" xml:space="preserve">
          <source>BIFs can fail for various reasons. All BIFs fail with reason &lt;code&gt;badarg&lt;/code&gt; if they are called with arguments of an incorrect type. The other reasons are described in the description of each individual BIF.</source>
          <target state="translated">BIF могут выйти из строя по разным причинам. Все BIF не работают по причине &lt;code&gt;badarg&lt;/code&gt; , если они вызываются с аргументами неправильного типа. Остальные причины описаны в описании каждого отдельного BIF.</target>
        </trans-unit>
        <trans-unit id="0971b2037c9ec621fb794e414dbe4e3e6e9ea234" translate="yes" xml:space="preserve">
          <source>Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern 2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different:</source>
          <target state="translated">Возвращаясь на верхний уровень,следующий символ (&quot;c&quot;)сравнивается с тем,какой подмакетке 2 соответствовала подмакетка,которая была &quot;a&quot;.Это не удается.Так как рекурсия рассматривается как атомная группа,то теперь нет точек обратного отсчета,и поэтому все совпадение проваливается.(Perl может теперь снова войти в рекурсию и попробовать вторую альтернативу.)Однако,если шаблон записан с альтернативами в другом порядке,все будет по-другому:</target>
        </trans-unit>
        <trans-unit id="48a05ca6fa60802ff208e26ea9e34464ac28a529" translate="yes" xml:space="preserve">
          <source>Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group.</source>
          <target state="translated">Обратные ссылки этого типа приводят к тому,что группа,на которую они ссылаются,рассматривается как атомная группа.После того,как вся группа была сопоставлена,последующий сбой в сопоставлении не может привести к обратному просмотру в центр группы.</target>
        </trans-unit>
        <trans-unit id="ab429c0e231fa759e013662e3a14521ce2c5b79b" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt;.</source>
          <target state="translated">Бэкэнд-функции, используемые &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4aa3add341382a466d659f858fca56aef2ce0f58" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt;.</source>
          <target state="translated">Внутренние функции, используемые &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="84e3bb9dd16cb2ba0f02d7245545feda5e3cabcb" translate="yes" xml:space="preserve">
          <source>Backspace.</source>
          <target state="translated">Backspace.</target>
        </trans-unit>
        <trans-unit id="7fc5d71b3eae328beb908064e6dec5ed2151041f" translate="yes" xml:space="preserve">
          <source>Backup and restore of C node state to and from &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">Резервное копирование и восстановление состояния узла C в &lt;code&gt;Mnesia&lt;/code&gt; и обратно</target>
        </trans-unit>
        <trans-unit id="643aeb5ad5e07a8a0aedfaec9f291b8b2d8eb1e8" translate="yes" xml:space="preserve">
          <source>Backup operation are performed with the following functions:</source>
          <target state="translated">Операция резервного копирования выполняется со следующими функциями:</target>
        </trans-unit>
        <trans-unit id="a1b1261f879477741073cc5643737c50cece295a" translate="yes" xml:space="preserve">
          <source>Backup persistent data handled by the manager.</source>
          <target state="translated">Резервное копирование постоянных данных,обрабатываемых менеджером.</target>
        </trans-unit>
        <trans-unit id="48159fb2ea43e7a90492b5cc62df25d733040b1d" translate="yes" xml:space="preserve">
          <source>Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).</source>
          <target state="translated">Резервное копирование постоянных/постоянных данных,обрабатываемых агентом (таких как local-db,mib-data и vacm).</target>
        </trans-unit>
        <trans-unit id="76b2ca97753e81a47e64d73e23600b3684a357e4" translate="yes" xml:space="preserve">
          <source>Backup, restore, fallback, and disaster recovery</source>
          <target state="translated">Резервное копирование,восстановление,резервное копирование и аварийное восстановление.</target>
        </trans-unit>
        <trans-unit id="8afb5bf327667dc553b8e9a32ac34a080d815b3b" translate="yes" xml:space="preserve">
          <source>BackupDir cannot be identical to DbDir.</source>
          <target state="translated">BackupDir не может быть идентичен DbDir.</target>
        </trans-unit>
        <trans-unit id="f132fe31e8d713406288c3f7dcb9dbc8378cfdf5" translate="yes" xml:space="preserve">
          <source>Backward character</source>
          <target state="translated">отсталый характер</target>
        </trans-unit>
        <trans-unit id="82c36d6a4f52a2dc6589f184f22fdf4b95e97b1c" translate="yes" xml:space="preserve">
          <source>Backward kill line</source>
          <target state="translated">обратная линия убийств</target>
        </trans-unit>
        <trans-unit id="5be769b9776675c14c24d6f30ed3fba3e401a997" translate="yes" xml:space="preserve">
          <source>Backward kill word</source>
          <target state="translated">Обратное слово убийства</target>
        </trans-unit>
        <trans-unit id="c0b7a7d6f9015db486c407e9f3cba9dc8dea0ff8" translate="yes" xml:space="preserve">
          <source>Backward word</source>
          <target state="translated">обратное слово</target>
        </trans-unit>
        <trans-unit id="1161e058ccd842cdd5e5fe2efd102fbd9ed43bbd" translate="yes" xml:space="preserve">
          <source>Bad argument in an arithmetic expression.</source>
          <target state="translated">Плохой аргумент в арифметическом выражении.</target>
        </trans-unit>
        <trans-unit id="af4ade1fd757cc8bcb7e76a2f6d37f1ec5bbb7b5" translate="yes" xml:space="preserve">
          <source>Bad argument.</source>
          <target state="translated">Плохой аргумент.</target>
        </trans-unit>
        <trans-unit id="c4cf9343231b13c7b7056a157910cd49cc8ff14e" translate="yes" xml:space="preserve">
          <source>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</source>
          <target state="translated">Плохой аргумент.Аргумент имеет неверный тип данных или неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="3401e9b8481ac17e3759a0b06770cb6fc7bbc79c" translate="yes" xml:space="preserve">
          <source>Bad input arguments to &lt;code&gt;open_port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open_port&lt;/code&gt; входные аргументы для open_port .</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="26e5990472188146a21fbe9216d5e35fd4688af2" translate="yes" xml:space="preserve">
          <source>Base Protocol Command AVP Table</source>
          <target state="translated">Команда базового протокола Таблица AVP</target>
        </trans-unit>
        <trans-unit id="d9e2287d49a0defabf83f04683cfd099fe9d2461" translate="yes" xml:space="preserve">
          <source>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called &lt;strong&gt;release handling&lt;/strong&gt;.</source>
          <target state="translated">На основе этой функции SASL-приложение OTP обеспечивает основу для обновления и понижения между различными версиями всего выпуска во время выполнения. Это называется &lt;strong&gt;обработкой релиза&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="37e7613ad8170257c16610a53d06cfb1a6379742" translate="yes" xml:space="preserve">
          <source>Basic AVP Data Formats</source>
          <target state="translated">Основные форматы данных AVP</target>
        </trans-unit>
        <trans-unit id="6b9ebfc825400dcd8efd5ccd3ed7166c57bc3280" translate="yes" xml:space="preserve">
          <source>Basic Encoding Rules (BER)</source>
          <target state="translated">Основные правила кодирования (BER)</target>
        </trans-unit>
        <trans-unit id="60289c0d7f3cdae9e1d8eee79fef52de4c163a03" translate="yes" xml:space="preserve">
          <source>Basic knowledge of Emacs and Erlang/OTP.</source>
          <target state="translated">Базовые знания Emacs и Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="9dd9d44759000b74a8ffb28eb7a9b5d4bda605bf" translate="yes" xml:space="preserve">
          <source>Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;, adding transport capability using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; and sending Diameter requests and receiving Diameter answers with &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;. Incoming Diameter requests are communicated as callbacks to a &lt;code&gt;diameter_app(3)&lt;/code&gt; callback modules as specified in the service configuration.</source>
          <target state="translated">Базовое использование состоит из создания представления локально реализованного узла Diameter и его возможностей с помощью &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; , добавления транспортных возможностей с помощью &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; , отправки запросов Diameter и получения ответов Diameter с помощью &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; . Входящие запросы Diameter передаются в виде обратных вызовов модулям обратного вызова Diameter_app &lt;code&gt;diameter_app(3)&lt;/code&gt; как указано в конфигурации службы.</target>
        </trans-unit>
        <trans-unit id="d03e3070f8930ea991974fa59117d8692bbcffdd" translate="yes" xml:space="preserve">
          <source>Basically the same as UTF-32, but without some Unicode semantics, defined by IEEE, and has little use as a separate encoding standard. For all normal (and possibly abnormal) use, UTF-32 and UCS-4 are interchangeable.</source>
          <target state="translated">В основном то же самое,что и UTF-32,но без некоторой семантики Юникода,определенной IEEE,и мало используется в качестве отдельного стандарта кодирования.При нормальном (и,возможно,ненормальном)использовании UTF-32 и UCS-4 взаимозаменяемы.</target>
        </trans-unit>
        <trans-unit id="7299a57060c9f81f94931f5581972334cd31d5c2" translate="yes" xml:space="preserve">
          <source>Basically, the &lt;code&gt;etags&lt;/code&gt; utility is ran using the following form:</source>
          <target state="translated">В основном, &lt;code&gt;etags&lt;/code&gt; утилита является RAN с помощью следующей формы:</target>
        </trans-unit>
        <trans-unit id="38c83af4610a697d6724ff3bf3f45adb4124041d" translate="yes" xml:space="preserve">
          <source>Basically, the procedure is as follows:</source>
          <target state="translated">В основном,процедура выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="9c6f5bb2c23fc72e02ed4fe91c08eb86ab7eb097" translate="yes" xml:space="preserve">
          <source>Basics on how computers are programmed</source>
          <target state="translated">Основы программирования компьютеров</target>
        </trans-unit>
        <trans-unit id="075b61c3bd00c5372d9b40a37e76d0e216819b8e" translate="yes" xml:space="preserve">
          <source>Bassa_Vah</source>
          <target state="translated">Bassa_Vah</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="58c655b2cd5d86487b8917d2d93a7efbac26efff" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;enif_schedule_nif&lt;/code&gt;, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return. This means that the calling NIF cannot expect to receive the scheduled NIF return value and use it for further operations.</source>
          <target state="translated">Имейте в &lt;code&gt;enif_schedule_nif&lt;/code&gt; , что enif_schedule_nif , как следует из его названия, только планирует NIF для будущего выполнения. Вызывающий NIF не блокирует ожидание выполнения и возврата запланированного NIF. Это означает, что вызывающий NIF не может ожидать получения запланированного возвращаемого значения NIF и использовать его для дальнейших операций.</target>
        </trans-unit>
        <trans-unit id="1bb1d4b8960f0882b546a0b46a0612e449641efb" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">Будьте осторожны при установке &lt;code&gt;infinity&lt;/code&gt; времени выключения, когда дочерний процесс является рабочим. Поскольку в этой ситуации завершение дерева контроля зависит от дочернего процесса, оно должно быть реализовано безопасным способом, и его процедура очистки всегда должна возвращаться.</target>
        </trans-unit>
        <trans-unit id="ffb65a64fc348102ef56127a672718177ad2a7ab" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process; it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">Будьте осторожны при установке &lt;code&gt;infinity&lt;/code&gt; времени выключения, когда дочерний процесс является рабочим. Потому что в этой ситуации завершение дерева надзора зависит от дочернего процесса; он должен быть реализован безопасным способом, и его процедура очистки всегда должна возвращаться.</target>
        </trans-unit>
        <trans-unit id="2fd62499ab8def7b8b69fee274c4b8917538a4e1" translate="yes" xml:space="preserve">
          <source>Be careful with the version header, use &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; when appropriate.</source>
          <target state="translated">Будьте осторожны с заголовком версии, при необходимости используйте &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7301ce2a6e0b85e60f35ab88d520e5d9725285df" translate="yes" xml:space="preserve">
          <source>Be started in a way that makes the process fit into a supervision tree</source>
          <target state="translated">Начать процесс таким образом,чтобы он вписывался в дерево наблюдения.</target>
        </trans-unit>
        <trans-unit id="105320a56b534ace4c0d31c6412a7c5d4168a815" translate="yes" xml:space="preserve">
          <source>Be sure &lt;strong&gt;not&lt;/strong&gt; no name the directory containing the measurement binaries starting with 'megaco-', e.g. megaco-meas. This will confuse the erlang application loader (erlang applications are named, e.g. megaco-1.0.2).</source>
          <target state="translated">&amp;Igrave;бедитесь , &lt;strong&gt;не&lt;/strong&gt; не имя каталога , содержащего двоичные файлы измерений , начиная с &amp;laquo;megaco-&amp;raquo;, например , MeGaCo-тез. Это запутает загрузчик приложений erlang (приложения на erlang называются, например, megaco-1.0.2).</target>
        </trans-unit>
        <trans-unit id="00d0130a026229dfaa52123c4c578740ea2d109c" translate="yes" xml:space="preserve">
          <source>Be sure to read about &lt;code&gt;Long-running NIFs&lt;/code&gt; before writing a NIF.</source>
          <target state="translated">Обязательно прочтите о &lt;code&gt;Long-running NIFs&lt;/code&gt; перед написанием NIF.</target>
        </trans-unit>
        <trans-unit id="d2edff3a35b65adb5039205d11c2d7f121323a42" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children will do their cleanup in parallel and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">Поскольку у супервизора &lt;code&gt;simple_one_for_one&lt;/code&gt; может быть много потомков, он асинхронно отключает их всех. Это означает, что дочерние элементы будут выполнять очистку параллельно, и поэтому порядок их остановки не определен.</target>
        </trans-unit>
        <trans-unit id="abef4f4009e13039f29fcccf0a57474c315686c1" translate="yes" xml:space="preserve">
          <source>Because lists are commonly used, they have shorthand type notations. The types &lt;code&gt;list(T)&lt;/code&gt; and &lt;code&gt;nonempty_list(T)&lt;/code&gt; have the shorthands &lt;code&gt;[T]&lt;/code&gt; and &lt;code&gt;[T,...]&lt;/code&gt;, respectively. The only difference between the two shorthands is that &lt;code&gt;[T]&lt;/code&gt; can be an empty list but &lt;code&gt;[T,...]&lt;/code&gt; cannot.</source>
          <target state="translated">Поскольку списки широко используются, они имеют сокращенные обозначения типов. Типы &lt;code&gt;list(T)&lt;/code&gt; и &lt;code&gt;nonempty_list(T)&lt;/code&gt; имеют сокращения &lt;code&gt;[T]&lt;/code&gt; и &lt;code&gt;[T,...]&lt;/code&gt; соответственно. Единственная разница между этими двумя сокращениями состоит в том, что &lt;code&gt;[T]&lt;/code&gt; может быть пустым списком, а &lt;code&gt;[T,...]&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="5b3a7dd1ee18a1a87ef5bd7ed89f7551e8ad10ce" translate="yes" xml:space="preserve">
          <source>Because of network and processing delays, the period of tracing is approximate.</source>
          <target state="translated">Из-за задержек в работе сети и обработке данных период отслеживания является приблизительным.</target>
        </trans-unit>
        <trans-unit id="d37fd4abb225a06f4a6768bb951238ff22bfe669" translate="yes" xml:space="preserve">
          <source>Because of peculiarities in the dynamic loading interfaces on different platforms, the returned string is only guaranteed to describe the correct error &lt;strong&gt;if format_error/1 is called in the same instance of the Erlang virtual machine as the error appeared in&lt;/strong&gt; (meaning the same operating system process).</source>
          <target state="translated">Из-за особенностей интерфейсов динамической загрузки на разных платформах возвращаемая строка гарантированно описывает правильную ошибку только в том &lt;strong&gt;случае, если format_error / 1 вызывается в том же экземпляре виртуальной машины Erlang, где возникла ошибка&lt;/strong&gt; (то есть в том же процессе операционной системы ).</target>
        </trans-unit>
        <trans-unit id="2937aec3114f354420a4dc65f7919f8480931c3a" translate="yes" xml:space="preserve">
          <source>Because of subtype relations that exist between types, types form a lattice where the top-most element, &lt;code&gt;any()&lt;/code&gt;, denotes the set of all Erlang terms and the bottom-most element, &lt;code&gt;none()&lt;/code&gt;, denotes the empty set of terms.</source>
          <target state="translated">Из-за отношений подтипов, которые существуют между типами, типы образуют решетку, где самый верхний элемент, &lt;code&gt;any()&lt;/code&gt; , обозначает набор всех терминов Erlang, а самый нижний элемент &lt;code&gt;none()&lt;/code&gt; обозначает пустой набор терминов.</target>
        </trans-unit>
        <trans-unit id="022a498b7c46fc56b49452af050953c22bfbf306" translate="yes" xml:space="preserve">
          <source>Because of the limited length of atoms, it is recommended to use &lt;code&gt;-run&lt;/code&gt; instead.</source>
          <target state="translated">Из-за ограниченной длины атомов рекомендуется вместо этого использовать &lt;code&gt;-run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1384b995beb9b21c8a759c386f9768bb6e9bf48f" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\h&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ ч&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="299f84debe52036e59ae03120fd4f1dabe601f72" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Ll}&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ p {Ll}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d91b3caacd37fdde510b95d27795a9af6bf8136" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Lu}&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ p {Lu}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c0abdb743817968c55df2e58d08673027964564" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{L}&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ p {L}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="730c516db3536d87659465b8430f3c06b9b28d02" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Nd}&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ p {Nd}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af6446ff6bb33935f80c0e27353d8c85c94660f6" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xan}&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ p {Xan}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d22b3bf8b56b82387696e9e8f32390beb8e0c" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xps}&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ p {Xps}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89fc848e28a9b477f8a3b6e31d45687e11d42e23" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xwd}&lt;/strong&gt;</source>
          <target state="translated">Становится &lt;strong&gt;\ p {Xwd}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ebae434cd88ef2302f9bbb202778d21d2e46d19" translate="yes" xml:space="preserve">
          <source>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with &lt;code&gt;badarg&lt;/code&gt; if the monitored process resided on a primitive node (such as erl_interface or jinterface), where remote process monitoring is not implemented.</source>
          <target state="translated">До ERTS 10.0 (OTP 21.0) мониторинг процесса мог завершиться ошибкой с помощью &lt;code&gt;badarg&lt;/code&gt; , если отслеживаемый процесс находился на примитивном узле (таком как erl_interface или jinterface), где удаленный мониторинг процесса не реализован.</target>
        </trans-unit>
        <trans-unit id="c2170fbb9997cb7343b013f87d0b07f06679bee2" translate="yes" xml:space="preserve">
          <source>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</source>
          <target state="translated">До ERTS 5.9 можно было конфигурировать меньшее количество потоковых экземпляров,чем планировщики.Однако это уже невозможно.</target>
        </trans-unit>
        <trans-unit id="60f2fe367a59604d77c1ee7cdc5c0f81f65eda6e" translate="yes" xml:space="preserve">
          <source>Before ERTS 7.0 (Erlang/OTP 18), the return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if &lt;code&gt;enif_make_badarg&lt;/code&gt; has been invoked.</source>
          <target state="translated">До ERTS 7.0 (Erlang / OTP 18) возвращаемое значение из &lt;code&gt;enif_make_badarg&lt;/code&gt; нужно было возвращать из NIF. Теперь это требование отменено, поскольку возвращаемое значение из NIF игнорируется, если был вызван &lt;code&gt;enif_make_badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ec3341c03352c2dcbc8cc1ae6efea67d454637" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other and to empty binaries (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;). If serialized, they would be recreated as plain empty binaries.</source>
          <target state="translated">До ERTS 9.0 (OTP-20.0) все термины ресурсов сравнивались как равные друг другу и с пустыми двоичными файлами ( &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ). В случае сериализации они будут воссозданы как простые пустые двоичные файлы.</target>
        </trans-unit>
        <trans-unit id="f16cc2c8df0cf217a1b01164cd474f9be586865b" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255 was accepted in the string. Now any unicode string is valid.</source>
          <target state="translated">До ERTS 9.1 (OTP-20.1)в строке принимались только кодовые точки в диапазоне 0-255.Теперь любая строка юникода действительна.</target>
        </trans-unit>
        <trans-unit id="b8815a40e2ba0160069e9df632d708ff9fef831a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 17.1, if your test run consisted of multiple tests, cover would be started and stopped for each test within the test run. Separate logs would be available through the &quot;Coverage log&quot; link on the test suite result pages. These links are still available, but now they all point to the same page as the button on the top-level index page. The log contains the accumulated results for the complete test run. For details about this change, see the release notes.</source>
          <target state="translated">До Erlang/OTP 17.1,если ваш тестовый прогон состоял из нескольких тестов,крышка начиналась и останавливалась для каждого теста в течение тестового прогона.Отдельные журналы будут доступны по ссылке &quot;Журнал покрытия&quot; на страницах результатов тестового набора.Эти ссылки все еще доступны,но теперь все они указывают на ту же самую страницу,что и кнопка на главной странице верхнего уровня.Журнал содержит накопленные результаты за весь тестовый период.Подробнее об этом изменении см.в примечаниях к обновлению.</target>
        </trans-unit>
        <trans-unit id="173b9788d3472306f8bca6acb906380d15ebb018" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 19, for fields without initial values, the singleton type &lt;code&gt;'undefined'&lt;/code&gt; was added to all declared types. In other words, the following two record declarations had identical effects:</source>
          <target state="translated">До Erlang / OTP 19 для полей без начальных значений одноэлементный тип &lt;code&gt;'undefined'&lt;/code&gt; добавлялся ко всем объявленным типам. Другими словами, следующие два объявления записей имели одинаковый эффект:</target>
        </trans-unit>
        <trans-unit id="1ebd17eea52effdc10d3b387a5f97c65de3d711a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; behaved completely asynchronously, that is, the monitor was active until the &quot;demonitor signal&quot; reached the monitored entity. This had one undesirable effect. You could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to receive a &lt;code&gt;DOWN&lt;/code&gt; message because of the monitor.</source>
          <target state="translated">До того как Erlang / OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; вёл себя полностью асинхронно, то есть монитор был активен до тех пор, пока &amp;laquo;сигнал демонитора&amp;raquo; не достигал контролируемого объекта. Это имело один нежелательный эффект. Вы никогда не могли знать, когда вы гарантированно &lt;strong&gt;не&lt;/strong&gt; получите сообщение &lt;code&gt;DOWN&lt;/code&gt; из-за монитора.</target>
        </trans-unit>
        <trans-unit id="c04cf745a3c4adfcd300b132adf03ceaef66e4c6" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; behaved completely asynchronously, that is, the link was active until the &quot;unlink signal&quot; reached the linked entity. This had an undesirable effect, as you could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to be effected by the link.</source>
          <target state="translated">До того, как Erlang / OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; вёл себя полностью асинхронно, то есть ссылка была активна до тех пор, пока &amp;laquo;сигнал разъединения&amp;raquo; не достигал связанного объекта. Это имело нежелательный эффект, так как вы никогда не знаете , когда вы были гарантированы &lt;strong&gt;не&lt;/strong&gt; будет осуществляться по ссылке.</target>
        </trans-unit>
        <trans-unit id="14149394b7877b033496395cfd6e420c1de55bda" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R16, the port ID could be used as a key with proper casting, but after the rewrite of the port subsystem, this is no longer the case. With this function, you can achieve the same distribution based on port IDs as before Erlang/OTP R16.</source>
          <target state="translated">До Erlang/OTP R16 идентификатор порта мог использоваться в качестве ключа с правильным кастингом,но после перезаписи подсистемы порта это уже не так.С помощью этой функции можно добиться того же распределения по идентификаторам портов,что и до Erlang/OTP R16.</target>
        </trans-unit>
        <trans-unit id="055828a24a30444b0c0047933c2db837ba4b5188" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but could not retrieved with &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;. Since Linux 3.8, it is readable.</source>
          <target state="translated">До Linux 3.8 этот параметр сокета можно было установить, но нельзя было получить с помощью &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; . Начиная с Linux 3.8, он доступен для чтения.</target>
        </trans-unit>
        <trans-unit id="de814773d3f4ef3f2f57f8421829e0616b1e21de" translate="yes" xml:space="preserve">
          <source>Before OTP 19, if the &lt;code&gt;on_load&lt;/code&gt; function failed, any previously current code would become old, essentially leaving the system without any working and reachable instance of the module. That problem has been eliminated in OTP 19.</source>
          <target state="translated">До OTP 19 в случае &lt;code&gt;on_load&lt;/code&gt; функции on_load любой ранее текущий код становился старым, по существу оставляя систему без какого-либо работающего и доступного экземпляра модуля. Эта проблема была устранена в OTP 19.</target>
        </trans-unit>
        <trans-unit id="0463b80fdbddc48ab1e8bca76239196573ee534f" translate="yes" xml:space="preserve">
          <source>Before OTP R14A (ERTS version 5.8), an implicitly qualified function call to a function having the same name as an auto-imported BIF always resulted in the BIF being called. In newer versions of the compiler, the local function is called instead. This is to avoid that future additions to the set of auto-imported BIFs do not silently change the behavior of old code.</source>
          <target state="translated">До OTP R14A (ERTS версии 5.8)вызов неявно квалифицированной функции с тем же именем,что и автоматически импортируемый BIF,всегда приводил к вызову BIF.В более новых версиях компилятора вместо этого вызывается локальная функция.Это делается для того,чтобы избежать того,что будущие дополнения к набору автоматически импортируемых BIF не будут безмолвно изменять поведение старого кода.</target>
        </trans-unit>
        <trans-unit id="b947a51569cc1cfaeef7b7ff4bf48e678a02c245" translate="yes" xml:space="preserve">
          <source>Before R14, parentheses were needed as follows:</source>
          <target state="translated">До R14 скобки были необходимы следующим образом:</target>
        </trans-unit>
        <trans-unit id="777f496c9fcf95c8a759b97ce9f5b072f83c3c75" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successfull, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="translated">Прежде чем драйвер можно будет вызвать из Erlang, его необходимо загрузить и открыть. Загрузка выполняется с &lt;code&gt;erl_ddll&lt;/code&gt; модуля erl_ddll ( драйвер &lt;code&gt;erl_ddll&lt;/code&gt; , загружающий динамический драйвер, на самом деле является самим драйвером). Если загрузка прошла успешно, порт можно открыть с помощью &lt;code&gt;open_port/2&lt;/code&gt; . Имя порта должно совпадать с именем разделяемой библиотеки и именем в структуре записи драйвера.</target>
        </trans-unit>
        <trans-unit id="20019fdf1abe6fd7869945f2f7dac92f9f72ebdc" translate="yes" xml:space="preserve">
          <source>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the &lt;code&gt;UserProgressTerm&lt;/code&gt; that will be used as input the next time the callback function is called.</source>
          <target state="translated">Перед передачей файла выполняется следующий вызов, чтобы указать начало передачи файла и размер файла. Возвращаемое значение функции обратного вызова должно быть новым значением для &lt;code&gt;UserProgressTerm&lt;/code&gt; , которое будет использоваться в качестве входных данных при следующем вызове функции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="159e2277de857354c36db29ad08f2c463be464e2" translate="yes" xml:space="preserve">
          <source>Before an application can be started, it must be &lt;strong&gt;loaded&lt;/strong&gt;. The application controller reads and stores the information from the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">Прежде чем приложение может быть запущено, оно должно быть &lt;strong&gt;загружено&lt;/strong&gt; . Контроллер приложения считывает и сохраняет информацию из файла &lt;code&gt;.app&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="afd284c8bc9adc5dd4975944173af35c38112da6" translate="yes" xml:space="preserve">
          <source>Before an application makes its first access to a table, &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; is to be executed to ensure that the table is accessible from the local node. If the function times out, the application can choose to force a load of the local replica with &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; and deliberately lose all updates that can have been performed on the other nodes while the local node was down. If &lt;code&gt;Mnesia&lt;/code&gt; has loaded the table on another node already, or intends to do so, copy the table from that node to avoid unnecessary inconsistency.</source>
          <target state="translated">Прежде чем приложение сделает свой первый доступ к таблице, &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; быть выполнено mnesia: wait_for_tables (TabList, Timeout), чтобы обеспечить доступ к таблице с локального узла. Если время ожидания функции истекло, приложение может выбрать принудительную загрузку локальной реплики с помощью &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; и намеренно потерять все обновления, которые могли быть выполнены на других узлах, пока локальный узел не работал. Если &lt;code&gt;Mnesia&lt;/code&gt; уже загрузила таблицу на другой узел или намеревается сделать это, скопируйте таблицу с этого узла, чтобы избежать ненужной несогласованности.</target>
        </trans-unit>
        <trans-unit id="75a2137a0d589f3ac4ee86651537916f812a4998" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, module data must be &lt;strong&gt;set up&lt;/strong&gt;. For instance, the cross reference and the unknown functions are computed when all module data are known. The functions that need complete data (&lt;code&gt;analyze&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;variables&lt;/code&gt;) take care of setting up data automatically. Module data need to be set up (again) after calls to any of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set_library_path&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions.</source>
          <target state="translated">Перед проведением любого анализа необходимо &lt;strong&gt;настроить&lt;/strong&gt; данные модуля . Например, перекрестная ссылка и неизвестные функции вычисляются, когда известны все данные модуля. Функции, которым нужны полные данные ( &lt;code&gt;analyze&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; , &lt;code&gt;variables&lt;/code&gt; ), автоматически настраивают данные. Данные модуля необходимо настроить (снова) после вызовов любой из функций &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;set_library_path&lt;/code&gt; или &lt;code&gt;update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca67bda82873ef4332d857192e18635d990609ed" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt;. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">Перед проведением любого анализа задействованные модули должны быть &lt;strong&gt;скомпилированы&lt;/strong&gt; . Это означает, что в модуль добавляется некоторая дополнительная информация перед его компиляцией в двоичный файл, который затем &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt; . Исходный файл модуля не &lt;code&gt;.beam&lt;/code&gt; файл .beam не создается.</target>
        </trans-unit>
        <trans-unit id="258fe4cd782832c98fba1da0a69f9a8b68aa3908" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is loaded. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">Перед проведением любого анализа задействованные модули должны быть &lt;strong&gt;скомпилированы&lt;/strong&gt; . Это означает, что в модуль добавляется некоторая дополнительная информация перед его компиляцией в двоичный файл, который затем загружается. Исходный файл модуля не &lt;code&gt;.beam&lt;/code&gt; файл .beam не создается.</target>
        </trans-unit>
        <trans-unit id="451eac2b19829254921c8ba2920439b2b92145f5" translate="yes" xml:space="preserve">
          <source>Before applying a patch you need to do a &lt;strong&gt;full&lt;/strong&gt; build of OTP in the source directory.</source>
          <target state="translated">Перед применением патча вам необходимо выполнить &lt;strong&gt;полную&lt;/strong&gt; сборку OTP в исходном каталоге.</target>
        </trans-unit>
        <trans-unit id="0af32825676162dfe9c05e6f703b3efa51985180" translate="yes" xml:space="preserve">
          <source>Before asking a question you can browse the &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt; mailing list archive&lt;/a&gt; and read the &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Frequently Asked Questions&lt;/a&gt;.</source>
          <target state="translated">Прежде чем задать вопрос, вы можете просмотреть &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt;архив списка рассылки&lt;/a&gt; и прочитать &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Часто задаваемые вопросы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cda5c6edb9898f9347103f74f622c57ddde1c654" translate="yes" xml:space="preserve">
          <source>Before calling any of the other &lt;code&gt;Erl_Interface&lt;/code&gt; functions, call &lt;code&gt;erl_init()&lt;/code&gt; exactly once to initialize the library. &lt;code&gt;erl_init()&lt;/code&gt; takes two arguments. However, the arguments are no longer used by &lt;code&gt;Erl_Interface&lt;/code&gt; and are therefore to be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">Перед вызовом любой из других функций &lt;code&gt;Erl_Interface&lt;/code&gt; вызовите &lt;code&gt;erl_init()&lt;/code&gt; ровно один раз для инициализации библиотеки. &lt;code&gt;erl_init()&lt;/code&gt; принимает два аргумента. Однако аргументы больше не используются &lt;code&gt;Erl_Interface&lt;/code&gt; и поэтому должны быть указаны как &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5913933d73f661127a755638c745adee88554860" translate="yes" xml:space="preserve">
          <source>Before calling any other function in Erl_Interface, the memory handling must be initiated:</source>
          <target state="translated">Перед вызовом любой другой функции в Erl_Interface необходимо инициировать обработку памяти:</target>
        </trans-unit>
        <trans-unit id="c91078fc982ffe0902391841ac4ff114e2a4c572" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">Перед началом выполнения группы &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; конфигурационная функция init_per_group (GroupName, Config) . Список кортежей, возвращаемых этой функцией, передается тестовым примерам обычным образом с помощью аргумента &lt;code&gt;Config&lt;/code&gt; . &lt;code&gt;init_per_group/2&lt;/code&gt; предназначен для использования для инициализаций, общих для тестовых случаев в группе. После завершения выполнения группы вызывается функция &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; . Эта функция предназначена для использования для очистки после &lt;code&gt;init_per_group/2&lt;/code&gt; . Если определена функция инициализации, то должна быть и конечная функция.</target>
        </trans-unit>
        <trans-unit id="dfe638852bde7e76a1e9584d5c09fb0ca66d3651" translate="yes" xml:space="preserve">
          <source>Before execution of the timetrap function (which is performed on a parallel, dedicated timetrap process), &lt;code&gt;Common Test&lt;/code&gt; cancels any previously set timer for the test case or configuration function. When the timetrap function returns, the time-out is triggered, &lt;strong&gt;unless&lt;/strong&gt; the return value is a valid timetrap time, such as an integer, or a &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; tuple (for details, see module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;). If a time value is returned, a new timetrap is started to generate a time-out after the specified time.</source>
          <target state="translated">Перед выполнением функции timetrap (которая выполняется в параллельном выделенном процессе timetrap) &lt;code&gt;Common Test&lt;/code&gt; отменяет любой ранее установленный таймер для тестового примера или функции конфигурации. Когда функция timetrap возвращается, тайм-аут запускается, &lt;strong&gt;если&lt;/strong&gt; возвращаемое значение не является допустимым временем timetrap, например целым числом, или &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; (подробности см. В модуле &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; ). Если возвращается значение времени, запускается новая временная ловушка для создания тайм-аута после указанного времени.</target>
        </trans-unit>
        <trans-unit id="08b1254c8bec1bc486b54b5a55646cb74814353f" translate="yes" xml:space="preserve">
          <source>Before going into details of the supervision and error handling in an Erlang system, let us see how Erlang processes terminate, or in Erlang terminology, &lt;strong&gt;exit&lt;/strong&gt;.</source>
          <target state="translated">Прежде чем вдаваться в подробности обработки контроля и ошибок в системе Erlang, давайте посмотрим , как Erlang процессы прекращаются, или в терминологии Erlang, &lt;strong&gt;выход&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="158d175d6b77bf980038361a2e334b0ed9a4b8fc" translate="yes" xml:space="preserve">
          <source>Before improving the messenger program, let us look at some general principles, using the ping pong program as an example. Recall that when &quot;ping&quot; finishes, it tells &quot;pong&quot; that it has done so by sending the atom &lt;code&gt;finished&lt;/code&gt; as a message to &quot;pong&quot; so that &quot;pong&quot; can also finish. Another way to let &quot;pong&quot; finish is to make &quot;pong&quot; exit if it does not receive a message from ping within a certain time. This can be done by adding a &lt;strong&gt;time-out&lt;/strong&gt; to &lt;code&gt;pong&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">Прежде чем улучшать программу обмена сообщениями, давайте рассмотрим некоторые общие принципы на примере программы для настольного тенниса. Вспомните, что когда &amp;laquo;ping&amp;raquo; завершается, он сообщает &amp;laquo;pong&amp;raquo;, что это было сделано, отправляя атом &lt;code&gt;finished&lt;/code&gt; в виде сообщения &amp;laquo;pong&amp;raquo;, чтобы &amp;laquo;pong&amp;raquo; также мог закончить. Другой способ дать &quot;pong&quot; закончиться - это завершить &quot;pong&quot;, если он не получает сообщение от ping в течение определенного времени. Это можно сделать, добавив &lt;strong&gt;тайм-аут&lt;/strong&gt; для &lt;code&gt;pong&lt;/code&gt; , как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="5d0240a960734bd032bfb25f877be3ed95c27ca3" translate="yes" xml:space="preserve">
          <source>Before installation you should test whether your build is working properly by running our smoke test. The smoke test is a subset of the complete Erlang/OTP test suites. First you will need to build and release the test suites.</source>
          <target state="translated">Перед установкой вы должны проверить,правильно ли работает ваше здание,запустив наш дымовой тест.Дымовое тестирование является частью полного набора тестов Erlang/OTP.Сначала вам необходимо построить и выпустить наборы тестов.</target>
        </trans-unit>
        <trans-unit id="f9b6bb02452d70c4cea213f1df9be77d0db03bc1" translate="yes" xml:space="preserve">
          <source>Before looking at how this program works, notice that a few comments are added to the code. A comment starts with a %-character and goes on to the end of the line. Notice also that the &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; line only includes the function &lt;code&gt;format_temps/1&lt;/code&gt;. The other functions are &lt;strong&gt;local&lt;/strong&gt; functions, that is, they are not visible from outside the module &lt;code&gt;tut5&lt;/code&gt;.</source>
          <target state="translated">Прежде чем посмотреть, как работает эта программа, обратите внимание, что в код добавлено несколько комментариев. Комментарий начинается с символа% и продолжается до конца строки. Также обратите внимание, что &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; строка включает только функцию &lt;code&gt;format_temps/1&lt;/code&gt; . Остальные функции являются &lt;strong&gt;локальными&lt;/strong&gt; функциями, то есть они не видны извне модуля &lt;code&gt;tut5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12bcc79844186de606633bdd333ae924acec0daf" translate="yes" xml:space="preserve">
          <source>Before registering a name, you should already have registered your port number with &lt;code&gt;epmd&lt;/code&gt;. This is not strictly necessary, but if you neglect to do so, then other nodes wishing to communicate with your service cannot find or connect to your process.</source>
          <target state="translated">Перед регистрацией имени вы должны уже зарегистрировать свой номер порта в &lt;code&gt;epmd&lt;/code&gt; . В этом нет строгой необходимости, но если вы не сделаете этого, другие узлы, желающие взаимодействовать с вашей службой, не смогут найти ваш процесс или подключиться к нему.</target>
        </trans-unit>
        <trans-unit id="26cb26b93d1388560e328aa535c6bbe4b5f0b51c" translate="yes" xml:space="preserve">
          <source>Before registering with &lt;code&gt;epmd&lt;/code&gt;, you must first create a listen socket and bind it to a port. Then:</source>
          <target state="translated">Перед регистрацией в &lt;code&gt;epmd&lt;/code&gt; вы должны сначала создать прослушивающий сокет и привязать его к порту. Затем:</target>
        </trans-unit>
        <trans-unit id="9c7e0e1b9fcac24580ab6b3d03b6e4b55f4c8972" translate="yes" xml:space="preserve">
          <source>Before starting &lt;code&gt;Mnesia&lt;/code&gt;, the following must be done:</source>
          <target state="translated">Перед запуском &lt;code&gt;Mnesia&lt;/code&gt; необходимо сделать следующее:</target>
        </trans-unit>
        <trans-unit id="7a519a0020d8de31b673de93ded06a0618f853d2" translate="yes" xml:space="preserve">
          <source>Before starting, notice the following:</source>
          <target state="translated">Перед началом работы обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="7011eaabfad589a3868b28c469ad42e5d05beb89" translate="yes" xml:space="preserve">
          <source>Before the call of &lt;code&gt;deflateParams&lt;/code&gt;, the stream state must be set as for a call of &lt;code&gt;deflate/3&lt;/code&gt;, as the currently available input may have to be compressed and flushed.</source>
          <target state="translated">Перед вызовом &lt;code&gt;deflateParams&lt;/code&gt; состояние потока должно быть установлено, как для вызова &lt;code&gt;deflate/3&lt;/code&gt; , поскольку доступный в данный момент ввод может быть сжат и сброшен.</target>
        </trans-unit>
        <trans-unit id="78fa7e00043ebdf38881948abf63f1275524f7cf" translate="yes" xml:space="preserve">
          <source>Before the first call to &lt;code&gt;allow/1&lt;/code&gt;, any node with the correct cookie can be connected. When &lt;code&gt;allow/1&lt;/code&gt; is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not in that list will be rejected.</source>
          <target state="translated">Перед первым вызовом &lt;code&gt;allow/1&lt;/code&gt; может быть подключен любой узел с правильным файлом cookie. Когда вызывается &lt;code&gt;allow/1&lt;/code&gt; , создается список разрешенных узлов. Любые попытки доступа к узлам, не входящим в этот список (или к ним), будут отклонены.</target>
        </trans-unit>
        <trans-unit id="dc3113c94757b2848bc9b3cfac6670102a406895" translate="yes" xml:space="preserve">
          <source>Before the log is dumped, the file &lt;code&gt;LATEST.LOG&lt;/code&gt; is renamed to &lt;code&gt;PREVIOUS.LOG&lt;/code&gt;, and a new &lt;code&gt;LATEST.LOG&lt;/code&gt; file is created. Once the log has been successfully dumped, the file &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; is deleted.</source>
          <target state="translated">Перед &lt;code&gt;LATEST.LOG&lt;/code&gt; файл LATEST.LOG переименовывается в &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; , и создается новый файл &lt;code&gt;LATEST.LOG&lt;/code&gt; . После успешного сброса журнала файл &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; удаляется.</target>
        </trans-unit>
        <trans-unit id="db255d80fd5fbd19169beeb79eff7051fb467716" translate="yes" xml:space="preserve">
          <source>Before the port is created, the driver must be loaded. This is done with the function &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt;, with the name of the shared library as argument.</source>
          <target state="translated">Перед созданием порта необходимо загрузить драйвер. Это делается с помощью функции &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt; с именем разделяемой библиотеки в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="46a334a8ddbc15c984030c1582dd4508b5f21665" translate="yes" xml:space="preserve">
          <source>Before the traversal starts, the source backup media is opened with &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt;, and the target backup media is opened with &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt;. The arguments are as follows:</source>
          <target state="translated">Перед началом обхода исходный носитель резервной копии открывается с помощью &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt; , а целевой носитель резервной копии открывается с помощью &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt; . Аргументы следующие:</target>
        </trans-unit>
        <trans-unit id="a1da9ec4f3c9fc4eb1c3cfeb7777f44d15e8f2fe" translate="yes" xml:space="preserve">
          <source>Before this instruction occurs, &lt;code&gt;Mod&lt;/code&gt; must have been loaded using &lt;code&gt;load_object_code&lt;/code&gt;. This instruction loads the module. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">Прежде чем эта инструкция &lt;code&gt;load_object_code&lt;/code&gt; , &lt;code&gt;Mod&lt;/code&gt; должен быть загружен с использованием load_object_code . Эта инструкция загружает модуль. &lt;code&gt;PrePurge&lt;/code&gt; игнорируется. Описание &lt;code&gt;PostPurge&lt;/code&gt; см. Ранее в &lt;code&gt;update&lt;/code&gt; инструкций высокого уровня .</target>
        </trans-unit>
        <trans-unit id="352876a2381c0951748f4964cadc93f74da158b5" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding startElement event, and all endPrefixMapping events will occur immediately after the corresponding endElement event, but their order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable.</source>
          <target state="translated">Начните область отображения пространства имён с префиксом-URI.Обратите внимание,что события start/endPrefixMapping не гарантированно корректно вложены друг в друга:все события startPrefixMapping будут происходить непосредственно перед соответствующим событием startElement,а все события endPrefixMapping будут происходить непосредственно после соответствующего события endElement,но их порядок не гарантирован.События start/endPrefixMapping для префикса &quot;xml&quot; не будут происходить,т.к.они предварительно объявлены и являются неизменными.</target>
        </trans-unit>
        <trans-unit id="ef3ba8079ba496eafefddd167fd69849d3349c1c" translate="yes" xml:space="preserve">
          <source>Beginning of line</source>
          <target state="translated">Начало пути</target>
        </trans-unit>
        <trans-unit id="a0541a24650d9da6d38c74c8da4b43cac73179f4" translate="yes" xml:space="preserve">
          <source>Beginning with Erlang/OTP R14, parentheses when accessing or updating nested records can be omitted. Assume the following record definitions:</source>
          <target state="translated">Начиная с Erlang/OTP R14,скобки при доступе к вложенным записям или их обновлении могут быть опущены.Допустим,следующие определения записей:</target>
        </trans-unit>
        <trans-unit id="dbe51e0d3cf7fe095d04d74ded17ede0a93150c5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="translated">Ведет себя как &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt; , но создает двоичный код вместо списка Unicode.</target>
        </trans-unit>
        <trans-unit id="89ade40ae04b2b1a7cb87dcb6495bdb4cd27f4c3" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; except that it allows an extra option to be specified, namely &lt;code&gt;allow_passive_connect&lt;/code&gt;. This option allows the BIF to wait the normal network connection time-out for the &lt;strong&gt;monitored node&lt;/strong&gt; to connect itself, even if it cannot be actively connected from this node (that is, it is blocked). The state where this can be useful can only be achieved by using the Kernel option &lt;code&gt;dist_auto_connect once&lt;/code&gt;. If that option is not used, option &lt;code&gt;allow_passive_connect&lt;/code&gt; has no effect.</source>
          <target state="translated">Ведет себя как &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; , за исключением того, что позволяет указать дополнительную опцию, а именно &lt;code&gt;allow_passive_connect&lt;/code&gt; . Этот параметр позволяет BIF ожидать обычного тайм-аута сетевого подключения, чтобы &lt;strong&gt;отслеживаемый узел&lt;/strong&gt; подключился сам, даже если он не может быть активно подключен с этого узла (т. Е. Он заблокирован). Состояние, при котором это может быть полезно, может быть достигнуто только &lt;code&gt;dist_auto_connect once&lt;/code&gt; использованием параметра ядра dist_auto_connect . Если этот параметр не используется, опция &lt;code&gt;allow_passive_connect&lt;/code&gt; не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="64aaa639db43c0fb66ead8ebf5d3670fe4ea4ff0" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">Поведение, описывающее API для обработки открытого ключа клиента SSH. Реализуя обратные вызовы, определенные в этом поведении, можно настроить обработку открытого ключа клиента SSH. По умолчанию приложение &lt;code&gt;ssh&lt;/code&gt; реализует это поведение с помощью стандартных файлов OpenSSH, см. Руководство приложения &lt;code&gt;ssh(6)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f16faae4208d9a96f7fb1bb23ef9cd7087ccfdeb" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">Поведение, описывающее API для обработки открытого ключа SSH-сервера. Реализуя обратные вызовы, определенные в этом поведении, можно настроить обработку открытого ключа SSH-сервера. По умолчанию приложение SSH реализует это поведение с помощью стандартных файлов OpenSSH, см. Руководство приложения &lt;code&gt;ssh(6)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d4ec155f7430eef8a27415e38c4ad6595b98c0" translate="yes" xml:space="preserve">
          <source>Behaviour module for reporting SNMP agent errors</source>
          <target state="translated">Модуль поведения для формирования отчетов об ошибках агентов SNMP</target>
        </trans-unit>
        <trans-unit id="2d41c7e7235b92d9c78165f5ea1a1214538b7ae8" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent discovery handler.</source>
          <target state="translated">Модуль поведения для обработчика обнаружения агентов SNMP.</target>
        </trans-unit>
        <trans-unit id="4d88eee718b5f101a30d4bf7abe96e2a4af445a2" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib storage.</source>
          <target state="translated">Модуль поведения для хранилища SNMP агента миб.</target>
        </trans-unit>
        <trans-unit id="213836ecbce5c62ee5c70a707ff8f6efbfddb7e0" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib-server data module.</source>
          <target state="translated">Модуль поведения для модуля данных SNMP агента mib-сервера.</target>
        </trans-unit>
        <trans-unit id="9b9ea5bbfad06ea1fc316484f53361a36304e0df" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network interface.</source>
          <target state="translated">Модуль поведения для сетевого интерфейса агента SNMP.</target>
        </trans-unit>
        <trans-unit id="b7490591e615b37731085e0dc791786738305c7b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network-interface filter.</source>
          <target state="translated">Модуль поведения для фильтра сетевого интерфейса SNMP-агента.</target>
        </trans-unit>
        <trans-unit id="2d2c6aaaa587ce80e3a95c5e764e760aa91d874b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification delivery information receiver.</source>
          <target state="translated">Модуль поведения для SNMP-приемника информации о доставке агента оповещения.</target>
        </trans-unit>
        <trans-unit id="625c1c9de2b712103668af5814be0412885b49e5" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification filters.</source>
          <target state="translated">Модуль поведения для фильтров уведомления об агентах SNMP.</target>
        </trans-unit>
        <trans-unit id="de9d0d8b19209222093743579cc0da909bbbb028" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network interface.</source>
          <target state="translated">Модуль поведения для сетевого интерфейса SNMP-менеджера.</target>
        </trans-unit>
        <trans-unit id="2f41f4d43078504e98d5de4dc916e14eb8a85ba6" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network-interface filter.</source>
          <target state="translated">Модуль поведения для фильтра сетевого интерфейса SNMP-менеджера.</target>
        </trans-unit>
        <trans-unit id="eb1e7ed7fa32a13f652cc9e9bf36d2ab93e52c2b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager user.</source>
          <target state="translated">Модуль поведения для пользователя SNMP-менеджера.</target>
        </trans-unit>
        <trans-unit id="77b3fcb503c107fdcf78ea27b16f4310e4bd176a" translate="yes" xml:space="preserve">
          <source>Behaviour with optional callbacks to customize the inets HTTP server.</source>
          <target state="translated">Поведение с дополнительными обратными вызовами для настройки неэффективного HTTP-сервера.</target>
        </trans-unit>
        <trans-unit id="e0f283a40056570ec143d350395380c52fd1c5b2" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;/usr/local/otp&lt;/code&gt;:</source>
          <target state="translated">Ниже приведен полный пример того, что следует добавить в пользовательский &lt;code&gt;.emacs&lt;/code&gt; при условии, что OTP установлен в каталоге &lt;code&gt;/usr/local/otp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1fad7bb629bd2e9041c6abf5bc0a920316f854b0" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Ниже приведен полный пример того, что следует добавить в &lt;code&gt;.emacs&lt;/code&gt; пользователя при условии, что OTP установлен в каталоге &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40217191ef85c64b525b787ccb400689f06f21a9" translate="yes" xml:space="preserve">
          <source>Below is an example of the grammar above with structure building code added:</source>
          <target state="translated">Ниже приведен пример грамматики выше с добавлением кода построения структуры:</target>
        </trans-unit>
        <trans-unit id="5d5970fcf1e0337426fd2a5c1de2fd3082f3b1fe" translate="yes" xml:space="preserve">
          <source>Benchmarks can measure wall-clock time or CPU time.</source>
          <target state="translated">Бенчмарки могут измерять время настенных часов или процессорное время.</target>
        </trans-unit>
        <trans-unit id="bfb8b17cc74805621ef756d36abfea020e22ec89" translate="yes" xml:space="preserve">
          <source>Benchmarks that appear to be concurrent are often sequential. The estone benchmark, for example, is entirely sequential. So is the most common implementation of the &quot;ring benchmark&quot;; usually one process is active, while the others wait in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="translated">Тесты, которые кажутся параллельными, часто бывают последовательными. Например, эталонный тест Estone полностью последовательный. Такова наиболее распространенная реализация &amp;laquo;кольцевого теста&amp;raquo;; обычно один процесс активен, в то время как другие ждут в операторе &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="c274af2a723078651a0cf0e2bdc4b8cb3f48d70d" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;qlc:table/2&lt;/code&gt;, other functions return query handles. They are used more seldom than tables, but are sometimes useful. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; traverses objects from many tables or lists after each other. If, for example, you want to traverse all answers to a query &lt;code&gt;QH&lt;/code&gt; and then finish off by a term &lt;code&gt;{finished}&lt;/code&gt;, you can do that by calling &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt;. &lt;code&gt;append/2&lt;/code&gt; first returns all objects of &lt;code&gt;QH&lt;/code&gt;, then &lt;code&gt;{finished}&lt;/code&gt;. If a tuple &lt;code&gt;{finished}&lt;/code&gt; exists among the answers to &lt;code&gt;QH&lt;/code&gt;, it is returned twice from &lt;code&gt;append/2&lt;/code&gt;.</source>
          <target state="translated">Помимо &lt;code&gt;qlc:table/2&lt;/code&gt; , другие функции возвращают дескрипторы запросов. Они используются реже таблиц, но иногда полезны. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; просматривает объекты из многих таблиц или списков друг за другом. Если, например, вы хотите просмотреть все ответы на запрос &lt;code&gt;QH&lt;/code&gt; , а затем закончить его термином &lt;code&gt;{finished}&lt;/code&gt; , вы можете сделать это, вызвав &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt; . &lt;code&gt;append/2&lt;/code&gt; сначала возвращает все объекты &lt;code&gt;QH&lt;/code&gt; , затем &lt;code&gt;{finished}&lt;/code&gt; . Если среди ответов на &lt;code&gt;QH&lt;/code&gt; существует кортеж &lt;code&gt;{finished}&lt;/code&gt; , он возвращается дважды из &lt;code&gt;append/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6260580b5bc11052e617d5d44b018db15e9a982" translate="yes" xml:space="preserve">
          <source>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</source>
          <target state="translated">Помимо адресации процесса с помощью pid,существуют также BIF для регистрации процесса под именем.Название должно быть атомом и автоматически не регистрируется,если процесс завершается:</target>
        </trans-unit>
        <trans-unit id="b15bc3f2eceb04129fd4516b3b370516eb00424d" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Помимо сообщения времени, &lt;code&gt;erlang:now/0&lt;/code&gt; также производит уникальные и строго монотонно возрастающие значения. Чтобы отделить эту функциональность от измерения времени, мы ввели &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a52810e66627e5a80808e690811322ee8adf786" translate="yes" xml:space="preserve">
          <source>Besides test cases and groups, the test suite can also contain configuration functions. These functions are meant to be used for setting up (and verifying) environment and state in the SUT (and/or the &lt;code&gt;Common Test&lt;/code&gt; host node), required for the tests to execute correctly. Examples of operations are: Opening a connection to the SUT, initializing a database, running an installation script, and so on. Configuration can be performed per suite, per test case group, and per individual test case.</source>
          <target state="translated">Помимо тестовых примеров и групп, набор тестов также может содержать функции настройки. Эти функции предназначены для использования для настройки (и проверки) среды и состояния в SUT (и / или хост-узле &lt;code&gt;Common Test&lt;/code&gt; ), необходимых для правильного выполнения тестов. Примеры операций: открытие соединения с SUT, инициализация базы данных, запуск сценария установки и т. Д. Конфигурация может выполняться для каждого набора, для группы тестовых примеров и для каждого отдельного тестового набора.</target>
        </trans-unit>
        <trans-unit id="007ac80b876d6b31b51d4c189993df4c58d1fc5a" translate="yes" xml:space="preserve">
          <source>Besides the already mentioned source parameters &lt;code&gt;root_dir&lt;/code&gt; and &lt;code&gt;lib_dirs&lt;/code&gt;, the following system (&lt;code&gt;sys&lt;/code&gt;) level options are supported:</source>
          <target state="translated">Помимо уже упомянутых исходных параметров &lt;code&gt;root_dir&lt;/code&gt; и &lt;code&gt;lib_dirs&lt;/code&gt; , поддерживаются следующие параметры системного ( &lt;code&gt;sys&lt;/code&gt; ) уровня:</target>
        </trans-unit>
        <trans-unit id="d77fc5043db349a36fcc2530a0223317a9d51ded" translate="yes" xml:space="preserve">
          <source>Between modules</source>
          <target state="translated">Между модулями</target>
        </trans-unit>
        <trans-unit id="7e04d97ca7154dfa6468b97d3b9c42d0c616a358" translate="yes" xml:space="preserve">
          <source>Between nodes</source>
          <target state="translated">Между узлами</target>
        </trans-unit>
        <trans-unit id="3430043cce88789d3bd382a0b2a1bc3c39a24538" translate="yes" xml:space="preserve">
          <source>Between processes</source>
          <target state="translated">Между процессами</target>
        </trans-unit>
        <trans-unit id="f647ae7d5e7143915c4692eef6551f34333f508c" translate="yes" xml:space="preserve">
          <source>Beware of confusing mandatory in the sense of the M-bit with mandatory in the sense of the command grammar. The former is a semantic requirement: that the receiver understand the semantics of the AVP in the context in question. The latter is a syntactic requirement: whether or not the AVP must occur in the message in question.</source>
          <target state="translated">Остерегайтесь путать обязательное в смысле M-бита с обязательным в смысле грамматики команды.Первое-это семантическое требование:чтобы ресивер понимал семантику АВП в рассматриваемом контексте.Второе-синтаксическое требование:должен ли AVP встречаться в рассматриваемом сообщении или нет.</target>
        </trans-unit>
        <trans-unit id="5a3b08c5bdc112934a46e49f93c6566926eb949f" translate="yes" xml:space="preserve">
          <source>Beware of trailing space in &lt;code&gt;Replacement&lt;/code&gt; to be used. If you must have a space in &lt;code&gt;Re&lt;/code&gt;, use, for example, the character encoding &lt;code&gt;\040&lt;/code&gt;, see &lt;code&gt;re(3)&lt;/code&gt;.</source>
          <target state="translated">Остерегайтесь использования конечного пробела в &lt;code&gt;Replacement&lt;/code&gt; . Если у вас должен быть пробел в &lt;code&gt;Re&lt;/code&gt; , используйте, например, кодировку символов &lt;code&gt;\040&lt;/code&gt; , см. &lt;code&gt;re(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99e106abb61082912f0a96161c0ad22a4eea32f3" translate="yes" xml:space="preserve">
          <source>Beware of using fun expressions of the form &lt;code&gt;fun Name/Arity&lt;/code&gt; in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Остерегайтесь использования забавных выражений формы &lt;code&gt;fun Name/Arity&lt;/code&gt; в ситуациях, когда удовольствие не длится недолго и код должен обновляться во время выполнения, поскольку любые процессы, сохраняющие такое веселье, будут иметь ссылку на старый код. В частности, такое значение обычно не подходит для конфигурации, передаваемой в &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f04d9d4432e8383e468152a41bfa09dcf4f742e" translate="yes" xml:space="preserve">
          <source>Beware that RFC 6733 changed the DiameterURI transport/port defaults specified in RFC3588. Relying on the defaults can result in interoperability problems.</source>
          <target state="translated">Остерегайтесь,что RFC 6733 изменил настройки транспорта/порта DiameterURI по умолчанию,указанные в RFC3588.Опора на значения по умолчанию может привести к проблемам функциональной совместимости.</target>
        </trans-unit>
        <trans-unit id="37789191d916ab6f4adfabdff7e05307d5bbf9ba" translate="yes" xml:space="preserve">
          <source>Beware the difference between &lt;strong&gt;diameter&lt;/strong&gt; (not capitalized) and &lt;strong&gt;Diameter&lt;/strong&gt; (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733.</source>
          <target state="translated">Обратите внимание на разницу между &lt;strong&gt;диаметром&lt;/strong&gt; (без заглавной буквы) и &lt;strong&gt;диаметром&lt;/strong&gt; (с заглавной буквы). Первый относится к приложению Erlang с именем Diameter, основной api которого здесь определен, второй - к протоколу Diameter в смысле RFC 6733.</target>
        </trans-unit>
        <trans-unit id="5b68a0f135268fc97357fa1f2e8bec70aa5933a7" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the binum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="translated">Бигнумы хранятся в унарной форме с байтом &lt;code&gt;Sign&lt;/code&gt; , то есть 0, если бинум положительный, и 1, если он отрицательный. Цифры сохраняются, причем младший байт сохраняется первым. Для вычисления целого числа можно использовать следующую формулу:</target>
        </trans-unit>
        <trans-unit id="b0c51379d746d689abb0d4163480ae980cc1ea4f" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="translated">Двоичные файлы генерируются с помощью выражения битового синтаксиса или с помощью &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; , &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt; или как входные данные из двоичных портов. Поле длины &lt;code&gt;Len&lt;/code&gt; представляет собой 4-байтовое целое число без знака (с прямым порядком байтов).</target>
        </trans-unit>
        <trans-unit id="afb16785a033cecba113ba879f8a7ad266f9f880" translate="yes" xml:space="preserve">
          <source>Binaries are more troublesome. For performance reasons, programs often store textual data in binaries instead of lists, mainly because they are more compact (one byte per character instead of two words per character, as is the case with lists). Using &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, an ISO Latin-1 Erlang string can be converted into a binary, effectively using bytewise encoding: one byte per character. This was convenient for those limited Erlang strings, but cannot be done for arbitrary Unicode lists.</source>
          <target state="translated">Бинарные файлы более хлопотны. По соображениям производительности программы часто хранят текстовые данные в двоичных файлах, а не в списках, в основном потому, что они более компактны (один байт на символ вместо двух слов на символ, как в случае со списками). Используя &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; , строку Erlang ISO Latin-1 можно преобразовать в двоичную, эффективно используя побайтное кодирование: один байт на символ. Это было удобно для этих ограниченных строк Erlang, но невозможно для произвольных списков Unicode.</target>
        </trans-unit>
        <trans-unit id="9777da829501809520a535ef9e6d08ff6a5dcba9" translate="yes" xml:space="preserve">
          <source>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</source>
          <target state="translated">Бинарии-это последовательности целых байтов.Битовые строки с произвольной длиной битов пока не имеют поддержки.</target>
        </trans-unit>
        <trans-unit id="ddb0d785eee554ca3ad9cce85a18ca8630f56b8c" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently built in the following way:</source>
          <target state="translated">Бинарии могут быть эффективно построены следующим образом:</target>
        </trans-unit>
        <trans-unit id="0d0d3b67132c6fcaa92c679366fed8db13d485e2" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently matched like this:</source>
          <target state="translated">Бинарии могут быть эффективно подобраны вот так:</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="892dde55806e241693a0b3bdfdd1efae250f381f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;Bin&lt;/code&gt; contains the same information as the output from &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt;. Use &lt;code&gt;binary_to_list/1&lt;/code&gt; to obtain the string of characters from the binary.</source>
          <target state="translated">Двоичный &lt;code&gt;Bin&lt;/code&gt; содержит ту же информацию, что и вывод &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt; . Используйте &lt;code&gt;binary_to_list/1&lt;/code&gt; , чтобы получить строку символов из двоичного файла .</target>
        </trans-unit>
        <trans-unit id="ebbd4d9948de9c87d6e53af4cc41250b5709a590" translate="yes" xml:space="preserve">
          <source>Binary boot script</source>
          <target state="translated">скрипт двоичной загрузки</target>
        </trans-unit>
        <trans-unit id="6ca5ef63e7a423ed4f0c902eb2201ec5aa53e26f" translate="yes" xml:space="preserve">
          <source>Binary callback function &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; is used for looking up objects in the table. The first argument &lt;code&gt;Position&lt;/code&gt; is the key position or an indexed position and the second argument &lt;code&gt;Keys&lt;/code&gt; is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at &lt;code&gt;Position&lt;/code&gt; is a member of &lt;code&gt;Keys&lt;/code&gt;. Any other return value is immediately returned as value of the query evaluation. &lt;code&gt;LookupFun&lt;/code&gt; is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at &lt;code&gt;Position&lt;/code&gt; in such a way that only &lt;code&gt;Keys&lt;/code&gt; need to be looked up to find all potential answers.</source>
          <target state="translated">Двоичная функция обратного вызова &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; используется для поиска объектов в таблице. Первый аргумент &lt;code&gt;Position&lt;/code&gt; - это позиция ключа или индексированная позиция, а второй аргумент &lt;code&gt;Keys&lt;/code&gt; - это отсортированный список уникальных значений. Возвращаемое значение должно быть списком всех объектов (кортежей), так что элемент в &lt;code&gt;Position&lt;/code&gt; является членом &lt;code&gt;Keys&lt;/code&gt; . Любое другое возвращаемое значение немедленно возвращается как значение оценки запроса. &lt;code&gt;LookupFun&lt;/code&gt; вызывается вместо обхода таблицы, если преобразование синтаксического анализа во время компиляции может определить соответствие фильтров и сравнить элемент в &lt;code&gt;Position&lt;/code&gt; таким образом, что только &lt;code&gt;Keys&lt;/code&gt; нужно искать, чтобы найти все возможные ответы.</target>
        </trans-unit>
        <trans-unit id="91649b24f930abce26bedbe83f0148ebb05baa18" translate="yes" xml:space="preserve">
          <source>Binary codecs</source>
          <target state="translated">бинарные кодеки</target>
        </trans-unit>
        <trans-unit id="bfbd337015a6a1e9c7fe45e7f4ee5d33b7a0cc06" translate="yes" xml:space="preserve">
          <source>Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.</source>
          <target state="translated">Двоичные данные разделяются между процессами.Если другой процесс все еще ссылается на большой двоичный файл,то копирование части,используемой этим процессом,только потребляет больше памяти и не освобождает большой двоичный файл для сбора мусора.Используйте такие навязчивые функции с крайней осторожностью и только в случае обнаружения реальной проблемы.</target>
        </trans-unit>
        <trans-unit id="e0b461eb903baadd26c515cd4ef53be30f07dc47" translate="yes" xml:space="preserve">
          <source>Binary handling was significantly improved in R12B. Because code that was efficient in R11B might not be efficient in R12B, and vice versa, earlier revisions of this Efficiency Guide contained some information about binary handling in R11B.</source>
          <target state="translated">Двоичная обработка была значительно улучшена в R12B.Поскольку код,который был эффективен в R11B,может быть не эффективен в R12B,и наоборот,более ранние версии этого Руководства по эффективности содержали некоторую информацию о работе с бинарными данными в R11B.</target>
        </trans-unit>
        <trans-unit id="3435ca67f0f051a1fea228cdb0770bf8e8bb3d65" translate="yes" xml:space="preserve">
          <source>Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with &lt;code&gt;copy/1&lt;/code&gt; can be useful when optimizing for memory use.</source>
          <target state="translated">Совместное использование двоичных файлов происходит всякий раз, когда двоичные файлы разделяются. Это основная причина того, почему двоичные файлы работают быстро, разложение всегда может быть выполнено со сложностью O (1). Однако в редких случаях совместное использование данных нежелательно, поэтому эта функция вместе с &lt;code&gt;copy/1&lt;/code&gt; может быть полезна при оптимизации использования памяти.</target>
        </trans-unit>
        <trans-unit id="444f4f33b9d5b0002c23fd9ec1a4edab1ded0af6" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in UTF-8 or UTF-16.</source>
          <target state="translated">Двоичный файл с символами в кодировке UTF-8 или UTF-16.</target>
        </trans-unit>
        <trans-unit id="c065024f1e88a0e634a5d724af341ce692e22147" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in iso-latin-1.</source>
          <target state="translated">Двоичный файл с символами,закодированными в изолатине-1.</target>
        </trans-unit>
        <trans-unit id="89f902f1a369dce968f46c3953a9e68e0d99f72f" translate="yes" xml:space="preserve">
          <source>BinaryGraphOp ::= &lt;code&gt;of&lt;/code&gt;</source>
          <target state="translated">BinaryGraphOp :: = &lt;code&gt;of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7513e46be3c5ca02f1cd91f8479bcae815aa2cca" translate="yes" xml:space="preserve">
          <source>BinarySetOp ::= &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">BinarySetOp :: = &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8264338650782cc58de94b15794c38a796b18c92" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is not supported on the specific platform.</source>
          <target state="translated">Привязка планировщиков не поддерживается на конкретной платформе.</target>
        </trans-unit>
        <trans-unit id="65e949b92a71c14d4ea442682069d67c76442e70" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is only supported on newer Linux, Solaris, FreeBSD, and Windows systems.</source>
          <target state="translated">Привязка планировщиков поддерживается только на новых Linux,Solaris,FreeBSD и Windows системах.</target>
        </trans-unit>
        <trans-unit id="1e29acb46257f51cfc0f132df9d70d5a8cf45608" translate="yes" xml:space="preserve">
          <source>Bindings,</source>
          <target state="translated">Bindings,</target>
        </trans-unit>
        <trans-unit id="a255a9d3a4009bbdfcc5e9d159b353b687a30da6" translate="yes" xml:space="preserve">
          <source>Binds a socket to a specific network interface. This option must be used in a function call that creates a socket, that is, &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Привязывает сокет к определенному сетевому интерфейсу. Эта опция должна использоваться в вызове функции, которая создает сокет, то есть &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="360cda316649dfca67f2603c94b136a74b6c648a" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are analogous to List Comprehensions. They are used to generate bit strings efficiently and succinctly.</source>
          <target state="translated">Понимание битовой строки аналогично пониманию List Comprehensions.Они используются для эффективной и лаконичной генерации битовых строк.</target>
        </trans-unit>
        <trans-unit id="f9ef7ef37c0e6417fc396a660a24f1538c5ef671" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are written with the following syntax:</source>
          <target state="translated">Понимание битовых строк пишется со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="fe2441919ecc33eba0d15c91c6774d8e118b27fa" translate="yes" xml:space="preserve">
          <source>Bit strings are expressed using the &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Битовые строки выражаются с использованием &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef4786f28896f4e7ec27947fbbc93a25189b57f1" translate="yes" xml:space="preserve">
          <source>Bit strings that consist of a number of bits that are evenly divisible by eight, are called &lt;strong&gt;binaries&lt;/strong&gt;</source>
          <target state="translated">Битовые строки, состоящие из числа битов, которые делятся на восемь без остатка, называются &lt;strong&gt;двоичными.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71ef7d1974a07fcaa17eb97f44c3fb4fcef331ed" translate="yes" xml:space="preserve">
          <source>Bitshift right</source>
          <target state="translated">битсдвиг вправо</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">Побочно ИЛИ</target>
        </trans-unit>
        <trans-unit id="567f521d0a70021d35df0a7429cd3579c200a9d3" translate="yes" xml:space="preserve">
          <source>Bitwise operators: &lt;code&gt;band&lt;/code&gt;, &lt;code&gt;bor&lt;/code&gt;, &lt;code&gt;bxor&lt;/code&gt;, &lt;code&gt;bnot&lt;/code&gt;, &lt;code&gt;bsl&lt;/code&gt;, &lt;code&gt;bsr&lt;/code&gt;</source>
          <target state="translated">Битовые операторы: &lt;code&gt;band&lt;/code&gt; , &lt;code&gt;bor&lt;/code&gt; , &lt;code&gt;bxor&lt;/code&gt; , &lt;code&gt;bnot&lt;/code&gt; , &lt;code&gt;bsl&lt;/code&gt; , &lt;code&gt;bsr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae104d5e9f670270b20927f74417d76623f8773a" translate="yes" xml:space="preserve">
          <source>Black-box testing of target systems of any type (that is, not necessarily implemented in Erlang). This is performed through standard O&amp;amp;M interfaces (such as SNMP, HTTP, CORBA, and Telnet) and, if necessary, through user-specific interfaces (often called test ports).</source>
          <target state="translated">Тестирование целевых систем любого типа методом &amp;laquo;черного ящика&amp;raquo; (то есть не обязательно реализовано в Erlang). Это выполняется через стандартные интерфейсы O&amp;amp;M (такие как SNMP, HTTP, CORBA и Telnet) и, при необходимости, через пользовательские интерфейсы (часто называемые тестовыми портами).</target>
        </trans-unit>
        <trans-unit id="9a8a1cf314b7d5a93ed2c3c8500ce8e82ea060d8" translate="yes" xml:space="preserve">
          <source>Block ciphers -  DES and AES in Block Cipher Modes - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Блочные шифры - DES и AES в режимах блочного шифрования - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc11d63974d38781fdb2ea32c8ba8e895421285c" translate="yes" xml:space="preserve">
          <source>Block expressions provide a way to group a sequence of expressions, similar to a clause body. The return value is the value of the last expression &lt;code&gt;ExprN&lt;/code&gt;.</source>
          <target state="translated">Блочные выражения позволяют группировать последовательность выражений, аналогичную телу предложения. Возвращаемое значение - это значение последнего выражения &lt;code&gt;ExprN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a11c7845b57dd764a4e0b6dfeac45510d039cbd4" translate="yes" xml:space="preserve">
          <source>Blocking of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that you need to use these features, consider it a few more times again. Blocking multi-scheduling is only to be used as a last resort, as it is most likely a &lt;strong&gt;very inefficient&lt;/strong&gt; way to solve the problem.</source>
          <target state="translated">Блокировка множественного планирования и нормального множественного планирования обычно не требуется. Если вы чувствуете, что вам нужно использовать эти функции, подумайте еще несколько раз. Блокирование множественного расписания следует использовать только в крайнем случае, так как это, скорее всего, &lt;strong&gt;очень неэффективный&lt;/strong&gt; способ решения проблемы.</target>
        </trans-unit>
        <trans-unit id="f88bcddd0731f8535aab4cf6c4aea9771da5b592" translate="yes" xml:space="preserve">
          <source>Blocks that are larger than the value of the singleblock carrier threshold (&lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt;) parameter are placed in singleblock carriers.</source>
          <target state="translated">Блоки, размер которых превышает значение параметра singleblock carrier threshold ( &lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt; ), помещаются в одноблочные несущие.</target>
        </trans-unit>
        <trans-unit id="19edd385ea6503e1211246f52fb3bd015a6b72b6" translate="yes" xml:space="preserve">
          <source>Blocks that are smaller than the value of parameter &lt;code&gt;sbct&lt;/code&gt; are placed in multiblock carriers.</source>
          <target state="translated">Блоки, размер которых меньше значения параметра &lt;code&gt;sbct&lt;/code&gt; , размещаются на многоблочных носителях.</target>
        </trans-unit>
        <trans-unit id="4206776cd5ab32e70519cb42f90bc1cb4373333a" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3cde099dd0c2860dfd30f6b0378f3f056b13cc7" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="60192723d1692fc0b5f8fc179416c38b9c58ae23" translate="yes" xml:space="preserve">
          <source>Boolean expressions</source>
          <target state="translated">булевы выражения</target>
        </trans-unit>
        <trans-unit id="66182d005e228ccf7ad8ca7af48f43e62e8288b3" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;andalso&lt;/code&gt;, &lt;code&gt;orelse&lt;/code&gt;</source>
          <target state="translated">Логические операторы: &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;andalso&lt;/code&gt; , &lt;code&gt;orelse&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff2372b936c678678613bf8145deb94c379766ad" translate="yes" xml:space="preserve">
          <source>Booleans in ASN.1 express values that can be either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;. The meanings assigned to &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are outside the scope of this text.</source>
          <target state="translated">Логические значения в ASN.1 выражают значения, которые могут быть &lt;code&gt;TRUE&lt;/code&gt; или &lt;code&gt;FALSE&lt;/code&gt; . Значения, присвоенные &lt;code&gt;TRUE&lt;/code&gt; и &lt;code&gt;FALSE&lt;/code&gt; , выходят за рамки этого текста.</target>
        </trans-unit>
        <trans-unit id="57f87135d0b5c7204e5e725d7f6d51c65d0e1da6" translate="yes" xml:space="preserve">
          <source>Boot script</source>
          <target state="translated">загрузочный сценарий</target>
        </trans-unit>
        <trans-unit id="55cc3a7f7d6ae5f5575682107980e3293f644b52" translate="yes" xml:space="preserve">
          <source>Boot scripts are built using the &lt;code&gt;systools&lt;/code&gt; utility in the SASL application. For more information on &lt;code&gt;systools&lt;/code&gt;, see the SASL documentation. This is only an example of what can be done.</source>
          <target state="translated">Сценарии загрузки создаются с &lt;code&gt;systools&lt;/code&gt; утилиты systools в приложении SASL. Для получения дополнительной информации о &lt;code&gt;systools&lt;/code&gt; см. Документацию по SASL. Это только пример того, что можно сделать.</target>
        </trans-unit>
        <trans-unit id="a3d4144d275cc7e2f7cb03eca0c38a1d2569fa5e" translate="yes" xml:space="preserve">
          <source>Boot server for other Erlang machines.</source>
          <target state="translated">Загрузочный сервер для других машин Erlang.</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="aeca55061b1a7fcf42d399adecf44466466ea1f5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;GetInfo&lt;/code&gt; and &lt;code&gt;GetBin&lt;/code&gt; must be called within the &lt;code&gt;Fun&lt;/code&gt;. Their behavior is undefined if they are called outside the context of &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">И &lt;code&gt;GetInfo&lt;/code&gt; , и &lt;code&gt;GetBin&lt;/code&gt; должны вызываться в &lt;code&gt;Fun&lt;/code&gt; . Их поведение не определено, если они вызываются вне контекста &lt;code&gt;Fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088b2c8092f1e119c8753dea210acbd5446d7101" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;WarningList&lt;/code&gt; and &lt;code&gt;ErrorList&lt;/code&gt; have the following format:</source>
          <target state="translated">И &lt;code&gt;WarningList&lt;/code&gt; , и &lt;code&gt;ErrorList&lt;/code&gt; имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="17f701bc8b6f6001358219750664486c85b21b5d" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; have &lt;strong&gt;return values&lt;/strong&gt;, that is, in the above example &lt;code&gt;case&lt;/code&gt; returned either &lt;code&gt;{inch,X/2.54}&lt;/code&gt; or &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt;. The behaviour of &lt;code&gt;case&lt;/code&gt; can also be modified by using guards. The following example clarifies this. It tells us the length of a month, given the year. The year must be known, since February has 29 days in a leap year.</source>
          <target state="translated">Оба &lt;code&gt;case&lt;/code&gt; , и , &lt;code&gt;if&lt;/code&gt; есть &lt;strong&gt;возвращаемые значения&lt;/strong&gt; , то есть, в приведенном выше примере &lt;code&gt;case&lt;/code&gt; возвращается либо &lt;code&gt;{inch,X/2.54}&lt;/code&gt; или &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt; . Поведение &lt;code&gt;case&lt;/code&gt; также можно изменить с помощью ограждений. Следующий пример поясняет это. Он сообщает нам продолжительность месяца с учетом года. Год нужно знать, так как в феврале 29 дней в високосном году.</target>
        </trans-unit>
        <trans-unit id="28509f91486de7be6923a1aa53ee47118e6db5bf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; belong to the STDLIB application.</source>
          <target state="translated">И &lt;code&gt;sys&lt;/code&gt; , и &lt;code&gt;proc_lib&lt;/code&gt; принадлежат приложению STDLIB.</target>
        </trans-unit>
        <trans-unit id="da40d11cd13d54f5078c0119cec66e0ccfe5dfdd" translate="yes" xml:space="preserve">
          <source>Both building with dynamic trace probes and using them is experimental and unsupported by Erlang/OTP. It is included as an option for the developer to trace and debug performance issues in their systems.</source>
          <target state="translated">Оба здания с динамическими зондами трасс и их использование является экспериментальным и не поддерживается Erlang/OTP.Он включен в качестве опции для разработчика,чтобы отслеживать и отлаживать проблемы производительности в своих системах.</target>
        </trans-unit>
        <trans-unit id="272b41459c2a4ad1e5b3d0281a8c236f1fbb8ef5" translate="yes" xml:space="preserve">
          <source>Both clients and daemons accepts options that controls the exact behaviour. Some options are common to both. The three sets are called &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">И клиенты, и демоны принимают параметры, которые контролируют точное поведение. Некоторые варианты являются общими для обоих. Три набора называется &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43500df87c9d667061a043ba9cd51b43abef2516" translate="yes" xml:space="preserve">
          <source>Both functions are described in the following.</source>
          <target state="translated">Обе функции описаны ниже.</target>
        </trans-unit>
        <trans-unit id="8393123b8c640d62b0cc06dc60be2e57645d7426" translate="yes" xml:space="preserve">
          <source>Both increasing and decreasing &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt;s are allowed.</source>
          <target state="translated">&lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt; увеличение, так и уменьшение значений &amp;lt;IdRange&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="84d91e83adcd109e53d7f1d1718f4d0e6a80ae0d" translate="yes" xml:space="preserve">
          <source>Both mechanisms have the same theoretical time and memory complexity, while the selective receive language construct has smaller constant factors.</source>
          <target state="translated">Оба механизма имеют одинаковую теоретическую сложность по времени и памяти,в то время как конструкция языка селективного получения имеет меньшие постоянные факторы.</target>
        </trans-unit>
        <trans-unit id="c1196a55702bdb5abaf2deea06cedc05c7a896fe" translate="yes" xml:space="preserve">
          <source>Both of them can be empty, but not at the same time. If &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; is empty, no changes have been made that change the build result of any application. This could, for example, be a pure bug fix of the build system. The order of lines is undefined. All white-space characters in this file are either space (character 32) or line-break (character 10).</source>
          <target state="translated">Оба они могут быть пустыми, но не одновременно. Если &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; пуст, никаких изменений, которые изменяют результат сборки любого приложения, не было. Это может быть, например, чистое исправление ошибки в системе сборки. Порядок строк не определен. Все символы пробела в этом файле являются либо пробелом (символ 32), либо разрывом строки (символ 10).</target>
        </trans-unit>
        <trans-unit id="3442514fe2989d64511fbe704d87cbeac484a561" translate="yes" xml:space="preserve">
          <source>Both old and current code for a module are valid, and can even be evaluated concurrently. The difference is that exported functions in old code are unavailable. Hence, a global call cannot be made to an exported function in old code, but old code can still be evaluated because of processes lingering in it.</source>
          <target state="translated">Как старый,так и текущий код модуля действителен и даже может быть оценен одновременно.Разница заключается в том,что экспортируемые функции в старом коде недоступны.Следовательно,глобальный вызов экспортируемой функции в старом коде не может быть осуществлен,но старый код все равно может быть вычислен из-за затянувшихся в нем процессов.</target>
        </trans-unit>
        <trans-unit id="0a81666107cfaaf40864441b74f9792a8cc7fb8a" translate="yes" xml:space="preserve">
          <source>Both old and current code is valid, and can be evaluated concurrently. Fully qualified function calls always refer to current code. Old code can still be evaluated because of processes lingering in the old code.</source>
          <target state="translated">Как старый,так и текущий код действителен и может быть оценен одновременно.Полноценные вызовы функций всегда относятся к текущему коду.Старый код все еще может быть обработан из-за процессов,задерживающихся в старом коде.</target>
        </trans-unit>
        <trans-unit id="19893bb20867dad51e674f2c8283aa35e37963b9" translate="yes" xml:space="preserve">
          <source>Both options give the same effect, the input string is interpreted as UTF-8. Notice that with these instructions, the automatic conversion of lists to UTF-8 is not performed by the &lt;code&gt;re&lt;/code&gt; functions. Therefore, using these sequences is not recommended. Add option &lt;code&gt;unicode&lt;/code&gt; when running &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Оба варианта дают одинаковый эффект, входная строка интерпретируется как UTF-8. Обратите внимание, что с помощью этих инструкций автоматическое преобразование списков в UTF-8 не выполняется функциями &lt;code&gt;re&lt;/code&gt; . Поэтому использовать эти последовательности не рекомендуется. Вместо этого добавьте опцию &lt;code&gt;unicode&lt;/code&gt; при запуске &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04f750b6f7ecf467d03fd155880c2c08a8e8637a" translate="yes" xml:space="preserve">
          <source>Both server and event manager are registered processes which can be expected to be always accessible. Thus they are specified to be &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">И сервер, и менеджер событий - это зарегистрированные процессы, которые, как ожидается, будут всегда доступны. Таким образом, они определены как &lt;code&gt;permanent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dd8748ee1441894d656dd738cdc13c745b3ff2" translate="yes" xml:space="preserve">
          <source>Both source code and object code for the module is found.</source>
          <target state="translated">Найдены как исходный,так и объектный код модуля.</target>
        </trans-unit>
        <trans-unit id="e0ebc6ec0ff8694d627315dcce4507da48f45e45" translate="yes" xml:space="preserve">
          <source>Both the agent and the manager can be configured to log incoming and outgoing messages. It uses the Erlang standard log mechanism &lt;code&gt;disk_log&lt;/code&gt; for logging. The size and location of the log files are configurable. A wrap log is used, which means that when the log has grown to a maximum size, it starts from the beginning of the log, overwriting existing log records.</source>
          <target state="translated">И агент, и менеджер могут быть настроены для регистрации входящих и исходящих сообщений. Он использует стандартный механизм журнала Erlang &lt;code&gt;disk_log&lt;/code&gt; для ведения журнала. Размер и расположение файлов журнала можно настроить. Используется журнал переноса, что означает, что когда журнал увеличился до максимального размера, он начинается с начала журнала, перезаписывая существующие записи журнала.</target>
        </trans-unit>
        <trans-unit id="31ef6ae37976246cbbb8302e6168cf2ddacebc06" translate="yes" xml:space="preserve">
          <source>Both the module declaration and the export declaration of the &lt;code&gt;main/1&lt;/code&gt; function are optional.</source>
          <target state="translated">И объявление модуля, и экспортное объявление функции &lt;code&gt;main/1&lt;/code&gt; не являются обязательными.</target>
        </trans-unit>
        <trans-unit id="19b296fa85d6e817ce8e73a30a0d4e4ab33ce24a" translate="yes" xml:space="preserve">
          <source>Both the old and new versions of the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.rel&lt;/code&gt; files must be in the code path, as well as the &lt;code&gt;.appup&lt;/code&gt; and (new) &lt;code&gt;.beam&lt;/code&gt; files. The code path can be extended by using the option &lt;code&gt;path&lt;/code&gt;:</source>
          <target state="translated">Как старая, так и новая версии файлов &lt;code&gt;.app&lt;/code&gt; и &lt;code&gt;.rel&lt;/code&gt; должны находиться в пути кода, а также &lt;code&gt;.appup&lt;/code&gt; и (новые) &lt;code&gt;.beam&lt;/code&gt; . Путь кода может быть расширен с помощью параметра &lt;code&gt;path&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2a0efd65a8f4b932941a27e1ed06208576cd1ee" translate="yes" xml:space="preserve">
          <source>Both the registration and lock services are atomic. All nodes involved in these actions have the same view of the information.</source>
          <target state="translated">И служба регистрации,и служба запирания являются атомными.Все узлы,вовлеченные в эти действия,имеют одинаковое представление об информации.</target>
        </trans-unit>
        <trans-unit id="a1ccfade4aa63d420f2f18a1184490432f9a36ed" translate="yes" xml:space="preserve">
          <source>Both these tools use the message package (time_test.msgs) provided with the tool(s), although it can run on any message package as long as it has the same structure.</source>
          <target state="translated">Оба этих инструмента используют пакет сообщений (time_test.msgs),поставляемый вместе с инструментом(ами),хотя он может работать с любым пакетом сообщений,если имеет одинаковую структуру.</target>
        </trans-unit>
        <trans-unit id="1ccbfe9c0e689e8b9dc53b4b4ec4a1a3a8c73326" translate="yes" xml:space="preserve">
          <source>Both transport security at connection establishment and negotiated via an Inband-Security AVP are supported.</source>
          <target state="translated">Оказывается поддержка как в обеспечении транспортной безопасности при установлении соединения,так и в проведении переговоров с помощью АПП по внутриполосной безопасности.</target>
        </trans-unit>
        <trans-unit id="0c0eaabc27903558b46afc5c85515d4a1d0fc689" translate="yes" xml:space="preserve">
          <source>Bound on the expected size of incoming Diameter messages. Messages larger than the specified number of bytes are discarded.</source>
          <target state="translated">Привязка к ожидаемому размеру входящих сообщений Диаметр.Сообщения,размер которых превышает указанное количество байт,отбрасываются.</target>
        </trans-unit>
        <trans-unit id="0021328dee4879f40d348f1597841de3b466cc17" translate="yes" xml:space="preserve">
          <source>Bound parts (Erlang terms)</source>
          <target state="translated">Связанные части (термины Эрланга)</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="acd5609c99b4261f4b2a9f0f2cd2cd2a63fc35c8" translate="yes" xml:space="preserve">
          <source>Branches off an existing association &lt;code&gt;Assoc&lt;/code&gt; in a socket &lt;code&gt;Socket&lt;/code&gt; of type &lt;code&gt;seqpacket&lt;/code&gt; (one-to-many style) into a new socket &lt;code&gt;NewSocket&lt;/code&gt; of type &lt;code&gt;stream&lt;/code&gt; (one-to-one style).</source>
          <target state="translated">Разветвляет существующую ассоциацию &lt;code&gt;Assoc&lt;/code&gt; в сокете &lt;code&gt;Socket&lt;/code&gt; типа &lt;code&gt;seqpacket&lt;/code&gt; ( стиль &amp;laquo; один ко многим&amp;raquo;) в новый сокет &lt;code&gt;NewSocket&lt;/code&gt; типа &lt;code&gt;stream&lt;/code&gt; (стиль &amp;laquo;один к одному&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="7fb13ed24388f546ddc4203cc04ff019ad463378" translate="yes" xml:space="preserve">
          <source>Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths:</source>
          <target state="translated">Ответвления,которые соответствуют строкам разной длины,разрешены только на верхнем уровне lookbehind утверждения.Это расширение по сравнению с Perl,которое требует,чтобы все ветви совпадали со строками одинаковой длины.Утверждение,подобное следующему,не разрешается,так как его одна ветвь верхнего уровня может совпадать с двумя ветвями разной длины:</target>
        </trans-unit>
        <trans-unit id="e5a0f50acb3dd75574af8408fef3b88b8ceb46b5" translate="yes" xml:space="preserve">
          <source>Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs.</source>
          <target state="translated">Разрыв долговременной функции таким образом позволяет ВМ восстановить контроль между вызовами к NIF.</target>
        </trans-unit>
        <trans-unit id="8bdcc7199154fffd9f8d9a9848283a3809fc361e" translate="yes" xml:space="preserve">
          <source>Breakpoints are created and deleted using the &lt;strong&gt;Break&lt;/strong&gt; menu of either the Monitor window, View Module window, or Attach Process window.</source>
          <target state="translated">Точки останова создаются и удаляются с помощью меню &amp;laquo; &lt;strong&gt;Разрыв&amp;raquo;&lt;/strong&gt; в окне &amp;laquo;Монитор&amp;raquo;, &amp;laquo;Просмотр модуля&amp;raquo; или &amp;laquo;Присоединить процесс&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7a8d8f460f3a399bfb04e89862d06e9b316c1004" translate="yes" xml:space="preserve">
          <source>Breakpoints are marked with a stop symbol.</source>
          <target state="translated">Точки останова обозначены символом остановки.</target>
        </trans-unit>
        <trans-unit id="e0fac70209382c8083fb51c23797738064b31d35" translate="yes" xml:space="preserve">
          <source>Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches a breakpoint, it stops. This means that a breakpoint must be set at an executable line, that is, a code line containing an executable expression.</source>
          <target state="translated">Точки останова задаются на линейной основе.Когда процесс,выполняющий код в интерпретируемом модуле,достигает точки останова,он останавливается.Это означает,что точка останова должна быть установлена в исполняемой строке,т.е.в строке кода,содержащей исполняемое выражение.</target>
        </trans-unit>
        <trans-unit id="fbbe2bd05741e651732db1439c4df7101add2a7e" translate="yes" xml:space="preserve">
          <source>Briefly on Solaris 10</source>
          <target state="translated">Кратко о Солярисе 10</target>
        </trans-unit>
        <trans-unit id="2c54c32cef81a294e27f0b55c17e9d3989656be7" translate="yes" xml:space="preserve">
          <source>Broadcasts on a condition variable. That is, if other threads are waiting on the condition variable being broadcast on, &lt;strong&gt;all&lt;/strong&gt; of them are woken.</source>
          <target state="translated">Рассылает по переменной условия. То есть, если другие потоки ожидают широковещательной передачи переменной условия, &lt;strong&gt;все&lt;/strong&gt; они будут разбужены.</target>
        </trans-unit>
        <trans-unit id="298841afbb7ef24f7711e916938def078c174299" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; asynchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">Транслирует сообщение &lt;code&gt;Msg&lt;/code&gt; асинхронно зарегистрированного процесса &lt;code&gt;Name&lt;/code&gt; на указанных узлах.</target>
        </trans-unit>
        <trans-unit id="0e9067bfac6a20153ac4defbe476694c9b168a4a" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; synchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">Транслирует сообщение &lt;code&gt;Msg&lt;/code&gt; синхронно зарегистрированного процесса &lt;code&gt;Name&lt;/code&gt; на указанных узлах.</target>
        </trans-unit>
        <trans-unit id="e87af70cba1f1e451d37824609594b2a73b9bafc" translate="yes" xml:space="preserve">
          <source>Browse the application configuration file (do &lt;strong&gt;not&lt;/strong&gt; edit it). The full name of the application configuration file is derived from the position of the &lt;code&gt;os_mon&lt;/code&gt; application in the file system by adding &lt;code&gt;/ebin/os_mon.app&lt;/code&gt;.</source>
          <target state="translated">Просмотрите файл конфигурации приложения ( &lt;strong&gt;не&lt;/strong&gt; редактируйте его). Полное имя файла конфигурации приложения определяется положением приложения &lt;code&gt;os_mon&lt;/code&gt; в файловой системе путем добавления &lt;code&gt;/ebin/os_mon.app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d698cd7b5307da0633f70f00f726e5dbe00ea1a" translate="yes" xml:space="preserve">
          <source>Browses table &lt;code&gt;Tab&lt;/code&gt; on a terminal.</source>
          <target state="translated">Таблица просматривает &lt;code&gt;Tab&lt;/code&gt; на терминал.</target>
        </trans-unit>
        <trans-unit id="f47b617427a681f5cc68845744e7adc91ae07ed8" translate="yes" xml:space="preserve">
          <source>Browsing the html pages by loading the page &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; or &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; if the prefix option has been used.</source>
          <target state="translated">Просмотр html-страниц путем загрузки страницы &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; или &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; , если использовалась опция префикса.</target>
        </trans-unit>
        <trans-unit id="792fdd1cd5fd403216843c6560d9bf75c37a3a2e" translate="yes" xml:space="preserve">
          <source>Buf is initialized to contain object attributes.</source>
          <target state="translated">Buf инициализируется,чтобы содержать атрибуты объекта.</target>
        </trans-unit>
        <trans-unit id="3caca7ca1e839168f274364c9d0c4a80119c3d3a" translate="yes" xml:space="preserve">
          <source>Buffer is too small.</source>
          <target state="translated">Буфер слишком маленький.</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="5e39e7697b21824bcc7130368908ca3db3109308" translate="yes" xml:space="preserve">
          <source>Build Erlang/OTP</source>
          <target state="translated">Построить Эрланг/ОТП</target>
        </trans-unit>
        <trans-unit id="da71556c2060cac2828b51ce118c10a5f1cb07b2" translate="yes" xml:space="preserve">
          <source>Build Issues</source>
          <target state="translated">Проблемы построения</target>
        </trans-unit>
        <trans-unit id="82de423db4cc623ec5f04ba52bfec4b055f722a1" translate="yes" xml:space="preserve">
          <source>Build or install the FIPS Object Module and a FIPS enabled OpenSSL library.</source>
          <target state="translated">Сборка или установка объектного модуля FIPS и библиотеки OpenSSL с поддержкой FIPS.</target>
        </trans-unit>
        <trans-unit id="0ca44d234eb0f2b9b591c5ee4decd555e8ce199c" translate="yes" xml:space="preserve">
          <source>Build the Erlang/OTP release.</source>
          <target state="translated">Постройте релиз Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="07f491f3b5c090f34f2ee3e97cafbb3c5f5f8099" translate="yes" xml:space="preserve">
          <source>Build the boot script.</source>
          <target state="translated">Постройте загрузочный скрипт.</target>
        </trans-unit>
        <trans-unit id="77d5d2f2a5f4a3ffbde6ae0d3e363ac721059f26" translate="yes" xml:space="preserve">
          <source>Build the documentation.</source>
          <target state="translated">Постройте документацию.</target>
        </trans-unit>
        <trans-unit id="55d9080383317c03f360d21bbd25b0561e946784" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. Note that &lt;code&gt;otp_build configure&lt;/code&gt; will produce a default configuration that differs from what &lt;code&gt;configure&lt;/code&gt; will produce by default. For example, currently &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; is added to the &lt;code&gt;configure&lt;/code&gt; command line arguments unless &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; has been explicitly passed. The binary releases that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;. The defaults used by &lt;code&gt;otp_build configure&lt;/code&gt; may change at any time without prior notice.</source>
          <target state="translated">Сборка Erlang / OTP может быть выполнена либо с помощью &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; , либо путем &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; вызова $ ERL_TOP / configure и &lt;code&gt;make&lt;/code&gt; . Сборка с использованием &lt;code&gt;otp_build&lt;/code&gt; проще, поскольку она включает меньше шагов, но &lt;code&gt;otp_build&lt;/code&gt; сборки otp_build не так гибка, как процедура сборки &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; . Обратите внимание, что &lt;code&gt;otp_build configure&lt;/code&gt; по умолчанию, которая отличается от той, которую &lt;code&gt;configure&lt;/code&gt; создаст по умолчанию. Например, в настоящее время &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; добавляется к аргументам командной строки &lt;code&gt;configure&lt;/code&gt; , если &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; был явно пропущен. &lt;code&gt;otp_build&lt;/code&gt; нами бинарные выпуски созданы с использованием otp_build . Значения по умолчанию, используемые &lt;code&gt;otp_build configure&lt;/code&gt; могут измениться в любое время без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="0288be29544ae6b8e621446c1d716ba731ebd705" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. The binary releases for Windows that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;.</source>
          <target state="translated">Сборка Erlang / OTP может быть выполнена либо с помощью &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; , либо путем &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; вызова $ ERL_TOP / configure и &lt;code&gt;make&lt;/code&gt; . Сборка с использованием &lt;code&gt;otp_build&lt;/code&gt; проще, так как она включает меньше шагов, но &lt;code&gt;otp_build&lt;/code&gt; сборки otp_build не так гибка, как процедура сборки &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; . &lt;code&gt;otp_build&lt;/code&gt; нами двоичные выпуски для Windows созданы с использованием otp_build .</target>
        </trans-unit>
        <trans-unit id="f9a1d72262f0ba28560224e8b5f84f82d3a37931" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP on a relatively fast computer takes approximately 5 minutes. To speed it up, you can utilize parallel make with the &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">Сборка Erlang / OTP на относительно быстром компьютере занимает примерно 5 минут. Чтобы ускорить его, вы можете использовать параллельную &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; с параметром -j &amp;lt;num_jobs&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="9ef5793998a525a29078ba78dcc6651a8e69241f" translate="yes" xml:space="preserve">
          <source>Building a Bootstrap System</source>
          <target state="translated">Строительство системы Bootstrap</target>
        </trans-unit>
        <trans-unit id="6fcd9e84832d8fc06ff9412088752b9ac40d1d27" translate="yes" xml:space="preserve">
          <source>Building in Git</source>
          <target state="translated">Здание в Гите</target>
        </trans-unit>
        <trans-unit id="6e610827003738b99e768b26958b3f36694ff33c" translate="yes" xml:space="preserve">
          <source>Building is easiest using the &lt;code&gt;otp_build&lt;/code&gt; script:</source>
          <target state="translated">Строить проще всего с &lt;code&gt;otp_build&lt;/code&gt; скрипта otp_build :</target>
        </trans-unit>
        <trans-unit id="840f8d32dc79d0e6d7906ca187022ffdcd65d433" translate="yes" xml:space="preserve">
          <source>Building on OS X</source>
          <target state="translated">Основанная на ОС X</target>
        </trans-unit>
        <trans-unit id="0919d6c99c47efcb70329ed0ebdeb92cd58e964c" translate="yes" xml:space="preserve">
          <source>Building terms and patterns</source>
          <target state="translated">Строительные условия и модели</target>
        </trans-unit>
        <trans-unit id="d7b4eea65f50794546e0a9cd2e50530baa9d4e3f" translate="yes" xml:space="preserve">
          <source>Building with wxErlang</source>
          <target state="translated">Здание с wxErlang</target>
        </trans-unit>
        <trans-unit id="03d9659d4e51ca391a6e1291a5a6e5195ec7e16f" translate="yes" xml:space="preserve">
          <source>Building with wxWidgets. Download wxWidgets-3.0.3 or higher.</source>
          <target state="translated">Здание с wxWidgets.Скачать wxWidgets-3.0.3 или выше.</target>
        </trans-unit>
        <trans-unit id="5a48efe1163ff4f604b0e75b0f8069e848d42294" translate="yes" xml:space="preserve">
          <source>Builds a BEAM module (as a binary) from a list of chunks.</source>
          <target state="translated">Строит модуль BEAM (в виде бинарного файла)из списка блоков.</target>
        </trans-unit>
        <trans-unit id="04266b7610bbe7204641a5a18f1b641cc5a4ad92" translate="yes" xml:space="preserve">
          <source>Builds an internal structure representing a compilation of a search pattern, later to be used in functions &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;cp()&lt;/code&gt; returned is guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">Создает внутреннюю структуру, представляющую компиляцию шаблона поиска, которая позже будет использоваться в функциях &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; , match &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;cp()&lt;/code&gt; возвращается гарантированно быть &lt;code&gt;tuple()&lt;/code&gt; , чтобы программы , чтобы отличить его от не-скомпилированных шаблонов поиска.</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="3685c8c87d2a5725cbc54a94228a1a89d1d88a57" translate="yes" xml:space="preserve">
          <source>Built-in term storage.</source>
          <target state="translated">Встроенное срочное хранилище.</target>
        </trans-unit>
        <trans-unit id="5849712291c78b1a99987a87b4b4819b9538fc4d" translate="yes" xml:space="preserve">
          <source>But if a constant is sent to another process (or stored in an Ets table), it is &lt;strong&gt;copied&lt;/strong&gt;. The reason is that the runtime system must be able to keep track of all references to constants to unload code containing constants properly. (When the code is unloaded, the constants are copied to the heap of the processes that refer to them.) The copying of constants might be eliminated in a future Erlang/OTP release.</source>
          <target state="translated">Но если константа отправляется другому процессу (или сохраняется в таблице Ets), она &lt;strong&gt;копируется&lt;/strong&gt; . Причина в том, что исполняющая система должна иметь возможность отслеживать все ссылки на константы, чтобы правильно выгрузить код, содержащий константы. (Когда код выгружается, константы копируются в кучу процессов, которые на них ссылаются.) Копирование констант может быть исключено в будущих выпусках Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="12383ec381d6eef21e12692f3a3beac567f979cb" translate="yes" xml:space="preserve">
          <source>But in more complicated code, how can one know whether the optimization is applied or not?</source>
          <target state="translated">Но в более сложном коде,как узнать,применяется оптимизация или нет?</target>
        </trans-unit>
        <trans-unit id="13e80088d58b6e2e78ae703a190df34ce17a3ab1" translate="yes" xml:space="preserve">
          <source>But it will generate code that builds a sub binary in the first clause:</source>
          <target state="translated">Но в первом пункте он сгенерирует код,который построит поддвоичный файл:</target>
        </trans-unit>
        <trans-unit id="a0a27a5b2ec989d8d33e3ef99ff2c029f3ccadb0" translate="yes" xml:space="preserve">
          <source>But that is history. Funs was given its own data type in R6B and was further optimized in R7B. Now the cost for a fun call falls roughly between the cost for a call to a local function and &lt;code&gt;apply/3&lt;/code&gt;.</source>
          <target state="translated">Но это уже история. Funs получил собственный тип данных в R6B и был дополнительно оптимизирован в R7B. Теперь стоимость забавного вызова находится примерно между стоимостью вызова локальной функции и &lt;code&gt;apply/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9edeffd1c02cedcbcf042627c2b5c0c907cde008" translate="yes" xml:space="preserve">
          <source>But this fails as Fred has already logged off.</source>
          <target state="translated">Но это не удается,так как Фред уже вышел из игры.</target>
        </trans-unit>
        <trans-unit id="3c55fef2a765c8d16ab4eacfbd4c2a04ae1406db" translate="yes" xml:space="preserve">
          <source>But this fails:</source>
          <target state="translated">Но это не удается:</target>
        </trans-unit>
        <trans-unit id="ae29bf624e4dd4338883041af300ffb73e4829e9" translate="yes" xml:space="preserve">
          <source>But this is not enough. There is also a set of &lt;strong&gt;mandatory&lt;/strong&gt; messages which the network interface entity must be able to receive and be able to send. This is described in chapter &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Но этого недостаточно. Также существует набор &lt;strong&gt;обязательных&lt;/strong&gt; сообщений, которые объект сетевого интерфейса должен иметь возможность получать и отправлять. Это описано в главе &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45778b54cb8ef168c982efffe69e2d8b502fce93" translate="yes" xml:space="preserve">
          <source>But using &lt;code&gt;++&lt;/code&gt; as follows is not bad:</source>
          <target state="translated">Но использовать &lt;code&gt;++&lt;/code&gt; следующим образом неплохо:</target>
        </trans-unit>
        <trans-unit id="521274df22007097293748284fe185141e772a3c" translate="yes" xml:space="preserve">
          <source>But you realize that it is unnecessary to have the Erlang compiler in this one:</source>
          <target state="translated">Но вы понимаете,что в этом компиляторе Erlang нет необходимости:</target>
        </trans-unit>
        <trans-unit id="94852e93461c3ce16031709d1ba53f77338d1422" translate="yes" xml:space="preserve">
          <source>But, if we nevertheless &lt;strong&gt;do&lt;/strong&gt; dig down we find the call to the linked in driver that does the file operations towards the host operating system:</source>
          <target state="translated">Но если мы все &lt;strong&gt;же&lt;/strong&gt; раскопаемся, мы обнаружим вызов связанного драйвера, который выполняет файловые операции с операционной системой хоста:</target>
        </trans-unit>
        <trans-unit id="aaa9717eecd88e22102280721e33d90c4f0a390a" translate="yes" xml:space="preserve">
          <source>By &lt;strong&gt;attaching to&lt;/strong&gt; a process executing interpreted code, it is possible to examine variable bindings and order stepwise execution. This is done by sending and receiving information to/from the process through a third process, called the meta process. You can implement your own attached process. See &lt;code&gt;int.erl&lt;/code&gt; for available functions and &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; for possible messages.</source>
          <target state="translated">По &lt;strong&gt;прикрепляться к&lt;/strong&gt; процессу исполняющего интерпретируемому кода, можно исследовать привязки переменных и выполнение заказа ступенчатого. Это осуществляется путем отправки и получения информации в / из процесса через третий процесс, называемый метапроцессом. Вы можете реализовать свой собственный прикрепленный процесс. См. &lt;code&gt;int.erl&lt;/code&gt; для доступных функций и &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; для возможных сообщений.</target>
        </trans-unit>
        <trans-unit id="5e25689214717ab6f387eff1ce87fefe79882799" translate="yes" xml:space="preserve">
          <source>By SASL reports we mean supervisor reports, crash reports and progress reports.</source>
          <target state="translated">Под отчетами SASL мы понимаем отчеты супервайзеров,отчеты о дорожно-транспортных происшествиях и отчеты о прогрессе.</target>
        </trans-unit>
        <trans-unit id="61329f5b77a1e8f4de56300ae6baa6480eff0a5f" translate="yes" xml:space="preserve">
          <source>By calling &lt;code&gt;blend/2&lt;/code&gt; on any color term created by &lt;code&gt;new/4&lt;/code&gt;, the resulting color can be calculated as determined by the two map terms.</source>
          <target state="translated">Вызывая &lt;code&gt;blend/2&lt;/code&gt; для любого элемента цвета, созданного с помощью &lt;code&gt;new/4&lt;/code&gt; , можно рассчитать результирующий цвет, определяемый двумя терминами карты.</target>
        </trans-unit>
        <trans-unit id="6e21b8bafe38feea973da163115371fd334e57e8" translate="yes" xml:space="preserve">
          <source>By calling function &lt;code&gt;info/0&lt;/code&gt; in a generated module, you get information about which compiler options were used.</source>
          <target state="translated">Вызывая функцию &lt;code&gt;info/0&lt;/code&gt; в сгенерированном модуле, вы получаете информацию о том, какие параметры компилятора использовались.</target>
        </trans-unit>
        <trans-unit id="817528d15c927d91ed8c4901f6bd96f0b70a6a47" translate="yes" xml:space="preserve">
          <source>By clicking the name in the column header of any table (for example, &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;, and so on), the table rows are sorted in whatever order makes sense for the type of value (for example, numerical for &quot;Ok&quot; or &quot;Time&quot;, and alphabetical for &quot;Case&quot;). The sorting is performed through JavaScript code, automatically inserted into the HTML log files. &lt;code&gt;Common Test&lt;/code&gt; uses the &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; library and the &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; plugin, with customized sorting functions, for this implementation.</source>
          <target state="translated">Если щелкнуть имя в заголовке столбца любой таблицы (например, &amp;laquo;ОК&amp;raquo;, &amp;laquo;Случай&amp;raquo;, &amp;laquo;Время&amp;raquo; и т. Д.), Строки таблицы будут отсортированы в любом порядке, имеющем смысл для типа значения (например, , числовой для &amp;laquo;Ок&amp;raquo; или &amp;laquo;Время&amp;raquo; и алфавитный для &amp;laquo;Случай&amp;raquo;). Сортировка выполняется с помощью кода JavaScript, который автоматически вставляется в файлы журнала HTML. &lt;code&gt;Common Test&lt;/code&gt; использует для этой реализации библиотеку &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; и плагин &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; с настраиваемыми функциями сортировки.</target>
        </trans-unit>
        <trans-unit id="3e3f09bd43c71064511228990649461289b5c148" translate="yes" xml:space="preserve">
          <source>By configuration, you can also modify or disable the default handler, replace it by a custom handler, and install additional handlers.</source>
          <target state="translated">По умолчанию вы также можете изменить или отключить обработчик по умолчанию,заменить его на пользовательский обработчик,а также установить дополнительные обработчики.</target>
        </trans-unit>
        <trans-unit id="65dc91babe6148c48d235004a31fddc4c1120398" translate="yes" xml:space="preserve">
          <source>By convention, most Built-In Functions (BIFs) are included in this module. Some of the BIFs are viewed more or less as part of the Erlang programming language and are &lt;strong&gt;auto-imported&lt;/strong&gt;. Thus, it is not necessary to specify the module name. For example, the calls &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; and &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; are identical.</source>
          <target state="translated">По соглашению, в этот модуль включено большинство встроенных функций (BIF). Некоторые из BIF рассматриваются более или менее как часть языка программирования Erlang и &lt;strong&gt;импортируются автоматически&lt;/strong&gt; . Таким образом, указывать имя модуля необязательно. Например, вызовы &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; и &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; идентичны.</target>
        </trans-unit>
        <trans-unit id="082c66d79fe52cb570696433b4792152063b55b2" translate="yes" xml:space="preserve">
          <source>By convention, the name of a tar file is to end in &quot;&lt;code&gt;.tar&lt;/code&gt;&quot;. To abide to the convention, add &quot;&lt;code&gt;.tar&lt;/code&gt;&quot; to the name.</source>
          <target state="translated">По соглашению имя файла tar должно заканчиваться на &amp;laquo; &lt;code&gt;.tar&lt;/code&gt; &amp;raquo;. Чтобы соблюдать соглашение, добавьте к имени &quot; &lt;code&gt;.tar&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="e51e93220df3f4bd5dc8a32795232ab13e7f0c15" translate="yes" xml:space="preserve">
          <source>By convention, the name of a zip file is to end with &lt;code&gt;.zip&lt;/code&gt;. To abide to the convention, add &lt;code&gt;.zip&lt;/code&gt; to the filename.</source>
          <target state="translated">По соглашению имя zip-файла должно заканчиваться на &lt;code&gt;.zip&lt;/code&gt; . Чтобы соблюдать соглашение, добавьте к имени файла &lt;code&gt;.zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="458ef8621b4f7c4ee2bf42d5b9e1f263171a21fb" translate="yes" xml:space="preserve">
          <source>By default 16 files are merged at a time. This option is rarely needed.</source>
          <target state="translated">По умолчанию одновременно объединяются 16 файлов.Эта опция используется редко.</target>
        </trans-unit>
        <trans-unit id="f916c5ec73659e63b033b011cdae7b63d48ef9e3" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 100 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;Mnesia&lt;/code&gt; выгружает журнал, когда в журнал записано 100 записей, или по прошествии трех минут. Это контролируется двумя параметрами приложения &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; и &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e33f74e5fe8c2a189ae75982a8ae0619e585aa16" translate="yes" xml:space="preserve">
          <source>By default SSL/TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="translated">По умолчанию SSL / TLS запускается по протоколу TCP / IP, даже если вы можете подключить любой другой надежный транспортный протокол с тем же интерфейсом прикладного программирования (API), что и модуль &lt;code&gt;gen_tcp&lt;/code&gt; в ядре. DTLS по умолчанию выполняется через UDP / IP, что означает, что данные приложения не имеют гарантий доставки. Другие транспорты, такие как SCTP, могут поддерживаться в будущих выпусках.</target>
        </trans-unit>
        <trans-unit id="55b91f316a10114e643a738ef56cbce119a92d15" translate="yes" xml:space="preserve">
          <source>By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed.</source>
          <target state="translated">По умолчанию около 512*1024 байт,считанных из файлов,отсортировано внутренне.Эта опция используется редко.</target>
        </trans-unit>
        <trans-unit id="1e8fa96214b81833eb829752ba3cb11f2aac75f4" translate="yes" xml:space="preserve">
          <source>By default in OTP 17, the representation of the &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; types as Erlang terms were changed. &lt;code&gt;BIT STRING&lt;/code&gt; values are now Erlang bit strings and &lt;code&gt;OCTET STRING&lt;/code&gt; values are binaries. Also, an undecoded open type is now wrapped in an &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; tuple. For details, see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">По умолчанию в OTP 17 представление типов &lt;code&gt;BIT STRING&lt;/code&gt; и &lt;code&gt;OCTET STRING&lt;/code&gt; как терминов Erlang было изменено. Значения &lt;code&gt;BIT STRING&lt;/code&gt; теперь являются битовыми строками Erlang, а значения &lt;code&gt;OCTET STRING&lt;/code&gt; - двоичными. Кроме того, незакодированный открытый тип теперь заключен в кортеж &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; . Для получения дополнительной информации см. &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt; и ASN.1 в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="9dc86d1dada42ddb164640d0be1c9cd268646f6a" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be.</source>
          <target state="translated">По умолчанию она не включена,но если эта опция присутствует,то будет.</target>
        </trans-unit>
        <trans-unit id="c97804b0eee285b037a2d076e7ba516d0e16e389" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be. The reference text will be placed in the allocList field of the mib-entry record (#me{}) for the table.</source>
          <target state="translated">По умолчанию она не включена,но если эта опция присутствует,то будет.Текст ссылки будет помещен в поле allocationList записи mib-entry (#me{})для таблицы.</target>
        </trans-unit>
        <trans-unit id="a4cb7bdb00bc5f4f34ca644e957ab5ac212ab81d" translate="yes" xml:space="preserve">
          <source>By default on such systems, Erlang starts in &lt;code&gt;utf8&lt;/code&gt; filename mode if the terminal supports UTF-8, otherwise in &lt;code&gt;latin1&lt;/code&gt; mode.</source>
          <target state="translated">По умолчанию в таких системах Erlang запускается в режиме имени файла &lt;code&gt;utf8&lt;/code&gt; , если терминал поддерживает UTF-8, в противном случае - в режиме &lt;code&gt;latin1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66001038963df69c701cdea04de30818e23ced2f" translate="yes" xml:space="preserve">
          <source>By default only the running target is available, unless the server includes &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; in its list of capabilities.</source>
          <target state="translated">По умолчанию доступна только текущая цель, если сервер не включает &lt;code&gt;:candidate&lt;/code&gt; или &lt;code&gt;:startup&lt;/code&gt; в свой список возможностей.</target>
        </trans-unit>
        <trans-unit id="b1f41b809750734c802dac0f55be66baad734531" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Application inclusion policy&lt;/code&gt; on system level is used for all applications. Set the value to &lt;code&gt;include&lt;/code&gt; if you want to explicitly include one particular application. Set it to &lt;code&gt;exclude&lt;/code&gt; if you want to exclude the application despite that it is used by another (explicitly or implicitly) included application. &lt;code&gt;derived&lt;/code&gt; means that the application automatically will be included if some other (explicitly or implicitly) included application uses it.</source>
          <target state="translated">По умолчанию для всех приложений применяется &lt;code&gt;Application inclusion policy&lt;/code&gt; на системном уровне. Установите значение для &lt;code&gt;include&lt;/code&gt; если вы хотите явно включить одно конкретное приложение. Установите для него значение &lt;code&gt;exclude&lt;/code&gt; , если вы хотите исключить приложение, несмотря на то, что оно используется другим (явно или неявно) включенным приложением. &lt;code&gt;derived&lt;/code&gt; означает, что приложение будет автоматически включено, если какое-либо другое (явно или неявно) включенное приложение использует его.</target>
        </trans-unit>
        <trans-unit id="3bb33b9d4c2d5314003279505372f2bd591c4469" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Module inclusion policy&lt;/code&gt; on system level is used for all applications. Set it to &lt;code&gt;derived&lt;/code&gt; if you only want actually used modules to be included. Set it to &lt;code&gt;app&lt;/code&gt; if you, besides derived modules, also want the modules listed in the app file to be included. Set it to &lt;code&gt;ebin&lt;/code&gt; if you, besides derived modules, also want the modules that exist as beam files in the ebin directory to be included. Set it to &lt;code&gt;all&lt;/code&gt; if you want all modules to be included, that is the union of modules found in the ebin directory and listed in the app file.</source>
          <target state="translated">По умолчанию для всех приложений применяется &lt;code&gt;Module inclusion policy&lt;/code&gt; на системном уровне. Установите его на &lt;code&gt;derived&lt;/code&gt; если вы хотите, чтобы были включены только фактически используемые модули. Установите для него значение &lt;code&gt;app&lt;/code&gt; , если вы, помимо производных модулей, также хотите, чтобы были включены модули, перечисленные в файле приложения. Установите для него значение &lt;code&gt;ebin&lt;/code&gt; , если вы, помимо производных модулей, также хотите, чтобы были включены модули, существующие как файлы лучей в каталоге ebin. Установите значение &lt;code&gt;all&lt;/code&gt; , если вы хотите, чтобы были включены все модули, то есть объединение модулей, найденных в каталоге ebin и перечисленных в файле приложения.</target>
        </trans-unit>
        <trans-unit id="81c493b42c1c2d3836dadd1b1f65d1b4066bbbb2" translate="yes" xml:space="preserve">
          <source>By default the EPMD listens on port 4369.</source>
          <target state="translated">По умолчанию EPMD прослушивает порт 4369.</target>
        </trans-unit>
        <trans-unit id="60c9fed0b81fb4b980269d86433bdb1dec183e3e" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it.</source>
          <target state="translated">По умолчанию клиенты TLS/DTLS пытаются повторно использовать доступный сеанс,а по умолчанию серверы TLS/DTLS соглашаются повторно использовать сеансы,когда клиенты просят об этом.</target>
        </trans-unit>
        <trans-unit id="40a1d269c0b2f20066064de554ea4fe767edbe1b" translate="yes" xml:space="preserve">
          <source>By default the currently stored events (existing) are written to a brand new file (write) and the events are kept (keep) after they have been written to the file.</source>
          <target state="translated">По умолчанию текущие (существующие)события записываются в новый файл (запись),а события сохраняются (сохраняются)после записи в файл.</target>
        </trans-unit>
        <trans-unit id="b301155fe91b7f29a76df23651c02320368fef48" translate="yes" xml:space="preserve">
          <source>By default the flex scanner reports line-number of an error. But it can be built without line-number reporting. Instead token number is used. This will speed up the scanning some 5-10%. Use &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; when configuring the application.</source>
          <target state="translated">По умолчанию сканер гибкости сообщает номер строки ошибки. Но его можно построить и без отчетности по номерам строк. Вместо этого используется номер токена. Это ускорит сканирование примерно на 5-10%. При настройке приложения используйте &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c20eaae0e3f3676678ff09602bb8cee954cea155" translate="yes" xml:space="preserve">
          <source>By default the socket options set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; are used when establishing a connection.</source>
          <target state="translated">По умолчанию параметры сокета, заданные функцией &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; , используются при установлении соединения.</target>
        </trans-unit>
        <trans-unit id="ec72fa4eac79a3cc871f1f0e43828e92af1bb91b" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">По умолчанию коррекция времени включена, если она поддерживается на конкретной платформе. Его поддержка включает как монотонное время ОС, обеспечиваемое ОС, так и реализацию в системе времени выполнения Erlang с использованием монотонного времени ОС. Чтобы проверить, поддерживает ли ваша система монотонное время ОС, вызовите &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; . Чтобы проверить, включена ли коррекция времени в вашей системе, вызовите &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ceb9ebe7b981aea32343aa2ebada87a65d18c16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; fetches trace logs and trace information files from all nodes. The logs are stored in a new directory named &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; under the working directory of the trace control node. Fetching can be disabled by providing option &lt;code&gt;nofetch&lt;/code&gt; to &lt;code&gt;ttb:stop/1&lt;/code&gt;. The user can specify a fetch directory by passing option &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; извлекает журналы трассировки и файлы информации трассировки со всех узлов. Журналы хранятся в новом каталоге с именем &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; в рабочем каталоге узла управления трассировкой. Извлечение можно отключить, &lt;code&gt;nofetch&lt;/code&gt; параметр nofetch для &lt;code&gt;ttb:stop/1&lt;/code&gt; . Пользователь может указать каталог для выборки, передав параметр &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e28d91aead7c4c840b960191290c3223a7f6126a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Char&lt;/code&gt; is &lt;code&gt;$\s&lt;/code&gt; and &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;trailing&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;Char&lt;/code&gt; - это &lt;code&gt;$\s&lt;/code&gt; а &lt;code&gt;Dir&lt;/code&gt; - в &lt;code&gt;trailing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="071766231ebcbb0e6dd0a89742db95d7cd2d08e3" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Common Test&lt;/code&gt; creates one central private directory per test run, shared by all test cases. This is not always suitable. Especially if the same test cases are executed multiple times during a test run (that is, if they belong to a test case group with property &lt;code&gt;repeat&lt;/code&gt;) and there is a risk that files in the private directory get overwritten. Under these circumstances, &lt;code&gt;Common Test&lt;/code&gt; can be configured to create one dedicated private directory per test case and execution instead. This is accomplished with the flag/option &lt;code&gt;create_priv_dir&lt;/code&gt; (to be used with the &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program, the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; function, or as test specification term). There are three possible values for this option as follows:</source>
          <target state="translated">По умолчанию &lt;code&gt;Common Test&lt;/code&gt; создает один центральный частный каталог на каждый тестовый запуск, общий для всех тестовых случаев. Это не всегда подходит. Особенно, если одни и те же тестовые примеры выполняются несколько раз во время тестового прогона (то есть, если они принадлежат группе тестовых примеров со свойством &lt;code&gt;repeat&lt;/code&gt; ) и существует риск перезаписи файлов в частном каталоге. В этих условиях &lt;code&gt;Common Test&lt;/code&gt; может быть настроен на создание одного выделенного частного каталога для каждого тестового примера и выполнения. Это достигается с помощью флага / опции &lt;code&gt;create_priv_dir&lt;/code&gt; (для использования с программой &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; функция, или как термин спецификации теста). Для этой опции есть три возможных значения:</target>
        </trans-unit>
        <trans-unit id="bc3169458b9c52d0cd7a98448830679fb2a8731a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;leading&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;Dir&lt;/code&gt; является &lt;code&gt;leading&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28f74729db7b0c3b278863ef6db06bd5bab6afe7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ERTS&lt;/code&gt; is only guaranteed to be compatible with other Erlang/OTP components from the same release as &lt;code&gt;ERTS&lt;/code&gt; itself.</source>
          <target state="translated">По умолчанию гарантируется совместимость &lt;code&gt;ERTS&lt;/code&gt; только с другими компонентами Erlang / OTP из того же выпуска, что и сама &lt;code&gt;ERTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d10644009649e0b88125d8c14d6cdb3379fe167" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Norm&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;IgnoreCase&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , а &lt;code&gt;Norm&lt;/code&gt; - &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d6341953fcce030f785b04ed13be99fb6431b5" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;Length&lt;/code&gt; равна &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="737dbf79ae1fa944f9b53b6e9f296655a6f7aa71" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;relup&lt;/code&gt; file is located in the current working directory. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, the &lt;code&gt;relup&lt;/code&gt; file is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">По умолчанию файл &lt;code&gt;relup&lt;/code&gt; находится в текущем рабочем каталоге. Если &lt;code&gt;{outdir,Dir}&lt;/code&gt; параметр {outdir, Dir} , &lt;code&gt;relup&lt;/code&gt; файл повторной установки находится в &lt;code&gt;Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e5740833bc9a00277b2eef37e4a06e9efa51635" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the &lt;code&gt;proc_lib&lt;/code&gt; module.</source>
          <target state="translated">По умолчанию &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; если информация о начальном вызове не может быть найдена. Предполагается, что вызывающий знает, что процесс был порожден модулем &lt;code&gt;proc_lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a09da640fbd6b16e4c97f30cbf385b23a15ab05" translate="yes" xml:space="preserve">
          <source>By default, Debugger only saves information about recursive function calls, that is, function calls that have not yet returned a value (option &lt;strong&gt;Stack On, No Tail&lt;/strong&gt;).</source>
          <target state="translated">По умолчанию Debugger сохраняет информацию только о рекурсивных вызовах функций, то есть о вызовах функций, которые еще не вернули значение (опция &lt;strong&gt;Stack On, No Tail&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb83760fc1df1215ce919183bfc30967f2391d71" translate="yes" xml:space="preserve">
          <source>By default, Dialyzer caches the results of native compilation in directory &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt;. &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; defaults to &lt;code&gt;$HOME/.cache&lt;/code&gt;. Use this option to disable caching.</source>
          <target state="translated">По умолчанию Dialyzer кэширует результаты собственной компиляции в каталоге &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt; . &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; по умолчанию - &lt;code&gt;$HOME/.cache&lt;/code&gt; . Используйте эту опцию, чтобы отключить кеширование.</target>
        </trans-unit>
        <trans-unit id="ca501566661fba6186a204103ba54062fe33920b" translate="yes" xml:space="preserve">
          <source>By default, Erlang is started so that only the &lt;code&gt;latin1&lt;/code&gt; range of characters indicate that a list of integers is a string.</source>
          <target state="translated">По умолчанию Erlang запускается так, что только диапазон символов &lt;code&gt;latin1&lt;/code&gt; указывает, что список целых чисел является строкой.</target>
        </trans-unit>
        <trans-unit id="8a82754162a45a0d73de414ecadee9a7ddca8c1b" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="translated">По умолчанию Erlang обнаруживает только списки символов в диапазоне Latin-1 как строки, но для изменения этого можно использовать флаг &lt;code&gt;+pc unicode&lt;/code&gt; (подробности см. В &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="ddfb5846cc6e75b4d26cdc33d2870cc55885837f" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; option.</source>
          <target state="translated">По умолчанию выпуск Erlang / OTP будет установлен в &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; . Если у вас, например, нет разрешения на установку в стандартном месте, вы можете установить Erlang / OTP в другом месте. Например, для установки в &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt; используйте параметр &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="449ac9961843b5846b7c02a09a67a56c7a856de8" translate="yes" xml:space="preserve">
          <source>By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (&lt;code&gt;^&lt;/code&gt;) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (&lt;code&gt;$&lt;/code&gt;) matches only at the end of the string, or before a terminating newline (unless option &lt;code&gt;dollar_endonly&lt;/code&gt; is specified). This is the same as in Perl.</source>
          <target state="translated">По умолчанию PCRE рассматривает строку темы как состоящую из одной строки символов (даже если она содержит символы новой строки). &amp;laquo;Начало строки&amp;raquo; метасимвол ( &lt;code&gt;^&lt;/code&gt; ) совпадает только в начале строки, в то время как &amp;laquo;конец строки&amp;raquo; метасимвол ( &lt;code&gt;$&lt;/code&gt; ) совпадает только в конце строки или перед символ новой строки (если опция &lt;code&gt;dollar_endonly&lt;/code&gt; не указана ). Это то же самое, что и в Perl.</target>
        </trans-unit>
        <trans-unit id="c5979203f447d5bf52653ed357687aa3ce1b0b5f" translate="yes" xml:space="preserve">
          <source>By default, a breakpoint is active, has trigger action &lt;code&gt;enable&lt;/code&gt;, and has no associated condition. For details about breakpoints, see the User's Guide.</source>
          <target state="translated">По умолчанию точка останова активна, имеет &lt;code&gt;enable&lt;/code&gt; действие триггера и не имеет связанного условия. Подробнее о точках останова см. В Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="2ce5b679d831561af8a791cf34b427a861410973" translate="yes" xml:space="preserve">
          <source>By default, a name must be unique within a pattern, but this constraint can be relaxed by setting option &lt;code&gt;dupnames&lt;/code&gt; at compile time. (Duplicate names are also always permitted for subpatterns with the same number, set up as described in the previous section.) Duplicate names can be useful for patterns where only one instance of the named parentheses can match. Suppose that you want to match the name of a weekday, either as a 3-letter abbreviation or as the full name, and in both cases you want to extract the abbreviation. The following pattern (ignoring the line breaks) does the job:</source>
          <target state="translated">По умолчанию имя должно быть уникальным в пределах шаблона, но это ограничение можно &lt;code&gt;dupnames&lt;/code&gt; установив опцию dupnames во время компиляции. (Повторяющиеся имена также всегда разрешены для подшаблонов с тем же номером, настроенных, как описано в предыдущем разделе.) Дублирующиеся имена могут быть полезны для шаблонов, в которых может совпадать только один экземпляр названных скобок. Предположим, вы хотите сопоставить название дня недели, либо в виде трехбуквенного сокращения, либо в виде полного имени, и в обоих случаях вы хотите извлечь аббревиатуру. Следующий шаблон (без разрыва строки) выполняет свою работу:</target>
        </trans-unit>
        <trans-unit id="c874b6a01a35c20ad7535dd46729e15bd7a18206" translate="yes" xml:space="preserve">
          <source>By default, after \x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \x{ and }. If a character other than a hexadecimal digit appears between \x{ and }, or if there is no terminating }, an error occurs.</source>
          <target state="translated">По умолчанию после \x,за которым не следует {,считываются от нуля до двух шестнадцатеричных цифр (буквы могут быть в верхнем или нижнем регистре).Между \x{и}может находиться любое количество шестнадцатеричных цифр.Если между \x{и}появится символ,отличный от шестнадцатеричной цифры,или если не будет прерывания },то произойдет ошибка.</target>
        </trans-unit>
        <trans-unit id="1911d23f55521707a73b458b73f12a15fc75306a" translate="yes" xml:space="preserve">
          <source>By default, all I/O devices in OTP are set in &lt;code&gt;list&lt;/code&gt; mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers.</source>
          <target state="translated">По умолчанию все устройства ввода-вывода в OTP установлены в режиме &lt;code&gt;list&lt;/code&gt; . Однако функции ввода-вывода могут обрабатывать любой из этих режимов, как и другие, написанные пользователем, модули, работающие как клиенты для серверов ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="6b2f7942ad86f7d74769554cdd60a7505d483c06" translate="yes" xml:space="preserve">
          <source>By default, all NETCONF traffic is logged in one single log file. However, different connections can be logged in separate files. To do this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work, that is, they must be opened with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">По умолчанию весь трафик NETCONF регистрируется в одном файле журнала. Однако разные соединения могут регистрироваться в отдельных файлах. Для этого используйте опцию перехвата &lt;code&gt;hosts&lt;/code&gt; и перечислите имена серверов / соединений, которые будут использоваться в наборе. Соединения должны быть названы, чтобы это работало, то есть они должны открываться с помощью &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d82598d7e978ba992edaa523f47e7a8ba20e371c" translate="yes" xml:space="preserve">
          <source>By default, all applications are loaded with permission &lt;code&gt;true&lt;/code&gt; on all nodes. The permission can be configured using the Kernel configuration parameter &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">По умолчанию все приложения загружаются с разрешением &lt;code&gt;true&lt;/code&gt; на всех узлах. Разрешение можно настроить с помощью параметра конфигурации ядра &lt;code&gt;permissions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97ad4d1175f0f089a0071483175aa615b421ee54" translate="yes" xml:space="preserve">
          <source>By default, all existing files with the same name as files in the tar file are overwritten. With this option, existing files are not overwriten.</source>
          <target state="translated">По умолчанию все существующие файлы с теми же именами,что и файлы в tar-файле,перезаписываются.При использовании этой опции существующие файлы не перезаписываются.</target>
        </trans-unit>
        <trans-unit id="7e40750937dae4fae3bc5f70b97a3f2528fbb80b" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the tar file. With this option, only those files are extracted whose names are included in &lt;code&gt;FileList&lt;/code&gt;.</source>
          <target state="translated">По умолчанию все файлы извлекаются из tar-файла. С помощью этой опции извлекаются только те файлы, имена которых включены в &lt;code&gt;FileList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e8684fe917ca09c774ce03048bec7c20dc7976" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the zip archive. With option &lt;code&gt;{file_list, FileList}&lt;/code&gt;, function &lt;code&gt;unzip/2&lt;/code&gt; only extracts the files whose names are included in &lt;code&gt;FileList&lt;/code&gt;. The full paths, including the names of all subdirectories within the zip archive, must be specified.</source>
          <target state="translated">По умолчанию все файлы извлекаются из zip-архива. С опцией &lt;code&gt;{file_list, FileList}&lt;/code&gt; функция &lt;code&gt;unzip/2&lt;/code&gt; извлекает только файлы, имена которых включены в &lt;code&gt;FileList&lt;/code&gt; . Необходимо указать полные пути, включая имена всех подкаталогов в zip-архиве.</target>
        </trans-unit>
        <trans-unit id="8373c854a1dcafc057dbfa5df0f447eef64bc1ef" translate="yes" xml:space="preserve">
          <source>By default, all files with the same name as files in the zip archive are overwritten. With option &lt;code&gt;keep_old_files&lt;/code&gt; set, function &lt;code&gt;unzip/2&lt;/code&gt; does not overwrite existing files. Notice that even with option &lt;code&gt;memory&lt;/code&gt; specified, which means that no files are overwritten, existing files are excluded from the result.</source>
          <target state="translated">По умолчанию все файлы с тем же именем, что и файлы в zip-архиве, перезаписываются. При установленной опции &lt;code&gt;keep_old_files&lt;/code&gt; функция &lt;code&gt;unzip/2&lt;/code&gt; не перезаписывает существующие файлы. Обратите внимание, что даже с указанным параметром &lt;code&gt;memory&lt;/code&gt; , что означает, что файлы не перезаписываются, существующие файлы исключаются из результата.</target>
        </trans-unit>
        <trans-unit id="6de29fd7730a88164d057863c9dcf72fa1cb3f6c" translate="yes" xml:space="preserve">
          <source>By default, all log events originating from within OTP, except the former so called &quot;SASL reports&quot;, look the same as before.</source>
          <target state="translated">По умолчанию,все события журнала,происходящие из OTP,за исключением прежних,так называемых &quot;отчетов SASL&quot;,выглядят так же,как и раньше.</target>
        </trans-unit>
        <trans-unit id="2882c6abbebff5ea0f043573bc5ce53ddfde39c3" translate="yes" xml:space="preserve">
          <source>By default, all parts of the string, including the empty strings, are returned from the function, for example:</source>
          <target state="translated">По умолчанию все части строки,включая пустые строки,возвращаются,например,из функции:</target>
        </trans-unit>
        <trans-unit id="74b4b269097f50b433c9602d13038dfa07527232" translate="yes" xml:space="preserve">
          <source>By default, an &lt;code&gt;OCTET STRING&lt;/code&gt; is always represented as an Erlang binary. If the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;, the encode functions accept both lists and binaries, and the decode functions decode an &lt;code&gt;OCTET STRING&lt;/code&gt; to a list.</source>
          <target state="translated">По умолчанию &lt;code&gt;OCTET STRING&lt;/code&gt; всегда представляется как двоичный файл Erlang. Если спецификация была скомпилирована с опцией &lt;code&gt;legacy_erlang_types&lt;/code&gt; , функции кодирования принимают как списки, так и двоичные файлы, а функции декодирования декодируют &lt;code&gt;OCTET STRING&lt;/code&gt; в список.</target>
        </trans-unit>
        <trans-unit id="0bac80eb92816a5a88bf3b52b9fd2aacd857eeb1" translate="yes" xml:space="preserve">
          <source>By default, autostart information is stored in a file named &lt;code&gt;ttb_autostart.bin&lt;/code&gt; on each node. If this is not desired (for example, on diskless nodes), a custom module handling autostart information storage and retrieval can be provided by specifying environment variable &lt;code&gt;ttb_autostart_module&lt;/code&gt; for the application Runtime_Tools. The module must respond to the following API:</source>
          <target state="translated">По умолчанию информация об автозапуске хранится в файле с именем &lt;code&gt;ttb_autostart.bin&lt;/code&gt; на каждом узле. Если это нежелательно (например, на бездисковых узлах), можно предоставить настраиваемый модуль, обрабатывающий хранение и извлечение информации об автозапуске, указав переменную среды &lt;code&gt;ttb_autostart_module&lt;/code&gt; для приложения Runtime_Tools. Модуль должен отвечать следующему API:</target>
        </trans-unit>
        <trans-unit id="ad25aa21de1694492059b0bfb35caab2d579e0fb" translate="yes" xml:space="preserve">
          <source>By default, characters with values &amp;gt; 255 do not match any of the Posix character classes. However, if option &lt;code&gt;PCRE_UCP&lt;/code&gt; is passed to &lt;code&gt;pcre_compile()&lt;/code&gt;, some of the classes are changed so that Unicode character properties are used. This is achieved by replacing certain Posix classes by other sequences, as follows:</source>
          <target state="translated">По умолчанию символы со значениями&amp;gt; 255 не соответствуют ни одному из классов символов Posix. Однако, если параметр &lt;code&gt;PCRE_UCP&lt;/code&gt; передается в &lt;code&gt;pcre_compile()&lt;/code&gt; , некоторые классы изменяются так, что используются свойства символов Unicode. Это достигается заменой определенных классов Posix другими последовательностями, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="053346f97801947e69ed842b8b3fec738287fe79" translate="yes" xml:space="preserve">
          <source>By default, data for all Telnet connections is logged in one common file (named &lt;code&gt;default&lt;/code&gt;), which can get messy, for example, if multiple Telnet sessions are running in parallel. Therefore a separate log file can be created for each connection. To configure this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work (see &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">По умолчанию данные для всех подключений Telnet регистрируются в одном общем файле (с именем &lt;code&gt;default&lt;/code&gt; ), что может стать беспорядочным, например, если несколько сеансов Telnet выполняются параллельно. Поэтому для каждого подключения можно создать отдельный файл журнала. Чтобы настроить это, используйте &lt;code&gt;hosts&lt;/code&gt; опцией перехвата и перечислите имена серверов / соединений, которые будут использоваться в наборе. Чтобы это работало, соединения должны быть названы (см. &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="776bbd51980a39359333108981da5fd37cece1a7" translate="yes" xml:space="preserve">
          <source>By default, each CTH installed is executed in the order that they are installed for init calls, and then reversed for end calls. This is not always desired, so &lt;code&gt;Common Test&lt;/code&gt; allows the user to specify a priority for each hook. The priority can either be specified in the CTH function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; or when installing the hook. The priority specified at installation overrides the priority returned by the CTH.</source>
          <target state="translated">По умолчанию каждый установленный CTH выполняется в том порядке, в котором они установлены для вызовов инициализации, а затем меняются местами для вызовов завершения. Это не всегда желательно, поэтому &lt;code&gt;Common Test&lt;/code&gt; позволяет пользователю указать приоритет для каждой ловушки. Приоритет можно указать либо в функции CTH &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; , либо при установке ловушки. Приоритет, указанный при установке, имеет приоритет над приоритетом, возвращаемым CTH.</target>
        </trans-unit>
        <trans-unit id="462e7da9c97e5f027114d96a2306c993c035da8a" translate="yes" xml:space="preserve">
          <source>By default, each installation of a CTH causes a new instance of it to be activated. This can cause problems if you want to override CTHs in test specifications while still having them in the suite information function. The &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; callback exists to address this problem. By returning the same &lt;code&gt;id&lt;/code&gt; in both places, &lt;code&gt;Common Test&lt;/code&gt; knows that this CTH is already installed and does not try to install it again.</source>
          <target state="translated">По умолчанию каждая установка CTH вызывает активацию нового экземпляра. Это может вызвать проблемы, если вы хотите переопределить CTH в тестовых спецификациях, сохранив их в информационной функции набора. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; обратного вызова существует для решения этой проблемы. Возвращая один и тот же &lt;code&gt;id&lt;/code&gt; в обоих местах, &lt;code&gt;Common Test&lt;/code&gt; знает, что этот CTH уже установлен, и не пытается установить его снова.</target>
        </trans-unit>
        <trans-unit id="46480571329f9b5765128d1e4d2b38b49550c0a0" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead either returns &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt;, where &lt;code&gt;Relup&lt;/code&gt; is the release upgrade file, or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">По умолчанию ошибки и предупреждения выводятся на tty, и функция возвращает &lt;code&gt;ok&lt;/code&gt; или &lt;code&gt;error&lt;/code&gt; . Если указана опция &lt;code&gt;silent&lt;/code&gt; , функция вместо этого либо возвращает &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt; , где &lt;code&gt;Relup&lt;/code&gt; - это файл обновления выпуска, либо &lt;code&gt;{error,Module,Error}&lt;/code&gt; . Предупреждения и ошибки можно преобразовать в строки, вызвав &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; или &lt;code&gt;Module:format_error(Error)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="294052fb58119cdee244d014d8cb85f8f3d4b24a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">По умолчанию ошибки и предупреждения выводятся на tty, и функция возвращает &lt;code&gt;ok&lt;/code&gt; или &lt;code&gt;error&lt;/code&gt; . Если задана опция &lt;code&gt;silent&lt;/code&gt; , функция вместо этого возвращает &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; или &lt;code&gt;{error,Module,Error}&lt;/code&gt; . Предупреждения и ошибки можно преобразовать в строки, вызвав &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; или &lt;code&gt;Module:format_error(Error)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee3c67a77746a67e2bb8398f5d758b0ceca821c3" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; function opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">По умолчанию функция &lt;code&gt;open/2&lt;/code&gt; открывает tar-файл в &lt;code&gt;raw&lt;/code&gt; режиме, который работает быстрее, но не позволяет использовать удаленный (Erlang) файловый сервер. Добавление &lt;code&gt;cooked&lt;/code&gt; в список режимов отменяет значение по умолчанию и открывает tar-файл без опции &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31b08201db8e452376ac550216866c4f0213c87" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">По умолчанию функция &lt;code&gt;open/2&lt;/code&gt; открывает tar-файл в &lt;code&gt;raw&lt;/code&gt; режиме, который быстрее, но не позволяет использовать удаленный (Erlang) файловый сервер. Добавление &lt;code&gt;cooked&lt;/code&gt; в список режимов отменяет значение по умолчанию и открывает файл tar без опции &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4fa6e3241b3f16b2494ba76c92a8e6751097f9" translate="yes" xml:space="preserve">
          <source>By default, if any requested chunk is missing in &lt;code&gt;Beam&lt;/code&gt;, an &lt;code&gt;error&lt;/code&gt; tuple is returned. However, if option &lt;code&gt;allow_missing_chunks&lt;/code&gt; is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt;. Notice however that if chunk &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; is missing, that is considered a fatal error and the return value is an &lt;code&gt;error&lt;/code&gt; tuple.</source>
          <target state="translated">По умолчанию, если какой-либо запрошенный фрагмент отсутствует в &lt;code&gt;Beam&lt;/code&gt; , возвращается кортеж с &lt;code&gt;error&lt;/code&gt; . Однако, если &lt;code&gt;allow_missing_chunks&lt;/code&gt; параметр allow_missing_chunks , результат будет возвращен, даже если фрагменты отсутствуют. В списке результатов любые недостающие фрагменты представлены как &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt; . Обратите внимание, однако, что если блок &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; отсутствует, это считается фатальной ошибкой, а возвращаемое значение является кортежем &lt;code&gt;error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f53b57e48d13ba35bc616bbd211c0e3f61e0177" translate="yes" xml:space="preserve">
          <source>By default, in &lt;code&gt;unicode&lt;/code&gt; mode, characters with values &amp;gt; 255, that is, all characters outside the ISO Latin-1 character set, never match \d, \s, or \w, and always match \D, \S, and \W. These sequences retain their original meanings from before UTF support was available, mainly for efficiency reasons. However, if option &lt;code&gt;ucp&lt;/code&gt; is set, the behavior is changed so that Unicode properties are used to determine character types, as follows:</source>
          <target state="translated">По умолчанию в режиме &lt;code&gt;unicode&lt;/code&gt; символы со значениями&amp;gt; 255, то есть все символы вне набора символов ISO Latin-1, никогда не соответствуют \ d, \ s или \ w и всегда соответствуют \ D, \ S и \ W. Эти последовательности сохраняют свое первоначальное значение до того, как стала доступна поддержка UTF, в основном из соображений эффективности. Однако, если установлена ​​опция &lt;code&gt;ucp&lt;/code&gt; , поведение изменяется так, что свойства Unicode используются для определения типов символов, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="8dce2b9977241b689bc8a7cc79ba1876582a372f" translate="yes" xml:space="preserve">
          <source>By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option &lt;code&gt;dereference&lt;/code&gt;.</source>
          <target state="translated">По умолчанию символические ссылки сохраняются как символические ссылки в файле tar. Чтобы переопределить значение по умолчанию и сохранить файл, на который указывает символическая ссылка, в файл tar, используйте &lt;code&gt;dereference&lt;/code&gt; опции .</target>
        </trans-unit>
        <trans-unit id="307631df678df3363024a8553c6845aa25ac4dbc" translate="yes" xml:space="preserve">
          <source>By default, that lock is at the driver level, that is, if several ports have been opened to the same driver, only code for one port at the same time can be running.</source>
          <target state="translated">По умолчанию эта блокировка находится на уровне драйвера,т.е.если на один и тот же драйвер было открыто несколько портов,то может быть запущен только код для одного порта одновременно.</target>
        </trans-unit>
        <trans-unit id="59ef4e65d1c06e09a6d712a392cd376d76f7e30c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; libraries are only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">По умолчанию библиотеки &lt;code&gt;Erl_Interface&lt;/code&gt; гарантированно совместимы только с другими компонентами Erlang / OTP из того же выпуска, что и сами библиотеки. Для получения информации о том, как взаимодействовать с компонентами Erlang / OTP из более ранних выпусков, см. Функции &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de70cb5ed283df211d9a60f565e19a6787b411b0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;Erl_Interface&lt;/code&gt; library itself. For example, &lt;code&gt;Erl_Interface&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">По умолчанию библиотека &lt;code&gt;Erl_Interface&lt;/code&gt; гарантированно совместима только с другими компонентами Erlang / OTP из того же выпуска, что и &lt;code&gt;Erl_Interface&lt;/code&gt; библиотека Erl_Interface . Например, &lt;code&gt;Erl_Interface&lt;/code&gt; из Erlang / OTP R10 по умолчанию несовместим с эмулятором Erlang из Erlang / OTP R9.</target>
        </trans-unit>
        <trans-unit id="5408a0e73229b9b5e967fe902da2634b16e6868a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;ei&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;ei&lt;/code&gt; library itself. For example, &lt;code&gt;ei&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">По умолчанию библиотека &lt;code&gt;ei&lt;/code&gt; гарантированно совместима только с другими компонентами Erlang / OTP из того же выпуска, что и сама библиотека &lt;code&gt;ei&lt;/code&gt; . Например, &lt;code&gt;ei&lt;/code&gt; из Erlang / OTP R10 по умолчанию несовместим с эмулятором Erlang из Erlang / OTP R9.</target>
        </trans-unit>
        <trans-unit id="cc7855f5354d795a3773624d2090708d90c447ea" translate="yes" xml:space="preserve">
          <source>By default, the &lt;strong&gt;default user&lt;/strong&gt; is set to the &lt;code&gt;snmpm_user_default&lt;/code&gt; module, which simply sends an info message to the error_logger. It is however highly recommended that this module be replaced by another that does something useful (see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; for more info).</source>
          <target state="translated">По умолчанию &lt;strong&gt;пользователь&lt;/strong&gt; по &lt;strong&gt;умолчанию&lt;/strong&gt; настроен на модуль &lt;code&gt;snmpm_user_default&lt;/code&gt; , который просто отправляет информационное сообщение error_logger. Однако настоятельно рекомендуется заменить этот модуль другим, выполняющим что-то полезное (см. &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; для получения дополнительной информации).</target>
        </trans-unit>
        <trans-unit id="8754a9737ab7ee6fe2f3b847124e99177bf4ce53" translate="yes" xml:space="preserve">
          <source>By default, the Cover tool is automatically stopped when the tests are completed. This causes the original (non-cover compiled) modules to be loaded back into the test node. If a process at this point still runs old code of any of the modules that are cover compiled, meaning that it has not done any fully qualified function call after the cover compilation, the process is killed. To avoid this, set the value of option &lt;code&gt;cover_stop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. This means that the modules stay cover compiled. Therefore, this is only recommended if the Erlang nodes under test are terminated after the test is completed, or if cover can be manually stopped.</source>
          <target state="translated">По умолчанию инструмент Cover автоматически останавливается после завершения тестов. Это приводит к загрузке исходных (не скомпилированных) модулей обратно в тестовый узел. Если процесс на этом этапе все еще выполняет старый код любого из модулей, которые скомпилированы прикрытием, что означает, что он не выполнил полностью квалифицированный вызов функции после компиляции обложки, процесс завершается. Чтобы этого избежать, установите для параметра &lt;code&gt;cover_stop&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; . Это означает, что модули остаются скомпилированными. Следовательно, это рекомендуется только в том случае, если тестируемые узлы Erlang завершаются после завершения теста или если покрытие может быть остановлено вручную.</target>
        </trans-unit>
        <trans-unit id="9bc1af126fb19b5493bbbaf63937647ea51683fa" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default printed to the terminal.</source>
          <target state="translated">По умолчанию приложение ядра устанавливает один обработчик журнала при запуске системы. Этот обработчик называется по &lt;code&gt;default&lt;/code&gt; . Он принимает и обрабатывает стандартные события журнала, создаваемые системой времени выполнения Erlang, стандартным поведением и различными приложениями Erlang / OTP. События журнала по умолчанию выводятся на терминал.</target>
        </trans-unit>
        <trans-unit id="44204f5230679d2fef96d8949b078f4f3e6c9083" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default written to the terminal.</source>
          <target state="translated">По умолчанию приложение ядра устанавливает один обработчик журнала при запуске системы. Этот обработчик называется по &lt;code&gt;default&lt;/code&gt; . Он принимает и обрабатывает стандартные события журнала, создаваемые системой времени выполнения Erlang, стандартным поведением и различными приложениями Erlang / OTP. События журнала по умолчанию записываются в терминал.</target>
        </trans-unit>
        <trans-unit id="05263651b062c95772f413d54c47f0b67ec3f917" translate="yes" xml:space="preserve">
          <source>By default, the actual access to the backup media is performed through module &lt;code&gt;mnesia_backup&lt;/code&gt; for both read and write. Currently &lt;code&gt;mnesia_backup&lt;/code&gt; is implemented with the standard library module &lt;code&gt;disc_log&lt;/code&gt;. However, you can write your own module with the same interface as &lt;code&gt;mnesia_backup&lt;/code&gt; and configure &lt;code&gt;Mnesia&lt;/code&gt; so that the alternative module performs the actual accesses to the backup media. The user can therefore put the backup on a media that &lt;code&gt;Mnesia&lt;/code&gt; does not know about, possibly on hosts where Erlang is not running. Use configuration parameter &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">По умолчанию фактический доступ к резервному &lt;code&gt;mnesia_backup&lt;/code&gt; осуществляется через модуль mnesia_backup как для чтения, так и для записи. В настоящее время &lt;code&gt;mnesia_backup&lt;/code&gt; реализован с помощью стандартного библиотечного модуля &lt;code&gt;disc_log&lt;/code&gt; . Однако вы можете написать свой собственный модуль с тем же интерфейсом, что и &lt;code&gt;mnesia_backup&lt;/code&gt; , и настроить &lt;code&gt;Mnesia&lt;/code&gt; так, чтобы альтернативный модуль выполнял фактический доступ к носителю резервной копии. Таким образом, пользователь может разместить резервную копию на носителе, о котором &lt;code&gt;Mnesia&lt;/code&gt; не знает, возможно, на хостах, на которых не запущен Erlang. Для этого используйте параметр конфигурации &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1afaf0fcbb8ede75fea0c65c21d25a0925f3450" translate="yes" xml:space="preserve">
          <source>By default, the agent has no knowledge of any other contexts than the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;. If it is to support more contexts, these must be explicitly added, by using an appropriate configuration file &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">По умолчанию агенту неизвестны какие-либо другие контексты, кроме контекста по умолчанию &lt;code&gt;&quot;&quot;&lt;/code&gt; . Если он предназначен для поддержки большего количества контекстов, они должны быть явно добавлены с помощью соответствующего файла конфигурации &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90e34246dd8429aefe6c7b588f2a3b0f064042d2" translate="yes" xml:space="preserve">
          <source>By default, the boot script and boot file are located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, they are located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">По умолчанию сценарий загрузки и файл загрузки находятся в том же каталоге, что и &lt;code&gt;Name.rel&lt;/code&gt; . То есть в текущем рабочем каталоге, если &lt;code&gt;Name&lt;/code&gt; содержит путь. Если &lt;code&gt;{outdir,Dir}&lt;/code&gt; параметр {outdir, Dir} , они вместо этого находятся в &lt;code&gt;Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3804b66310d736d0a24d21cca9ed0959844c03" translate="yes" xml:space="preserve">
          <source>By default, the generated code for operation &lt;code&gt;Record#record_tag.field&lt;/code&gt; verifies that the tuple &lt;code&gt;Record&lt;/code&gt; has the correct size for the record, and that the first element is the tag &lt;code&gt;record_tag&lt;/code&gt;. Use this option to omit the verification code.</source>
          <target state="translated">По умолчанию сгенерированный код для операции &lt;code&gt;Record#record_tag.field&lt;/code&gt; проверяет, что кортеж &lt;code&gt;Record&lt;/code&gt; имеет правильный размер для записи и что первым элементом является тег &lt;code&gt;record_tag&lt;/code&gt; . Используйте эту опцию, чтобы пропустить проверочный код.</target>
        </trans-unit>
        <trans-unit id="92ed03811630a1034411365747a68f1b027d08b7" translate="yes" xml:space="preserve">
          <source>By default, the maximum number of atoms is 1,048,576. This limit can be raised or lowered using the &lt;code&gt;+t&lt;/code&gt; option.</source>
          <target state="translated">По умолчанию максимальное количество атомов - 1 048 576. Этот предел можно увеличить или уменьшить с помощью опции &lt;code&gt;+t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c86aae6b772372c0ae40b88282e56c074aa7a5f1" translate="yes" xml:space="preserve">
          <source>By default, the parser that was generated will not print out error messages to the screen. The user will have to do this either by printing the returned error messages, or by inserting tests and print instructions in the Erlang code associated with the syntax rules of the grammar file.</source>
          <target state="translated">По умолчанию сгенерированный парсер не выводит на экран сообщения об ошибках.Пользователю придется это сделать либо распечатывая возвращаемые сообщения об ошибках,либо вставляя тесты и инструкции по печати в код Erlang,связанный с синтаксическими правилами грамматического файла.</target>
        </trans-unit>
        <trans-unit id="e241a1115343866b033984b2e0f3224cbedbb8d1" translate="yes" xml:space="preserve">
          <source>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern</source>
          <target state="translated">По умолчанию квантификаторы &quot;жадные&quot;,т.е.они максимально совпадают (до максимально допустимого количества раз),не приводя к отказу оставшегося шаблона.Классическим примером того,где это дает проблемы,является попытка сопоставить комментарии в программах на языке Си.Они появляются между /*и */.Внутри комментария могут появляться отдельные*и/символы.Попытка сопоставить комментарии на языке C с помощью шаблона</target>
        </trans-unit>
        <trans-unit id="3c85bc6c43eb52272e65af88f8cd9d253d828366" translate="yes" xml:space="preserve">
          <source>By default, the release package contains the directories &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; and &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; for each included application. If more directories are to be included, option &lt;code&gt;dirs&lt;/code&gt; is specified, for example, &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt;.</source>
          <target state="translated">По умолчанию пакет выпуска содержит каталоги &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; и &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; для каждого включенного приложения. Если нужно включить больше каталогов, указывается опция &lt;code&gt;dirs&lt;/code&gt; , например &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f48b56c162fe6bc8e83c9024713b2063795276f9" translate="yes" xml:space="preserve">
          <source>By default, the release package file is located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, it is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">По умолчанию файл пакета выпуска находится в том же каталоге, что и &lt;code&gt;Name.rel&lt;/code&gt; . То есть в текущем рабочем каталоге, если &lt;code&gt;Name&lt;/code&gt; содержит путь. Если &lt;code&gt;{outdir,Dir}&lt;/code&gt; параметр {outdir, Dir} , он находится в &lt;code&gt;Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd67be193ef985280c7869e02ad1eaa76d02cee6" translate="yes" xml:space="preserve">
          <source>By default, the script will be interpreted. You can force it to be compiled by including the following line somewhere in the script file:</source>
          <target state="translated">По умолчанию скрипт будет интерпретироваться.Вы можете заставить его скомпилироваться,включив следующую строку где-нибудь в файл скрипта:</target>
        </trans-unit>
        <trans-unit id="b2a64b819e1641df3c5bc639a09bb56418f80b28" translate="yes" xml:space="preserve">
          <source>By default, the tar file is opened in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">По умолчанию файл tar открывается в &lt;code&gt;raw&lt;/code&gt; режиме, который работает быстрее, но не позволяет использовать удаленный (Erlang) файловый сервер. Добавление &lt;code&gt;cooked&lt;/code&gt; в список режимов отменяет значение по умолчанию и открывает tar-файл без опции &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="968238200f11724a49fdbda317cbe260c831d025" translate="yes" xml:space="preserve">
          <source>By default, the value is as before, that is, &lt;code&gt;minimal&lt;/code&gt;.</source>
          <target state="translated">По умолчанию значение прежнее, то есть &lt;code&gt;minimal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69fa5b82743edee630d33a79817b045aafc5d81" translate="yes" xml:space="preserve">
          <source>By default, this function adds a new line to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">По умолчанию эта функция добавляет новую строку в конец указанной команды. Если это нежелательно, используйте опцию &lt;code&gt;{newline,false}&lt;/code&gt; . Это необходимо, например, при отправке последовательностей команд Telnet с префиксом &amp;laquo;Интерпретировать как команду&amp;raquo; (IAC).</target>
        </trans-unit>
        <trans-unit id="d49eba4b9253b8356ed12159ecfe231995c2f898" translate="yes" xml:space="preserve">
          <source>By default, this function adds a newline to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">По умолчанию эта функция добавляет новую строку в конец указанной команды. Если это нежелательно, можно использовать параметр &lt;code&gt;{newline,false}&lt;/code&gt; . Это необходимо, например, при отправке последовательностей команд Telnet с префиксом &amp;laquo;Интерпретировать как команду&amp;raquo; (IAC).</target>
        </trans-unit>
        <trans-unit id="a9e7714f2d506552215115a4ebf113d003a0acf0" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">По умолчанию эта функция открывает zip-файл в &lt;code&gt;raw&lt;/code&gt; режиме, который работает быстрее, но не позволяет использовать удаленный (Erlang) файловый сервер. Добавление &lt;code&gt;cooked&lt;/code&gt; в список режимов отменяет значение по умолчанию и открывает zip-файл без опции &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d14a17c6143d2f118a5dcf4b9f9f2f606d6beef7" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;. The same applies for the files extracted.</source>
          <target state="translated">По умолчанию эта функция открывает zip-файл в &lt;code&gt;raw&lt;/code&gt; режиме, который работает быстрее, но не позволяет использовать удаленный (Erlang) файловый сервер. Добавление &lt;code&gt;cooked&lt;/code&gt; в список режимов отменяет значение по умолчанию и открывает zip-файл без опции &lt;code&gt;raw&lt;/code&gt; . То же самое касается извлеченных файлов.</target>
        </trans-unit>
        <trans-unit id="7a8f2bce9d4e28310f04f71c37d623d77632500e" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in mode &lt;code&gt;raw&lt;/code&gt;, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without the &lt;code&gt;raw&lt;/code&gt; option. The same applies for the files added.</source>
          <target state="translated">По умолчанию эта функция открывает zip-файл в режиме &lt;code&gt;raw&lt;/code&gt; , который быстрее, но не позволяет использовать удаленный (Erlang) файловый сервер. Добавление &lt;code&gt;cooked&lt;/code&gt; в список режимов отменяет значение по умолчанию и открывает zip-файл без параметра &lt;code&gt;raw&lt;/code&gt; . То же самое относится и к добавленным файлам.</target>
        </trans-unit>
        <trans-unit id="679e4d02c8183bf697056897c283fb7c9fe1a240" translate="yes" xml:space="preserve">
          <source>By default, this option is not set. This means that the number is not limited.</source>
          <target state="translated">По умолчанию эта опция не установлена.Это означает,что количество не ограничено.</target>
        </trans-unit>
        <trans-unit id="6486abd515b1ceb341dd61657f6cfe722ef188e0" translate="yes" xml:space="preserve">
          <source>By default, this rule is written to &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt;. However, if option &lt;code&gt;binary&lt;/code&gt; is set, nothing is written and the rule is returned in &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="translated">По умолчанию это правило записывается в &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt; . Однако, если установлен параметр &lt;code&gt;binary&lt;/code&gt; , ничего не записывается, и правило возвращается в &lt;code&gt;Binary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc5c5c502173feaca81300d649a4642ade965d9" translate="yes" xml:space="preserve">
          <source>By default, this will &lt;strong&gt;not&lt;/strong&gt; be used.</source>
          <target state="translated">По умолчанию это &lt;strong&gt;не&lt;/strong&gt; будет использоваться.</target>
        </trans-unit>
        <trans-unit id="9e77c5d7a27dc1e5cf909f3bf8e3e3ad53b629c2" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted for unused variables, except for variables beginning with an underscore (&quot;Prolog style warnings&quot;). Use this option to turn off this kind of warnings.</source>
          <target state="translated">По умолчанию предупреждения выдаются для неиспользуемых переменных,за исключением переменных,начинающихся с символа подчеркивания (&quot;Предупреждения в стиле Prolog&quot;).Используйте данную опцию для отключения данного вида предупреждений.</target>
        </trans-unit>
        <trans-unit id="20ba07e398dad932a7a5314c1ee7e53c53da657a" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;[]&lt;/code&gt; is passed as &lt;code&gt;ModifierList&lt;/code&gt;, both negative and positive integers can be returned. This to use the range of integers that do not need heap memory allocation as much as possible. By default the returned integers are also only guaranteed to be unique, that is, any returned integer can be smaller or larger than previously returned integers.</source>
          <target state="translated">По умолчанию, когда &lt;code&gt;[]&lt;/code&gt; передается как &lt;code&gt;ModifierList&lt;/code&gt; , могут возвращаться как отрицательные, так и положительные целые числа. Это позволяет максимально использовать диапазон целых чисел, для которых не требуется выделение памяти кучи. По умолчанию также гарантируется уникальность возвращаемых целых чисел, то есть любое возвращаемое целое число может быть меньше или больше, чем возвращенные ранее целые числа.</target>
        </trans-unit>
        <trans-unit id="11b69da7024ea541c3dc95c3ee7904796b05dd49" translate="yes" xml:space="preserve">
          <source>By definition, it is not possible to send objects with ACCESS &lt;code&gt;not-accessible&lt;/code&gt; in notifications. However, historically this is often done and for this reason we allow it in notification sending. If a variable has ACCESS &lt;code&gt;not-accessible&lt;/code&gt;, the user must provide a value for the variable in the &lt;code&gt;Varbinds&lt;/code&gt; list. It is not possible for the agent to perform a get-operation to retrieve this value.</source>
          <target state="translated">По определению, невозможно отправлять объекты с &lt;code&gt;not-accessible&lt;/code&gt; ACCESS в уведомлениях. Однако исторически это часто делается, и по этой причине мы разрешаем это при отправке уведомлений. Если для переменной ACCESS &lt;code&gt;not-accessible&lt;/code&gt; , пользователь должен &lt;code&gt;Varbinds&lt;/code&gt; значение для переменной в списке Varbinds . Агент не может выполнить операцию получения для получения этого значения.</target>
        </trans-unit>
        <trans-unit id="1fe4bf7551fb0bca40b8408258d2d9b38f061a30" translate="yes" xml:space="preserve">
          <source>By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea.</source>
          <target state="translated">Умышленно копируя один двоичный файл,чтобы избежать ссылки на большой двоичный файл,можно,вместо того,чтобы освободить большой двоичный файл для последующего сбора мусора,создать гораздо больше двоичных данных,чем это необходимо.Совместное использование двоичных данных,как правило,хорошо.Только в особых случаях,когда маленькие части ссылаются на большие двоичные файлы,а большие двоичные файлы больше не используются в каком-либо процессе,преднамеренное копирование может быть хорошей идеей.</target>
        </trans-unit>
        <trans-unit id="3a1bde088e58ddc2e236cd1237348e4ca2d354a9" translate="yes" xml:space="preserve">
          <source>By executing these commands, two Erlang nodes are configured to run the &lt;code&gt;Company&lt;/code&gt; database, and therefore, initialize the database. This is required only once when setting up. The next time the system is started, &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes, to initialize the system from disc.</source>
          <target state="translated">Выполняя эти команды, два узла Erlang настраиваются для запуска базы данных &lt;code&gt;Company&lt;/code&gt; и, следовательно, инициализации базы данных. Это требуется только один раз при настройке. При следующем &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; на обоих узлах вызывается mnesia: start () для инициализации системы с диска.</target>
        </trans-unit>
        <trans-unit id="d4cbb518f731cd8bac9f82803da816e494e6c084" translate="yes" xml:space="preserve">
          <source>By far the most common situation where this occurs, is when you get lists of UTF-8 instead of proper Unicode strings, and then convert them to UTF-8 in a binary or on a file:</source>
          <target state="translated">На сегодняшний день наиболее распространенная ситуация,когда это происходит,это когда вы получаете списки UTF-8 вместо правильных Unicode строк,а затем конвертируете их в UTF-8 в двоичном коде или в файле:</target>
        </trans-unit>
        <trans-unit id="e536308fb486e25402a1208f98bf1f7153e3c15e" translate="yes" xml:space="preserve">
          <source>By focusing on getting the code to pass the tests, the programmer can become more productive, not overspecify or get lost in premature optimizations, and create code that is correct from the very beginning (so-called &lt;strong&gt;test-driven development&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Сосредоточив внимание на том, чтобы код прошел тесты, программист может стать более продуктивным, не переоценивать и не теряться в преждевременных оптимизациях и создавать правильный код с самого начала (так называемая разработка через &lt;strong&gt;тестирование&lt;/strong&gt; ; см. &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1be6092d2f04d5672bbcc552b76ea03252377f9a" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application (see section &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Дав обработчику формата &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; , вы можете иметь графическое представление журнала трассировки с помощью &lt;code&gt;et_viewer&lt;/code&gt; в приложении ET (см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d1f348639ff071f4f3a637874209a8d2a2be427" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application. &lt;code&gt;ttb&lt;/code&gt; provides filters that can be selected from the menu &lt;strong&gt;Filter&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt; window. The filters are names according to the type of actors they present (that is, what each vertical line in the sequence diagram represents). Interaction between actors is shown as red arrows between two vertical lines, and activities within an actor are shown as blue text to the right of the actors line.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; обработчику формата ttb: get_et_handler () , вы можете представить журнал трассировки графически с помощью &lt;code&gt;et_viewer&lt;/code&gt; в приложении ET. &lt;code&gt;ttb&lt;/code&gt; предоставляет фильтры, которые можно выбрать в меню &amp;laquo; &lt;strong&gt;Фильтр&amp;raquo;&lt;/strong&gt; в окне &lt;code&gt;et_viewer&lt;/code&gt; . Фильтры представляют собой имена в соответствии с типом действующих лиц, которые они представляют (то есть, что представляет каждая вертикальная линия на диаграмме последовательности). Взаимодействие между актерами показано красными стрелками между двумя вертикальными линиями, а действия внутри актера показаны синим текстом справа от линии актеров.</target>
        </trans-unit>
        <trans-unit id="1c38dcce4fbbcbaa49db2c494d622ac31a93af9e" translate="yes" xml:space="preserve">
          <source>By inspecting the headers or writing a small C program, it is found that &lt;code&gt;IPPROTO_TCP&lt;/code&gt; is 6, &lt;code&gt;TCP_INFO&lt;/code&gt; is 11, the structure size is 92 (bytes), the offset of &lt;code&gt;tcpi_sacked&lt;/code&gt; is 28 bytes, and the value is a 32-bit integer. The following code can be used to retrieve the value:</source>
          <target state="translated">&lt;code&gt;TCP_INFO&lt;/code&gt; заголовки или написав небольшую программу на C, выяснилось, что &lt;code&gt;IPPROTO_TCP&lt;/code&gt; - 6, TCP_INFO - 11, размер структуры - 92 (байта), смещение &lt;code&gt;tcpi_sacked&lt;/code&gt; - 28 байтов, а значение - 32-битное целое число. Для получения значения можно использовать следующий код:</target>
        </trans-unit>
        <trans-unit id="018fc7c90872dc5bcc3ecc8ce71bc58db7e38b60" translate="yes" xml:space="preserve">
          <source>By inspecting the implementation, you might notice that some specific signal gives a stricter guarantee than described above. It is of vital importance that such knowledge about the implementation is &lt;strong&gt;not&lt;/strong&gt; used by Erlang code, as the implementation can change at any time without prior notice.</source>
          <target state="translated">Изучив реализацию, вы можете заметить, что какой-то конкретный сигнал дает более строгую гарантию, чем описано выше. Жизненно важно, чтобы такие знания о реализации &lt;strong&gt;не&lt;/strong&gt; использовались кодом Erlang, поскольку реализация может измениться в любое время без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="e8b879e7731e558078b8cea840f1fb4c1f690b4a" translate="yes" xml:space="preserve">
          <source>By looking at the results from the analyses, it can be deducted that the test case does not cover the case when all channels are allocated and &lt;code&gt;test.erl&lt;/code&gt; should be extended accordingly.</source>
          <target state="translated">Глядя на результаты анализа, можно сделать вывод, что тестовый пример не охватывает случай, когда все каналы выделены и &lt;code&gt;test.erl&lt;/code&gt; должен быть соответственно расширен.</target>
        </trans-unit>
        <trans-unit id="0adc0a428da4933a5c912fbd894ed220b7168db5" translate="yes" xml:space="preserve">
          <source>By parsing an XML document you will get a record, displaying the structure of the document, as return value. The record also holds the data of the document. xmerl is convenient to use in for instance the following scenarios:</source>
          <target state="translated">При разборе XML-документа вы получите запись,отображающую структуру документа,в качестве возвращаемого значения.Запись также содержит данные документа.xmerl удобно использовать,например,в следующих сценариях:</target>
        </trans-unit>
        <trans-unit id="805a7a9a8ddfb1ba7400cf31f92187edc3ff9a77" translate="yes" xml:space="preserve">
          <source>By passing a pointer to an integer variable containing the value &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt;, the currently used limit is read and written back to the integer variable. A new limit can be set by passing a pointer to an integer variable containing a valid limit. The passed value is written to the internal limit. The internal limit is then adjusted. After this the adjusted limit is written back to the integer variable from which the new value was read. Values are in bytes.</source>
          <target state="translated">При передаче указателя на целочисленную переменную, содержащую значение &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt; , текущий используемый предел считывается и записывается обратно в целочисленную переменную. Новый предел можно установить, передав указатель на целочисленную переменную, содержащую допустимый предел. Переданное значение записывается во внутренний предел. Затем внутренний предел корректируется. После этого скорректированный предел записывается обратно в целочисленную переменную, из которой было прочитано новое значение. Значения указаны в байтах.</target>
        </trans-unit>
        <trans-unit id="75da6c1f2ebad0633762bf86ba622c3a4f5ba6cd" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">Если передать то же самое &amp;laquo;развлечение&amp;raquo; в качестве аргумента функции &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; , она выполняется почти в том же контексте, что и функция &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt; . Отличие в том, что операции выполняются синхронно. Вызывающий ожидает выполнения обновлений для всех активных реплик. Использование &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; полезно в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="808cd51c3638fb04adece47349170a09569ccf1c" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; то же самое &amp;laquo;веселье&amp;raquo; в качестве аргумента функции mnesia: async_dirty (Fun [, Args]) , она выполняется в грязном контексте. Вызов функций сопоставляется с соответствующими грязными функциями. Это по-прежнему включает в себя ведение журнала, репликацию и подписки, но не задействуются протоколы блокировки, локального хранилища транзакций или фиксации. Фиксаторы КПП обновляются, но обновляются &amp;laquo;грязно&amp;raquo;. Таким образом, они обновляются асинхронно. Функции ждут, пока операция будет выполнена на одном узле, но не на других. Если таблица находится локально, ожидания не происходит.</target>
        </trans-unit>
        <trans-unit id="5fe18782111712f87288c23d1c8fb50a83e580df" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; то же самое &amp;laquo;удовольствие&amp;raquo; в качестве аргумента функции mnesia: sync_transaction (Fun [, Args]), она выполняется в контексте синхронизированной транзакции. Синхронизированные транзакции ждут, пока все активные реплики не зафиксируют транзакцию (на диск), прежде чем вернуться из &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; . Использование &lt;code&gt;sync_transaction&lt;/code&gt; полезно в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="8d8e68091d4403f0e83bd114c70649e6a566d00b" translate="yes" xml:space="preserve">
          <source>By preference, these functions can be included in module &lt;code&gt;shell_default&lt;/code&gt;. By default, they are included in that module.</source>
          <target state="translated">По &lt;code&gt;shell_default&lt;/code&gt; эти функции могут быть включены в модуль shell_default . По умолчанию они включены в этот модуль.</target>
        </trans-unit>
        <trans-unit id="7f254d4f66995179ccfd6ad20889ce3083eb5612" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;SourceMod&lt;/code&gt; and &lt;code&gt;TargetMod&lt;/code&gt; to different modules, a backup can be copied from one backup media to another.</source>
          <target state="translated">Установив &lt;code&gt;SourceMod&lt;/code&gt; и &lt;code&gt;TargetMod&lt;/code&gt; к различным модулям, резервное копирование может быть скопировано из одного резервного носителя к другому.</target>
        </trans-unit>
        <trans-unit id="d49dba3e2b5c5cceb098125c642fa912b7e82445" translate="yes" xml:space="preserve">
          <source>By testing in a bottom-up fashion, beginning with the smallest program units and creating a confidence in that they work as they should, it becomes easier to test that a higher-level component, consisting of several such units, also behaves according to specification (known as &lt;strong&gt;integration testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Путем тестирования снизу вверх, начиная с самых маленьких программных модулей и создавая уверенность в том, что они работают должным образом, становится легче проверить, что компонент более высокого уровня, состоящий из нескольких таких модулей, также ведет себя в соответствии со спецификацией. (известное как &lt;strong&gt;интеграционное тестирование&lt;/strong&gt; ; см. &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff05bbe6b9df494deffc0d26f620950719c544d4" translate="yes" xml:space="preserve">
          <source>By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:</source>
          <target state="translated">Таким образом,можно задать различные настройки для разных частей детали.Любые изменения,внесенные в одну из альтернатив,переносятся на последующие ветви внутри одной и той же подмаски.Например:</target>
        </trans-unit>
        <trans-unit id="35ec349917181f956c0a4c9c0f4a81caa7003c00" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt;, you can specify if Debugger is to be started in local or global mode:</source>
          <target state="translated">Используя &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt; , вы можете указать, должен ли отладчик запускаться в локальном или глобальном режиме:</target>
        </trans-unit>
        <trans-unit id="6da8978f9ea68a7c6f48f6d3c9e527498ef08964" translate="yes" xml:space="preserve">
          <source>By using option &lt;code&gt;handler&lt;/code&gt; when starting the tracer, the information about how to format the file is stored in the trace information file (&lt;code&gt;.ti&lt;/code&gt;). This is not necessary, as it can be specified when formatting instead. However, It can be useful if you, for example, want to format trace logs automatically using option &lt;code&gt;format&lt;/code&gt; in &lt;code&gt;ttb:stop/1&lt;/code&gt;. Also, you do not need any knowledge of the content of a binary log to format it the way it is intended. If option &lt;code&gt;handler&lt;/code&gt; is specified both when starting the tracer and when formatting, the one specified when formatting is used.</source>
          <target state="translated">При использовании &lt;code&gt;handler&lt;/code&gt; опций при запуске трассировщика информация о том, как отформатировать файл, сохраняется в файле информации трассировки ( &lt;code&gt;.ti&lt;/code&gt; ). В этом нет необходимости, так как это можно указать при форматировании. Однако это может быть полезно, если вы, например, хотите автоматически форматировать журналы трассировки с использованием параметра &lt;code&gt;format&lt;/code&gt; в &lt;code&gt;ttb:stop/1&lt;/code&gt; . Кроме того, вам не нужно знать содержимое двоичного журнала, чтобы отформатировать его так, как задумано. Если &lt;code&gt;handler&lt;/code&gt; опций указан как при запуске трассировщика, так и при форматировании, используется тот, который указан при форматировании.</target>
        </trans-unit>
        <trans-unit id="02d1325592a3ef565e5e7f405f91fc17bcd0d42f" translate="yes" xml:space="preserve">
          <source>By using ordinary UNIX tools like &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; one can easily find answers to various questions like:</source>
          <target state="translated">Используя обычные инструменты UNIX, такие как &lt;code&gt;sed&lt;/code&gt; и &lt;code&gt;grep&lt;/code&gt; , можно легко найти ответы на различные вопросы, например:</target>
        </trans-unit>
        <trans-unit id="a2d275dd09349865f8c3284b6c4fd5293841ad62" translate="yes" xml:space="preserve">
          <source>By using the new API, you automatically get scalability and performance improvements. This also enables you to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; that improves accuracy and precision of time measurements.</source>
          <target state="translated">Используя новый API, вы автоматически получаете улучшения масштабируемости и производительности. Это также позволяет использовать режим &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; , повышающий точность и точность измерений времени.</target>
        </trans-unit>
        <trans-unit id="77c257b7be9bfb86770597be303f8b67e4aa586a" translate="yes" xml:space="preserve">
          <source>By wrapping the API with functions that fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable, and using these wrappers instead of using the API directly, the problem is solved. These wrappers can, for example, be implemented as in &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt;.</source>
          <target state="translated">Проблема решена путем обертывания API функциями, которые возвращаются к &lt;code&gt;erlang:now/0&lt;/code&gt; , когда новый API недоступен, и использования этих оболочек вместо прямого использования API. Эти оболочки могут быть реализованы, например, как в &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00bf079d821f3a0145d168bfcf76ce42b727b9c4" translate="yes" xml:space="preserve">
          <source>Bypass all messages to the receiving process.</source>
          <target state="translated">Обходите все сообщения на прием.</target>
        </trans-unit>
        <trans-unit id="0cfa66375624ff2bee2fec17b2715898b2615b30" translate="yes" xml:space="preserve">
          <source>Bypass the native code compilation of some key files that Dialyzer heuristically performs when dialyzing many files. This avoids the compilation time, but can result in (much) longer analysis time.</source>
          <target state="translated">Обходите компиляцию родного кода некоторых ключевых файлов,которую Dialyzer эвристически выполняет при наборе множества файлов.Это позволяет избежать времени компиляции,но может привести к (значительному)увеличению времени анализа.</target>
        </trans-unit>
        <trans-unit id="eed4df1a2c0521e891f717551aca2cc2df95a04a" translate="yes" xml:space="preserve">
          <source>Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte).</source>
          <target state="translated">Байты,которые находятся вне диапазона 0x2A,0x2D,0x2E,0x30 до 0x39,0x41 до 0x5A,0x5F,0x61 до 0x7A,закодированы в процентах (символ U+0025 PERCENT SIGN (%),за которым следуют заглавные гекс-цифры ASCII,представляющие собой шестнадцатеричное значение байта).</target>
        </trans-unit>
        <trans-unit id="0ca15868aa5caba5cda8401a4c79d41061a3d6a4" translate="yes" xml:space="preserve">
          <source>Bytes written to the file by any means are translated to UTF-8 encoding before being stored on the disk file.</source>
          <target state="translated">Байты,записанные в файл любым способом,перед сохранением в дисковом файле переводятся в кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="e48d8a1314ac59090c047f1cace030d6174ffe04" translate="yes" xml:space="preserve">
          <source>C nodes can also register themselves with &lt;code&gt;epmd&lt;/code&gt; if they want other nodes in the system to be able to find and connect to them.</source>
          <target state="translated">Узлы C также могут зарегистрироваться в &lt;code&gt;epmd&lt;/code&gt; , если они хотят, чтобы другие узлы в системе могли их находить и подключаться к ним.</target>
        </trans-unit>
        <trans-unit id="7aaca542e8937ae72090fdd955fe659422678461" translate="yes" xml:space="preserve">
          <source>C-Left</source>
          <target state="translated">C-Left</target>
        </trans-unit>
        <trans-unit id="e2bb854461c349ecc3ae2bfb00ac6727ba113ad8" translate="yes" xml:space="preserve">
          <source>C-Right</source>
          <target state="translated">C-Right</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="1d8e75405de8be939b05db3eef9ab4daa516674d" translate="yes" xml:space="preserve">
          <source>C-d</source>
          <target state="translated">C-d</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="68b4cf03a08cd7bf7acc0d39d68cca6ef0f409f3" translate="yes" xml:space="preserve">
          <source>C-t</source>
          <target state="translated">C-t</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="8e0be97e2cc76979d93e15014888863a6e79a7af" translate="yes" xml:space="preserve">
          <source>C-w</source>
          <target state="translated">C-w</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="27ae2e5d9b51df18972eb310bdefaba625476830" translate="yes" xml:space="preserve">
          <source>CEA is sent and received by diameter.</source>
          <target state="translated">CEA отправляется и принимается по диаметру.</target>
        </trans-unit>
        <trans-unit id="ff534b0e9ae18ae782f79e9fe262a000f3c6ff49" translate="yes" xml:space="preserve">
          <source>CER is sent and received by diameter.</source>
          <target state="translated">CER отправляется и принимается по диаметру.</target>
        </trans-unit>
        <trans-unit id="112d72d949c9bbe40789456cde8492d907b63e28" translate="yes" xml:space="preserve">
          <source>CHARACTER (size), CHAR (size)</source>
          <target state="translated">CHARACTER (размер),CHAR (размер)</target>
        </trans-unit>
        <trans-unit id="24ecce9e5657a884a70aea047867075f09d39ad6" translate="yes" xml:space="preserve">
          <source>CHARACTER VARYING(size), CHAR VARYING(size)</source>
          <target state="translated">CHARACTER VARYING(размер),CHAR VARYING(размер)</target>
        </trans-unit>
        <trans-unit id="4a4f0e1b5b9cde6b772cb89e0e6bdb0a6ab6de56" translate="yes" xml:space="preserve">
          <source>CR, LF, or CRLF only</source>
          <target state="translated">Только CR,LF или CRLF.</target>
        </trans-unit>
        <trans-unit id="d5ab3cb5603f8a4df9b9b5741bc8bf57061a02e7" translate="yes" xml:space="preserve">
          <source>CRL cache</source>
          <target state="translated">CRL-кэш</target>
        </trans-unit>
        <trans-unit id="ff86d60418e1cef1253cf01c43b18051224fcb54" translate="yes" xml:space="preserve">
          <source>CTHs are run with the same process scoping as normal test suites, that is, a different process executes the &lt;code&gt;init_per_suite&lt;/code&gt; hooks then the &lt;code&gt;init_per_group&lt;/code&gt; or &lt;code&gt;per_testcase&lt;/code&gt; hooks. So if you want to spawn a process in the CTH, you cannot link with the CTH process, as it exits after the post hook ends. Also, if you for some reason need an ETS table with your CTH, you must spawn a process that handles it.</source>
          <target state="translated">CTH запускаются с той же областью процесса, что и обычные тестовые наборы, то есть другой процесс выполняет хуки &lt;code&gt;init_per_suite&lt;/code&gt; ,а затем хуки &lt;code&gt;init_per_group&lt;/code&gt; или &lt;code&gt;per_testcase&lt;/code&gt; . Поэтому, если вы хотите создать процесс в CTH, вы не можете связать его с процессом CTH, поскольку он завершается после завершения обработчика post. Кроме того, если вам по какой-то причине нужна таблица ETS с вашим CTH, вы должны создать процесс, который ее обрабатывает.</target>
        </trans-unit>
        <trans-unit id="7e6e1792db904ba826af372ccec45b6e25fb5024" translate="yes" xml:space="preserve">
          <source>CTHs can also be added within a test suite. This is done by returning &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; in the configuration list from &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CTH также можно добавить в набор тестов. Это делается путем возврата &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; в списке конфигурации из &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cebcaf761552337b6a6de3a9db00451f69633f4b" translate="yes" xml:space="preserve">
          <source>CTHs can be used to synchronize test runs with external user applications. The init function can, for example, start and/or communicate with an application that has the purpose of preparing the SUT for an upcoming test run, or initialize a database for saving test data to during the test run. The terminate function can similarly order such an application to reset the SUT after the test run, and/or tell the application to finish active sessions and terminate. Any system error- or progress reports generated during the init- or termination stage are saved in the &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt;. (This is also true for any printouts made with &lt;code&gt;ct:log/2&lt;/code&gt; and &lt;code&gt;ct:pal/2&lt;/code&gt;).</source>
          <target state="translated">CTH можно использовать для синхронизации тестовых прогонов с внешними пользовательскими приложениями. Функция init может, например, запускать и / или связываться с приложением, целью которого является подготовка SUT к предстоящему тесту, или инициализировать базу данных для сохранения тестовых данных во время выполнения теста. Функция завершения может аналогичным образом приказать такому приложению сбросить ТУС после выполнения теста и / или сообщить приложению о завершении активных сеансов и завершении. Любые системные сообщения об ошибках или отчеты о ходе выполнения, созданные на этапе инициации или завершения, сохраняются в журнале &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt; до и после тестирования . (Это также верно для любых распечаток, сделанных с помощью &lt;code&gt;ct:log/2&lt;/code&gt; и &lt;code&gt;ct:pal/2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1413152f77878171b8b1aa5bd33bfea4b91b1e35" translate="yes" xml:space="preserve">
          <source>CTHs cannot be added here right now. That feature may be added in a later release, but it would right now break backwards compatibility.</source>
          <target state="translated">КТГ не может быть добавлена сюда прямо сейчас.Эта функция может быть добавлена в более позднем выпуске,но это нарушит обратную совместимость прямо сейчас.</target>
        </trans-unit>
        <trans-unit id="27930480546a406089acbe7e97d210e59cf3f0a5" translate="yes" xml:space="preserve">
          <source>Caches a new session or updates an already cached one. Is only called from the cache handling process.</source>
          <target state="translated">Кэширует новую сессию или обновляет уже кэшированную.Вызывается только из процесса обработки кэша.</target>
        </trans-unit>
        <trans-unit id="a61c27140fecb8e4a22ce80c81760b45147855bd" translate="yes" xml:space="preserve">
          <source>Calculate scheduler utilizations for the time interval from when &lt;code&gt;Sample&lt;/code&gt; was taken and &quot;now&quot;. The same as calling &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt;.</source>
          <target state="translated">Рассчитайте использование планировщика для временного интервала от момента взятия &lt;code&gt;Sample&lt;/code&gt; до &amp;laquo;сейчас&amp;raquo;. То же, что и вызов &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3159ceb44a5156030b65aa273f276c3747dcacc9" translate="yes" xml:space="preserve">
          <source>Calculates a key for later use in &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt;. The keys are evenly distributed so that a fair mapping between port IDs and async thread IDs is achieved.</source>
          <target state="translated">Вычисляет ключ для последующего использования в &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; . Ключи распределяются равномерно, так что достигается справедливое сопоставление между идентификаторами портов и идентификаторами асинхронных потоков.</target>
        </trans-unit>
        <trans-unit id="97a16654177af632fa24a3c60a60a85917da19f0" translate="yes" xml:space="preserve">
          <source>Calculates a ssh fingerprint from a public host key as openssh does.</source>
          <target state="translated">Вычисляет отпечаток ssh с открытого ключа хоста,как это делает openssh.</target>
        </trans-unit>
        <trans-unit id="96b67c5752326af1f998bcfc9d0641aa609cb938" translate="yes" xml:space="preserve">
          <source>Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included).</source>
          <target state="translated">Вычисляет проверку MD5 резервирования для кода модуля (дата компиляции и другие атрибуты не включены).</target>
        </trans-unit>
        <trans-unit id="49556b91adcf0245cb3d710749c75861fa022a4f" translate="yes" xml:space="preserve">
          <source>Calculates and returns the length of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">Вычисляет и возвращает длину очереди &lt;code&gt;Q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e81ece084c83acdfbcc583fdce8e53ba5b901b1" translate="yes" xml:space="preserve">
          <source>Calculates scheduler utilizations for the time interval between the two samples obtained from calling &lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вычисляет использование планировщика для временного интервала между двумя выборками, полученными при вызове &lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="227b790ced77d840153cd69f4b9d2467f87af6d9" translate="yes" xml:space="preserve">
          <source>Calculates the Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">Вычисляет контрольную сумму Adler-32 для &lt;code&gt;Data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f486ba07e5a51271bcf5c7397d6baef999b087f1" translate="yes" xml:space="preserve">
          <source>Calculates the CRC checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">Вычисляет контрольную сумму CRC для &lt;code&gt;Data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8a87c52d80ef29c6c7f4e720f1eb69b8f5e769" translate="yes" xml:space="preserve">
          <source>Calculates the time difference &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; in &lt;strong&gt;microseconds&lt;/strong&gt;, where &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are time-stamp tuples on the same format as returned from &lt;code&gt;erlang:timestamp/0&lt;/code&gt; or &lt;code&gt;os:timestamp/0&lt;/code&gt;.</source>
          <target state="translated">Вычисляет разницу во времени &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; в &lt;strong&gt;микросекундах&lt;/strong&gt; , где &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; - это кортежи отметок времени в том же формате, что и возвращенные из &lt;code&gt;erlang:timestamp/0&lt;/code&gt; или &lt;code&gt;os:timestamp/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e631ed71da6b22331e1ba2c1ab40350acc8c94" translate="yes" xml:space="preserve">
          <source>Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format. The following condition applies always:</source>
          <target state="translated">Вычисляет,без кодирования,максимальный размер байта для термина,закодированного во внешнем терминологическом формате Erlang.При этом всегда действует следующее условие:</target>
        </trans-unit>
        <trans-unit id="d9a2b0161d342ba687bae1cf3bd6fc16726fc85e" translate="yes" xml:space="preserve">
          <source>Call ::= FunSpec &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt;MFA&lt;code&gt;,&lt;/code&gt; MFA&lt;code&gt;}&lt;/code&gt; | AtomConst &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt;AtomConst&lt;code&gt;,&lt;/code&gt; AtomConst&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">Вызов :: = FunSpec &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt; МИД &lt;code&gt;,&lt;/code&gt; МИД &lt;code&gt;}&lt;/code&gt; | АтомКонст &lt;code&gt;-&amp;gt;&lt;/code&gt; АтомКонст | &lt;code&gt;{&lt;/code&gt; AtomConst &lt;code&gt;,&lt;/code&gt; AtomConst &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87defee9508517c6c10659d4e0fee5236449ad6" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, pass to it a pointer to the dirty NIF to be executed, and indicate with argument &lt;code&gt;flags&lt;/code&gt; whether it expects the operation to be CPU-bound or I/O-bound.</source>
          <target state="translated">Вызовите &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; , передайте ему указатель на грязный NIF, который должен быть выполнен, и укажите с помощью &lt;code&gt;flags&lt;/code&gt; аргументов , ожидает ли он, что операция будет связана с процессором или вводом-выводом.</target>
        </trans-unit>
        <trans-unit id="69bfcf4495124cb65edd6183c66a7288de41dd51" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;analyze&lt;/code&gt; with &lt;code&gt;total&lt;/code&gt; option when profiling has been stopped to display the results per function call, that is in which function calls the time has been spent.</source>
          <target state="translated">Вызов &lt;code&gt;analyze&lt;/code&gt; с опцией &lt;code&gt;total&lt;/code&gt; , когда профилирование было остановлено, чтобы отобразить результаты для каждого вызова функции, то есть на вызовы какой функции было потрачено время.</target>
        </trans-unit>
        <trans-unit id="166bcff3bd03bad3b22be129a767e953b92bb7c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">Информация &lt;code&gt;info&lt;/code&gt; звонке :</target>
        </trans-unit>
        <trans-unit id="9b32de2da67e0b479c6558da688c298d2c8d61df" translate="yes" xml:space="preserve">
          <source>Call Graph Edges (*).</source>
          <target state="translated">Звоните в &quot;График краев&quot; (*).</target>
        </trans-unit>
        <trans-unit id="ee61800f5d1b4760400245c96aa2f8c30730dd00" translate="yes" xml:space="preserve">
          <source>Call Graph Vertices (*).</source>
          <target state="translated">Вызовите графические вершины (*).</target>
        </trans-unit>
        <trans-unit id="4517bf0f809aaf1e241952932bd6d071e97a1670" translate="yes" xml:space="preserve">
          <source>Call a NIF that first performs a chunk of the work, then invokes the &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</source>
          <target state="translated">Вызов NIF, который сначала выполняет часть работы, а затем вызывает функцию &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; , чтобы запланировать другой вызов NIF для выполнения следующего фрагмента. Последний вызов, запланированный таким образом, может затем вернуть общий результат.</target>
        </trans-unit>
        <trans-unit id="9e64aca1cbd78581418480040f30e164b840d03b" translate="yes" xml:space="preserve">
          <source>Call back function to accumulate contents of entity.</source>
          <target state="translated">Функция обратного вызова для накопления содержимого сущности.</target>
        </trans-unit>
        <trans-unit id="25cbcf90fa280c9778e7621dfdd70289b3357c4e" translate="yes" xml:space="preserve">
          <source>Call back function to decide what to do if the scanner runs into EOF before the document is complete.</source>
          <target state="translated">Функция обратного вызова,чтобы решить,что делать,если сканер запустится в EOF до завершения работы над документом.</target>
        </trans-unit>
        <trans-unit id="305e72ce9d0178fb37627379b7066e3998f1aaff" translate="yes" xml:space="preserve">
          <source>Call back function to fetch an external resource.</source>
          <target state="translated">Функция обратного вызова для получения внешнего ресурса.</target>
        </trans-unit>
        <trans-unit id="f1d17c05f561817d9262782ed4703874ffa16a47" translate="yes" xml:space="preserve">
          <source>Call back function to handle scanner events.</source>
          <target state="translated">Функция обратного вызова для обработки событий сканера.</target>
        </trans-unit>
        <trans-unit id="967a892c17aad400146f3cd8a0b41cd0e008b98d" translate="yes" xml:space="preserve">
          <source>Call back function to process the document entities once identified.</source>
          <target state="translated">Функция обратного вызова для обработки документов после их идентификации.</target>
        </trans-unit>
        <trans-unit id="e43990d9029a1b5faffe47cfb2a73c40d38948b7" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradation in the vicinity of 10 percent.</source>
          <target state="translated">По сравнению с другими формами трассировки,трассировка по количеству вызовов очень легкая,так как не требуется генерировать сообщение об отслеживании.Некоторые измерения указывают на снижение производительности примерно на 10 процентов.</target>
        </trans-unit>
        <trans-unit id="1d9d8ff2abc216537369a4f6c51252cf41bb671a" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradations in the vicinity of 10 percent.</source>
          <target state="translated">По сравнению с другими формами трассировки,трассировка по количеству вызовов очень легкая,так как не требуется генерировать сообщение об отслеживании.Некоторые измерения указывают на снижение производительности примерно на 10 процентов.</target>
        </trans-unit>
        <trans-unit id="9ed8c88acf1e0b8225e507d6c8cef5617c61d6b6" translate="yes" xml:space="preserve">
          <source>Call these iteration functions on nodes that contain a replica of the table. Each call to the function &lt;code&gt;Fun&lt;/code&gt; access the table and if the table resides on another node it generates much unnecessary network traffic.</source>
          <target state="translated">Вызовите эти функции итерации на узлах, которые содержат реплику таблицы. Каждый вызов функции &lt;code&gt;Fun&lt;/code&gt; обращается к таблице, и если таблица находится на другом узле, она генерирует много ненужного сетевого трафика.</target>
        </trans-unit>
        <trans-unit id="92a83b9ff602a28ae97d4ee0c90eb3fa1240e7fa" translate="yes" xml:space="preserve">
          <source>Call this function to stop cover test on nodes previously added with &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt;. Results on the remote node are transferred to the &lt;code&gt;Common Test&lt;/code&gt; node.</source>
          <target state="translated">Вызовите эту функцию, чтобы остановить проверку покрытия на узлах, ранее добавленных с помощью &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt; . Результаты на удаленном узле передаются на узел &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37045b168b3bc333ac8bca52ef56747d12a1101f" translate="yes" xml:space="preserve">
          <source>Call this function when profiling has been stopped to display the results per process, that is:</source>
          <target state="translated">Вызовите эту функцию,когда профилирование было остановлено,чтобы отобразить результаты для каждого процесса,то есть:</target>
        </trans-unit>
        <trans-unit id="eea8e2a2479f703038c465d2c2ffcd082e88cb6f" translate="yes" xml:space="preserve">
          <source>Callback = atom()</source>
          <target state="translated">Обратный вызов=atom()</target>
        </trans-unit>
        <trans-unit id="61dfb922d9f46c947d009d0fb95ea292779f3dc7" translate="yes" xml:space="preserve">
          <source>Callback for &lt;code&gt;ct_telnet.erl&lt;/code&gt;.</source>
          <target state="translated">Обратный &lt;code&gt;ct_telnet.erl&lt;/code&gt; для ct_telnet.erl .</target>
        </trans-unit>
        <trans-unit id="7e45c8484398e4aeac5267b27d0e1fb6f862e303" translate="yes" xml:space="preserve">
          <source>Callback function &lt;code&gt;TraverseFun&lt;/code&gt; is used for traversing the table. It is to return a list of objects terminated by either &lt;code&gt;[]&lt;/code&gt; or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary &lt;code&gt;TraverseFun&lt;/code&gt;s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling &lt;code&gt;qlc:table/2&lt;/code&gt; and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, &lt;code&gt;TraverseFun&lt;/code&gt; is called with a match specification returning every object.</source>
          <target state="translated">Функция обратного вызова &lt;code&gt;TraverseFun&lt;/code&gt; используется для обхода таблицы. Он должен возвращать список объектов, завершаемых либо &lt;code&gt;[]&lt;/code&gt; , либо нулевым значением, которое будет использоваться для обхода еще не пройденных объектов таблицы. Любое другое возвращаемое значение немедленно возвращается как значение оценки запроса. Унарные &lt;code&gt;TraverseFun&lt;/code&gt; должны принимать в качестве аргумента спецификацию соответствия. Спецификация соответствия создается преобразованием синтаксического анализа путем анализа шаблона генератора, вызывающего &lt;code&gt;qlc:table/2&lt;/code&gt; , и фильтрации с использованием переменных, представленных в шаблоне. Если преобразование синтаксического анализа не может найти спецификацию совпадения, эквивалентную шаблону и фильтрам, &lt;code&gt;TraverseFun&lt;/code&gt; вызывается со спецификацией совпадения, возвращающей каждый объект.</target>
        </trans-unit>
        <trans-unit id="04f9a377a5245adf1c0c727ef509b19ea04d764a" translate="yes" xml:space="preserve">
          <source>Callback functions</source>
          <target state="translated">Функции обратного вызова</target>
        </trans-unit>
        <trans-unit id="37556ac19058ca5c17bab63cd838a12f2880d206" translate="yes" xml:space="preserve">
          <source>Callback functions that are optional for the user of the behaviour to implement are specified by use of the &lt;code&gt;-optional_callbacks&lt;/code&gt; attribute:</source>
          <target state="translated">Функции обратного вызова, которые не являются обязательными для пользователя реализуемого поведения, указываются с помощью атрибута &lt;code&gt;-optional_callbacks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a04bb6692677302b06dcc4155d24ffed7a1d8b90" translate="yes" xml:space="preserve">
          <source>Callback invoked prior to terminating the transport process of a transport connection having watchdog state &lt;code&gt;OKAY&lt;/code&gt;. Applied to &lt;code&gt;application|service|transport&lt;/code&gt; and the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; in question: &lt;code&gt;application&lt;/code&gt; indicates that the diameter application is being stopped, &lt;code&gt;service&lt;/code&gt; that the service in question is being stopped by &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;transport&lt;/code&gt; that the transport in question is being removed by &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратный вызов вызывается до завершения транспортного процесса транспортного соединения, имеющего сторожевое состояние &lt;code&gt;OKAY&lt;/code&gt; . Применяется к &lt;code&gt;application|service|transport&lt;/code&gt; и рассматриваемым &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; и &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; : &lt;code&gt;application&lt;/code&gt; указывает, что приложение &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt; останавливается, &lt;code&gt;service&lt;/code&gt; , о которой идет речь, останавливается с помощью stop_service / 1 , и &lt;code&gt;transport&lt;/code&gt; что транспорт рассматриваемый вопрос удаляется &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66eade566a1aabb00b9616d9f85c98561a92d0e8" translate="yes" xml:space="preserve">
          <source>Callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether or not the connection should be accepted. Applied to the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;#diameter_caps{}&lt;/code&gt; record of the connection.</source>
          <target state="translated">Обратный вызов вызывается при получении CER / CEA во время обмена возможностями, чтобы спросить, следует ли принимать соединение. Применяется к записи соединения &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; и &lt;code&gt;#diameter_caps{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8170a9b43176c43c83ab38fea10e4e72c195d1f2" translate="yes" xml:space="preserve">
          <source>Callback module for &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">Модуль обратного вызова для &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; , для подключения к серверу Telnet на хосте UNIX.</target>
        </trans-unit>
        <trans-unit id="723d576b61f4090ef99d45ef635768456422a654" translate="yes" xml:space="preserve">
          <source>Callback module for ct_telnet, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">Модуль обратного вызова для ct_telnet,для подключения к Telnet-серверу на UNIX-хосте.</target>
        </trans-unit>
        <trans-unit id="c6227e8f008e1e3653b7695696953858c51a783a" translate="yes" xml:space="preserve">
          <source>Callback module for customized logging of errors, warnings, and info messages. The callback module must implement the &lt;code&gt;tftp_logger&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt;. The default module is &lt;code&gt;tftp_logger&lt;/code&gt;.</source>
          <target state="translated">Модуль обратного вызова для настраиваемой регистрации ошибок, предупреждений и информационных сообщений. Модуль обратного вызова должен реализовывать поведение &lt;code&gt;tftp_logger&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt; . Модуль по умолчанию - &lt;code&gt;tftp_logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac834d27797dbad127ce8fd6d8a2319b5f46c402" translate="yes" xml:space="preserve">
          <source>Callback module for users of the Megaco application</source>
          <target state="translated">Модуль обратного вызова для пользователей приложения Megaco</target>
        </trans-unit>
        <trans-unit id="55798c61abfa41a7a5297d6740d1e64b1d565485" translate="yes" xml:space="preserve">
          <source>Callback module in which messages of the Diameter application are handled. See &lt;code&gt;diameter_app(3)&lt;/code&gt; for the required interface and semantics.</source>
          <target state="translated">Модуль обратного вызова, в котором обрабатываются сообщения приложения Diameter. См. &lt;code&gt;diameter_app(3)&lt;/code&gt; для получения информации о необходимом интерфейсе и семантике.</target>
        </trans-unit>
        <trans-unit id="63edefe6aafdd040e89d039ff830e8a61ffa1b95" translate="yes" xml:space="preserve">
          <source>Callback modules for &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;gen_event&lt;/code&gt; can also change the value of &lt;code&gt;Misc&lt;/code&gt; by exporting a function &lt;code&gt;format_status/2&lt;/code&gt;, which contributes module-specific information. For details, see &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратный звонок модули для &lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; и &lt;code&gt;gen_event&lt;/code&gt; также могут изменить значение &lt;code&gt;Misc&lt;/code&gt; путем экспорта функции &lt;code&gt;format_status/2&lt;/code&gt; , что способствует информации о модуле конкретной. Подробнее см &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a42e9b08e0786b523d53e7aaa69806b6b4c7c7b" translate="yes" xml:space="preserve">
          <source>Callback timeouts</source>
          <target state="translated">таймауты обратного вызова</target>
        </trans-unit>
        <trans-unit id="1424d68bc26afe36f6e438d92e2344fe5359e183" translate="yes" xml:space="preserve">
          <source>Called after an asynchronous call has completed. The asynchronous call is started with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt;. This function is called from the Erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multi-threading is enabled).</source>
          <target state="translated">Вызывается после завершения асинхронного вызова. Асинхронный вызов запускается с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt; . Эта функция вызывается из потока эмулятора Erlang, в отличие от асинхронной функции, которая вызывается в некотором потоке (если включена многопоточность).</target>
        </trans-unit>
        <trans-unit id="308f76c161337017286f205aef3ab09cb6ea041d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the master-agent for primary processing.</source>
          <target state="translated">Вызывается после завершения базовой обработки сообщения (MPD),но до передачи pdu ведущему агенту для первичной обработки.</target>
        </trans-unit>
        <trans-unit id="a313d3073d9eea56873be11a826fd840a7e0d86d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the server for primary processing.</source>
          <target state="translated">Вызывается после выполнения основной обработки сообщений (MPD),но до передачи pdu на сервер для первичной обработки.</target>
        </trans-unit>
        <trans-unit id="e5fe3aacb675f5586e55ac426e9e29a0553867e0" translate="yes" xml:space="preserve">
          <source>Called any time after the driver's timer reaches &lt;code&gt;0&lt;/code&gt;. The timer is activated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt;. No priorities or ordering exist among drivers, so if several drivers time out at the same time, anyone of them is called first.</source>
          <target state="translated">Вызывается в любое время после того, как таймер драйвера достигает &lt;code&gt;0&lt;/code&gt; . Таймер активируется с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt; . Среди драйверов не существует приоритетов или упорядочения, поэтому, если время ожидания нескольких драйверов истекает одновременно, любой из них вызывается первым.</target>
        </trans-unit>
        <trans-unit id="81eabbdc5601ceaa0bccb714043c53b451726d6f" translate="yes" xml:space="preserve">
          <source>Called at the reception of a message (before &lt;strong&gt;any&lt;/strong&gt; processing has been done).</source>
          <target state="translated">Вызывается при получении сообщения (до выполнения &lt;strong&gt;какой-либо&lt;/strong&gt; обработки).</target>
        </trans-unit>
        <trans-unit id="bf59df7706e69db3cc159c1ee57e97f02070c14b" translate="yes" xml:space="preserve">
          <source>Called before the basic message processing (MPD) is done, when a pdu has been received from the master-agent.</source>
          <target state="translated">Вызывается перед обработкой основных сообщений (MPD),когда от ведущего-агента получен канал.</target>
        </trans-unit>
        <trans-unit id="67cc06ab5c5cdaf22f4e18059ff7135bed75b26e" translate="yes" xml:space="preserve">
          <source>Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; as part of its return value.</source>
          <target state="translated">Вызывается до того, как приколы не зарегистрированы. Здесь можно произвести любую уборку. Возвращаемое значение не важно, но передается обратно вызывающей стороне &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; как часть возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="60cc53ceda191e4c7c43073a2ca95d2429376ca7" translate="yes" xml:space="preserve">
          <source>Called before the sending of a message (after &lt;strong&gt;all&lt;/strong&gt; processing has been done).</source>
          <target state="translated">Вызывается перед отправкой сообщения (после завершения &lt;strong&gt;всей&lt;/strong&gt; обработки).</target>
        </trans-unit>
        <trans-unit id="411e859542f736dac045f8721e0a466752068640" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Host&lt;/code&gt; defaults to the localhost. Returns the names and associated port numbers of the Erlang nodes that &lt;code&gt;epmd&lt;/code&gt; registered at the specified host. Returns &lt;code&gt;{error, address}&lt;/code&gt; if &lt;code&gt;epmd&lt;/code&gt; is not operational.</source>
          <target state="translated">Вызывается &lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;Host&lt;/code&gt; умолчанию используется локальный хост . Возвращает имена и связанные номера портов узлов Erlang, которые &lt;code&gt;epmd&lt;/code&gt; зарегистрировал на указанном хосте. Возвращает &lt;code&gt;{error, address}&lt;/code&gt; если &lt;code&gt;epmd&lt;/code&gt; не работает.</target>
        </trans-unit>
        <trans-unit id="754186ab8b7082c0674d04f3bdaf7fcddc1ab3a3" translate="yes" xml:space="preserve">
          <source>Called by the &lt;code&gt;erl_ddll&lt;/code&gt; driver when the driver is unloaded. (It is only called in dynamic drivers.)</source>
          <target state="translated">Вызывается драйвером &lt;code&gt;erl_ddll&lt;/code&gt; , когда драйвер выгружается. (Он вызывается только в динамических драйверах.)</target>
        </trans-unit>
        <trans-unit id="650a5975977f531507f62d29a2ce95a7a1cfb83f" translate="yes" xml:space="preserve">
          <source>Called by the distribution module. Resolves the &lt;code&gt;Host&lt;/code&gt; to an IP address.</source>
          <target state="translated">Вызывается модулем распределения. Преобразует &lt;code&gt;Host&lt;/code&gt; в IP-адрес.</target>
        </trans-unit>
        <trans-unit id="e6e67ee5139f5c3d24c6add77615125e4e640a01" translate="yes" xml:space="preserve">
          <source>Called directly after the driver has been loaded by &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; (actually when the driver is added to the driver list). The driver is to return &lt;code&gt;0&lt;/code&gt;, or, if the driver cannot initialize, &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">Вызывается сразу после загрузки драйвера из &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; (фактически, когда драйвер добавляется в список драйверов). Драйвер должен вернуть &lt;code&gt;0&lt;/code&gt; или, если драйвер не может инициализировать, &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="262d7b78c6487d8a39946866f1d11a39d5496a09" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to continue its execution (for example, after it has been suspended). This function never returns.</source>
          <target state="translated">Вызывается из &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; , когда процесс должен продолжить свое выполнение (например, после того, как он был приостановлен). Эта функция никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="73172cc1a7cb2d69c85f4a96da6765b4101ba755" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to perform a code change. The code change is used when the internal data structure has changed. This function converts argument &lt;code&gt;Misc&lt;/code&gt; to the new data structure. &lt;code&gt;OldVsn&lt;/code&gt; is attribute &lt;strong&gt;vsn&lt;/strong&gt; of the old version of the &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the atom &lt;code&gt;undefined&lt;/code&gt; is sent.</source>
          <target state="translated">Вызывается из &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; , когда процесс должен выполнить изменение кода. Изменение кода используется при изменении внутренней структуры данных. Эта функция преобразует аргумент &lt;code&gt;Misc&lt;/code&gt; в новую структуру данных. &lt;code&gt;OldVsn&lt;/code&gt; - атрибут &lt;strong&gt;vsn&lt;/strong&gt; старой версии &lt;code&gt;Module&lt;/code&gt; . Если такой атрибут не определен, отправляется атом &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="594143f9a65ae1c6fe10c4f338068b8a9f905601" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to replace its current state. &lt;code&gt;NState&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызывается из &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; , когда процесс должен заменить свое текущее состояние. &lt;code&gt;NState&lt;/code&gt; - это значение, возвращаемое &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b3e834b715a254168526e411e95a8a48713b20" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to return a term that reflects its current state. &lt;code&gt;State&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызывается из &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; , когда процесс должен вернуть термин, отражающий его текущее состояние. &lt;code&gt;State&lt;/code&gt; - это значение, возвращаемое &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c98925793456e56a2d33122eb6a311fa293f3d" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to terminate. For example, this function is called when the process is suspended and its parent orders shutdown. It gives the process a chance to do a cleanup. This function never returns.</source>
          <target state="translated">Вызывается из &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; , когда процесс должен завершиться. Например, эта функция вызывается, когда процесс приостановлен и его родитель приказывает завершить работу. Это дает процессу возможность выполнить очистку. Эта функция никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="ee779128abb96dcaaa77c4845eb5b58fcbdf4ab2" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt;. It works a lot like the &lt;code&gt;control&lt;/code&gt; callback, but uses the external term format for input and output.</source>
          <target state="translated">Вызывается из &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt; . Он работает так же, как обратный вызов элемента &lt;code&gt;control&lt;/code&gt; , но использует внешний формат термина для ввода и вывода.</target>
        </trans-unit>
        <trans-unit id="eda5333bad3b8e6536c6e400a545bf0c68561f86" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="translated">Вызывается из &lt;code&gt;erlang:open_port/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c95806576ffd5c6e9bda3738995849c83e6d48" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_call/3&lt;/code&gt;.</source>
          <target state="translated">Вызывается из &lt;code&gt;erlang:port_call/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37967ef10d51ab9623c55cce347e8ac82ffaa69f" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_control/3&lt;/code&gt;.</source>
          <target state="translated">Вызывается из &lt;code&gt;erlang:port_control/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76a9c293f08a9964ffe8949415ea15fcd479022c" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:send/2&lt;/code&gt; and &lt;code&gt;erlang:port_command/2&lt;/code&gt;.</source>
          <target state="translated">Вызывается из &lt;code&gt;erlang:send/2&lt;/code&gt; и &lt;code&gt;erlang:port_command/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b7712d2af65521477e16f6013575117d34b96c0" translate="yes" xml:space="preserve">
          <source>Called in order to close the &lt;code&gt;Listen&lt;/code&gt; handle that originally was passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback.</source>
          <target state="translated">Вызывается, чтобы закрыть дескриптор &lt;code&gt;Listen&lt;/code&gt; , который первоначально был передан из обратного вызова &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="470a1c0ce98f90a6c63285d61ce7082f47f6706f" translate="yes" xml:space="preserve">
          <source>Called on behalf of &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; when it is safe to close an event object.</source>
          <target state="translated">Вызывается от имени &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; , когда можно безопасно закрыть объект события.</target>
        </trans-unit>
        <trans-unit id="23ff0ae2399ea44f77132823a27ee56494ae7347" translate="yes" xml:space="preserve">
          <source>Called to instruct the manager that this agent shall be handled. This function is used when the user knows in advance which agents the manager shall handle. Note that there is an alternate way to do the same thing: Add the agent to the manager config files (see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Вызывается, чтобы проинструктировать менеджера, что этот агент должен быть обработан. Эта функция используется, когда пользователь заранее знает, с какими агентами должен работать менеджер. Обратите внимание, что есть альтернативный способ сделать то же самое: добавить агент в файлы конфигурации менеджера (см. &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c4e12b2b87e916464a480eeba6c90e011990c07" translate="yes" xml:space="preserve">
          <source>Called when a driver event (specified in parameter &lt;code&gt;event&lt;/code&gt;) is signaled. This is used to help asynchronous drivers &quot;wake up&quot; when something occurs.</source>
          <target state="translated">Вызывается, когда сигнализируется событие драйвера (указанное в параметре &lt;code&gt;event&lt;/code&gt; ). Это используется, чтобы помочь асинхронным драйверам &amp;laquo;проснуться&amp;raquo;, когда что-то происходит.</target>
        </trans-unit>
        <trans-unit id="f5f6a024fd8f77a2ea9867d6adcf09937e5b321e" translate="yes" xml:space="preserve">
          <source>Called when a monitored process exits. The &lt;code&gt;drv_data&lt;/code&gt; is the data associated with the port for which the process is monitored (using &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt;) and the &lt;code&gt;monitor&lt;/code&gt; corresponds to the &lt;code&gt;ErlDrvMonitor&lt;/code&gt; structure filled in when creating the monitor. The driver interface function &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; can be used to retrieve the process ID of the exiting process as an &lt;code&gt;ErlDrvTermData&lt;/code&gt;.</source>
          <target state="translated">Вызывается, когда отслеживаемый процесс завершается. &lt;code&gt;drv_data&lt;/code&gt; это данные , связанные с портом , для которых процесс контролируется ( с использованием &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt; ) и &lt;code&gt;monitor&lt;/code&gt; соответствует &lt;code&gt;ErlDrvMonitor&lt;/code&gt; структуре заполненных при создании монитора. Функция интерфейса драйвера &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; может использоваться для получения идентификатора процесса &lt;code&gt;ErlDrvTermData&lt;/code&gt; процесса в виде ErlDrvTermData .</target>
        </trans-unit>
        <trans-unit id="d67e2aa0c472d7e1f331918d874d82a46a103385" translate="yes" xml:space="preserve">
          <source>Called when a port is closed.</source>
          <target state="translated">Вызывается,когда порт закрыт.</target>
        </trans-unit>
        <trans-unit id="9f79f35f10e231c1c5d46754dcc831f0124571c5" translate="yes" xml:space="preserve">
          <source>Called when an Erlang process has sent data to the port. The data is pointed to by &lt;code&gt;buf&lt;/code&gt;, and is &lt;code&gt;len&lt;/code&gt; bytes. Data is sent to the port with &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; or with &lt;code&gt;erlang:port_command/2&lt;/code&gt;. Depending on how the port was opened, it is to be either a list of integers &lt;code&gt;0...255&lt;/code&gt; or a binary. See &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызывается, когда процесс Erlang отправляет данные в порт. На данные указывает &lt;code&gt;buf&lt;/code&gt; и они имеют &lt;code&gt;len&lt;/code&gt; байтов. Данные отправляются в порт с &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; или с помощью &lt;code&gt;erlang:port_command/2&lt;/code&gt; . В зависимости от того, как порт был открыт, это должен быть список целых чисел &lt;code&gt;0...255&lt;/code&gt; или двоичный. Смотрите &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fefd076009119dd92492aabc22699c37cd1acfde" translate="yes" xml:space="preserve">
          <source>Called when document has been completely parsed.</source>
          <target state="translated">Вызывается,когда документ полностью разобран.</target>
        </trans-unit>
        <trans-unit id="d9d5c990ed44bfe60f747ede5eb6362b963aa6ee" translate="yes" xml:space="preserve">
          <source>Called when it is possible to write to a socket.</source>
          <target state="translated">Вызывается,когда можно писать в розетку.</target>
        </trans-unit>
        <trans-unit id="ea08619d53f9130eaa9e346bb5fa5aec56010fde" translate="yes" xml:space="preserve">
          <source>Called when the driver is instantiated, when &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; is called. The driver is to return a number &amp;gt;= 0 or a pointer, or, if the driver cannot be started, one of three error codes:</source>
          <target state="translated">Вызывается при создании экземпляра драйвера, когда &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; . Драйвер должен вернуть число&amp;gt; = 0 или указатель, или, если драйвер не может быть запущен, один из трех кодов ошибки:</target>
        </trans-unit>
        <trans-unit id="c7878482ce6f10c4027034352ce73f5aaa4ce9cf" translate="yes" xml:space="preserve">
          <source>Called when the driver is unloaded. A distribution driver will never be unloaded, but we include this for completeness. To be able to clean up after oneself is always a good thing.</source>
          <target state="translated">Вызывается,когда водитель выгружается.Драйвер дистрибутива никогда не будет выгружен,но мы включаем его для полноты.Способность убирать за собой-это всегда хорошо.</target>
        </trans-unit>
        <trans-unit id="e9777a1b7d37a6943bc53bf03a6d0e91d50d751f" translate="yes" xml:space="preserve">
          <source>Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; is returned, &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; is registered instead of &lt;code&gt;CryptoKeyFun&lt;/code&gt;. If &lt;code&gt;{error, Term}&lt;/code&gt; is returned, the registration is aborted and &lt;code&gt;crypto_key_fun/1&lt;/code&gt; also returns &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="translated">Вызывается при регистрации веселья в процессе, в котором проводится веселье. Здесь криптоключ Fun может выполнять любые необходимые инициализации. Если возвращается &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; , &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; регистрируется вместо &lt;code&gt;CryptoKeyFun&lt;/code&gt; . Если &lt;code&gt;{error, Term}&lt;/code&gt; возвращается, регистрация прерывается и &lt;code&gt;crypto_key_fun/1&lt;/code&gt; также возвращает &lt;code&gt;{error, Term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ad7a8527ae38bbbd2d4e06002457415af632b3" translate="yes" xml:space="preserve">
          <source>Called when the key is needed for module &lt;code&gt;Module&lt;/code&gt; in the file named &lt;code&gt;Filename&lt;/code&gt;. &lt;code&gt;Mode&lt;/code&gt; is the type of crypto algorithm; currently, the only possible value is &lt;code&gt;des3_cbc&lt;/code&gt;. The call is to fail (raise an exception) if no key is available.</source>
          <target state="translated">Вызывается, когда требуется ключ для модуля &lt;code&gt;Module&lt;/code&gt; в файле с именем &lt;code&gt;Filename&lt;/code&gt; . &lt;code&gt;Mode&lt;/code&gt; - это тип криптоалгоритма; в настоящее время единственное возможное значение - &lt;code&gt;des3_cbc&lt;/code&gt; . Вызов должен завершиться ошибкой (вызвать исключение), если ключ недоступен.</target>
        </trans-unit>
        <trans-unit id="0dcbf03fb42831c6723cb1715f47765453867f67" translate="yes" xml:space="preserve">
          <source>Called when the port is about to be closed, and there is data in the driver queue that must be flushed before 'stop' can be called.</source>
          <target state="translated">Вызывается,когда порт вот-вот закроется,и в очереди драйвера есть данные,которые должны быть промыты,прежде чем можно будет вызвать 'stop'.</target>
        </trans-unit>
        <trans-unit id="8919d79f584bde48131fa0a13624f5f0b5dd1e5e" translate="yes" xml:space="preserve">
          <source>Called when the port is closed, with &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;Port ! {self(), close}&lt;/code&gt;. Notice that terminating the port owner process also closes the port. If &lt;code&gt;drv_data&lt;/code&gt; is a pointer to memory allocated in &lt;code&gt;start&lt;/code&gt;, then &lt;code&gt;stop&lt;/code&gt; is the place to deallocate that memory.</source>
          <target state="translated">Вызывается, когда порт закрыт, с помощью &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;Port ! {self(), close}&lt;/code&gt; . Обратите внимание, что завершение процесса владельца порта также закрывает порт. Если &lt;code&gt;drv_data&lt;/code&gt; - это указатель на память, выделенную при &lt;code&gt;start&lt;/code&gt; , то &lt;code&gt;stop&lt;/code&gt; - это место для освобождения этой памяти.</target>
        </trans-unit>
        <trans-unit id="bce5d5b2decf756f58e8642c565207befb9d1e4c" translate="yes" xml:space="preserve">
          <source>Called when there is something to read from a socket.</source>
          <target state="translated">Звонили,когда есть что читать из розетки.</target>
        </trans-unit>
        <trans-unit id="cb06eda8927a232da24c20e732e3e2949f2b101f" translate="yes" xml:space="preserve">
          <source>Called whenever the port is written to. If it is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;output&lt;/code&gt; function is called instead. This function is faster than &lt;code&gt;output&lt;/code&gt;, as it takes an &lt;code&gt;ErlIOVec&lt;/code&gt; directly, which requires no copying of the data. The port is to be in binary mode, see &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызывается всякий раз, когда выполняется запись в порт. Если он равен &lt;code&gt;NULL&lt;/code&gt; , вместо этого вызывается функция &lt;code&gt;output&lt;/code&gt; . Эта функция работает быстрее, чем &lt;code&gt;output&lt;/code&gt; , так как она принимает &lt;code&gt;ErlIOVec&lt;/code&gt; напрямую, что не требует копирования данных. Порт должен быть в двоичном режиме, см &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c4da0ebceae11eff6b7919b2ddd46f27587b04d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; with a string argument still produces a crash dump. On Unix systems, sending an emulator process a &lt;code&gt;SIGUSR1&lt;/code&gt; signal also forces a crash dump.</source>
          <target state="translated">Вызов &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; со строковым аргументом по-прежнему вызывает аварийный дамп. В системах Unix отправка процессу эмулятора сигнала &lt;code&gt;SIGUSR1&lt;/code&gt; также вызывает аварийный дамп.</target>
        </trans-unit>
        <trans-unit id="655a22092d77d88145d5c50ca50e242cddc91b3d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; is equivalent to the following, but more efficient:</source>
          <target state="translated">Вызов &lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; эквивалентен следующему, но более эффективен:</target>
        </trans-unit>
        <trans-unit id="8abf86e315d47dada23e450fdd1a6d2f9ae320c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time()&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызов &lt;code&gt;erlang:system_time()&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b083a75a2460c0a8048c36cd9fefa43e466519e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">Вызов &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; erlang: system_time &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac8161866033e5fba00c9f967a358dd87e252b77" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;merl:print(Call)&lt;/code&gt; will then print the following code:</source>
          <target state="translated">Вызов &lt;code&gt;merl:print(Call)&lt;/code&gt; затем напечатает следующий код:</target>
        </trans-unit>
        <trans-unit id="2cedca3701bb5e353b3d951a1078a1fe4f284c28" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;os:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;erlang:convert_time_unit&lt;/code&gt;(&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">Вызов &lt;code&gt;os:system_time(Unit)&lt;/code&gt; эквивалентен &lt;code&gt;erlang:convert_time_unit&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afeabfe36eaf236b85f9317a022e3a32b2c67b0d" translate="yes" xml:space="preserve">
          <source>Calling and applying a fun does not involve any hash-table lookup. A fun contains an (indirect) pointer to the function that implements the fun.</source>
          <target state="translated">Звонок и применение веселья не связаны с просмотром хэш-таблицы.Забава содержит (косвенный)указатель на функцию,реализующую забаву.</target>
        </trans-unit>
        <trans-unit id="90124b2b5c5e8b577f502d3a36088e606891a366" translate="yes" xml:space="preserve">
          <source>Calling or applying a fun (&lt;code&gt;Fun()&lt;/code&gt;, &lt;code&gt;apply(Fun, [])&lt;/code&gt;) is about &lt;strong&gt;three times&lt;/strong&gt; as expensive as calling a local function.</source>
          <target state="translated">Вызов или применение функции fun ( &lt;code&gt;Fun()&lt;/code&gt; , &lt;code&gt;apply(Fun, [])&lt;/code&gt; ) примерно в &lt;strong&gt;три раза&lt;/strong&gt; дороже, чем вызов локальной функции.</target>
        </trans-unit>
        <trans-unit id="4977f905b190f9bbe202e2e85576e00836e9734e" translate="yes" xml:space="preserve">
          <source>Calling the function with &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; as argument is the same as calling &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызов функции с &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; аналогичен вызову &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b42cc7ad99418c1a03de8a69add23747a547065" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing all the integer()'s and string()'s provided, as well as any user tag set in the current process.</source>
          <target state="translated">Вызов этой функции вызовет &quot;пользовательский&quot; зонд трассировки user_trace_i4s4 в модуле dyntrace NIF,посылая сообщение о трассировке,содержащее все предоставленные функции integer()и string(),а также любой пользовательский тег,установленный в текущем процессе.</target>
        </trans-unit>
        <trans-unit id="444f79602e491b38e25cb8c13003f56f8345ff63" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer or string parameter in the first integer/string field.</source>
          <target state="translated">Вызов этой функции вызовет &quot;пользовательский&quot; датчик трассы user_trace_i4s4 в модуле dyntrace NIF,посылая сообщение о трассе,содержащее метку пользователя и целочисленный или строковый параметр в первом целочисленном/строковом поле.</target>
        </trans-unit>
        <trans-unit id="ca84bd13b57ed20dc137036dea97bc867dd9acff" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters, as in &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызов этой функции вызовет &amp;laquo;пользовательский&amp;raquo; зонд трассировки user_trace_i4s4 в модуле dyntrace NIF, отправив сообщение трассировки, содержащее пользовательский тег и параметры integer () или string () в качестве первых полей соответствующего типа. Параметры integer () должны быть помещены перед любыми параметрами string (), как в &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d6504b8ed29fe9b52bfa13411a0abbd154f8e3e" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters. I.e. &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; is ok, as is &lt;code&gt;p(1,1)&lt;/code&gt; and &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt;, but not &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt;.</source>
          <target state="translated">Вызов этой функции вызовет &amp;laquo;пользовательский&amp;raquo; зонд трассировки user_trace_i4s4 в модуле dyntrace NIF, отправив сообщение трассировки, содержащее пользовательский тег и параметры integer () или string () в качестве первых полей соответствующего типа. Параметры integer () должны быть помещены перед любыми параметрами string (). Т.е. &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; в порядке, как и &lt;code&gt;p(1,1)&lt;/code&gt; и &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt; , но не &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba80ef3622f6d7266790c78fbbdd6b4544d6f3ea" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message only containing the user tag and zeroes/empty strings in all other fields.</source>
          <target state="translated">Вызов этой функции вызовет &quot;пользовательский&quot; трейс-зонд user_trace_i4s4 в модуле dyntrace NIF,посылая сообщение о трассировке,содержащее только тег пользователя и нули/пустые строки во всех остальных полях.</target>
        </trans-unit>
        <trans-unit id="fc31c095d153129fc853cf06c728a75bf3b46c60" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; with the same arguments and filters the result, so &lt;code&gt;Opts&lt;/code&gt; is described for those functions.</source>
          <target state="translated">Вызовы &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; с теми же аргументами и фильтрация результата, поэтому для этих функций описаны &lt;code&gt;Opts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64e4f69ad9125f63ba8df8f7d7d250f3cecda4ae" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; for every &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/3&lt;/code&gt; must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value &lt;code&gt;Init&lt;/code&gt; is returned if the map is empty.</source>
          <target state="translated">Вызывает &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; для каждого &lt;code&gt;K&lt;/code&gt; , чтобы &lt;code&gt;MapOrIter&lt;/code&gt; значение ассоциации &lt;code&gt;V&lt;/code&gt; в MapOrIter в любом порядке. Функция &lt;code&gt;fun F/3&lt;/code&gt; должна возвращать новый аккумулятор, который передается следующему последовательному вызову. Эта функция возвращает окончательное значение аккумулятора. Если карта пуста, возвращается начальное значение аккумулятора &lt;code&gt;Init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4295c8a20ece7cf06d43d6ebf25e275c406c6e5f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; for each element &lt;code&gt;Elem&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt;. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun(Elem)&lt;/code&gt; для каждого элемента &lt;code&gt;Elem&lt;/code&gt; в &lt;code&gt;List&lt;/code&gt; . Эта функция используется для ее побочных эффектов, и порядок оценки определяется таким же, как порядок элементов в списке.</target>
        </trans-unit>
        <trans-unit id="63f2bd2bc7b570ff8e3f588bc3a35e7f39bb021c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; on successive elements &lt;code&gt;Elem&lt;/code&gt; of &lt;code&gt;List1&lt;/code&gt;. &lt;code&gt;Fun/1&lt;/code&gt; must return either a Boolean or a tuple &lt;code&gt;{true, Value}&lt;/code&gt;. The function returns the list of elements for which &lt;code&gt;Fun&lt;/code&gt; returns a new value, where a value of &lt;code&gt;true&lt;/code&gt; is synonymous with &lt;code&gt;{true, Elem}&lt;/code&gt;.</source>
          <target state="translated">Вызовы &lt;code&gt;Fun(Elem)&lt;/code&gt; на последовательных элементы &lt;code&gt;Elem&lt;/code&gt; из &lt;code&gt;List1&lt;/code&gt; . &lt;code&gt;Fun/1&lt;/code&gt; должен возвращать либо логическое значение, либо кортеж &lt;code&gt;{true, Value}&lt;/code&gt; . Функция возвращает список элементов, для которых &lt;code&gt;Fun&lt;/code&gt; возвращает новое значение, где значение &lt;code&gt;true&lt;/code&gt; является синонимом &lt;code&gt;{true, Elem}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50d89c32ea4d0c6ee1b26f9c66ad9e11c8879726" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements &lt;code&gt;A&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">Вызовы &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; на последовательные элементы из &lt;code&gt;List&lt;/code&gt; , начиная с &lt;code&gt;AccIn == Acc0&lt;/code&gt; . &lt;code&gt;Fun/2&lt;/code&gt; должен вернуть новый аккумулятор, который передается следующему вызову. Функция возвращает окончательное значение аккумулятора. &lt;code&gt;Acc0&lt;/code&gt; возвращается, если список пуст. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d14f785e84c0e45ac023a87056c299dcc94c604" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements of the cache, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the cache is empty.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; для последовательных элементов кеша, начиная с &lt;code&gt;AccIn == Acc0&lt;/code&gt; . &lt;code&gt;Fun/2&lt;/code&gt; должен вернуть новый аккумулятор, который передается следующему вызову. Функция возвращает окончательное значение аккумулятора. &lt;code&gt;Acc0&lt;/code&gt; возвращается, если кеш пуст.</target>
        </trans-unit>
        <trans-unit id="d85b7bf8f7b8acf4c9a5d164bbe2b412bc74ce98" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; on successive files in the &lt;code&gt;Archive&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; для последовательных файлов в &lt;code&gt;Archive&lt;/code&gt; , начиная с &lt;code&gt;AccIn == Acc0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb1b12376680c06a8dcd6a14c87f88b97c0f362" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict1&lt;/code&gt; tvo return a new value for each key.</source>
          <target state="translated">Вызов &lt;code&gt;Fun&lt;/code&gt; для последовательных ключей и значений &lt;code&gt;Orddict1&lt;/code&gt; tvo возвращает новое значение для каждого ключа.</target>
        </trans-unit>
        <trans-unit id="41cc957320ee93c3d6a8d2c0cf887c390c051f0c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun&lt;/code&gt; для последовательных ключей и значений &lt;code&gt;Orddict&lt;/code&gt; вместе с дополнительным аргументом &lt;code&gt;Acc&lt;/code&gt; (сокращенно от аккумулятора). &lt;code&gt;Fun&lt;/code&gt; должен возвращать новый аккумулятор, который передается следующему вызову. &lt;code&gt;Acc0&lt;/code&gt; возвращается, если список пуст.</target>
        </trans-unit>
        <trans-unit id="db2c15c0e80df0b70d2a4c08c9328f07d292a334" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict1&lt;/code&gt; to return a new value for each key. The evaluation order is undefined.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun&lt;/code&gt; для последовательных ключей и значений словаря &lt;code&gt;Dict1&lt;/code&gt; , чтобы вернуть новое значение для каждого ключа. Порядок оценки не определен.</target>
        </trans-unit>
        <trans-unit id="51e98c878f8461c82b19b807000534c1ee895d35" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the dictionary is empty. The evaluation order is undefined.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun&lt;/code&gt; для последовательных ключей и значений словаря &lt;code&gt;Dict&lt;/code&gt; вместе с дополнительным аргументом &lt;code&gt;Acc&lt;/code&gt; (сокращение от Accumulator). &lt;code&gt;Fun&lt;/code&gt; должен возвращать новый аккумулятор, который передается следующему вызову. &lt;code&gt;Acc0&lt;/code&gt; возвращается, если словарь пуст. Порядок оценки не определен.</target>
        </trans-unit>
        <trans-unit id="1e38b9bc9aa02fa070ce4650030edfd32a81b7dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive answers to the query handle together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The query handle and the function are evaluated in the calling process. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if there are no answers to the query handle.</source>
          <target state="translated">Вызывает &lt;code&gt;Function&lt;/code&gt; при последовательных ответах на дескриптор запроса вместе с дополнительным аргументом &lt;code&gt;AccIn&lt;/code&gt; . Дескриптор запроса и функция оцениваются в вызывающем процессе. &lt;code&gt;Function&lt;/code&gt; должна вернуть новый аккумулятор, который будет передан следующему вызову. &lt;code&gt;Acc0&lt;/code&gt; возвращается, если на дескриптор запроса нет ответов.</target>
        </trans-unit>
        <trans-unit id="411261c708a55893631cad145cf652a3f25bc6dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive elements of table &lt;code&gt;Name&lt;/code&gt; together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The table elements are traversed in unspecified order. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the table is empty.</source>
          <target state="translated">Вызывает &lt;code&gt;Function&lt;/code&gt; для следующих друг за другом элементов таблицы &lt;code&gt;Name&lt;/code&gt; вместе с дополнительным аргументом &lt;code&gt;AccIn&lt;/code&gt; . Элементы таблицы просматриваются в неопределенном порядке. &lt;code&gt;Function&lt;/code&gt; должна вернуть новый аккумулятор, который будет передан следующему вызову. &lt;code&gt;Acc0&lt;/code&gt; возвращается, если таблица пуста.</target>
        </trans-unit>
        <trans-unit id="e4d0f89deb9513a8ea8d66e61b19ec50cb6a197f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; surrounded by &lt;code&gt;trace([start, ...])&lt;/code&gt; and &lt;code&gt;trace(stop)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; окружении &lt;code&gt;trace([start, ...])&lt;/code&gt; и &lt;code&gt;trace(stop)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8e905cfa5d08f37d1d656135714c1381b168281" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt;, where &lt;code&gt;AccessMod&lt;/code&gt; is the default access callback module obtained by &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt;. &lt;code&gt;Args&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt; , где &lt;code&gt;AccessMod&lt;/code&gt; - это модуль обратного вызова доступа по умолчанию, полученный &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt; . &lt;code&gt;Args&lt;/code&gt; умолчанию аргументы равны &lt;code&gt;[]&lt;/code&gt; (пустой список).</target>
        </trans-unit>
        <trans-unit id="7ba5ad987837e04f29a6e17ab4165c3bf8a13ef5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffcbed2136c4dbb9cb540ca3e3bb945d48a84489" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd2ad960a91e2c7b84aad8b8cab2b4af89af1d4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Record)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1619836284281d3b4ace7f8138860d37a317d20" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7eff8e0d0f21895a3712d8b82ab68aad9ff93c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Record)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b968f64643fdd3ef4196ca7f2353074d34a25592" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Pattern)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc9bba8191f80d74baf71dc1c6ce5482c73891a5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672698b739738396e1aaa279f1425416fa4ed4d3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15de5c4989490ba445d84120b63ae4fef3a10da" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Record)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a49f85d237c7a52c5025bd7a45bcefecee838aed" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1e1b27f2b3d32c30f1a9af2546f7ff28be30d84" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; , где &lt;code&gt;Args&lt;/code&gt; - это &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adefbd4d29b6f99f9c5284fcea99a93af40e2354" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}]&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; , где &lt;code&gt;Args&lt;/code&gt; - это &lt;code&gt;[{scope, global}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6371048f46424da76665133d09722d29e17eb95d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Pattern)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="506bd136b0f38c6b5c4e9aba7994479cbf8607c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4768e4194eaa19668e98e8297432714da38f80fe" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt; . Обратите внимание, что результат &lt;code&gt;Fun&lt;/code&gt; возвращается, если транзакция прошла успешно (атомарно), в противном случае функция завершается с причиной прерывания.</target>
        </trans-unit>
        <trans-unit id="f4238a5e661c7a2d85c9a77b9854e4b9f7ca29a9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt; . Обратите внимание, что результат &lt;code&gt;Fun&lt;/code&gt; возвращается, если транзакция прошла успешно (атомарно), в противном случае функция завершается с причиной прерывания.</target>
        </trans-unit>
        <trans-unit id="4bef8126b535186f1c6f440c4f89eb4f6b6acd97" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt;, where &lt;code&gt;RecName&lt;/code&gt; is &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt; , где &lt;code&gt;RecName&lt;/code&gt; - это &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f8dac520c4ed465440262ceedf36f6b5ee392b4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;names(Host)&lt;/code&gt; for all hosts that are specified in the Erlang host file &lt;code&gt;.hosts.erlang&lt;/code&gt;, collects the replies, and then evaluates &lt;code&gt;ping(Node)&lt;/code&gt; on all those nodes. Returns the list of all nodes that are successfully pinged.</source>
          <target state="translated">Вызывает &lt;code&gt;names(Host)&lt;/code&gt; для всех хостов, которые указаны в файле хоста Erlang &lt;code&gt;.hosts.erlang&lt;/code&gt; , собирает ответы, а затем оценивает &lt;code&gt;ping(Node)&lt;/code&gt; на всех этих узлах. Возвращает список всех узлов, которые успешно проверены.</target>
        </trans-unit>
        <trans-unit id="6f89caf1a58d70de4bc1545d4d2c63f722e1134d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt;. If you want to start a node from the command line and set up a number of pseudo servers, an Erlang runtime system can be started as follows:</source>
          <target state="translated">Вызывает &lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt; . Если вы хотите запустить узел из командной строки и настроить несколько псевдосерверов, систему времени выполнения Erlang можно запустить следующим образом:</target>
        </trans-unit>
        <trans-unit id="2fd282143317f0c95d38258aa5488afaefacb19b" translate="yes" xml:space="preserve">
          <source>Calls a fun, passing the elements in &lt;code&gt;Args&lt;/code&gt; as arguments.</source>
          <target state="translated">Вызывает забаву, передавая элементы в &lt;code&gt;Args&lt;/code&gt; в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="bc1df90caee2a0f744537886d1a4a5d884e3a1f0" translate="yes" xml:space="preserve">
          <source>Calls between functions are either  &lt;strong id=&quot;local_call&quot;&gt;local calls&lt;/strong&gt; like &lt;code&gt;f()&lt;/code&gt;, or  &lt;strong id=&quot;external_call&quot;&gt;external calls&lt;/strong&gt; like &lt;code&gt;m:f()&lt;/code&gt;.  &lt;strong id=&quot;module_data&quot;&gt;Module data&lt;/strong&gt;, which are extracted from BEAM files, include local functions, exported functions, local calls and external calls. By default, calls to built-in functions (BIF) are ignored, but if the option &lt;code&gt;builtins&lt;/code&gt;, accepted by some of this module's functions, is set to &lt;code&gt;true&lt;/code&gt;, calls to BIFs are included as well. It is the analyzing OTP version that decides what functions are BIFs. Functional objects are assumed to be called where they are created (and nowhere else).  &lt;strong id=&quot;unresolved_call&quot;&gt;Unresolved calls&lt;/strong&gt; are calls to &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; with variable module, variable function, or variable arguments. Examples are &lt;code&gt;M:F(a)&lt;/code&gt;, &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt;, and &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt;. Unresolved calls are represented by calls where variable modules have been replaced with the atom &lt;code&gt;'$M_EXPR'&lt;/code&gt;, variable functions have been replaced with the atom &lt;code&gt;'$F_EXPR'&lt;/code&gt;, and variable number of arguments have been replaced with the number &lt;code&gt;-1&lt;/code&gt;. The above mentioned examples are represented by calls to &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt;, &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt;, and &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt;. The unresolved calls are a subset of the external calls.</source>
          <target state="translated">Вызовы между функциями являются либо &lt;strong id=&quot;local_call&quot;&gt;локальными вызовами,&lt;/strong&gt; такими как &lt;code&gt;f()&lt;/code&gt; , либо &lt;strong id=&quot;external_call&quot;&gt;внешними вызовами,&lt;/strong&gt; такими как &lt;code&gt;m:f()&lt;/code&gt; . &lt;strong id=&quot;module_data&quot;&gt;Данные модуля&lt;/strong&gt; , которые извлекаются из файлов BEAM, включают локальные функции, экспортируемые функции, локальные вызовы и внешние вызовы. По умолчанию вызовы встроенных функций (BIF) игнорируются, но если для параметра &lt;code&gt;builtins&lt;/code&gt; , принимаемого некоторыми функциями этого модуля, установлено значение &lt;code&gt;true&lt;/code&gt; , вызовы BIF также включаются. Именно анализирующая версия OTP решает, какие функции являются BIF. Предполагается, что функциональные объекты вызываются там, где они созданы (и нигде больше). &lt;strong id=&quot;unresolved_call&quot;&gt;Неразрешенные вызовы&lt;/strong&gt; - это призывы &lt;code&gt;apply&lt;/code&gt; или &lt;code&gt;spawn&lt;/code&gt; с переменным модулем, переменной функцией или переменными аргументами. Примеры: &lt;code&gt;M:F(a)&lt;/code&gt; , &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt; и &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt; . Неразрешенные вызовы представлены вызовами, в которых модули переменных были заменены атомом &lt;code&gt;'$M_EXPR'&lt;/code&gt; , функции переменных были заменены атомом &lt;code&gt;'$F_EXPR'&lt;/code&gt; , а переменное количество аргументов было заменено числом &lt;code&gt;-1&lt;/code&gt; . Вышеупомянутые примеры представлены вызовами &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt; , &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt; и &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt; . Неразрешенные вызовы - это подмножество внешних вызовов.</target>
        </trans-unit>
        <trans-unit id="e175a0645ad31688c1ad90ebe51d1f98332790c8" translate="yes" xml:space="preserve">
          <source>Calls between modules, applications and releases are also directed graphs. The  &lt;strong id=&quot;type&quot;&gt;types&lt;/strong&gt; of the vertices and edges of these graphs are (ranging from the most special to the most general): &lt;code&gt;Fun&lt;/code&gt; for functions; &lt;code&gt;Mod&lt;/code&gt; for modules; &lt;code&gt;App&lt;/code&gt; for applications; and &lt;code&gt;Rel&lt;/code&gt; for releases. The following paragraphs will describe the different constructs of the language used for selecting and analyzing parts of the graphs, beginning with the  &lt;strong id=&quot;constants&quot;&gt;constants&lt;/strong&gt;:</source>
          <target state="translated">Вызовы между модулями, приложениями и выпусками также представляют собой ориентированные графы. В &lt;strong id=&quot;type&quot;&gt;типах&lt;/strong&gt; вершин и ребер этих графов (начиная от самого особенного в наиболее общем): &lt;code&gt;Fun&lt;/code&gt; для функций; &lt;code&gt;Mod&lt;/code&gt; на модули; &lt;code&gt;App&lt;/code&gt; для приложений; и &lt;code&gt;Rel&lt;/code&gt; для релизов. В следующих параграфах будут описаны различные конструкции языка, используемые для выбора и анализа частей графиков, начиная с &lt;strong id=&quot;constants&quot;&gt;констант&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="be43177e95bbd471940bc32f6f4691d58dabae5d" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ab266a520f0fa15f418f121757a95a2f87b8a3" translate="yes" xml:space="preserve">
          <source>Calls quickcheck and returns the result in a form suitable for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">Вызывает quickcheck и возвращает результат в форме, подходящей для &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c7c891f9853016ddc130d88be49b034108f4922" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. It is performed in almost the same context as &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the &lt;code&gt;Fun&lt;/code&gt; returns. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun&lt;/code&gt; в контексте, который не защищен транзакцией. Вызовы функций Mnesia, выполняемые в &lt;code&gt;Fun&lt;/code&gt; , сопоставляются с соответствующими грязными функциями. Он выполняется почти в том же контексте, что и &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt; . Отличие в том, что операции выполняются синхронно. Вызывающий ожидает выполнения обновлений на всех активных репликах, прежде чем &lt;code&gt;Fun&lt;/code&gt; вернется. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; и Руководство пользователя.</target>
        </trans-unit>
        <trans-unit id="7f3ec8be69b09a2c810b010167a3f606775918ce" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indexes are updated, but they are updated dirty. As for normal &lt;code&gt;mnesia:dirty_*&lt;/code&gt; operations, the operations are performed semi-asynchronously. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun&lt;/code&gt; в контексте, который не защищен транзакцией. Вызовы функций Mnesia, выполняемые в &lt;code&gt;Fun&lt;/code&gt; , сопоставляются с соответствующими грязными функциями. Это по-прежнему включает в себя ведение журнала, репликацию и подписки, но при этом не используются ни блокировка, ни локальное хранилище транзакций, ни протоколы фиксации. Фиксаторы контрольных точек и индексы обновляются, но обновляются грязно. Что касается обычных &lt;code&gt;mnesia:dirty_*&lt;/code&gt; , операции выполняются полусинхронно . Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; и Руководство пользователя.</target>
        </trans-unit>
        <trans-unit id="d819d67bdd8cdeb2caeeb18f61988b23312e64a2" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a raw context that is not protected by a transaction. The Mnesia function call is performed in the &lt;code&gt;Fun&lt;/code&gt; and performed directly on the local ETS tables on the assumption that the local storage type is &lt;code&gt;ram_copies&lt;/code&gt; and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to &lt;code&gt;disc_copies&lt;/code&gt; tables if all operations are read only. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">Вызывает &lt;code&gt;Fun&lt;/code&gt; в необработанном контексте, который не защищен транзакцией. Вызов функции Mnesia выполняется в &lt;code&gt;Fun&lt;/code&gt; и выполняется непосредственно для локальных таблиц ETS при условии, что тип локального хранилища - &lt;code&gt;ram_copies&lt;/code&gt; , и таблицы не реплицируются на другие узлы. Подписки не запускаются и контрольные точки не обновляются, но это происходит очень быстро. Эту функцию также можно применить к таблицам &lt;code&gt;disc_copies&lt;/code&gt; , если все операции доступны только для чтения. Подробнее см. &lt;code&gt;mnesia:activity/4&lt;/code&gt; и Руководство пользователя.</target>
        </trans-unit>
        <trans-unit id="a8a784dd04ba58d02965f17a28a416dac496f4c6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt;</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecca9949a5635aaf8c27410eea7636e30e459fb0" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Record)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949e11ed9c4c541b273d5f803d7f14e93decf845" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8c4bc10158fea84b8bc4d0f51afdb0e35c5827" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cddc0b283837cd9cf6bfc5ffbfc0d1ab69ceebc5" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55f266ac7f0a7fd8339f6a382397f015c2d00cb9" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a04316f127b21a90e451cb0328b531e879c5c8a6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Record)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6619bcc0446814c6bc36959f774872812e839577" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt; , где &lt;code&gt;Tab&lt;/code&gt; - это &lt;code&gt;element(1, Record)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b9dce33ce75c3e0cd20ec5b024a2864ee93e989" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;free()&lt;/code&gt; function.</source>
          <target state="translated">Вызывает стандартную функцию &lt;code&gt;free()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b90d8d44b261c3e05c2a69f75c7d0d01e3b518f9" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;malloc()&lt;/code&gt; function.</source>
          <target state="translated">Вызывает стандартную функцию &lt;code&gt;malloc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f325b7e41b1fdb81e7bc7cb001482dfdf57640d" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt;, and corresponding functions for warning and info messages, are all forwarded to Logger as calls to &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызовы &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt; и соответствующие функции для предупреждений и информационных сообщений все перенаправляются в Logger как вызовы в &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="681ce3661a9a40c6caccc2250ea6929229c7aac3" translate="yes" xml:space="preserve">
          <source>Calls to functions defined by evaluating fun expressions &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; are also hidden from non-local function handlers.</source>
          <target state="translated">Вызовы функций, определенных путем вычисления забавных выражений &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; , также скрыты от нелокальных обработчиков функций.</target>
        </trans-unit>
        <trans-unit id="a78c70fc8985fb6668305436210f739782826d6b" translate="yes" xml:space="preserve">
          <source>Calls to local or external functions (&lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;m:foo()&lt;/code&gt;) are the fastest calls.</source>
          <target state="translated">Вызов локальных или внешних функций ( &lt;code&gt;foo()&lt;/code&gt; , &lt;code&gt;m:foo()&lt;/code&gt; ) - самые быстрые вызовы.</target>
        </trans-unit>
        <trans-unit id="c1368b924e595a7f64353a1c8704cd02aa9b58af" translate="yes" xml:space="preserve">
          <source>Calls to the BIFs specified in table &lt;code&gt;Type Test BIFs&lt;/code&gt;</source>
          <target state="translated">Вызовы BIF, указанные в таблице &lt;code&gt;Type Test BIFs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5e2dbf1a74a301e38682ebfa666c1939e25bd23" translate="yes" xml:space="preserve">
          <source>Can another internal data representation be used to make things more efficient?</source>
          <target state="translated">Можно ли использовать другое внутреннее представление данных,чтобы сделать вещи более эффективными?</target>
        </trans-unit>
        <trans-unit id="ce2b0460aad57730836f17162000a27e6d1988d5" translate="yes" xml:space="preserve">
          <source>Can any redundant tests be removed?</source>
          <target state="translated">Могут ли быть удалены избыточные тесты?</target>
        </trans-unit>
        <trans-unit id="14d70599293b8e413ef952c38a0440843056f84c" translate="yes" xml:space="preserve">
          <source>Can any test be run less often if the order of tests is changed?</source>
          <target state="translated">Может ли любой тест выполняться реже,если изменен порядок проведения тестов?</target>
        </trans-unit>
        <trans-unit id="1dbbd23b5878e1a733c169db6ec8393bc170cde2" translate="yes" xml:space="preserve">
          <source>Can be a back reference, or another way of writing a tab</source>
          <target state="translated">Может быть обратной ссылкой,или другим способом написания вкладки.</target>
        </trans-unit>
        <trans-unit id="9ff3af864aead7cd729fa897ed19cd40dd3bea5a" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise the character with octal code 113</source>
          <target state="translated">Может быть обратной ссылкой,в противном случае символ с восьмеричным кодом 113</target>
        </trans-unit>
        <trans-unit id="ca748588186d1a7e973cd887d71235755974030e" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise value 255 (decimal)</source>
          <target state="translated">Может быть обратной ссылкой,в противном случае значение 255 (десятичное).</target>
        </trans-unit>
        <trans-unit id="7d7475380f4be07d179c7231bb2dd90fbd5279b2" translate="yes" xml:space="preserve">
          <source>Can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="translated">Может быть вызван процессом для отмены регистрации указанного узла в EPMD на локальном хосте. Однако это обычно недопустимо, если только EPMD не был запущен с флагом &lt;code&gt;-relaxed_command_check&lt;/code&gt; , что обычно не так.</target>
        </trans-unit>
        <trans-unit id="f44b4080b46d42a3270b0b18ff48ce34cd9d5ec2" translate="yes" xml:space="preserve">
          <source>Can be implemented as:</source>
          <target state="translated">Может быть реализовано как:</target>
        </trans-unit>
        <trans-unit id="435b9419e03f7e525befa539fe46b7b2779ce303" translate="yes" xml:space="preserve">
          <source>Can be one of the following:</source>
          <target state="translated">Может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="18e0b766363b36ea716659f6503b3ddde9e7ec85" translate="yes" xml:space="preserve">
          <source>Can be removed in a future release of the halfword emulator.</source>
          <target state="translated">Может быть удален в следующем выпуске эмулятора полуфабрикатов.</target>
        </trans-unit>
        <trans-unit id="a329dd98b578890314d90cd00ae46894da7e6ba8" translate="yes" xml:space="preserve">
          <source>Can be set to &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;relaxed&lt;/code&gt;. It controls how each directory in the code path is to be interpreted:</source>
          <target state="translated">Может быть &lt;code&gt;strict&lt;/code&gt; или &lt;code&gt;relaxed&lt;/code&gt; . Он контролирует, как интерпретировать каждый каталог в пути кода:</target>
        </trans-unit>
        <trans-unit id="61d2fdff92dff8eebb470df37755eb8b633955c3" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; daemon listens only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified).</source>
          <target state="translated">Может быть установлен в виде списка IP-адресов, разделенных запятыми, и в этом случае демон &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; прослушивает только указанный адрес (а) и адрес обратной связи (который неявно добавляется в список, если он не был указан).</target>
        </trans-unit>
        <trans-unit id="1d6e47517b6960079a15e323f8e14b95671cfd59" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;epmd&lt;/code&gt; daemon will listen only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified). The default behavior is to listen on all available IP addresses.</source>
          <target state="translated">Может быть установлен в виде списка IP-адресов, разделенных запятыми, и в этом случае демон &lt;code&gt;epmd&lt;/code&gt; будет прослушивать только указанный адрес (а) и адрес обратной связи (который неявно добавляется в список, если он не был указан). По умолчанию прослушиваются все доступные IP-адреса.</target>
        </trans-unit>
        <trans-unit id="32027351ef478fb666878cfb7ea809e9ec8104be" translate="yes" xml:space="preserve">
          <source>Can be used as a name resolving function for &lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Может использоваться как функция разрешения имен для &lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a41238ba1ffe4cd44c8669bf5362c16badbd6e66" translate="yes" xml:space="preserve">
          <source>Can be used by a process that initiates a debug structure from a list of options. The values of argument &lt;code&gt;Opt&lt;/code&gt; are the same as for the corresponding functions.</source>
          <target state="translated">Может использоваться процессом, который инициирует структуру отладки из списка параметров. Значения аргумента &lt;code&gt;Opt&lt;/code&gt; такие же, как для соответствующих функций.</target>
        </trans-unit>
        <trans-unit id="e44e4550227750d3133233de3b9ab784df8d5876" translate="yes" xml:space="preserve">
          <source>Can be used if interactive performance is not to be affected by the emulator process.</source>
          <target state="translated">Может использоваться,если интерактивная производительность не должна зависеть от процесса эмулятора.</target>
        </trans-unit>
        <trans-unit id="4554428a28a365553523e827200f0a4801491275" translate="yes" xml:space="preserve">
          <source>Can be used if the size of the trace logs must be limited. Default values are &lt;code&gt;Size=128*1024&lt;/code&gt; and &lt;code&gt;Count=8&lt;/code&gt;.</source>
          <target state="translated">Может использоваться, если необходимо ограничить размер журналов трассировки. Значения по умолчанию: &lt;code&gt;Size=128*1024&lt;/code&gt; и &lt;code&gt;Count=8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52514699bbc5fce906ba4874a907b457ea6b2ad1" translate="yes" xml:space="preserve">
          <source>Can be used if two Erlang nodes are to reside on one dedicated system and one is to have precedence over the other.</source>
          <target state="translated">Может использоваться,если два узла Erlang должны находиться на одной выделенной системе и один из них должен иметь приоритет над другим.</target>
        </trans-unit>
        <trans-unit id="1cfd6096580c6f0fc105f7dae283a846f824ac79" translate="yes" xml:space="preserve">
          <source>Can be used to determine which crypto algorithms that are supported by the underlying OpenSSL library</source>
          <target state="translated">Может использоваться для определения того,какие криптоалгоритмы поддерживаются базовой библиотекой OpenSSL</target>
        </trans-unit>
        <trans-unit id="8ac2e838e28c4e79b7b0173c19b32b3299e09f77" translate="yes" xml:space="preserve">
          <source>Can be used to determine which named elliptic curves are supported.</source>
          <target state="translated">Может использоваться для определения того,какие именованные эллиптические кривые поддерживаются.</target>
        </trans-unit>
        <trans-unit id="0139eb1de3d0a9614c9b210a184d4b0320912f6e" translate="yes" xml:space="preserve">
          <source>Can be used to make the client act as an &lt;code&gt;HTTP/1.0&lt;/code&gt; or &lt;code&gt;HTTP/0.9&lt;/code&gt; client. By default this is an &lt;code&gt;HTTP/1.1&lt;/code&gt; client. When using &lt;code&gt;HTTP/1.0&lt;/code&gt; persistent connections are not used.</source>
          <target state="translated">Может использоваться для того, чтобы клиент работал как клиент &lt;code&gt;HTTP/1.0&lt;/code&gt; или &lt;code&gt;HTTP/0.9&lt;/code&gt; . По умолчанию это клиент &lt;code&gt;HTTP/1.1&lt;/code&gt; . При использовании &lt;code&gt;HTTP/1.0&lt;/code&gt; постоянные соединения не используются.</target>
        </trans-unit>
        <trans-unit id="e9de6dfb4b293a374f8bbe2fd001451aff895674" translate="yes" xml:space="preserve">
          <source>Can be used to retrieve information about the C-node. These values are initially set with &lt;code&gt;ei_connect_init()&lt;/code&gt; or &lt;code&gt;ei_connect_xinit()&lt;/code&gt;.</source>
          <target state="translated">Может использоваться для получения информации о C-узле. Эти значения изначально устанавливаются с помощью &lt;code&gt;ei_connect_init()&lt;/code&gt; или &lt;code&gt;ei_connect_xinit()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b6b3b3a5a2150a389c6b25e1e84aa23960992c" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with a server called &lt;code&gt;Name&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;. It is assumed that the server receives messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and replies using &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt;. This function makes such a server call and ensures that the entire call is packed into an atomic transaction, which either succeeds or fails. It never hangs, unless the server itself hangs.</source>
          <target state="translated">Может использоваться при взаимодействии с сервером под названием &lt;code&gt;Name&lt;/code&gt; на узле &lt;code&gt;Node&lt;/code&gt; . Предполагается, что сервер получает сообщения в формате &lt;code&gt;{From, Msg}&lt;/code&gt; и отвечает, используя &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt; . Эта функция выполняет такой вызов сервера и гарантирует, что весь вызов упакован в атомарную транзакцию, которая либо завершается успешно, либо терпит неудачу. Никогда не зависает, если только сам сервер не зависает.</target>
        </trans-unit>
        <trans-unit id="bb8693797500f3627529857787e0f8552cc7d7b2" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with servers called &lt;code&gt;Name&lt;/code&gt; on the specified nodes. It is assumed that the servers receive messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and reply using &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the node where the server is located. The function returns &lt;code&gt;{Replies, BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of all &lt;code&gt;Reply&lt;/code&gt; values, and &lt;code&gt;BadNodes&lt;/code&gt; is one of the following:</source>
          <target state="translated">Может использоваться при взаимодействии с серверами с именем &lt;code&gt;Name&lt;/code&gt; на указанных узлах. Предполагается, что серверы получают сообщения в формате &lt;code&gt;{From, Msg}&lt;/code&gt; и отвечают, используя &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt; , где &lt;code&gt;Node&lt;/code&gt; - это имя узла, на котором расположен сервер. Функция возвращает &lt;code&gt;{Replies, BadNodes}&lt;/code&gt; , где &lt;code&gt;Replies&lt;/code&gt; - это список всех значений &lt;code&gt;Reply&lt;/code&gt; , а &lt;code&gt;BadNodes&lt;/code&gt; - одно из следующих:</target>
        </trans-unit>
        <trans-unit id="413a11e06a5cc3367aeaca579508da6cce5c360b" translate="yes" xml:space="preserve">
          <source>Can be used with &lt;code&gt;chunk/2,3&lt;/code&gt; and &lt;code&gt;bchunk/2,3&lt;/code&gt; to search through an internally formatted wrap log. It takes as argument a continuation as returned by &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, or &lt;code&gt;chunk_step/3&lt;/code&gt;, and steps forward (or backward) &lt;code&gt;Step&lt;/code&gt; files in the wrap log. The continuation returned, points to the first log item in the new current file.</source>
          <target state="translated">Может использоваться с &lt;code&gt;chunk/2,3&lt;/code&gt; и &lt;code&gt;bchunk/2,3&lt;/code&gt; для поиска по внутренне отформатированному журналу переноса . Он принимает в качестве аргумента продолжение, возвращаемое &lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; или &lt;code&gt;chunk_step/3&lt;/code&gt; , и делает шаги вперед (или назад) по файлам &lt;code&gt;Step&lt;/code&gt; в журнале переноса . Возвращенное продолжение указывает на первый элемент журнала в новом текущем файле.</target>
        </trans-unit>
        <trans-unit id="54b689659783bb6b4ac1454db70e48394a638a38" translate="yes" xml:space="preserve">
          <source>Can contain the port number &lt;code&gt;epmd&lt;/code&gt; will use. The default port will work fine in most cases. A different port can be specified to allow several instances of &lt;code&gt;epmd&lt;/code&gt;, representing independent clusters of nodes, to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">Может содержать номер порта, &lt;code&gt;epmd&lt;/code&gt; будет использовать epmd . Порт по умолчанию будет работать нормально в большинстве случаев. Можно указать другой порт, чтобы несколько экземпляров &lt;code&gt;epmd&lt;/code&gt; , представляющих независимые кластеры узлов, могли сосуществовать на одном хосте. Все узлы в кластере должны использовать один и тот же &lt;code&gt;epmd&lt;/code&gt; порта epmd .</target>
        </trans-unit>
        <trans-unit id="d1d4e8ff3c787597c2cdf851d9445ac7a46d3eec" translate="yes" xml:space="preserve">
          <source>Can contain the port number to use when communicating with &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt;. The default port works fine in most cases. A different port can be specified to allow nodes of independent clusters to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">Может содержать номер порта для связи с &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; . Порт по умолчанию работает нормально в большинстве случаев. Можно указать другой порт, чтобы позволить узлам независимых кластеров сосуществовать на одном хосте. Все узлы в кластере должны использовать один и тот же &lt;code&gt;epmd&lt;/code&gt; порта epmd .</target>
        </trans-unit>
        <trans-unit id="763e2024cfbffcaa35312ea836b3ce5e41e09735" translate="yes" xml:space="preserve">
          <source>Can either be the originals passed into the calling NIF, or can be values created by the calling NIF.</source>
          <target state="translated">Могут быть либо оригиналы,переданные в вызывающий NIF,либо значения,созданные вызывающим NIF.</target>
        </trans-unit>
        <trans-unit id="1762b945a07d7a0928b055cdfb86c61f5e180a18" translate="yes" xml:space="preserve">
          <source>Can enable trace on all functions or only exported functions on chosen modules.</source>
          <target state="translated">Может включить трассировку по всем функциям или только экспортированным функциям на выбранных модулях.</target>
        </trans-unit>
        <trans-unit id="a6d98498dcb02bc77d5362ec71948bf4dcb80403" translate="yes" xml:space="preserve">
          <source>Can only be used to check the local time of day if the time-zone information of the underlying OS is properly configured.</source>
          <target state="translated">Может использоваться только для проверки местного времени суток,если информация о часовом поясе базовой операционной системы настроена правильно.</target>
        </trans-unit>
        <trans-unit id="3b665cc5f87b4b96a8b89bb4858d5c6ded666e00" translate="yes" xml:space="preserve">
          <source>Can only be used with TLS/DTLS connections; &lt;code&gt;{error, undefined}&lt;/code&gt; is returned for SSLv3 connections.</source>
          <target state="translated">Может использоваться только с соединениями TLS / DTLS; &lt;code&gt;{error, undefined}&lt;/code&gt; возвращается для соединений SSLv3.</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="0ce7f9b48109071ca45af63e2c7f4cded74fe895" translate="yes" xml:space="preserve">
          <source>Cancel a previous asynchronous request.</source>
          <target state="translated">Отмените предыдущий асинхронный запрос.</target>
        </trans-unit>
        <trans-unit id="8c0d517ae93b9275421781af37452eec4bb2fa47" translate="yes" xml:space="preserve">
          <source>Cancel a previous request to be notified of SNMP manager start.</source>
          <target state="translated">Отменить предыдущий запрос,чтобы получить уведомление о запуске SNMP-менеджера.</target>
        </trans-unit>
        <trans-unit id="a9a0f30cfff3cf2f7919e74d440e32f436d7292c" translate="yes" xml:space="preserve">
          <source>Cancel all outstanding messages for this connection</source>
          <target state="translated">Отменить все оставшиеся сообщения для этого соединения</target>
        </trans-unit>
        <trans-unit id="2e83179d769a2b44650615f9d44ca78b37a04604" translate="yes" xml:space="preserve">
          <source>Cancel the handshake with a fatal &lt;code&gt;USER_CANCELED&lt;/code&gt; alert.</source>
          <target state="translated">Отмените рукопожатие с фатальным предупреждением &lt;code&gt;USER_CANCELED&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
