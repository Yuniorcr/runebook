<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="f82ed6c2be9cde928b716896e0b7750e4269ef66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_server&lt;/code&gt; process handles system messages as described in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;sys&lt;/code&gt; module can be used for debugging a &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; процесс обрабатывает системные сообщения , как описано в &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; . Модуль &lt;code&gt;sys&lt;/code&gt; можно использовать для отладки процесса &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9183aff59e51eee9e3ac3b923db0e1df5aa748f5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_statem&lt;/code&gt; assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; предполагает , что все конкретные детали , которые будут расположены в модуле обратного вызова экспортирующего заранее определенный набор функций. Связь между функциями поведения и функциями обратного вызова следующая:</target>
        </trans-unit>
        <trans-unit id="c088e6c3ad593b97e2719e3a7f2ef3d25643973c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_statem&lt;/code&gt; handles system messages as described in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;sys&lt;/code&gt; module can be used for debugging a &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; обрабатывает системные сообщения , как описано в &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; . Модуль &lt;code&gt;sys&lt;/code&gt; можно использовать для отладки &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb679bbc4a894da7c683af08fece335a0b2f7f3a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;host&lt;/code&gt; filter is not typically desirable when setting Destination-Host since it will remove peer agents from the candidates list.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; фильтр обычно не желательно при настройке Destination-Host , так как это приведет к удалению пэра агентов из списка кандидатов.</target>
        </trans-unit>
        <trans-unit id="3136f605b2f92ac3277fb1aa4fb5ac14a0ceaca5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt;, defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; , по умолчанию &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687a85ac1691431ae16424f09a8711efd93e00b8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt;, defaults to [].</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; , по умолчанию [].</target>
        </trans-unit>
        <trans-unit id="8945c1936d6e5ae6093c7d0fe2fcd18eac87d001" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;message_error()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError.</source>
          <target state="translated">&lt;code&gt;message_error()&lt;/code&gt; , указывает на то, что удаленный пользователь ответил с явным transactionError.</target>
        </trans-unit>
        <trans-unit id="e9dc2723fde49808f2786f42dd59628134c7bdff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;nowarn_xxx&lt;/code&gt; form, to turn off the warning.</source>
          <target state="translated">&lt;code&gt;nowarn_xxx&lt;/code&gt; форма, чтобы выключить предупреждение.</target>
        </trans-unit>
        <trans-unit id="c1871757dec2ac832830f5a635684899bd5b3db1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;permanent&lt;/code&gt; child process is always restarted.</source>
          <target state="translated">&lt;code&gt;permanent&lt;/code&gt; дочерний процесс перезапускается всегда.</target>
        </trans-unit>
        <trans-unit id="adff669099f0ada70cada77f613b34ae862107ab" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor by name resolves the &lt;code&gt;RegisteredName&lt;/code&gt; to &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; only once at the moment of monitor instantiation, later changes to the name registration will not affect the existing monitor.</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; или &lt;code&gt;port&lt;/code&gt; монитора по имени разрешает &lt;code&gt;RegisteredName&lt;/code&gt; к &lt;code&gt;pid()&lt;/code&gt; или &lt;code&gt;port()&lt;/code&gt; только один раз в момент монитора конкретизации, а затем переходит в регистрации имени не повлияет на существующий монитор.</target>
        </trans-unit>
        <trans-unit id="b4a4e8cecf512f5c76654bdb793223d7fff4380d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered only once, after that it is removed from both monitoring process and the monitored entity. Monitors are fired when the monitored process or port terminates, does not exist at the moment of creation, or if the connection to it is lost. If the connection to it is lost, we do not know if it still exists. The monitoring is also turned off when &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; или &lt;code&gt;port&lt;/code&gt; монитора срабатывает только один раз, после чего он удаляется из обоих процесса мониторинга и контролируемого объекта. Мониторы запускаются, когда отслеживаемый процесс или порт завершается, не существует в момент создания или если соединение с ним потеряно. Если соединение с ним потеряно, мы не знаем, существует ли он еще. Также отключается мониторинг при &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faabc209db7c57f4dac9a885c73eaefbaad312f3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in a test case information function</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; заявление в информационной функции тестового примера</target>
        </trans-unit>
        <trans-unit id="84c08b930b637efc74e4be68d8d836d66a78b1ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in the suite information function (&lt;code&gt;suite/0&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; заявление , в функции люкс информации ( &lt;code&gt;suite/0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c43c43f9ed4d600c7d71b45d8ac9c7203e0f6da6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in the test suite information case or test case information-list is to look like &lt;code&gt;{require,CfgVarName}&lt;/code&gt; or &lt;code&gt;{require,AliasName,CfgVarName}&lt;/code&gt;. The arguments &lt;code&gt;AliasName&lt;/code&gt; and &lt;code&gt;CfgVarName&lt;/code&gt; are the same as the arguments to &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;AliasName&lt;/code&gt; becomes an alias for the configuration variable, and can be used as reference to the configuration data value. The configuration variable can be associated with any number of alias names, but each name must be unique within the same test suite. The two main uses for alias names follows:</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; заявление в тестовом наборе информации случая или тестового пример информации списка должны выглядеть как &lt;code&gt;{require,CfgVarName}&lt;/code&gt; или &lt;code&gt;{require,AliasName,CfgVarName}&lt;/code&gt; . Аргументы &lt;code&gt;AliasName&lt;/code&gt; и &lt;code&gt;CfgVarName&lt;/code&gt; такие же, как аргументы для &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;AliasName&lt;/code&gt; становится псевдонимом для переменной конфигурации и может использоваться как ссылка на значение данных конфигурации. Переменная конфигурации может быть связана с любым количеством псевдонимов, но каждое имя должно быть уникальным в рамках одного набора тестов. Ниже приведены два основных варианта использования псевдонимов:</target>
        </trans-unit>
        <trans-unit id="5ff9958a6d15c210b3259bc6e40de68c3b9fa571" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;resend_indication()&lt;/code&gt;, defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;resend_indication()&lt;/code&gt; , по умолчанию &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0153a022671e7ff3f8f28950553457e8d9526f45" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;scanner&lt;/code&gt; to pre-process the text (program, etc.) to be parsed is not provided in the &lt;code&gt;yecc&lt;/code&gt; module. The scanner serves as a kind of lexicon look-up routine. It is possible to write a grammar that uses only character tokens as terminal symbols, thereby eliminating the need for a scanner, but this would make the parser larger and slower.</source>
          <target state="translated">&lt;code&gt;scanner&lt;/code&gt; для предварительной обработки текста (программы и т.п.) должны быть разобраны не предусмотрено в &lt;code&gt;yecc&lt;/code&gt; модуле. Сканер служит своего рода программой поиска по словарю. Можно написать грамматику, в которой в качестве терминальных символов используются только символьные токены, что устраняет необходимость в сканере, но это сделало бы анализатор больше и медленнее.</target>
        </trans-unit>
        <trans-unit id="87ac317ef6fe7f30b73d95244c9d1336c4280f0e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;segment_reason()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError for this segment. This is of course only possible if the reply was segmented.</source>
          <target state="translated">A &lt;code&gt;segment_reason()&lt;/code&gt; указывает, что удаленный пользователь ответил явной ошибкой transactionError для этого сегмента. Конечно, это возможно только в том случае, если ответ был сегментирован.</target>
        </trans-unit>
        <trans-unit id="b6458c8e12fe0d6e7fcbb7cf092bd2f54ade6bdd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;send_error()&lt;/code&gt;, indicates that the send function of the megaco transport callback module failed to send the request. There are two separate cases: &lt;code&gt;send_cancelled_reason()&lt;/code&gt; and &lt;code&gt;send_failed_reason()&lt;/code&gt;. The first is the result of the send function returning &lt;code&gt;{cancel, Reason}&lt;/code&gt; and the second is some other kind of erroneous return value. See the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function for more info.</source>
          <target state="translated">&lt;code&gt;send_error()&lt;/code&gt; , указывает на то, что функция отправки модуля обратного вызова Megaco транспорта не удалось отправить запрос. Есть два отдельных случая: &lt;code&gt;send_cancelled_reason()&lt;/code&gt; и &lt;code&gt;send_failed_reason()&lt;/code&gt; . Первый - результат того, что функция отправки возвращает &lt;code&gt;{cancel, Reason}&lt;/code&gt; а второй - некое другое ошибочное возвращаемое значение. См. &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2afcbf56605493e5cb096c43726f60e7b25a7e6c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;send_reason()&lt;/code&gt;, indicates that the transport module &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function did not send the message. The reason for this can be:</source>
          <target state="translated">&lt;code&gt;send_reason()&lt;/code&gt; , указывает на то, что транспортный модуль &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; функция не отправить сообщение. Причиной этого может быть:</target>
        </trans-unit>
        <trans-unit id="0c9e5cf1fc1ef1d9c81cf8a83bbb2c92cb7facff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;snmpa_mib_storage&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">&lt;code&gt;snmpa_mib_storage&lt;/code&gt; модуль совместимый должен экспортировать следующие функции:</target>
        </trans-unit>
        <trans-unit id="be1b2110a34fe49a492c740fc6d2a1e353485a6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;snmpa_notification_delivery_info_receiver&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">&lt;code&gt;snmpa_notification_delivery_info_receiver&lt;/code&gt; модуль совместимый должен экспортировать следующие функции:</target>
        </trans-unit>
        <trans-unit id="da19f426ecc187ba7aec2fbddba35e35ebdc8cfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;supervisor&lt;/code&gt; and a &lt;code&gt;supervisor_bridge&lt;/code&gt; are also &lt;code&gt;gen_server&lt;/code&gt; processes. To return information that this process is a supervisor and the name of the callback module, &lt;code&gt;Module&lt;/code&gt; is &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; is the name of the supervisor callback module. &lt;code&gt;Arity&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, as the &lt;code&gt;init/1&lt;/code&gt; function is called initially in the callback module.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; и &lt;code&gt;supervisor_bridge&lt;/code&gt; также &lt;code&gt;gen_server&lt;/code&gt; процессы. Чтобы вернуть информацию о том, что этот процесс является супервизором, и имя модуля обратного вызова, &lt;code&gt;Module&lt;/code&gt; - это &lt;code&gt;supervisor&lt;/code&gt; а &lt;code&gt;Function&lt;/code&gt; - имя модуля обратного вызова супервизора. &lt;code&gt;Arity&lt;/code&gt; равна &lt;code&gt;1&lt;/code&gt; , так как функция &lt;code&gt;init/1&lt;/code&gt; изначально вызывается в модуле обратного вызова.</target>
        </trans-unit>
        <trans-unit id="9e84ddb3d1abb6010ba95215374a2c3fda587dad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;temporary&lt;/code&gt; child process is never restarted (not even when the supervisor restart strategy is &lt;code&gt;rest_for_one&lt;/code&gt; or &lt;code&gt;one_for_all&lt;/code&gt; and a sibling death causes the temporary process to be terminated).</source>
          <target state="translated">&lt;code&gt;temporary&lt;/code&gt; дочерний процесс никогда не перезапускается (даже тогда , когда стратегия перезапуска супервизор &lt;code&gt;rest_for_one&lt;/code&gt; или &lt;code&gt;one_for_all&lt;/code&gt; и смерть родного брата вызывает временный процесс будет прекращен).</target>
        </trans-unit>
        <trans-unit id="1d2a39bc2849b9b4ae106fb8032df69b5cf6fefa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tftp&lt;/code&gt; callback module is to be implemented as a &lt;code&gt;tftp&lt;/code&gt; behavior and export the functions listed in the following.</source>
          <target state="translated">Модуль обратного вызова &lt;code&gt;tftp&lt;/code&gt; должен быть реализован как поведение &lt;code&gt;tftp&lt;/code&gt; и экспортировать функции, перечисленные ниже.</target>
        </trans-unit>
        <trans-unit id="27cee850217202e8dabaf2537514f0583ea52228" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tftp_logger&lt;/code&gt; callback module is to be implemented as a &lt;code&gt;tftp_logger&lt;/code&gt; behavior and export the following functions:</source>
          <target state="translated">&lt;code&gt;tftp_logger&lt;/code&gt; модуль обратного вызова должен быть реализован в виде &lt;code&gt;tftp_logger&lt;/code&gt; поведения и экспорта следующие функции:</target>
        </trans-unit>
        <trans-unit id="6a934fbaa0dfee55a432f14191eb1f24df633cfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tooBig&lt;/code&gt; error in an SNMPv1 packet will always use the &lt;code&gt;'NULL'&lt;/code&gt; value in all variable bindings.</source>
          <target state="translated">Ошибка &lt;code&gt;tooBig&lt;/code&gt; в пакете SNMPv1 всегда будет использовать значение &lt;code&gt;'NULL'&lt;/code&gt; во всех привязках переменных.</target>
        </trans-unit>
        <trans-unit id="33cb62d5e14ba5b3198337c7ba3cd6fbbcb1589c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;transaction_reason()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError.</source>
          <target state="translated">A &lt;code&gt;transaction_reason()&lt;/code&gt; указывает, что удаленный пользователь ответил явной ошибкой transactionError.</target>
        </trans-unit>
        <trans-unit id="e53d6f03dc678459ddffb4d98f7b557780e96fef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;transient&lt;/code&gt; child process is restarted only if it terminates abnormally, that is, with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;transient&lt;/code&gt; дочерний процесс перезапускается только если он завершается аварийно, то есть, с выходом причине, кроме &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; или &lt;code&gt;{shutdown,Term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9eb9caf239b9bb7b398b87222c53f550da50ad9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;user_cancel_error()&lt;/code&gt;, indicates that the request has been canceled by the user. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; is the reason given in the call to the &lt;code&gt;&lt;a href=&quot;#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;user_cancel_error()&lt;/code&gt; , указывает на то, что запрос был отменен пользователем. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; - это причина, указанная в вызове функции &lt;code&gt;&lt;a href=&quot;#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caaac6e0eeba26f0e8f05cc72836874db9f304d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;user_cancel_reason()&lt;/code&gt;, indicates that the request has been canceled by the user. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; is the reason given in the call to the &lt;code&gt;&lt;a href=&quot;megaco#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;user_cancel_reason()&lt;/code&gt; , указывает на то, что запрос был отменен пользователем. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; - это причина, указанная в вызове функции &lt;code&gt;&lt;a href=&quot;megaco#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c86492d0dd649ce209af387e79b667ae92d9b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;warn_xxx&lt;/code&gt; form, to turn on the warning.</source>
          <target state="translated">&lt;code&gt;warn_xxx&lt;/code&gt; форма, чтобы включить предупреждения.</target>
        </trans-unit>
        <trans-unit id="d4775dc55315e4de3bfb697e86b747e1981e9aa0" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;components&quot;&gt;connected component&lt;/strong&gt; is a maximal subgraph such that there is a path between each pair of vertices, considering all edges undirected.</source>
          <target state="translated">&lt;strong id=&quot;components&quot;&gt;Компонента связности&lt;/strong&gt; является максимальным подграф таким образом, что существует путь между каждой парой вершин, с учетом всех ребер неориентированных.</target>
        </trans-unit>
        <trans-unit id="c5c8116d1626ee6ce9e1eb9f966086aa8cd78606" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;depth_first_traversal&quot;&gt;depth-first traversal&lt;/strong&gt; of a directed digraph can be viewed as a process that visits all vertices of the digraph. Initially, all vertices are marked as unvisited. The traversal starts with an arbitrarily chosen vertex, which is marked as visited, and follows an edge to an unmarked vertex, marking that vertex. The search then proceeds from that vertex in the same fashion, until there is no edge leading to an unvisited vertex. At that point the process backtracks, and the traversal continues as long as there are unexamined edges. If unvisited vertices remain when all edges from the first vertex have been examined, some so far unvisited vertex is chosen, and the process is repeated.</source>
          <target state="translated">&lt;strong id=&quot;depth_first_traversal&quot;&gt;Глубины первого обхода&lt;/strong&gt; ориентированного орграфа можно рассматривать как процесс , который посещение всех вершин орграфа. Изначально все вершины помечаются как непосещенные. Обход начинается с произвольно выбранной вершины, которая помечена как посещенная, и следует по ребру до немаркированной вершины, отмечая эту вершину. Затем поиск продолжается от этой вершины таким же образом, пока не останется ребро, ведущее в непосещенную вершину. В этот момент процесс возвращается, и обход продолжается до тех пор, пока остаются неисследованные ребра. Если непосещенные вершины остаются после проверки всех ребер из первой вершины, выбирается некоторая пока непосещенная вершина, и процесс повторяется.</target>
        </trans-unit>
        <trans-unit id="1b2506dfb79fff8f12c8b8a1cad93d4f54d6d800" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;digraph&quot;&gt;directed graph&lt;/strong&gt; (or just &quot;digraph&quot;) is a pair (V, E) of a finite set V of &lt;strong id=&quot;vertex&quot;&gt;vertices&lt;/strong&gt; and a finite set E of &lt;strong id=&quot;edge&quot;&gt;directed edges&lt;/strong&gt; (or just &quot;edges&quot;). The set of edges E is a subset of V &amp;times; V (the Cartesian product of V with itself).</source>
          <target state="translated">&lt;strong id=&quot;digraph&quot;&gt;Ориентированный граф&lt;/strong&gt; (или просто &amp;laquo;орграф&amp;raquo;) является пара (V, Е) из конечного множества V из &lt;strong id=&quot;vertex&quot;&gt;вершин&lt;/strong&gt; и конечного множества Е &lt;strong id=&quot;edge&quot;&gt;направленных ребер&lt;/strong&gt; (или просто &amp;laquo;ребра&amp;raquo;). Множество ребер E является подмножеством V &amp;times; V (декартово произведение V на себя).</target>
        </trans-unit>
        <trans-unit id="d772fcf249486473885a86b1e0fb07e1b81cc558" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;function&quot;&gt;function&lt;/strong&gt; F is a relation, a subset of X &amp;times; Y, such that the domain of F is equal to X and such that for every x in X there is a unique element y in Y with (x, y) in F. The latter condition can be formulated as follows: if x F y and x F z, then y = z. In this module, it is not required that the domain of F is equal to X for a relation to be considered a function.</source>
          <target state="translated">&lt;strong id=&quot;function&quot;&gt;Функция&lt;/strong&gt; F является отношением, подмножество X &amp;times; Y, такими , что область F равна X и такой , что для каждого х в Й существует единственный элемент у в Y с (х, у) в Ф. Последнее условие можно сформулировать следующим образом: если x F y и x F z, то y = z. В этом модуле не требуется, чтобы область определения F была равна X, чтобы отношение считалось функцией.</target>
        </trans-unit>
        <trans-unit id="9e6750400d02e17360f35f2ed9e1616f594d887a" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;loop&quot;&gt;loop&lt;/strong&gt; is a cycle of length one.</source>
          <target state="translated">&lt;strong id=&quot;loop&quot;&gt;Цикл&lt;/strong&gt; является циклом длины одного.</target>
        </trans-unit>
        <trans-unit id="7c11e23c2588408ff5e86ef238bc8fcbf38b7c2f" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;partial_ordering&quot;&gt;partial ordering&lt;/strong&gt; of a set S is a transitive, antisymmetric, and reflexive relation between the objects of S.</source>
          <target state="translated">&lt;strong id=&quot;partial_ordering&quot;&gt;Частичное упорядочение&lt;/strong&gt; из множества S является транзитивным, антисимметричной и рефлексивным отношением между объектами S.</target>
        </trans-unit>
        <trans-unit id="ac7ee38ffc1b59180cff85a400c6326e6a6aab8c" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;partition&quot;&gt;partition&lt;/strong&gt; of a set X is a collection S of non-empty subsets of X whose union is X and whose elements are pairwise disjoint.</source>
          <target state="translated">&lt;strong id=&quot;partition&quot;&gt;Перегородка&lt;/strong&gt; из множества X представляет собой набор S непустых подмножеств X, объединение которых X и элементы которого попарно не пересекаются.</target>
        </trans-unit>
        <trans-unit id="d7deee876d2b62ea04d66ac5c3791065935e84a9" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;path&quot;&gt;path&lt;/strong&gt; P from v[1] to v[k] in a digraph (V, E) is a non-empty sequence v[1], v[2], ..., v[k] of vertices in V such that there is an edge (v[i],v[i+1]) in E for 1 &amp;lt;= i &amp;lt; k.</source>
          <target state="translated">&lt;strong id=&quot;path&quot;&gt;Путь&lt;/strong&gt; Р от V [1] V [K] в орграфа (V, E) является непустая последовательность v [1], V [2], ..., v [к] вершин в V такой что в E есть ребро (v [i], v [i + 1]) для 1 &amp;lt;= i &amp;lt;k.</target>
        </trans-unit>
        <trans-unit id="e8aedf35788745c62222f34810b580741df0e0a0" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;relation&quot;&gt;relation&lt;/strong&gt; is a subset of X &amp;times; Y. Let R be a relation. The fact that (x, y) belongs to R is written as x R y. As relations are sets, the definitions of the last item (subset, union, and so on) apply to relations as well.</source>
          <target state="translated">&lt;strong id=&quot;relation&quot;&gt;Соотношение&lt;/strong&gt; является подмножеством X &amp;times; Y. Пусть R будет отношение. Тот факт, что (x, y) принадлежит R, записывается как x R y. Поскольку отношения являются наборами, определения последнего элемента (подмножества, объединения и т. Д.) Также применимы к отношениям.</target>
        </trans-unit>
        <trans-unit id="95446742f2edee92dac5319d85b31460c32015fe" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;simple_cycle&quot;&gt;simple cycle&lt;/strong&gt; is a path that is both a cycle and simple.</source>
          <target state="translated">&lt;strong id=&quot;simple_cycle&quot;&gt;Простой цикл&lt;/strong&gt; является путем , который является как циклом и простым.</target>
        </trans-unit>
        <trans-unit id="39c00c45dee614b6888498650b2a3b294abd94c1" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;strong_components&quot;&gt;strongly connected component&lt;/strong&gt; is a maximal subgraph such that there is a path between each pair of vertices.</source>
          <target state="translated">&lt;strong id=&quot;strong_components&quot;&gt;Сильно компонента связности&lt;/strong&gt; является максимальным подграф таким образом, что существует путь между каждой парой вершин.</target>
        </trans-unit>
        <trans-unit id="77ea1ecd6a8be92c17cbe1f20f7156f6526977e8" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;sub_binary&quot;&gt;sub binary&lt;/strong&gt; is created by &lt;code&gt;split_binary/2&lt;/code&gt; and when a binary is matched out in a binary pattern. A sub binary is a reference into a part of another binary (refc or heap binary, but never into another sub binary). Therefore, matching out a binary is relatively cheap because the actual binary data is never copied.</source>
          <target state="translated">&lt;strong id=&quot;sub_binary&quot;&gt;Суб двоичный&lt;/strong&gt; создаются &lt;code&gt;split_binary/2&lt;/code&gt; и , когда двоичный подобран в виде двоичных чисел. Дополнительный двоичный файл - это ссылка на часть другого двоичного файла (refc или двоичный файл кучи, но никогда не на другой дополнительный двоичный файл). Следовательно, сопоставление двоичного файла относительно дешево, поскольку фактические двоичные данные никогда не копируются.</target>
        </trans-unit>
        <trans-unit id="0025b1cc50f1b9268b28c701eca602b36605c8b7" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;subgraph&quot;&gt;subgraph&lt;/strong&gt; G' of G is a digraph whose vertices and edges form subsets of the vertices and edges of G.</source>
          <target state="translated">&lt;strong id=&quot;subgraph&quot;&gt;Подграф&lt;/strong&gt; G&amp;raquo;из G является орграфом, вершины и ребра образуют подмножество вершин и ребра графа G.</target>
        </trans-unit>
        <trans-unit id="0039a610746b5b7e8cb57b8cba5ce780934ff7d1" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;tree&quot;&gt;tree&lt;/strong&gt; is an acyclic non-empty digraph such that there is a unique path between every pair of vertices, considering all edges undirected.</source>
          <target state="translated">&lt;strong id=&quot;tree&quot;&gt;Дерево&lt;/strong&gt; представляет собой ациклическое непустое орграф таких , что существует единственный путь между каждой парой вершин, с учетом всех ребер неориентированных.</target>
        </trans-unit>
        <trans-unit id="b32ebe8bef0eb8997c83afb4f754eff3d04ebc28" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;type&quot;&gt;type&lt;/strong&gt; is an element of the domain of Sets.</source>
          <target state="translated">&lt;strong id=&quot;type&quot;&gt;Тип&lt;/strong&gt; является элементом домена множеств.</target>
        </trans-unit>
        <trans-unit id="c01dd20588e862d2bb347c0df2cf5a5ed91552dc" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;C node&lt;/strong&gt; is a C program written to act as a hidden node in a distributed Erlang system. The library &lt;strong&gt;Erl_Interface&lt;/strong&gt; contains functions for this purpose. For more information about C nodes, see the &lt;code&gt;Erl_Interface&lt;/code&gt; application and &lt;code&gt;Interoperability Tutorial.&lt;/code&gt;.</source>
          <target state="translated">Узел &lt;strong&gt;C&lt;/strong&gt; - это программа на языке C, написанная для работы в качестве скрытого узла в распределенной системе Erlang. Библиотека &lt;strong&gt;Erl_Interface&lt;/strong&gt; содержит функции для этого. Дополнительные сведения об узлах C см. &lt;code&gt;Erl_Interface&lt;/code&gt; приложении Erl_Interface и руководстве по &lt;code&gt;Interoperability Tutorial.&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="66dcfd2061a6be3ffc5089c446867b8415893bb3" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;basic target system&lt;/strong&gt; that can be started by calling the ordinary &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">&lt;strong&gt;Основная целевая система&lt;/strong&gt; , которая может быть запущена с помощью вызова обычного &lt;code&gt;erl&lt;/code&gt; сценария.</target>
        </trans-unit>
        <trans-unit id="55d83db79d583006717a0aeac0080dc553b75d98" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bit string generator&lt;/strong&gt; is written as:</source>
          <target state="translated">&lt;strong&gt;Генератор битовой строки&lt;/strong&gt; записываются в виде:</target>
        </trans-unit>
        <trans-unit id="afe2abf552bd26d880de2e2001d284ae41c0e744" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bitstring&lt;/strong&gt; is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8. If the number of bits is divisible by 8, the bitstring is also a binary.</source>
          <target state="translated">&lt;strong&gt;Битовая&lt;/strong&gt; последовательность из нуля или более битов, где число битов не должны быть кратна 8. Если число битов делится на 8, битовая также двоичный файл.</target>
        </trans-unit>
        <trans-unit id="a2d735f3a5066ecc4d1454fc4b0afd8407d709de" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;configuration file&lt;/strong&gt; contains values for configuration parameters for the applications in the system. The &lt;code&gt;erl&lt;/code&gt; command-line argument &lt;code&gt;-config Name&lt;/code&gt; tells the system to use data in the system configuration file &lt;code&gt;Name.config&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Конфигурационный файл&lt;/strong&gt; содержит значение параметров конфигурации для приложений в системе. &lt;code&gt;erl&lt;/code&gt; аргумент командной строки &lt;code&gt;-config Name&lt;/code&gt; указывает системе использовать данные в файле конфигурации системы &lt;code&gt;Name.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5f0a033b07b19b645b9f720df2987e2a2450883" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;distributed Erlang system&lt;/strong&gt; consists of a number of Erlang runtime systems communicating with each other. Each such runtime system is called a &lt;strong&gt;node&lt;/strong&gt;. Message passing between processes at different nodes, as well as links and monitors, are transparent when pids are used. Registered names, however, are local to each node. This means that the node must be specified as well when sending messages, and so on, using registered names.</source>
          <target state="translated">&lt;strong&gt;Распределенная система Эрланга&lt;/strong&gt; состоит из нескольких систем во время выполнения Эрланга , сообщающихся друг с другом. Каждая такая система исполнения называется &lt;strong&gt;узлом&lt;/strong&gt; . Передача сообщений между процессами на разных узлах, а также ссылки и мониторы прозрачны при использовании pid. Однако зарегистрированные имена являются локальными для каждого узла. Это означает, что узел также должен быть указан при отправке сообщений и т. Д. С использованием зарегистрированных имен.</target>
        </trans-unit>
        <trans-unit id="35fc39aba9120eb638121a4fd00b0aff5c8df307" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;filter&lt;/strong&gt; is an expression that evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Фильтр&lt;/strong&gt; представляет собой выражение , которое вычисляется &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af58fb7b10794b226c8b033e42961c724b6386f1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;filter&lt;/strong&gt; is an expression, which evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Фильтр&lt;/strong&gt; представляет собой выражение, которое вычисляется в &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7239a397a4de1f7e0f662d28e63db77e29a8a038" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;function clause&lt;/strong&gt; consists of a clause head and a clause body, separated by &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Предложение &lt;strong&gt;функции&lt;/strong&gt; состоит из заголовка предложения и тела предложения, разделенных знаком &lt;code&gt;-&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702433f39c9e775694cb8f7f07b7d2e088b91814" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;function declaration&lt;/strong&gt; is a sequence of function clauses separated by semicolons, and terminated by period (.).</source>
          <target state="translated">Объявление &lt;strong&gt;функции&lt;/strong&gt; - это последовательность предложений функции, разделенных точкой с запятой и завершенных точкой (.).</target>
        </trans-unit>
        <trans-unit id="e0718a97c18e8111eccdd99489900e93dcc235d2" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;generator&lt;/strong&gt; is written as:</source>
          <target state="translated">&lt;strong&gt;Генератор&lt;/strong&gt; записывается в виде:</target>
        </trans-unit>
        <trans-unit id="49fb24f8d2c4665a71b9fb75a2c85a70a1e64874" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;guard sequence&lt;/strong&gt; is a sequence of guards, separated by semicolon (;). The guard sequence is true if at least one of the guards is true. (The remaining guards, if any, are not evaluated.)</source>
          <target state="translated">&lt;strong&gt;Последовательность охранника&lt;/strong&gt; представляет собой последовательность охранников, разделенных точкой с запятой (;). Последовательность охранников верна, если хотя бы одна из охранников верна. (Остальные охранники, если таковые имеются, не оцениваются.)</target>
        </trans-unit>
        <trans-unit id="981eab14479daed48688de4a5ee56b2147f16eb8" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;guard&lt;/strong&gt; is a sequence of guard expressions, separated by comma (,). The guard is true if all guard expressions evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Охранник&lt;/strong&gt; представляет собой последовательность защитных выражений, разделенных запятой (,). Защита истинна, если все выражения защиты имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a741610f94ddf021d50b6a4ce0ea1ba4c3d40351" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;list&lt;/strong&gt; is any number of items. For example, an argument list can consist of zero, one, or more arguments.</source>
          <target state="translated">&lt;strong&gt;Список&lt;/strong&gt; любое количество элементов. Например, список аргументов может состоять из нуля, одного или нескольких аргументов.</target>
        </trans-unit>
        <trans-unit id="4bc9678f26cf6461a8a6b9764f2f492dda8d420f" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;log event&lt;/strong&gt; consists of a &lt;strong&gt;log level&lt;/strong&gt;, the &lt;strong&gt;message&lt;/strong&gt; to be logged, and &lt;strong&gt;metadata&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Журнал событий&lt;/strong&gt; состоит из &lt;strong&gt;уровня журнала&lt;/strong&gt; , то &lt;strong&gt;сообщение&lt;/strong&gt; , чтобы быть зарегистрированным, и &lt;strong&gt;метаданные&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d6bec719f540faf5ce29c281150ca7c1acd29a54" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;match context&lt;/strong&gt; is similar to a sub binary, but is optimized for binary matching. For example, it contains a direct pointer to the binary data. For each field that is matched out of a binary, the position in the match context is incremented.</source>
          <target state="translated">&lt;strong&gt;Контекст матча&lt;/strong&gt; похож на суб двоичный, но оптимизирован для двоичного сравнения. Например, он содержит прямой указатель на двоичные данные. Для каждого поля, сопоставленного из двоичного файла, позиция в контексте сопоставления увеличивается.</target>
        </trans-unit>
        <trans-unit id="1e9bc69d9c0a74c78cd0265b7c282de9ccd749ff" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;module attribute&lt;/strong&gt; defines a certain property of a module.</source>
          <target state="translated">&lt;strong&gt;Атрибут модуль&lt;/strong&gt; определяет некоторое свойство модуля.</target>
        </trans-unit>
        <trans-unit id="e8190f1687ae12b86f4402d53955920f9bd416c8" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;node&lt;/strong&gt; is an executing Erlang runtime system that has been given a name, using the command-line flag &lt;code&gt;-name&lt;/code&gt; (long names) or &lt;code&gt;-sname&lt;/code&gt; (short names).</source>
          <target state="translated">&lt;strong&gt;Узел&lt;/strong&gt; является выполнение системы выполнения Erlang, которое было дано имя, используя флаг командной строки &lt;code&gt;-name&lt;/code&gt; (длинные имена) или &lt;code&gt;-sname&lt;/code&gt; (короткие имена).</target>
        </trans-unit>
        <trans-unit id="6e89fa647f29644ee120e6617c0ff85024742693" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;raw filename&lt;/strong&gt; is a filename specified as a binary. The Erlang VM does not translate a filename specified as a binary on systems with transparent naming.</source>
          <target state="translated">&lt;strong&gt;Сырым имя файла&lt;/strong&gt; является имя файла задается в виде двоичного файла. Виртуальная машина Erlang не переводит имя файла, указанное как двоичное, в системах с прозрачным именованием.</target>
        </trans-unit>
        <trans-unit id="a275977fa1312a664ffd71817618e729388e7ac1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;release package&lt;/strong&gt; is a compressed tar file containing code for a certain version of a release, created by calling &lt;code&gt;&lt;a href=&quot;systools#make_tar-1&quot;&gt;systools:make_tar/1,2&lt;/a&gt;&lt;/code&gt;. The release package is to be located in the &lt;code&gt;$ROOT/releases&lt;/code&gt; directory of the previous version of the release, where &lt;code&gt;$ROOT&lt;/code&gt; is the installation root directory, &lt;code&gt;code:root_dir()&lt;/code&gt;. Another &lt;code&gt;releases&lt;/code&gt; directory can be specified using the SASL configuration parameter &lt;code&gt;releases_dir&lt;/code&gt; or the OS environment variable &lt;code&gt;RELDIR&lt;/code&gt;. The release handler must have write access to this directory to install the new release. The persistent state of the release handler is stored there in a file called &lt;code&gt;RELEASES&lt;/code&gt;.</source>
          <target state="translated">Пакет &lt;strong&gt;выпуска&lt;/strong&gt; - это сжатый файл tar, содержащий код для определенной версии выпуска, созданный с помощью вызова &lt;code&gt;&lt;a href=&quot;systools#make_tar-1&quot;&gt;systools:make_tar/1,2&lt;/a&gt;&lt;/code&gt; . Пакет выпуска должен быть расположен в каталоге &lt;code&gt;$ROOT/releases&lt;/code&gt; предыдущей версии выпуска, где &lt;code&gt;$ROOT&lt;/code&gt; - корневой каталог установки, &lt;code&gt;code:root_dir()&lt;/code&gt; . Другой &lt;code&gt;releases&lt;/code&gt; каталог может быть задан с помощью параметра конфигурации SASL &lt;code&gt;releases_dir&lt;/code&gt; или переменной окружения OS &lt;code&gt;RELDIR&lt;/code&gt; . У обработчика выпуска должны быть права на запись в этот каталог для установки нового выпуска. Постоянное состояние обработчика выпуска хранится там в файле под названием &lt;code&gt;RELEASES&lt;/code&gt; .,</target>
        </trans-unit>
        <trans-unit id="b0e927f4d2edf71fc5d44ab43ed17efe8434b72b" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;release&lt;/strong&gt; is a complete system made out from a subset of Erlang/OTP applications and a set of user-specific applications.</source>
          <target state="translated">&lt;strong&gt;Выпуск&lt;/strong&gt; представляет собой полную систему из из подмножества Erlang / OTP приложений и набора пользователем конкретных приложений.</target>
        </trans-unit>
        <trans-unit id="976ea0cb3408e08f1ff1f8752455df14d099e36d" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;sequence&lt;/strong&gt; is one or more items. For example, a clause body consists of a sequence of expressions. This means that there must be at least one expression.</source>
          <target state="translated">&lt;strong&gt;Последовательность&lt;/strong&gt; представляет собой один или несколько элементов. Например, тело предложения состоит из последовательности выражений. Это означает, что должно быть хотя бы одно выражение.</target>
        </trans-unit>
        <trans-unit id="17f419c4c64396cd3eddb7f3ce76e4edf856d5d9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;simple target system&lt;/strong&gt; where also code replacement in runtime can be performed.</source>
          <target state="translated">&lt;strong&gt;Просто целевая система&lt;/strong&gt; , где также может быть выполнена замена кода во время выполнения.</target>
        </trans-unit>
        <trans-unit id="bd639259721f11093866111b359fef2a8236a3eb" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;simple test object&lt;/strong&gt; is one of the following:</source>
          <target state="translated">&lt;strong&gt;Простой тест - объекта&lt;/strong&gt; является один из следующих:</target>
        </trans-unit>
        <trans-unit id="82a1fd7cbded9d1d8965325e8da4ad9119bb1b3f" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;start type&lt;/strong&gt; is defined when starting the application:</source>
          <target state="translated">Тип &lt;strong&gt;запуска&lt;/strong&gt; определяется при запуске приложения:</target>
        </trans-unit>
        <trans-unit id="a0236d18c08e4a43e425435b87053806e35cfab2" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;symmetric key&lt;/strong&gt; algorithm has one key only. The key is used for both encryption and decryption. These algorithms are fast, compared to public key algorithms (using two keys, one public and one private) and are therefore typically used for encrypting bulk data.</source>
          <target state="translated">&lt;strong&gt;Симметричный ключ&lt;/strong&gt; алгоритм имеет только один ключ. Ключ используется как для шифрования, так и для дешифрования. Эти алгоритмы быстры по сравнению с алгоритмами с открытым ключом (с использованием двух ключей, одного открытого и одного закрытого) и поэтому обычно используются для шифрования больших объемов данных.</target>
        </trans-unit>
        <trans-unit id="90e12c45690a2d90b9b7c27b63616643b3b02e6c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;token&lt;/strong&gt; is a tuple containing information about syntactic category, the token annotations, and the terminal symbol. For punctuation characters (such as &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) and reserved words, the category and the symbol coincide, and the token is represented by a two-tuple. Three-tuples have one of the following forms:</source>
          <target state="translated">&lt;strong&gt;Маркер&lt;/strong&gt; представляет собой кортеж , содержащий информацию о синтаксической категории, маркер аннотации, и символ терминала. Для знаков пунктуации (таких как &lt;code&gt;;&lt;/code&gt; и &lt;code&gt;|&lt;/code&gt; ) и зарезервированных слов категория и символ совпадают, и маркер представлен кортежем из двух элементов. Три кортежа имеют одну из следующих форм:</target>
        </trans-unit>
        <trans-unit id="c710c4620cfaa2e0ecb80d9dcbf14cd7cba3ca83" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;user&lt;/strong&gt; in this context is basically a module implementing the &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; behaviour. A &lt;strong&gt;user&lt;/strong&gt; can issue snmp requests and receive notification/traps.</source>
          <target state="translated">&lt;strong&gt;Пользователь&lt;/strong&gt; в данном контексте в основном модуль реализации &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; поведения. &lt;strong&gt;Пользователь&lt;/strong&gt; может выдавать запросы SNMP и получать уведомления / ловушку.</target>
        </trans-unit>
        <trans-unit id="9d2d133d1504025586739d14579afcf2a4b16f56" translate="yes" xml:space="preserve">
          <source>A Bin does not need to consist of a whole number of bytes.</source>
          <target state="translated">Мусорное ведро не обязательно должно состоять из целого числа байтов.</target>
        </trans-unit>
        <trans-unit id="446abf7d28572cb4c16319d9159e9f73428ea954" translate="yes" xml:space="preserve">
          <source>A Bin is a low-level sequence of bits or bytes. The purpose of a Bin is to enable construction of binaries:</source>
          <target state="translated">Бин-это низкоуровневая последовательность битов или байтов.Назначение Бина-дать возможность построения двоичных файлов:</target>
        </trans-unit>
        <trans-unit id="e18b65283e058fbced7bffdbd923450b434dd1e6" translate="yes" xml:space="preserve">
          <source>A Boolean indicating if the abstract code is compiler-generated. The Erlang Compiler does not emit warnings for such code.</source>
          <target state="translated">Булева,указывающая,генерируется ли абстрактный код компилятором.Компилятор Erlang не выдает предупреждений на такой код.</target>
        </trans-unit>
        <trans-unit id="8fafe519eed7d47dd4061f1954b6119a2c8bfca3" translate="yes" xml:space="preserve">
          <source>A Boolean indicating if the origin of the abstract code is a record. Used by &lt;code&gt;Dialyzer&lt;/code&gt; to assign types to tuple elements.</source>
          <target state="translated">Логическое значение, указывающее, является ли источником абстрактного кода запись. Используется &lt;code&gt;Dialyzer&lt;/code&gt; для присвоения типов элементам кортежа.</target>
        </trans-unit>
        <trans-unit id="6de41a093bc1801677e67b2a06074305f2cfcbb9" translate="yes" xml:space="preserve">
          <source>A Boolean specifying if the data has been transmitted over the wire.</source>
          <target state="translated">Булева указание,были ли данные переданы по проводу.</target>
        </trans-unit>
        <trans-unit id="0384327244e40e6c1e6266a9b063a6ad9f121c59" translate="yes" xml:space="preserve">
          <source>A C node has access to names registered through the &lt;code&gt;global&lt;/code&gt; module in Kernel. Names can be looked up, allowing the C node to send messages to named Erlang services. C nodes can also register global names, allowing them to provide named services to Erlang processes or other C nodes.</source>
          <target state="translated">Узел AC имеет доступ к именам, зарегистрированным через &lt;code&gt;global&lt;/code&gt; модуль ядра. Можно искать имена, что позволяет узлу C отправлять сообщения именованным службам Erlang. Узлы C также могут регистрировать глобальные имена, что позволяет им предоставлять именованные службы процессам Erlang или другим узлам C.</target>
        </trans-unit>
        <trans-unit id="682f01848ff412b810853a147adc8683eb3445ca" translate="yes" xml:space="preserve">
          <source>A C node server using long node names:</source>
          <target state="translated">Сервер узлов на C,использующий длинные имена узлов:</target>
        </trans-unit>
        <trans-unit id="bb35db3d2e0c2f3a8f1ad0dde3a30bca6441edc6" translate="yes" xml:space="preserve">
          <source>A C program that uses the Erl_Interface functions for setting up a connection to, and communicating with, a distributed Erlang node is called a &lt;strong&gt;C node&lt;/strong&gt;, or a &lt;strong&gt;hidden node&lt;/strong&gt;. The main advantage with a C node is that the communication from the Erlang programmer's perspective is extremely easy, as the C program behaves as a distributed Erlang node.</source>
          <target state="translated">Программа AC, которая использует функции Erl_Interface для установки соединения и связи с распределенным узлом Erlang, называется &lt;strong&gt;узлом C&lt;/strong&gt; или &lt;strong&gt;скрытым узлом&lt;/strong&gt; . Основное преимущество узла C состоит в том, что коммуникация с точки зрения программиста на Erlang чрезвычайно проста, поскольку программа C ведет себя как распределенный узел Erlang.</target>
        </trans-unit>
        <trans-unit id="aa24a183415b610afc89cc8dcdc9ea0fca45c74b" translate="yes" xml:space="preserve">
          <source>A C-node acting as a server is assigned a creation number when it calls &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">C-узлу, действующему как сервер, назначается номер создания, когда он вызывает &lt;code&gt;ei_publish()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c7aba44f58b6222686f74dc17e0b3bd8f16425" translate="yes" xml:space="preserve">
          <source>A C-node acting as a server is assigned a creation number when it calls &lt;code&gt;erl_publish()&lt;/code&gt;.</source>
          <target state="translated">C-узлу, действующему как сервер, назначается номер создания, когда он вызывает &lt;code&gt;erl_publish()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5f9a2d3d932ac1d27aa18a6752ebffe6998981" translate="yes" xml:space="preserve">
          <source>A C-node appears to Erlang as a &lt;strong&gt;hidden node&lt;/strong&gt;. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name does not appear in the listing provided by &lt;code&gt;erlang:nodes/0&lt;/code&gt; in &lt;code&gt;ERTS&lt;/code&gt;.</source>
          <target state="translated">C-узел кажется Erlang &lt;strong&gt;скрытым узлом&lt;/strong&gt; . То есть процессы Erlang, которым известно имя C-узла, могут связываться с ним обычным образом, но имя узла не появляется в списке, предоставленном &lt;code&gt;erlang:nodes/0&lt;/code&gt; в &lt;code&gt;ERTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e583adab7ce74410cb0c7c1feef4181103360c0c" translate="yes" xml:space="preserve">
          <source>A C-node appears to Erlang as a &lt;strong&gt;hidden node&lt;/strong&gt;. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name is not shown in the listing provided by &lt;code&gt;erlang:nodes/0&lt;/code&gt; in &lt;code&gt;ERTS&lt;/code&gt;.</source>
          <target state="translated">C-узел кажется Erlang &lt;strong&gt;скрытым узлом&lt;/strong&gt; . То есть процессы Erlang, которым известно имя C-узла, могут связываться с ним обычным образом, но имя узла не отображается в списке, предоставленном &lt;code&gt;erlang:nodes/0&lt;/code&gt; в &lt;code&gt;ERTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08059f968b0ad7c0b01718559289e25bd4f10ee5" translate="yes" xml:space="preserve">
          <source>A CPU Load and CPU Utilization Supervisor Process</source>
          <target state="translated">Процесс супервайзера загрузки и использования процессора</target>
        </trans-unit>
        <trans-unit id="5d2433f698f9b491166c109983414e1ff91ef2ab" translate="yes" xml:space="preserve">
          <source>A CPU topology can consist of both processor external, and processor internal NUMA nodes as long as each logical processor belongs to only one NUMA node. If &lt;code&gt;&amp;lt;ProcessorIds&amp;gt;&lt;/code&gt; is omitted, its default position is before &lt;code&gt;&amp;lt;NodeIds&amp;gt;&lt;/code&gt;. That is, the default is processor external NUMA nodes.</source>
          <target state="translated">Топология ЦП может состоять как из внешнего процессора, так и из внутреннего узла NUMA процессора, если каждый логический процессор принадлежит только одному узлу NUMA. Если &lt;code&gt;&amp;lt;ProcessorIds&amp;gt;&lt;/code&gt; опущен, его позиция по умолчанию перед &lt;code&gt;&amp;lt;NodeIds&amp;gt;&lt;/code&gt; . То есть по умолчанию используются внешние узлы NUMA процессора.</target>
        </trans-unit>
        <trans-unit id="8ed401286c11a4167b9153f2763d08ee22a748c5" translate="yes" xml:space="preserve">
          <source>A CTH can be installed in multiple ways in your test run. You can do it for all tests in a run, for specific test suites, and for specific groups within a test suite. If you want a CTH to be present in all test suites within your test run, there are three ways to accomplish that, as follows:</source>
          <target state="translated">CTH может быть установлен несколькими способами во время пробного прогона.Вы можете сделать это для всех тестов за один прогон,для определенных комплектов тестов,а также для определенных групп в комплекте тестов.Если вы хотите,чтобы КТГ присутствовала во всех тестовых комплектах во время прогона,есть три способа сделать это,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="2484fb91ce1c0711415802f1c1e1b2f011ddea08" translate="yes" xml:space="preserve">
          <source>A Coverage Analysis Tool for Erlang</source>
          <target state="translated">Инструмент для анализа покрытия для Эрланга</target>
        </trans-unit>
        <trans-unit id="462cfacaa4707242a4aec32251bf3187a68a4056" translate="yes" xml:space="preserve">
          <source>A Cross Reference Tool for analyzing dependencies between functions, modules, applications and releases.</source>
          <target state="translated">Перекрестное справочное средство для анализа зависимостей между функциями,модулями,приложениями и версиями.</target>
        </trans-unit>
        <trans-unit id="52283e056d3171a619c0cac0805fc7102c861750" translate="yes" xml:space="preserve">
          <source>A DBMS query language, Query List Comprehension (QLC) as an add-on library.</source>
          <target state="translated">Язык запросов СУБД,Понимание списка запросов (QLC)как дополнительная библиотека.</target>
        </trans-unit>
        <trans-unit id="bb6bc7a0a2c07a2fe54be2405da37b62f7c39bde" translate="yes" xml:space="preserve">
          <source>A DSA private key can look as follows:</source>
          <target state="translated">Личный ключ DSA может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="a0b5e71146772a786dbb1661b191c55af9cb0b9a" translate="yes" xml:space="preserve">
          <source>A Diameter application supported by the service.</source>
          <target state="translated">Приложение &quot;Диаметр&quot;,поддерживаемое сервисной службой.</target>
        </trans-unit>
        <trans-unit id="d177fdf4f1cf327fbf5fecfc4fa72345624b5d5f" translate="yes" xml:space="preserve">
          <source>A Diameter message as passed over the transport interface.</source>
          <target state="translated">Сигнал диаметра,переданный через транспортный интерфейс.</target>
        </trans-unit>
        <trans-unit id="62bfb25c7e21e8b536daf6c9f716b0eb6fa490c9" translate="yes" xml:space="preserve">
          <source>A Diameter node is implemented by configuring a &lt;strong&gt;service&lt;/strong&gt; and one or more &lt;strong&gt;transports&lt;/strong&gt; using the interface module &lt;code&gt;&lt;a href=&quot;diameter&quot;&gt;diameter&lt;/a&gt;&lt;/code&gt;. The service configuration defines the Diameter applications to be supported by the node and, typically, the capabilities that it should send to remote peers at capabilities exchange upon the establishment of transport connections. A transport is configured on a service and provides protocol-specific send/receive functionality by way of a transport interface defined by diameter and implemented by a transport module. The diameter application provides two transport modules: &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp&lt;/a&gt;&lt;/code&gt; for transport over TCP (using &lt;code&gt;gen_tcp&lt;/code&gt;) and SCTP (using &lt;code&gt;gen_sctp&lt;/code&gt;) respectively. Other transports can be provided by any module that implements diameter's &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Узел Diameter реализуется путем настройки &lt;strong&gt;службы&lt;/strong&gt; и одного или нескольких &lt;strong&gt;транспортов&lt;/strong&gt; с использованием &lt;code&gt;&lt;a href=&quot;diameter&quot;&gt;diameter&lt;/a&gt;&lt;/code&gt; интерфейсного модуля . Конфигурация службы определяет приложения Diameter, которые должны поддерживаться узлом, и, как правило, возможности, которые он должен отправлять удаленным одноранговым узлам при обмене возможностями после установления транспортных соединений. Транспорт настроен для службы и обеспечивает специфичные для протокола функции отправки / получения посредством транспортного интерфейса, определенного диаметром и реализуемого транспортным модулем. Применение диаметр обеспечивает два транспортных модулей: &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp&lt;/a&gt;&lt;/code&gt; для транспортировки по TCP (используя &lt;code&gt;gen_tcp&lt;/code&gt; ) и SCTP ( с использованием &lt;code&gt;gen_sctp&lt;/code&gt; ) соответственно. Другие виды транспорта могут быть предоставлены любым модулем, реализующим &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport interface&lt;/a&gt;&lt;/code&gt; диаметра .</target>
        </trans-unit>
        <trans-unit id="f6f02eb64bbe780dfde9efd8754001ee09c7d316" translate="yes" xml:space="preserve">
          <source>A Disk Supervisor Process</source>
          <target state="translated">Процесс супервайзера дисков</target>
        </trans-unit>
        <trans-unit id="cfe5d3f52e1bab9a63a7df0c0c6f4e1c0567b94a" translate="yes" xml:space="preserve">
          <source>A File Transfer Protocol client.</source>
          <target state="translated">Клиент протокола передачи файлов.</target>
        </trans-unit>
        <trans-unit id="8d70bbe040a2f8306532e86a99c772dde2300f04" translate="yes" xml:space="preserve">
          <source>A GUI tool for observing an Erlang system.</source>
          <target state="translated">Инструмент GUI для наблюдения за системой Эрланга.</target>
        </trans-unit>
        <trans-unit id="412558260339ef39924a36cedb4746b92b39860e" translate="yes" xml:space="preserve">
          <source>A MIB compiler, which understands SMIv1 (RFC1155, 1212, and 1215) and SMIv2 (RFC1902, 1903, and 1904).</source>
          <target state="translated">Компилятор MIB,понимающий SMIv1 (RFC1155,1212 и 1215)и SMIv2 (RFC1902,1903 и 1904).</target>
        </trans-unit>
        <trans-unit id="465e342200f443fe19bf77c7c55e103eb0525cf5" translate="yes" xml:space="preserve">
          <source>A Make Utility for Erlang</source>
          <target state="translated">A Сделать утилиту для Эрланга</target>
        </trans-unit>
        <trans-unit id="4dfa6d3d81a250e09767148c068c430d43e6542a" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to #megaco_incr_timer{}.</source>
          <target state="translated">Таймер Megaco (см.объяснение выше),по умолчанию #megaco_incr_timer{}.</target>
        </trans-unit>
        <trans-unit id="b68589e1526f4c0bee999a382123018413ba14b2" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to 30000.</source>
          <target state="translated">Таймер Megaco (см.объяснение выше),по умолчанию 30000.</target>
        </trans-unit>
        <trans-unit id="cbd6f555dff6fd8042f699c901ba913734ef4278" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;.</source>
          <target state="translated">Таймер Megaco (см. Объяснение выше), по умолчанию - &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dad93e1d5d1ceeacd635b8d583372b48511bbd3" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;10000&lt;/code&gt;.</source>
          <target state="translated">Таймер Megaco (см. Объяснение выше), по умолчанию &lt;code&gt;10000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c141bdf1ede3294bead601d72060262ea844d853" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;60 seconds&lt;/code&gt;.</source>
          <target state="translated">Таймер Megaco (см. Объяснение выше), по умолчанию &lt;code&gt;60 seconds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b0881b9c745a291d82b3b71d65651beef69c53b" translate="yes" xml:space="preserve">
          <source>A Memory Supervisor Process</source>
          <target state="translated">Процесс супервайзера памяти</target>
        </trans-unit>
        <trans-unit id="ae5893b089e2986872b8d9a34ac398cb97910587" translate="yes" xml:space="preserve">
          <source>A NIF does not have to be exported, it can be local to the module. However, unused local stub functions will be optimized away by the compiler, causing loading of the NIF library to fail.</source>
          <target state="translated">NIF не обязательно экспортировать,он может быть локальным для модуля.Однако неиспользуемые функции локальных шлейфов будут оптимизированы компилятором,что приведет к сбою при загрузке библиотеки NIF.</target>
        </trans-unit>
        <trans-unit id="ae9dbde8e133cef08c1e749be3a70e95b4ade2c3" translate="yes" xml:space="preserve">
          <source>A NIF is a function that is implemented in C instead of Erlang. NIFs appear as any other functions to the callers. They belong to a module and are called like any other Erlang functions. The NIFs of a module are compiled and linked into a dynamic loadable, shared library (SO in UNIX, DLL in Windows). The NIF library must be loaded in runtime by the Erlang code of the module.</source>
          <target state="translated">NIF-это функция,которая реализуется на C вместо Erlang.NIF появляются вызывающим абонентам как и любые другие функции.Они принадлежат модулю и вызываются,как и любые другие функции Erlang.NIF модуля компилируются и связываются в динамически загружаемую общую библиотеку (SO в UNIX,DLL в Windows).Библиотека NIF должна быть загружена во время выполнения кода модуля на Erlang.</target>
        </trans-unit>
        <trans-unit id="84d9be08ac04a1b8855fd49f7405173d0e59dc63" translate="yes" xml:space="preserve">
          <source>A NIF is thread-safe without any explicit synchronization as long as it acts as a pure function and only reads the supplied arguments. When you write to a shared state either through static variables or &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;, you need to supply your own explicit synchronization. This includes terms in process-independent environments that are shared between threads. Resource objects also require synchronization if you treat them as mutable.</source>
          <target state="translated">NIF является потокобезопасным без какой-либо явной синхронизации, пока он действует как чистая функция и считывает только предоставленные аргументы. Когда вы записываете в общее состояние через статические переменные или &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; , вам необходимо предоставить свою собственную явную синхронизацию. Это включает термины в независимых от процессов средах, которые используются потоками совместно. Объекты ресурсов также требуют синхронизации, если вы рассматриваете их как изменяемые.</target>
        </trans-unit>
        <trans-unit id="8a60c02f399b39b76528cae89a210e7ba95c129a" translate="yes" xml:space="preserve">
          <source>A NIF library contains native implementation of some functions of an Erlang module. The native implemented functions (NIFs) are called like any other functions without any difference to the caller. Each NIF must have an implementation in Erlang that is invoked if the function is called before the NIF library is successfully loaded. A typical such stub implementation is to throw an exception. But it can also be used as a fallback implementation if the NIF library is not implemented for some architecture.</source>
          <target state="translated">Библиотека NIF содержит нативную реализацию некоторых функций модуля Erlang.Нативные реализованные функции (NIF)вызываются,как и любые другие функции,без какой-либо разницы с вызывающим абонентом.Каждый NIF должен иметь реализацию на Erlang,которая вызывается,если функция вызывается до успешной загрузки библиотеки NIF.Типичной такой реализацией заглушки является бросание исключения.Но она также может быть использована в качестве резервной реализации,если библиотека NIF не реализована на какой-то архитектуре.</target>
        </trans-unit>
        <trans-unit id="16083aaa52c81a0267780218bf0e70427a08f38c" translate="yes" xml:space="preserve">
          <source>A NIF library is already loaded for this module instance. The previously deprecated &lt;code&gt;reload&lt;/code&gt; feature was removed in OTP 20.</source>
          <target state="translated">Для этого экземпляра модуля уже загружена библиотека NIF. Ранее устаревшая функция &lt;code&gt;reload&lt;/code&gt; была удалена в OTP 20.</target>
        </trans-unit>
        <trans-unit id="3a1f48477831047343a1f8bf95917f0e713f592c" translate="yes" xml:space="preserve">
          <source>A NIF that cannot be split and cannot execute in a millisecond or less is called a &quot;dirty NIF&quot;, as it performs work that the ordinary schedulers of the Erlang runtime system cannot handle cleanly. Applications that make use of such functions must indicate to the runtime that the functions are dirty so they can be handled specially. This is handled by executing dirty jobs on a separate set of schedulers called dirty schedulers. A dirty NIF executing on a dirty scheduler does not have the same duration restriction as a normal NIF.</source>
          <target state="translated">NIF,который не может быть разделен и не может быть выполнен за миллисекунду или меньше,называется &quot;грязным NIF&quot;,так как он выполняет работу,с которой обычные планировщики системы исполнения Erlang не могут справиться чисто.Приложения,использующие такие функции,должны указывать на время выполнения,что эти функции &quot;грязные&quot;,чтобы их можно было специально обрабатывать.Это выполняется путем выполнения &quot;грязных&quot; работ на отдельном наборе планировщиков,называемых &quot;грязными&quot; планировщиками.Грязный NIF,выполняемый на &quot;грязном&quot; планировщике,не имеет такого же ограничения длительности,как обычный NIF.</target>
        </trans-unit>
        <trans-unit id="af197bff7b3c7ea0c0e795a6e3fce23b4ca646b1" translate="yes" xml:space="preserve">
          <source>A Net if process must implement the SNMP agent &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Процесс Net if должен реализовывать &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt; агента SNMP .</target>
        </trans-unit>
        <trans-unit id="4682baf7bf989ecc09c30378539a80083913f72a" translate="yes" xml:space="preserve">
          <source>A Net if process must implement the SNMP manager &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Процесс Net if должен реализовывать &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt; менеджера SNMP .</target>
        </trans-unit>
        <trans-unit id="b5ce5e0afdd417aa616eb37eb871e57129530691" translate="yes" xml:space="preserve">
          <source>A POSIX error value if something else goes wrong, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; for possible error values</source>
          <target state="translated">Значение ошибки POSIX, если что-то еще пойдет не так, см. &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; для возможных значений ошибок</target>
        </trans-unit>
        <trans-unit id="66a3f3d7962a2ff38d3eb0fc27400ec7705ecedf" translate="yes" xml:space="preserve">
          <source>A POSIX thread like API for multi-threading is provided. The Erlang driver thread API only provides a subset of the functionality provided by the POSIX thread API. The subset provided is more or less the basic functionality needed for multi-threaded programming:</source>
          <target state="translated">Для многопоточности предусмотрен POSIX-поток,например,API.Потоковое API драйвера Erlang предоставляет только подмножество функций,предоставляемых POSIX-потоковым API.Это подмножество является более или менее базовой функциональностью,необходимой для многопоточного программирования:</target>
        </trans-unit>
        <trans-unit id="0bd457a7ac87a208b16a149cb348e99367ad82ba" translate="yes" xml:space="preserve">
          <source>A PPID can be configured with a a gen_sctp sctp_default_send_param option.</source>
          <target state="translated">PPID может быть настроен с опцией sctp_default_send_param.</target>
        </trans-unit>
        <trans-unit id="6c511d3ccb60e7dc830ac553725bdc5da3a2e9fa" translate="yes" xml:space="preserve">
          <source>A Route-Record AVP is appended by diameter when the return value of a request callback asks that a request be forwarded. Appending the AVP in other cases is the responsibility of the user.</source>
          <target state="translated">Route-Record AVP добавляется по диаметру,когда возвращаемое значение обратного вызова запроса запрашивает переадресацию запроса.Ответственность за добавление AVP в других случаях лежит на пользователе.</target>
        </trans-unit>
        <trans-unit id="094734567e030c7a3c51ff51fd0000a24bb2ce28" translate="yes" xml:space="preserve">
          <source>A SAX parser for XML that sends the events through a callback interface. SAX is the &lt;strong&gt;Simple API for XML&lt;/strong&gt;, originally a Java-only API. SAX was the first widely adopted API for XML in Java, and is a &lt;strong&gt;de facto&lt;/strong&gt; standard where there are versions for several programming language environments other than Java.</source>
          <target state="translated">Синтаксический анализатор SAX для XML, который отправляет события через интерфейс обратного вызова. SAX - это &lt;strong&gt;простой API для XML&lt;/strong&gt; , изначально предназначенный только для Java. SAX был первым широко принятым API для XML в Java и &lt;strong&gt;де-факто&lt;/strong&gt; стандартом, в котором есть версии для нескольких языковых сред программирования, отличных от Java.</target>
        </trans-unit>
        <trans-unit id="248ee08e6a02ab2fc5bc7400b653c53caa52bbda" translate="yes" xml:space="preserve">
          <source>A Set of Release Handling Tools</source>
          <target state="translated">Набор инструментов для разблокировки</target>
        </trans-unit>
        <trans-unit id="60186d2f270382eb00ad49b3e5e34efc25a7eb30" translate="yes" xml:space="preserve">
          <source>A TAR program that understands the GNU TAR format for long filenames.</source>
          <target state="translated">Программа TAR,которая понимает формат GNU TAR для длинных имен файлов.</target>
        </trans-unit>
        <trans-unit id="7a5eb9a2cf5198242ce83b7910f56bb7256b5a72" translate="yes" xml:space="preserve">
          <source>A Time Profiling Tool for Erlang</source>
          <target state="translated">Инструмент профилирования времени для Эрланга</target>
        </trans-unit>
        <trans-unit id="02d15da22619453c9a967ff17ef23dbd1a99ec4f" translate="yes" xml:space="preserve">
          <source>A Time Profiling Tool using trace to file for minimal runtime performance impact.</source>
          <target state="translated">Инструмент временного профилирования,использующий трассировку в файл для минимального влияния на производительность во время выполнения.</target>
        </trans-unit>
        <trans-unit id="b6a932a694249ceff9de8c32f16fd50b0a78a087" translate="yes" xml:space="preserve">
          <source>A URI is an identifier consisting of a sequence of characters matching the syntax rule named &lt;strong&gt;URI&lt;/strong&gt; in &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">URI - это идентификатор, состоящий из последовательности символов, соответствующих правилу синтаксиса с именем &lt;strong&gt;URI&lt;/strong&gt; в &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e149e0b4c1a1c105b7f889d32cd56c5262fc2226" translate="yes" xml:space="preserve">
          <source>A Unicode extended grapheme cluster</source>
          <target state="translated">Расширенный графемный кластер Юникода</target>
        </trans-unit>
        <trans-unit id="91c776c2572caac7dae19c58dc677fab9b2bc760" translate="yes" xml:space="preserve">
          <source>A Unix-specific example:</source>
          <target state="translated">Пример для Unix:</target>
        </trans-unit>
        <trans-unit id="44f895c061c338a2c4f6db51cc29f383c116fdd5" translate="yes" xml:space="preserve">
          <source>A User is an entity identified by a MID, e.g. a MGC or a MG.</source>
          <target state="translated">Пользователь-это организация,идентифицируемая MID,например,MGC или MG.</target>
        </trans-unit>
        <trans-unit id="32b6de1aa97b29f50e5912a12d7ac4a95b0cfea8" translate="yes" xml:space="preserve">
          <source>A WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">Инструмент на основе WxWidgets для просмотра аварийных сбросов Erlang.</target>
        </trans-unit>
        <trans-unit id="e4bde50404582298e3cf270bb8ccc3daf0ea5444" translate="yes" xml:space="preserve">
          <source>A back reference (see the next section)</source>
          <target state="translated">Обратная ссылка (см.следующий раздел)</target>
        </trans-unit>
        <trans-unit id="53d6a047b6dd3ed0e849f25a2c3fb01b061ee975" translate="yes" xml:space="preserve">
          <source>A back reference matches whatever matched the capturing subpattern in the current subject string, rather than anything matching the subpattern itself (section &lt;code&gt;&lt;a href=&quot;#sect21&quot;&gt;Subpattern as Subroutines&lt;/a&gt;&lt;/code&gt; describes a way of doing that). So, the following pattern matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;:</source>
          <target state="translated">Обратная ссылка соответствует тому, что соответствует подшаблону захвата в текущей строке темы, а не чему-либо, совпадающему с самим подшаблоном (раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#sect21&quot;&gt;Subpattern as Subroutines&lt;/a&gt;&lt;/code&gt; описывает способ сделать это). Итак, следующий шаблон соответствует &amp;laquo;разуму и чувствительности&amp;raquo; и &amp;laquo;реакции и ответственности&amp;raquo;, но не &amp;laquo;разуму и ответственности&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="c7a2ff223aa7f1180c7a5c0c761648542d8226fb" translate="yes" xml:space="preserve">
          <source>A back reference that occurs inside the parentheses to which it refers fails when the subpattern is first used, so, for example, (a\1) never matches. However, such references can be useful inside repeated subpatterns. For example, the following pattern matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababbaa&quot;, and so on:</source>
          <target state="translated">Обратная ссылка,которая возникает внутри круглых скобок,на которые она ссылается,не срабатывает при первом использовании подмаскировки,так что,например,(a\1)никогда не совпадает.Однако,такие ссылки могут быть полезны внутри повторяющихся подмаскировок.Например,следующий шаблон соответствует любому числу &quot;a&quot;,а также &quot;aba&quot;,&quot;ababbaa&quot; и так далее:</target>
        </trans-unit>
        <trans-unit id="ffc1ebbafbdaba3dd7477ee36631ba1276292a19" translate="yes" xml:space="preserve">
          <source>A back reference to a numbered subpattern uses the most recent value that is set for that number by any subpattern. The following pattern matches &quot;abcabc&quot; or &quot;defdef&quot;:</source>
          <target state="translated">Обратная ссылка на пронумерованную подмасштабинку использует самое последнее значение,установленное для этого числа любой подмасштабинкой.Следующий образец совпадает с &quot;abcabc&quot; или &quot;defdef&quot;:</target>
        </trans-unit>
        <trans-unit id="0d402fcdbef693771940455e9ef73fd921c03b39" translate="yes" xml:space="preserve">
          <source>A base for building trace tools for distributed systems.</source>
          <target state="translated">База для создания инструментов трассировки для распределенных систем.</target>
        </trans-unit>
        <trans-unit id="c418f2ac7b109d9e422eb741c2ec0065dcef710c" translate="yes" xml:space="preserve">
          <source>A basic concept in Erlang/OTP is the &lt;strong&gt;supervision tree&lt;/strong&gt;. This is a process structuring model based on the idea of &lt;strong&gt;workers&lt;/strong&gt; and &lt;strong&gt;supervisors&lt;/strong&gt;:</source>
          <target state="translated">Основная концепция Erlang / OTP - это &lt;strong&gt;дерево надзора&lt;/strong&gt; . Это модель структурирования процесса, основанная на идее &lt;strong&gt;работников&lt;/strong&gt; и &lt;strong&gt;руководителей&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="a7814d9e97780d5bb1e4072e8590cdbb3e3d0929" translate="yes" xml:space="preserve">
          <source>A better solution for a real module is to take advantage of the new directive &lt;code&gt;on_load&lt;/code&gt; (see section &lt;code&gt;Running a Function When a Module is Loaded&lt;/code&gt; in the Erlang Reference Manual) to load the NIF library automatically when the module is loaded.</source>
          <target state="translated">Лучшее решение для реального модуля - воспользоваться новой директивой &lt;code&gt;on_load&lt;/code&gt; (см. Раздел &amp;laquo; &lt;code&gt;Running a Function When a Module is Loaded&lt;/code&gt; загрузке модуля&amp;raquo; в Справочном руководстве Erlang) для автоматической загрузки библиотеки NIF при загрузке модуля.</target>
        </trans-unit>
        <trans-unit id="415e0f889e1439e4772c9c6a317c5d9eae0185a6" translate="yes" xml:space="preserve">
          <source>A binary always contains a complete number of bytes.</source>
          <target state="translated">Двоичный файл всегда содержит полное количество байт.</target>
        </trans-unit>
        <trans-unit id="b3e748c424b491ef4e2b424caaa0193f66560cd4" translate="yes" xml:space="preserve">
          <source>A binary data object, structured according to the Erlang external term format.</source>
          <target state="translated">Объект двоичных данных,структурированный в соответствии с форматом внешних терминов Erlang.</target>
        </trans-unit>
        <trans-unit id="298c689646b297768a8fb73aa045eb2812167789" translate="yes" xml:space="preserve">
          <source>A binding structure.</source>
          <target state="translated">Связывающая структура.</target>
        </trans-unit>
        <trans-unit id="e77e3889fe8c014ea8612f275ae6ccbea02093b9" translate="yes" xml:space="preserve">
          <source>A bit string comprehension returns a bit string, which is created by concatenating the results of evaluating &lt;code&gt;BitString&lt;/code&gt; for each combination of bit string generator elements, for which all filters are true.</source>
          <target state="translated">&lt;code&gt;BitString&lt;/code&gt; битовой строки возвращает битовую строку, которая создается путем объединения результатов оценки BitString для каждой комбинации элементов генератора битовой строки, для которой все фильтры истинны.</target>
        </trans-unit>
        <trans-unit id="c30114629b8426a6ada7d40a7f0ce097c95413d5" translate="yes" xml:space="preserve">
          <source>A bit string is used to store an area of untyped memory.</source>
          <target state="translated">Битовая строка используется для хранения области нетиповой памяти.</target>
        </trans-unit>
        <trans-unit id="36bc1be2e2bdda5bcfbb5daa59af1b7decd47b95" translate="yes" xml:space="preserve">
          <source>A bitstring. By default, a &lt;code&gt;BIT STRING&lt;/code&gt; with no symbolic names is decoded to an Erlang bitstring.</source>
          <target state="translated">Битва. По умолчанию &lt;code&gt;BIT STRING&lt;/code&gt; без символических имен декодируется в битовую строку Erlang.</target>
        </trans-unit>
        <trans-unit id="c215287a4d613c8262ada2c7133754a941970ff4" translate="yes" xml:space="preserve">
          <source>A body B is a non-empty sequence of expressions &lt;code&gt;E_1, ..., E_k&lt;/code&gt;, and Rep(B) = &lt;code&gt;[Rep(E_1), ..., Rep(E_k)]&lt;/code&gt;.</source>
          <target state="translated">Тело B - это непустая последовательность выражений &lt;code&gt;E_1, ..., E_k&lt;/code&gt; и Rep (B) = &lt;code&gt;[Rep(E_1), ..., Rep(E_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d107afa764d6c26d14d3133c85da34202dfafd4f" translate="yes" xml:space="preserve">
          <source>A boot script (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;) can be used that automatically starts the application.</source>
          <target state="translated">Можно использовать сценарий загрузки (см. &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ), который автоматически запускает приложение.</target>
        </trans-unit>
        <trans-unit id="919bef16600e113be86a5b24871b84665ab0d813" translate="yes" xml:space="preserve">
          <source>A boot script can be written manually. However, it is recommended to create a boot script by generating it from a release resource file &lt;code&gt;Name.rel&lt;/code&gt;, using the function &lt;code&gt;systools:make_script/1,2&lt;/code&gt;. This requires that the source code is structured as applications according to the OTP design principles. (The program does not have to be started in terms of OTP applications, but can be plain Erlang).</source>
          <target state="translated">Сценарий загрузки можно написать вручную. Однако рекомендуется создать сценарий загрузки, сгенерировав его из файла ресурсов выпуска &lt;code&gt;Name.rel&lt;/code&gt; , используя функцию &lt;code&gt;systools:make_script/1,2&lt;/code&gt; . Для этого необходимо, чтобы исходный код был структурирован как приложения в соответствии с принципами проектирования OTP. (Программа не обязательно должна запускаться с точки зрения приложений OTP, но может быть простым Erlang).</target>
        </trans-unit>
        <trans-unit id="c5fdc6fd4567d3a558e76cbc7f894eaa5a1c1eee" translate="yes" xml:space="preserve">
          <source>A boot script file has the extension &lt;code&gt;.script&lt;/code&gt;. The runtime system uses a binary version of the script. This &lt;strong&gt;binary boot script&lt;/strong&gt; file has the extension &lt;code&gt;.boot&lt;/code&gt;.</source>
          <target state="translated">Файл загрузочного сценария имеет расширение &lt;code&gt;.script&lt;/code&gt; . Система выполнения использует двоичную версию сценария. Этот &lt;strong&gt;двоичный&lt;/strong&gt; файл &lt;strong&gt;сценария загрузки&lt;/strong&gt; имеет расширение &lt;code&gt;.boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38a18422668a20d746ea102449e8109a669766e" translate="yes" xml:space="preserve">
          <source>A boot script generated using &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; is already transformed to the binary form.</source>
          <target state="translated">Сценарий загрузки, созданный с помощью &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; , уже преобразован в двоичную форму.</target>
        </trans-unit>
        <trans-unit id="4418a28f4bc85f1e896a145b5a8fb062a5cafe33" translate="yes" xml:space="preserve">
          <source>A boot script, &lt;code&gt;Name.boot&lt;/code&gt;</source>
          <target state="translated">Загрузочный скрипт &lt;code&gt;Name.boot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="506ee8bd04d892c57686f10406bfc1fa492da78c" translate="yes" xml:space="preserve">
          <source>A breakpoint can be either &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. Inactive breakpoints are ignored.</source>
          <target state="translated">Точка останова может быть &lt;strong&gt;активной&lt;/strong&gt; или &lt;strong&gt;неактивной&lt;/strong&gt; . Неактивные точки останова игнорируются.</target>
        </trans-unit>
        <trans-unit id="a1dbb3701c56d51053c806657654df88416bde25" translate="yes" xml:space="preserve">
          <source>A breakpoint has the following:</source>
          <target state="translated">Точка останова имеет следующее:</target>
        </trans-unit>
        <trans-unit id="f64f15640358c275e2397b778cc1de26c7a69372" translate="yes" xml:space="preserve">
          <source>A brief example in C of how to set the console control handler:</source>
          <target state="translated">Краткий пример на C,как установить обработчик консольного управления:</target>
        </trans-unit>
        <trans-unit id="f6e88d46ec95e4e6ad69aee75cf44a13d46cf46a" translate="yes" xml:space="preserve">
          <source>A buffer that holds a message being decoded can also have trailing bytes. If those trailing bytes are important, they can be returned along with the decoded value by compiling the ASN.1 specification with option &lt;code&gt;+undec_rest&lt;/code&gt;. The return value from the decoder is &lt;code&gt;{ok,Value,Rest}&lt;/code&gt; where &lt;code&gt;Rest&lt;/code&gt; is a binary containing the trailing bytes.</source>
          <target state="translated">Буфер, содержащий декодируемое сообщение, также может иметь завершающие байты. Если эти завершающие байты важны, они могут быть возвращены вместе с декодированным значением путем компиляции спецификации ASN.1 с опцией &lt;code&gt;+undec_rest&lt;/code&gt; . Возвращаемое значение декодера - &lt;code&gt;{ok,Value,Rest}&lt;/code&gt; , где &lt;code&gt;Rest&lt;/code&gt; - двоичный файл, содержащий завершающие байты.</target>
        </trans-unit>
        <trans-unit id="233c3de16098dc52e49751db996b0afab4a44df9" translate="yes" xml:space="preserve">
          <source>A buffer that holds a message, being decoded it can also have some following bytes. Those following bytes can now be returned together with the decoded value. If an ASN.1 specification is compiled with this option, a tuple &lt;code&gt;{ok, Value, Rest}&lt;/code&gt; is returned. &lt;code&gt;Rest&lt;/code&gt; can be a list or a binary. Earlier versions of the compiler ignored those following bytes.</source>
          <target state="translated">Буфер, содержащий сообщение, которое декодируется, также может иметь несколько следующих байтов. Следующие байты теперь могут быть возвращены вместе с декодированным значением. Если спецификация ASN.1 скомпилирована с этой опцией, возвращается кортеж &lt;code&gt;{ok, Value, Rest}&lt;/code&gt; . &lt;code&gt;Rest&lt;/code&gt; может быть списком или двоичным. Более ранние версии компилятора игнорировали следующие байты.</target>
        </trans-unit>
        <trans-unit id="1919a9845de02d3849d0b2e74c7851b7ee8c5506" translate="yes" xml:space="preserve">
          <source>A built-in function is called.</source>
          <target state="translated">Вызывается встроенная функция.</target>
        </trans-unit>
        <trans-unit id="99e307ba4f985ee1b328ac24d026a83d768b7e31" translate="yes" xml:space="preserve">
          <source>A call has been made to another transfer function during chunk sending, that is, before a call to &lt;code&gt;send_chunk_end/1&lt;/code&gt;.</source>
          <target state="translated">Вызов был сделан в другую функцию передачи во время отправки блока, то есть перед вызовом &lt;code&gt;send_chunk_end/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c058e649153aa49de98647d3ad23a2d22b4f3cbb" translate="yes" xml:space="preserve">
          <source>A call is made to &lt;code&gt;send_chunk/2&lt;/code&gt; or &lt;code&gt;send_chunk_end/1&lt;/code&gt; before a call to &lt;code&gt;send_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">Вызов делается &lt;code&gt;send_chunk/2&lt;/code&gt; или &lt;code&gt;send_chunk_end/1&lt;/code&gt; перед вызовом &lt;code&gt;send_chunk_start/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74dd8fdb8624f61745c3d9662e7a1e10a90a4feb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;ei_set_compat_rel(release_number)&lt;/code&gt; sets the &lt;code&gt;ei&lt;/code&gt; library in compatibility mode of release &lt;code&gt;release_number&lt;/code&gt;. Valid range of &lt;code&gt;release_number&lt;/code&gt; is &lt;code&gt;[7, current release]&lt;/code&gt;. This makes it possible to communicate with Erlang/OTP components from earlier releases.</source>
          <target state="translated">Вызов &lt;code&gt;ei_set_compat_rel(release_number)&lt;/code&gt; устанавливает библиотеку &lt;code&gt;ei&lt;/code&gt; в режим совместимости выпуска &lt;code&gt;release_number&lt;/code&gt; . Допустимый диапазон &lt;code&gt;release_number&lt;/code&gt; : &lt;code&gt;[7, current release]&lt;/code&gt; . Это позволяет взаимодействовать с компонентами Erlang / OTP из более ранних выпусков.</target>
        </trans-unit>
        <trans-unit id="e817aa48e70b9f9cfae211dd9da7a5a9ccf5b654" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;erl_set_compat_rel(release_number)&lt;/code&gt; sets the &lt;code&gt;Erl_Interface&lt;/code&gt; library in compatibility mode of release &lt;code&gt;release_number&lt;/code&gt;. Valid range of &lt;code&gt;release_number&lt;/code&gt; is [7, current release]. This makes it possible to communicate with Erlang/OTP components from earlier releases.</source>
          <target state="translated">Вызов &lt;code&gt;erl_set_compat_rel(release_number)&lt;/code&gt; устанавливает библиотеку &lt;code&gt;Erl_Interface&lt;/code&gt; в режим совместимости выпуска &lt;code&gt;release_number&lt;/code&gt; . Допустимый диапазон &lt;code&gt;release_number&lt;/code&gt; : [7, текущий выпуск]. Это позволяет взаимодействовать с компонентами Erlang / OTP из более ранних выпусков.</target>
        </trans-unit>
        <trans-unit id="0712fa3986f50d28ad07c76a65c1ecbb80736c35" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;get_system_memory_data/0&lt;/code&gt; is more costly than a call to &lt;code&gt;get_memory_data/0&lt;/code&gt; as data is collected synchronously when this function is called.</source>
          <target state="translated">Вызов &lt;code&gt;get_system_memory_data/0&lt;/code&gt; дороже, чем вызов &lt;code&gt;get_memory_data/0&lt;/code&gt; , поскольку данные собираются синхронно при вызове этой функции.</target>
        </trans-unit>
        <trans-unit id="2f677dc037cd69c670e9e88e5bc616a216192d94" translate="yes" xml:space="preserve">
          <source>A call to the call-back function &lt;code&gt;F&lt;/code&gt; will be</source>
          <target state="translated">Вызов функции обратного вызова &lt;code&gt;F&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="64cfccc0b7ce97122769d167098947b39055c31f" translate="yes" xml:space="preserve">
          <source>A call to validate/2 or validate/3 must provide a well formed parsed XML element &lt;code&gt;#xmlElement{}&lt;/code&gt; and a State, &lt;code&gt;global_state()&lt;/code&gt;, which holds necessary information from an already processed schema. Thus validate enables reuse of the schema information and therefore if one shall validate several times towards the same schema it reduces time consumption.</source>
          <target state="translated">Вызов функции validate / 2 или validate / 3 должен предоставлять хорошо сформированный проанализированный элемент XML &lt;code&gt;#xmlElement{}&lt;/code&gt; и состояние &lt;code&gt;global_state()&lt;/code&gt; , которое содержит необходимую информацию из уже обработанной схемы. Таким образом, проверка позволяет повторно использовать информацию о схеме, и поэтому, если нужно проверять несколько раз одну и ту же схему, это сокращает затраты времени.</target>
        </trans-unit>
        <trans-unit id="4d8d381879044ee596ec7ee05db7b89483e7064a" translate="yes" xml:space="preserve">
          <source>A call-back function for user-controlled formatting. See &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция обратного вызова для форматирования, управляемого пользователем. См. &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df69379f9325d6a9fdffa360b63f0ee0eab09db5" translate="yes" xml:space="preserve">
          <source>A callback function that is called when the scanner has found an unquoted atom. If the function returns &lt;code&gt;true&lt;/code&gt;, the unquoted atom itself becomes the category of the token. If the function returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;atom&lt;/code&gt; becomes the category of the unquoted atom.</source>
          <target state="translated">Функция обратного вызова, которая вызывается, когда сканер обнаруживает атом без кавычек. Если функция возвращает &lt;code&gt;true&lt;/code&gt; , атом без кавычек сам становится категорией токена. Если функция возвращает &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;atom&lt;/code&gt; становится категорией атома без кавычек.</target>
        </trans-unit>
        <trans-unit id="d91fce55e4034ef8ef725ab8525f555ff39cf2b9" translate="yes" xml:space="preserve">
          <source>A callback interface on top of Common Test.</source>
          <target state="translated">Интерфейс обратного вызова поверх общего теста.</target>
        </trans-unit>
        <trans-unit id="5e9caf8f98e50d5cd26b8f05e66b990f8b3c6d79" translate="yes" xml:space="preserve">
          <source>A callback module can inherit definitions from other callback modules, through the required function &lt;code&gt;'#xml-interitance#() -&amp;gt; [ModuleName::atom()]&lt;/code&gt;.</source>
          <target state="translated">Модуль обратного вызова может наследовать определения от других модулей обратного вызова через требуемую функцию &lt;code&gt;'#xml-interitance#() -&amp;gt; [ModuleName::atom()]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb141abb3a89c44d4c462fec76a604e27632ab05" translate="yes" xml:space="preserve">
          <source>A callback module is a functional module, and for code extensions simple code replacement is sufficient.</source>
          <target state="translated">Модуль обратного вызова является функциональным модулем,а для расширения кода достаточно простой замены кода.</target>
        </trans-unit>
        <trans-unit id="b46a19092f99a8ba307ae9376469c5315dc6fe6f" translate="yes" xml:space="preserve">
          <source>A callback module to customize the inets HTTP servers behaviour see &lt;code&gt;&lt;a href=&quot;httpd_custom_api&quot;&gt;httpd_custom_api&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Модуль обратного вызова для настройки поведения HTTP-серверов &lt;code&gt;&lt;a href=&quot;httpd_custom_api&quot;&gt;httpd_custom_api&lt;/a&gt;&lt;/code&gt; см. Httpd_custom_api</target>
        </trans-unit>
        <trans-unit id="5dc7be0b141d438c4483859c6c7d158a83325e8d" translate="yes" xml:space="preserve">
          <source>A cancelled timetrap is not automatically reactivated after the break, but must be started exlicitly with &lt;code&gt;&lt;a href=&quot;#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Отмененная временная ловушка не активируется автоматически после перерыва, но должна быть запущена явно с помощью &lt;code&gt;&lt;a href=&quot;#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80902d7e7f7cef8831c2f630fc53d4cb3659cebe" translate="yes" xml:space="preserve">
          <source>A certificate is similar to a driver's license, or a passport. The holder of the certificate is called the &lt;strong&gt;subject&lt;/strong&gt;. The certificate is signed with the private key of the issuer of the certificate. A chain of trust is built by having the issuer in its turn being certified by another certificate, and so on, until you reach the so called root certificate, which is self-signed, that is, issued by itself.</source>
          <target state="translated">Свидетельство похоже на водительское удостоверение или паспорт. Обладатель сертификата называется &lt;strong&gt;субъектом&lt;/strong&gt; . Сертификат подписан закрытым ключом эмитента сертификата. Цепочка доверия создается тем, что эмитент, в свою очередь, сертифицируется другим сертификатом, и так далее, пока вы не достигнете так называемого корневого сертификата, который является самоподписанным, то есть выпущенным самим собой.</target>
        </trans-unit>
        <trans-unit id="f2fd43ae2e93cd58a77e25d50c236c265a71aa31" translate="yes" xml:space="preserve">
          <source>A chain of calls is represented by a list of &lt;code&gt;constant()&lt;/code&gt;. The list contains the From vertex of every call and the To vertex of the last call.</source>
          <target state="translated">Цепочка вызовов представлена ​​списком &lt;code&gt;constant()&lt;/code&gt; . Список содержит вершину From каждого вызова и вершину To последнего вызова.</target>
        </trans-unit>
        <trans-unit id="85a537a33d3a97006da5ac79a03e13d4e08816a8" translate="yes" xml:space="preserve">
          <source>A chain of module calls from &lt;code&gt;toolbar&lt;/code&gt; to &lt;code&gt;debugger&lt;/code&gt;, if there is such a chain, otherwise &lt;code&gt;false&lt;/code&gt;. The chain of calls is represented by a list of modules, &lt;code&gt;toolbar&lt;/code&gt; being the first element and &lt;code&gt;debugger&lt;/code&gt;the last element.</source>
          <target state="translated">Цепочка вызовов модуля от &lt;code&gt;toolbar&lt;/code&gt; к &lt;code&gt;debugger&lt;/code&gt; , если такая цепочка есть, иначе &lt;code&gt;false&lt;/code&gt; . Цепочка вызовов представлена ​​списком модулей, &lt;code&gt;toolbar&lt;/code&gt; является первым элементом, а &lt;code&gt;debugger&lt;/code&gt; - последним элементом.</target>
        </trans-unit>
        <trans-unit id="c963de72e2f1d6300c000423f7ebb85156dc2f81" translate="yes" xml:space="preserve">
          <source>A challenge is a 32-bit integer in big-endian order. Below the function &lt;code&gt;gen_challenge()&lt;/code&gt; returns a random 32-bit integer used as a challenge.</source>
          <target state="translated">Задача - это 32-битное целое число с прямым порядком байтов. Ниже функция &lt;code&gt;gen_challenge()&lt;/code&gt; возвращает случайное 32-битное целое число, используемое как вызов.</target>
        </trans-unit>
        <trans-unit id="39b14f10c5b55097c8101f85c3f9aa51d49c3b22" translate="yes" xml:space="preserve">
          <source>A change in time offset can be observed at slightly different points in time by different processes.</source>
          <target state="translated">Изменение временного смещения может наблюдаться в несколько разных точках времени различными процессами.</target>
        </trans-unit>
        <trans-unit id="542fbe84d9ce4598795bc891dcdfd8b000e68f19" translate="yes" xml:space="preserve">
          <source>A character class</source>
          <target state="translated">Класс характера</target>
        </trans-unit>
        <trans-unit id="61e7e6e3a9874a828dada509dcc75ed9b8baa957" translate="yes" xml:space="preserve">
          <source>A character class matches a single character in the subject. In a UTF mode, the character can be more than one data unit long. A matched character must be in the set of characters defined by the class, unless the first character in the class definition is a circumflex, in which case the subject character must not be in the set defined by the class. If a circumflex is required as a member of the class, ensure that it is not the first character, or escape it with a backslash.</source>
          <target state="translated">Класс персонажей соответствует одному персонажу в теме.В режиме UTF длина символа может превышать одну единицу данных.Соответствующий символ должен быть в наборе символов,определенном классом,если только первый символ в определении класса не является циркумфлексом,в этом случае символ субъекта не должен быть в наборе,определенном классом.Если циркумфлекс требуется в качестве члена класса,убедитесь,что он не является первым персонажем,или выйдите из него с обратным слешем.</target>
        </trans-unit>
        <trans-unit id="9c9c4d2679cf888b556f5d6ffced7246bbf40eb2" translate="yes" xml:space="preserve">
          <source>A character preceded by &lt;code&gt;\&lt;/code&gt; loses its special meaning. Note that &lt;code&gt;\&lt;/code&gt; must be written as &lt;code&gt;\\&lt;/code&gt; in a string literal. For example, &quot;\\?*&quot; will match any filename starting with &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">Символ, которому предшествует &lt;code&gt;\&lt;/code&gt; , теряет свое особое значение. Обратите внимание, что &lt;code&gt;\&lt;/code&gt; должен быть записан как &lt;code&gt;\\&lt;/code&gt; в строковом литерале. Например, &amp;laquo;\\? *&amp;raquo; Будет соответствовать любому имени файла, начинающемуся с &lt;code&gt;?&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="142cc4bd716c781df84ea694767d7514165b6796" translate="yes" xml:space="preserve">
          <source>A character with property &lt;strong&gt;xx&lt;/strong&gt;</source>
          <target state="translated">Персонаж со свойством &lt;strong&gt;xx&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf738d3d1defd49ac7c9b392cd81c1e47fcf59d0" translate="yes" xml:space="preserve">
          <source>A character without property &lt;strong&gt;xx&lt;/strong&gt;</source>
          <target state="translated">Персонаж без свойства &lt;strong&gt;xx&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377286b10e032ac7b156b224cfe02d4aa3b5ac8" translate="yes" xml:space="preserve">
          <source>A checkpoint is a consistent view of the system. A checkpoint can be activated on a set of tables. This checkpoint can then be traversed and presents a view of the system as it existed at the time when the checkpoint was activated, even if the tables are being or have been manipulated.</source>
          <target state="translated">Контрольно-пропускной пункт-это согласованный взгляд на систему.Контрольная точка может быть активирована по набору таблиц.Этот контрольно-пропускной пункт может быть пройден и представляет собой представление системы в том виде,в котором она существовала на момент активации контрольно-пропускного пункта,даже в том случае,если с таблицами производились или производились манипуляции.</target>
        </trans-unit>
        <trans-unit id="edd44bafd2855e97c83bfe1495556b1997dac899" translate="yes" xml:space="preserve">
          <source>A checkpoint is a transaction consistent state that spans over one or more tables. When a checkpoint is activated, the system remembers the current content of the set of tables. The checkpoint retains a transaction consistent state of the tables, allowing the tables to be read and updated while the checkpoint is active. A checkpoint is typically used to back up tables to external media, but they are also used internally in &lt;code&gt;Mnesia&lt;/code&gt; for other purposes. Each checkpoint is independent and a table can be involved in several checkpoints simultaneously.</source>
          <target state="translated">Контрольная точка - это согласованное состояние транзакции, охватывающее одну или несколько таблиц. Когда контрольная точка активируется, система запоминает текущее содержимое набора таблиц. Контрольная точка сохраняет согласованное с транзакцией состояние таблиц, позволяя читать и обновлять таблицы, пока контрольная точка активна. Контрольная точка обычно используется для резервного копирования таблиц на внешний носитель, но они также используются внутри &lt;code&gt;Mnesia&lt;/code&gt; для других целей. Каждая контрольная точка независима, и таблица может быть задействована в нескольких контрольных точках одновременно.</target>
        </trans-unit>
        <trans-unit id="7af90dbef0975afb7b45bd12517b2d0b310aad09" translate="yes" xml:space="preserve">
          <source>A checkpoint with the name &lt;code&gt;Checkpoint&lt;/code&gt; is activated and the current node is involved in the checkpoint. Checkpoints can be activated explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint/1&lt;/a&gt;&lt;/code&gt; or implicitly at backup, when adding table replicas, at internal transfer of data between nodes, and so on. By default this event is ignored.</source>
          <target state="translated">Контрольная точка с именем &lt;code&gt;Checkpoint&lt;/code&gt; активируется, и текущий узел участвует в контрольной точке. Контрольные точки могут быть активированы явно с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint/1&lt;/a&gt;&lt;/code&gt; или неявно при резервном копировании, при добавлении реплик таблиц, при внутренней передаче данных между узлами и т. Д. По умолчанию это событие игнорируется.</target>
        </trans-unit>
        <trans-unit id="ce168e38a6f2a63614deb75483a5c4e60dab573e" translate="yes" xml:space="preserve">
          <source>A checkpoint with the name &lt;code&gt;Checkpoint&lt;/code&gt; is deactivated and the current node is involved in the checkpoint. Checkpoints can be deactivated explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate/1&lt;/a&gt;&lt;/code&gt; or implicitly when the last replica of a table (involved in the checkpoint) becomes unavailable, for example, at node-down. By default this event is ignored.</source>
          <target state="translated">Контрольная точка с именем &lt;code&gt;Checkpoint&lt;/code&gt; деактивирована, и текущий узел участвует в контрольной точке. Контрольные точки можно деактивировать явно с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate/1&lt;/a&gt;&lt;/code&gt; или неявно, когда последняя реплика таблицы (задействованная в контрольной точке) становится недоступной, например, при отключении узла. По умолчанию это событие игнорируется.</target>
        </trans-unit>
        <trans-unit id="757093a3c3c4440d97791337c35337b6b5b5acf3" translate="yes" xml:space="preserve">
          <source>A child under a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can be terminated with the following:</source>
          <target state="translated">Дочерний элемент супервизора &lt;code&gt;simple_one_for_one&lt;/code&gt; может быть завершен следующим образом:</target>
        </trans-unit>
        <trans-unit id="b0b7cb7b3462b17e43bbfe35864d2ca8d80d92e7" translate="yes" xml:space="preserve">
          <source>A circumflex can conveniently be used with the uppercase character types to specify a more restricted set of characters than the matching lowercase type. For example, class [^\W_] matches any letter or digit, but not underscore, while [\w] includes underscore. A positive character class is to be read as &quot;something OR something OR ...&quot; and a negative class as &quot;NOT something AND NOT something AND NOT ...&quot;.</source>
          <target state="translated">Циркумфлекс можно удобно использовать с заглавными типами символов для указания более ограниченного набора символов,чем соответствующий строчный тип.Например,класс [^\W_]соответствует любой букве или цифре,но не символу подчеркивания,в то время как [\w]включает символ подчеркивания.Класс положительных символов должен быть прочитан как &quot;что-то ИЛИ что-то ИЛИ ...&quot;,а класс отрицательных-как &quot;НЕ что-то ИЛИ НЕ что-то ИЛИ ...&quot;.</target>
        </trans-unit>
        <trans-unit id="0a95d789d7844b6626f4da863b5eea766e7744a0" translate="yes" xml:space="preserve">
          <source>A clause &lt;strong&gt;body&lt;/strong&gt; consists of a sequence of expressions separated by comma (,):</source>
          <target state="translated">&lt;strong&gt;Тело&lt;/strong&gt; предложения состоит из последовательности выражений, разделенных запятыми (,):</target>
        </trans-unit>
        <trans-unit id="19e13c276c19b62374e61b0b7fc25118ed9d5cf8" translate="yes" xml:space="preserve">
          <source>A clause &lt;strong&gt;head&lt;/strong&gt; consists of the function name, an argument list, and an optional guard sequence beginning with the keyword &lt;code&gt;when&lt;/code&gt;:</source>
          <target state="translated">Оговорка &lt;strong&gt;головка&lt;/strong&gt; состоит из имени функции, списка аргументов, и необязательного начала последовательности караула с ключевым словом &lt;code&gt;when&lt;/code&gt; это :</target>
        </trans-unit>
        <trans-unit id="58a6114240a04a860a349454adf52142f50d9abd" translate="yes" xml:space="preserve">
          <source>A clause C is one of the following:</source>
          <target state="translated">Пункт С является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="d1f7a0040d46c009ca43441ed2b3e8cecbe10566" translate="yes" xml:space="preserve">
          <source>A client application that is dependent on the SNMP manager will use this function in order to be notified of when the manager has started. There are two situations when this is useful:</source>
          <target state="translated">Клиентское приложение,зависящее от SNMP-менеджера,будет использовать эту функцию,чтобы получить уведомление о запуске менеджера.Есть две ситуации,когда это полезно:</target>
        </trans-unit>
        <trans-unit id="92b63c3639a0d3be7790653a4cf98a0c37efe2e2" translate="yes" xml:space="preserve">
          <source>A closing brace on its own is not a special character. If the second number is omitted, but the comma is present, there is no upper limit. If the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus, the following matches at least three successive vowels, but can match many more:</source>
          <target state="translated">Закрывающаяся скоба сама по себе не является особым характером.Если второе число опущено,но запятая присутствует,то верхнего предела нет.Если опущены и второе число,и запятая,квантификатор указывает точное количество требуемых совпадений.Таким образом,следующие совпадают как минимум с тремя последовательными гласными,но могут совпадать и с гораздо большим количеством:</target>
        </trans-unit>
        <trans-unit id="5df59142009d0a2f0174628ac8c696397e059c32" translate="yes" xml:space="preserve">
          <source>A collection of annotations.</source>
          <target state="translated">Сборник аннотаций.</target>
        </trans-unit>
        <trans-unit id="03e8d201bb4d1ea3a3e042cc7f432a7b21d3da31" translate="yes" xml:space="preserve">
          <source>A collection of list processing functions can be found in the &lt;code&gt;lists&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">Набор функций обработки списков можно найти на странице руководства &lt;code&gt;lists&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="0cdd7d34c0f5f7115114bd571785b83e151e658b" translate="yes" xml:space="preserve">
          <source>A collection of maps processing functions can be found in &lt;code&gt;maps&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">Набор функций обработки карт можно найти на странице руководства по &lt;code&gt;maps&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="c3e3cce83083c2f4eda9342971b0fd43678fa41c" translate="yes" xml:space="preserve">
          <source>A collection of mathematical functions that return floats. Arguments are numbers.</source>
          <target state="translated">Коллекция математических функций,которые возвращают поплавки.Аргументы-это числа.</target>
        </trans-unit>
        <trans-unit id="605e87ed4414816e773ab8b3750564d7de25784e" translate="yes" xml:space="preserve">
          <source>A collection of open disk logs with the same name running on different nodes is said to be a &lt;strong&gt;distributed disk log&lt;/strong&gt; if requests made to any of the logs are automatically made to the other logs as well. The members of such a collection are called individual distributed disk logs, or just distributed disk logs if there is no risk of confusion. There is no order between the members of such a collection. For example, logged terms are not necessarily written to the node where the request was made before written to the other nodes. However, a few functions do not make requests to all members of distributed disk logs, namely &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#chunk_step-3&quot;&gt;chunk_step/3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#lclose-1&quot;&gt;lclose/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Набор журналов открытых дисков с одинаковыми именами, запущенных на разных узлах, называется &lt;strong&gt;распределенным журналом диска,&lt;/strong&gt; если запросы, сделанные в любой из журналов, автоматически отправляются и в другие журналы. Члены такой коллекции называются индивидуальными распределенными дисковыми журналами или просто распределенными дисковыми журналами, если нет риска путаницы. Между членами такой коллекции нет порядка. Например, зарегистрированные термины не обязательно записываются в узел, на котором был сделан запрос, до записи в другие узлы. Однако некоторые функции не делают запросы ко всем членам распределенных дисковых журналов, а именно &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#chunk_step-3&quot;&gt;chunk_step/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#lclose-1&quot;&gt;lclose/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c28e602c295299b55b61e9e0432393728a24bb97" translate="yes" xml:space="preserve">
          <source>A collection of test cases, generally with a specific, common target for testing, such as a single function, module, or subsystem. A test suite may also be recursively composed by smaller test suites.</source>
          <target state="translated">Коллекция тестовых случаев,как правило,с конкретной,общей целью для тестирования,например,с одной функцией,модулем или подсистемой.Набор тестов также может быть рекурсивно составлен небольшими наборами тестов.</target>
        </trans-unit>
        <trans-unit id="1465092184b8e8294117483f6254c408114fee45" translate="yes" xml:space="preserve">
          <source>A command file for restarting a service looks as follows:</source>
          <target state="translated">Командный файл для перезапуска службы выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="9252c2a7f2a4db9009910e3b44326441724181d8" translate="yes" xml:space="preserve">
          <source>A common interoperability situation is when you want to incorporate a piece of code, solving a complex problem, in your Erlang program. Suppose for example, that you have the following C functions that you would like to call from Erlang:</source>
          <target state="translated">Обычная ситуация интероперабельности-это когда вы хотите включить кусок кода,решающего сложную проблему,в свою программу на Erlang.Предположим,например,что у вас есть следующие функции C,которые вы хотели бы вызвать из Erlang:</target>
        </trans-unit>
        <trans-unit id="b06198c1c89c922d52dc5340ce3b2b05bb39280d" translate="yes" xml:space="preserve">
          <source>A common method of identifying encoding in text files is to put a Byte Order Mark (BOM) first in the file. The BOM is the code point 16#FEFF encoded in the same way as the remaining file. If such a file is to be read, the first few bytes (depending on encoding) are not part of the text. This code outlines how to open a file that is believed to have a BOM, and sets the files encoding and position for further sequential reading (preferably using the &lt;code&gt;io&lt;/code&gt; module).</source>
          <target state="translated">Распространенным методом определения кодировки в текстовых файлах является размещение в файле метки порядка байтов (BOM) первой. Спецификация - это кодовая точка 16 # FEFF, закодированная так же, как и оставшийся файл. Если такой файл должен быть прочитан, первые несколько байтов (в зависимости от кодировки) не являются частью текста. Этот код описывает, как открыть файл, который, как предполагается, имеет спецификацию, и устанавливает кодировку и положение файлов для дальнейшего последовательного чтения (предпочтительно с использованием модуля &lt;code&gt;io&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5647ae6e936ad55169d59c790e8343814c809ae6" translate="yes" xml:space="preserve">
          <source>A common situation in more complex systems is that the data in a table is distributed. Different table rows are implemented in different places. Some SNMP tool-kits dedicate an SNMP sub-agent for each part of the table and load the corresponding MIB into all sub-agents. The Master Agent is responsible for presenting the distributed table as a single table to the manager. The toolkit supplied uses a different method.</source>
          <target state="translated">Распространенной ситуацией в более сложных системах является распределение данных в таблице.В разных местах реализуются разные строки таблицы.Некоторые наборы инструментов SNMP выделяют субагент SNMP для каждой части таблицы и загружают соответствующие MIB во все субагенты.Главный агент отвечает за представление распределенной таблицы в виде единой таблицы менеджеру.Инструментарий,поставляемый в комплекте,использует другой метод.</target>
        </trans-unit>
        <trans-unit id="c7eeae65f0479a03e33632169a4331231e0f176a" translate="yes" xml:space="preserve">
          <source>A common way to send a zero-terminated string to a port is the following:</source>
          <target state="translated">Общий способ отправки нулевой строки в порт следующий:</target>
        </trans-unit>
        <trans-unit id="a45a7f5aa5a20b6c21f0a78bd8f6845034a8417e" translate="yes" xml:space="preserve">
          <source>A compile-time error, for example a syntax error, does not cause much trouble as it is caught by the compiler.</source>
          <target state="translated">Ошибка компиляции,например,синтаксическая ошибка,не вызывает особых проблем,так как попадается компилятору.</target>
        </trans-unit>
        <trans-unit id="b4602d9b41e423bca7841f2df941cffa70742972" translate="yes" xml:space="preserve">
          <source>A compiled MIB for SNMP. It generates a &lt;code&gt;.hrl&lt;/code&gt; file.</source>
          <target state="translated">Скомпилированный MIB для SNMP. Он генерирует файл &lt;code&gt;.hrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5f98caa0ae9cf0f1bdae4ba51cfa598afa6c9ca" translate="yes" xml:space="preserve">
          <source>A compiled match specification.</source>
          <target state="translated">Скомпилированная спецификация соответствия.</target>
        </trans-unit>
        <trans-unit id="9d939a33ffd17f021de49031e6a1518334f87b64" translate="yes" xml:space="preserve">
          <source>A compiled regular expression</source>
          <target state="translated">Скомпилированное регулярное выражение</target>
        </trans-unit>
        <trans-unit id="f8e9759655ec875d9026034a3b0994a59f1ef864" translate="yes" xml:space="preserve">
          <source>A compiled regular expression and the options for running it</source>
          <target state="translated">Скомпилированное регулярное выражение и опции для его выполнения</target>
        </trans-unit>
        <trans-unit id="d4c9209a41f5a084f05f289c557f295094459659" translate="yes" xml:space="preserve">
          <source>A completly different storage could be interfaced by writing call-back modules using the behaviours &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;. A callback module is installed with the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; to the client and/or the daemon.</source>
          <target state="translated">Совершенно другое хранилище можно было бы &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; помощью написания модулей обратного вызова с использованием поведения ssh_client_key_api и / или &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; . Модуль обратного вызова устанавливается с опцией &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; для клиента и / или демона.</target>
        </trans-unit>
        <trans-unit id="952ff2aeda160eb34af5c137f617385ffdf99591" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; does not exist.</source>
          <target state="translated">Компонента &lt;code&gt;Dir&lt;/code&gt; не существует.</target>
        </trans-unit>
        <trans-unit id="246870fe4fc14eed479b16bbb7b62bf284297f4b" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned instead.</source>
          <target state="translated">Компонент &lt;code&gt;Dir&lt;/code&gt; не является каталогом. На некоторых платформах вместо этого возвращается &lt;code&gt;enoent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="402962cd392724e5760c55baa6887c10aa95a217" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned.</source>
          <target state="translated">Компонент &lt;code&gt;Dir&lt;/code&gt; не является каталогом. На некоторых платформах возвращается &lt;code&gt;enoent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60b48fcc9f23ddcda04bff0fa0292b7348897642" translate="yes" xml:space="preserve">
          <source>A component of the filename does not exist.</source>
          <target state="translated">Компонента имени файла не существует.</target>
        </trans-unit>
        <trans-unit id="135c8c2d97ee75d613c98cc3cf13f66a7bede390" translate="yes" xml:space="preserve">
          <source>A component of the filename is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned instead.</source>
          <target state="translated">Компонент имени файла не является каталогом. На некоторых платформах вместо этого возвращается &lt;code&gt;enoent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="821747f02cfeb9e5714e2b19ea3b50b461a99dfe" translate="yes" xml:space="preserve">
          <source>A compression level can be specified by giving option &lt;code&gt;{compressed, Level}&lt;/code&gt;. &lt;code&gt;Level&lt;/code&gt; is an integer with range 0..9, where:</source>
          <target state="translated">Уровень сжатия можно указать, задав параметр &lt;code&gt;{compressed, Level}&lt;/code&gt; . &lt;code&gt;Level&lt;/code&gt; - целое число в диапазоне 0..9, где:</target>
        </trans-unit>
        <trans-unit id="d0e574bf3fa3da4f1323956974511982101a1711" translate="yes" xml:space="preserve">
          <source>A concept of table fragmentation has been introduced to cope with large tables. The idea is to split a table into several manageable fragments. Each fragment is implemented as a first class &lt;code&gt;Mnesia&lt;/code&gt; table and can be replicated, have indexes, and so on, as any other table. But the tables cannot have &lt;code&gt;local_content&lt;/code&gt; or have the &lt;code&gt;snmp&lt;/code&gt; connection activated.</source>
          <target state="translated">Для работы с большими таблицами была введена концепция фрагментации таблиц. Идея состоит в том, чтобы разбить таблицу на несколько управляемых фрагментов. Каждый фрагмент реализован как таблица &lt;code&gt;Mnesia&lt;/code&gt; первого класса и может быть реплицирован, иметь индексы и так далее, как любую другую таблицу. Но в таблицах не может быть &lt;code&gt;local_content&lt;/code&gt; или активировано соединение &lt;code&gt;snmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e49ca9c3184442cd50035d353e0e9f2682e7441b" translate="yes" xml:space="preserve">
          <source>A conditional breakpoint calling &lt;code&gt;c_test:c_break/1&lt;/code&gt; is added at line 6 in module &lt;code&gt;fact&lt;/code&gt;. Each time the breakpoint is reached, the function is called. When &lt;code&gt;N&lt;/code&gt; is equal to 3, the function returns &lt;code&gt;true&lt;/code&gt; and the process stops.</source>
          <target state="translated">Условная точка останова, вызывающая &lt;code&gt;c_test:c_break/1&lt;/code&gt; , добавляется в строку 6 в модуле &lt;code&gt;fact&lt;/code&gt; . Каждый раз, когда достигается точка останова, вызывается функция. Когда &lt;code&gt;N&lt;/code&gt; равно 3, функция возвращает &lt;code&gt;true&lt;/code&gt; и процесс останавливается.</target>
        </trans-unit>
        <trans-unit id="420493b84dd5c17e043c6b4089d0760ab787da6f" translate="yes" xml:space="preserve">
          <source>A conditional breakpoint is created at a certain line in the module, but a process reaching the breakpoint stops only if a specified condition is true.</source>
          <target state="translated">Условная точка останова создается на определенной строке в модуле,но процесс,достигающий точки останова,останавливается только в том случае,если указанное условие истинно.</target>
        </trans-unit>
        <trans-unit id="f2032c66ce1d764483fb75f184dda9191dfa8a90" translate="yes" xml:space="preserve">
          <source>A configuration example:</source>
          <target state="translated">Пример конфигурации:</target>
        </trans-unit>
        <trans-unit id="fca2493f0bfcfddaa7857841304efa4715628d65" translate="yes" xml:space="preserve">
          <source>A configuration file can contain any number of elements of the type:</source>
          <target state="translated">Конфигурационный файл может содержать любое количество элементов данного типа:</target>
        </trans-unit>
        <trans-unit id="78ca415df4713a5dc750b7b27876e4c151d1fefd" translate="yes" xml:space="preserve">
          <source>A configuration file for using the FTP client to access files on a remote host can look as follows:</source>
          <target state="translated">Файл конфигурации для использования FTP-клиента для доступа к файлам на удаленном хосте может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="1c3a7bd9523a05d54af1d3003cdb3950dec94457" translate="yes" xml:space="preserve">
          <source>A configuration file is created or extended with &lt;code&gt;&lt;a href=&quot;ttb#write_config-2&quot;&gt;ttb:write_config/2,3&lt;/a&gt;&lt;/code&gt;. Configuration files are binary files and can therefore only be read and written with functions provided by &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">Файл конфигурации создается или расширяется с помощью &lt;code&gt;&lt;a href=&quot;ttb#write_config-2&quot;&gt;ttb:write_config/2,3&lt;/a&gt;&lt;/code&gt; . Файлы конфигурации представляют собой двоичные файлы, поэтому их можно читать и записывать только с помощью функций, предоставляемых &lt;code&gt;ttb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="671d2cc5723fde16b3b1db23f40f7f8a98edafae" translate="yes" xml:space="preserve">
          <source>A configuration is created in the following way:</source>
          <target state="translated">Конфигурация создается следующим образом:</target>
        </trans-unit>
        <trans-unit id="c8ccb5edfb531730a93bb64572c6648008c39609" translate="yes" xml:space="preserve">
          <source>A configuration key which exists in a configuration file</source>
          <target state="translated">Ключ конфигурации,который существует в файле конфигурации</target>
        </trans-unit>
        <trans-unit id="390f275edabaf65d38db27499e0d752ebcf76daa" translate="yes" xml:space="preserve">
          <source>A confirmation that the test has started and information about how many test cases are executed in total.</source>
          <target state="translated">Подтверждение того,что тест начался,и информация о том,сколько всего тестовых случаев выполнено.</target>
        </trans-unit>
        <trans-unit id="16cfc1e11c18feed4f6e01ecf44d3ed97a53d652" translate="yes" xml:space="preserve">
          <source>A confirmation when the test run is complete.</source>
          <target state="translated">Подтверждение по окончании пробного прогона.</target>
        </trans-unit>
        <trans-unit id="a8db6e97290afb25f8da08685474a76274ab963c" translate="yes" xml:space="preserve">
          <source>A connected socket (or accepted socket) in &lt;code&gt;command&lt;/code&gt; mode mentioned earlier.</source>
          <target state="translated">Подключенный сокет (или принятый сокет) в &lt;code&gt;command&lt;/code&gt; режиме, упомянутый ранее.</target>
        </trans-unit>
        <trans-unit id="b989a34ee0dda9766c669da2f15eb2969efbeba6" translate="yes" xml:space="preserve">
          <source>A connected socket returned from &lt;code&gt;&lt;a href=&quot;gen_tcp#accept-1&quot;&gt;gen_tcp:accept/1&lt;/a&gt;&lt;/code&gt; inherits the &lt;code&gt;show_econnreset&lt;/code&gt; setting from the listening socket.</source>
          <target state="translated">Подключенный сокет, возвращенный из &lt;code&gt;&lt;a href=&quot;gen_tcp#accept-1&quot;&gt;gen_tcp:accept/1&lt;/a&gt;&lt;/code&gt; , наследует параметр &lt;code&gt;show_econnreset&lt;/code&gt; из прослушивающего сокета.</target>
        </trans-unit>
        <trans-unit id="16798b95a6178eace7c7e27d49d5ae81b52eea7c" translate="yes" xml:space="preserve">
          <source>A connecting transport is attempting to establish/reestablish a transport connection with a peer following &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry.</source>
          <target state="translated">Подключающийся транспорт пытается установить / восстановить транспортное соединение с одноранговым &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; после истечения срока действия connect_timer или &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2de4335ce6ca183161a25e425035c54728e74d6f" translate="yes" xml:space="preserve">
          <source>A connection can be associated with a target name and/or a handle. If &lt;code&gt;Connection&lt;/code&gt; has no associated target name, it can only be closed with the handle value (see &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:open/4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Соединение может быть связано с целевым именем и / или дескриптором. Если &lt;code&gt;Connection&lt;/code&gt; не имеет связанного имени цели, его можно закрыть только с помощью значения дескриптора (см. &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:open/4&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84ef649954a73cf1383ab5bc1d54652a8c9eadd0" translate="yes" xml:space="preserve">
          <source>A connection is closed by simply closing the socket. For information about how to close the socket gracefully (when there are outgoing packets before close), see the relevant system documentation.</source>
          <target state="translated">Соединение закрывается простым закрытием розетки.Информацию о том,как изящно закрыть розетку (при наличии исходящих пакетов до закрытия),см.в соответствующей системной документации.</target>
        </trans-unit>
        <trans-unit id="17e6c50bbb1f711f9fede53cf0df05d82936b396" translate="yes" xml:space="preserve">
          <source>A connection may be established in several ways:</source>
          <target state="translated">Соединение может быть установлено несколькими способами:</target>
        </trans-unit>
        <trans-unit id="a37d94bb6ad00988b64d647642ebc7cb8c0abb3c" translate="yes" xml:space="preserve">
          <source>A connection to the node is already active, which either means that node &lt;code&gt;A&lt;/code&gt; is confused or that the TCP connection breakdown of a previous node with this name has not yet reached node &lt;code&gt;B&lt;/code&gt;. See step 3B below.</source>
          <target state="translated">Подключение к узлу уже активно, который либо означает , что узел запутан или что пробые соединения TCP предыдущего узла с этим именем еще не достиг узел &lt;code&gt;B&lt;/code&gt; . См. Шаг 3B ниже. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7ac923ae2612ff651e35e68a8cf52b6bfffc763" translate="yes" xml:space="preserve">
          <source>A consequence of the rules for importing variables into a list comprehensions is that certain pattern matching operations must be moved into the filters and cannot be written directly in the generators.</source>
          <target state="translated">Следствием правил импорта переменных в понимание списка является то,что определенные операции по совпадению шаблонов должны быть перенесены в фильтры и не могут быть записаны непосредственно в генераторы.</target>
        </trans-unit>
        <trans-unit id="13bd8527f949ed0966879c517d0b7fc761771b34" translate="yes" xml:space="preserve">
          <source>A constant value &lt;code&gt;H&lt;/code&gt; for the topmost &lt;code&gt;32-N&lt;/code&gt; bits of of 32-bit End-to-End and Hop-by-Hop Identifiers generated by the service, either explicitly or as a return value of a function to be evaluated at &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;. In particular, an identifier &lt;code&gt;Id&lt;/code&gt; is mapped to a new identifier as follows.</source>
          <target state="translated">Постоянное значение &lt;code&gt;H&lt;/code&gt; для самых верхних &lt;code&gt;32-N&lt;/code&gt; битов 32-битных идентификаторов End-to-End и Hop-by-Hop, сгенерированных службой, либо явно, либо как возвращаемое значение функции, которая должна быть оценена в &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; , В частности, идентификатор &lt;code&gt;Id&lt;/code&gt; отображается на новый идентификатор следующим образом.</target>
        </trans-unit>
        <trans-unit id="18d886af02e0496aa48e2b5d6a6f92d0202ac37e" translate="yes" xml:space="preserve">
          <source>A container for incoming and outgoing Diameter messages. Fields have the following types.</source>
          <target state="translated">Контейнер для входящих и исходящих сообщений диаметра.Поля имеют следующие типы.</target>
        </trans-unit>
        <trans-unit id="b1dd9fe6f6d7543e1cad9aacae9f7f895fe2c259" translate="yes" xml:space="preserve">
          <source>A context is a collection of management information accessible by an SNMP entity. An instance of a management object may exist in more than one context. An SNMP entity potentially has access to many contexts.</source>
          <target state="translated">Контекст-это совокупность управленческой информации,доступной для SNMP-структуры.Экземпляр объекта управления может существовать более чем в одном контексте.Объект SNMP потенциально имеет доступ ко многим контекстам.</target>
        </trans-unit>
        <trans-unit id="734dc478d1f1465863bbde8232d6c6d77c880f57" translate="yes" xml:space="preserve">
          <source>A continuation as returned by &lt;code&gt;&lt;a href=&quot;#fread-3&quot;&gt;fread/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Продолжение, возвращенное &lt;code&gt;&lt;a href=&quot;#fread-3&quot;&gt;fread/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6381830ad9a3607ffa3055f5bcf56d4da1d20cb" translate="yes" xml:space="preserve">
          <source>A convenient way to specify arguments to Erlang is to use environment variable &lt;code&gt;ERL_FLAGS&lt;/code&gt;. All the flags needed to use the SSL/TLS distribution can be specified in that variable and are then interpreted as command-line arguments for all subsequent invocations of Erlang.</source>
          <target state="translated">Удобный способ указать аргументы для Erlang - использовать переменную среды &lt;code&gt;ERL_FLAGS&lt;/code&gt; . Все флаги, необходимые для использования распространения SSL / TLS, могут быть указаны в этой переменной и затем интерпретированы как аргументы командной строки для всех последующих вызовов Erlang.</target>
        </trans-unit>
        <trans-unit id="1ca49f6e451d0d84b06716dddb10383b5981e929" translate="yes" xml:space="preserve">
          <source>A correctly encoded map cannot have duplicate keys.</source>
          <target state="translated">Правильно закодированная карта не может иметь дубликаты ключей.</target>
        </trans-unit>
        <trans-unit id="d121637a1d8220cf7197c40025c0f7398d773f8f" translate="yes" xml:space="preserve">
          <source>A cross configuration file can be passed to &lt;code&gt;otp_build configure&lt;/code&gt; using the &lt;code&gt;--xcomp-conf&lt;/code&gt; command line argument. Note that &lt;code&gt;configure&lt;/code&gt; does not accept this command line argument. When using the &lt;code&gt;configure&lt;/code&gt; script directly, pass the configuration variables as arguments to &lt;code&gt;configure&lt;/code&gt; using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax. Variables can also be passed as environment variables to &lt;code&gt;configure&lt;/code&gt;. However, if you pass the configuration in the environment, make sure to unset all of these environment variables before invoking &lt;code&gt;make&lt;/code&gt;; otherwise, the environment variables might set make variables in some applications, or parts of some applications, and you may end up with an erroneously configured build.</source>
          <target state="translated">Файл кросс-конфигурации можно передать в &lt;code&gt;otp_build configure&lt;/code&gt; с помощью &lt;code&gt;--xcomp-conf&lt;/code&gt; командной строки --xcomp-conf . Обратите внимание, что &lt;code&gt;configure&lt;/code&gt; не принимает этот аргумент командной строки. При прямом использовании сценария &lt;code&gt;configure&lt;/code&gt; передайте переменные конфигурации в качестве аргументов для &lt;code&gt;configure&lt;/code&gt; с использованием синтаксиса &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; . Переменные также можно передавать как переменные среды для &lt;code&gt;configure&lt;/code&gt; . Однако, если вы передаете конфигурацию в среде, обязательно отключите все эти переменные среды перед вызовом &lt;code&gt;make&lt;/code&gt; .; в противном случае переменные среды могут устанавливать переменные make в некоторых приложениях или частях некоторых приложений, и вы можете получить неправильно настроенную сборку.</target>
        </trans-unit>
        <trans-unit id="d1583ce679c6d2d53d418e62301c75ea7be08c45" translate="yes" xml:space="preserve">
          <source>A current restriction, which currently results in a warning (not an error) by the compiler, is that the domains of the argument types cannot overlap. For example, the following specification results in a warning:</source>
          <target state="translated">Текущим ограничением,которое в настоящее время приводит к предупреждению (а не к ошибке)компилятора,является то,что домены типов аргументов не могут перекрываться.Например,следующая спецификация приводит к предупреждению:</target>
        </trans-unit>
        <trans-unit id="88d09c4bad655176f525dc30f98c229dc5d52beb" translate="yes" xml:space="preserve">
          <source>A customized prompt function is stated as a tuple &lt;code&gt;{Mod,&amp;nbsp;Func}&lt;/code&gt;. The function is called as &lt;code&gt;Mod:Func(L)&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; is a list of key-value pairs created by the shell. Currently there is only one pair: &lt;code&gt;{history, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the current command number. The function is to return a list of characters or an atom. This constraint is because of the Erlang I/O protocol. Unicode characters beyond code point 255 are allowed in the list and the atom. Notice that in restricted mode the call &lt;code&gt;Mod:Func(L)&lt;/code&gt; must be allowed or the default shell prompt function is called.</source>
          <target state="translated">Настроенная функция подсказки указывается как кортеж &lt;code&gt;{Mod,&amp;nbsp;Func}&lt;/code&gt; . Функция называется &lt;code&gt;Mod:Func(L)&lt;/code&gt; , где &lt;code&gt;L&lt;/code&gt; - это список пар ключ-значение, созданный оболочкой. На данный момент существует только одна пара: &lt;code&gt;{history, N}&lt;/code&gt; , где &lt;code&gt;N&lt;/code&gt; - номер текущей команды. Функция состоит в том, чтобы вернуть список символов или атом. Это ограничение связано с протоколом ввода-вывода Erlang. В списке и в атоме разрешены символы Юникода после кодовой точки 255. Обратите внимание, что в ограниченном режиме вызов &lt;code&gt;Mod:Func(L)&lt;/code&gt; должен быть разрешен или вызывается функция приглашения оболочки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8c9abdbda17aa95d8e0108392fe6c0db5b6c523d" translate="yes" xml:space="preserve">
          <source>A database schema must be initiated, using the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Схема базы данных должна быть инициирована с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e3317b1ebd7518e2b7a6cb468c8efab693a0e3" translate="yes" xml:space="preserve">
          <source>A decimal integer is expected.</source>
          <target state="translated">Ожидается десятичное целое число.</target>
        </trans-unit>
        <trans-unit id="c1c59bae41554e9820138c5a12e4fa4d04d13249" translate="yes" xml:space="preserve">
          <source>A default set of socket &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;options&lt;/a&gt;&lt;/code&gt; is used. In particular, the socket is opened in &lt;code&gt;&lt;a href=&quot;#option-binary&quot;&gt;binary&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode, with SockType &lt;code&gt;seqpacket&lt;/code&gt;, and with reasonably large &lt;code&gt;&lt;a href=&quot;inet#option-sndbuf&quot;&gt;kernel&lt;/a&gt;&lt;/code&gt; and driver &lt;code&gt;&lt;a href=&quot;inet#option-buffer&quot;&gt;buffers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используется набор &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;options&lt;/a&gt;&lt;/code&gt; сокета по умолчанию . В частности, сокет открывается в &lt;code&gt;&lt;a href=&quot;#option-binary&quot;&gt;binary&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; режимах с использованием seqpacket &lt;code&gt;seqpacket&lt;/code&gt; и с достаточно большими &lt;code&gt;&lt;a href=&quot;inet#option-buffer&quot;&gt;buffers&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;inet#option-sndbuf&quot;&gt;kernel&lt;/a&gt;&lt;/code&gt; и драйверов .</target>
        </trans-unit>
        <trans-unit id="0a0192ce6ab3cadd73202466e0233a173404e218" translate="yes" xml:space="preserve">
          <source>A definition has normally a status field. When the status field has the value deprecated, then the MIB-compiler will ignore this definition. With the MIB-compiler option &lt;code&gt;{deprecated,true}&lt;/code&gt; the MIB-compiler does not ignore the deprecated definitions.</source>
          <target state="translated">Определение обычно имеет поле статуса. Когда в поле статуса указано значение &amp;laquo;deprecated&amp;raquo;, компилятор MIB проигнорирует это определение. С параметром компилятора MIB &lt;code&gt;{deprecated,true}&lt;/code&gt; компилятор MIB не игнорирует устаревшие определения.</target>
        </trans-unit>
        <trans-unit id="08538f938c9e3f97e154e5c1ebc56ab69364db2a" translate="yes" xml:space="preserve">
          <source>A department is managed by an employee, hence the &lt;code&gt;manager&lt;/code&gt; relationship.</source>
          <target state="translated">Отделом управляет сотрудник, отсюда и отношения с &lt;code&gt;manager&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="534a5700b1818fc0d3d69084b7c41aaeecf9a10e" translate="yes" xml:space="preserve">
          <source>A destroyed key is very likely to be reused soon. Therefore, if you fail to clear the thread-specific data using this key in a thread before destroying the key, you will &lt;strong&gt;very likely&lt;/strong&gt; get unexpected errors in other parts of the system.</source>
          <target state="translated">Уничтоженный ключ, скорее всего, вскоре будет повторно использован. Следовательно, если вам не удастся очистить данные, специфичные для потока, с помощью этого ключа в потоке, прежде чем уничтожить ключ, вы, &lt;strong&gt;скорее всего,&lt;/strong&gt; получите неожиданные ошибки в других частях системы.</target>
        </trans-unit>
        <trans-unit id="6c06f3920fbc20d8a33902857e2e1dbbe9185ab8" translate="yes" xml:space="preserve">
          <source>A diameter service, as configured with &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, specifies one or more supported Diameter applications. Each Diameter application specifies a dictionary module that knows how to encode and decode its messages and AVPs. The dictionary module is in turn generated from a file that defines these messages and AVPs. The format of such a file is defined in &lt;code&gt;&lt;a href=&quot;#FILE_FORMAT&quot;&gt;FILE FORMAT&lt;/a&gt;&lt;/code&gt; below. Users add support for their specific applications by creating dictionary files, compiling them to Erlang modules using either &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; and configuring the resulting dictionaries modules on a service.</source>
          <target state="translated">Служба диаметра, сконфигурированная с &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; , указывает одно или несколько поддерживаемых приложений Diameter. Каждое приложение Diameter определяет модуль словаря, который знает, как кодировать и декодировать свои сообщения и AVP. Модуль словаря, в свою очередь, создается из файла, который определяет эти сообщения и AVP. Формат такого файла определяется в &lt;code&gt;&lt;a href=&quot;#FILE_FORMAT&quot;&gt;FILE FORMAT&lt;/a&gt;&lt;/code&gt; ниже. Пользователи добавляют поддержку своих конкретных приложений, создавая файлы словарей, компилируя их в модули Erlang, используя либо &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; либо &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; и настраивая результирующие модули словарей в службе.</target>
        </trans-unit>
        <trans-unit id="7a9137875cffe6b05cd927e970323d3a0b3eea26" translate="yes" xml:space="preserve">
          <source>A dictionary file consists of distinct sections. Each section starts with a tag followed by zero or more arguments and ends at the the start of the next section or end of file. Tags consist of an ampersand character followed by a keyword and are separated from their arguments by whitespace. Whitespace separates individual tokens but is otherwise insignificant.</source>
          <target state="translated">Файл словаря состоит из отдельных разделов.Каждая секция начинается с тэга,за которым следует ноль или больше аргументов,и заканчивается в начале следующей секции или в конце файла.Тэги состоят из символа амперсанда,за которым следует ключевое слово,и отделяются от своих аргументов пробелами.Пробельные символы отделяют отдельные токены,но в остальном они несущественны.</target>
        </trans-unit>
        <trans-unit id="5e33a8495150bb32e7f8b820523060366bf248c7" translate="yes" xml:space="preserve">
          <source>A difference is how messages are sent to a registered process on another node:</source>
          <target state="translated">Разница заключается в том,как сообщения отправляются зарегистрированному процессу на другом узле:</target>
        </trans-unit>
        <trans-unit id="94b01ef26ce08428a3ba5531da74cc6167159294" translate="yes" xml:space="preserve">
          <source>A digest is a (16 bytes) MD5 hash of the challenge (as text) concatenated with the cookie (as text). Below, the function &lt;code&gt;gen_digest(Challenge, Cookie)&lt;/code&gt; generates a digest as described above.</source>
          <target state="translated">Дайджест - это (16 байт) хеш MD5 запроса (в виде текста), объединенный с файлом cookie (в виде текста). Ниже функция &lt;code&gt;gen_digest(Challenge, Cookie)&lt;/code&gt; генерирует дайджест, как описано выше.</target>
        </trans-unit>
        <trans-unit id="97a4d843c861dcb7b6c4243c19ad5c6f32cf1f75" translate="yes" xml:space="preserve">
          <source>A digraph as returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Орграф, возвращенный функцией &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0,1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92134ca8f685d563f60794a6f2cd96898218a3f1" translate="yes" xml:space="preserve">
          <source>A direct one-to-one mapping can be established between Mnesia tables and SNMP tables. Many telecommunication applications are controlled and monitored by the SNMP protocol. This connection between Mnesia and SNMP makes it simple and convenient to achieve this mapping.</source>
          <target state="translated">Между таблицами Мнезии и таблицами SNMP можно установить прямое картирование один-на-один.Многие телекоммуникационные приложения управляются и контролируются с помощью протокола SNMP.Такая связь между Мнезией и SNMP делает процесс картирования простым и удобным.</target>
        </trans-unit>
        <trans-unit id="5a14fb204056be345e895dd5aa7d44f25878907a" translate="yes" xml:space="preserve">
          <source>A directory &lt;code&gt;$ROOT/lib/releases/Vsn&lt;/code&gt; is created, where the &lt;code&gt;.rel&lt;/code&gt; file, the boot script &lt;code&gt;start.boot&lt;/code&gt;, the system configuration file &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt; are placed. For applications with new version numbers, the application directories are placed under &lt;code&gt;$ROOT/lib&lt;/code&gt;. Unchanged applications are not affected.</source>
          <target state="translated">Создается каталог &lt;code&gt;$ROOT/lib/releases/Vsn&lt;/code&gt; , в который &lt;code&gt;.rel&lt;/code&gt; файл .rel , сценарий загрузки &lt;code&gt;start.boot&lt;/code&gt; , файл конфигурации системы &lt;code&gt;sys.config&lt;/code&gt; и &lt;code&gt;relup&lt;/code&gt; . Для приложений с новыми номерами версий каталоги приложений помещаются в &lt;code&gt;$ROOT/lib&lt;/code&gt; . Неизмененные приложения не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="b6621117e99280c08a6a5c251265a94569f71ef2" translate="yes" xml:space="preserve">
          <source>A directory &lt;code&gt;releases&lt;/code&gt; is also included in the release package, containing &lt;code&gt;Name.rel&lt;/code&gt; and a subdirectory &lt;code&gt;RelVsn&lt;/code&gt;. &lt;code&gt;RelVsn&lt;/code&gt; is the release version as specified in &lt;code&gt;Name.rel&lt;/code&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;releases&lt;/code&gt; также включен в пакет выпуска, содержащий &lt;code&gt;Name.rel&lt;/code&gt; и подкаталог &lt;code&gt;RelVsn&lt;/code&gt; . &lt;code&gt;RelVsn&lt;/code&gt; - это версия выпуска, указанная в &lt;code&gt;Name.rel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4500d0e224c17fb948b0cb9c7625fe0de15c6f3" translate="yes" xml:space="preserve">
          <source>A directory containing one or more test suite modules, that is, a group of test suites.</source>
          <target state="translated">Каталог,содержащий один или несколько модулей набора тестов,то есть группу наборов тестов.</target>
        </trans-unit>
        <trans-unit id="e1df29d5aaa8b080fbaa691c505a19d49ce3028b" translate="yes" xml:space="preserve">
          <source>A dirty CPU scheduler thread.</source>
          <target state="translated">Грязный процессорный поток планировщика.</target>
        </trans-unit>
        <trans-unit id="ac9d98b43f6ed325d229760f35e5424d98091c99" translate="yes" xml:space="preserve">
          <source>A dirty I/O scheduler thread.</source>
          <target state="translated">Грязный поток планировщика входов/выходов.</target>
        </trans-unit>
        <trans-unit id="bf9457e20d0f94d641c3b38efb00a54afdb0494c" translate="yes" xml:space="preserve">
          <source>A dirty operation ensures a certain level of consistency. For example, dirty operations cannot return garbled records. Hence, each individual read or write operation is performed in an atomic manner.</source>
          <target state="translated">Грязная операция обеспечивает определенный уровень постоянства.Например,грязные операции не могут вернуть искаженные записи.Следовательно,каждая отдельная операция чтения или записи выполняется атомарным способом.</target>
        </trans-unit>
        <trans-unit id="7ebf083e79a4bab181933e594cee2d9370b9ab7c" translate="yes" xml:space="preserve">
          <source>A disk-based term logging facility.</source>
          <target state="translated">Дисковая система регистрации терминов.</target>
        </trans-unit>
        <trans-unit id="0d96f2972ef274a3b4c3377bf6357c2926605d52" translate="yes" xml:space="preserve">
          <source>A disk-based term storage.</source>
          <target state="translated">Дисковая система хранения данных.</target>
        </trans-unit>
        <trans-unit id="47c69df1e3667dcfedb432994923493351c17966" translate="yes" xml:space="preserve">
          <source>A disk_log based handler for Logger</source>
          <target state="translated">Обработчик на основе disk_log для Логгера</target>
        </trans-unit>
        <trans-unit id="d5a1bc14ede3681f787b432535890d0cd273d420" translate="yes" xml:space="preserve">
          <source>A distributed telecommunications DBMS</source>
          <target state="translated">Распределенная телекоммуникационная СУБД</target>
        </trans-unit>
        <trans-unit id="ce830ece0130879215c67d6a63d5c97d8a7c48e3" translate="yes" xml:space="preserve">
          <source>A dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). This option is ignored if option &lt;code&gt;multiline&lt;/code&gt; is specified. There is no equivalent option in Perl, and it cannot be set within a pattern.</source>
          <target state="translated">Метасимвол доллара в шаблоне соответствует только в конце строки темы. Без этой опции доллар также соответствует непосредственно перед новой строкой в ​​конце строки (но не перед любыми другими символами новой строки). Эта опция игнорируется, если указана опция &lt;code&gt;multiline&lt;/code&gt; . В Perl нет эквивалентной опции, и ее нельзя установить в шаблоне.</target>
        </trans-unit>
        <trans-unit id="ade8b69a85608bc000b53cc0bb10d32bd6f4e1e4" translate="yes" xml:space="preserve">
          <source>A domain field must be a list of atoms, creating smaller and more specialized domains as the list grows longer. The greatest domain is &lt;code&gt;[]&lt;/code&gt;, which comprises all possible domains.</source>
          <target state="translated">Поле домена должно быть списком атомов, создавая меньшие и более специализированные домены по мере того, как список увеличивается. Самый большой домен - &lt;code&gt;[]&lt;/code&gt; , который включает все возможные домены.</target>
        </trans-unit>
        <trans-unit id="3633cdcde13dc5b95a07d9cdccf61ad19b7292b3" translate="yes" xml:space="preserve">
          <source>A door with a code lock can be seen as a state machine. Initially, the door is locked. When someone presses a button, an event is generated. The pressed buttons are collected, up to the number of buttons in the correct code. If correct, the door is unlocked for 10 seconds. If not correct, we wait for a new button to be pressed.</source>
          <target state="translated">Дверь с кодовым замком можно рассматривать как государственную машину.Изначально дверь запирается.Когда кто-то нажимает кнопку,генерируется событие.Нажатые кнопки собираются,вплоть до количества кнопок в правильном коде.При правильном выборе,дверь отпирается на 10 секунд.Если это неправильно,мы ждем,пока не будет нажата новая кнопка.</target>
        </trans-unit>
        <trans-unit id="9d2a5945a95873dd7f235759b1053935e86a971f" translate="yes" xml:space="preserve">
          <source>A dot in the pattern matches all characters, including those indicating newline. Without it, a dot does not match when the current position is at a newline. This option is equivalent to Perl option &lt;code&gt;/s&lt;/code&gt; and it can be changed within a pattern by a &lt;code&gt;(?s)&lt;/code&gt; option setting. A negative class, such as &lt;code&gt;[^a]&lt;/code&gt;, always matches newline characters, independent of the setting of this option.</source>
          <target state="translated">Точка в шаблоне соответствует всем символам, включая символы новой строки. Без него точка не будет соответствовать, если текущая позиция находится на новой строке. Этот параметр эквивалентен параметру &lt;code&gt;/s&lt;/code&gt; Perl, и его можно изменить в шаблоне с помощью параметра &lt;code&gt;(?s)&lt;/code&gt; . Отрицательный класс, такой как &lt;code&gt;[^a]&lt;/code&gt; , всегда соответствует символам новой строки, независимо от настройки этого параметра.</target>
        </trans-unit>
        <trans-unit id="885bb765c3b45bdf4bc945235d9e2dd16052f6ab" translate="yes" xml:space="preserve">
          <source>A drawback of simple test functions is that you must write a separate function (with a separate name) for each test case. A more compact way of writing tests (and much more flexible, as we shall see), is to write functions that &lt;strong&gt;return&lt;/strong&gt; tests, instead of &lt;strong&gt;being&lt;/strong&gt; tests.</source>
          <target state="translated">Недостатком простых тестовых функций является то, что вы должны писать отдельную функцию (с отдельным именем) для каждого тестового примера. Более компактный способ написания тестов (и гораздо более гибкий, как мы увидим) - это написать функции, которые &lt;strong&gt;возвращают&lt;/strong&gt; тесты, а не &lt;strong&gt;являются&lt;/strong&gt; тестами.</target>
        </trans-unit>
        <trans-unit id="b000c1146f0c1ed1dc5a3aabc97ba084c853c614" translate="yes" xml:space="preserve">
          <source>A drawback with implementing an SNMP table as a Mnesia table is that the internal resource is forced to use the table definition from the MIB, which means that the external data model must be used internally. Actually, this is only partially true. The Mnesia table may extend the SNMP table, which means that the Mnesia table may have columns which are use internally and are not seen by SNMP. Still, the data model from SNMP must be maintained. Although this is undesirable, it is a pragmatic compromise in many situations where simple and efficient implementation is preferable to abstraction.</source>
          <target state="translated">Недостатком внедрения таблицы SNMP в качестве таблицы Mnesia является то,что внутренний ресурс вынужден использовать определение таблицы из MIB,что означает,что внешняя модель данных должна использоваться внутренне.На самом деле,это лишь частично верно.Таблица Мнезия может расширять таблицу SNMP,что означает,что таблица Мнезия может иметь столбцы,которые используются внутри организации и невидимы для SNMP.Тем не менее,модель данных из SNMP должна поддерживаться.Хотя это нежелательно,это является прагматичным компромиссом во многих ситуациях,когда простая и эффективная реализация предпочтительнее абстракции.</target>
        </trans-unit>
        <trans-unit id="dc70d1fd3885c3da6699390fff4e736e7393cca0" translate="yes" xml:space="preserve">
          <source>A driver binary allocated in the driver, with &lt;code&gt;driver_alloc_binary&lt;/code&gt;, is to be freed in the driver (unless otherwise stated) with &lt;code&gt;driver_free_binary&lt;/code&gt;. (Notice that this does not necessarily deallocate it, if the driver is still referred in the emulator, the ref-count will not go to zero.)</source>
          <target state="translated">Бинарный файл драйвера, выделенный в драйвере с помощью &lt;code&gt;driver_alloc_binary&lt;/code&gt; , должен быть освобожден в драйвере (если не указано иное) с помощью &lt;code&gt;driver_free_binary&lt;/code&gt; . (Обратите внимание, что это не обязательно освобождает его, если драйвер все еще упоминается в эмуляторе, счетчик ссылок не будет равен нулю.)</target>
        </trans-unit>
        <trans-unit id="54bf6555831bbcbb33a1143a231274fb8310abec" translate="yes" xml:space="preserve">
          <source>A driver callback doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">Обратный вызов драйвера, выполняющий &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; перед возвратом, ухудшает отзывчивость виртуальной машины и может вызывать разные странные поведения. Такое странное поведение включает, помимо прочего, чрезмерное использование памяти и плохую балансировку нагрузки между планировщиками. Странное поведение, которое может возникнуть из-за длительной работы, также может различаться между выпусками Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="8a40326bca24e22884109edb9057e64a36e9d19f" translate="yes" xml:space="preserve">
          <source>A driver callback doing &lt;code&gt;&lt;a href=&quot;erl_driver#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">Обратный вызов драйвера, выполняющий &lt;code&gt;&lt;a href=&quot;erl_driver#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; перед возвратом, ухудшает отзывчивость виртуальной машины и может вызывать разные странные поведения. Такое странное поведение включает, помимо прочего, чрезмерное использование памяти и плохую балансировку нагрузки между планировщиками. Странное поведение, которое может возникнуть из-за длительной работы, также может различаться между выпусками Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="0b5eb508da3e1d5ef4a4f999ab3b5ee6a71a758f" translate="yes" xml:space="preserve">
          <source>A driver callback is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the driver callback function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">Обратный вызов драйвера выполняется как прямое расширение собственного кода виртуальной машины. Казнь не производится в безопасных условиях. Виртуальная машина &lt;strong&gt;не может&lt;/strong&gt; предоставлять те же услуги, что и при выполнении кода Erlang, такие как упреждающее планирование или защита памяти. Если функция обратного вызова драйвера не работает должным образом, вся виртуальная машина будет вести себя неправильно.</target>
        </trans-unit>
        <trans-unit id="c5fe6680281eb2602c7b531134d6486d21c3966d" translate="yes" xml:space="preserve">
          <source>A driver callback that crash will crash the whole VM.</source>
          <target state="translated">Водитель,позвонивший в эту аварию,разобьет весь ВМ.</target>
        </trans-unit>
        <trans-unit id="35f6d76692e5c5a3a8bc9ae237376468c696b57c" translate="yes" xml:space="preserve">
          <source>A driver can add and later remove drivers.</source>
          <target state="translated">Драйвер может добавлять и впоследствии удалять драйверы.</target>
        </trans-unit>
        <trans-unit id="5db720ccab1ee2294dd6583e58238e6ff531fde9" translate="yes" xml:space="preserve">
          <source>A driver can be configured to have one lock for each port instead.</source>
          <target state="translated">Вместо этого драйвер может быть настроен на один замок для каждого порта.</target>
        </trans-unit>
        <trans-unit id="ea8de0f635aa82b9e3262bc25c0681bf5ef9e25f" translate="yes" xml:space="preserve">
          <source>A driver can be dynamically loaded, as a shared library (known as a DLL on Windows), or statically loaded, linked with the emulator when it is compiled and linked. Only dynamically loaded drivers are described here, statically linked drivers are beyond the scope of this section.</source>
          <target state="translated">Драйвер может быть динамически загружен,как разделяемая библиотека (известная как DLL в Windows),или статически загружен,скомпонован с эмулятором,когда он скомпилирован и скомпонован.Здесь описаны только динамически загружаемые драйверы,статически связанные драйверы выходят за рамки данного раздела.</target>
        </trans-unit>
        <trans-unit id="e0a7bb769b863c9b98696f02891a10946d65061a" translate="yes" xml:space="preserve">
          <source>A driver can monitor a process that does not own a port.</source>
          <target state="translated">Драйвер может контролировать процесс,у которого нет порта.</target>
        </trans-unit>
        <trans-unit id="c998e9cdc2a7831f2ce7666b5692240829ea93b5" translate="yes" xml:space="preserve">
          <source>A driver in Erlang is a library written in C, which is linked to the Erlang emulator and called from Erlang. Drivers can be used when C is more suitable than Erlang, to speed up things, or to provide access to OS resources not directly accessible from Erlang.</source>
          <target state="translated">Драйвер на Erlang-это библиотека,написанная на C,которая связана с эмулятором Erlang и вызывается из Erlang.Драйверы могут быть использованы,когда C более подходит,чем Erlang,для ускорения работы или для предоставления доступа к ресурсам ОС,напрямую не доступным с Erlang.</target>
        </trans-unit>
        <trans-unit id="485795b556efcb079ba1f2cce0c02a2d6a8f0346" translate="yes" xml:space="preserve">
          <source>A driver monitor for unload eventually results in one of the following messages being sent:</source>
          <target state="translated">Монитор водителя для выгрузки в конечном итоге приводит к отправке одного из следующих сообщений:</target>
        </trans-unit>
        <trans-unit id="776db06c979c20584411a6ff4cdf277b51cad201" translate="yes" xml:space="preserve">
          <source>A drop-down box in the toolbar contains the command history. Selecting a command in the drop-down box inserts the command at the prompt, as if you used the keyboard to retrieve the command.</source>
          <target state="translated">Выпадающее окно на панели инструментов содержит историю команд.Выбор команды в раскрывающемся списке вставляет ее в приглашение,как если бы вы использовали клавиатуру для ее получения.</target>
        </trans-unit>
        <trans-unit id="6861853bee0f535fea0e16450c99ed3515493ce2" translate="yes" xml:space="preserve">
          <source>A failed user authentication.</source>
          <target state="translated">Неудачная аутентификация пользователя.</target>
        </trans-unit>
        <trans-unit id="9db63409ec19fe48d435b1817d57ade59ec9240c" translate="yes" xml:space="preserve">
          <source>A fallback is typically used when a system upgrade is performed. A system typically involves the installation of new software versions, and &lt;code&gt;Mnesia&lt;/code&gt; tables are often transformed into new layouts. If the system crashes during an upgrade, it is highly probable that reinstallation of the old applications is required, and restoration of the database to its previous state. This can be done if a backup is performed and installed as a fallback before the system upgrade begins.</source>
          <target state="translated">Откат обычно используется при обновлении системы. Система обычно включает установку новых версий программного обеспечения, и таблицы &lt;code&gt;Mnesia&lt;/code&gt; часто преобразуются в новые макеты. Если система выйдет из строя во время обновления, весьма вероятно, что потребуется переустановка старых приложений и восстановление базы данных до ее предыдущего состояния. Это можно сделать, если резервное копирование выполняется и устанавливается в качестве резервной копии до начала обновления системы.</target>
        </trans-unit>
        <trans-unit id="318a05f034b1325fb1731c6625436c4ea96c2dba" translate="yes" xml:space="preserve">
          <source>A family of options that selectively turn on/off warnings. (For help on the names of warnings, use &lt;code&gt;dialyzer -Whelp&lt;/code&gt;.) Notice that the options can also be specified in the file with a &lt;code&gt;-dialyzer()&lt;/code&gt; attribute. For details, see section &lt;code&gt;&lt;a href=&quot;#suppression&quot;&gt;Requesting or Suppressing Warnings in Source Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Семейство опций, которые выборочно включают / выключают предупреждения. (Для справки по именам предупреждений используйте &lt;code&gt;dialyzer -Whelp&lt;/code&gt; .) Обратите внимание, что параметры также могут быть указаны в файле с помощью &lt;code&gt;-dialyzer()&lt;/code&gt; . Подробности см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#suppression&quot;&gt;Requesting or Suppressing Warnings in Source Files&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f11118ca381dffc41f3188bffb0c43a4c650f1ba" translate="yes" xml:space="preserve">
          <source>A fast allocator used for some frequently used fixed size data types.</source>
          <target state="translated">Быстрый аллокатор,используемый для некоторых часто используемых типов данных фиксированного размера.</target>
        </trans-unit>
        <trans-unit id="3744509be8dd70aa593f301a9795a7c56c7a0de4" translate="yes" xml:space="preserve">
          <source>A faulty linked-in driver causes the entire Erlang runtime system to leak memory, hang, or crash.</source>
          <target state="translated">Неисправный связанный драйвер приводит к утечке памяти,зависанию или аварийному завершению работы всей системы Erlang.</target>
        </trans-unit>
        <trans-unit id="89cefbb8feb5d084db82b500bebe6a7d1dfbb558" translate="yes" xml:space="preserve">
          <source>A few applications, such as HiPE, do not support upgrade. This is indicated by an application upgrade file containing only &lt;code&gt;{Vsn,[],[]}&lt;/code&gt;. Any attempt at creating a release upgrade file with such input fails. The only way to force an upgrade involving applications like this is to handwrite the file &lt;code&gt;relup&lt;/code&gt;, preferably as described above with only the &lt;code&gt;restart_emulator&lt;/code&gt; instruction.</source>
          <target state="translated">Некоторые приложения, например HiPE, не поддерживают обновление. На это указывает файл обновления приложения, содержащий только &lt;code&gt;{Vsn,[],[]}&lt;/code&gt; . Любая попытка создать файл обновления выпуска с такими входными данными терпит неудачу. Единственный способ принудительно выполнить обновление, включающее такие приложения, - это вручную &lt;code&gt;relup&lt;/code&gt; файла , желательно, как описано выше, только с инструкцией &lt;code&gt;restart_emulator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff07fbc6aad7ee78f12be074f853b050b49851ab" translate="yes" xml:space="preserve">
          <source>A few basic match specifications are provided in the tool, and you can provide your own match specifications. The syntax of match specifications is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. To simplify the writing of a match specification, they can also be written as &lt;code&gt;fun/1&lt;/code&gt;. For details, see module &lt;code&gt;ms_transform&lt;/code&gt; in application STDLIB.</source>
          <target state="translated">Инструмент предоставляет несколько основных спецификаций совпадений, и вы можете указать свои собственные. Синтаксис спецификаций совпадений описан в &lt;code&gt;ERTS User's Guide&lt;/code&gt; . Чтобы упростить написание спецификации соответствия, их также можно записать как &lt;code&gt;fun/1&lt;/code&gt; . Подробнее см. Модуль &lt;code&gt;ms_transform&lt;/code&gt; в приложении STDLIB.</target>
        </trans-unit>
        <trans-unit id="09ac9a5c3fa6e165b6c50df51a6215981d75c01d" translate="yes" xml:space="preserve">
          <source>A few cases when it can be useful to change &lt;code&gt;fullsweep_after&lt;/code&gt;:</source>
          <target state="translated">Несколько случаев, когда может быть полезно изменить &lt;code&gt;fullsweep_after&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fd821a8e6f09efd8fb5370148d4ea4ec2ea95138" translate="yes" xml:space="preserve">
          <source>A few exceptions are documented for each property that behaves differently, and the special cases &lt;code&gt;{directory, {path(), PropertyList}}&lt;/code&gt; and &lt;code&gt;{security_directory, {Dir, PropertyList}}&lt;/code&gt;, are represented as:</source>
          <target state="translated">Некоторые исключения задокументированы для каждого свойства, которое ведет себя по-разному, а особые случаи &lt;code&gt;{directory, {path(), PropertyList}}&lt;/code&gt; и &lt;code&gt;{security_directory, {Dir, PropertyList}}&lt;/code&gt; представлены как:</target>
        </trans-unit>
        <trans-unit id="fce4084ca7f83d86aff3d0d9ecf63d0ad90bd23a" translate="yes" xml:space="preserve">
          <source>A few functions of this module (&lt;code&gt;&lt;a href=&quot;#drestriction-3&quot;&gt;drestriction/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#family_projection-2&quot;&gt;family_projection/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#partition_family-2&quot;&gt;partition_family/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#projection-2&quot;&gt;projection/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#restriction-3&quot;&gt;restriction/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#substitution-2&quot;&gt;substitution/2&lt;/a&gt;&lt;/code&gt;) accept an Erlang function as a means to modify each element of a given unordered set. Such a function, called SetFun in the following, can be specified as a functional object (fun), a tuple &lt;code id=&quot;set_fun&quot;&gt;{external,&amp;nbsp;Fun}&lt;/code&gt;, or an integer:</source>
          <target state="translated">Некоторые функции этого модуля ( &lt;code&gt;&lt;a href=&quot;#drestriction-3&quot;&gt;drestriction/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#family_projection-2&quot;&gt;family_projection/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#partition_family-2&quot;&gt;partition_family/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#projection-2&quot;&gt;projection/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#restriction-3&quot;&gt;restriction/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#substitution-2&quot;&gt;substitution/2&lt;/a&gt;&lt;/code&gt; ) принимают функцию Erlang как средство для изменения каждого элемента данного неупорядоченного устанавливать. Такая функция, называемая далее SetFun, может быть указана как функциональный объект (развлечение), кортеж &lt;code id=&quot;set_fun&quot;&gt;{external,&amp;nbsp;Fun}&lt;/code&gt; или целое число:</target>
        </trans-unit>
        <trans-unit id="e2ace938c1e5c889a1c9155b08dfea0b539e2fd8" translate="yes" xml:space="preserve">
          <source>A few more ways of retrieving parts of the result set when the driver supports scrollable cursors. Note that next will work even without support for scrollable cursors.</source>
          <target state="translated">Еще несколько способов извлечения частей набора результатов,когда драйвер поддерживает курсоры прокрутки.Обратите внимание,что следующий будет работать даже без поддержки прокручиваемых курсоров.</target>
        </trans-unit>
        <trans-unit id="69178368f8f421dd7829a950db37217d05913e11" translate="yes" xml:space="preserve">
          <source>A file &lt;code&gt;test.config&lt;/code&gt; is created with the following contents:</source>
          <target state="translated">Создается файл &lt;code&gt;test.config&lt;/code&gt; со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="c8d336412b7f7b3198bf244f5e66fc7122fd82ab" translate="yes" xml:space="preserve">
          <source>A file can be included as follows:</source>
          <target state="translated">Файл может быть включен следующим образом:</target>
        </trans-unit>
        <trans-unit id="cbeaf69644d74ca16d734d345aa0a129a3918826" translate="yes" xml:space="preserve">
          <source>A file can contain several &lt;code&gt;BEGIN/END&lt;/code&gt; blocks. Text lines between blocks are ignored. Attributes, if present, are ignored except for &lt;code&gt;Proc-Type&lt;/code&gt; and &lt;code&gt;DEK-Info&lt;/code&gt;, which are used when &lt;code&gt;DER&lt;/code&gt; data is encrypted.</source>
          <target state="translated">Файл может содержать несколько блоков &lt;code&gt;BEGIN/END&lt;/code&gt; . Текстовые строки между блоками игнорируются. Атрибуты, если они есть, игнорируются, за исключением &lt;code&gt;Proc-Type&lt;/code&gt; и &lt;code&gt;DEK-Info&lt;/code&gt; , которые используются при шифровании данных &lt;code&gt;DER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9565a924f37de4be5c2226f5018cb7da0db985af" translate="yes" xml:space="preserve">
          <source>A file can have an encoding option that makes it generally usable by the &lt;code&gt;io&lt;/code&gt; module (for example &lt;code&gt;{encoding,utf8}&lt;/code&gt;), but is by default opened as a byte-oriented file. The &lt;code&gt;file&lt;/code&gt; module is byte-oriented, so only ISO Latin-1 characters can be written using that module. Use the &lt;code&gt;io&lt;/code&gt; module if Unicode data is to be output to a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding). It is slightly confusing that a file opened with, for example, &lt;code&gt;file:open(Name,[read,{encoding,utf8}])&lt;/code&gt; cannot be properly read using &lt;code&gt;file:read(File,N)&lt;/code&gt;, but using the &lt;code&gt;io&lt;/code&gt; module to retrieve the Unicode data from it. The reason is that &lt;code&gt;file:read&lt;/code&gt; and &lt;code&gt;file:write&lt;/code&gt; (and friends) are purely byte-oriented, and should be, as that is the way to access files other than text files, byte by byte. As with ports, you can write encoded data into a file by &quot;manually&quot; converting the data to the encoding of choice (using the &lt;code&gt;unicode&lt;/code&gt; module or the bit syntax) and then output it on a bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoded file.</source>
          <target state="translated">Файл может иметь параметр кодировки, который делает его обычно используемым модулем &lt;code&gt;io&lt;/code&gt; (например, &lt;code&gt;{encoding,utf8}&lt;/code&gt; ), но по умолчанию открывается как файл с байтовой ориентацией. &lt;code&gt;file&lt;/code&gt; модуля байт-ориентированный, поэтому только ISO Latin-1 символов можно записать с помощью этого модуля. Используйте модуль &lt;code&gt;io&lt;/code&gt; , если данные Unicode должны выводиться в файл с &lt;code&gt;encoding&lt;/code&gt; отличной от &lt;code&gt;latin1&lt;/code&gt; (побайтовое кодирование). Немного сбивает с толку то, что файл, открытый, например, с помощью &lt;code&gt;file:open(Name,[read,{encoding,utf8}])&lt;/code&gt; не может быть правильно прочитан с помощью &lt;code&gt;file:read(File,N)&lt;/code&gt; , но с помощью модуля &lt;code&gt;io&lt;/code&gt; для получения данные Unicode из него. Причина в том, что &lt;code&gt;file:read&lt;/code&gt; и &lt;code&gt;file:write&lt;/code&gt; (и друзья) являются чисто побайтно-ориентированными и должны быть, поскольку это способ доступа к файлам, отличным от текстовых файлов, побайтно. Как и в случае с портами, вы можете записать закодированные данные в файл, &amp;laquo;вручную&amp;raquo; преобразовав данные в выбранную кодировку (используя модуль &lt;code&gt;unicode&lt;/code&gt; или битовый синтаксис), а затем вывести их в файл с побайтной ( &lt;code&gt;latin1&lt;/code&gt; ) кодировкой.</target>
        </trans-unit>
        <trans-unit id="4d89c7591289fd3005e1bbfce5efe617ceee10df" translate="yes" xml:space="preserve">
          <source>A file containing data related to a test and/or an SUT, for example, protocol server addresses, client login details, and hardware interface addresses. That is, any data that is to be handled as variable in the suite and not be hard-coded.</source>
          <target state="translated">Файл,содержащий данные,связанные с тестом и/или SUT,например,адреса протокольного сервера,данные для входа клиента и адреса аппаратного интерфейса.То есть,любые данные,которые должны обрабатываться как переменные в комплекте,а не как жестко закодированные.</target>
        </trans-unit>
        <trans-unit id="616a73250d7af5692f557f0fc3d8f0aefbf16ef9" translate="yes" xml:space="preserve">
          <source>A file descriptor representing a file opened in &lt;code&gt;&lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">Дескриптор файла, представляющий файл, открытый в &lt;code&gt;&lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt;&lt;/code&gt; режиме.</target>
        </trans-unit>
        <trans-unit id="2d71dcec01ab246a78607a17cbd7cd28847c46b5" translate="yes" xml:space="preserve">
          <source>A file or directory named &lt;code&gt;Dir&lt;/code&gt; exists already.</source>
          <target state="translated">Файл или каталог с именем &lt;code&gt;Dir&lt;/code&gt; уже существует.</target>
        </trans-unit>
        <trans-unit id="26be688763e641b3a9dfad11fde8db2842f3801c" translate="yes" xml:space="preserve">
          <source>A filename.</source>
          <target state="translated">Фамилия.</target>
        </trans-unit>
        <trans-unit id="7e18ad0e74d1cf4a7f98aab6228b1e84c7680443" translate="yes" xml:space="preserve">
          <source>A filter is defined as:</source>
          <target state="translated">Фильтр определяется как:</target>
        </trans-unit>
        <trans-unit id="8e5fa771ebe9bef523c8171150923d10ee3e8517" translate="yes" xml:space="preserve">
          <source>A filter which can be installed as a handler filter, or as a primary filter in Logger.</source>
          <target state="translated">Фильтр,который может быть установлен в качестве обработчика или в качестве первичного фильтра в журнале регистрации событий.</target>
        </trans-unit>
        <trans-unit id="1e3cb0a88c21fc9cb93d8900a90dbffadc95b7ff" translate="yes" xml:space="preserve">
          <source>A filter_fun() takes an event record as sole argument and returns false | true | {true, NewEvent}.</source>
          <target state="translated">Фильтр_fun()принимает в качестве единственного аргумента запись события и возвращает false | true | {true,NewEvent}.</target>
        </trans-unit>
        <trans-unit id="520861380e77fff7b333b5642ccc63edc6c4108c" translate="yes" xml:space="preserve">
          <source>A final massage of the environment is needed, and that is done by the script &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt;. Start bash and do the following, note the &quot;back-ticks&quot; (`), can be quite hard to get on some keyboards, but pressing the back-tick key followed by the space bar might do it...</source>
          <target state="translated">Требуется заключительный массаж среды, и это выполняется сценарием &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; . Запустите bash и сделайте следующее, обратите внимание на &quot;обратные галочки&quot; (`), которые могут быть довольно трудными для доступа на некоторых клавиатурах, но нажатие клавиши обратного отсчета с последующим пробелом может сделать это ...</target>
        </trans-unit>
        <trans-unit id="90f744119c16fd9fb8932446ccb5476df4faf187" translate="yes" xml:space="preserve">
          <source>A fixed number of characters is requested using the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">Фиксированное количество символов запрашивается с помощью следующего &lt;code&gt;Request&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a7d5da9ebedb8e232edc49649003f18ee79c791" translate="yes" xml:space="preserve">
          <source>A fixed-size array does not grow automatically and does not allow accesses beyond the last set entry:</source>
          <target state="translated">Массив с фиксированным размером не растет автоматически и не разрешает доступ за пределы последней записи набора:</target>
        </trans-unit>
        <trans-unit id="3bad05ad914ca3ed5e8df973848616692506d53e" translate="yes" xml:space="preserve">
          <source>A flag starting with a plus (&lt;code&gt;+&lt;/code&gt;) rather than a hyphen is converted to an Erlang term and passed unchanged to the compiler. For example, option &lt;code&gt;export_all&lt;/code&gt; for the Erlang compiler can be specified as follows:</source>
          <target state="translated">Флаг, начинающийся с плюса ( &lt;code&gt;+&lt;/code&gt; ), а не дефиса, преобразуется в термин Эрланга и передается компилятору без изменений. Например, параметр &lt;code&gt;export_all&lt;/code&gt; для компилятора Erlang можно указать следующим образом:</target>
        </trans-unit>
        <trans-unit id="10b632ad7a686b2d7a96c3959bf12e04c0566f52" translate="yes" xml:space="preserve">
          <source>A float is stored as 8 bytes in big-endian IEEE format.</source>
          <target state="translated">Плавающий диск хранится в виде 8 байт в big-endian формате IEEE.</target>
        </trans-unit>
        <trans-unit id="e9e5201aedcab16b3adecdda5a3e12ff8098d3d7" translate="yes" xml:space="preserve">
          <source>A float is stored in string format. The format used in sprintf to format the float is &quot;%.20e&quot; (there are more bytes allocated than necessary). To unpack the float, use sscanf with format &quot;%lf&quot;.</source>
          <target state="translated">Плавающий диск хранится в строковом формате.Формат,используемый в sprintf для форматирования float-&quot;%.20e&quot; (выделяется больше байт,чем необходимо).Для распаковки флота используйте sscanf с форматом &quot;%lf&quot;.</target>
        </trans-unit>
        <trans-unit id="a6f6fcdac9b179d5523fd1d6e88e1a598a905d83" translate="yes" xml:space="preserve">
          <source>A floating point number is expected. It must follow the Erlang floating point number syntax.</source>
          <target state="translated">Ожидается,что число с плавающей точкой.Оно должно следовать синтаксису чисел с плавающей точкой Erlang.</target>
        </trans-unit>
        <trans-unit id="b4d0580dc8d2afb0f4c6adffa439752a5472ac02" translate="yes" xml:space="preserve">
          <source>A format handler is a fun taking four arguments. This fun is called for each trace message in the binary log(s). A simple example that only prints each trace message can be as follows:</source>
          <target state="translated">Обработчик форматов-это весело,принимая четыре аргумента.Это удовольствие вызывается для каждого сообщения трассировки в двоичном журнале (журналах).Простой пример,что только печатает каждое сообщение трассировки,может быть следующим:</target>
        </trans-unit>
        <trans-unit id="685c2f489be151735ae38f24a353d5faae37fc17" translate="yes" xml:space="preserve">
          <source>A formatter can be used by the handler implementation to do the final formatting of a log event, before printing to the handler's destination. The handler callback receives the formatter information as part of the handler configuration, which is passed as the second argument to &lt;code&gt;&lt;a href=&quot;logger#HModule:log-2&quot;&gt;HModule:log/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Программа форматирования может использоваться реализацией обработчика для окончательного форматирования события журнала перед печатью в место назначения обработчика. Обратный вызов обработчика получает информацию средства форматирования как часть конфигурации обработчика, которая передается в качестве второго аргумента &lt;code&gt;&lt;a href=&quot;logger#HModule:log-2&quot;&gt;HModule:log/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ddabb55af8280ef44d4873b2fe6f87c2ff0d592" translate="yes" xml:space="preserve">
          <source>A framework for automated testing of any target nodes.</source>
          <target state="translated">Фреймворк для автоматизированного тестирования любых целевых узлов.</target>
        </trans-unit>
        <trans-unit id="aee4c7374225cff97b384f5e8f0444105623df6f" translate="yes" xml:space="preserve">
          <source>A fun created by &lt;code&gt;fun M:F/A&lt;/code&gt; is called an &lt;strong&gt;external&lt;/strong&gt; fun. Calling it will always call the function &lt;code&gt;F&lt;/code&gt; with arity &lt;code&gt;A&lt;/code&gt; in the latest code for module &lt;code&gt;M&lt;/code&gt;. Notice that module &lt;code&gt;M&lt;/code&gt; does not even need to be loaded when the fun &lt;code&gt;fun M:F/A&lt;/code&gt; is created.</source>
          <target state="translated">Забава, созданная &lt;code&gt;fun M:F/A&lt;/code&gt; , называется &lt;strong&gt;внешним&lt;/strong&gt; развлечением. Назвать это всегда будет вызывать функцию &lt;code&gt;F&lt;/code&gt; с валентности &lt;code&gt;A&lt;/code&gt; в последней версии кода для модуля &lt;code&gt;M&lt;/code&gt; . Обратите внимание, что модуль &lt;code&gt;M&lt;/code&gt; даже не нужно загружать, когда создается &lt;code&gt;fun M:F/A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe82f35844a581a23e9acd45f2d705a836415f6f" translate="yes" xml:space="preserve">
          <source>A fun expression begins with the keyword &lt;code&gt;fun&lt;/code&gt; and ends with the keyword &lt;code&gt;end&lt;/code&gt;. Between them is to be a function declaration, similar to a &lt;code&gt;&lt;a href=&quot;functions#syntax&quot;&gt;regular function declaration&lt;/a&gt;&lt;/code&gt;, except that the function name is optional and is to be a variable, if any.</source>
          <target state="translated">Выражение fun начинается с ключевого слова &lt;code&gt;fun&lt;/code&gt; и заканчивается ключевым словом &lt;code&gt;end&lt;/code&gt; . Между ними должно быть объявление функции, аналогичное объявлению &lt;code&gt;&lt;a href=&quot;functions#syntax&quot;&gt;regular function declaration&lt;/a&gt;&lt;/code&gt; , за исключением того, что имя функции является необязательным и должно быть переменной, если таковая имеется.</target>
        </trans-unit>
        <trans-unit id="7ba69074df191132a5aee72b7de68af231ccb23b" translate="yes" xml:space="preserve">
          <source>A fun is a functional object. Funs make it possible to create an anonymous function and pass the function itself -- not its name -- as argument to other functions.</source>
          <target state="translated">Веселье-это функциональный объект.Веселье позволяет создать анонимную функцию и передать саму функцию,а не ее имя,в качестве аргумента другим функциям.</target>
        </trans-unit>
        <trans-unit id="a83e179e2a0b967f058ad516cb4229a827e95fd9" translate="yes" xml:space="preserve">
          <source>A fun is applied to the wrong number of arguments. &lt;code&gt;F&lt;/code&gt; describes the fun and the arguments.</source>
          <target state="translated">Забава применяется к неправильному количеству аргументов. &lt;code&gt;F&lt;/code&gt; описывает развлечения и аргументы.</target>
        </trans-unit>
        <trans-unit id="331ce727ff0b82a2baa3eca467f7f047acb2688e" translate="yes" xml:space="preserve">
          <source>A fun refers into a fun table, which also consumes memory.</source>
          <target state="translated">Веселье относится к веселью,которое также потребляет память.</target>
        </trans-unit>
        <trans-unit id="917f02c1a076a8a47ebb3722785173da993cb101" translate="yes" xml:space="preserve">
          <source>A fun with the following signature:</source>
          <target state="translated">Забава со следующей подписью:</target>
        </trans-unit>
        <trans-unit id="9c0db4550739af00d32b0dfa12f09adabde22929" translate="yes" xml:space="preserve">
          <source>A function (&lt;code&gt;fun/0&lt;/code&gt; or &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) tuple) can be specified as timetrap value in the suite-, group- and test case information function, and as argument to function &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция ( &lt;code&gt;fun/0&lt;/code&gt; или &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) кортеж) может быть указана как значение timetrap в функции информации набора, группы и тестового примера, а также как аргумент функции &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a3cf7ceca0e362fe2af257283edf78084fc160" translate="yes" xml:space="preserve">
          <source>A function breakpoint is a set of line breakpoints, one at the first line of each clause in the specified function.</source>
          <target state="translated">Точка останова функции-это набор точек останова линии,по одной в первой строке каждого пункта в указанной функции.</target>
        </trans-unit>
        <trans-unit id="5f0fd871bd70c7514030529afb1f484443906fd8" translate="yes" xml:space="preserve">
          <source>A function can have many arguments. Let us expand the module &lt;code&gt;tut1&lt;/code&gt; with the function to multiply two numbers:</source>
          <target state="translated">У функции может быть много аргументов. Давайте расширим модуль &lt;code&gt;tut1&lt;/code&gt; функцией умножения двух чисел:</target>
        </trans-unit>
        <trans-unit id="fede52edfc71f21c837f79f6a8e9fb78f0248b2b" translate="yes" xml:space="preserve">
          <source>A function compliant with these functions. For details, see the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page.</source>
          <target state="translated">Функция, совместимая с этими функциями. Подробности см. На странице руководства &lt;code&gt;supervisor(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f617733f33e20e330ebc8aa6d33e7c36f5c2a1" translate="yes" xml:space="preserve">
          <source>A function constraint Fc is a non-empty sequence of constraints &lt;code&gt;C_1, ..., C_k&lt;/code&gt;, and Rep(Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt;.</source>
          <target state="translated">Функциональное ограничение Fc представляет собой непустую последовательность ограничений &lt;code&gt;C_1, ..., C_k&lt;/code&gt; и Rep (Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dfcd76722f3584d620315b3cb799ba807ca502f" translate="yes" xml:space="preserve">
          <source>A function for an exclusive decode, whose name the user decides in the configuration file</source>
          <target state="translated">Функция эксклюзивного декодирования,имя которой пользователь определяет в конфигурационном файле</target>
        </trans-unit>
        <trans-unit id="be3487c9bce760681de79e5934bed4a4861cc982" translate="yes" xml:space="preserve">
          <source>A function in a test suite that is meant to be used for setting up, cleaning up, and/or verifying the state and environment on the System Under Test (SUT) and/or the &lt;code&gt;Common Test&lt;/code&gt; host node, so that a test case (or a set of test cases) can execute correctly.</source>
          <target state="translated">Функция в наборе тестов, которая предназначена для использования для настройки, очистки и / или проверки состояния и среды в тестируемой системе (SUT) и / или узле хоста &lt;code&gt;Common Test&lt;/code&gt; , чтобы тестовый пример ( или набор тестовых примеров) может выполняться правильно.</target>
        </trans-unit>
        <trans-unit id="8a453d0634dfbb426f81f44cc7d5fb202b518059" translate="yes" xml:space="preserve">
          <source>A function in a test suite that returns a list of properties (read by the &lt;code&gt;Common Test&lt;/code&gt; server) that describes the conditions for executing the test cases in the suite.</source>
          <target state="translated">Функция в наборе тестов, которая возвращает список свойств (считанных сервером &lt;code&gt;Common Test&lt;/code&gt; ), который описывает условия для выполнения тестовых случаев в наборе.</target>
        </trans-unit>
        <trans-unit id="bee93e2fd141ac952df7640f626d3d10f1e92fbd" translate="yes" xml:space="preserve">
          <source>A function in the &lt;code&gt;proc_lib&lt;/code&gt; module is to be used to start the process. Several functions are available, for example, &lt;code&gt;spawn_link/3,4&lt;/code&gt; for asynchronous start and &lt;code&gt;start_link/3,4,5&lt;/code&gt; for synchronous start.</source>
          <target state="translated">Функция в модуле &lt;code&gt;proc_lib&lt;/code&gt; должна использоваться для запуска процесса. Доступно несколько функций, например, &lt;code&gt;spawn_link/3,4&lt;/code&gt; для асинхронного запуска и &lt;code&gt;start_link/3,4,5&lt;/code&gt; для синхронного запуска.</target>
        </trans-unit>
        <trans-unit id="1ea8125453a1f5033d8778318612575164d3d3ce" translate="yes" xml:space="preserve">
          <source>A function is called using the &lt;code&gt;M:F&lt;/code&gt; syntax, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are atoms or expressions.</source>
          <target state="translated">Функция вызывается с использованием синтаксиса &lt;code&gt;M:F&lt;/code&gt; , где &lt;code&gt;M&lt;/code&gt; и &lt;code&gt;F&lt;/code&gt; - атомы или выражения.</target>
        </trans-unit>
        <trans-unit id="f874e0a252012bc547a3211dd48e03d0c6554317" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;f&lt;/code&gt; in the module &lt;code&gt;m&lt;/code&gt; and with arity &lt;code&gt;N&lt;/code&gt; is often denoted as &lt;code&gt;m:f/N&lt;/code&gt;.</source>
          <target state="translated">Функция с именем &lt;code&gt;f&lt;/code&gt; в модуле &lt;code&gt;m&lt;/code&gt; и валентности &lt;code&gt;N&lt;/code&gt; часто обозначается как &lt;code&gt;m:f/N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e2076ece482295f13f43d68037c1f2992b8f9a" translate="yes" xml:space="preserve">
          <source>A function not explicitly documented as thread-safe can, at some point in time, have a thread-safe implementation in the runtime system. Such an implementation can however change to a thread &lt;strong&gt;unsafe&lt;/strong&gt; implementation at any time &lt;strong&gt;without any notice&lt;/strong&gt;.</source>
          <target state="translated">Функция, явно не задокументированная как потокобезопасная, может в какой-то момент иметь поточно-ориентированную реализацию в системе времени выполнения. Однако такая реализация может измениться на &lt;strong&gt;небезопасную&lt;/strong&gt; для потока реализацию в любое время &lt;strong&gt;без какого-либо уведомления&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ad55a8c4f2fdc2e2ad52ed3c0264567f558d6c9a" translate="yes" xml:space="preserve">
          <source>A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, and the reply is returned as value of the current call to the sort or merge function.</source>
          <target state="translated">В качестве вывода может быть указана функция одного аргумента. Результаты сортировки или объединения входных данных собираются в непустую последовательность списков переменной длины двоичных файлов или терминов в зависимости от формата. Функция вывода вызывается с одним списком за раз, и предполагается, что она возвращает новую функцию вывода. Любое другое возвращаемое значение немедленно возвращается как значение текущего вызова функции сортировки или слияния. Каждая функция вывода вызывается ровно один раз. Когда какая-либо функция вывода была применена ко всем результатам или возникает ошибка, последняя функция вызывается с аргументом &lt;code&gt;close&lt;/code&gt; , и ответ возвращается как значение текущего вызова функции сортировки или слияния.</target>
        </trans-unit>
        <trans-unit id="59fe57d80e3ef9db4ebd49c663824a7be50c8252" translate="yes" xml:space="preserve">
          <source>A function specification can be overloaded. That is, it can have several types, separated by a semicolon (&lt;code&gt;;&lt;/code&gt;):</source>
          <target state="translated">Спецификация функции может быть перегружена. То есть он может иметь несколько типов, разделенных точкой с запятой ( &lt;code&gt;;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="fa95908fabb759c7e5694e79bc74d7fa4cb9cab8" translate="yes" xml:space="preserve">
          <source>A function that adds a family to the database can be written as follows if there is a structure &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt;:</source>
          <target state="translated">Функцию, которая добавляет семью в базу данных, можно записать следующим образом, если есть структура &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd3a3a3eaa7687c88a4600f70861728b853757b4" translate="yes" xml:space="preserve">
          <source>A function that is intended to be traced.</source>
          <target state="translated">Функция,которая предназначена для отслеживания.</target>
        </trans-unit>
        <trans-unit id="84f14d74551f2c944f4c5fc40a31a1120c5642d9" translate="yes" xml:space="preserve">
          <source>A function type Ft is one of the following:</source>
          <target state="translated">Тип функции Ft является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="f2ed1d7e05b7d9f3e384891d361b5e9e23e3a041" translate="yes" xml:space="preserve">
          <source>A function which has been called with &lt;code&gt;is_set_ok&lt;/code&gt; will be called again, either with &lt;code&gt;set&lt;/code&gt; if there was no error, or with &lt;code&gt;undo&lt;/code&gt;, if an error occurred. In this way, resources can be reserved in the &lt;code&gt;is_set_ok&lt;/code&gt; operation, released in the &lt;code&gt;undo&lt;/code&gt; operation, or made permanent in the &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">Функция, которая была вызвана с &lt;code&gt;is_set_ok&lt;/code&gt; , будет вызвана снова, либо с &lt;code&gt;set&lt;/code&gt; , если ошибки не было, либо с &lt;code&gt;undo&lt;/code&gt; , если ошибка произошла. Таким образом, ресурсы могут быть зарезервированы в операции &lt;code&gt;is_set_ok&lt;/code&gt; , освобождены в операции &lt;code&gt;undo&lt;/code&gt; или сделаны постоянными в операции &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd8be8e88421b65c5785dda3b74a299c4437c971" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test()&lt;/code&gt; is recognized by EUnit as a simple test function - it takes no arguments, and its execution either succeeds (returning some arbitrary value that EUnit will throw away), or fails by throwing an exception of some kind (or by not terminating, in which case it will be aborted after a while).</source>
          <target state="translated">Функция с именем, заканчивающимся на &lt;code&gt;..._test()&lt;/code&gt; , распознается EUnit как простая тестовая функция - она ​​не принимает аргументов, и ее выполнение либо завершается успешно (возвращает какое-то произвольное значение, которое EUnit отбрасывает), либо завершается ошибкой, бросая исключение какого-либо вида (или невыполнение, в этом случае оно будет прервано через некоторое время).</target>
        </trans-unit>
        <trans-unit id="6cb5bb4750e96bdf1cb4a018b0ae8f0c42348f8c" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test_()&lt;/code&gt; (note the final underscore) is recognized by EUnit as a &lt;strong&gt;test generator&lt;/strong&gt; function. Test generators return a &lt;strong&gt;representation&lt;/strong&gt; of a &lt;strong&gt;set of tests&lt;/strong&gt; to be executed by EUnit.</source>
          <target state="translated">Функция с именем, оканчивающимся на &lt;code&gt;..._test_()&lt;/code&gt; (обратите внимание на последнее подчеркивание), распознается EUnit как функция &lt;strong&gt;генератора тестов&lt;/strong&gt; . Испытательные генераторы возвращают &lt;strong&gt;представление&lt;/strong&gt; о &lt;strong&gt;наборе тестов&lt;/strong&gt; , которые будут выполняться EUnit.</target>
        </trans-unit>
        <trans-unit id="1a48507b735622ceff0ef19da321ab8f330d7565" translate="yes" xml:space="preserve">
          <source>A functional interface to system messages.</source>
          <target state="translated">Функциональный интерфейс к системным сообщениям.</target>
        </trans-unit>
        <trans-unit id="5718538818085276e24476684d081fe2c16ac1e8" translate="yes" xml:space="preserve">
          <source>A functional object (fun) is called.</source>
          <target state="translated">Называется функциональный объект (веселье).</target>
        </trans-unit>
        <trans-unit id="a77ae01d0047b90d93e3127e8ab05f3c2f271265" translate="yes" xml:space="preserve">
          <source>A functional, extendible array. The representation is not documented and is subject to change without notice. Notice that arrays cannot be directly compared for equality.</source>
          <target state="translated">Функциональный,расширяемый массив.Представление не документировано и может быть изменено без предварительного уведомления.Обратите внимание,что массивы нельзя напрямую сравнивать для равенства.</target>
        </trans-unit>
        <trans-unit id="54ada27e365cb4a22611cb6a9989b7fa6327cde2" translate="yes" xml:space="preserve">
          <source>A general balanced set iterator.</source>
          <target state="translated">Общий сбалансированный итератор.</target>
        </trans-unit>
        <trans-unit id="abd2d7ccb70af9192a88e9078363ed031f3357e6" translate="yes" xml:space="preserve">
          <source>A general balanced set.</source>
          <target state="translated">Общий сбалансированный набор.</target>
        </trans-unit>
        <trans-unit id="8cf5f3092481aa2537de6a0b5a55a3c05a0431e5" translate="yes" xml:space="preserve">
          <source>A general balanced tree iterator.</source>
          <target state="translated">Общий уравновешенный итератор деревьев.</target>
        </trans-unit>
        <trans-unit id="9983fa582405ead1dae547bcbe84a7f86c9c2c6a" translate="yes" xml:space="preserve">
          <source>A general balanced tree.</source>
          <target state="translated">Общее сбалансированное дерево.</target>
        </trans-unit>
        <trans-unit id="ef9ed8ddc12844f0870bb4f089487a9445710baf" translate="yes" xml:space="preserve">
          <source>A general function for creating Erlang terms using a format specifier and a corresponding set of arguments, much in the way &lt;code&gt;printf()&lt;/code&gt; works.</source>
          <target state="translated">Общая функция для создания терминов Erlang с использованием спецификатора формата и соответствующего набора аргументов, во многом &lt;code&gt;printf()&lt;/code&gt; принципу работы printf () .</target>
        </trans-unit>
        <trans-unit id="2e207a92b9beca5dbcb01f63b66742b4b78e66b3" translate="yes" xml:space="preserve">
          <source>A general function for retrieving any kind of object from the registry.</source>
          <target state="translated">Общая функция для получения любого типа объектов из реестра.</target>
        </trans-unit>
        <trans-unit id="59cb7a53195dd959efa385b2b1d8e6b04a5e665a" translate="yes" xml:space="preserve">
          <source>A generated error is when the code itself calls &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;throw/1&lt;/code&gt;. Notice that emulated run-time errors are not denoted as generated errors here.</source>
          <target state="translated">Сгенерированная ошибка возникает, когда сам код вызывает &lt;code&gt;exit/1&lt;/code&gt; или &lt;code&gt;throw/1&lt;/code&gt; . Обратите внимание, что эмулируемые ошибки времени выполнения здесь не обозначаются как сгенерированные ошибки.</target>
        </trans-unit>
        <trans-unit id="8faf45d14b7e5fe4683d094888fbeeed4fc63af0" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library.</source>
          <target state="translated">Общая симпатичная библиотека принтеров.</target>
        </trans-unit>
        <trans-unit id="96309c20b89273ad4e96e038b104fd007caed27f" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library. This module uses a strict-style context passing implementation of John Hughes algorithm, described in &quot;The design of a Pretty-printing Library&quot;. The paragraph-style formatting, empty documents, floating documents, and null strings are my own additions to the algorithm.</source>
          <target state="translated">Общая симпатичная библиотека принтеров.В этом модуле используется реализация алгоритма Джона Хьюза,описанного в &quot;Дизайн библиотеки красивых принтеров&quot;,в строгом стиле.Форматирование в стиле абзаца,пустые документы,плавающие документы и нулевые строки-это мои собственные дополнения к алгоритму.</target>
        </trans-unit>
        <trans-unit id="ac6a4400b941cc8bdd539f01f5213eda72cb86dc" translate="yes" xml:space="preserve">
          <source>A generic single object compare-and-swap operation:</source>
          <target state="translated">Общая операция сравнения и замены одного объекта:</target>
        </trans-unit>
        <trans-unit id="3f766bd2ae406c1622999afa0312a1512bd99928" translate="yes" xml:space="preserve">
          <source>A generic state machine process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">Общий процесс &lt;code&gt;gen_statem&lt;/code&gt; автомата ( gen_statem ), реализованный с помощью этого модуля, имеет стандартный набор интерфейсных функций и включает в себя функции для отслеживания и сообщения об ошибках. Он также вписывается в дерево контроля OTP. Для получения дополнительной информации см. &lt;code&gt;OTP Design Principles&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a97b266d23ce2fe3a69cfab0ece23a4c06694585" translate="yes" xml:space="preserve">
          <source>A global group defined with &lt;code&gt;PublishType&lt;/code&gt; equal to &lt;code&gt;hidden&lt;/code&gt; is said to be a hidden global group. All nodes in a hidden global group are hidden nodes, whether they are started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; or not.</source>
          <target state="translated">Глобальная группа, определенная с &lt;code&gt;PublishType&lt;/code&gt; , равным &lt;code&gt;hidden&lt;/code&gt; , называется скрытой глобальной группой. Все узлы в скрытой глобальной группе являются скрытыми узлами, независимо от того, запущены они с флагом командной строки &lt;code&gt;-hidden&lt;/code&gt; или нет.</target>
        </trans-unit>
        <trans-unit id="be16c14a618ebfab9ed6b6a24231e3d1ce85555b" translate="yes" xml:space="preserve">
          <source>A global name registration facility.</source>
          <target state="translated">Глобальный центр регистрации имен.</target>
        </trans-unit>
        <trans-unit id="5ca996b1105de3e2c7c27a0f7cfb576400f98429" translate="yes" xml:space="preserve">
          <source>A global trace flag for the Erlang node that makes all trace time stamps using flag &lt;code&gt;timestamp&lt;/code&gt; to be in CPU time, not wall clock time. That is, &lt;code&gt;cpu_timestamp&lt;/code&gt; is not be used if &lt;code&gt;monotonic_timestamp&lt;/code&gt; or &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; is enabled. Only allowed with &lt;code&gt;PidPortSpec==all&lt;/code&gt;. If the host machine OS does not support high-resolution CPU time measurements, &lt;code&gt;trace/3&lt;/code&gt; exits with &lt;code&gt;badarg&lt;/code&gt;. Notice that most OS do not synchronize this value across cores, so be prepared that time can seem to go backwards when using this option.</source>
          <target state="translated">Флаг глобальной трассировки для узла Erlang, который делает все метки времени трассировки, используя &lt;code&gt;timestamp&lt;/code&gt; флага, во времени процессора, а не времени настенных часов. То есть, &lt;code&gt;cpu_timestamp&lt;/code&gt; не будет использоваться , если &lt;code&gt;monotonic_timestamp&lt;/code&gt; или &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; включена. Разрешено только с &lt;code&gt;PidPortSpec==all&lt;/code&gt; . Если ОС хост-машины не поддерживает измерения времени ЦП с высоким разрешением, &lt;code&gt;trace/3&lt;/code&gt; завершается с помощью &lt;code&gt;badarg&lt;/code&gt; . Обратите внимание, что большинство ОС не синхронизируют это значение между ядрами, поэтому будьте готовы к тому, что при использовании этой опции время может идти в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="a35f6209ff3e97a1fbff24a3ba0f5b7de01c5979" translate="yes" xml:space="preserve">
          <source>A good book explaining those reference texts is Dubuisson: ASN.1 - Communication Between Heterogeneous Systems, is free to download at &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Хорошая книга, объясняющая эти справочные тексты, - это Дубюиссон: ASN.1 - Связь между гетерогенными системами, которую можно бесплатно загрузить с &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb427e2a68f8e5f95a66a1dfb82ade3b982ce6f" translate="yes" xml:space="preserve">
          <source>A good start when programming efficiently is to know how much memory different data types and operations require. It is implementation-dependent how much memory the Erlang data types and other items consume, but the following table shows some figures for the &lt;code&gt;erts-8.0&lt;/code&gt; system in OTP 19.0.</source>
          <target state="translated">Хорошее начало для эффективного программирования - это знать, сколько памяти требуется для различных типов данных и операций. &lt;code&gt;erts-8.0&lt;/code&gt; памяти, потребляемой типами данных Erlang и другими элементами, зависит от реализации, но в следующей таблице показаны некоторые цифры для системы erts-8.0 в OTP 19.0.</target>
        </trans-unit>
        <trans-unit id="104d4b7a2a11dda4f50138a2b0c530944556b6b2" translate="yes" xml:space="preserve">
          <source>A good way to check if more IO poll threads are needed is to use &lt;code&gt;microstate accounting&lt;/code&gt; and see what the load of the IO poll thread is. If it is high it could be a good idea to add more threads.</source>
          <target state="translated">Хороший способ проверить, нужны ли дополнительные потоки опроса ввода-вывода, - использовать &lt;code&gt;microstate accounting&lt;/code&gt; и посмотреть, какова нагрузка потока опроса ввода-вывода. Если он высокий, неплохо было бы добавить больше потоков.</target>
        </trans-unit>
        <trans-unit id="902246acf44b902caba68cbdbd165ab3a85407bd" translate="yes" xml:space="preserve">
          <source>A grammar to parse list expressions (with empty associated code):</source>
          <target state="translated">Грамматика для разбора выражений списка (с пустым ассоциированным кодом):</target>
        </trans-unit>
        <trans-unit id="1046b82d616c92a5ac3eba8ae29c8d175e6a998a" translate="yes" xml:space="preserve">
          <source>A group nested under a parallel group starts executing in parallel with previous (parallel) test cases (no matter what properties the nested group has). However, as test cases are never executed in parallel with &lt;code&gt;init_per_group/2&lt;/code&gt; or &lt;code&gt;end_per_group/2&lt;/code&gt; of the same group, it is only after a nested group has finished that remaining parallel cases in the previous group become spawned.</source>
          <target state="translated">Группа, вложенная в параллельную группу, начинает выполняться параллельно с предыдущими (параллельными) тестовыми примерами (независимо от того, какие свойства вложенная группа имеет). Однако, поскольку тестовые примеры никогда не выполняются параллельно с &lt;code&gt;init_per_group/2&lt;/code&gt; или &lt;code&gt;end_per_group/2&lt;/code&gt; той же группы, только после завершения вложенной группы создаются оставшиеся параллельные случаи в предыдущей группе.</target>
        </trans-unit>
        <trans-unit id="2bac3d793bd4b0481740f078d1dd54e8fa1f7130" translate="yes" xml:space="preserve">
          <source>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</source>
          <target state="translated">Внутри транзакции может быть вызвана группа функций или процессов.Транзакция может включать в себя операторы чтения,записи или удаления данных из СУБД.Многие такие транзакции могут выполняться одновременно,и программисту нет необходимости явно синхронизировать процессы,манипулирующие данными.</target>
        </trans-unit>
        <trans-unit id="05cb23555bdd306501c7337362942fb611d143f7" translate="yes" xml:space="preserve">
          <source>A group of processes can be accessed by a common name. For example, if there is a group named &lt;code&gt;foobar&lt;/code&gt;, there can be a set of processes (which can be located on different nodes) that are all members of the group &lt;code&gt;foobar&lt;/code&gt;. There are no special functions for sending a message to the group. Instead, client functions are to be written with the functions &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; to determine which processes are members of the group. Then the message can be sent to one or more group members.</source>
          <target state="translated">Доступ к группе процессов можно получить по общему имени. Например, если есть группа с именем &lt;code&gt;foobar&lt;/code&gt; , может быть набор процессов (которые могут быть расположены на разных узлах), которые все являются членами группы &lt;code&gt;foobar&lt;/code&gt; . Специальных функций для отправки сообщения группе нет. Вместо этого клиентские функции должны быть написаны с функциями &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; , чтобы определить, какие процессы являются членами группы. Затем сообщение можно отправить одному или нескольким участникам группы.</target>
        </trans-unit>
        <trans-unit id="5a3229fa1db1fe8eed7e1f7d567d0b55b01718ab" translate="yes" xml:space="preserve">
          <source>A group that starts with (?| resets the capturing parentheses numbers in each alternative (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt;). The assertions at the start of each branch check the next UTF-8 character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of the character are then captured by the appropriate number of groups.</source>
          <target state="translated">Группа, которая начинается с (? | &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; числа в скобках для записи в каждой альтернативе (см. Раздел &amp;laquo; Дублированные номера подшаблонов&amp;raquo; ). Утверждения в начале каждой ветви проверяют следующий символ UTF-8 на предмет значений, в кодировке которых используются 1, 2, 3, или 4 байта, соответственно. Затем отдельные байты символа захватываются соответствующим количеством групп.</target>
        </trans-unit>
        <trans-unit id="6db07dc0cd651815b5c72435ed2208f519f62680" translate="yes" xml:space="preserve">
          <source>A guard G is a non-empty sequence of guard tests &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt;, and Rep(G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt; G - это непустая последовательность проверок защиты Gt_1, ..., Gt_k и Rep (G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9da1b8fcba29590ca36e99b9fdb91354688f306d" translate="yes" xml:space="preserve">
          <source>A guard sequence Gs is a sequence of guards &lt;code&gt;G_1; ...; G_k&lt;/code&gt;, and Rep(Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt;. If the guard sequence is empty, then Rep(Gs) = &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Охранная последовательность Gs - это последовательность охранников &lt;code&gt;G_1; ...; G_k&lt;/code&gt; и Rep (Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt; . Если защитная последовательность пуста, то Rep (Gs) = &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e607c9ab56bd394d6c9eeddb457df24a34026a6" translate="yes" xml:space="preserve">
          <source>A guard test Gt is one of the following:</source>
          <target state="translated">Тест на охрану Gt-один из следующих:</target>
        </trans-unit>
        <trans-unit id="0958ebfcb794773c3476244fc72f207f83085686" translate="yes" xml:space="preserve">
          <source>A handle to driver-specific data, passed to the driver callbacks. It is a pointer, and is most often type cast to a specific pointer in the driver.</source>
          <target state="translated">Ручка с данными,специфичными для водителя,передаваемая водителю для обратного вызова.Это указатель,который чаще всего приводится к конкретному указателю в драйвере.</target>
        </trans-unit>
        <trans-unit id="fdc243bdb933b5a71a48ce564407f75cabaaebaf" translate="yes" xml:space="preserve">
          <source>A handler callback module must export:</source>
          <target state="translated">Модуль обратного вызова обработчика должен экспортироваться:</target>
        </trans-unit>
        <trans-unit id="31be10ebd1dea0e036e6cc2ff50b43986eb9b610" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="translated">Обработчик можно удалить, вызвав &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt; вызывает HModule: remove_handler (Config) и удаляет конфигурацию обработчика из базы данных конфигурации.</target>
        </trans-unit>
        <trans-unit id="8b450cb00cc7d0fceaaaa8e163bad6a1a09d773b" translate="yes" xml:space="preserve">
          <source>A handler is defined as a module exporting at least the following callback function:</source>
          <target state="translated">Обработчик определяется как модуль,экспортирующий,по крайней мере,следующую функцию обратного вызова:</target>
        </trans-unit>
        <trans-unit id="a23d43ddf6d207f81a92e3f11ea5d88e0322baa2" translate="yes" xml:space="preserve">
          <source>A hidden node is a node started with the command-line flag &lt;code&gt;-hidden&lt;/code&gt;. Connections between hidden nodes and other nodes are not transitive, they must be set up explicitly. Also, hidden nodes does not show up in the list of nodes returned by &lt;code&gt;nodes()&lt;/code&gt;. Instead, &lt;code&gt;nodes(hidden)&lt;/code&gt; or &lt;code&gt;nodes(connected)&lt;/code&gt; must be used. This means, for example, that the hidden node is not added to the set of nodes that &lt;code&gt;global&lt;/code&gt; is keeping track of.</source>
          <target state="translated">Скрытый узел - это узел, запущенный с флагом командной строки &lt;code&gt;-hidden&lt;/code&gt; . Связи между скрытыми узлами и другими узлами не являются транзитивными, они должны быть установлены явно. Кроме того, скрытые узлы не отображаются в списке узлов, возвращаемом &lt;code&gt;nodes()&lt;/code&gt; . Вместо этого должны использоваться &lt;code&gt;nodes(hidden)&lt;/code&gt; или &lt;code&gt;nodes(connected)&lt;/code&gt; . Это означает, например, что скрытый узел не добавляется к набору узлов, которые отслеживает &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad527cdee0b441182ba0bc41ca62d2081d24f24" translate="yes" xml:space="preserve">
          <source>A histogram of block sizes where each interval's upper bound is twice as high as the one before it.</source>
          <target state="translated">Гистограмма размеров блоков,где верхняя граница каждого интервала в два раза больше,чем перед ним.</target>
        </trans-unit>
        <trans-unit id="ad63f98e4ec8a5df7f88023c80bfbc7bf7d5bd26" translate="yes" xml:space="preserve">
          <source>A hook function (cf. the &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; type) is passed the current syntax tree node, the context, and a continuation. The context can be examined and manipulated by functions such as &lt;code&gt;get_ctxt_user/1&lt;/code&gt; and &lt;code&gt;set_ctxt_user/2&lt;/code&gt;. The hook must return a &quot;document&quot; data structure (see &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt;); this may be constructed in part or in whole by applying the continuation function. For example, the following is a trivial hook:</source>
          <target state="translated">Перехватывающей функции (см. Тип &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; ) передается текущий узел синтаксического дерева, контекст и продолжение. Контекст можно исследовать и управлять такими функциями, как &lt;code&gt;get_ctxt_user/1&lt;/code&gt; и &lt;code&gt;set_ctxt_user/2&lt;/code&gt; . Ловушка должна возвращать структуру данных &amp;laquo;документ&amp;raquo; (см. &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt; ); это можно построить частично или полностью, применив функцию продолжения. Например, вот простой хук:</target>
        </trans-unit>
        <trans-unit id="1edf358d74594d5d0d07749392202e53a874bde3" translate="yes" xml:space="preserve">
          <source>A job that alternates between I/O bound and CPU bound can be reclassified and rescheduled using &lt;code&gt;enif_schedule_nif&lt;/code&gt; so that it executes on the correct type of dirty scheduler at all times. For more information see the documentation of the &lt;code&gt;erl(1)&lt;/code&gt; command line arguments &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Задание, которое чередуется между привязкой ввода-вывода и привязкой к ЦП, может быть переклассифицировано и перепланировано с помощью &lt;code&gt;enif_schedule_nif&lt;/code&gt; , чтобы оно всегда выполнялось в правильном типе грязного планировщика. Для получения дополнительной информации см. Документацию по аргументам командной строки &lt;code&gt;erl(1)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58867f002dc318ccf9bce1131e2694062d5333ed" translate="yes" xml:space="preserve">
          <source>A larger buffer limit allows processes to buffer more outgoing messages over the distribution. When the buffer limit has been reached, sending processes will be suspended until the buffer size has shrunk. The buffer limit is per distribution channel. A higher limit gives lower latency and higher throughput at the expense of higher memory use.</source>
          <target state="translated">Большой лимит буфера позволяет процессам буферировать больше исходящих сообщений над дистрибутивом.Когда лимит буфера достигнут,отправка процессов будет приостановлена до тех пор,пока размер буфера не уменьшится.Лимит буфера устанавливается для каждого канала рассылки.Более высокий лимит дает меньшую задержку и большую пропускную способность за счет большего использования памяти.</target>
        </trans-unit>
        <trans-unit id="06a81726c24b8781e74e0cf024d9ccac67383c44" translate="yes" xml:space="preserve">
          <source>A level in term &lt;code&gt;CpuTopology&lt;/code&gt; can be omitted if only one entry exists and &lt;code&gt;InfoList&lt;/code&gt; is empty.</source>
          <target state="translated">Уровень в термине &lt;code&gt;CpuTopology&lt;/code&gt; может быть опущен, если существует только одна запись и &lt;code&gt;InfoList&lt;/code&gt; пуст.</target>
        </trans-unit>
        <trans-unit id="dce227656c4a97473171d894829d7b5055a34016" translate="yes" xml:space="preserve">
          <source>A library application that cannot be started or stopped, does not need any application callback module.</source>
          <target state="translated">Библиотечное приложение,которое не может быть запущено или остановлено,не нуждается в модуле обратного вызова приложения.</target>
        </trans-unit>
        <trans-unit id="f1237e5b11078ec794450ace16c7850dee19ffaa" translate="yes" xml:space="preserve">
          <source>A line breakpoint can also be created (and deleted) by double-clicking the line when the module is displayed in the View Module window or Attach Process window.</source>
          <target state="translated">Точку останова линии также можно создать (и удалить)двойным щелчком мыши на линии,когда модуль отображается в окне View Module или Attach Process.</target>
        </trans-unit>
        <trans-unit id="25e27b31c8e51ff696a72775acff4cd63fac142f" translate="yes" xml:space="preserve">
          <source>A line breakpoint is created at a certain line in a module.</source>
          <target state="translated">Точка останова линии создаётся на определённой линии в модуле.</target>
        </trans-unit>
        <trans-unit id="98ca655fbbfd2af69c799f1de396c9692c8ffecf" translate="yes" xml:space="preserve">
          <source>A line level calls analysis of &lt;code&gt;channel&lt;/code&gt; can be written to a file using &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt;:</source>
          <target state="translated">Анализ вызовов на уровне линии &lt;code&gt;channel&lt;/code&gt; может быть записана в файл с помощью &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="30f9e5debe76dcfd36d855503d282295078ca73b" translate="yes" xml:space="preserve">
          <source>A link can be removed by calling the BIF &lt;code&gt;unlink(Pid)&lt;/code&gt;.</source>
          <target state="translated">Ссылку можно удалить, вызвав BIF &lt;code&gt;unlink(Pid)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b621ff75576ed0db731737d0b2db8dd71853fd" translate="yes" xml:space="preserve">
          <source>A link existed between the local process and the remote process at the time of the crash.</source>
          <target state="translated">В момент аварии существовала связь между локальным процессом и удаленным процессом.</target>
        </trans-unit>
        <trans-unit id="71334f2a43a0426d62a5d4505c43986a1e04107a" translate="yes" xml:space="preserve">
          <source>A link is broken. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes, and &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; contains the reason for the exit.</source>
          <target state="translated">Ссылка не работает. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; и &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; содержат идентификаторы связанных процессов, а &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; - причину выхода.</target>
        </trans-unit>
        <trans-unit id="f6d5b20cc777398a2954a5f904e0c368fb34c735" translate="yes" xml:space="preserve">
          <source>A link to all runs executed from a certain directory is written in the log named &lt;code&gt;all_runs.html&lt;/code&gt; and direct links to all tests (the latest results) are written to the top-level &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">Ссылка на все &lt;code&gt;all_runs.html&lt;/code&gt; выполняемые из определенного каталога, записывается в журнал с именем all_runs.html, а прямые ссылки на все тесты (последние результаты) записываются в &lt;code&gt;index.html&lt;/code&gt; верхнего уровня .</target>
        </trans-unit>
        <trans-unit id="c9ed186e6c9cb98bafec7585f14769f53a755b9c" translate="yes" xml:space="preserve">
          <source>A list comprehension returns a list, where the elements are the result of evaluating &lt;code&gt;Expr&lt;/code&gt; for each combination of generator list elements and bit string generator elements, for which all filters are true.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; списка возвращает список, элементы которого являются результатом вычисления Expr для каждой комбинации элементов списка генератора и элементов генератора битовой строки, для которых все фильтры истинны.</target>
        </trans-unit>
        <trans-unit id="02a87e72df2e9591f46019f9ed75098ceee2e35d" translate="yes" xml:space="preserve">
          <source>A list comprehension:</source>
          <target state="translated">Понимание списка:</target>
        </trans-unit>
        <trans-unit id="7085d8980ae301152b6ee803668c44a99ddba230" translate="yes" xml:space="preserve">
          <source>A list is a compound data type with a variable number of terms.</source>
          <target state="translated">Список-это составной тип данных с переменным количеством терминов.</target>
        </trans-unit>
        <trans-unit id="cdf78c94ee3134a5064c3958c1d7c8e4a3de8736" translate="yes" xml:space="preserve">
          <source>A list must be specified with the number of elements, including the tail, which is the last term preceding &lt;code&gt;ERL_DRV_LIST&lt;/code&gt;.</source>
          <target state="translated">Список должен быть указан с количеством элементов, включая хвост, который является последним термином, предшествующим &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70b8617890707dfd903ea1026d415236f1bdc921" translate="yes" xml:space="preserve">
          <source>A list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">Список записей 'ActionReply',возможно,содержащих указания на ошибку.</target>
        </trans-unit>
        <trans-unit id="51c375d52fb989d38f521acbea65939966bc14e9" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;UpdateOp&lt;/code&gt; can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done.</source>
          <target state="translated">Список &lt;code&gt;UpdateOp&lt;/code&gt; может быть предоставлен для выполнения множества операций обновления внутри объекта. Операции выполняются в порядке, указанном в списке. Если одна и та же позиция счетчика встречается в списке более одного раза, соответствующий счетчик, таким образом, обновляется много раз, каждый раз на основе предыдущего результата. Возвращаемое значение - это список новых значений счетчика от каждой операции обновления в том же порядке, что и в списке операций. Если указан пустой список, ничего не обновляется и возвращается пустой список. Если функция не работает, обновления не выполняются.</target>
        </trans-unit>
        <trans-unit id="030f0cbd94947cdf93b77d371b60c32ef8fca036" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Memory}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Memory&lt;/code&gt; is how much memory it occupies</source>
          <target state="translated">Список кортежей &lt;code&gt;{Name, Memory}&lt;/code&gt; , где &lt;code&gt;Name&lt;/code&gt; - это &lt;code&gt;Name&lt;/code&gt; фрагмента , а &lt;code&gt;Memory&lt;/code&gt; - сколько памяти он занимает.</target>
        </trans-unit>
        <trans-unit id="c72f78c95adc9eeb9cf8ccea551cf18350671fbd" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Size}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Size&lt;/code&gt; is how many records it contains</source>
          <target state="translated">Список кортежей &lt;code&gt;{Name, Size}&lt;/code&gt; , где &lt;code&gt;Name&lt;/code&gt; - это &lt;code&gt;Name&lt;/code&gt; фрагмента , а &lt;code&gt;Size&lt;/code&gt; - количество записей, которые он содержит</target>
        </trans-unit>
        <trans-unit id="e2180b4c9facbabd3ef7f26e9137ff364cfb6bb1" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Pos,Value}&lt;/code&gt; can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results.</source>
          <target state="translated">Список &lt;code&gt;{Pos,Value}&lt;/code&gt; может быть предоставлен для обновления многих элементов в одном объекте. Если одна и та же позиция встречается в списке более одного раза, записывается последнее значение в списке. Если список пуст или функция не работает, обновления не выполняются. Функция также является атомарной в том смысле, что другие процессы никогда не могут увидеть никаких промежуточных результатов.</target>
        </trans-unit>
        <trans-unit id="b3c0a15b7c94f033790cb5a9578215ba2c5eb2b7" translate="yes" xml:space="preserve">
          <source>A list of &lt;strong&gt;release upgrade instructions&lt;/strong&gt;, see &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt;. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by &lt;code&gt;systools&lt;/code&gt; when creating the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">Список &lt;strong&gt;инструкций по обновлению выпуска&lt;/strong&gt; см. В разделе &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt; . Рекомендуется использовать только инструкции высокого уровня. Они автоматически переводятся в инструкции низкого уровня с помощью программных &lt;code&gt;systools&lt;/code&gt; при создании файла &lt;code&gt;relup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9313069dff4ca94cf23c29546a7ad4ed8220831c" translate="yes" xml:space="preserve">
          <source>A list of DER-encoded certificates in trust order ending with the peer certificate.</source>
          <target state="translated">Список сертификатов с DER-кодировкой в порядке доверия,заканчивающийся сертификатом &quot;равный-равному&quot;.</target>
        </trans-unit>
        <trans-unit id="cfdc5fa9c2f2d452137349f08f0ebdc7cd06e86e" translate="yes" xml:space="preserve">
          <source>A list of active checkpoints can be obtained with the following functions:</source>
          <target state="translated">Список активных контрольно-пропускных пунктов можно получить с помощью следующих функций:</target>
        </trans-unit>
        <trans-unit id="22e1cd424af636813424f38dcaf9d38efccd215c" translate="yes" xml:space="preserve">
          <source>A list of all valid Erlang Top configuration parameters is available in module &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Список всех допустимых параметров конфигурации Erlang Top доступен в модуле &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84f87e145849ab0fff970812ed60b4958a7995b9" translate="yes" xml:space="preserve">
          <source>A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the dictionary of the application in question. At decode, such AVPs are represented as diameter_avp records in the &lt;code&gt;'AVP'&lt;/code&gt; field of a decoded message or Grouped AVP, the first alternate that succeeds in decoding the AVP setting the record's value field. At encode, values in an &lt;code&gt;'AVP'&lt;/code&gt; list can be passed as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of such a tuple.</source>
          <target state="translated">Список альтернативных словарных модулей, с помощью которых можно кодировать / декодировать AVP, которые не определены в словаре рассматриваемого приложения. При декодировании такие AVP представлены в виде записей Diameter_avp в поле &lt;code&gt;'AVP'&lt;/code&gt; декодированного сообщения или Grouped AVP, первой альтернативы, которая успешно декодирует AVP, устанавливающую поле значения записи. При кодировании значения в списке &lt;code&gt;'AVP'&lt;/code&gt; могут быть переданы как 2-кортежи имя / значение AVP, и определение AVP такого кортежа является ошибкой кодирования, поскольку нет альтернативы.</target>
        </trans-unit>
        <trans-unit id="bcb8af967c3f5df09119723a75e7c020769c5e61" translate="yes" xml:space="preserve">
          <source>A list of application versions that the application depends on. An example of such an application version is &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt;. Application versions specified as runtime dependencies are minimum requirements. That is, a larger application version than the one specified in the dependency satisfies the requirement. For information about how to compare application versions, see section &lt;code&gt;Versions&lt;/code&gt; in the System Principles User's Guide.</source>
          <target state="translated">Список версий приложения, от которых оно зависит. Пример такой версии приложения - &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt; . Версии приложения, указанные как зависимости времени выполнения, являются минимальными требованиями. То есть более крупная версия приложения, чем та, которая указана в зависимости, удовлетворяет требованию. Для получения информации о том, как сравнивать версии приложений, см. Раздел &amp;laquo; &lt;code&gt;Versions&lt;/code&gt; в Руководстве пользователя по принципам системы.</target>
        </trans-unit>
        <trans-unit id="85bcb2be6c30593796c07db13b64536f31aab04f" translate="yes" xml:space="preserve">
          <source>A list of applications that are included by an application included in the release. The list must be a subset of the included applications specified in the application resource file (&lt;code&gt;Application.app&lt;/code&gt;) and overrides this value. Defaults to the same value as in the application resource file.</source>
          <target state="translated">Список приложений, которые включены в приложение, включенное в выпуск. Список должен быть подмножеством включенных приложений, указанных в файле ресурсов приложения ( &lt;code&gt;Application.app&lt;/code&gt; ), и переопределять это значение. По умолчанию используется то же значение, что и в файле ресурсов приложения.</target>
        </trans-unit>
        <trans-unit id="73a81a79f1a7098f6cb205944af55c35f111d222" translate="yes" xml:space="preserve">
          <source>A list of atoms corresponding to atoms in the &lt;code&gt;NamedBitList&lt;/code&gt; in the &lt;code&gt;BIT STRING&lt;/code&gt; definition. A &lt;code&gt;BIT STRING&lt;/code&gt; with symbolic names is always decoded to the format shown in the following example:</source>
          <target state="translated">Список атомов, соответствующих атомам в &lt;code&gt;NamedBitList&lt;/code&gt; в определении &lt;code&gt;BIT STRING&lt;/code&gt; . &lt;code&gt;BIT STRING&lt;/code&gt; с символическими именами всегда декодируются в формат , показанном в следующем примере:</target>
        </trans-unit>
        <trans-unit id="4416e89ecd0bec31a83597e47f21c9429cab1bb6" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Список двоичных файлов. Этот тип данных полезно использовать вместе с &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64654646df6b843e592f4468159e2fedaaec3b28" translate="yes" xml:space="preserve">
          <source>A list of functions specified in option &lt;code&gt;Startup&lt;/code&gt; are executed after startup of the node. Notice that all used modules are to be present in the code path on &lt;code&gt;Host&lt;/code&gt;.</source>
          <target state="translated">Список функций, указанных в опции &lt;code&gt;Startup&lt;/code&gt; , выполняется после запуска узла. Обратите внимание, что все используемые модули должны присутствовать в пути кода на &lt;code&gt;Host&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79b9f4cc16d6de8c7e19f996e3ff20895acaba69" translate="yes" xml:space="preserve">
          <source>A list of key-value tuples (that is, a property list) containing runtime configuration data passed from the configuration functions to the test cases.</source>
          <target state="translated">Список кортежей с ключевыми значениями (т.е.список свойств),содержащий данные конфигурации,передаваемые из конфигурационных функций в тестовые случаи.</target>
        </trans-unit>
        <trans-unit id="53072cdf6c2b3e1f0ce0b618f29746a989ccb6e4" translate="yes" xml:space="preserve">
          <source>A list of low-level release upgrade instructions, see &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt;. It consists of the release upgrade instructions from the respective application upgrade files (high-level instructions are translated to low-level instructions), in the same order as in the start script.</source>
          <target state="translated">Список инструкций по обновлению низкоуровневого выпуска см. В &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt; . Он состоит из инструкций по обновлению выпуска из соответствующих файлов обновления приложения (высокоуровневые инструкции переводятся в низкоуровневые инструкции) в том же порядке, что и в стартовом скрипте.</target>
        </trans-unit>
        <trans-unit id="c5458cb9ed4430c9a1044722c1c9f0ec73351850" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Список характеристик соответствия. Пустой список эквивалентен &lt;code&gt;true&lt;/code&gt; . Описание характеристик соответствия см. В разделе &amp;laquo; &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="4f24e9180cc135394011e3f9e98998139bc43ae7" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Список характеристик соответствия. Сопоставление выполняется по списку &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; . &lt;code&gt;Node&lt;/code&gt; - это имя узла отправителя. &lt;code&gt;Sender&lt;/code&gt; - это процесс или идентификатор порта отправителя, или атом &lt;code&gt;undefined&lt;/code&gt; если отправитель неизвестен (что может иметь место для удаленных отправителей). &lt;code&gt;Msg&lt;/code&gt; - это термин сообщения. Доступ к pid принимающего процесса можно получить с помощью функции защиты &lt;code&gt;self/0&lt;/code&gt; . Пустой список соответствует &lt;code&gt;true&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="1ae6c5016a51b941ea9b569f5d1e616278b56ff4" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Список характеристик соответствия. Соответствие выполняется в списке &lt;code&gt;[Receiver, Msg]&lt;/code&gt; . &lt;code&gt;Receiver&lt;/code&gt; - это идентификатор процесса или порта получателя, а &lt;code&gt;Msg&lt;/code&gt; - термин сообщения. Доступ к pid отправляющего процесса можно получить с помощью функции защиты &lt;code&gt;self/0&lt;/code&gt; . Пустой список соответствует &lt;code&gt;true&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="f891abb57f22c043046c0acca9828e5f72f099a9" translate="yes" xml:space="preserve">
          <source>A list of monitors (started by &lt;code&gt;monitor/2&lt;/code&gt;) that are active for the process. For a local process monitor or a remote process monitor by a process identifier, the list consists of:</source>
          <target state="translated">Список мониторов (запущенных &lt;code&gt;monitor/2&lt;/code&gt; ), активных для процесса. Для локального монитора процесса или удаленного монитора процесса по идентификатору процесса список состоит из:</target>
        </trans-unit>
        <trans-unit id="1e09e85b1d23a2d1904ace9e97601c063a94ad34" translate="yes" xml:space="preserve">
          <source>A list of node names (atoms), the group nodes.</source>
          <target state="translated">Список имен узлов (атомов),групповых узлов.</target>
        </trans-unit>
        <trans-unit id="f513e60b833a271eafeea13f285937ef60a9f36a" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes currently synchronized with the local node.</source>
          <target state="translated">Список имен узлов,групповых узлов,синхронизированных в данный момент с локальным узлом.</target>
        </trans-unit>
        <trans-unit id="d5813c5a7e310a9d07043782acc2491f544da810" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes to which there are currently no connections.</source>
          <target state="translated">Список имен узлов,групповых узлов,к которым на данный момент нет подключений.</target>
        </trans-unit>
        <trans-unit id="ede2a365270db1734a514f8930fed986e258eb67" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes with which the local node has failed to synchronize.</source>
          <target state="translated">Список имен узлов,групповых узлов,с которыми локальный узел не смог синхронизироваться.</target>
        </trans-unit>
        <trans-unit id="68320e1e6e32580922546695a30d4ffc50df4758" translate="yes" xml:space="preserve">
          <source>A list of objects and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращается список объектов и продолжение, если таблица не пуста, и в этом случае &lt;code&gt;'$end_of_table'&lt;/code&gt; . Продолжение должно использоваться при сопоставлении других объектов путем вызова &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795b45a529dceb8a27da1be92835aa76262ca94d" translate="yes" xml:space="preserve">
          <source>A list of pids, specifying the processes that have subscribed to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">Список pid, определяющий процессы, которые подписались на сообщения &lt;code&gt;nodeup&lt;/code&gt; и &lt;code&gt;nodedown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc2862b14b19fa3c52a7c39935bdc51459df8ec" translate="yes" xml:space="preserve">
          <source>A list of process identifiers monitoring the process (with &lt;code&gt;monitor/2&lt;/code&gt;).</source>
          <target state="translated">Список идентификаторов процессов, отслеживающих процесс (с помощью &lt;code&gt;monitor/2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="798f3c6d606c88936e16d8fb3e746a3c0d7e414f" translate="yes" xml:space="preserve">
          <source>A list of start phases and corresponding start arguments for the application. If this key is present, the application master, in addition to the usual call to &lt;code&gt;Module:start/2&lt;/code&gt;, also calls &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; for each start phase defined by key &lt;code&gt;start_phases&lt;/code&gt;. Only after this extended start procedure, &lt;code&gt;application:start(Application)&lt;/code&gt; returns.</source>
          <target state="translated">Список этапов запуска и соответствующие аргументы запуска для приложения. Если этот ключ присутствует, мастер приложения, помимо обычного вызова &lt;code&gt;Module:start/2&lt;/code&gt; , также вызывает &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; для каждой фазы запуска, определенной ключом &lt;code&gt;start_phases&lt;/code&gt; . Только после этой расширенной процедуры &lt;code&gt;application:start(Application)&lt;/code&gt; возвращается application: start (Приложение) .</target>
        </trans-unit>
        <trans-unit id="edf21767ef6072f1fd3b3c1a6a4c7c161dc74414" translate="yes" xml:space="preserve">
          <source>A list of the characters in the matched token.</source>
          <target state="translated">Список символов в соответствующем токене.</target>
        </trans-unit>
        <trans-unit id="8133b9a65a9c55bb804a98f418e83c6fd30bd2dd" translate="yes" xml:space="preserve">
          <source>A list of the nodes that do not exist</source>
          <target state="translated">Список узлов,которые не существуют.</target>
        </trans-unit>
        <trans-unit id="4787cc71f8b45d2d5a1e6a23232994156e3e6848" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server does not exist</source>
          <target state="translated">Список узлов,где нет сервера.</target>
        </trans-unit>
        <trans-unit id="23fbc37251525e0fbe5e6808d56771dd9e1bb61d" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server terminated before sending any reply.</source>
          <target state="translated">Список узлов,на которых сервер прекратил работу до отправки ответа.</target>
        </trans-unit>
        <trans-unit id="86b3af01504c95f1ff0a3bad6e86965e662943b1" translate="yes" xml:space="preserve">
          <source>A list of tokens produced by the scanner should end with a special &lt;code&gt;end_of_input&lt;/code&gt; tuple which the parser is looking for. The format of this tuple should be &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt;, where &lt;code&gt;Endsymbol&lt;/code&gt; is an identifier that is distinguished from all the terminal and non-terminal categories of the syntax rules. The &lt;code&gt;Endsymbol&lt;/code&gt; may be declared in the grammar file (see below).</source>
          <target state="translated">Список токенов, созданный сканером, должен заканчиваться специальным кортежем &lt;code&gt;end_of_input&lt;/code&gt; , который ищет анализатор. Формат этого кортежа должен быть &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt; , где &lt;code&gt;Endsymbol&lt;/code&gt; - это идентификатор, который отличается от всех терминальных и нетерминальных категорий синтаксических правил. &lt;code&gt;Endsymbol&lt;/code&gt; могут быть объявлены в файле грамматики (см . Ниже)</target>
        </trans-unit>
        <trans-unit id="c2109516cde7b07bab03027450759556426aff7c" translate="yes" xml:space="preserve">
          <source>A list of tuples containing results for individual schedulers as well as aggregated averages. &lt;code&gt;Util&lt;/code&gt; is the scheduler utilization as a floating point value between 0.0 and 1.0. &lt;code&gt;Percent&lt;/code&gt; is the same utilization as a more human readable string expressed in percent.</source>
          <target state="translated">Список кортежей, содержащий результаты для отдельных планировщиков, а также агрегированные средние значения. &lt;code&gt;Util&lt;/code&gt; - это использование планировщика в виде значения с плавающей запятой от 0,0 до 1,0. &lt;code&gt;Percent&lt;/code&gt; - это то же использование, что и более удобочитаемая строка, выраженная в процентах.</target>
        </trans-unit>
        <trans-unit id="2ea742332d3293e5cbb6278b7055ef5cb1f029ed" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each function in a module, in decreasing &lt;code&gt;FuncCallCount&lt;/code&gt; order.</source>
          <target state="translated">Список кортежей, по одному для каждой функции в модуле, в порядке убывания &lt;code&gt;FuncCallCount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d414f3936cc6ab0feb3f8f3f242331f59448312d" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each module except &lt;code&gt;cprof&lt;/code&gt;, in decreasing &lt;code&gt;ModCallCount&lt;/code&gt; order.</source>
          <target state="translated">Список кортежей, по одному для каждого модуля, кроме &lt;code&gt;cprof&lt;/code&gt; , в порядке убывания &lt;code&gt;ModCallCount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a515d4554cb24670f64c931a7f1c050e2d9f77e" translate="yes" xml:space="preserve">
          <source>A list representing the tail elements of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Список, представляющий хвостовые элементы списка &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49c534723b00f62164b408805f640dc737cc5620" translate="yes" xml:space="preserve">
          <source>A list sorted as follows:</source>
          <target state="translated">Список отсортирован следующим образом:</target>
        </trans-unit>
        <trans-unit id="f5ef252277490863011469cba50309fcc2a552c0" translate="yes" xml:space="preserve">
          <source>A list where the tail is a list is sometimes called a &lt;strong&gt;proper list&lt;/strong&gt;. It is allowed to have a list where the tail is not a list, for example, &lt;code&gt;[a|b]&lt;/code&gt;. However, this type of list is of little practical use.</source>
          <target state="translated">Список, в котором хвост является списком, иногда называют &lt;strong&gt;правильным списком&lt;/strong&gt; . Допускается иметь список, в котором хвост не является списком, например, &lt;code&gt;[a|b]&lt;/code&gt; . Однако этот тип списка мало пригоден.</target>
        </trans-unit>
        <trans-unit id="efe540ae45894e0fdbc313179169b5e104e7d954" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list Each element can be:</source>
          <target state="translated">Список с таким количеством элементов, как список &lt;code&gt;Cols&lt;/code&gt; . Каждый элемент может быть:</target>
        </trans-unit>
        <trans-unit id="9b2d1080e5c727bcb4180b6c054a8305dfd68dfc" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list, where each element is the value of the corresponding column. Each element can be:</source>
          <target state="translated">Список с таким количеством элементов, как список &lt;code&gt;Cols&lt;/code&gt; , где каждый элемент является значением соответствующего столбца. Каждый элемент может быть:</target>
        </trans-unit>
        <trans-unit id="1f4d38e7e775065b86b76958019e087be5338c72" translate="yes" xml:space="preserve">
          <source>A list with integers &amp;gt; 255 is considered an error if the Unicode translation modifier is not specified:</source>
          <target state="translated">Список с целыми числами&amp;gt; 255 считается ошибкой, если не указан модификатор перевода Unicode:</target>
        </trans-unit>
        <trans-unit id="14565d44a02de06df96d7cafd4c87d042823638e" translate="yes" xml:space="preserve">
          <source>A listbox containing the names of all interpreted modules</source>
          <target state="translated">Окно списка,содержащее имена всех интерпретируемых модулей</target>
        </trans-unit>
        <trans-unit id="d04bc0e41b8be3fc83734efd80c9fb1225163fbf" translate="yes" xml:space="preserve">
          <source>A listening transport presents its information slightly differently since there may be multiple accepted connections for the same &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;transport&lt;/code&gt; info returned by a server with a single client connection might look as follows.</source>
          <target state="translated">Прослушивающий транспорт представляет свою информацию несколько иначе, поскольку для одного и того же &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; может быть несколько принятых соединений . Информация о &lt;code&gt;transport&lt;/code&gt; возвращаемая сервером с одним клиентским подключением, может выглядеть следующим образом.</target>
        </trans-unit>
        <trans-unit id="9f635b77fbd8f2fa61daabd2f18c04196f559460" translate="yes" xml:space="preserve">
          <source>A literal &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Понимание буквального &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17c58bfa57cd941d6af606b21964e3471f8b0dec" translate="yes" xml:space="preserve">
          <source>A literal data character</source>
          <target state="translated">Буквальный характер данных</target>
        </trans-unit>
        <trans-unit id="b9eff8ef6bae96d4d99cb1d0d45944faf85b28e0" translate="yes" xml:space="preserve">
          <source>A literal string can be written instead of an element:</source>
          <target state="translated">Вместо элемента может быть записана буквальная строка:</target>
        </trans-unit>
        <trans-unit id="c5bb25cde669006f83df9c8db3230c71118a01ae" translate="yes" xml:space="preserve">
          <source>A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded, the new module instance needs to load its own NIF library (or maybe choose not to). The new module instance can, however, choose to load the exact same NIF library as the old code if it wants to. Sharing the dynamic library means that static data defined by the library is shared as well. To avoid unintentionally shared static data between module instances, each Erlang module version can keep its own private data. This private data can be set when the NIF library is loaded and later retrieved by calling &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Загруженная библиотека NIF привязана к экземпляру модуля Erlang, который ее загрузил. Если модуль обновлен, новый экземпляр модуля должен загрузить свою собственную библиотеку NIF (или, возможно, выбрать не делать этого). Однако новый экземпляр модуля может выбрать загрузку той же самой библиотеки NIF, что и старый код, если захочет. Совместное использование динамической библиотеки означает, что статические данные, определенные библиотекой, также являются общими. Чтобы избежать непреднамеренного совместного использования статических данных между экземплярами модуля, каждая версия модуля Erlang может хранить свои собственные личные данные. Эти личные данные могут быть установлены при загрузке библиотеки NIF, а затем извлечены путем вызова &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b6d76f899d39de86797bece2df0524e5c5bc58f" translate="yes" xml:space="preserve">
          <source>A log file can be opened more than once by giving different values to option &lt;code&gt;name&lt;/code&gt; or by using the same file when distributing a log on different nodes. It is up to the user of module &lt;code&gt;disk_log&lt;/code&gt; to ensure that not more than one disk log process has write access to any file, otherwise the file can be corrupted.</source>
          <target state="translated">Файл журнала можно открыть более одного раза, задав разные значения &lt;code&gt;name&lt;/code&gt; параметра или используя один и тот же файл при распространении журнала на разные узлы. Пользователь модуля &lt;code&gt;disk_log&lt;/code&gt; должен убедиться, что не более одного процесса журнала диска имеют доступ на запись к любому файлу, иначе файл может быть поврежден.</target>
        </trans-unit>
        <trans-unit id="0f75009c18af2951c814381c778a999ec618f179" translate="yes" xml:space="preserve">
          <source>A log file for one particular test case. Also called the test case log file.</source>
          <target state="translated">Лог-файл для одного конкретного тестового случая.Также называется лог-файл тестового случая.</target>
        </trans-unit>
        <trans-unit id="6a0809efff21f90864c4f42725c904032725ee3b" translate="yes" xml:space="preserve">
          <source>A logical error is when a program does not behave as intended, but does not crash. An example is that nothing happens when a button in a graphical user interface is clicked.</source>
          <target state="translated">Логической ошибкой является то,что программа ведет себя не так,как предполагалось,но не аварийно.Например,ничего не происходит при нажатии кнопки в графическом интерфейсе пользователя.</target>
        </trans-unit>
        <trans-unit id="5ca61b37a0ea4d7b34c40913d6020ff25d24aa5f" translate="yes" xml:space="preserve">
          <source>A long queue of requests can cause a user-perceived delay, as earlier requests can take a long time to complete. The HTTP/1.1 specification suggests a limit of two persistent connections per server, which is the default value of option &lt;code&gt;max_sessions&lt;/code&gt;.</source>
          <target state="translated">Длинная очередь запросов может вызвать задержку, воспринимаемую пользователем, поскольку выполнение более ранних запросов может занять много времени. Спецификация HTTP / 1.1 предлагает ограничение в два постоянных соединения на сервер, что является значением по умолчанию для параметра &lt;code&gt;max_sessions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4935bb183b98bea21599c5ff3981cab6721e4f54" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;, where all occurrences of a variable &lt;code&gt;Var&lt;/code&gt; from the macro definition are replaced with the corresponding argument &lt;code&gt;Arg&lt;/code&gt;.</source>
          <target state="translated">Макрос &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; заменяется на &lt;code&gt;Replacement&lt;/code&gt; , где все вхождения переменной &lt;code&gt;Var&lt;/code&gt; из определения макроса заменяются соответствующим аргументом &lt;code&gt;Arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d257ea7c2cd44ef76446306fb9244bed68bdcdf" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; with a (possibly empty) list of arguments results in an error message if there is at least one definition of &lt;code&gt;Func&lt;/code&gt; with arguments, but none with N arguments.</source>
          <target state="translated">Макрос &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; с (возможно, пустым) списком аргументов приводит к сообщению об ошибке, если существует хотя бы одно определение &lt;code&gt;Func&lt;/code&gt; с аргументами, но ни одно определение с N аргументами.</target>
        </trans-unit>
        <trans-unit id="73f534c58d9ea31eaf8fb9427562c3ead1595373" translate="yes" xml:space="preserve">
          <source>A macro definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the macro.</source>
          <target state="translated">Определение макроса может быть размещено в любом месте среди атрибутов и деклараций функций модуля,но определение должно прийти до любого использования макроса.</target>
        </trans-unit>
        <trans-unit id="b023cfdfd3e8c944def982069911746c56dbb5ff" translate="yes" xml:space="preserve">
          <source>A macro is also used when spawning the server process:</source>
          <target state="translated">Макрос также используется при порождении серверного процесса:</target>
        </trans-unit>
        <trans-unit id="7f21e1aec85a7381be96d5bfbfec7f097bd47be9" translate="yes" xml:space="preserve">
          <source>A macro is defined as follows:</source>
          <target state="translated">Макрос определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="ce03814050d5f8680e3201e0fe96acef21b95f3d" translate="yes" xml:space="preserve">
          <source>A macro is used as follows:</source>
          <target state="translated">Макрос используется следующим образом:</target>
        </trans-unit>
        <trans-unit id="88726427099902153bb75f43bd476a92b9488c2a" translate="yes" xml:space="preserve">
          <source>A manager generates commands and receives notifications from agents. There usually are only a few managers in a system.</source>
          <target state="translated">Менеджер генерирует команды и получает уведомления от агентов.Обычно в системе всего несколько менеджеров.</target>
        </trans-unit>
        <trans-unit id="11e6d2013425970bf367a17f1b0c89bb48e7ff98" translate="yes" xml:space="preserve">
          <source>A map containing information about a specific thread. The percentages in the map can be either run-time or real-time depending on if &lt;code&gt;runtime&lt;/code&gt; or &lt;code&gt;realtime&lt;/code&gt; was requested from &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;system&lt;/code&gt; is the percentage of total system time for this specific thread.</source>
          <target state="translated">Карта, содержащая информацию о конкретной теме. Проценты в карте может быть либо во время выполнения или в режиме реального времени в зависимости от того, если во &lt;code&gt;runtime&lt;/code&gt; или в &lt;code&gt;realtime&lt;/code&gt; было предложено от &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;system&lt;/code&gt; - это процент от общего системного времени для этого конкретного потока.</target>
        </trans-unit>
        <trans-unit id="c1a5aa45e09b54b7bc479445ee3316a7d38b6bc0" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states and the number of microseconds spent in it.</source>
          <target state="translated">Карта,содержащая различные состояния микрогосударственного учета и количество микросекунд,потраченных на нее.</target>
        </trans-unit>
        <trans-unit id="55baef3a4a4f36d3a95ce66a57813b6156ada372" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states. Each value in the map contains another map with the percentage of time that this thread has spent in the specific state. Both the percentage of &lt;code&gt;system&lt;/code&gt; time and the time for that specific &lt;code&gt;thread&lt;/code&gt; is part of the map.</source>
          <target state="translated">Карта, содержащая различные состояния учета на микрогосударствах. Каждое значение на карте содержит другую карту с процентным соотношением времени, которое этот поток провел в определенном состоянии. И процент &lt;code&gt;system&lt;/code&gt; времени, и время для этого конкретного &lt;code&gt;thread&lt;/code&gt; являются частью карты.</target>
        </trans-unit>
        <trans-unit id="55c86ea1a266f601e2fcf39f41d436ed4bb1d415" translate="yes" xml:space="preserve">
          <source>A map is a compound data type with a variable number of key-value associations:</source>
          <target state="translated">Карта-это составной тип данных с переменным количеством ассоциаций ключей-значений:</target>
        </trans-unit>
        <trans-unit id="6df3d7501dc214f5a620dc3e70ec00231ed3a7da" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Итератор карты полезен только во время жизни среды &lt;code&gt;env&lt;/code&gt; , к которой принадлежит &lt;code&gt;map&lt;/code&gt; . Итератор необходимо уничтожить вызовом &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="48183a4afcb12654d2835dae35952f5ae81cc70f" translate="yes" xml:space="preserve">
          <source>A map must be specified with the number of key-value pairs &lt;code&gt;N&lt;/code&gt;. The key-value pairs must precede the &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; in this order: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt;. Duplicate keys are not allowed.</source>
          <target state="translated">Карта должна быть указана с числом пар ключ-значение &lt;code&gt;N&lt;/code&gt; . Пары &amp;laquo;ключ-значение&amp;raquo; должны предшествовать &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; в следующем порядке: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt; . Повторяющиеся ключи не допускаются.</target>
        </trans-unit>
        <trans-unit id="31783f08d32874056a3057b68b1693f84e957994" translate="yes" xml:space="preserve">
          <source>A match specification can turn on or off sequential tracing. This function returns a match specification, which turns on sequential tracing with the specified &lt;code&gt;Flags&lt;/code&gt;.</source>
          <target state="translated">Спецификация соответствия может включать или отключать последовательную трассировку. Эта функция возвращает спецификацию соответствия, которая включает последовательную трассировку с указанными &lt;code&gt;Flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6ddfb750b1e05982e25e257ab27afe27127e930" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;'receive'&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;, &lt;code&gt;is_seq_trace&lt;/code&gt;, &lt;code&gt;get_seq_token&lt;/code&gt;, &lt;code&gt;set_seq_token&lt;/code&gt;, &lt;code&gt;enable_trace&lt;/code&gt;, &lt;code&gt;disable_trace&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;silent&lt;/code&gt;, and &lt;code&gt;process_dump&lt;/code&gt;.</source>
          <target state="translated">Спецификация соответствия для трассировки &lt;code&gt;'receive'&lt;/code&gt; может использовать все функции защиты и тела, кроме &lt;code&gt;caller&lt;/code&gt; , &lt;code&gt;is_seq_trace&lt;/code&gt; , &lt;code&gt;get_seq_token&lt;/code&gt; , &lt;code&gt;set_seq_token&lt;/code&gt; , &lt;code&gt;enable_trace&lt;/code&gt; , &lt;code&gt;disable_trace&lt;/code&gt; , &lt;code&gt;trace&lt;/code&gt; , &lt;code&gt;silent&lt;/code&gt; и &lt;code&gt;process_dump&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1a2a4c3c454f94b1fa52f933e896cf4b6f1dcf" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;send&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;.</source>
          <target state="translated">Спецификация соответствия для трассировки &lt;code&gt;send&lt;/code&gt; может использовать все функции защиты и тела, кроме &lt;code&gt;caller&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775d888e22b3e82c594b4190a83e5f1b3950e566" translate="yes" xml:space="preserve">
          <source>A match specification used in &lt;code&gt;ets(3)&lt;/code&gt; can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">Спецификацию соответствия, используемую в &lt;code&gt;ets(3)&lt;/code&gt; можно описать следующей &lt;strong&gt;неформальной&lt;/strong&gt; грамматикой:</target>
        </trans-unit>
        <trans-unit id="83306dec354257cfad7ed48f591c0ff422b66b68" translate="yes" xml:space="preserve">
          <source>A match specification used in tracing can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">Спецификацию соответствия, используемую при трассировке, можно описать следующей &lt;strong&gt;неформальной&lt;/strong&gt; грамматикой:</target>
        </trans-unit>
        <trans-unit id="c3565e8901b4b3516619d211f5de1eb7c7f5a2de" translate="yes" xml:space="preserve">
          <source>A match specification, see above.</source>
          <target state="translated">Спецификация соответствия,см.выше.</target>
        </trans-unit>
        <trans-unit id="bfda4d3ad9a01b6a5ad6d226917a35814c884393" translate="yes" xml:space="preserve">
          <source>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before each backtrack occurs (in this example, 10 times).</source>
          <target state="translated">Сравнение со строкой &quot;aaaa&quot; всегда не удается,но вызов принимается перед каждым обратным ходом (в данном примере 10 раз).</target>
        </trans-unit>
        <trans-unit id="6f29c903e3589affa8d324ed95b31c5c61e91931" translate="yes" xml:space="preserve">
          <source>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the &lt;code&gt;mmap&lt;/code&gt; system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</source>
          <target state="translated">Распределитель сегментов памяти. Он используется другими распределителями для выделения сегментов памяти и доступен только в системах, в которых есть системный вызов &lt;code&gt;mmap&lt;/code&gt; . Освобожденные сегменты памяти некоторое время хранятся в кэше сегментов, прежде чем они будут уничтожены. Когда сегменты выделяются, по возможности используются кэшированные сегменты вместо создания новых сегментов. Это позволяет сократить количество выполняемых системных вызовов.</target>
        </trans-unit>
        <trans-unit id="95c010e88e46ea60a66fde46681834435a05128c" translate="yes" xml:space="preserve">
          <source>A minimal example of a NIF library can look as follows:</source>
          <target state="translated">Минимальный пример библиотеки NIF может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="87e74e52d3b9087104d60a0e55cc35f5604c3259" translate="yes" xml:space="preserve">
          <source>A minimum Windows NT installation with networking needs 250 MB, and an extra 130 MB for the swap file.</source>
          <target state="translated">Минимальная инсталляция Windows NT с сетью требует 250 МБ,а для файла подкачки дополнительно 130 МБ.</target>
        </trans-unit>
        <trans-unit id="ccca12c026cce7e56e7fa3fc8b384f432861042d" translate="yes" xml:space="preserve">
          <source>A misbehaving filter will be removed.</source>
          <target state="translated">Фильтр от неправильного поведения будет удален.</target>
        </trans-unit>
        <trans-unit id="06a13e586eee527b77c49434cc8f50ec42065c62" translate="yes" xml:space="preserve">
          <source>A module attribute consists of a tag and a value:</source>
          <target state="translated">Атрибут модуля состоит из тега и значения:</target>
        </trans-unit>
        <trans-unit id="dab39b0e69b099bf9e59a93c7991371da0a76b13" translate="yes" xml:space="preserve">
          <source>A module can also be used to represent a test set; see &lt;code&gt;ModuleName&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">Модуль также может использоваться для представления тестового набора; см. &lt;code&gt;ModuleName&lt;/code&gt; в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="c521c6a7b79de7232798a925aa632173f772fa44" translate="yes" xml:space="preserve">
          <source>A module can be specified by its module name (atom) or filename.</source>
          <target state="translated">Модуль может быть указан по имени (атому)или по имени файла.</target>
        </trans-unit>
        <trans-unit id="4d45b4986dc3244ccb1e4bc16129b111cc4334f7" translate="yes" xml:space="preserve">
          <source>A module can export some types to declare that other modules are allowed to refer to them as &lt;strong&gt;remote types&lt;/strong&gt;. This declaration has the following form:</source>
          <target state="translated">Модуль может экспортировать некоторые типы, чтобы объявить, что другим модулям разрешено ссылаться на них как на &lt;strong&gt;удаленные типы&lt;/strong&gt; . Это заявление имеет следующий вид:</target>
        </trans-unit>
        <trans-unit id="c7142355abe56d1cdac6e2f4354e4ece086ad515" translate="yes" xml:space="preserve">
          <source>A module can use data generated by previous modules in the Erlang webserver API module sequence or generate data to be used by consecutive Erlang Web Server API modules. This is possible owing to an internal list of key-value tuples, referred to as interaction data.</source>
          <target state="translated">Модуль может использовать данные,сгенерированные предыдущими модулями в последовательности API модулей веб-сервера Erlang или генерировать данные для использования последовательными API модулями веб-сервера Erlang.Это возможно благодаря внутреннему списку кортежей со значениями ключей,называемых данными взаимодействия.</target>
        </trans-unit>
        <trans-unit id="18900dbf59944d973af029df61cc566921cfdcc4" translate="yes" xml:space="preserve">
          <source>A module contains an &lt;code&gt;-on_load function&lt;/code&gt;.</source>
          <target state="translated">Модуль содержит функцию &lt;code&gt;-on_load function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93157c2c246b2925926264e6f2195084f98fb551" translate="yes" xml:space="preserve">
          <source>A module declaration consists of a sequence of forms, which are either function declarations or attributes.</source>
          <target state="translated">Модульная декларация состоит из последовательности форм,которые являются либо декларациями функций,либо атрибутами.</target>
        </trans-unit>
        <trans-unit id="610a0d8699dc82d5f83c6e9ce3301c3d01553b3b" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour. The info functions of this module will be called at various stages of delivery.</source>
          <target state="translated">Модуль, реализующий поведение &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; . Информационные функции этого модуля будут вызываться на разных этапах доставки.</target>
        </trans-unit>
        <trans-unit id="c6984ab40887600f2a1370e3539c8ccdba1c5de4" translate="yes" xml:space="preserve">
          <source>A module is included more than once in &lt;code&gt;Modules&lt;/code&gt;.</source>
          <target state="translated">Модуль входит в &lt;code&gt;Modules&lt;/code&gt; более одного раза .</target>
        </trans-unit>
        <trans-unit id="cd8890dc272bd36c3a480c734c6925501fff4e99" translate="yes" xml:space="preserve">
          <source>A module specified as a &lt;code&gt;transport_module&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; must implement the interface documented here. The interface consists of a function with which diameter starts a transport process and a message interface with which the transport process communicates with the process that starts it (aka its parent).</source>
          <target state="translated">Модуль, указанный как &lt;code&gt;transport_module&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; должен реализовывать интерфейс, описанный здесь. Интерфейс состоит из функции, с помощью которой диаметр запускает транспортный процесс, и интерфейса сообщений, с помощью которого транспортный процесс взаимодействует с процессом, который его запускает (он же родительский).</target>
        </trans-unit>
        <trans-unit id="492b06093c2441b11284458e2b4d042f4ba5283d" translate="yes" xml:space="preserve">
          <source>A monitor can be removed by calling &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt;.</source>
          <target state="translated">Монитор можно удалить, вызвав &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c985866a716b1f38553284b766cb9d078544843" translate="yes" xml:space="preserve">
          <source>A monitor created as &lt;code&gt;unloaded_only&lt;/code&gt; behaves exactly as one created as &lt;code&gt;unloaded&lt;/code&gt; except that the &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; message is never sent, but the monitor instead persists until the driver &lt;strong&gt;really&lt;/strong&gt; gets unloaded.</source>
          <target state="translated">Монитор, созданный как &lt;code&gt;unloaded_only&lt;/code&gt; , ведет себя точно так же, как созданный как &lt;code&gt;unloaded&lt;/code&gt; , за исключением того, что сообщение &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; никогда не отправляется, а вместо этого монитор продолжает работать до тех пор, пока драйвер &lt;strong&gt;действительно не&lt;/strong&gt; будет выгружен.</target>
        </trans-unit>
        <trans-unit id="e224d8a9f9c0d94e691cbfa15fef0b1fe2f4e60f" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Монотонно увеличивающееся время, обеспечиваемое системой времени выполнения Erlang. Монотонное время Эрланга увеличивается с некоторого неопределенного момента времени. Чтобы получить его, вызовите &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcff3bd090752a02621fd3d2ad9e629fddd5e95" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the OS. This time does not leap and has a relatively steady frequency although not completely correct. However, it is not uncommon that OS monotonic time stops if the system is suspended. This time typically increases since some unspecified point in time that is not connected to &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. This type of time is not necessarily provided by all OSs.</source>
          <target state="translated">Монотонно увеличивающееся время, предоставляемое ОС. Это время без скачков и имеет относительно стабильную частоту, хотя и не совсем правильную. Однако не редкость, что монотонное время ОС останавливается, если система приостановлена. Это время обычно увеличивается с некоторого неопределенного момента времени, который не связан с &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; . Этот тип времени не обязательно предоставляется всеми ОС.</target>
        </trans-unit>
        <trans-unit id="5712c1400575e91c9656e681e7475784bdfd9eda" translate="yes" xml:space="preserve">
          <source>A more complicated example with two quad core processors, each processor in its own NUMA node. The ordering of logical processors is a bit weird. This to give a better example of identifier lists:</source>
          <target state="translated">Более сложный пример с двумя четырёхъядерными процессорами,каждый процессор в своём узле NUMA.Порядок расположения логических процессоров немного странный.Это для того,чтобы привести лучший пример списков идентификаторов:</target>
        </trans-unit>
        <trans-unit id="a0d3ff79b050cf4e67f5f12480ec66e526e82e53" translate="yes" xml:space="preserve">
          <source>A more detailed internal representation of the state of this process.</source>
          <target state="translated">Более подробное внутреннее представление состояния этого процесса.</target>
        </trans-unit>
        <trans-unit id="f3c43b55cc6e4ec72f53a82fa0f070f9038b700e" translate="yes" xml:space="preserve">
          <source>A more precise language for MIB specification</source>
          <target state="translated">Более точный язык для спецификации MIB</target>
        </trans-unit>
        <trans-unit id="d9a6a54885c00dec728fc7fc51d18dd588db7351" translate="yes" xml:space="preserve">
          <source>A more refined version of this format handler is function &lt;code&gt;handle_gc/4&lt;/code&gt; in module &lt;code&gt;multitrace.erl&lt;/code&gt; included in directory &lt;code&gt;src&lt;/code&gt; of the Observer application.</source>
          <target state="translated">Более усовершенствованная версия этого обработчика формата - это функция &lt;code&gt;handle_gc/4&lt;/code&gt; в модуле &lt;code&gt;multitrace.erl&lt;/code&gt; , включенном в каталог &lt;code&gt;src&lt;/code&gt; приложения Observer.</target>
        </trans-unit>
        <trans-unit id="5d37f040ad3ea680b60e046bb149872d221815ff" translate="yes" xml:space="preserve">
          <source>A multi-lingual SNMP manager.</source>
          <target state="translated">Многоязычный менеджер SNMP.</target>
        </trans-unit>
        <trans-unit id="9e37a488733c4647d4a17da583fd3b03c8d0d81b" translate="yes" xml:space="preserve">
          <source>A name (an Erlang atom) associated with a data value read from a configuration file.</source>
          <target state="translated">Имя (атом Erlang),связанное со значением данных,считанных из конфигурационного файла.</target>
        </trans-unit>
        <trans-unit id="2416bd3c84f93d0172f4762c1b29e0836c7a7539" translate="yes" xml:space="preserve">
          <source>A name and association to configuration data introduced through a require statement, or a call to &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt;.</source>
          <target state="translated">Имя и связь с данными конфигурации, введенными посредством оператора require или вызова &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; , например, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a56d53bccebb00764e45b858a26b5ebf2ade91" translate="yes" xml:space="preserve">
          <source>A name constructed from the name of the function in which they are created</source>
          <target state="translated">Имя,построенное из названия функции,в которой они созданы.</target>
        </trans-unit>
        <trans-unit id="ccf5e0e4e127bfae4bef5668c5a9b13172a11e7a" translate="yes" xml:space="preserve">
          <source>A name for the data must be allocated in the suite using &lt;code&gt;require&lt;/code&gt; (see the example above). Pass this name as argument &lt;code&gt;SnmpAppConfName&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_snmp&lt;/code&gt; specifies default values for some &lt;code&gt;SNMP&lt;/code&gt; application configuration parameters (such as &lt;code&gt;{verbosity,trace}&lt;/code&gt; for parameter &lt;code&gt;config&lt;/code&gt;). This set of defaults is merged with the parameters specified by the user. The user values override &lt;code&gt;ct_snmp&lt;/code&gt; defaults.</source>
          <target state="translated">Имя для данных должно быть выделено в наборе с помощью &lt;code&gt;require&lt;/code&gt; (см. Пример выше). Передайте это имя в качестве аргумента &lt;code&gt;SnmpAppConfName&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ct_snmp&lt;/code&gt; задает значения по умолчанию для некоторых параметров конфигурации приложения &lt;code&gt;SNMP&lt;/code&gt; (например, &lt;code&gt;{verbosity,trace}&lt;/code&gt; для параметра &lt;code&gt;config&lt;/code&gt; ). Этот набор значений по умолчанию объединяется с параметрами, указанными пользователем. Пользовательские значения переопределяют &lt;code&gt;ct_snmp&lt;/code&gt; умолчанию ct_snmp .</target>
        </trans-unit>
        <trans-unit id="5489bf9abf580e46c80a7d46f5c6b357c56bfd5f" translate="yes" xml:space="preserve">
          <source>A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique.</source>
          <target state="translated">С этим глаголом всегда требуется имя.В шаблоне может быть столько экземпляров (*MARK),сколько вам нравится,и их имена не обязательно должны быть уникальными.</target>
        </trans-unit>
        <trans-unit id="37561d5bd1b8f3c3ed788a8368cee35cffb7641d" translate="yes" xml:space="preserve">
          <source>A native function doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">Собственная функция, выполняющая &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; перед возвратом, ухудшает отзывчивость виртуальной машины и может вызывать разные странные поведения. Такое странное поведение включает, помимо прочего, чрезмерное использование памяти и плохую балансировку нагрузки между планировщиками. Странное поведение, которое может возникнуть из-за длительной работы, также может различаться между выпусками Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="054cf9ceb563ed6f90ffbc9bbce068da6480e085" translate="yes" xml:space="preserve">
          <source>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the native function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">Собственная функция выполняется как прямое расширение собственного кода виртуальной машины. Казнь не производится в безопасных условиях. Виртуальная машина &lt;strong&gt;не может&lt;/strong&gt; предоставлять те же услуги, которые предоставляются при выполнении кода Erlang, такие как упреждающее планирование или защита памяти. Если собственная функция не работает должным образом, вся виртуальная машина будет вести себя неправильно.</target>
        </trans-unit>
        <trans-unit id="5d7156f3c126c629744aa907155b989bd0af5b92" translate="yes" xml:space="preserve">
          <source>A native function that crash will crash the whole VM.</source>
          <target state="translated">Нативная функция,которая аварийно завершает работу всей ВМ.</target>
        </trans-unit>
        <trans-unit id="a596b85ce60a4ebd518468dd4ada66946ee5ba8d" translate="yes" xml:space="preserve">
          <source>A native signed 64-bit integer type.</source>
          <target state="translated">Нативный знаковый 64-битный целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="d333b99d2c176e6cef29cdbe662fff2fc82351f6" translate="yes" xml:space="preserve">
          <source>A native unsigned 64-bit integer type.</source>
          <target state="translated">Нативный 64-битный целочисленный беззнаковый тип.</target>
        </trans-unit>
        <trans-unit id="1a25fa736ef55d7f9c1d89a3af60f13910153e4c" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;WindowBits&lt;/code&gt; value makes zlib ignore the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">Отрицательное значение &lt;code&gt;WindowBits&lt;/code&gt; заставляет zlib игнорировать заголовок zlib (и контрольную сумму) из потока. Обратите внимание, что в источнике zlib это упоминается только как недокументированная функция.</target>
        </trans-unit>
        <trans-unit id="bff6f239743ba458b6fef3d31577263304f30dcc" translate="yes" xml:space="preserve">
          <source>A negative length can be used to extract bytes at the end of a binary:</source>
          <target state="translated">Отрицательная длина может быть использована для извлечения байтов в конце двоичного файла:</target>
        </trans-unit>
        <trans-unit id="6a5647dc70e502438e63ae1f528d8168602285f6" translate="yes" xml:space="preserve">
          <source>A negative response can look as follows:</source>
          <target state="translated">Отрицательная реакция может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="acfd9f30ed035c8f515380634a9f49e2e6305307" translate="yes" xml:space="preserve">
          <source>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">Отрицательное значение заставляет систему времени выполнения ждать неопределенное время, пока файл аварийного дампа не будет полностью записан. Это значение по умолчанию , если параметр &lt;code&gt;-heart&lt;/code&gt; это &lt;strong&gt;не&lt;/strong&gt; передается &lt;code&gt;erl&lt;/code&gt; и &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; не установлен.</target>
        </trans-unit>
        <trans-unit id="9ad2ef1372f693b05aa57e2e774e90e14b42ac7f" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation.</source>
          <target state="translated">Фильтр сетевого интерфейса может использоваться,например,во время испытаний или для регулирования нагрузки.</target>
        </trans-unit>
        <trans-unit id="a5da2ab0a310bd02dc005df1f2a390906381786a" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;req_limit&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Фильтр сетевого интерфейса можно использовать, например, во время тестирования или для регулирования нагрузки. Если предполагаемое использование - регулирование нагрузки, см. Также &lt;code&gt;req_limit&lt;/code&gt; и функцию &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a37e856dd2d89d23cca0a3d2993676ef15b297" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;person&lt;/code&gt; record is created as follows:</source>
          <target state="translated">Запись нового &lt;code&gt;person&lt;/code&gt; создается следующим образом:</target>
        </trans-unit>
        <trans-unit id="0cb57df1a585271753d77c0b683d96263a8aeb0a" translate="yes" xml:space="preserve">
          <source>A new boot script was generated, without the &lt;code&gt;local&lt;/code&gt; option set, before the release package was made. In the release package, all application directories are placed under &lt;code&gt;lib&lt;/code&gt;. You do not know where the release package will be installed, so no hard-coded absolute paths are allowed.</source>
          <target state="translated">Перед созданием пакета выпуска был сгенерирован новый сценарий загрузки без установленной &lt;code&gt;local&lt;/code&gt; опции. В пакете выпуска все каталоги приложений помещены в &lt;code&gt;lib&lt;/code&gt; . Вы не знаете, где будет установлен пакет выпуска, поэтому жестко заданные абсолютные пути не допускаются.</target>
        </trans-unit>
        <trans-unit id="0cd3d52715f74b16be431ae39bdcad7432af2c3a" translate="yes" xml:space="preserve">
          <source>A new interface &lt;code&gt;delete/1&lt;/code&gt; is now added to handle the case when a process wants to discard an index table (i.e. to build a completely new). Any application using transient snmp indexes has to be modified to handle this.</source>
          <target state="translated">Теперь добавлен новый интерфейс &lt;code&gt;delete/1&lt;/code&gt; для обработки случая, когда процесс хочет отбросить индексную таблицу (т.е. построить полностью новую). Любое приложение, использующее временные индексы snmp, должно быть изменено, чтобы справиться с этим.</target>
        </trans-unit>
        <trans-unit id="7813433a94ab5122a108632d44422a9630945f8c" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Новый процесс запускается приложением &lt;code&gt;Module:Function&lt;/code&gt; к &lt;code&gt;Args&lt;/code&gt; . Одновременно отслеживается процесс. Возвращает идентификатор процесса и ссылку на монитор. В противном случае работает как &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c6aeb17dbb1f994107439b1a93fe0bdeabaadd7" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value and &lt;code&gt;OldRecords&lt;/code&gt; contains the records before the operation is performed. Notice that the new content depends on the table type.</source>
          <target state="translated">Написан новый рекорд. &lt;code&gt;NewRecord&lt;/code&gt; содержит новое значение записи, а &lt;code&gt;OldRecords&lt;/code&gt; содержит записи до выполнения операции. Обратите внимание, что новое содержимое зависит от типа таблицы.</target>
        </trans-unit>
        <trans-unit id="eecdd1aca65c090cd037cecb43b60372b3e2d23d" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value.</source>
          <target state="translated">Написан новый рекорд. &lt;code&gt;NewRecord&lt;/code&gt; содержит новое значение записи.</target>
        </trans-unit>
        <trans-unit id="bcbee27c7629c70c521974bc4a2ef6365b44965e" translate="yes" xml:space="preserve">
          <source>A new version of the &lt;code&gt;ch_app.app&lt;/code&gt; file must now be created, where the version is updated:</source>
          <target state="translated">Теперь необходимо создать новую версию файла &lt;code&gt;ch_app.app&lt;/code&gt; , в которой версия обновлена:</target>
        </trans-unit>
        <trans-unit id="207842ca1ef434b687fe891079409854db11ce8f" translate="yes" xml:space="preserve">
          <source>A newline convention can also be specified by starting a pattern string with one of the following five sequences:</source>
          <target state="translated">Новое соглашение может быть также задано путем запуска строки шаблона с одной из следующих пяти последовательностей:</target>
        </trans-unit>
        <trans-unit id="810a5966eb1e7ee3bb3f54687643fa10446c0bcc" translate="yes" xml:space="preserve">
          <source>A newly spawned Erlang process uses 309 words of memory in the non-SMP emulator without HiPE support. (SMP support and HiPE support both add to this size.) The size can be found as follows:</source>
          <target state="translated">Недавно созданный процесс Erlang использует 309 слов памяти в не-SMP эмуляторе без поддержки HiPE.(поддержка SMP и поддержка HiPE добавляют к этому размеру.)Размер можно найти следующим образом:</target>
        </trans-unit>
        <trans-unit id="06c8c9ea0c1555c71b7dd9ae8ee6da8f6b7d0bc2" translate="yes" xml:space="preserve">
          <source>A nice feature is that a test specification that includes node information can still be used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server (as described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;). The result is that any test specified to run on a node with the same name as the &lt;code&gt;Common Test&lt;/code&gt; node in question (typically &lt;code&gt;ct@somehost&lt;/code&gt; if started with the &lt;code&gt;ct_run&lt;/code&gt; program), is performed. Tests without explicit node association are always performed too, of course.</source>
          <target state="translated">Приятной особенностью является то, что спецификацию теста, включающую информацию об узлах, можно по-прежнему использовать в качестве входных данных для обычного сервера &lt;code&gt;Common Test&lt;/code&gt; (как описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; ). В результате выполняется любой тест, указанный для запуска на узле с тем же именем, что и рассматриваемый узел &lt;code&gt;Common Test&lt;/code&gt; (обычно &lt;code&gt;ct@somehost&lt;/code&gt; если запускается с &lt;code&gt;ct_run&lt;/code&gt; программы ct_run ). Конечно, всегда выполняются тесты без явной привязки узлов.</target>
        </trans-unit>
        <trans-unit id="7ee9953adae41a7655f8d2084b4fa873e00e82bf" translate="yes" xml:space="preserve">
          <source>A node can crash (probably a buggy one, hence traced). Use &lt;code&gt;resume&lt;/code&gt; to resume tracing on the node automatically when it gets back. The failing node then tries to reconnect to trace control node when &lt;code&gt;Runtime_Tools&lt;/code&gt; is started. This implies that &lt;code&gt;Runtime_Tools&lt;/code&gt; must be included in the startup chain of other nodes (if not, you can still resume tracing by starting &lt;code&gt;Runtime_Tools&lt;/code&gt; manually, that is, by an RPC call).</source>
          <target state="translated">Узел может аварийно завершить работу (возможно, с ошибкой, поэтому отслеживается). Используйте &lt;code&gt;resume&lt;/code&gt; для автоматического возобновления трассировки на узле, когда он вернется. Затем отказавший узел пытается повторно подключиться к узлу управления трассировкой при &lt;code&gt;Runtime_Tools&lt;/code&gt; . Это означает, что &lt;code&gt;Runtime_Tools&lt;/code&gt; должен быть включен в цепочку запуска других узлов (если нет, вы все равно можете возобновить трассировку, запустив &lt;code&gt;Runtime_Tools&lt;/code&gt; вручную, то есть с помощью вызова RPC).</target>
        </trans-unit>
        <trans-unit id="e9ed4743bc1cec802b20617a0fd885483b2dd9dc" translate="yes" xml:space="preserve">
          <source>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</source>
          <target state="translated">Узел получает номер порта другого узла через EPMD (на другом узле),чтобы инициировать запрос на соединение.</target>
        </trans-unit>
        <trans-unit id="4faa439d4cf9e40f5ce1dc04ca048d241e286cf4" translate="yes" xml:space="preserve">
          <source>A node of type &lt;code&gt;map_expr&lt;/code&gt; is a leaf node if and only if it has no argument and no fields. A node of type &lt;code&gt;map_type&lt;/code&gt; is a leaf node if and only if it has no fields (&lt;code&gt;any_size&lt;/code&gt;). A node of type &lt;code&gt;tuple&lt;/code&gt; is a leaf node if and only if its arity is zero. A node of type &lt;code&gt;tuple_type&lt;/code&gt; is a leaf node if and only if it has no elements (&lt;code&gt;any_size&lt;/code&gt;).</source>
          <target state="translated">Узел типа &lt;code&gt;map_expr&lt;/code&gt; является листовым узлом тогда и только тогда, когда у него нет аргументов и полей. Узел типа &lt;code&gt;map_type&lt;/code&gt; является листовым узлом тогда и только тогда, когда он не имеет полей ( &lt;code&gt;any_size&lt;/code&gt; ). Узел типа &lt;code&gt;tuple&lt;/code&gt; является листовым тогда и только тогда, когда его арность равна нулю. Узел типа &lt;code&gt;tuple_type&lt;/code&gt; является листовым узлом тогда и только тогда, когда он не имеет элементов ( &lt;code&gt;any_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb52c93cebdeac0dab7fcc67ec63e9553ad8a863" translate="yes" xml:space="preserve">
          <source>A node running on Windows can only start slave nodes on the host on which it is running.</source>
          <target state="translated">Узел,работающий под управлением Windows,может запускать подчиненные узлы только на том узле,на котором он запущен.</target>
        </trans-unit>
        <trans-unit id="9d21f5fbd84596b473f63ef2991ce0e43cba7cfb" translate="yes" xml:space="preserve">
          <source>A node started in this way is fully functional, using TLS as the distribution protocol.</source>
          <target state="translated">Узел,запущенный таким образом,полностью функционален,используя TLS в качестве протокола распределения.</target>
        </trans-unit>
        <trans-unit id="fc7f66a0ac45a7c84f0bb5f9e9d30342b7788580" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using SSL/TLS distribution over IPv6.</source>
          <target state="translated">Узел,запущенный таким образом,сможет взаимодействовать с другими узлами только с помощью распространения SSL/TLS по протоколу IPv6.</target>
        </trans-unit>
        <trans-unit id="15e879d0b785427426139719e5c9dfe725a5b841" translate="yes" xml:space="preserve">
          <source>A node started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; (see &lt;code&gt;erl(1)&lt;/code&gt;) is said to be a &lt;strong&gt;hidden&lt;/strong&gt; node. A hidden node establishes hidden connections to nodes not part of the same global group, but normal (visible) connections to nodes part of the same global group.</source>
          <target state="translated">Узел, запущенный с флагом командной строки &lt;code&gt;-hidden&lt;/code&gt; (см. &lt;code&gt;erl(1)&lt;/code&gt; ), называется &lt;strong&gt;скрытым&lt;/strong&gt; узлом. Скрытый узел устанавливает скрытые соединения с узлами, не входящими в одну и ту же глобальную группу, а обычные (видимые) соединения с узлами, входящими в одну и ту же глобальную группу.</target>
        </trans-unit>
        <trans-unit id="20c980faeffa1454b2f85d7502b23e1c0b0103b4" translate="yes" xml:space="preserve">
          <source>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</source>
          <target state="translated">Узел сам удаляется из EPMD,закрывая TCP-соединение с EPMD,установленное при регистрации узла.</target>
        </trans-unit>
        <trans-unit id="d42befae27c8be5c2d1b9032dc8b9a0535e6021b" translate="yes" xml:space="preserve">
          <source>A node with a long node name cannot communicate with a node with a short node name.</source>
          <target state="translated">Узел с длинным именем не может взаимодействовать с узлом с коротким именем.</target>
        </trans-unit>
        <trans-unit id="5608a2aa0096e2c431c4d688274c5bfed3dfbe6a" translate="yes" xml:space="preserve">
          <source>A node with name &lt;code&gt;Name@Host&lt;/code&gt; already exists.</source>
          <target state="translated">Узел с именем &lt;code&gt;Name@Host&lt;/code&gt; уже существует.</target>
        </trans-unit>
        <trans-unit id="9de4833cf4636cc7347017906607c0375ae36fb9" translate="yes" xml:space="preserve">
          <source>A non-local return from a function. If evaluated within a &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; returns value &lt;code&gt;Any&lt;/code&gt;. Example:</source>
          <target state="translated">Нелокальный возврат из функции. Если вычислено в пределах &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; возвращает значение &lt;code&gt;Any&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="3104d91a116c49b17930265301a213974b99a618" translate="yes" xml:space="preserve">
          <source>A non-terminal category can be used at the left hand side (= &lt;code&gt;lhs&lt;/code&gt;, or &lt;code&gt;head&lt;/code&gt;) of a grammar rule. It can also appear at the right hand side of rules.</source>
          <target state="translated">Нетерминальная категория может быть использована на левой стороне (= &lt;code&gt;lhs&lt;/code&gt; , или &lt;code&gt;head&lt;/code&gt; ) из правила грамматики. Он также может отображаться в правой части правил.</target>
        </trans-unit>
        <trans-unit id="522676de41bafa253c8f310dce88c669f1124e1c" translate="yes" xml:space="preserve">
          <source>A nonempty list &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; of syntax trees. This is equivalent to passing &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt;.</source>
          <target state="translated">Непустой список &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; синтаксических деревьев. Это эквивалентно переходу &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a728b05450ce93eb12d475c06f9983d66527797f" translate="yes" xml:space="preserve">
          <source>A nonempty list of lists of syntax trees &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt;, which is equivalent to passing &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt;.</source>
          <target state="translated">Непустой список списков синтаксических деревьев &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt; , что эквивалентно передаче &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfe0accad3b0782ec5f58066cb4e83f925efd4a7" translate="yes" xml:space="preserve">
          <source>A normal file is really a process so it can be used as an I/O device (see &lt;code&gt;io&lt;/code&gt;). Therefore, when data is written to a normal file, the sending of the data to the file process, copies all data that are not binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the file is opened on another node, or if the file server runs as slave to the file server of another node, also binaries are copied.</source>
          <target state="translated">Обычный файл - это действительно процесс, поэтому его можно использовать как устройство ввода-вывода (см. &lt;code&gt;io&lt;/code&gt; ). Поэтому, когда данные записываются в обычный файл, при отправке данных в файловый процесс копируются все данные, которые не являются двоичными. Поэтому рекомендуется открыть файл в двоичном режиме и записать двоичные файлы. Если файл открыт на другом узле или если файловый сервер работает как подчиненный файлового сервера другого узла, также копируются двоичные файлы.</target>
        </trans-unit>
        <trans-unit id="c470da7bdfad13769766d01b29332c73881e0c5a" translate="yes" xml:space="preserve">
          <source>A normal installation of Windows NT 4.0, with Service Pack 4 or later, is required for an embedded Windows NT running OTP.</source>
          <target state="translated">Обычная установка Windows NT 4.0 с пакетом обновления 4 или более поздней версии требуется для встроенной Windows NT,работающей по протоколу OTP.</target>
        </trans-unit>
        <trans-unit id="b9be4139254b3d41e2b3331c9e7f9cdccd473c9d" translate="yes" xml:space="preserve">
          <source>A normal scheduler thread.</source>
          <target state="translated">Обычный поток планировщика.</target>
        </trans-unit>
        <trans-unit id="1ba3e6a43cfdf42b7ee92131fc56ef43d47532de" translate="yes" xml:space="preserve">
          <source>A notable return value is &lt;code&gt;{error, closed}&lt;/code&gt; indicating that the socket is closed.</source>
          <target state="translated">Примечательным возвращаемым значением является &lt;code&gt;{error, closed}&lt;/code&gt; указывающее, что сокет закрыт.</target>
        </trans-unit>
        <trans-unit id="3b3bb227d33cdecc5e31e4a78df3f54b111efcf9" translate="yes" xml:space="preserve">
          <source>A notation that tells which part of the type to be decoded</source>
          <target state="translated">Примечание,которое указывает,какая часть типа должна быть декодирована.</target>
        </trans-unit>
        <trans-unit id="d7dc1e195006c9ad7d9414abaacea8ee8034b8fa" translate="yes" xml:space="preserve">
          <source>A notation that tells which parts of the message structure to be excluded from decode</source>
          <target state="translated">Примечание,указывающее,какие части структуры сообщения должны быть исключены из декодирования.</target>
        </trans-unit>
        <trans-unit id="027b96af0679f806c12b49fa73f516241d045fca" translate="yes" xml:space="preserve">
          <source>A note of warning: Igor cannot do anything about the case when the name of a remote function is passed to the built-in functions &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;spawn&lt;/code&gt;&lt;strong&gt;unless&lt;/strong&gt; the module and function names are explicitly stated in the call, as in e.g. &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt;. In all other cases, Igor leaves such calls unchanged, and warns the user that manual editing might be necessary.</source>
          <target state="translated">Примечание к предупреждению: Игорь не может ничего сделать в случае, когда имя удаленной функции передается встроенным функциям &lt;code&gt;apply&lt;/code&gt; и &lt;code&gt;spawn&lt;/code&gt; ,&lt;strong&gt;если&lt;/strong&gt; имена модуля и функции явно не указаны в вызове, как, например, в &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt; . Во всех остальных случаях Игорь оставляет такие вызовы без изменений и предупреждает пользователя, что может потребоваться ручное редактирование.</target>
        </trans-unit>
        <trans-unit id="bb34c061995c9bd9c3bf3fd5336b0597518696e6" translate="yes" xml:space="preserve">
          <source>A notification filter is a module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; behaviour. A filter is added/deleted using the functions: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Фильтр уведомлений - это модуль, реализующий поведение &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; . Фильтр добавляется / удаляется с помощью функций: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23a7337393f51adec78486c788d793b331d07279" translate="yes" xml:space="preserve">
          <source>A nullary functional value (i.e., a fun that takes zero arguments). Examples:</source>
          <target state="translated">Нулевое функциональное значение (т.е.веселье,которое принимает нулевые аргументы).Примеры:</target>
        </trans-unit>
        <trans-unit id="e5362e0c25c0703bb5ca7c53501e9fabd30aa894" translate="yes" xml:space="preserve">
          <source>A number (starting with 0) indicating the number of that fun within that function</source>
          <target state="translated">Номер (начинающийся с 0),указывающий на количество этого удовольствия в рамках этой функции.</target>
        </trans-unit>
        <trans-unit id="cf27cfd569963d1d3e948b114051da6fdcf3d00a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Thoose objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для работы приложения SSH необходимо наличие ряда объектов. Выбранные объекты по умолчанию хранятся в файлах. Имена, пути и форматы файлов по умолчанию такие же, как для &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; . Ключи могут быть созданы с помощью программы &lt;code&gt;ssh-keygen&lt;/code&gt; из OpenSSH. См. &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c32086c997452421cf26bca4ec5f8f37980a88f" translate="yes" xml:space="preserve">
          <source>A one-line description of the application.</source>
          <target state="translated">Однострочное описание приложения.</target>
        </trans-unit>
        <trans-unit id="7676e10e4c0c5db81948c82045b717673602dd63" translate="yes" xml:space="preserve">
          <source>A one-shot timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; is not linked to any process. Hence, such a timer is removed only when it reaches its time-out, or if it is explicitly removed by a call to &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt; таймер, то есть таймер, созданный путем оценки любой из функций apply_after / 4 , &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; , не связан с любой процесс. Следовательно, такой таймер удаляется только тогда, когда он достигает своего тайм-аута, или если он явно удаляется вызовом &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652f0a6b7da70ccce812924b966b0be33a66985d" translate="yes" xml:space="preserve">
          <source>A packet is a line-terminated by a delimiter byte, default is the latin-1 newline character. The delimiter byte is included in the returned packet unless the line was truncated according to option &lt;code&gt;line_length&lt;/code&gt;.</source>
          <target state="translated">Пакет - это строка, оканчивающаяся байтом-разделителем, по умолчанию - символ новой строки latin-1. Байт-разделитель включается в возвращаемый пакет, если строка не была усечена в соответствии с опцией &lt;code&gt;line_length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="243cae021af59d36fb2ba67a11310414b8344606" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt;, where &lt;code&gt;LineNumber&lt;/code&gt; is a nonnegative integer and &lt;code&gt;SimpleTest&lt;/code&gt; is another simple test object. &lt;code&gt;LineNumber&lt;/code&gt; should indicate the source line of the test. Pairs like this are usually only created via &lt;code&gt;?_test(...)&lt;/code&gt; macros; see &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Пара &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt; , где &lt;code&gt;LineNumber&lt;/code&gt; - неотрицательное целое число, а &lt;code&gt;SimpleTest&lt;/code&gt; - еще один простой тестовый объект. &lt;code&gt;LineNumber&lt;/code&gt; должен указывать на исходную строку теста. &lt;code&gt;?_test(...)&lt;/code&gt; пары обычно создаются только с помощью макросов? _Test (...) ; см. &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="defb50c3733240a6d3613348a3d9ea0d5e3378d6" translate="yes" xml:space="preserve">
          <source>A parallel test case has a private I/O server as its group leader. (For a description of the group leader concept, see &lt;code&gt;ERTS&lt;/code&gt;). The central I/O server process, which handles the output from regular test cases and configuration functions, does not respond to I/O messages during execution of parallel groups. This is important to understand to avoid certain traps, like the following:</source>
          <target state="translated">Параллельный тестовый пример имеет частный сервер ввода-вывода в качестве лидера группы. (Описание концепции лидера группы см. В &lt;code&gt;ERTS&lt;/code&gt; ). Процесс центрального сервера ввода-вывода, который обрабатывает выходные данные из обычных тестовых примеров и функций конфигурации, не отвечает на сообщения ввода-вывода во время выполнения параллельных групп. Это важно понимать, чтобы избежать определенных ловушек, например следующих:</target>
        </trans-unit>
        <trans-unit id="59ee8343e4e789ac929459cd04d582cafeb246fb" translate="yes" xml:space="preserve">
          <source>A parameterized type is to be considered as an embedded type. Each time such a type is referenced, an instance of it is defined. Thus, in the following example a record with name &lt;code&gt;'Seq_b'&lt;/code&gt; is generated in the &lt;code&gt;.hrl&lt;/code&gt; file and is used to hold values:</source>
          <target state="translated">Параметризованный тип следует рассматривать как встроенный. Каждый раз, когда на такой тип ссылаются, определяется его экземпляр. Таким образом, в следующем примере запись с именем &lt;code&gt;'Seq_b'&lt;/code&gt; генерируется в &lt;code&gt;.hrl&lt;/code&gt; файл и используется для значений трюмов:</target>
        </trans-unit>
        <trans-unit id="024ff9d111af56355737a8c26860d8a633650503" translate="yes" xml:space="preserve">
          <source>A parenthesized subpattern (including assertions)</source>
          <target state="translated">Подмаска в скобках (включая утверждения).</target>
        </trans-unit>
        <trans-unit id="3ea3805acd22f42cb11f366b367ef59a1e1dc7d4" translate="yes" xml:space="preserve">
          <source>A parse transformation that translates fun syntax into match specifications.</source>
          <target state="translated">Преобразование разбора,которое переводит синтаксис веселья в спецификации на соответствие.</target>
        </trans-unit>
        <trans-unit id="991f645ed0dc31daba5645f487f69d46fc37f314" translate="yes" xml:space="preserve">
          <source>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Частичный сбой доставки. В текущей реализации привязки Erlang / SCTP это событие внутренне преобразуется в термин &lt;code&gt;error&lt;/code&gt; возвращаемый &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb726df29d93231b466c44dbe8038aa91fcb314b" translate="yes" xml:space="preserve">
          <source>A pattern can be selected to narrow the profiling. For instance a specific module can be selected, and only the code executed in that module will be profiled.</source>
          <target state="translated">Деталь можно выбрать,чтобы сузить профилирование.Например,можно выбрать конкретный модуль,и профилировать будет только код,выполняемый в этом модуле.</target>
        </trans-unit>
        <trans-unit id="c67b6c7226586d1f049336989af73704b318b899" translate="yes" xml:space="preserve">
          <source>A pattern has the same structure as a term but can contain unbound variables.</source>
          <target state="translated">Шаблон имеет ту же структуру,что и термин,но может содержать несвязанные переменные.</target>
        </trans-unit>
        <trans-unit id="430efb2a85da18740aa7226ea60c97fb378ca179" translate="yes" xml:space="preserve">
          <source>A pattern is a term that can contain:</source>
          <target state="translated">Образец-это термин,который может содержать:</target>
        </trans-unit>
        <trans-unit id="17c671d86e70778fccd78b1c171062748a656776" translate="yes" xml:space="preserve">
          <source>A pattern that matches a certain record is created in the same way as a record is created:</source>
          <target state="translated">Шаблон,совпадающий с определенной записью,создается так же,как и запись:</target>
        </trans-unit>
        <trans-unit id="086559c23f422f88dfb22263e5064971fda50484" translate="yes" xml:space="preserve">
          <source>A peer's DiameterIdentity is not required when initiating a connection: the identify is received at capabilities exchange, at which time the connection can be rejected if the identity is objectionable.</source>
          <target state="translated">При инициации подключения не требуется DiameterIdentity аналога:идентификация получена при обмене возможностями,и в этот момент соединение может быть отклонено,если идентификация вызывает возражения.</target>
        </trans-unit>
        <trans-unit id="6ac1afaee6db30631244af22883394c04ea016de" translate="yes" xml:space="preserve">
          <source>A piece of data of any data type is called a &lt;strong&gt;term&lt;/strong&gt;.</source>
          <target state="translated">Фрагмент данных любого типа называется &lt;strong&gt;термином&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="27a9280a59a327bcaa7fa4531cf4080082cc2a4d" translate="yes" xml:space="preserve">
          <source>A pointer to a function to execute in the created thread.</source>
          <target state="translated">Указатель на функцию для выполнения в созданном потоке.</target>
        </trans-unit>
        <trans-unit id="2425be4490c62b2d9ac48f8dfb6dca6c94bc6de8" translate="yes" xml:space="preserve">
          <source>A pointer to a thread identifier variable.</source>
          <target state="translated">Указатель на переменную идентификатора потока.</target>
        </trans-unit>
        <trans-unit id="bdca82216af70bfb4f52fcc1c479301f1b25be42" translate="yes" xml:space="preserve">
          <source>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</source>
          <target state="translated">Указатель на целое число.Целое число используется как для передачи входного,так и выходного размера (см.ниже).</target>
        </trans-unit>
        <trans-unit id="9e7bc1ca5fcc169a07a734702da7afb3a87a923b" translate="yes" xml:space="preserve">
          <source>A pointer to an output buffer.</source>
          <target state="translated">Указатель на выходной буфер.</target>
        </trans-unit>
        <trans-unit id="78c2fb1c9ead9f20103777b7ae3edafb6a2eea4e" translate="yes" xml:space="preserve">
          <source>A pointer to another port structure, which is either the listen port from which this port is accepting a connection or conversely. The &quot;partner relation&quot; is always bidirectional.</source>
          <target state="translated">Указатель на другую структуру порта,которая является либо портом прослушивания,с которого этот порт принимает соединение,либо наоборот.Партнерские отношения&quot; всегда являются двунаправленными.</target>
        </trans-unit>
        <trans-unit id="aae44b20ecd8d8611c610749c380b8aec87c9bfa" translate="yes" xml:space="preserve">
          <source>A pointer to argument to the &lt;code&gt;func&lt;/code&gt; function.</source>
          <target state="translated">Указатель на аргумент &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f4cacb4211d371a86050f3b2bf4514f77eeffa8" translate="yes" xml:space="preserve">
          <source>A pointer to the contents of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Указатель на содержимое &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5991945ec65c59205cb652ca3121b479552f42" translate="yes" xml:space="preserve">
          <source>A pointer to the function that implements the NIF.</source>
          <target state="translated">Указатель на функцию,реализующую NIF.</target>
        </trans-unit>
        <trans-unit id="d4bf94b670a866ff43aac180a11292d00d614edb" translate="yes" xml:space="preserve">
          <source>A pointer to thread options to use or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Указатель на используемые параметры потока или &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1206cda26f132192edd3659328975e4d3cafd278" translate="yes" xml:space="preserve">
          <source>A port can be set to use binaries instead of lists of bytes. It is then not necessary to invent any encoding/decoding scheme. Erl_Interface functions are used for unpacking the binary and convert it into a struct similar to an Erlang term. Such a struct can be manipulated in different ways, be converted to the Erlang external format, and sent to Erlang.</source>
          <target state="translated">Можно настроить порт на использование двоичных файлов вместо списков байт.Тогда нет необходимости изобретать какую-либо схему кодирования/декодирования.Функции Erl_Interface используются для распаковки бинарного файла и преобразования его в структуру,аналогичную термину Erlang.Такой структурой можно манипулировать различными способами,преобразовывать во внешний формат Erlang и отправлять на Erlang.</target>
        </trans-unit>
        <trans-unit id="c39dd0f30e9a0ba72b5dacc6b581f2019abf49ac" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Блокировка данных порта считается подсчетом ссылок, и когда счетчик ссылок достигает нуля, она уничтожается. Эмулятор, по крайней мере, увеличивает счетчик ссылок один раз при создании блокировки и уменьшает его после завершения работы порта, связанного с блокировкой. Эмулятор также увеличивает счетчик ссылок, когда асинхронное задание ставится в очередь, и уменьшает его, когда асинхронное задание было вызвано. Кроме того, драйвер отвечает за то, чтобы счетчик ссылок не достиг нуля до последнего использования блокировки драйвером. Счетчик ссылок может быть прочитан, увеличен и уменьшен с помощью &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="293c8a353a9462ae3b6bfddcb9d1223abb498be9" translate="yes" xml:space="preserve">
          <source>A port driver is a linked-in driver that is accessible as a port from an Erlang program. It is a shared library (SO in UNIX, DLL in Windows), with special entry points. The Erlang runtime system calls these entry points when the driver is started and when data is sent to the port. The port driver can also send data to Erlang.</source>
          <target state="translated">Драйвер порта-это драйвер linked-in,который доступен как порт из программы Erlang.Это разделяемая библиотека (SO в UNIX,DLL в Windows),со специальными точками входа.Система исполнения Erlang вызывает эти точки входа при запуске драйвера и при отправке данных в порт.Драйвер порта также может отправлять данные на Эрланг.</target>
        </trans-unit>
        <trans-unit id="3c0708dd623cb47c7df1202d9dbfe1fbb7d19e65" translate="yes" xml:space="preserve">
          <source>A port identifier identifies an Erlang port.</source>
          <target state="translated">Идентификатор порта идентифицирует порт Эрланг.</target>
        </trans-unit>
        <trans-unit id="19b3ddd399fc086f92748ad13d0d6c9f12e76af1" translate="yes" xml:space="preserve">
          <source>A port identifier refers into a port table and a node table, which also consumes memory.</source>
          <target state="translated">Идентификатор порта относится к таблице портов и к таблице узлов,которая также потребляет память.</target>
        </trans-unit>
        <trans-unit id="18856ffa7bc1d834314eb745f89d3f4ac81cef62" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type.</source>
          <target state="translated">Идентификатор порта. В отличие от терминов идентификатора порта (экземпляры &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; ), &lt;code&gt;ErlNifPort&lt;/code&gt; являются самодостаточными и не привязаны к какой-либо &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPort&lt;/code&gt; - непрозрачный тип.</target>
        </trans-unit>
        <trans-unit id="a5794b57a917a22a654e45737ed3a63e4f792f19" translate="yes" xml:space="preserve">
          <source>A port that is connected to a listen socket. This port does not do much, no data pumping is done on this socket, but read data is available when one is trying to do an accept on the port.</source>
          <target state="translated">Порт,подключенный к прослушивающему разъему.Этот порт не делает много,на этом сокетах не производится накачка данных,но чтение данных доступно,когда кто-то пытается сделать прием на этом порту.</target>
        </trans-unit>
        <trans-unit id="e728f787c7fc14ca780c0ed99792cf4bab0d04bc" translate="yes" xml:space="preserve">
          <source>A positive integer or &lt;code&gt;infinity&lt;/code&gt;, defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Положительное целое число или &lt;code&gt;infinity&lt;/code&gt; , по умолчанию - &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff16a10dbcc92f0a90f938ecb26a69d5a07cb38" translate="yes" xml:space="preserve">
          <source>A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (in case no messages has been sent).</source>
          <target state="translated">Положительное целое число или атом &lt;code&gt;undefined_serial&lt;/code&gt; (в случае, если сообщения не были отправлены).</target>
        </trans-unit>
        <trans-unit id="a0b0b2de29f48def22ce618959435b19ac7becd8" translate="yes" xml:space="preserve">
          <source>A positive integer representing the absolute maximum size a string returned from this formatter can have. If the formatted string is longer, after possibly being limited by &lt;code&gt;chars_limit&lt;/code&gt; or &lt;code&gt;depth&lt;/code&gt;, it is truncated.</source>
          <target state="translated">Положительное целое число, представляющее абсолютный максимальный размер строки, возвращаемой этим средством форматирования. Если форматированная строка длиннее, после возможного ограничения &lt;code&gt;chars_limit&lt;/code&gt; или &lt;code&gt;depth&lt;/code&gt; , она усекается.</target>
        </trans-unit>
        <trans-unit id="8432f1221b4e6180daa30dde8c243b5ace3ee8ed" translate="yes" xml:space="preserve">
          <source>A positive integer representing the maximum depth to which terms shall be printed by this formatter. Format strings passed to this formatter are rewritten. The format controls ~p and ~w are replaced with ~P and ~W, respectively, and the value is used as the depth parameter. For details, see &lt;code&gt;io:format/2,3&lt;/code&gt; in STDLIB.</source>
          <target state="translated">Положительное целое число, представляющее максимальную глубину, до которой термины должны быть напечатаны этим средством форматирования. Строки формата, переданные в это средство форматирования, перезаписываются. Элементы управления форматом ~ p и ~ w заменяются на ~ P и ~ W соответственно, а значение используется в качестве параметра глубины. Подробнее см. &lt;code&gt;io:format/2,3&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="4b666ac2b38c4545ad7cf98d3da66419760a1f1f" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt;io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="translated">Положительное целое число, представляющее значение параметра с тем же именем, которое будет использоваться при вызове &lt;code&gt;io_lib:format/3&lt;/code&gt; . Это значение ограничивает общее количество символов, печатаемых для каждого события журнала. Обратите внимание, что это мягкий предел. Чтобы узнать о жестком пределе усечения, см. &lt;code&gt;max_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00810275831c468fa832818d7831816d4d68cc76" translate="yes" xml:space="preserve">
          <source>A positive integer, defaults to 1.</source>
          <target state="translated">Положительное целое число,по умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="eae0729316a72e8195f927b7d08f3a3e873b0f72" translate="yes" xml:space="preserve">
          <source>A possible output from the system's &lt;code&gt;sequential_tracer&lt;/code&gt; can be like this:</source>
          <target state="translated">Возможный вывод из системы &lt;code&gt;sequential_tracer&lt;/code&gt; может быть таким:</target>
        </trans-unit>
        <trans-unit id="af7898411039ac7f27c7f7c532905e5b1d3ef4a9" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;Big(X)&lt;/code&gt; is defined, which is &lt;code&gt;true&lt;/code&gt; if its argument is greater that 10:</source>
          <target state="translated">Определен предикат &lt;code&gt;Big(X)&lt;/code&gt; , который &lt;code&gt;true&lt;/code&gt; если его аргумент больше 10:</target>
        </trans-unit>
        <trans-unit id="e7d9312c9e6373085b2581d401f52947630c30ca" translate="yes" xml:space="preserve">
          <source>A predicate is a function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;any&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if there is a term &lt;code&gt;X&lt;/code&gt; in the list such that &lt;code&gt;P(X)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Предикат - это функция, которая возвращает &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;any&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , если существует терм &lt;code&gt;X&lt;/code&gt; в списке таких , что &lt;code&gt;P(X)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a559512ddfd19a254b3dc8766e06627c3cf21e5" translate="yes" xml:space="preserve">
          <source>A prefix is optional but can be be used to disambiguate between record and constant names resulting from similarly named messages and AVPs in different Diameter applications.</source>
          <target state="translated">Префикс является необязательным,но может быть использован для разделения имен записей и констант,полученных из одноименных сообщений и AVP в различных приложениях Diameter.</target>
        </trans-unit>
        <trans-unit id="c17bae9646cdd5e9bda0a78a3791df32fbe7c33e" translate="yes" xml:space="preserve">
          <source>A previously loaded module contains an &lt;code&gt;-on_load&lt;/code&gt; function that never finished.</source>
          <target state="translated">Ранее загруженный модуль содержит функцию &lt;code&gt;-on_load&lt;/code&gt; , которая никогда не завершалась.</target>
        </trans-unit>
        <trans-unit id="1b8f8657029f4d6aa6e01af505f0ff328ca9512f" translate="yes" xml:space="preserve">
          <source>A problem can arise if a replicated table on one node is initiated, but &lt;code&gt;Mnesia&lt;/code&gt; deduces that another (remote) replica is more recent than the replica existing on the local node, and the initialization procedure does not proceed. In this situation, a call to &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt;, suspends the caller until the remote node has initialized the table from its local disc and the node has copied the table over the network to the local node.</source>
          <target state="translated">Проблема может возникнуть, если реплицируемая таблица на одном узле инициирована, но &lt;code&gt;Mnesia&lt;/code&gt; делает вывод, что другая (удаленная) реплика является более новой, чем реплика, существующая на локальном узле, и процедура инициализации не продолжается. В этой ситуации вызов &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt; приостанавливает выполнение вызывающей стороны до тех пор, пока удаленный узел не инициализирует таблицу со своего локального диска и узел не скопирует таблицу по сети на локальный узел.</target>
        </trans-unit>
        <trans-unit id="8ebbb1fef06e8f55da3f26cfd1b065a870dd9421" translate="yes" xml:space="preserve">
          <source>A process calling &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;spawn_link&lt;/code&gt;, &lt;code&gt;spawn_monitor&lt;/code&gt;, or &lt;code&gt;spawn_opt&lt;/code&gt; is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out.</source>
          <target state="translated">Процесс, вызывающий &lt;code&gt;spawn&lt;/code&gt; , &lt;code&gt;spawn_link&lt;/code&gt; , &lt;code&gt;spawn_monitor&lt;/code&gt; или &lt;code&gt;spawn_opt&lt;/code&gt; , планируется сразу после завершения вызова. Когда используются более высокие модифицированные уровни синхронизации, вызывающий абонент также спит некоторое время после того, как это запланировано.</target>
        </trans-unit>
        <trans-unit id="072b0b4dc3c07ad9ff81bf5af27f95232daef7d4" translate="yes" xml:space="preserve">
          <source>A process can also be terminated if it receives an exit signal with another exit reason than &lt;code&gt;normal&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Процесс также может быть завершен, если он получает сигнал выхода с другой причиной выхода, чем &lt;code&gt;normal&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f16a41a56038d323a59c139120b39c4d98df3227" translate="yes" xml:space="preserve">
          <source>A process can also call the function &lt;code&gt;exit(Pid,Reason)&lt;/code&gt;. This results in an exit signal with exit reason &lt;code&gt;Reason&lt;/code&gt; being emitted to &lt;code&gt;Pid&lt;/code&gt;, but does not affect the calling process.</source>
          <target state="translated">Процесс также может вызывать функцию &lt;code&gt;exit(Pid,Reason)&lt;/code&gt; . Это приводит к сигналу выхода с выходом Причина &lt;code&gt;Reason&lt;/code&gt; излучаемый на &lt;code&gt;Pid&lt;/code&gt; , но не влияет на процесс вызова.</target>
        </trans-unit>
        <trans-unit id="e6966f7ea916abf9765baf180b15bfc451003b50" translate="yes" xml:space="preserve">
          <source>A process can be set to trap exit signals by calling:</source>
          <target state="translated">Процесс может быть настроен на ловушку сигналов выхода путем вызова:</target>
        </trans-unit>
        <trans-unit id="51d9fe10dcef55d7d44c0442f222152ab34ddbe3" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="translated">Процесс может быть приостановлен несколькими процессами и может быть приостановлен несколько раз одним процессом. Приостановленный процесс не выходит из приостановленного состояния, пока его счетчик приостановки не достигнет нуля. Счетчик приостановки &lt;code&gt;Suspendee&lt;/code&gt; уменьшается, когда &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; вызывается тем же процессом, который вызвал &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt; . Все увеличенные счетчики приостановок для других процессов, полученные процессом, автоматически уменьшаются при завершении процесса.</target>
        </trans-unit>
        <trans-unit id="32f69066cd227a9815efdfec6c96cb7e6e8de0aa" translate="yes" xml:space="preserve">
          <source>A process can terminate itself by calling one of the following BIFs:</source>
          <target state="translated">Процесс может завершиться вызовом одного из следующих BIF:</target>
        </trans-unit>
        <trans-unit id="bd5238f73e1d44a290b4f80529059292d57da507" translate="yes" xml:space="preserve">
          <source>A process fixes a table by calling &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt;. The table remains fixed until the process releases it by calling &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt;, or until the process terminates.</source>
          <target state="translated">Процесс исправляет таблицу, вызывая &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt; . Таблица остается фиксированной, пока процесс не освободит ее, вызвав &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt; , или пока процесс не завершится.</target>
        </trans-unit>
        <trans-unit id="42b2c1b73ec6ef9ef96e79e9e9449854c76818bb" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type.</source>
          <target state="translated">Идентификатор процесса (pid). В отличие от терминов pid (экземпляры &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; ), &lt;code&gt;ErlNifPid&lt;/code&gt; являются самодостаточными и не привязаны к какой-либо &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPid&lt;/code&gt; - непрозрачный тип.</target>
        </trans-unit>
        <trans-unit id="37148f5c507ec0173b138452557614229468263f" translate="yes" xml:space="preserve">
          <source>A process identifier as in &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt;. Represents the process in which the fun was created.</source>
          <target state="translated">Идентификатор процесса, как в &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; . Представляет процесс, в котором было создано веселье.</target>
        </trans-unit>
        <trans-unit id="10461d2fc7608d820f0dfe163bcb992712ebe48a" translate="yes" xml:space="preserve">
          <source>A process identifier refers into a process table and a node table, which also consumes memory.</source>
          <target state="translated">Идентификатор процесса относится к таблице процесса и к таблице узлов,которая также потребляет память.</target>
        </trans-unit>
        <trans-unit id="69b2f4b3ae91aebe493ff76d27f3c271b8cfb661" translate="yes" xml:space="preserve">
          <source>A process identifier, pid, identifies a process.</source>
          <target state="translated">Идентификатор процесса,pid,идентифицирует процесс.</target>
        </trans-unit>
        <trans-unit id="98c8d95b2cf9ab7d1d26152983625cb3f9b34934" translate="yes" xml:space="preserve">
          <source>A process in a supervision tree is expected to terminate with the same reason as its parent.</source>
          <target state="translated">Ожидается,что процесс в дереве наблюдения завершится по той же причине,что и его родитель.</target>
        </trans-unit>
        <trans-unit id="d6ba7c3c946bdd4b03479883e86c12f1505bd1d6" translate="yes" xml:space="preserve">
          <source>A process is created by calling &lt;code&gt;spawn&lt;/code&gt;:</source>
          <target state="translated">Процесс создается путем вызова &lt;code&gt;spawn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="655669bae8fcf2c6bd4e506e48fb385c11ebcc8b" translate="yes" xml:space="preserve">
          <source>A process is said to &lt;strong&gt;use&lt;/strong&gt; a module &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification used to start the process, see &lt;code&gt;supervisor(3)&lt;/code&gt;. In the case of &lt;code&gt;gen_event&lt;/code&gt;, an event manager process is said to use &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is an installed event handler.</source>
          <target state="translated">Говорят, что процесс &lt;strong&gt;использует&lt;/strong&gt; модуль &lt;code&gt;Mod&lt;/code&gt; , если &lt;code&gt;Mod&lt;/code&gt; указан в части &amp;laquo; &lt;code&gt;Modules&lt;/code&gt; дочерней спецификации, используемой для запуска процесса, см. &lt;code&gt;supervisor(3)&lt;/code&gt; . В случае &lt;code&gt;gen_event&lt;/code&gt; говорят , что процесс диспетчера событий использует &lt;code&gt;Mod&lt;/code&gt; , если &lt;code&gt;Mod&lt;/code&gt; является установленным обработчиком событий.</target>
        </trans-unit>
        <trans-unit id="6ce5d54306fa5b34ccef5a88ec9ab67fc328d882" translate="yes" xml:space="preserve">
          <source>A process is said to terminate &lt;strong&gt;normally&lt;/strong&gt;, if the exit reason is the atom &lt;code&gt;normal&lt;/code&gt;. A process with no more code to execute terminates normally.</source>
          <target state="translated">Говорят, что процесс завершается &lt;strong&gt;нормально&lt;/strong&gt; , если причиной выхода является &lt;code&gt;normal&lt;/code&gt; атом . Процесс, у которого больше нет кода для выполнения, завершается нормально.</target>
        </trans-unit>
        <trans-unit id="c38c68c3f6186a6925602a46f9f750d6d6a871ba" translate="yes" xml:space="preserve">
          <source>A process started using one of these functions stores information (for example, about the ancestors and initial call) that is needed for a process in a supervision tree.</source>
          <target state="translated">Процесс,запущенный с помощью одной из этих функций,хранит информацию (например,о предках и начальном вызове),необходимую для процесса в дереве наблюдения.</target>
        </trans-unit>
        <trans-unit id="8a720c57ae355af10862b0bdc7f574cf5fde79d5" translate="yes" xml:space="preserve">
          <source>A process terminates when there is nothing more for it to do, that is, the last function it calls simply returns and does not call another function. Another way for a process to terminate is for it to call &lt;code&gt;exit/1&lt;/code&gt;. The argument to &lt;code&gt;exit/1&lt;/code&gt; has a special meaning, which is discussed later. In this example, &lt;code&gt;exit(normal)&lt;/code&gt; is done, which has the same effect as a process running out of functions to call.</source>
          <target state="translated">Процесс завершается, когда ему больше нечего делать, то есть последняя вызываемая им функция просто возвращается и не вызывает другую функцию. Другой способ завершить процесс - вызвать &lt;code&gt;exit/1&lt;/code&gt; . Аргумент &lt;code&gt;exit/1&lt;/code&gt; имеет особое значение, которое обсуждается позже. В этом примере выполняется &lt;code&gt;exit(normal)&lt;/code&gt; , который имеет тот же эффект, что и процесс, у которого заканчиваются функции для вызова.</target>
        </trans-unit>
        <trans-unit id="b7284987fd39b3d4aa792c2690fb0c00bf937e45" translate="yes" xml:space="preserve">
          <source>A process terminates with an exit reason &lt;code&gt;{Reason,Stack}&lt;/code&gt; when a run-time error occurs. See &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Процесс завершается по причине выхода &lt;code&gt;{Reason,Stack}&lt;/code&gt; , когда возникает ошибка времени выполнения. См. &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f5ab350433257813ae5457fda256563bb26173" translate="yes" xml:space="preserve">
          <source>A process that has subscribed receives the messages &lt;code&gt;{nodeup, Node}&lt;/code&gt; and &lt;code&gt;{nodedown, Node}&lt;/code&gt; when a group node connects or disconnects, respectively.</source>
          <target state="translated">Подписавшийся процесс получает сообщения &lt;code&gt;{nodeup, Node}&lt;/code&gt; и &lt;code&gt;{nodedown, Node}&lt;/code&gt; когда узел группы подключается или отключается, соответственно.</target>
        </trans-unit>
        <trans-unit id="88f957222cd12e5811bc10dccb60ff786260ced6" translate="yes" xml:space="preserve">
          <source>A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old heap contains mostly garbage. To ensure a fullsweep occasionally, set &lt;code&gt;Number&lt;/code&gt; to a suitable value, such as 10 or 20.</source>
          <target state="translated">Процесс, который в основном имеет краткосрочные данные, редко или никогда полностью очищается, то есть старая куча в основном содержит мусор. Чтобы время от времени обеспечивать полную развертку, установите для &lt;code&gt;Number&lt;/code&gt; подходящее значение, например 10 или 20.</target>
        </trans-unit>
        <trans-unit id="b02ce9655d7ee12a68cc9c922758cfe90268e361" translate="yes" xml:space="preserve">
          <source>A process that terminates emits an &lt;strong&gt;exit signal&lt;/strong&gt; with an &lt;strong&gt;exit reason&lt;/strong&gt; that says something about which error has occurred. Normally, some information about the error is printed to the terminal.</source>
          <target state="translated">Процесс , который заканчивается выдает &lt;strong&gt;сигнал на выход&lt;/strong&gt; с &lt;strong&gt;причиной выхода&lt;/strong&gt; , что говорит о котором произошла ошибка. Обычно некоторая информация об ошибке выводится на терминал.</target>
        </trans-unit>
        <trans-unit id="4c1ad1b1dc6212b6747cc5b78c88b6a9bc5616a4" translate="yes" xml:space="preserve">
          <source>A process uses a module if the name is listed in &lt;code&gt;Modules&lt;/code&gt; in the child specification for the process.</source>
          <target state="translated">Процесс использует модуль, если имя указано в &lt;code&gt;Modules&lt;/code&gt; в дочерней спецификации для процесса.</target>
        </trans-unit>
        <trans-unit id="d52b7cef11e2674343ad2926d3e4df68d2f02770" translate="yes" xml:space="preserve">
          <source>A process which encounters a runtime error (for example, divide by zero, bad match, trying to call a function that does not exist and so on) exits with an error, that is, has an &lt;strong&gt;abnormal&lt;/strong&gt; exit. A process which executes &lt;code&gt;exit(Reason)&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is any Erlang term except the atom &lt;code&gt;normal&lt;/code&gt;, also has an abnormal exit.</source>
          <target state="translated">Процесс, который обнаруживает ошибку времени выполнения (например, деление на ноль, неправильное совпадение, попытка вызвать функцию, которая не существует, и т. Д.) Завершается с ошибкой, то есть имеет &lt;strong&gt;ненормальный&lt;/strong&gt; выход. Процесс, который выполняет &lt;code&gt;exit(Reason)&lt;/code&gt; где &lt;code&gt;Reason&lt;/code&gt; - это любой термин Erlang, кроме атома &lt;code&gt;normal&lt;/code&gt; , также имеет аномальный выход.</target>
        </trans-unit>
        <trans-unit id="d8cf739fd5b866124284242faae0350386ccbc38" translate="yes" xml:space="preserve">
          <source>A process which executes &lt;code&gt;exit(normal)&lt;/code&gt; or simply runs out of things to do has a &lt;strong&gt;normal&lt;/strong&gt; exit.</source>
          <target state="translated">Процесс, который выполняет &lt;code&gt;exit(normal)&lt;/code&gt; или просто заканчивает работу, имеет &lt;strong&gt;нормальный&lt;/strong&gt; выход.</target>
        </trans-unit>
        <trans-unit id="d70973a9129b09df85556ba1f21b22c9c9188ac7" translate="yes" xml:space="preserve">
          <source>A process-bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process-bound environments between NIF calls.</source>
          <target state="translated">Среда,связанная с процессом,содержит переходную информацию о вызывающем процессе Erlang.Среда действительна только в том потоке,в который она была передана в качестве аргумента,до тех пор,пока NIF не вернется.Таким образом,бесполезно и опасно хранить указатели на связанные с процессами среды между вызовами NIF.</target>
        </trans-unit>
        <trans-unit id="8439869a5f898e9ec34e7c4ce1fd0dfa05b36050" translate="yes" xml:space="preserve">
          <source>A program development technique where you continuously write tests &lt;strong&gt;before&lt;/strong&gt; you implement the code that is supposed to pass those tests. This can help you focus on solving the right problems, and not make a more complicated implementation than necessary, by letting the unit tests determine when a program is &quot;done&quot;: if it fulfils its specifications, there is no need to keep adding functionality.</source>
          <target state="translated">Метод разработки программ, при котором вы постоянно пишете тесты &lt;strong&gt;перед&lt;/strong&gt; тем, как реализовать код, который должен пройти эти тесты. Это может помочь вам сосредоточиться на решении правильных проблем и не создавать более сложную реализацию, чем необходимо, позволяя модульным тестам определять, когда программа &quot;завершена&quot;: если она соответствует ее спецификациям, нет необходимости продолжать добавлять функциональные возможности.</target>
        </trans-unit>
        <trans-unit id="31698109f367fecfe3048c58496050f0b7013f39" translate="yes" xml:space="preserve">
          <source>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</source>
          <target state="translated">Программа работает независимо от местоположения данных.Не имеет значения,находятся ли данные на локальном узле или на удаленном.</target>
        </trans-unit>
        <trans-unit id="31abad1a30c128c77e1602c287c4f23c333d4d5c" translate="yes" xml:space="preserve">
          <source>A programming language is not much use if you only can run code from the shell. So here is a small Erlang program. Enter it into a file named &lt;code&gt;tut.erl&lt;/code&gt; using a suitable text editor. The file name &lt;code&gt;tut.erl&lt;/code&gt; is important, and also that it is in the same directory as the one where you started &lt;code&gt;erl&lt;/code&gt;). If you are lucky your editor has an Erlang mode that makes it easier for you to enter and format your code nicely (see &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; in Tools User's Guide), but you can manage perfectly well without. Here is the code to enter:</source>
          <target state="translated">Язык программирования бесполезен, если вы можете запускать код только из оболочки. Итак, вот небольшая программа на Erlang. Введите его в файл с именем &lt;code&gt;tut.erl&lt;/code&gt; , используя подходящий текстовый редактор. Важно имя файла &lt;code&gt;tut.erl&lt;/code&gt; , а также то, что он находится в том же каталоге, что и тот, где вы запустили &lt;code&gt;erl&lt;/code&gt; ). Если вам повезло, в вашем редакторе есть режим Erlang, который упрощает вам ввод и форматирование кода (см. &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; в Руководстве пользователя инструментов), но вы можете прекрасно справиться и без него. Вот код для входа:</target>
        </trans-unit>
        <trans-unit id="01bea3eff51113f444f36e486039be93438b9aa1" translate="yes" xml:space="preserve">
          <source>A progress report is issued when a supervisor starts or restarts a child. A progress report contains the following items:</source>
          <target state="translated">Отчет о проделанной работе выдается,когда руководитель начинает или перезапускает ребенка.Отчет о проделанной работе содержит следующие пункты:</target>
        </trans-unit>
        <trans-unit id="dfa1a1d7586f8b047c09414dbfe4922da8132644" translate="yes" xml:space="preserve">
          <source>A protocol-independent equivalent of &lt;code&gt;tos&lt;/code&gt; above. Setting priority implies setting &lt;code&gt;tos&lt;/code&gt; as well.</source>
          <target state="translated">Независимый от протокола эквивалент приведенных выше &lt;code&gt;tos&lt;/code&gt; . Установка приоритета подразумевает также установку &lt;code&gt;tos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dcc85d5e6a8d3b2dabc11b50011d74738e45c9a" translate="yes" xml:space="preserve">
          <source>A proxy-authorization header using the provided username and password is added to the request.</source>
          <target state="translated">К запросу добавляется заголовок прокси-авторизации,использующий предоставленные имя пользователя и пароль.</target>
        </trans-unit>
        <trans-unit id="fca72e9fdf4fbe435757ecdf4f89e484c25bdd95" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для сеанса запрошен псевдотерминал. &lt;code&gt;Terminal&lt;/code&gt; - это значение переменной среды TERM, то есть &lt;code&gt;vt100&lt;/code&gt; . Параметры нулевого размера следует игнорировать. Размеры символа / строки имеют приоритет над размерами в пикселях (если они не равны нулю). Размеры в пикселях относятся к области рисования окна. &lt;code&gt;Opcode&lt;/code&gt; в списке &lt;code&gt;TerminalModes&lt;/code&gt; - это мнемоническое имя, представленное в виде строчного атома Эрланга, определенное в &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; , раздел 8. Он также может быть &lt;code&gt;Opcode&lt;/code&gt; если мнемоническое имя не указано в RFC. Пример: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt; . Это событие отправляется в результате вызова &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d53dd83df64a4aed582356aeff9d756b34b98db4" translate="yes" xml:space="preserve">
          <source>A qualifier Q is one of the following:</source>
          <target state="translated">Квалификатор Q является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="16e918dd54f68fd1cee2a154501ced6dc2ab06fa" translate="yes" xml:space="preserve">
          <source>A query handle is evaluated in the following order:</source>
          <target state="translated">Ручка обработки запросов обрабатывается в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="f61712a9538d9f895b83ffb3d3be147091cb2096" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on the current platform.</source>
          <target state="translated">Необработанный запрос параметра &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; может использоваться для получения информации о параметрах сокета, которые (явно) не поддерживаются эмулятором. Использование необработанных параметров сокета делает код непереносимым, но позволяет программисту на Erlang использовать необычные функции, присутствующие на текущей платформе.</target>
        </trans-unit>
        <trans-unit id="8ff008f39f98c26bb673531ccb371655a692f01c" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; data type, and the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Рекомендуемая отправная точка для начинающего пользователя - это документация по &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; данных syntaxTree () и &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; функции / 1 .</target>
        </trans-unit>
        <trans-unit id="1e58752debf6eb10b77ef1dd1dbb8c914a8de4f8" translate="yes" xml:space="preserve">
          <source>A record definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the record.</source>
          <target state="translated">Определение записи может быть размещено где угодно среди атрибутов и деклараций функций модуля,но определение должно прийти до любого использования записи.</target>
        </trans-unit>
        <trans-unit id="ba583d421bbddc518a0b6122d30465ab600660d3" translate="yes" xml:space="preserve">
          <source>A record definition consists of the name of the record, followed by the field names of the record. Record and field names must be atoms. Each field can be given an optional default value. If no default value is supplied, &lt;code&gt;undefined&lt;/code&gt; is used.</source>
          <target state="translated">Определение записи состоит из имени записи, за которым следуют имена полей записи. Имена записей и полей должны быть атомами. Каждому полю может быть присвоено необязательное значение по умолчанию. Если значение по умолчанию не указано, используется &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbaae8298ac3d9e6e938e77fc79043b34deaf0a" translate="yes" xml:space="preserve">
          <source>A record has possibly been deleted with &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;OldRecord&lt;/code&gt; contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">Возможно, запись была удалена с помощью &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;OldRecord&lt;/code&gt; содержит значение старой записи, как указано приложением в качестве аргумента. Обратите внимание, что другие записи с тем же ключом могут оставаться в таблице, если она имеет тип &lt;code&gt;bag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72d63fe5211c7ae3ef0a86204219aaaa2f059f47" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. However, a record is not a true data type. Instead, record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">Запись - это структура данных для хранения фиксированного количества элементов. Он имеет именованные поля и похож на структуру в C. Однако запись не является истинным типом данных. Вместо этого выражения записи преобразуются в выражения кортежа во время компиляции. Следовательно, выражения записи не распознаются оболочкой, если не предпринимаются специальные действия. За подробностями обращайтесь к странице руководства &lt;code&gt;shell(3)&lt;/code&gt; в STDLIB).</target>
        </trans-unit>
        <trans-unit id="10b1bbed2ccfee04b70ac0a61eb0d3ccdccb28c7" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. Record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">Запись - это структура данных для хранения фиксированного количества элементов. Он имеет именованные поля и похож на структуру в C. Выражения записи преобразуются в выражения кортежа во время компиляции. Следовательно, выражения записи не распознаются оболочкой, если не предпринимаются специальные действия. За подробностями обращайтесь к странице руководства &lt;code&gt;shell(3)&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="c08da4f4936f6c7ef6c5c849615f4e5aa16f8d6a" translate="yes" xml:space="preserve">
          <source>A record is defined as:</source>
          <target state="translated">Запись определяется как:</target>
        </trans-unit>
        <trans-unit id="2caff8ac97a88a40d8081c22ddabb3164e9d8ee2" translate="yes" xml:space="preserve">
          <source>A record that describes an employee can look as follows:</source>
          <target state="translated">Запись,описывающая сотрудника,может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="ea49bf259e7f3ffbeb1c63e53edd2986c4da3837" translate="yes" xml:space="preserve">
          <source>A reference is a term that is unique in an Erlang runtime system, created by calling &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">Ссылка - это термин, который является уникальным в системе времени выполнения Erlang, созданный путем вызова &lt;code&gt;make_ref/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14e8331cdb8c151b2856ff19909f37919f2942e9" translate="yes" xml:space="preserve">
          <source>A reference refers into a node table, which also consumes memory.</source>
          <target state="translated">Ссылка относится к таблице узлов,которая также потребляет память.</target>
        </trans-unit>
        <trans-unit id="0a4f0d6f1f9b5df543605d7bc8edbd15d630e93c" translate="yes" xml:space="preserve">
          <source>A registered name.</source>
          <target state="translated">Зарегистрированное имя.</target>
        </trans-unit>
        <trans-unit id="4417be038ecab856e8399ba11dec3102f33f7d40" translate="yes" xml:space="preserve">
          <source>A registered send operation has occurred and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contains the pid of the sender. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; зарегистрированная операция отправки, и emsg-&amp;gt; from содержит pid отправителя. Сообщение находится в &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e77a6a05b56401cd9d0ab970f691941ff41f5126" translate="yes" xml:space="preserve">
          <source>A registered send operation occurred. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contains the pid of the sender.</source>
          <target state="translated">Произошла зарегистрированная операция отправки. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; содержит идентификатор отправителя.</target>
        </trans-unit>
        <trans-unit id="f8d3748e235b7729da3350a0d2920104b36dba36" translate="yes" xml:space="preserve">
          <source>A registry that has previously been created with &lt;code&gt;ei_reg_open()&lt;/code&gt; is closed, and all the objects it contains are freed.</source>
          <target state="translated">Реестр, который ранее был создан с помощью &lt;code&gt;ei_reg_open()&lt;/code&gt; , закрывается, и все содержащиеся в нем объекты освобождаются.</target>
        </trans-unit>
        <trans-unit id="d54a6449f65944104c58b103284695849e8fb0c0" translate="yes" xml:space="preserve">
          <source>A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.</source>
          <target state="translated">Генератор лексического анализатора на основе регулярных выражений для Erlang,похожий на lex или flex.</target>
        </trans-unit>
        <trans-unit id="d1dac6b0a35eaa9eeb715296367bf1003d8ca372" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself:</source>
          <target state="translated">Регулярное выражение-это шаблон,который сопоставляется с тематической строкой слева направо.Большинство символов стоят в шаблоне и совпадают с соответствующими символами в теме.В качестве тривиального примера,следующий шаблон соответствует части строки темы,которая идентична самой себе:</target>
        </trans-unit>
        <trans-unit id="72879a85f0e7c023321bf2bf93898f7dd0d964ea" translate="yes" xml:space="preserve">
          <source>A relation R in X is &lt;strong&gt;reflexive&lt;/strong&gt; if x R x for every element x of X, it is &lt;strong&gt;symmetric&lt;/strong&gt; if x R y implies that y R x, and it is &lt;strong&gt;transitive&lt;/strong&gt; if x R y and y R z imply that x R z.</source>
          <target state="translated">Отношение R в X &lt;strong&gt;рефлексивно,&lt;/strong&gt; если x R x для каждого элемента x из X, оно &lt;strong&gt;симметрично,&lt;/strong&gt; если x R y влечет y R x, и &lt;strong&gt;транзитивно,&lt;/strong&gt; если x R y и y R z влекут x R z.</target>
        </trans-unit>
        <trans-unit id="d4e299db49e468c2bde2833d058721d987434955" translate="yes" xml:space="preserve">
          <source>A relation in a set is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is reflexive, symmetric, and transitive.</source>
          <target state="translated">Отношение в наборе является &lt;strong&gt;отношением эквивалентности,&lt;/strong&gt; если оно рефлексивно, симметрично и транзитивно.</target>
        </trans-unit>
        <trans-unit id="0ebab014aefe1952987eeb358deade3e55cb740e" translate="yes" xml:space="preserve">
          <source>A relational/object hybrid data model that is suitable for telecommunications applications.</source>
          <target state="translated">Гибридная модель реляционных/объектных данных,подходящая для телекоммуникационных приложений.</target>
        </trans-unit>
        <trans-unit id="bdbc21562cd7fcdf1a6c8c8fdaf7713b768b8540" translate="yes" xml:space="preserve">
          <source>A release package can also contain:</source>
          <target state="translated">Пакет выпуска также может содержать:</target>
        </trans-unit>
        <trans-unit id="70a237d6b6ad6eae7ebaff5d81629ed2d641cc80" translate="yes" xml:space="preserve">
          <source>A release package is always to contain:</source>
          <target state="translated">Пакет выпуска всегда должен содержать:</target>
        </trans-unit>
        <trans-unit id="ec17e9f9c454053a070fd20ff7eeb8af0a65c4c3" translate="yes" xml:space="preserve">
          <source>A release resource file, &lt;code&gt;Name.rel&lt;/code&gt;</source>
          <target state="translated">Файл ресурсов выпуска, &lt;code&gt;Name.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa054e2d79bd8ac06f390024625251631581f417" translate="yes" xml:space="preserve">
          <source>A release upgrade file, &lt;code&gt;relup&lt;/code&gt;</source>
          <target state="translated">Файл обновления выпуска, &lt;code&gt;relup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe2e6189285d97d6577d1e21b467c08a9445c7c" translate="yes" xml:space="preserve">
          <source>A released application must follow a certain structure.</source>
          <target state="translated">Выпущенное приложение должно следовать определенной структуре.</target>
        </trans-unit>
        <trans-unit id="1ffc64bafad7783a2c6df745a520b71eddb2ea11" translate="yes" xml:space="preserve">
          <source>A relup script can only have one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and it must always be placed at the end. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">Сценарий relup может иметь только одну инструкцию &lt;code&gt;restart_emulator&lt;/code&gt; , и ее всегда нужно размещать в конце. Если повторная установка создается с помощью &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; , это обеспечивается автоматически.</target>
        </trans-unit>
        <trans-unit id="c55e43ee14cb55c89c46dda7dd3c64e06ed074e9" translate="yes" xml:space="preserve">
          <source>A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (directly or through NFS).</source>
          <target state="translated">Удаленный файловый сервер Erlang не может быть использован.Компьютер,на котором запущен узел Erlang,должен иметь доступ к файловой системе (напрямую или через NFS).</target>
        </trans-unit>
        <trans-unit id="a57b69cf3ad43e824a3831ee7e57db92ae3dde80" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="translated">Удаленное выполнение может быть завершено принудительно из-за сигнала. Тогда это сообщение можно будет получить. Дополнительные сведения о допустимых строковых значениях см. В разделе 6.10 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; , в котором показан особый случай этих сигналов.</target>
        </trans-unit>
        <trans-unit id="cfa0f3b36cc97b41ae10c4a61219216ab07da247" translate="yes" xml:space="preserve">
          <source>A remote node Y must be known to node X if there exists any pids, ports, references, or funs (Erlang data types) from Y on X, or if X and Y are connected. The maximum number of remote nodes simultaneously/ever known to a node is limited by the &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; available for node names. All data concerning remote nodes, except for the node name atom, are garbage-collected.</source>
          <target state="translated">Удаленный узел Y должен быть известен узлу X, если существуют какие-либо pid, порты, ссылки или funs (типы данных Erlang) из Y на X, или если X и Y связаны. Максимальное количество удаленных узлов, одновременно / когда-либо известных узлу, ограничено &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; доступных для имен узлов. Все данные об удаленных узлах, за исключением атома имени узла, собираются сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="2ef0e40b8a94e3602eaf0a08318e503302907b08" translate="yes" xml:space="preserve">
          <source>A reply sent with this function is not visible in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug output.</source>
          <target state="translated">Ответ, отправленный с помощью этой функции, не отображается в выводе отладки &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65b57be2761081067ca64ced4646ffe5f623f66" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="translated">Обратный вызов отчета используется модулем форматирования для преобразования сообщений журнала в форме отчета в строку формата и аргументы. Обратный вызов отчета может быть указан в метаданных для события журнала. Если в метаданных нет обратного вызова отчета, &lt;code&gt;logger_formatter&lt;/code&gt; будет использовать &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; в качестве обратного вызова по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3cb325283449bed9030a0b8eb054228f9049d2fb" translate="yes" xml:space="preserve">
          <source>A representaion of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="translated">Представление части (или диапазона) в двоичном формате. &lt;code&gt;Start&lt;/code&gt; - это смещение с нуля в &lt;code&gt;binary()&lt;/code&gt; а &lt;code&gt;Length&lt;/code&gt; - это длина этой части. В качестве входных данных для функций в этом модуле разрешена спецификация обратной части, построенная с отрицательной &lt;code&gt;Length&lt;/code&gt; , так что часть двоичного файла начинается с &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; и имеет длину - &lt;code&gt;Length&lt;/code&gt; . Это полезно для ссылки на последние &lt;code&gt;N&lt;/code&gt; байтов двоичного файла как &lt;code&gt;{size(Binary), -N}&lt;/code&gt; . Функции в этом модуле всегда возвращают &lt;code&gt;part()&lt;/code&gt; с положительной &lt;code&gt;Length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd076e54cc70b0a6f690c2fbc8ae7eee141d7ed" translate="yes" xml:space="preserve">
          <source>A representation of the current context of the pretty-printer. Can be accessed in hook functions.</source>
          <target state="translated">Представление текущего контекста симпатичного принтера.Доступно в функциях крючка.</target>
        </trans-unit>
        <trans-unit id="489f7c9165ae17355e87065058b1cd9bf9bd345f" translate="yes" xml:space="preserve">
          <source>A request to http://your.server.org/cgi-bin/example/httpd_example:yahoo would refer to httpd_example:yahoo/3 or, if that does not exist, httpd_example:yahoo/2 and http://your.server.org/cgi-bin/example/other:yahoo would not be allowed to execute.</source>
          <target state="translated">Запрос на http://your.server.org/cgi-bin/example/httpd_example:yahoo будет содержать ссылку на httpd_example:yahoo/3 или,если ее нет,httpd_example:yahoo/2 и http://your.server.org/cgi-bin/example/other:yahoo не будет разрешен к выполнению.</target>
        </trans-unit>
        <trans-unit id="aa222544811c186e688c873a3b1f9169cad3037b" translate="yes" xml:space="preserve">
          <source>A request to terminate the transport process after having received DPA in response to DPR. The transport process should exit. &lt;code&gt;Pid&lt;/code&gt; is the pid() of the parent process.</source>
          <target state="translated">Запрос на завершение транспортного процесса после получения DPA в ответ на DPR. Процесс транспортировки должен завершиться. &lt;code&gt;Pid&lt;/code&gt; - это pid () родительского процесса.</target>
        </trans-unit>
        <trans-unit id="7e78eeac55809d5c5a5db06a988ff97769682bea" translate="yes" xml:space="preserve">
          <source>A required variable can also be given a default value to be used if the variable is not found in any configuration file. To specify a default value, add a tuple on the form &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; to the test case information list (the position in the list is irrelevant).</source>
          <target state="translated">Обязательной переменной также может быть присвоено значение по умолчанию, которое будет использоваться, если переменная не найдена ни в одном файле конфигурации. Чтобы указать значение по умолчанию, добавьте кортеж в форме &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; в список информации о тестовом примере (позиция в списке не имеет значения).</target>
        </trans-unit>
        <trans-unit id="c1229803283f11562375509c222552c10accf62d" translate="yes" xml:space="preserve">
          <source>A resource term can be serialized with &lt;code&gt;term_to_binary&lt;/code&gt; and later be fully recreated if the resource object is still alive when &lt;code&gt;binary_to_term&lt;/code&gt; is called. A &lt;strong&gt;stale&lt;/strong&gt; resource term will be returned from &lt;code&gt;binary_to_term&lt;/code&gt; if the resource object has been deallocated. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; will return false for stale resource terms.</source>
          <target state="translated">Термин ресурса можно сериализовать с помощью &lt;code&gt;term_to_binary&lt;/code&gt; и позже полностью воссоздать, если объект ресурса все еще жив, когда &lt;code&gt;binary_to_term&lt;/code&gt; . &lt;strong&gt;Несвежий&lt;/strong&gt; термин ресурса будет возвращен из &lt;code&gt;binary_to_term&lt;/code&gt; если объект ресурса был освобожден. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; вернет false для устаревших условий ресурса.</target>
        </trans-unit>
        <trans-unit id="50ae922c622293c13dbc2965d257c86fc95a1f21" translate="yes" xml:space="preserve">
          <source>A resource to be managed is represented by a managed object, which resides in the MIB. In an SNMP MIB, the managed objects are either:</source>
          <target state="translated">Ресурс,которым необходимо управлять,представляет собой управляемый объект,который находится в MIB.В SNMP MIB управляемыми объектами являются также объекты:</target>
        </trans-unit>
        <trans-unit id="d797a366df3377e950dd7503223fc79e6918d3ba" translate="yes" xml:space="preserve">
          <source>A returned error reason can be converted into a readable string using &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; причина ошибки может быть преобразована в читаемую строку с помощью format_error / 1 .</target>
        </trans-unit>
        <trans-unit id="e1717e1bc6c4fa58d53cbf11fb5819e00bdd83ca" translate="yes" xml:space="preserve">
          <source>A rudimentary DNS client.</source>
          <target state="translated">Зачаточный DNS-клиент.</target>
        </trans-unit>
        <trans-unit id="dd25b98d67a3d5acbff27d930ee3340ca6349672" translate="yes" xml:space="preserve">
          <source>A run-time error can also be emulated by calling &lt;code&gt;erlang:error(Reason)&lt;/code&gt; or &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt;.</source>
          <target state="translated">Ошибка времени выполнения также может быть эмулирована вызовом &lt;code&gt;erlang:error(Reason)&lt;/code&gt; или &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb56303785fbc88fcc2408a8fd31a4003ffe1f34" translate="yes" xml:space="preserve">
          <source>A run-time error is another name for an exception of class &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">Ошибка времени выполнения - это другое название исключения &lt;code&gt;error&lt;/code&gt; класса .</target>
        </trans-unit>
        <trans-unit id="608acd283e8c59f26f33232a215b266093ace6dd" translate="yes" xml:space="preserve">
          <source>A run-time error is when a crash occurs. An example is when an operator is applied to arguments of the wrong type. The Erlang programming language has built-in features for handling of run-time errors.</source>
          <target state="translated">Ошибка во время выполнения-это когда происходит сбой.Пример-когда оператор применяется к аргументам неправильного типа.Язык программирования Erlang имеет встроенные возможности для работы с ошибками во время выполнения.</target>
        </trans-unit>
        <trans-unit id="1f38ec391b2ae32351853cf5569dd5468c7febd8" translate="yes" xml:space="preserve">
          <source>A runtime system Lock Profiling tool.</source>
          <target state="translated">Инструмент Блокировки Профилирования системы во время выполнения.</target>
        </trans-unit>
        <trans-unit id="95c23e7c0085aa6a0c7d2ad3fa2a9bf1781844a4" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents:</source>
          <target state="translated">Второе использование обратного слеша обеспечивает способ кодирования непечатаемых символов в шаблонах видимым образом.Нет никаких ограничений на появление непечатающихся символов,кроме двоичного нуля,который прерывает шаблон.Когда шаблон подготавливается путем редактирования текста,часто проще использовать одну из следующих экранирующих последовательностей,чем двоичный символ,который он представляет:</target>
        </trans-unit>
        <trans-unit id="a201830f8803ef3e185325b4733be9adee2043a8" translate="yes" xml:space="preserve">
          <source>A second way to specify the configuration file is to set environment variable &lt;code&gt;ERL_INETRC&lt;/code&gt; to the full name of the file. Example (bash):</source>
          <target state="translated">Второй способ указать файл конфигурации - установить в переменной среды &lt;code&gt;ERL_INETRC&lt;/code&gt; полное имя файла. Пример (bash):</target>
        </trans-unit>
        <trans-unit id="3ab326930bafdf3ccbffeefe99fd3e37e21b2a36" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf16&lt;/code&gt; can match 2 or 4 bytes in the binary. The match fails if the binary at the match position does not contain a legal UTF-16 encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</source>
          <target state="translated">Сегмент типа &lt;code&gt;utf16&lt;/code&gt; может соответствовать 2 или 4 байтам в двоичном файле . Сопоставление не удается, если двоичный файл в позиции сопоставления не содержит допустимую кодировку UTF-16 кодовой точки Unicode. (См. RFC-2781 или стандарт Unicode.)</target>
        </trans-unit>
        <trans-unit id="39d79b140754fe8ea4a56be0590e56af2f7d1ffd" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf32&lt;/code&gt; can match 4 bytes in the binary in the same way as an &lt;code&gt;integer&lt;/code&gt; segment matches 32 bits. The match fails if the resulting integer is outside the legal ranges mentioned above.</source>
          <target state="translated">Сегмент типа &lt;code&gt;utf32&lt;/code&gt; может соответствовать 4 байтам в двоичном формате так же, как &lt;code&gt;integer&lt;/code&gt; сегмент соответствует 32 битам. Сопоставление не удается, если результирующее целое число выходит за пределы допустимых диапазонов, указанных выше.</target>
        </trans-unit>
        <trans-unit id="9984182f8f78656080573a1d2d8804143caf4c98" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf8&lt;/code&gt; matches 1-4 bytes in the binary, if the binary at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the Unicode standard.)</source>
          <target state="translated">Сегмент типа &lt;code&gt;utf8&lt;/code&gt; соответствует 1&amp;ndash;4 байтам в двоичном файле, если двоичный файл в позиции сопоставления содержит допустимую последовательность UTF-8. (См. RFC-3629 или стандарт Unicode.)</target>
        </trans-unit>
        <trans-unit id="a68e30a75c41fb283b1d801f37a87f7e17458fd0" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behavior as for any &lt;code&gt;gen_*&lt;/code&gt; behavior, as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviors must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the callback module.</source>
          <target state="translated">Выборочный прием не может быть использован из поведения &lt;code&gt;gen_statem&lt;/code&gt; , как и для любого поведения &lt;code&gt;gen_*&lt;/code&gt; , поскольку оператор приема находится внутри самого &lt;code&gt;gen_*&lt;/code&gt; . Он должен быть там, потому что все &lt;code&gt;sys&lt;/code&gt; - совместимые поведения должны отвечать на системные сообщения и, следовательно, делать это в цикле приема своего движка, передавая несистемные сообщения в модуль обратного вызова.</target>
        </trans-unit>
        <trans-unit id="784ef7e594348fdd6dc02214ab3a2844aad416d3" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="translated">Группа последовательностей может иметь подгруппы. Такие подгруппы могут иметь любое свойство, то есть они не обязательно должны быть последовательностями. Если вы хотите, чтобы статус подгруппы влиял на последовательность на уровне выше, верните &lt;code&gt;{return_group_result,Status}&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; , как описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; в написании наборов тестов&amp;raquo;. Неудачная подгруппа ( &lt;code&gt;Status == failed&lt;/code&gt; ) вызывает сбой выполнения последовательности так же, как и тестовый пример.</target>
        </trans-unit>
        <trans-unit id="d3c229a36faac40695a5902fc9fc7dd25d6c2813" translate="yes" xml:space="preserve">
          <source>A sequence of test cases is defined as a test case group with a &lt;code&gt;sequence&lt;/code&gt; property. Test case groups are defined through function &lt;code&gt;groups/0&lt;/code&gt; in the test suite (for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Последовательность тестовых примеров определяется как группа тестовых примеров со свойством &lt;code&gt;sequence&lt;/code&gt; . Группы тестовых наборов определяются через &lt;code&gt;groups/0&lt;/code&gt; функций / 0 в наборе тестов (подробности см. В разделе &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; тестовых примеров .</target>
        </trans-unit>
        <trans-unit id="c3bba90a5446a96b415be975533162f2c93173c4" translate="yes" xml:space="preserve">
          <source>A server (daemon) is started with &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt;. Possible channel handlers (subsystems) are declared with the &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; option when the daemon is started.</source>
          <target state="translated">Сервер (демон) запускается с помощью &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt; . Возможные обработчики каналов (подсистемы) объявляются с параметром &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; при запуске демона.</target>
        </trans-unit>
        <trans-unit id="7591fe377fd82c97d5cbe48dffa3dba89975a255" translate="yes" xml:space="preserve">
          <source>A server only does x509-path validation in mode &lt;code&gt;verify_peer&lt;/code&gt;, as it then sends a certificate request to the client (this message is not sent if the verify option is &lt;code&gt;verify_none&lt;/code&gt;). You can then also want to specify option &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt;.</source>
          <target state="translated">Сервер выполняет только проверку x509-пути в режиме &lt;code&gt;verify_peer&lt;/code&gt; , поскольку затем он отправляет клиенту запрос сертификата (это сообщение не отправляется, если опция проверки - &lt;code&gt;verify_none&lt;/code&gt; ). Затем вы также можете указать опцию &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d55cabe8354d1d604d4df37a3e5535ff9d3abddc" translate="yes" xml:space="preserve">
          <source>A server which receives just enough requests to never become idle will score a CPU utilization of 100%. If the server receives 50% more requests, it will still score 100%. When the system load is calculated with the percentage formula shown previously, the load will increase from 80% to 87%.</source>
          <target state="translated">Сервер,который получает достаточно запросов,чтобы никогда не простаивать,получит 100% загрузку процессора.Если сервер получает на 50% больше запросов,он все равно получит 100%.Когда загрузка системы рассчитывается по формуле процента,показанной ранее,нагрузка увеличится с 80% до 87%.</target>
        </trans-unit>
        <trans-unit id="49249370ad03c7d756d03cbc940860544a07d772" translate="yes" xml:space="preserve">
          <source>A server- or client-channel process can choose to close their session by sending a close event.</source>
          <target state="translated">Процесс серверного или клиентского канала может решить закрыть свою сессию,отправив событие закрытия.</target>
        </trans-unit>
        <trans-unit id="80df1578413d7127e8d72a01fdf816a3b3d60cac" translate="yes" xml:space="preserve">
          <source>A server-side subssystem (channel) server is requested by the client with &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сервер подсистемы (канала) на стороне сервера запрашивается клиентом с помощью &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d3204ae6a9c144bcf2930bab159f079cdea0012" translate="yes" xml:space="preserve">
          <source>A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Служба определяет локально реализованный узел Diameter, определяя возможности, которые будут объявляться во время обмена возможностями. Транспорты добавляются к сервису с помощью &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4b0724093ca8cf67b42fd8065ef62234f98ab2d" translate="yes" xml:space="preserve">
          <source>A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; is passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">Служба должна настроить один кортеж для каждого приложения Diameter, которое она намеревается поддерживать. Для исходящего запроса соответствующий &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; передается в &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; , в то время как для входящего запроса идентификатор приложения в заголовке сообщения определяет приложение, идентификатор указывается в файле &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; приложения .</target>
        </trans-unit>
        <trans-unit id="aaffe8ed9bffeb5034f89141848d697c4f8ddf46" translate="yes" xml:space="preserve">
          <source>A service started as &lt;code&gt;stand_alone&lt;/code&gt;, that is, the service is not started as part of the &lt;code&gt;Inets&lt;/code&gt; application, lose all OTP application benefits, such as soft upgrade. The &lt;code&gt;stand_alone&lt;/code&gt;-service is linked to the process that started it. Usually some supervision functionality is still in place and in some sense the calling process becomes the top supervisor.</source>
          <target state="translated">Служба, запущенная как &lt;code&gt;stand_alone&lt;/code&gt; , то есть служба не запускается как часть приложения &lt;code&gt;Inets&lt;/code&gt; , теряет все преимущества приложения OTP, такие как мягкое обновление. &lt;code&gt;stand_alone&lt;/code&gt; -service связан с процессом , который начал его. Обычно некоторые функции надзора все еще используются, и в некотором смысле вызывающий процесс становится главным супервизором.</target>
        </trans-unit>
        <trans-unit id="e8a6a012891bda48b015b0c9afa1553acf746ed9" translate="yes" xml:space="preserve">
          <source>A service that does not use shared peers will always pass the empty list as the second argument of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">Служба, которая не использует общих одноранговых узлов, всегда будет передавать пустой список в качестве второго аргумента &lt;code&gt;pick_peer/4&lt;/code&gt; вызовов pick_peer / 4 .</target>
        </trans-unit>
        <trans-unit id="10b22bcc7e1248f51cdd1cbb03116a8abb78e603" translate="yes" xml:space="preserve">
          <source>A service to read internally formatted wrap disk logs.</source>
          <target state="translated">Служба для чтения внутренне отформатированных оберточных дисковых журналов.</target>
        </trans-unit>
        <trans-unit id="948069c04efacc3c5dcde4803a65b30408e7f31d" translate="yes" xml:space="preserve">
          <source>A session opened in this way is closed using function &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сессия, открытая таким образом, закрывается с помощью функции &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8dce1ed875eff8e76251a001abc25f652960e66" translate="yes" xml:space="preserve">
          <source>A set of calls between strongly connected components is a sorted list without duplicates of &lt;code&gt;ComponentCall&lt;/code&gt;.</source>
          <target state="translated">Набор вызовов между сильно связанными компонентами представляет собой отсортированный список без дубликатов &lt;code&gt;ComponentCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="710107e57e111e349884878304dfebbb60768c1a" translate="yes" xml:space="preserve">
          <source>A set of calls is represented by a sorted list without duplicates of &lt;code&gt;call()&lt;/code&gt;.</source>
          <target state="translated">Набор вызовов представлен отсортированным списком без дубликатов &lt;code&gt;call()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ec339bfafa729e7589bcb584094f5693b62949" translate="yes" xml:space="preserve">
          <source>A set of constants is represented by a sorted list without duplicates of &lt;code&gt;constant()&lt;/code&gt;.</source>
          <target state="translated">Набор констант представлен отсортированным списком без дубликатов &lt;code&gt;constant()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46692ec19a49b0489e3ac224ff31df52bd24aef0" translate="yes" xml:space="preserve">
          <source>A set of functions is provvided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="translated">Предусмотрен набор функций для отправки и получения непрерывных частей файла для сохранения в удаленном файле. Для отправки см. &lt;code&gt;send_chunk_start/2&lt;/code&gt; , &lt;code&gt;send_chunk/2&lt;/code&gt; и &lt;code&gt;send_chunk_end/1&lt;/code&gt; . Для получения см. &lt;code&gt;recv_chunk_start/2&lt;/code&gt; и &lt;code&gt;recv_chunk/&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a9d7c3dd3508b04f4667584c78e7f619f9eb1de" translate="yes" xml:space="preserve">
          <source>A set of line numbered function calls is represented by a sorted list without duplicates of &lt;code&gt;CallAt&lt;/code&gt;.</source>
          <target state="translated">Набор вызовов функций с пронумерованными &lt;code&gt;CallAt&lt;/code&gt; представлен отсортированным списком без дубликатов CallAt .</target>
        </trans-unit>
        <trans-unit id="6b7c151fe3e99d8bd5f4ffa52f47c3f04812cf74" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions and function calls is represented by a sorted list without duplicates of &lt;code&gt;AllLines&lt;/code&gt;.</source>
          <target state="translated">Набор функций и вызовов функций с номерами строк представлен отсортированным списком без дубликатов &lt;code&gt;AllLines&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="840dbd2f93a5198291444ddc8bbccef2c8f9c9ff" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions is represented by a sorted list without duplicates of &lt;code&gt;DefineAt&lt;/code&gt;.</source>
          <target state="translated">Набор функций с номерами строк представлен отсортированным списком без дубликатов &lt;code&gt;DefineAt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a5c61082d9404d5c0adf57236aa5f42fbc02337" translate="yes" xml:space="preserve">
          <source>A set of strongly connected components is a sorted list without duplicates of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">Набор сильно связанных компонентов - это отсортированный список без дубликатов &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac0087ee308abd483706f991654adce8870956a6" translate="yes" xml:space="preserve">
          <source>A set of tables is created. The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates the required database tables. The options available with &lt;code&gt;ArgList&lt;/code&gt; are explained in &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Создан набор таблиц. Функция &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; создает необходимые таблицы базы данных. Параметры, доступные в &lt;code&gt;ArgList&lt;/code&gt; , описаны в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f06211d11839665e84e1ea20d520a0f11afac6" translate="yes" xml:space="preserve">
          <source>A set of test cases sharing configuration functions and execution properties. The execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is be repeated. Test case groups can also be nested. That is, a group can, besides test cases, contain subgroups.</source>
          <target state="translated">Набор тестовых примеров,совместно использующих функции конфигурации и свойства выполнения.Свойства исполнения определяют,будут ли тестовые случаи в группе выполняться в случайном порядке,параллельно или последовательно,и будет ли выполнение группы повторяться.Группы тестовых сценариев также могут быть вложены.То есть группа может,помимо тестовых случаев,содержать подгруппы.</target>
        </trans-unit>
        <trans-unit id="12949a595f1f2f62a415607d8b62df7565321239" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">Краткая форма для &lt;code&gt;report_errors&lt;/code&gt; и &lt;code&gt;report_warnings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63beb5981caaa740ca850381d113e7457110327c" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">Краткая форма для &lt;code&gt;return_errors&lt;/code&gt; и &lt;code&gt;return_warnings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea5611de1365c235cc088e3d33261341dcca035" translate="yes" xml:space="preserve">
          <source>A signal can be delivered to the remote process/service using the following message. Some systems do not support signals, in which case they are to ignore this message. There is currently no function to generate this event as the signals referred to are on OS-level and not something generated by an Erlang program.</source>
          <target state="translated">Сигнал может быть передан удаленному процессу/службе с помощью следующего сообщения.Некоторые системы не поддерживают сигналы,в этом случае они должны игнорировать это сообщение.В настоящее время нет функции генерации этого события,так как сигналы,о которых идет речь,находятся на уровне операционной системы,а не что-то,генерируемое программой Erlang.</target>
        </trans-unit>
        <trans-unit id="42eda09ed588353be26cc09cfa2d978f18b6e4d1" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for representation of time.</source>
          <target state="translated">Знаковый 64-битный целочисленный тип для представления времени.</target>
        </trans-unit>
        <trans-unit id="2ec4fc4bbc8342af35d07fe169518f0743782cba" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for time representation.</source>
          <target state="translated">Знаковый 64-битный целочисленный тип для представления времени.</target>
        </trans-unit>
        <trans-unit id="38a842896cfe88c4a3ddef8d3cf91788c49c732c" translate="yes" xml:space="preserve">
          <source>A signed integer type, the size of &lt;code&gt;ErlDrvSizeT&lt;/code&gt;.</source>
          <target state="translated">Целочисленный тип со &lt;code&gt;ErlDrvSizeT&lt;/code&gt; , размером ErlDrvSizeT .</target>
        </trans-unit>
        <trans-unit id="0a0fe9a2b6f1d0a57855755f4b057af6a3783f46" translate="yes" xml:space="preserve">
          <source>A similar syntax as for module attributes is used for specifying types and function specifications:</source>
          <target state="translated">Синтаксис,аналогичный синтаксису атрибутов модуля,используется для указания типов и спецификаций функций:</target>
        </trans-unit>
        <trans-unit id="8a8c55df8388e2c8abf4b42d441b92ec7fc5ed46" translate="yes" xml:space="preserve">
          <source>A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</source>
          <target state="translated">Простой инструмент профилирования подсчета вызовов с использованием точек останова для минимального влияния на производительность.</target>
        </trans-unit>
        <trans-unit id="c5cb837e5d2ca7e262291078f0d5802db7966be5" translate="yes" xml:space="preserve">
          <source>A simple Erlang SCTP client that uses the &lt;code&gt;connect_init&lt;/code&gt; API:</source>
          <target state="translated">Простой клиент SCTP на Erlang, использующий API &lt;code&gt;connect_init&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d0c9a192d81f4fa039cbd886ce4bd4a73ce2b099" translate="yes" xml:space="preserve">
          <source>A simple configuration handling driver, asking an external server for configuration data, can be implemented as follows:</source>
          <target state="translated">Простой драйвер для работы с конфигурацией,запрашивающий конфигурационные данные у внешнего сервера,может быть реализован следующим образом:</target>
        </trans-unit>
        <trans-unit id="94159518c423ba9ecd622c20fd73db453e69d787" translate="yes" xml:space="preserve">
          <source>A simple distributed agent can be managed without sub-agents. The instrumentation functions can use distributed Erlang to communicate with other parts of the application. However, a sub-agent can be used on each node if this generates too much unnecessary traffic. A sub-agent processes requests per incoming SNMP request, not per variable. Therefore the network traffic is minimized.</source>
          <target state="translated">Простой распределенный агент может управляться без субагентов.Функции приборов могут использовать распределенный Erlang для связи с другими частями приложения.Однако,субагент может быть использован на каждом узле,если это генерирует слишком много ненужного трафика.Субагент обрабатывает запросы на входящий SNMP-запрос,а не на переменную.Поэтому сетевой трафик сводится к минимуму.</target>
        </trans-unit>
        <trans-unit id="37a291b9ccd26ae2e858205df24cc14753b44a96" translate="yes" xml:space="preserve">
          <source>A simple example of how to use the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">Простой пример использования компонента &quot;Менеджер&quot; в SNMP Development Toolkit.</target>
        </trans-unit>
        <trans-unit id="e0d43223e0be204bdc5f431e2cd09f2620cd3cba" translate="yes" xml:space="preserve">
          <source>A simple example of how to write agent test cases, using the new manager.</source>
          <target state="translated">Простой пример того,как писать тестовые кейсы для агентов,используя нового менеджера.</target>
        </trans-unit>
        <trans-unit id="a47de2d4ec5f53818458005215063c067e9f2a3e" translate="yes" xml:space="preserve">
          <source>A simple example. A single quad core processor can be described as follows:</source>
          <target state="translated">Простой пример.Процессор с одним четырехъядерным процессором можно описать следующим образом:</target>
        </trans-unit>
        <trans-unit id="dd61143e005b303fe8d62ae782f18058638458a2" translate="yes" xml:space="preserve">
          <source>A simple handler that prints to the terminal can be implemented as follows:</source>
          <target state="translated">Простой обработчик,который печатает на терминал,может быть реализован следующим образом:</target>
        </trans-unit>
        <trans-unit id="d231f36ed1b4dce67cc3b50e0ae15aa4df7e9395" translate="yes" xml:space="preserve">
          <source>A simple interactive configuration tool. Simple configuration files can be generated, but more complex configurations still have to be edited manually.</source>
          <target state="translated">Простой интерактивный инструмент настройки.Простые конфигурационные файлы могут быть сгенерированы,но более сложные конфигурации все равно придется редактировать вручную.</target>
        </trans-unit>
        <trans-unit id="9bb0a791b7816e17ce1b48c1aee66bf6abe2e694" translate="yes" xml:space="preserve">
          <source>A simple solution would be to use the &lt;code&gt;name&lt;/code&gt; field as the key instead of the &lt;code&gt;idno&lt;/code&gt; field, but that would cause problems if the names were not unique. A more general solution would be to create a second table with &lt;code&gt;name&lt;/code&gt; as key and &lt;code&gt;idno&lt;/code&gt; as data, that is, to index (invert) the table regarding the &lt;code&gt;name&lt;/code&gt; field. Clearly, the second table would have to be kept consistent with the master table. Mnesia can do this for you, but a home brew index table can be very efficient compared to the overhead involved in using Mnesia.</source>
          <target state="translated">Простым решением было бы использовать поле &lt;code&gt;name&lt;/code&gt; в качестве ключа вместо поля &lt;code&gt;idno&lt;/code&gt; , но это могло бы вызвать проблемы, если бы имена не были уникальными. Более общим решением было бы создать вторую таблицу с &lt;code&gt;name&lt;/code&gt; качестве ключа и &lt;code&gt;idno&lt;/code&gt; в качестве данных, то есть индексировать (инвертировать) таблицу относительно поля &lt;code&gt;name&lt;/code&gt; . Очевидно, что вторая таблица должна быть согласована с основной таблицей. Mnesia может сделать это за вас, но таблица индексов домашнего пива может быть очень эффективной по сравнению с накладными расходами, связанными с использованием Mnesia.</target>
        </trans-unit>
        <trans-unit id="a677c35bea852cdbf8756b158d2b8bcbf8d2e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue the following commands:</source>
          <target state="translated">Простой способ сделать это-выдать следующие команды:</target>
        </trans-unit>
        <trans-unit id="464b91e40e2a3cb96819c357b1617d8db059e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue these commands:</source>
          <target state="translated">Простой способ сделать это-выдать эти команды:</target>
        </trans-unit>
        <trans-unit id="eea77823d49a9512680d9b481e0a65ed1b7a8abb" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;~&lt;/code&gt; is expected in the input.</source>
          <target state="translated">На входе ожидается одиночный &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d3145e708c1deab465a16f4608e04895d3f01b3" translate="yes" xml:space="preserve">
          <source>A single atom represents a module name, and is equivalent to &lt;code&gt;{module, ModuleName}&lt;/code&gt;. This is often used as in the call &lt;code&gt;eunit:test(some_module)&lt;/code&gt;.</source>
          <target state="translated">Отдельный атом представляет имя модуля и эквивалентен &lt;code&gt;{module, ModuleName}&lt;/code&gt; . Это часто используется как в вызове &lt;code&gt;eunit:test(some_module)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="437abe5f66fc807f023b84e5b53bea27300039ac" translate="yes" xml:space="preserve">
          <source>A single binary can be sent with &lt;code&gt;driver_output_binary()&lt;/code&gt;.</source>
          <target state="translated">Один двоичный файл можно отправить с помощью &lt;code&gt;driver_output_binary()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d82ab9afcf3b874d81d1b01e2b29a3023c6ead3c" translate="yes" xml:space="preserve">
          <source>A single line (as in former example) is requested with the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">Одна линия (как в предыдущем примере) запрашивается со следующей &lt;code&gt;Request&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91eb11dd51a7d947aa277af7b00518dd07ecd8dd" translate="yes" xml:space="preserve">
          <source>A single string represents the path of a file or directory, and is equivalent to &lt;code&gt;{file, Path}&lt;/code&gt;, or &lt;code&gt;{dir, Path}&lt;/code&gt;, respectively, depending on what &lt;code&gt;Path&lt;/code&gt; refers to in the file system.</source>
          <target state="translated">Одна строка представляет путь к файлу или каталогу и эквивалентна &lt;code&gt;{file, Path}&lt;/code&gt; или &lt;code&gt;{dir, Path}&lt;/code&gt; , соответственно, в зависимости от того, на какой &lt;code&gt;Path&lt;/code&gt; ссылается в файловой системе.</target>
        </trans-unit>
        <trans-unit id="f128070bab19006a2ef91c51aaca808921167bc6" translate="yes" xml:space="preserve">
          <source>A single test included in a test suite. A test case is implemented as a function in a test suite module.</source>
          <target state="translated">Один тест,включенный в набор тестов.Тестовый пример реализован как функция в модуле набора тестов.</target>
        </trans-unit>
        <trans-unit id="c6134a35a4b3aed44a3d6f996738074a3183b087" translate="yes" xml:space="preserve">
          <source>A single, well-defined test, that somehow can be uniquely identified. When executed, the test case either &lt;strong&gt;passes&lt;/strong&gt; or &lt;strong&gt;fails&lt;/strong&gt;; the test report should identify exactly which test cases failed.</source>
          <target state="translated">Единый, четко определенный тест, который каким-то образом можно однозначно идентифицировать. При выполнении тестовый пример либо &lt;strong&gt;проходит,&lt;/strong&gt; либо &lt;strong&gt;не &lt;/strong&gt;&lt;strong&gt;проходит&lt;/strong&gt; ; отчет о тестировании должен точно определять, какие тестовые примеры не прошли.</target>
        </trans-unit>
        <trans-unit id="ff7e932fb59b9670681676d154f390a5b9707270" translate="yes" xml:space="preserve">
          <source>A situation where it might be useful to add an algorithm is when one need to use a supported but disabled one. An example is the &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; which nowadays is very unsecure and therefore disabled. It is however still supported and might be used.</source>
          <target state="translated">Ситуация, когда может быть полезно добавить алгоритм, - это когда нужно использовать поддерживаемый, но отключенный. Примером может служить &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; который в настоящее время очень небезопасен и поэтому отключен. Однако он все еще поддерживается и может быть использован.</target>
        </trans-unit>
        <trans-unit id="c8a737055966988fa33536560d8ee3886f563bb5" translate="yes" xml:space="preserve">
          <source>A skeleton is a piece of pre-written code that can be inserted into the buffer. Erlang mode comes with a set of predefined skeletons. The skeletons can be accessed either from the Erlang menu of from commands named &lt;code&gt;tempo-template-erlang-*&lt;/code&gt;, as the skeletons is defined using the standard Emacs package &quot;tempo&quot;. Here follows a brief description of the available skeletons:</source>
          <target state="translated">Каркас - это кусок заранее написанного кода, который можно вставить в буфер. В режиме Erlang есть набор предопределенных скелетов. К скелетам можно получить доступ либо из меню Erlang, либо из команд с именем &lt;code&gt;tempo-template-erlang-*&lt;/code&gt; , так как скелеты определяются с использованием стандартного пакета Emacs &amp;laquo;tempo&amp;raquo;. Ниже следует краткое описание имеющихся скелетов:</target>
        </trans-unit>
        <trans-unit id="3fbeb5f6d202d2f6a94d6926e8772e60f8395d0b" translate="yes" xml:space="preserve">
          <source>A sketch of the procedure employed:</source>
          <target state="translated">Очерк используемой процедуры:</target>
        </trans-unit>
        <trans-unit id="347ad9db1092bfae38de28e8384c541f8eda0f16" translate="yes" xml:space="preserve">
          <source>A slogan indicating the reason for the dump</source>
          <target state="translated">Лозунг,указывающий на причину свалки...</target>
        </trans-unit>
        <trans-unit id="c82db0ac725e371be4e92cf842d525309be1a960" translate="yes" xml:space="preserve">
          <source>A small &lt;code&gt;ssh&lt;/code&gt; subsystem that echoes N bytes can be implemented as shown in the following example:</source>
          <target state="translated">Небольшая подсистема &lt;code&gt;ssh&lt;/code&gt; , которая отображает N байтов, может быть реализована, как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="ee793e88b05c2c54637d37d2dc3b6df251a95612" translate="yes" xml:space="preserve">
          <source>A small note about each failed test case.</source>
          <target state="translated">Небольшая записка о каждом неудачном тесте.</target>
        </trans-unit>
        <trans-unit id="89269626521455c0533dcc1024e681dcdd2fe91d" translate="yes" xml:space="preserve">
          <source>A small number of &quot;-&quot; flags exist, which now actually are emulator flags, see the description below.</source>
          <target state="translated">Существует небольшое количество &quot;-&quot; флагов,которые теперь фактически являются эмуляторными флагами,см.описание ниже.</target>
        </trans-unit>
        <trans-unit id="b8571dea892b8010a396168429a316241eeb9263" translate="yes" xml:space="preserve">
          <source>A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;&lt;code&gt;...&lt;/code&gt;&quot;. &lt;code&gt;CharsLimit&lt;/code&gt; defaults to -1, which means no limit on the number of characters returned.</source>
          <target state="translated">Мягкое ограничение на количество возвращаемых символов. Когда количество символов достигнуто, оставшиеся структуры заменяются на &amp;laquo; &lt;code&gt;...&lt;/code&gt; &amp;raquo;. &lt;code&gt;CharsLimit&lt;/code&gt; по умолчанию равен -1, что означает отсутствие ограничения на количество возвращаемых символов.</target>
        </trans-unit>
        <trans-unit id="c5403e8588747737164215b85effd60defff4f50" translate="yes" xml:space="preserve">
          <source>A sorted list of &lt;code&gt;{Node, Count}&lt;/code&gt; tuples that are sorted in increasing &lt;code&gt;Count&lt;/code&gt; order. &lt;code&gt;Count&lt;/code&gt; is the total number of replicas that this fragmented table hosts on each &lt;code&gt;Node&lt;/code&gt;. The list always contains at least all nodes in &lt;code&gt;node_pool&lt;/code&gt;. Nodes that do not belong to &lt;code&gt;node_pool&lt;/code&gt; are put last in the list even if their &lt;code&gt;Count&lt;/code&gt; is lower.</source>
          <target state="translated">Отсортированный список &lt;code&gt;{Node, Count}&lt;/code&gt; кортежей, которые отсортированы в увеличении &lt;code&gt;Count&lt;/code&gt; порядка. &lt;code&gt;Count&lt;/code&gt; - это общее количество реплик, которые эта фрагментированная таблица размещает на каждом &lt;code&gt;Node&lt;/code&gt; . Список всегда содержит по крайней мере все узлы в &lt;code&gt;node_pool&lt;/code&gt; . Узлы , которые не принадлежат к &lt;code&gt;node_pool&lt;/code&gt; помещаются последним в списке , даже если их &lt;code&gt;Count&lt;/code&gt; является ниже.</target>
        </trans-unit>
        <trans-unit id="920a6a7e45bffb0b7a8b87d5da85daae27b47541" translate="yes" xml:space="preserve">
          <source>A space-separated string specifying the program to be executed. The second field is typically a command name such as &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Строка, разделенная пробелами, определяющая программу, которую нужно выполнить. Второе поле обычно представляет собой имя команды, например &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bbb00e915060a377363fa9765e2fd6a815cb4ee" translate="yes" xml:space="preserve">
          <source>A special item that consists of (? followed by a number &amp;gt; 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression.</source>
          <target state="translated">Специальный элемент, состоящий из (?, За которым следует число&amp;gt; 0 и закрывающая скобка, является рекурсивным вызовом подпрограммы подшаблона данного числа, если он встречается внутри этого подшаблона. (Если нет, то это нерекурсивный вызов подпрограммы , который описывается в следующем разделе.) Специальный элемент (? R) или (? 0) - это рекурсивный вызов всего регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="b5d7d4630bf6e699f86315587f52b147af8c7634" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="translated">Специальная процедура, вызываемая с помощью &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; . Он работает как &amp;laquo;ioctl&amp;raquo; для драйверов Erlang. Данные, указанные для &lt;code&gt;port_control/3&lt;/code&gt; , поступают в &lt;code&gt;buf&lt;/code&gt; и &lt;code&gt;len&lt;/code&gt; . Драйвер может отправлять данные обратно, используя &lt;code&gt;*rbuf&lt;/code&gt; и &lt;code&gt;rlen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="818bed6690afd85a8e837d5ce544a94b65462268" translate="yes" xml:space="preserve">
          <source>A special type of error is when no actual invalid integers or bytes are found, but a trailing &lt;code&gt;binary()&lt;/code&gt; consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An &lt;code&gt;incomplete&lt;/code&gt; tuple is then returned instead of the &lt;code&gt;error&lt;/code&gt; tuple. It consists of the same parts as the &lt;code&gt;error&lt;/code&gt; tuple, but the tag is &lt;code&gt;incomplete&lt;/code&gt; instead of &lt;code&gt;error&lt;/code&gt; and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.</source>
          <target state="translated">Особый тип ошибки возникает, когда не обнаруживаются действительные недопустимые целые числа или байты, но завершающий &lt;code&gt;binary()&lt;/code&gt; состоит из слишком малого количества байтов для декодирования последнего символа. Эта ошибка может возникать, если байты читаются из файла по частям или если двоичные файлы другими способами разбиваются на границах символов, отличных от UTF. &lt;code&gt;incomplete&lt;/code&gt; кортеж затем возвращаются вместо &lt;code&gt;error&lt;/code&gt; кортежа. Он состоит из тех же частей, что и кортеж с &lt;code&gt;error&lt;/code&gt; , но тег является &lt;code&gt;incomplete&lt;/code&gt; а не &lt;code&gt;error&lt;/code&gt; а последний элемент всегда гарантированно является двоичным, состоящим из первой части (пока) действительного символа UTF.</target>
        </trans-unit>
        <trans-unit id="eebe590a8a4fd637cbd36f90802e9523ed6a4512" translate="yes" xml:space="preserve">
          <source>A specification (or contract) for a function is given using the &lt;code&gt;-spec&lt;/code&gt; attribute. The general format is as follows:</source>
          <target state="translated">Спецификация (или контракт) для функции дается с использованием атрибута &lt;code&gt;-spec&lt;/code&gt; . Общий формат следующий:</target>
        </trans-unit>
        <trans-unit id="7dc4ccb3d8ddcce0db9cf1c2ea5d5fda23fcb4be" translate="yes" xml:space="preserve">
          <source>A state change cancels a &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; and any new transition option of this type belongs to the new state.</source>
          <target state="translated">Изменение состояния отменяет &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; и любая новая опция перехода этого типа принадлежит новому состоянию.</target>
        </trans-unit>
        <trans-unit id="1ce1fae1923f3d7397b496fc579d7f7f29266cd7" translate="yes" xml:space="preserve">
          <source>A status, which is &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. An inactive breakpoint is ignored.</source>
          <target state="translated">Статус, &lt;strong&gt;активный&lt;/strong&gt; или &lt;strong&gt;неактивный&lt;/strong&gt; . Неактивная точка останова игнорируется.</target>
        </trans-unit>
        <trans-unit id="cb3254f6f71d42ad5babf60af6c4beadc5fe794a" translate="yes" xml:space="preserve">
          <source>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</source>
          <target state="translated">Липкий замок-это замок,который остается на месте в узле после того,как сделка,которая первой приобрела замок,завершилась.Чтобы проиллюстрировать это,предположим,что выполняется следующая транзакция:</target>
        </trans-unit>
        <trans-unit id="0d036eed01d979d152da2689054b2a8a3616ab3b" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Строка, содержащая номер выпуска OTP (такой же, как возвращаемый &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7a887f90504538f7764832dfb1ec18f08b3d4d4e" translate="yes" xml:space="preserve">
          <source>A string containing the regular expression</source>
          <target state="translated">Строка,содержащая регулярное выражение</target>
        </trans-unit>
        <trans-unit id="e0f49966a17385c888cdd7ff3581d6cc3b4a55ee" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Строка, содержащая номер версии системы времени выполнения (такая же, как возвращаемая &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a067c189aea167f729e4e4094e5cef684c3ebe5a" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable names using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) and &lt;code&gt;$=&lt;/code&gt; characters are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">Строка, содержащая допустимые символы в конкретной ОС для имен переменных среды с использованием кодировки &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что конкретно нулевые символы (целочисленное значение ноль) и символы &lt;code&gt;$=&lt;/code&gt; не допускаются. Однако обратите внимание, что не все недопустимые символы обязательно приведут к сбою операций primitiv, но вместо этого могут дать недопустимые результаты.</target>
        </trans-unit>
        <trans-unit id="70f78f37d5d4757bbdf76a8e2359db2143d09529" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">Строка, содержащая допустимые символы для конкретной ОС для значений переменных среды с использованием кодировки &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что конкретно нулевые символы (целочисленное значение ноль) не допускаются. Однако обратите внимание, что не все недопустимые символы обязательно приведут к сбою операций primitiv, но вместо этого могут дать недопустимые результаты.</target>
        </trans-unit>
        <trans-unit id="9de478315c2065a78cf4db328a67478bae83694c" translate="yes" xml:space="preserve">
          <source>A string describing the error is obtained with the following call:</source>
          <target state="translated">Строка,описывающая ошибку,получается при следующем вызове:</target>
        </trans-unit>
        <trans-unit id="ee46978e6166eeae1dd2570aa404c6015d82f71d" translate="yes" xml:space="preserve">
          <source>A string identifying the created thread. It is used to identify the thread in planned future debug functionality.</source>
          <target state="translated">Строка,идентифицирующая созданный поток.Используется для идентификации потока в планируемой будущей отладочной функциональности.</target>
        </trans-unit>
        <trans-unit id="a6d553d44ab1b8299b71777d9750b77ba466363e" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="translated">Строка в этом модуле представлена &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; , то есть списком кодовых точек, двоичных файлов с кодовыми точками в&lt;strong&gt; кодировке UTF-8 (двоичные файлы UTF-8&lt;/strong&gt; ) или их сочетанием.</target>
        </trans-unit>
        <trans-unit id="d11f0427336c725f5ed476d29c20afbd08fe897b" translate="yes" xml:space="preserve">
          <source>A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned.</source>
          <target state="translated">Читается строка не белых пробельных символов.Если задана ширина поля,то считывается это количество символов,а все последующие пробельные символы удаляются.Возвращается Erlang-строка (список символов).</target>
        </trans-unit>
        <trans-unit id="64783b9aab5a7910a29cafe20f9a64dc124f28e3" translate="yes" xml:space="preserve">
          <source>A string representing atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Строка, представляющая атом &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d7e23be6d1d7577f504730a2152e66a4301352e" translate="yes" xml:space="preserve">
          <source>A string that describes the error is obtained with the following call:</source>
          <target state="translated">Строка,описывающая ошибку,получается при следующем вызове:</target>
        </trans-unit>
        <trans-unit id="6b058a7796b9b771b09e5ec69321b91ea4d6b069" translate="yes" xml:space="preserve">
          <source>A string version of &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt;. When the query handle is evaluated, the fun created by the parse transform is interpreted by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. The query string is to be one single QLC terminated by a period.</source>
          <target state="translated">Строковая версия &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; . Когда &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; запроса оценивается, удовольствие, созданное преобразованием синтаксического анализа, интерпретируется erl_eval (3) . Строка запроса должна быть одним QLC, оканчивающимся точкой.</target>
        </trans-unit>
        <trans-unit id="e691523a7275fa4ec7b2002f9ce045f810aebbb7" translate="yes" xml:space="preserve">
          <source>A string with no adjacent dots.</source>
          <target state="translated">Строка без соседних точек.</target>
        </trans-unit>
        <trans-unit id="7b45ae634d5f2aacf52f18c9890284a21d2682fc" translate="yes" xml:space="preserve">
          <source>A stub module descriptor contains the module name, a list of exported functions, and a list of module attributes. Each function is described by its name (which includes its arity), and the corresponding module and function that it calls. (The arities should always match.) The attributes are simply described by key-value pairs.</source>
          <target state="translated">Дескриптор модуля заглушки содержит имя модуля,список экспортируемых функций и список атрибутов модуля.Каждая функция описывается ее именем (которое включает в себя ее атрибуты),а также соответствующим модулем и функцией,которую она вызывает.(Атрибуты должны всегда совпадать.)Атрибуты просто описываются парами ключ-значение.</target>
        </trans-unit>
        <trans-unit id="8dff76e790c867438fab881dad7f0b72bb5ec367" translate="yes" xml:space="preserve">
          <source>A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level:</source>
          <target state="translated">Подмаска,не содержащая символа |,является лишь частью вложенной альтернативы;это не вложенная альтернатива с одной альтернативой.Эффект (*THEN)распространяется за пределы такой подмаски на вложенную альтернативу.Рассмотрим следующий шаблон,где A,B и т.д.являются сложными фрагментами шаблона,не содержащими на этом уровне символов |:</target>
        </trans-unit>
        <trans-unit id="359594612c2eb9a5932465070d74beae6a372eb0" translate="yes" xml:space="preserve">
          <source>A subpattern that is referenced by name can appear in the pattern before or after the reference.</source>
          <target state="translated">Подмаска,на которую делается ссылка по имени,может появиться на детали до или после ссылки.</target>
        </trans-unit>
        <trans-unit id="d8554111ace0a51aa20ae047b50f0d90058ec0d6" translate="yes" xml:space="preserve">
          <source>A subroutine call to a subpattern (recursive or otherwise)</source>
          <target state="translated">Вызов подпрограммы к подмаскировке (рекурсивной или иной).</target>
        </trans-unit>
        <trans-unit id="1e9e2570d27c2595d94b29222dcc52f4683b8c79" translate="yes" xml:space="preserve">
          <source>A subset of all semantic checks on types are implemented. For example, strictly the &lt;code&gt;TimeTicks&lt;/code&gt; may not be sub-classed but the compiler allows this (standard MIBs must pass through the compiler) (deviates from SMIv2 only).</source>
          <target state="translated">Реализовано подмножество всех семантических проверок типов. Например, строго &lt;code&gt;TimeTicks&lt;/code&gt; не может быть подклассом, но компилятор позволяет это (стандартные MIB должны проходить через компилятор) (отклоняется только от SMIv2).</target>
        </trans-unit>
        <trans-unit id="29bc759fe88a2b272d7f7e146c9840a7ce6ba6f5" translate="yes" xml:space="preserve">
          <source>A successful match of a segment of a &lt;code&gt;utf&lt;/code&gt; type, results in an integer in the range 0..16#D7FF or 16#E000..16#10FFFF. The match fails if the returned value falls outside those ranges.</source>
          <target state="translated">Успешное совпадение сегмента типа &lt;code&gt;utf&lt;/code&gt; приводит к целому числу в диапазоне 0..16 # D7FF или 16 # E000..16 # 10FFFF. Сопоставление не удается, если возвращаемое значение выходит за пределы этих диапазонов.</target>
        </trans-unit>
        <trans-unit id="0dd5399d68fd62c8aa61dea1b9cd129c66c4e135" translate="yes" xml:space="preserve">
          <source>A suggestion, in kilowords, on how large a stack to use. A value &amp;lt; 0 means default size.</source>
          <target state="translated">Предложение в киловордах о том, какой размер стека использовать. Значение &amp;lt;0 означает размер по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d2bcf77bf32e3c737f6132f4ba89272aa61deb33" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be constructed from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by the following example code:</source>
          <target state="translated">Подходящий &lt;code&gt;erlang_pid&lt;/code&gt; может быть построен из структуры &lt;code&gt;ei_cnode&lt;/code&gt; с помощью следующего примера кода:</target>
        </trans-unit>
        <trans-unit id="e635ab7a6524cfed54f5074b2c5f201fa29a542e" translate="yes" xml:space="preserve">
          <source>A summary of all the run test cases.</source>
          <target state="translated">Краткий обзор всех тестовых заданий.</target>
        </trans-unit>
        <trans-unit id="490b87fb70901b3cf146b436d3ad3d6969ae85d3" translate="yes" xml:space="preserve">
          <source>A summary of allocated block sizes (including their headers) grouped by their &lt;code&gt;Origin&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">Сводка размеров выделенных блоков (включая их заголовки), сгруппированных по их &lt;code&gt;Origin&lt;/code&gt; и &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42e4170b78b8fb9e3847e667242b4de5cec174c5" translate="yes" xml:space="preserve">
          <source>A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions.</source>
          <target state="translated">Мост супервизора принимает на себя функции запуска и остановки подсистемы,расположенной в модуле обратного вызова,экспортируя предопределенный набор функций.</target>
        </trans-unit>
        <trans-unit id="f8e585f469018050c24b2320c6df8c355fe43361" translate="yes" xml:space="preserve">
          <source>A supervisor can have one of the following &lt;strong&gt;restart strategies&lt;/strong&gt; specified with the &lt;code&gt;strategy&lt;/code&gt; key in the above map:</source>
          <target state="translated">Супервизор может иметь одну из следующих &lt;strong&gt;стратегий перезапуска,&lt;/strong&gt; указанных с помощью ключа &lt;code&gt;strategy&lt;/code&gt; на приведенной выше карте:</target>
        </trans-unit>
        <trans-unit id="2b7d18f5eb25e50d03987db777d14f147e150acb" translate="yes" xml:space="preserve">
          <source>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions.</source>
          <target state="translated">Супервизор ожидает,что в модуле обратного вызова,экспортирующем предопределенный набор функций,будет указано,какие дочерние процессы должны контролироваться.</target>
        </trans-unit>
        <trans-unit id="f82d3f2d9f94a9fc80489eaf4729fa8c31535cf1" translate="yes" xml:space="preserve">
          <source>A supervisor for the SNMP agent Processes</source>
          <target state="translated">Руководитель процессов агента SNMP.</target>
        </trans-unit>
        <trans-unit id="07d7e065bf97522ff7b29841ee97a5f3abaaa707" translate="yes" xml:space="preserve">
          <source>A supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it is to keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">Супервайзер отвечает за запуск,остановку и мониторинг процессов,происходящих с детьми.Основная идея супервайзера заключается в том,что он должен поддерживать свои дочерние процессы,перезапуская их,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="8efae13f8c7942b2ac38b9a2a73eb196c3d0a6ff" translate="yes" xml:space="preserve">
          <source>A supervisor report is issued when a supervised child terminates unexpectedly. A supervisor report contains the following items:</source>
          <target state="translated">При неожиданной гибели ребенка,находящегося под наблюдением,выдается заключение руководителя.Отчет супервайзера содержит следующие пункты:</target>
        </trans-unit>
        <trans-unit id="2d5726e30c2bfdd999c9a419984c8b7f106bff81" translate="yes" xml:space="preserve">
          <source>A supervisor with restart strategy &lt;code&gt;simple_one_for_one&lt;/code&gt; is a simplified &lt;code&gt;one_for_one&lt;/code&gt; supervisor, where all child processes are dynamically added instances of the same process.</source>
          <target state="translated">Супервизор со стратегией перезапуска &lt;code&gt;simple_one_for_one&lt;/code&gt; - это упрощенный супервизор &lt;code&gt;one_for_one&lt;/code&gt; , в котором все дочерние процессы являются динамически добавляемыми экземплярами одного и того же процесса.</target>
        </trans-unit>
        <trans-unit id="4a17c6d57373e353ac6abb1cd3af415a947ff039" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. &lt;code&gt;Suspendee&lt;/code&gt; eventually suspends unless it is resumed before it could suspend. The caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; returns immediately, regardless of whether &lt;code&gt;Suspendee&lt;/code&gt; has suspended yet or not. The point in time when &lt;code&gt;Suspendee&lt;/code&gt; suspends cannot be deduced from other events in the system. It is only guaranteed that &lt;code&gt;Suspendee&lt;/code&gt;&lt;strong&gt;eventually&lt;/strong&gt; suspends (unless it is resumed). If no &lt;code&gt;asynchronous&lt;/code&gt; options has been passed, the caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; is blocked until &lt;code&gt;Suspendee&lt;/code&gt; has suspended.</source>
          <target state="translated">Запрос на приостановку отправляется процессу, указанному &lt;code&gt;Suspendee&lt;/code&gt; . &lt;code&gt;Suspendee&lt;/code&gt; конечном итоге приостанавливается, если она не будет возобновлена ​​до того, как она сможет приостановить. Вызывающий &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; немедленно возвращается, вне зависимости от того, &lt;code&gt;Suspendee&lt;/code&gt; ли Suspende еще или нет. Момент времени, когда &lt;code&gt;Suspendee&lt;/code&gt; приостановка, нельзя вывести из других событий в системе. Гарантируется только то, что &lt;code&gt;Suspendee&lt;/code&gt; приостановки в &lt;strong&gt;конечном итоге будет&lt;/strong&gt; приостановлена ​​(если только она не будет возобновлена). Если не было передано никаких &lt;code&gt;asynchronous&lt;/code&gt; параметров, вызывающий &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; блокируется до тех пор, пока &lt;code&gt;Suspendee&lt;/code&gt; не будет приостановлена.</target>
        </trans-unit>
        <trans-unit id="25b4e7d3e689427411ff502e735d917aa357caf7" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. When the suspend request has been processed, a reply message is sent to the caller of this function. The reply is on the form &lt;code&gt;{ReplyTag, State}&lt;/code&gt; where &lt;code&gt;State&lt;/code&gt; is either:</source>
          <target state="translated">Запрос на приостановку отправляется процессу, указанному &lt;code&gt;Suspendee&lt;/code&gt; . Когда запрос приостановки обработан, вызывающей стороне этой функции отправляется ответное сообщение. Ответ находится в форме &lt;code&gt;{ReplyTag, State}&lt;/code&gt; где &lt;code&gt;State&lt;/code&gt; либо:</target>
        </trans-unit>
        <trans-unit id="dab5b92521d5334adcd3b34a7cd584da12e53036" translate="yes" xml:space="preserve">
          <source>A syntax tree can be transformed to the &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; representation with the &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Синтаксическое дерево может быть преобразовано в представление &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; с помощью функции &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe7a01f61caca49ad408b9e314c2eab8ae04b7a" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">Системный вектор ввода-вывода, используемый &lt;code&gt;writev&lt;/code&gt; в Unix и &lt;code&gt;WSASend&lt;/code&gt; в Win32. Он используется в &lt;code&gt;ErlIOVec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0af2eabcce5a60d4fed7164c28fadc9a20e4493d" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlNifIOVec&lt;/code&gt; and by &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Системный вектор ввода-вывода, используемый &lt;code&gt;writev&lt;/code&gt; в Unix и &lt;code&gt;WSASend&lt;/code&gt; в Win32. Он используется в &lt;code&gt;ErlNifIOVec&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616d063d630bdaee784166c5d2aa3d7079333cc2" translate="yes" xml:space="preserve">
          <source>A system configuration file, &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">Файл конфигурации системы, &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a27085bf58c10c3bac131eedf2381b0839b7998" translate="yes" xml:space="preserve">
          <source>A system configuration source file, &lt;code&gt;sys.config.src&lt;/code&gt;</source>
          <target state="translated">Исходный файл конфигурации системы, &lt;code&gt;sys.config.src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c879d34c3ec9d9665df9efe9db8cf8d5df6abde2" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt;Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="translated">Достигнут системный предел. См. &lt;code&gt;Efficiency Guide&lt;/code&gt; по эффективности для получения информации о системных ограничениях.</target>
        </trans-unit>
        <trans-unit id="8b8fdecfc617b9fa3706b79edfcf234ce5f241ff" translate="yes" xml:space="preserve">
          <source>A tab followed by character &quot;3&quot;</source>
          <target state="translated">Вкладка,за которой следует символ &quot;3&quot;.</target>
        </trans-unit>
        <trans-unit id="7d11781c842639135820e9eada3b27c9a8d0d9ad" translate="yes" xml:space="preserve">
          <source>A table called &lt;code&gt;myTable&lt;/code&gt; has five columns. The first two are keys (not accessible), and the table has three rows. The instrumentation function for this table is called &lt;code&gt;my_table&lt;/code&gt;.</source>
          <target state="translated">Таблица &lt;code&gt;myTable&lt;/code&gt; состоит из пяти столбцов. Первые два являются ключами (недоступны), а таблица состоит из трех строк. Инструментальная функция для этой таблицы называется &lt;code&gt;my_table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75534734c58db0aa05f9239f37f6428de398c20c" translate="yes" xml:space="preserve">
          <source>A table identifier, as returned by &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Идентификатор таблицы, возвращаемый функцией &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f0fe364ceb37c8d8dc5f9217f78c519dc139c59" translate="yes" xml:space="preserve">
          <source>A table may contain columns that are used internally, but should not be visible to a manager. These internal columns must be the last columns in the table. The &lt;code&gt;set&lt;/code&gt; operation will not work with this arrangement, because there are columns that the agent does not know about. This situation is handled by adding values for the internal columns in the &lt;code&gt;set&lt;/code&gt; function.</source>
          <target state="translated">Таблица может содержать столбцы, которые используются внутри компании, но не должны быть видны руководителю. Эти внутренние столбцы должны быть последними столбцами в таблице. Операция &lt;code&gt;set&lt;/code&gt; не будет работать с таким расположением, потому что есть столбцы, о которых агент не знает. Эта ситуация обрабатывается путем добавления значений для внутренних столбцов в функцию &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ccf87ca282ead9bb584834a165823229be63f73" translate="yes" xml:space="preserve">
          <source>A table object</source>
          <target state="translated">Объект таблицы</target>
        </trans-unit>
        <trans-unit id="57b2065e432402661ed8ccb643e2901e6965c10a" translate="yes" xml:space="preserve">
          <source>A table of type &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; has either zero or one record per key, whereas a table of type &lt;code&gt;bag&lt;/code&gt; can have an arbitrary number of records per key. The key for each record is always the first attribute of the record.</source>
          <target state="translated">Таблица типа &lt;code&gt;set&lt;/code&gt; или &lt;code&gt;ordered_set&lt;/code&gt; имеет либо ноль, либо одну запись на ключ, тогда как таблица типа &lt;code&gt;bag&lt;/code&gt; может иметь произвольное количество записей на ключ. Ключ для каждой записи всегда является первым атрибутом записи.</target>
        </trans-unit>
        <trans-unit id="338d3dd5c9171dcfa74ab3490bd081525d78c330" translate="yes" xml:space="preserve">
          <source>A tail-recursive function that does not need to reverse the list at the end is faster than a body-recursive function, as are tail-recursive functions that do not construct any terms at all (for example, a function that sums all integers in a list).</source>
          <target state="translated">Хвостовая рекурсивная функция,которой не нужно перевернуть список в конце,быстрее,чем телесная рекурсивная функция,так же как и хвостовая рекурсивная функция,которая вообще не строит никаких членов (например,функция,которая суммирует все целые числа в списке).</target>
        </trans-unit>
        <trans-unit id="6ed306bfabb588bedad1a38ebc28c88dc1ee79a9" translate="yes" xml:space="preserve">
          <source>A target system may have several releases but the one given as &lt;code&gt;boot_rel&lt;/code&gt; will be used as default when the system is booting up.</source>
          <target state="translated">Целевая система может иметь несколько выпусков, но тот, который указан как &lt;code&gt;boot_rel&lt;/code&gt; , будет использоваться по умолчанию при загрузке системы.</target>
        </trans-unit>
        <trans-unit id="92a162c972e0a2da1ef36842b8e1183dc63976d3" translate="yes" xml:space="preserve">
          <source>A term in which the state machine implementation is to store any server data it needs. The difference between this and the &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state.</source>
          <target state="translated">Термин, в котором реализация конечного автомата заключается в хранении любых необходимых ему данных сервера. Разница между этим и самим &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; заключается в том, что изменение этих данных не вызывает повторной попытки отложенных событий. Следовательно, если изменение этих данных приведет к изменению набора обрабатываемых событий, то этот элемент данных должен стать частью состояния.</target>
        </trans-unit>
        <trans-unit id="f59430379cf9648470c25a50d2a2c81bb2b89218" translate="yes" xml:space="preserve">
          <source>A term, if the event handler is removed because of an error. Which term depends on the error.</source>
          <target state="translated">Термин,если обработчик события удален из-за ошибки.Какой срок зависит от ошибки.</target>
        </trans-unit>
        <trans-unit id="9594dc172a1a303c23e2c7f885380aa1c05fad93" translate="yes" xml:space="preserve">
          <source>A test case can handle several connections to one or more target systems, instruments, and traffic generators in parallel to perform the necessary actions for a test. The handling of many connections in parallel is one of the major strengths of &lt;code&gt;Common Test&lt;/code&gt;, thanks to the efficient support for concurrency in the Erlang runtime system, which &lt;code&gt;Common Test&lt;/code&gt; users can take great advantage of.</source>
          <target state="translated">Тестовый пример может обрабатывать несколько подключений к одной или нескольким целевым системам, инструментам и генераторам трафика параллельно для выполнения необходимых действий для теста. Параллельная обработка множества соединений является одной из основных сильных сторон &lt;code&gt;Common Test&lt;/code&gt; благодаря эффективной поддержке параллелизма в системе времени выполнения Erlang, которой пользователи &lt;code&gt;Common Test&lt;/code&gt; могут воспользоваться большим преимуществом.</target>
        </trans-unit>
        <trans-unit id="3f0276c5d34cae70dd7c0725d3127cfdb7e17a06" translate="yes" xml:space="preserve">
          <source>A test case failure is specified as a runtime error (a crash), no matter what the reason for termination is. If you use Erlang pattern matching effectively, you can take advantage of this property. The result is concise and readable test case functions that look much more like scripts than actual programs. A simple example:</source>
          <target state="translated">Сбой в тестовом случае указывается как ошибка во время выполнения (сбой),независимо от причины его завершения.Если вы эффективно используете совпадение по шаблону Erlang,вы можете воспользоваться этим свойством.В результате получаются лаконичные и читаемые функции тестового случая,которые гораздо больше похожи на скрипты,чем на реальные программы.Простой пример:</target>
        </trans-unit>
        <trans-unit id="57803d84844b81148f638909cfbdf834fb63a201" translate="yes" xml:space="preserve">
          <source>A test case group can be repeated a certain number of times (specified by an integer) or indefinitely (specified by &lt;code&gt;forever&lt;/code&gt;). The repetition can also be stopped too early if any or all cases fail or succeed, that is, if any of the properties &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, &lt;code&gt;repeat_until_any_ok&lt;/code&gt;, &lt;code&gt;repeat_until_all_fail&lt;/code&gt;, or &lt;code&gt;repeat_until_all_ok&lt;/code&gt; is used. If the basic &lt;code&gt;repeat&lt;/code&gt; property is used, status of test cases is irrelevant for the repeat operation.</source>
          <target state="translated">Группа тестовых примеров может повторяться определенное количество раз (задано целым числом) или бесконечно (задано &lt;code&gt;forever&lt;/code&gt; ). Повторение также может быть остановлено слишком рано, если один или все случаи &lt;code&gt;repeat_until_any_ok&lt;/code&gt; &lt;code&gt;repeat_until_all_fail&lt;/code&gt; или &lt;code&gt;repeat_until_all_ok&lt;/code&gt; успешно, то есть, если используется какое-либо из свойств &lt;code&gt;repeat_until_any_fail&lt;/code&gt; , repeat_until_any_ok , repeat_until_all_fail или repeat_until_all_ok . Если используется базовое свойство &lt;code&gt;repeat&lt;/code&gt; , статус тестовых примеров не имеет значения для операции повтора.</target>
        </trans-unit>
        <trans-unit id="70f3b406878b1ad27d06f47209f488fb0090bedb" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="translated">Группа тестовых примеров - это набор тестовых примеров, совместно использующих функции конфигурации и свойства выполнения. Группы тестовых примеров определяются функциональными &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; соответствии со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="e797bd2be17f58c7efe8dfeff204b02c5adaa5d5" translate="yes" xml:space="preserve">
          <source>A test case is considered successful if it returns to the caller, no matter what the returned value is. However, a few return values have special meaning as follows:</source>
          <target state="translated">Тестовый случай считается успешным,если он возвращается вызывающему абоненту,независимо от того,какое возвращаемое значение.Однако несколько возвращаемых значений имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="dcc50de966066784aa8d897c8ffe49a70bbe3620" translate="yes" xml:space="preserve">
          <source>A test is performed by running one or more test suites. A test suite consists of test cases, configuration functions, and information functions. Test cases can be grouped in so called test case groups. A test suite is an Erlang module and test cases are implemented as Erlang functions. Test suites are stored in test directories.</source>
          <target state="translated">Тест выполняется путем запуска одного или нескольких наборов тестов.Набор тестов состоит из тестовых примеров,функций конфигурации и информационных функций.Тестовые случаи можно сгруппировать в так называемые группы тестовых случаев.Набор тестов представляет собой модуль Erlang,а тестовые примеры реализуются в виде функций Erlang.Наборы тестов хранятся в тестовых каталогах.</target>
        </trans-unit>
        <trans-unit id="82b0d4348a040296baa971a336f70137d0143756" translate="yes" xml:space="preserve">
          <source>A test set can be easily created by placing a sequence of test objects in a list. If &lt;code&gt;T_1&lt;/code&gt;, ..., &lt;code&gt;T_N&lt;/code&gt; are individual test objects, then &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; is a test set consisting of those objects (in that order).</source>
          <target state="translated">Набор тестов можно легко создать, поместив последовательность тестовых объектов в список. Если &lt;code&gt;T_1&lt;/code&gt; , ..., &lt;code&gt;T_N&lt;/code&gt; - отдельные тестовые объекты, то &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; - это тестовый набор, состоящий из этих объектов (в указанном порядке).</target>
        </trans-unit>
        <trans-unit id="850a2b153e54fe3302effc5897fd48daf6d71d85" translate="yes" xml:space="preserve">
          <source>A test suite is an ordinary Erlang module that contains test cases. It is recommended that the module has a name on the form &lt;code&gt;*_SUITE.erl&lt;/code&gt;. Otherwise, the directory and auto compilation function in &lt;code&gt;Common Test&lt;/code&gt; cannot locate it (at least not by default).</source>
          <target state="translated">Набор тестов - это обычный модуль Erlang, содержащий тестовые примеры. Рекомендуется, чтобы у модуля было имя в форме &lt;code&gt;*_SUITE.erl&lt;/code&gt; . В противном случае каталог и функция автоматической компиляции в &lt;code&gt;Common Test&lt;/code&gt; не смогут его найти (по крайней мере, по умолчанию).</target>
        </trans-unit>
        <trans-unit id="c6a46a09bfa35f6d6a3e0deef8196b3ea6cd2281" translate="yes" xml:space="preserve">
          <source>A test term can also specify one or more test suites, groups, or test cases to be skipped. Skipped suites, groups, and cases are not executed and show up in the HTML log files as &lt;code&gt;SKIPPED&lt;/code&gt;.</source>
          <target state="translated">Термин теста также может указывать один или несколько наборов тестов, групп или тестовых примеров, которые следует пропустить. Пропущенные наборы, группы и дела не выполняются и отображаются в файлах журнала HTML как &lt;code&gt;SKIPPED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc9a7da069ee22047038749756cf97523761175f" translate="yes" xml:space="preserve">
          <source>A textual comment describing the service. Not mandatory, but shows up as the service description in the Windows service manager.</source>
          <target state="translated">Текстовый комментарий с описанием услуги.Не является обязательным,но отображается как описание службы в менеджере служб Windows.</target>
        </trans-unit>
        <trans-unit id="1b69647db9e6ba8a0e002c236579c1374755b41d" translate="yes" xml:space="preserve">
          <source>A the time of writing this, the latest released version of SystemTap is version 1.6. Erlang's DTrace support requires a MACRO that was introduced after that release. So either get a newer release or build SystemTap from git yourself (see: http://sourceware.org/systemtap/getinvolved.html)</source>
          <target state="translated">На момент написания этой статьи последней выпущенной версией SystemTap является версия 1.6.Для поддержки DTrace Эрланга требуется MACRO,который был введен после этого выпуска.Так что либо получите новый релиз,либо соберите SystemTap самостоятельно из git'а (см.:http://sourceware.org/systemtap/getinvolved.html).</target>
        </trans-unit>
        <trans-unit id="9b18f6bb3b01d76a4dfa566d98c87a28d7f6b44e" translate="yes" xml:space="preserve">
          <source>A third alternative is to download and install MSYS2 from:</source>
          <target state="translated">Третья альтернатива-скачать и установить MSYS2:</target>
        </trans-unit>
        <trans-unit id="f9c4754ee9c691b3be255533c56967a9f65767a3" translate="yes" xml:space="preserve">
          <source>A third usage is to block login attempts from a missbehaving peer. The &lt;code&gt;State&lt;/code&gt; described above can be used for this. The return value &lt;code&gt;disconnect&lt;/code&gt; is useful for this.</source>
          <target state="translated">Третий вариант использования - блокирование попыток входа в систему со стороны некорректного партнера. &lt;code&gt;State&lt;/code&gt; описано выше , можно использовать для этого. Для этого полезно возвращаемое значение &lt;code&gt;disconnect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9a2152eb9572e05f0a61d8511698051e7c78f8" translate="yes" xml:space="preserve">
          <source>A thread can only be joined once. The behavior of joining more than once is undefined, an emulator crash is likely. If &lt;code&gt;exit_value == NULL&lt;/code&gt;, the exit value of the terminated thread is ignored, otherwise the exit value of the terminated thread is stored at &lt;code&gt;*exit_value&lt;/code&gt;.</source>
          <target state="translated">К цепочке можно присоединиться только один раз. Поведение многократного присоединения не определено, возможен сбой эмулятора. Если &lt;code&gt;exit_value == NULL&lt;/code&gt; , значение выхода завершенного потока игнорируется, в противном случае значение выхода завершенного потока сохраняется в &lt;code&gt;*exit_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="713f4e1d5b50f7df039ee9fe6e1996e2572d7a3a" translate="yes" xml:space="preserve">
          <source>A thread identifier can be reused very quickly after a thread has terminated. Therefore, if a thread corresponding to one of the involved thread identifiers has terminated since the thread identifier was saved, the result of &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; does possibly not give the expected result.</source>
          <target state="translated">Идентификатор потока может быть повторно использован очень быстро после завершения потока. Следовательно, если поток, соответствующий одному из задействованных идентификаторов потока, завершился после сохранения идентификатора потока, результат &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; , возможно, не даст ожидаемого результата.</target>
        </trans-unit>
        <trans-unit id="cad763d5e07983c99c13f14998b109764ecd9488" translate="yes" xml:space="preserve">
          <source>A time stamp as returned by the BIF &lt;code&gt;now()&lt;/code&gt;.</source>
          <target state="translated">Отметка времени, возвращенная BIF &lt;code&gt;now()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09f8c7e2d1b4631a8a0fd8e3a936590e5cfc3d7c" translate="yes" xml:space="preserve">
          <source>A time warp is a leap forwards or backwards in time. That is, the difference of time values taken before and after the time warp does not correspond to the actual elapsed time.</source>
          <target state="translated">Искривление времени-это скачок вперед или назад во времени.То есть разница значений времени,взятых до и после искривления времени,не соответствует фактическому истекшему времени.</target>
        </trans-unit>
        <trans-unit id="cd86c3e0b5292795cee07d9ad33f244af7a25314" translate="yes" xml:space="preserve">
          <source>A time-out feature inherited from &lt;code&gt;gen_statem&lt;/code&gt;'s predecessor &lt;code&gt;gen_fsm&lt;/code&gt;, is an event time-out, that is, if an event arrives the timer is cancelled. You get either an event or a time-out, but not both.</source>
          <target state="translated">Тайм-аут особенность , унаследованная от &lt;code&gt;gen_statem&lt;/code&gt; &amp;laquo;s предшественника &lt;code&gt;gen_fsm&lt;/code&gt; , является тайм-аут события, то есть, если событие прибывает таймер будет отменен. Вы получаете либо событие, либо тайм-аут, но не то и другое одновременно.</target>
        </trans-unit>
        <trans-unit id="e4e7c858b3f4a06a0ae20e24345812eb57867da0" translate="yes" xml:space="preserve">
          <source>A time-out value of &lt;code&gt;0&lt;/code&gt; (zero) means that time-outs are disabled. Calling a &lt;code&gt;_tmo&lt;/code&gt; function with the last argument as &lt;code&gt;0&lt;/code&gt; is therefore the same thing as calling the function without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">Значение тайм-аута &lt;code&gt;0&lt;/code&gt; (ноль) означает, что тайм-ауты отключены. Вызов &lt;code&gt;_tmo&lt;/code&gt; функции с последним аргументом , как &lt;code&gt;0&lt;/code&gt; , поэтому то же самое , как вызов функции без &lt;code&gt;_tmo&lt;/code&gt; суффикса.</target>
        </trans-unit>
        <trans-unit id="e51396500c23760a237e8c8ce1759124abbdb2b6" translate="yes" xml:space="preserve">
          <source>A timeout, in seconds, for how long the &lt;code&gt;memsup&lt;/code&gt; process should wait for a result from a memory check. If the timeout expires, a warning message &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; is issued via &lt;code&gt;error_logger&lt;/code&gt; and any pending, synchronous client calls will return a dummy value. Normally, this situation should not occur. There have been cases on Linux, however, where the pseudo file from which system data is read is temporarily unavailable when the system is heavily loaded.</source>
          <target state="translated">&lt;code&gt;memsup&lt;/code&gt; аут в секундах, в течение которого процесс memsup должен ждать результата проверки памяти. Если время ожидания истекает, через &lt;code&gt;error_logger&lt;/code&gt; выдается предупреждающее сообщение &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; и любые ожидающие синхронные вызовы клиента возвращают фиктивное значение. Обычно такой ситуации не должно быть. Однако в Linux были случаи, когда псевдофайл, из которого считывались системные данные, был временно недоступен, когда система сильно загружена.</target>
        </trans-unit>
        <trans-unit id="68ff3c996ac6d98f27aaaac3ca2c11d67e8039ea" translate="yes" xml:space="preserve">
          <source>A timer can always be removed by calling &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Таймер всегда можно удалить, вызвав &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="726a053f638d7072079d375380c92439b2bbdb5e" translate="yes" xml:space="preserve">
          <source>A timer reference.</source>
          <target state="translated">Ссылка на таймер.</target>
        </trans-unit>
        <trans-unit id="94ea6da4ccb85a54c3d9ad09e70c59b90ddafcec" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt;.</source>
          <target state="translated">Метка времени, созданная с помощью &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="224b47a99ccb8f9ad2636eb28064f8326a8f1842" translate="yes" xml:space="preserve">
          <source>A timetrap can also be set or reset dynamically during the execution of a test case, or configuration function. This is done by calling &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;. This function cancels the current timetrap and starts a new one (that stays active until time-out, or end of the current function).</source>
          <target state="translated">Временную ловушку также можно устанавливать или сбрасывать динамически во время выполнения тестового примера или функции конфигурации. Это делается вызовом &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; . Эта функция отменяет текущую временную ловушку и запускает новую (которая остается активной до истечения времени ожидания или до конца текущей функции).</target>
        </trans-unit>
        <trans-unit id="8f213ae236a5f4c3df724a5656b6f24789d1f1a8" translate="yes" xml:space="preserve">
          <source>A tool for applying XSLT stylesheets to XML documents. Download xsltproc from &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Инструмент для применения таблиц стилей XSLT к XML-документам. Загрузите xsltproc с &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08f1e7c2bddf5c69b2f61fa1070545348579586c" translate="yes" xml:space="preserve">
          <source>A trace port is an Erlang port to a dynamically linked in driver that handles trace messages directly, without the overhead of sending them as messages in the Erlang virtual machine.</source>
          <target state="translated">Порт трассировки-это порт Erlang на динамически связанный в драйвере,который обрабатывает сообщения трассировки напрямую,без накладных расходов на их отправку в качестве сообщений на виртуальной машине Erlang.</target>
        </trans-unit>
        <trans-unit id="12ee06a6ceec6852b8fcedb1fbb55e6e9c5f6756" translate="yes" xml:space="preserve">
          <source>A trace server started in this way will simply display the trace messages in a formatted way in the Erlang shell (i. e. use io:format). See &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; for a description of how the trace message handler can be customized.</source>
          <target state="translated">Сервер трассировки, запущенный таким образом, будет просто отображать сообщения трассировки в отформатированном виде в оболочке Erlang (то есть использовать io: format). См. &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; для описания того, как можно настроить обработчик сообщений трассировки.</target>
        </trans-unit>
        <trans-unit id="c312d23149bf55415c7facde91760776534bda23" translate="yes" xml:space="preserve">
          <source>A trace token contains a label and a set of flags. Both the label and the flags are set in both alternatives above.</source>
          <target state="translated">Токен трассировки содержит метку и набор флагов.И метка,и флаги установлены в обоих вариантах выше.</target>
        </trans-unit>
        <trans-unit id="a0a3ada2bd3e540543826094f00fde5f11b86200" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will consist of &lt;code&gt;Erlang monotonic time&lt;/code&gt; and a monotonically increasing integer. The time-stamp has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает создание строгой монотонной временной метки для каждого отслеживаемого события. По умолчанию - &lt;code&gt;false&lt;/code&gt; . Отметки времени будут состоять из &lt;code&gt;Erlang monotonic time&lt;/code&gt; и монотонно увеличивающегося целого числа. &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; времени имеет тот же формат и значение, что и {erlang: monotonic_time (наносекунда), erlang: unique_integer ([monotonic])} .</target>
        </trans-unit>
        <trans-unit id="60097663814cb4e095c2a6a722349f6b5a5bf437" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will use &lt;code&gt;Erlang monotonic time&lt;/code&gt;. The time-stamp has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает создание строгой монотонной временной метки для каждого отслеживаемого события. По умолчанию - &lt;code&gt;false&lt;/code&gt; . Метки времени будут использовать &lt;code&gt;Erlang monotonic time&lt;/code&gt; . Метка времени имеет тот же формат и значение, что и &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82d8ecb25fb90aa7ddd424dd220b83a7b34ebd81" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает создание отметки времени для каждого отслеживаемого события. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3e634022f908badf152e1987898bd0b2c230015" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on explicit calls to &lt;code&gt;seq_trace:print/1&lt;/code&gt;. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает трассировку явных вызовов &lt;code&gt;seq_trace:print/1&lt;/code&gt; . По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde9aedc5e9c949b0aa2b17f37ee8c40d03b21b6" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг маркера трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает трассировку при получении сообщения. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c367670f41b59db0e6ecd2630bb172d3da0c69" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Флаг токена трассировки ( &lt;code&gt;true | false&lt;/code&gt; ), который включает / отключает трассировку при отправке сообщения. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fef110e2f0ab9e0376d172bcb7bfe8b65a404cd6" translate="yes" xml:space="preserve">
          <source>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</source>
          <target state="translated">Транзакционная система позволяет одновременно выполнять два или более процесса,которые манипулируют одной и той же записью.Программисту нет необходимости проверять синхронизацию обновлений,это контролируется обработчиком транзакции.Все программы,обращающиеся к БД через транзакционную систему,могут быть записаны так,как если бы у них был единоличный доступ к данным.</target>
        </trans-unit>
        <trans-unit id="040494e8706d570977340364653c32d0f74758d8" translate="yes" xml:space="preserve">
          <source>A transport can both override its service's capabilities and restrict its supported Diameter applications so &quot;service = Diameter node as identified by Origin-Host&quot; is not necessarily the case.</source>
          <target state="translated">Транспорт может как переопределить возможности своей службы,так и ограничить поддерживаемые приложения Diameter,поэтому &quot;service=Diameter node as identified by Origin-Host&quot; (служба=узел Diameter)не обязательно является таковым.</target>
        </trans-unit>
        <trans-unit id="023338b0c93aa9ea43a308354e8c6cb312d2e262" translate="yes" xml:space="preserve">
          <source>A transport process can expect messages of the following types from its parent.</source>
          <target state="translated">Транспортный процесс может ожидать от своих родителей сообщений следующих типов.</target>
        </trans-unit>
        <trans-unit id="c02ea719b68545a61ef8005dfcb9fa67f5f85090" translate="yes" xml:space="preserve">
          <source>A transport process must implement the message interface documented below. It should retain the pid of its parent, monitor the parent and terminate if it dies. It should not link to the parent. It should exit if its transport connection with its peer is lost.</source>
          <target state="translated">Транспортный процесс должен реализовывать интерфейс сообщения,описанный ниже.Он должен сохранить pid своего родителя,контролировать родителя и прекращать работу в случае его смерти.Он не должен связываться с родителем.Он должен завершить работу,если транспортное соединение с родителем потеряно.</target>
        </trans-unit>
        <trans-unit id="22cab074839dd6633c044492cf9e00d79ad7b9b9" translate="yes" xml:space="preserve">
          <source>A transport process should send messages of the following types to its parent.</source>
          <target state="translated">Транспортный процесс должен отправлять родителю сообщения следующих типов.</target>
        </trans-unit>
        <trans-unit id="90161712010dfd82bbaf6035b7ca236a047b2d07" translate="yes" xml:space="preserve">
          <source>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (&lt;strong&gt;enable&lt;/strong&gt;), or to become inactive (&lt;strong&gt;disable&lt;/strong&gt;), or to be removed (&lt;strong&gt;delete&lt;/strong&gt;).</source>
          <target state="translated">Действие триггера. При достижении точки останова действие триггера указывает, должна ли точка останова оставаться активной ( &lt;strong&gt;включить&lt;/strong&gt; ), стать неактивной ( &lt;strong&gt;отключить&lt;/strong&gt; ) или быть удаленной ( &lt;strong&gt;удалить&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="f841f79d498699c727c107e3b0ca4c79fda4714f" translate="yes" xml:space="preserve">
          <source>A true embedded system must start when the system boots. This section accounts for the necessary configurations needed to achieve that.</source>
          <target state="translated">Настоящая встроенная система должна запускаться при загрузке системы.В данном разделе рассматриваются необходимые для этого конфигурации.</target>
        </trans-unit>
        <trans-unit id="1e80ac87b4ba604d5c15b3ca4c06f00704683ae7" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt;. The &lt;code&gt;HashAlgoSpec&lt;/code&gt; specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the &lt;code&gt;accept_callback()&lt;/code&gt;. The &lt;code&gt;HashALgoSpec&lt;/code&gt; is either an atom or a list of atoms as the first argument in &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt;. If it is a list of hash algorithm names, the &lt;code&gt;FingerPrint&lt;/code&gt; argument in the &lt;code&gt;accept_callback()&lt;/code&gt; will be a list of fingerprints in the same order as the corresponding name in the &lt;code&gt;HashAlgoSpec&lt;/code&gt; list.</source>
          <target state="translated">Кортеж &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt; . В &lt;code&gt;HashAlgoSpec&lt;/code&gt; определяет , какой алгоритм хеширования должен использоваться для вычисления отпечатка пальца используется в вызове &lt;code&gt;accept_callback()&lt;/code&gt; . &lt;code&gt;HashALgoSpec&lt;/code&gt; либо атом или список атомов в качестве первого аргумента в &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt; . Если это список имен хеш-алгоритмов, аргумент &lt;code&gt;FingerPrint&lt;/code&gt; в &lt;code&gt;accept_callback()&lt;/code&gt; будет списком отпечатков пальцев в том же порядке, что и соответствующее имя в списке &lt;code&gt;HashAlgoSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7e5e9de3bf6f4c7060bdc6cec37d2c3b2e6d0c" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Major,Minor}&lt;/code&gt; containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return &lt;code&gt;{0,0}&lt;/code&gt; in this field.</source>
          <target state="translated">Кортеж &lt;code&gt;{Major,Minor}&lt;/code&gt; , содержащий основную и вспомогательную версии формата файла для дампа таблиц ETS. Это поле версии было добавлено, начиная с STDLIB 1.5.1. Файлы, сброшенные более старыми версиями, возвращают в этом поле &lt;code&gt;{0,0}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07bab1189c6299dfc8d87b9698a9d20069024cab" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; for function calls</source>
          <target state="translated">Кортеж &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; для вызовов функций</target>
        </trans-unit>
        <trans-unit id="85c425ef8b5c09edd293415683557a467b94cc4b" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{registered_name,node_name}&lt;/code&gt; is used instead of just the &lt;code&gt;registered_name&lt;/code&gt;.</source>
          <target state="translated">Кортеж &lt;code&gt;{registered_name,node_name}&lt;/code&gt; используется вместо только &lt;code&gt;registered_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3f0f1a112bc371fc9fac3b642164488b8dd6fb" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt;, where &lt;code&gt;ModuleName&lt;/code&gt; and &lt;code&gt;FunctionName&lt;/code&gt; are atoms, referring to the function &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</source>
          <target state="translated">Кортеж &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt; , где &lt;code&gt;ModuleName&lt;/code&gt; и &lt;code&gt;FunctionName&lt;/code&gt; - это атомы, относящиеся к функции &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7faaaea4addaa524ef387ae744a4927d4b84f230" translate="yes" xml:space="preserve">
          <source>A tuple is a compound data type with a fixed number of terms:</source>
          <target state="translated">Кортеж кортежа-это составной тип данных с фиксированным количеством сроков:</target>
        </trans-unit>
        <trans-unit id="df982bb074bb2bcc07a3f3574312720f45bcca1f" translate="yes" xml:space="preserve">
          <source>A tuple must be specified with the number of elements. (The elements precede the &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; term.)</source>
          <target state="translated">Кортеж должен быть указан с количеством элементов. (Элементы предшествуют термину &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="d813ebdb5f103f06a944c56ba2c1950a8ea79499" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="translated">Возвращается кортеж размером, равным &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; . Элементы кортежа являются целыми числами или &lt;code&gt;unbound&lt;/code&gt; атомом . Идентификаторы логических процессоров представлены целыми числами. &lt;code&gt;N&lt;/code&gt; - й элемент кортежа равен току связывания для планировщика с планировщиком идентификатором , равным &lt;code&gt;N&lt;/code&gt; . Например, если планировщики связаны, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; возвращает идентификатор логического процессора, на котором выполняется вызывающий процесс.</target>
        </trans-unit>
        <trans-unit id="810d5b526b8906970f984c1b3db62a6c47f80147" translate="yes" xml:space="preserve">
          <source>A tuple of size three containing: the segment number, the &lt;code&gt;last segment indicator&lt;/code&gt; and finally a list of 'ActionReply' records possibly containing error indications. This is of course only possible if the reply was segmented.</source>
          <target state="translated">Кортеж размером три, содержащий: номер &lt;code&gt;last segment indicator&lt;/code&gt; и, наконец, список записей ActionReply, которые могут содержать индикаторы ошибок. Конечно, это возможно только в том случае, если ответ был сегментирован.</target>
        </trans-unit>
        <trans-unit id="3dd7bc1a3405fbef606b572d8949507a33cc4df9" translate="yes" xml:space="preserve">
          <source>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращается кортеж привязок и продолжение, если таблица не пуста, и в этом случае &lt;code&gt;'$end_of_table'&lt;/code&gt; . Продолжение следует использовать при сопоставлении других объектов путем вызова &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c722068339f5605671934079ecb1e3f17e82123" translate="yes" xml:space="preserve">
          <source>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching more objects by calling &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращается кортеж результатов применения спецификации соответствия и продолжения, если таблица не пуста, и в этом случае &lt;code&gt;'$end_of_table'&lt;/code&gt; . Продолжение следует использовать при сопоставлении большего количества объектов путем вызова &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24035af62a2fdeb2d8901fd0ee530961ccde951f" translate="yes" xml:space="preserve">
          <source>A tuple passed using the external format of Erlang.</source>
          <target state="translated">Кортеж передается с использованием внешнего формата Erlang.</target>
        </trans-unit>
        <trans-unit id="8690cf67b400404bcc0f4ff1dceb7bb83944c22f" translate="yes" xml:space="preserve">
          <source>A tuple where the elements are of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Кортеж , в котором элементы имеют тип &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4c3a805c0c5a81f38e677fa3cd9def6b983c21d" translate="yes" xml:space="preserve">
          <source>A tuple with the string and the options for compilation</source>
          <target state="translated">Кортеж со строкой и опциями компиляции</target>
        </trans-unit>
        <trans-unit id="151bd15a2cb84f42df927246cfbe8c0dd7313819" translate="yes" xml:space="preserve">
          <source>A type specifier list TSL for a bitstring element is a sequence of type specifiers &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt;, and Rep(TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt;.</source>
          <target state="translated">Список спецификаторов типа TSL для элемента строки битов представляет собой последовательность спецификаторов типа &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt; и Rep (TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08976fc5cbfe03343391c63ca50f5f50c10b8d0b" translate="yes" xml:space="preserve">
          <source>A typical (compress) usage is as follows:</source>
          <target state="translated">Типичное (компрессионное)использование выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="126a0170061e6a79a71ccf9406ef6f3af55349d4" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;.erlang&lt;/code&gt; file contains a set of search paths, for example:</source>
          <target state="translated">Типичный файл &lt;code&gt;.erlang&lt;/code&gt; содержит набор путей поиска, например:</target>
        </trans-unit>
        <trans-unit id="72082aa56cd4d1e59057d7f28996bf925833376c" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;Common Test&lt;/code&gt; test suite using &lt;code&gt;ct_property_test&lt;/code&gt; is organized as follows:</source>
          <target state="translated">Типичный набор тестов &lt;code&gt;Common Test&lt;/code&gt; с использованием &lt;code&gt;ct_property_test&lt;/code&gt; организован следующим образом:</target>
        </trans-unit>
        <trans-unit id="6ef96d247bf0039ba1ccb9fddcabd0176ac0a0c3" translate="yes" xml:space="preserve">
          <source>A typical error reason is:</source>
          <target state="translated">Типичная причина ошибки:</target>
        </trans-unit>
        <trans-unit id="05d8d9f5d6888b35439d18b6e544520b23957a25" translate="yes" xml:space="preserve">
          <source>A typical error reason:</source>
          <target state="translated">Типичная причина ошибки:</target>
        </trans-unit>
        <trans-unit id="9061494e205704eb0cdfcf7a4c046c23d96666b9" translate="yes" xml:space="preserve">
          <source>A typical implementation on Unix is to do &lt;code&gt;close((int)event)&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация в Unix - это &lt;code&gt;close((int)event)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541396ef46ffec4bf5fa435c55b2863004f29300" translate="yes" xml:space="preserve">
          <source>A typical operation could include the following steps:</source>
          <target state="translated">Типичная операция может включать следующие шаги:</target>
        </trans-unit>
        <trans-unit id="50f89c2180f830349252137c0faf845e512001e7" translate="yes" xml:space="preserve">
          <source>A typical overload situation occurs when the applications perform more updates on disc resident tables than &lt;code&gt;Mnesia&lt;/code&gt; can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</source>
          <target state="translated">Типичная ситуация перегрузки возникает, когда приложения выполняют больше обновлений резидентных таблиц диска, чем &lt;code&gt;Mnesia&lt;/code&gt; может обработать. Игнорирование такого рода перегрузки может привести к ситуации, когда дисковое пространство исчерпано (независимо от размера таблиц, хранящихся на диске).</target>
        </trans-unit>
        <trans-unit id="acb703e9dec014081d4b1835cb51aaeb3d0b76b2" translate="yes" xml:space="preserve">
          <source>A typical use of this function is to replace unbounded-size control sequences like &lt;code&gt;~w&lt;/code&gt; and &lt;code&gt;~p&lt;/code&gt; with the depth-limited variants &lt;code&gt;~W&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; before formatting to text in, for example, a logger.</source>
          <target state="translated">Типичное использование этой функции - замена управляющих последовательностей неограниченного размера, таких как &lt;code&gt;~w&lt;/code&gt; и &lt;code&gt;~p&lt;/code&gt; вариантами &lt;code&gt;~W&lt;/code&gt; и &lt;code&gt;~P&lt;/code&gt; с ограниченной глубиной перед форматированием в текст, например, в регистраторе.</target>
        </trans-unit>
        <trans-unit id="3807873b97b8b82278afb2ef76e8ea8f9bb29594" translate="yes" xml:space="preserve">
          <source>A unique identifier for a filter.</source>
          <target state="translated">Уникальный идентификатор для фильтра.</target>
        </trans-unit>
        <trans-unit id="aeb6160c71f6b3c49b7dc45e065a90d43611f9a7" translate="yes" xml:space="preserve">
          <source>A unique identifier for a handler instance.</source>
          <target state="translated">Уникальный идентификатор экземпляра обработчика.</target>
        </trans-unit>
        <trans-unit id="35c6d039fac0be1661199d1ae0d64a6d99224787" translate="yes" xml:space="preserve">
          <source>A useful dispatch function that can be used from client functions. It returns a process on the local node, if such a process exists. Otherwise, it selects one randomly.</source>
          <target state="translated">Полезная функция диспетчеризации,которую можно использовать из клиентских функций.Она возвращает процесс на локальном узле,если такой процесс существует.В противном случае она выбирает один случайным образом.</target>
        </trans-unit>
        <trans-unit id="f5bfc38acae2f40bfaee12c264aaf4416d8847f9" translate="yes" xml:space="preserve">
          <source>A useful number.</source>
          <target state="translated">Полезный номер.</target>
        </trans-unit>
        <trans-unit id="5f280d2fcfe90c0ab1a22509cb3602587fb270ec" translate="yes" xml:space="preserve">
          <source>A useful way of looking at parts of lists, is by using &quot;|&quot;. This is best explained by an example using the shell:</source>
          <target state="translated">Полезным способом просмотра частей списков является использование &quot;|&quot;.Это лучше всего объяснить на примере использования оболочки:</target>
        </trans-unit>
        <trans-unit id="14fd4e6872c372a6c8cb217dbc2352699bd53754" translate="yes" xml:space="preserve">
          <source>A user defined identity representing this notification send operation.</source>
          <target state="translated">Идентификатор пользователя,представляющий данную операцию отправки уведомления.</target>
        </trans-unit>
        <trans-unit id="2a353ec2b424bd07df4385f13b10e3ea7d64ca54" translate="yes" xml:space="preserve">
          <source>A user is being blocked from access.</source>
          <target state="translated">Доступ пользователя блокируется.</target>
        </trans-unit>
        <trans-unit id="0c5079fbb762cb2270895845abfb45816e3f4e3e" translate="yes" xml:space="preserve">
          <source>A user is being removed from the block list.</source>
          <target state="translated">Пользователь удаляется из списка блоков.</target>
        </trans-unit>
        <trans-unit id="101ba63129c1dab0968eb1083541b31cda478b02" translate="yes" xml:space="preserve">
          <source>A user is identified by its UserMid, which must be a legal Megaco MID.</source>
          <target state="translated">Пользователя идентифицирует его UserMid,который должен быть законным Megaco MID.</target>
        </trans-unit>
        <trans-unit id="fd3a9f3997e885cf7dcc7677ac20d4c9631d90cc" translate="yes" xml:space="preserve">
          <source>A user may either be statically configured in a .config file according to the application concept of Erlang/OTP or dynamically started with the configuration settings as arguments to megaco:start_user/2. These configuration settings may be updated later on with megaco:update_conn_info/2.</source>
          <target state="translated">Пользователь может быть либо статически сконфигурирован в .config-файле в соответствии с концепцией приложения Erlang/OTP,либо динамически запущен с конфигурационными настройками в качестве аргументов в megaco:start_user/2.Эти конфигурационные настройки могут быть обновлены позже с помощью megaco:update_conn_info/2.</target>
        </trans-unit>
        <trans-unit id="1504430f3d4afc3f6c812eb47a15e10f01419f56" translate="yes" xml:space="preserve">
          <source>A user may have a number of &quot;virtual&quot; connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to any number of MG's. For each connection the user selects a transport service, an encoding scheme and a user callback module.</source>
          <target state="translated">Пользователь может иметь несколько &quot;виртуальных&quot; соединений с другими пользователями.MG подключается максимум к одному MGC,в то время как MGC может быть подключен к любому количеству MG.Для каждого соединения пользователь выбирает транспортную службу,схему кодирования и пользовательский модуль обратного вызова.</target>
        </trans-unit>
        <trans-unit id="e67f458b7905dc65a23e9c34758bfcdd553eff54" translate="yes" xml:space="preserve">
          <source>A user process can subscribe on the events generated by &lt;code&gt;Mnesia&lt;/code&gt;. The following two functions are provided:</source>
          <target state="translated">Пользовательский процесс может подписаться на события, генерируемые &lt;code&gt;Mnesia&lt;/code&gt; . Предусмотрены две следующие функции:</target>
        </trans-unit>
        <trans-unit id="a930c1684ddd9a6efd75c38df17f190cbc0c2e7d" translate="yes" xml:space="preserve">
          <source>A user variable is employed for holding the &lt;code&gt;digraph&lt;/code&gt; representation of the function graph for use in many queries. The reason is efficiency. As opposed to the &lt;code&gt;=&lt;/code&gt; operator, the &lt;code&gt;:=&lt;/code&gt; operator saves a value for subsequent analyses. Here might be the place to note that equal subexpressions within a query are evaluated only once; &lt;code&gt;=&lt;/code&gt; cannot be used for speeding things up.</source>
          <target state="translated">Пользовательская переменная используется для хранения &lt;code&gt;digraph&lt;/code&gt; представления графа функции для использования во многих запросах. Причина в эффективности. В отличие от оператора &lt;code&gt;=&lt;/code&gt; , оператор &lt;code&gt;:=&lt;/code&gt; сохраняет значение для последующего анализа. Здесь можно отметить, что одинаковые подвыражения в запросе оцениваются только один раз; &lt;code&gt;=&lt;/code&gt; нельзя использовать для ускорения.</target>
        </trans-unit>
        <trans-unit id="5dca3db2b5e814aa2f8b6c5ddad967e0eb6d4fd1" translate="yes" xml:space="preserve">
          <source>A user-defined instrumentation function for each object attaches the managed objects to real resources. This function is called by the agent on a &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; operation. The function could read some hardware register, perform a calculation, or whatever is necessary to implement the semantics associated with the conceptual variable. These functions must be written both for scalar variables and for tables. They are specified in the association file, which is a text file. In this file, the &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;, or symbolic name for each managed object, is associated with an Erlang tuple &lt;code&gt;{Module,&lt;/code&gt;&lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;ListOfExtraArguments}&lt;/code&gt;.</source>
          <target state="translated">Определяемая пользователем функция инструментария для каждого объекта связывает управляемые объекты с реальными ресурсами. Эта функция вызывается агентом при операции &lt;code&gt;get&lt;/code&gt; или &lt;code&gt;set&lt;/code&gt; . Функция может читать некоторый аппаратный регистр, выполнять вычисления или что-то еще, что необходимо для реализации семантики, связанной с концептуальной переменной. Эти функции должны быть написаны как для скалярных переменных, так и для таблиц. Они указаны в файле ассоциации, который представляет собой текстовый файл. В этом файле &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; , или символическое имя для каждого управляемого объекта, связан с кортежем Erlang &lt;code&gt;{Module,&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; , &lt;code&gt;ListOfExtraArguments}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4272ec5ada9781d28edc9d23bde5292b08de6e" translate="yes" xml:space="preserve">
          <source>A user-defined parameter passed from the function &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;. It is used in the return value of &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Определяемый пользователем параметр, переданный из функции &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; . Он используется в возвращаемом значении &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab19e68c658754f6d616e8a9359af12c979f8b2d" translate="yes" xml:space="preserve">
          <source>A user-perceived character, consisting of one or more codepoints.</source>
          <target state="translated">Пользовательский символ,состоящий из одной или нескольких кодовых точек.</target>
        </trans-unit>
        <trans-unit id="8c487c4839c1da9e5bc76ca352a5448a09547f8c" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt;ssl:ssl_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">Допустимая цепочка должна иметь как минимум ROOT и одноранговый сертификат. Корневой сертификат может быть предоставлен либо как сертификат, предварительно созданный с помощью &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; , либо как параметры генерации корневого сертификата. Корневой сертификат, созданный &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; . Для доступных опций см. &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; ниже. Это подмножество типа &lt;code&gt;ssl:ssl_option()&lt;/code&gt; . &lt;code&gt;PrivateKey&lt;/code&gt; - это то, что возвращает &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b7f3becec263c2ea738b6691bf529e9d0210ac" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has SMP support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;!= 0&lt;/code&gt; если исполняющая система поддерживает SMP; в противном случае &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac91e865bee333c1075b80d53873b9d3418a7c3" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has support for dirty scheduler threads; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;!= 0&lt;/code&gt; если исполняющая система поддерживает грязные потоки планировщика; в противном случае &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ec437d87d8ab2a59f963ce8195782385431267f" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has thread support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;!= 0&lt;/code&gt; если в исполняющей системе есть поддержка потоков; в противном случае &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ba959b8daba0b753bc8f2d86eb3f9db8c6578e" translate="yes" xml:space="preserve">
          <source>A value in the &lt;code&gt;msg&lt;/code&gt; field does &lt;strong&gt;not&lt;/strong&gt; imply an absence of decode errors. The &lt;code&gt;errors&lt;/code&gt; field should also be examined.</source>
          <target state="translated">Значение в поле &lt;code&gt;msg&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; означает отсутствие ошибок декодирования. &lt;code&gt;errors&lt;/code&gt; поле также должно быть рассмотрено.</target>
        </trans-unit>
        <trans-unit id="24b9fc9ee791392b2ee5f6e020d0a3fa901804d7" translate="yes" xml:space="preserve">
          <source>A value must be provided for all variables, which lack default values in the MIB.</source>
          <target state="translated">Значение должно быть предоставлено для всех переменных,в которых отсутствуют значения по умолчанию в MIB.</target>
        </trans-unit>
        <trans-unit id="c6977869e984d6fd810d1cba7c1d446b28da9624" translate="yes" xml:space="preserve">
          <source>A value must have length at least 1.</source>
          <target state="translated">Значение должно иметь длину не менее 1.</target>
        </trans-unit>
        <trans-unit id="5445236ba06b6cb9e9bcd38ff5b377fb1c4caffb" translate="yes" xml:space="preserve">
          <source>A value of this type is encoded as an &lt;code&gt;open type&lt;/code&gt;.</source>
          <target state="translated">Значение этого типа кодируется как &lt;code&gt;open type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c03ee0717973a910f7c750d1a0679fb27eb9cdb9" translate="yes" xml:space="preserve">
          <source>A variable cannot be assigned a new value unless first removed. Variables assigned to by the &lt;code&gt;=&lt;/code&gt; operator are removed at the end of the query, while variables assigned to by the &lt;code&gt;:=&lt;/code&gt; operator can only be removed by calls to &lt;code&gt;forget&lt;/code&gt;. There are no user variables when module data need to be set up again; if any of the functions that make it necessary to set up module data again is called, all user variables are forgotten.</source>
          <target state="translated">Переменной нельзя присвоить новое значение, если она не была сначала удалена. Переменные, присвоенные оператором &lt;code&gt;=&lt;/code&gt; , удаляются в конце запроса, тогда как переменные, назначенные оператором &lt;code&gt;:=&lt;/code&gt; , могут быть удалены только вызовами, чтобы &lt;code&gt;forget&lt;/code&gt; . Отсутствуют пользовательские переменные, когда необходимо заново настроить данные модуля; если вызывается какая-либо из функций, которые заставляют снова настраивать данные модуля, все пользовательские переменные забываются.</target>
        </trans-unit>
        <trans-unit id="5646fa290bab26490d3e95c3eda24f90bfb3cb85" translate="yes" xml:space="preserve">
          <source>A variable is an expression. If a variable is bound to a value, the return value is this value. Unbound variables are only allowed in patterns.</source>
          <target state="translated">Переменная-это выражение.Если переменная привязана к значению,то возвращаемым значением является это значение.Несвязанные переменные допускаются только в шаблонах.</target>
        </trans-unit>
        <trans-unit id="ad98bc5cb949befd1ed83fe57c5fe19294f99fe2" translate="yes" xml:space="preserve">
          <source>A variable name that is not in the environment results in an error.</source>
          <target state="translated">Имя переменной,не находящейся в окружении,приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="d4d78baa7493d760df88a559b3a2f6209c0e9bbb" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="translated">Один из вариантов - использовать &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt; . Затем состояние моделируется, например, с помощью кортежа &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d89b8938a6cae035d7fea046259542e22b9f6ee1" translate="yes" xml:space="preserve">
          <source>A web server can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application, or dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options, also called properties, are as follows:</source>
          <target state="translated">Веб - сервер может быть настроен на запуск при запуске &lt;code&gt;Inets&lt;/code&gt; приложения или динамически во время выполнения вызова &lt;code&gt;Inets&lt;/code&gt; приложения API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; или &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt; , см &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; . Параметры конфигурации, также называемые свойствами, следующие:</target>
        </trans-unit>
        <trans-unit id="b7054606b43999cf69240d9ae96069173e833e99" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match \w or \W (that is, one matches \w and the other matches \W), or the start or end of the string if the first or last character matches \w, respectively. In UTF mode, the meanings of \w and \W can be changed by setting option &lt;code&gt;ucp&lt;/code&gt;. When this is done, it also affects \b and \B. PCRE and Perl do not have a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However, whatever follows \b normally determines which it is. For example, the fragment \ba matches &quot;a&quot; at the start of a word.</source>
          <target state="translated">Граница слова - это позиция в строке темы, в которой текущий и предыдущий символы не совпадают ни с \ w, ни с \ W (то есть один соответствует \ w, а другой соответствует \ W), а также началу или концу строка, если первый или последний символ соответствует \ w соответственно. В режиме UTF значения \ w и \ W можно изменить, установив опцию &lt;code&gt;ucp&lt;/code&gt; . Когда это будет сделано, это также повлияет на \ b и \ B. PCRE и Perl не имеют отдельной метапоследовательности &amp;laquo;начало слова&amp;raquo; или &amp;laquo;конец слова&amp;raquo;. Однако то, что следует за \ b, обычно определяет, что это за символ. Например, фрагмент \ ba соответствует &quot;a&quot; в начале слова.</target>
        </trans-unit>
        <trans-unit id="62d9a28c75bb240da271eb7051702080009f9364" translate="yes" xml:space="preserve">
          <source>A wrap disk log file consists of many files, called index files. A log file can be opened and closed. Also, a single index file can be opened separately. If a non-existent or non-internally formatted file is opened, an error message is returned. If the file is corrupt, no attempt is made to repair it, but an error message is returned.</source>
          <target state="translated">Оберточный дисковый лог-файл состоит из множества файлов,называемых индексными файлами.Лог-файл может быть открыт и закрыт.Кроме того,один индексный файл может быть открыт отдельно.При открытии несуществующего или не форматированного файла возвращается сообщение об ошибке.Если файл поврежден,попытка восстановить его не предпринимается,но возвращается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="0eb179692808865df9fddfd61d123acd14ceb6dd" translate="yes" xml:space="preserve">
          <source>A wrap files specification is used to limit the disk space consumed by the trace. The trace is written to a limited number of files each with a limited size. The actual filenames are &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt;, where &lt;code&gt;SeqCnt&lt;/code&gt; counts as a decimal string from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;WrapCnt&lt;/code&gt; and then around again from &lt;code&gt;0&lt;/code&gt;. When a trace term written to the current file makes it longer than &lt;code&gt;WrapSize&lt;/code&gt;, that file is closed, if the number of files in this wrap trace is as many as &lt;code&gt;WrapCnt&lt;/code&gt; the oldest file is deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped, there are at most &lt;code&gt;WrapCnt&lt;/code&gt; trace files saved with a size of at least &lt;code&gt;WrapSize&lt;/code&gt; (but not much bigger), except for the last file that might even be empty. The default values are &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; and &lt;code&gt;WrapCnt = 8&lt;/code&gt;.</source>
          <target state="translated">Спецификация файлов переноса используется для ограничения дискового пространства, занимаемого трассировкой. Трассировка записывается в ограниченное количество файлов, каждый с ограниченным размером. Фактические имена файлов - это &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt; , где &lt;code&gt;SeqCnt&lt;/code&gt; считается десятичной строкой от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;WrapCnt&lt;/code&gt; , а затем снова с &lt;code&gt;0&lt;/code&gt; . Когда термин трассировки, записанный в текущий файл, делает его длиннее, чем &lt;code&gt;WrapSize&lt;/code&gt; , этот файл закрывается, если количество файлов в этой трассировке &lt;code&gt;WrapCnt&lt;/code&gt; самый старый файл удаляется, тогда открывается новый файл, который становится текущим. Таким образом, когда трассировка &lt;code&gt;WrapCnt&lt;/code&gt; была остановлена, имеется не более WrapCntфайлы трассировки, сохраненные с размером не менее &lt;code&gt;WrapSize&lt;/code&gt; (но не намного больше), за исключением последнего файла, который может быть даже пуст. Значения по умолчанию: &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; и &lt;code&gt;WrapCnt = 8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a037e42e51e318b55fc1948fa5a1661147cd7c" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The attributes and &lt;code&gt;TabDef&lt;/code&gt; are forwarded to &lt;code&gt;mnesia:create_table/2&lt;/code&gt;. For example, if the table is to reside as &lt;code&gt;disc_only_copies&lt;/code&gt; on all nodes, a call looks as follows:</source>
          <target state="translated">Функция-оболочка для &lt;code&gt;mnesia:create_table/2&lt;/code&gt; , которая создает таблицу (если таблицы не существует) с соответствующим набором &lt;code&gt;attributes&lt;/code&gt; . Атрибуты и &lt;code&gt;TabDef&lt;/code&gt; передаются в &lt;code&gt;mnesia:create_table/2&lt;/code&gt; . Например, если таблица должна находиться как &lt;code&gt;disc_only_copies&lt;/code&gt; на всех узлах, вызов будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="36b94a437ad5d966a2bc660ff3e1289bcc1b9fd7" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The table only resides on the local node and its storage type is the same as the &lt;code&gt;schema&lt;/code&gt; table on the local node, that is, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; or &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt;.</source>
          <target state="translated">Функция-оболочка для &lt;code&gt;mnesia:create_table/2&lt;/code&gt; , которая создает таблицу (если таблицы не существует) с соответствующим набором &lt;code&gt;attributes&lt;/code&gt; . Таблица находится только на локальном узле, и ее тип хранения такой же, как таблица &lt;code&gt;schema&lt;/code&gt; на локальном узле, то есть &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; или &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bab14cb554b0f0419a6e027fa857770d1ae7636" translate="yes" xml:space="preserve">
          <source>A write operation on a &lt;code&gt;disc_copies&lt;/code&gt; table replica is performed in two steps. First the write operation is appended to a log file, then the actual operation is performed in RAM.</source>
          <target state="translated">Операция записи в &lt;code&gt;disc_copies&lt;/code&gt; таблицы disc_copies выполняется в два этапа. Сначала операция записи добавляется в файл журнала, затем фактическая операция выполняется в ОЗУ.</target>
        </trans-unit>
        <trans-unit id="d9843d85d25b1bd741fdb98939b327e3138b2bfb" translate="yes" xml:space="preserve">
          <source>A zlib stream, see &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поток zlib, см. &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17afbf6d1d5b871c5ae0cee1ba18a4f7071dc38b" translate="yes" xml:space="preserve">
          <source>A: Cygwin, MSYS or MSYS2 is the environment, which closely resembles the environment found on any Unix machine. It's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, Cygwin/MSYS/MSYS2 tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; and &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in Cygwin/MSYS/MSYS2 are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The Cygwin specific command &lt;code&gt;cygpath&lt;/code&gt; is used for most of the path conversions in a Cygwin environment. Other tools are used (when needed) in the corresponding MSYS and MSYS2 environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="translated">A: Cygwin, MSYS или MSYS2 - это среда, которая очень похожа на среду на любой машине Unix. Это почти как если бы у вас была виртуальная машина Unix внутри Windows. Configure, задав определенные параметры, затем создает файлы сборки, которые используются программой gnu-make среды для сборки системы. Однако большинство реальных компиляторов и т. Д. Не являются инструментами Cygwin / MSYS / MSYS2, поэтому мы написали пару оболочек (сценариев оболочки Bourne), которые находятся в &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; и &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt; , Все они выполняют преобразование параметров и переключателей, общих для среды Unix, для соответствия встроенным инструментам Windows. Наиболее примечательны, конечно, пути, которые в Cygwin / MSYS / MSYS2 являются Unix-подобными путями с &amp;laquo;косой чертой&amp;raquo; (/) и без букв дисков. Специфическая команда Cygwin &lt;code&gt;cygpath&lt;/code&gt; используется для большинства преобразований пути в среде Cygwin. Другие инструменты используются (при необходимости) в соответствующей среде MSYS и MSYS2. К счастью, большинство компиляторов принимают в качестве разделителей пути косую черту вместо обратной, но все же нужно правильно указать буквы дисков и т. Д. Скрипты оболочки не являются общими в том смысле, что, например, cc.sh понимает и переводит все возможные параметры gcc и передает правильные параметры в cl.exe. Принцип состоит в том, что скрипты достаточно мощные, чтобы позволить создавать Erlang / OTP, ни больше, ни меньше. Им могут потребоваться расширения, чтобы справиться с изменениями во время разработки Erlang, и это одна из причин, по которой мы сделали их сценариями оболочки, а не сценариями Perl. Мы считаем, что их легче понять и изменить таким образом.</target>
        </trans-unit>
        <trans-unit id="4d1ee8b13defdb6f13a0a5e7daa4cf8a74b29540" translate="yes" xml:space="preserve">
          <source>A: For Cygwin, MSYS and MSYS2 alike, we try to use the latest releases available when building. What versions you use shouldn't really matter. We try to include workarounds for the bugs we've found in different Cygwin/MSYS/MSYS2 releases. Please help us add workarounds for new Cygwin/MSYS/MSYS2-related bugs as soon as you encounter them. Also please do submit bug reports to the appropriate Cygwin, MSYS and/or MSYS2 developers. The GCC we used for 21 was version 4.8.1 (MinGW 32bit) and 4.8.5 (MSYS2 64bit). We used VC++ 12.0 (i.e. Visual studio 2013), Sun's JDK 1.6.0_45 (32bit) and Sun's JDK 1.7.0_1 (64bit), NSIS 2.46, and Win32 OpenSSL 1.0.2d. Please read the next section for details on what you need.</source>
          <target state="translated">О:Для Cygwin,MSYS и MSYS2 мы стараемся использовать при сборке самые свежие релизы.Какие версии вы используете на самом деле не должны иметь значения.Мы стараемся включать обходные пути для найденных ошибок в различных релизах Cygwin/MSYS/MSYS2.Пожалуйста,помогите нам добавить обходные пути для новых ошибок,связанных с Cygwin/MSYS/MSYS2,как только вы с ними столкнетесь.Также,пожалуйста,отправляйте отчеты об ошибках соответствующим разработчикам Cygwin,MSYS и/или MSYS2.GCC,который мы использовали для 21,был версии 4.8.1 (MinGW 32bit)и 4.8.5 (MSYS2 64bit).Мы использовали VC++12.0 (т.е.Visual Studio 2013),Sun's JDK 1.6.0_45 (32 бит)и Sun's JDK 1.7.0_1 (64 бит),NSIS 2.46 и Win32 OpenSSL 1.0.2d.Пожалуйста,прочтите следующий раздел для получения подробной информации о том,что вам нужно.</target>
        </trans-unit>
        <trans-unit id="731d5bc0547d3ee14b9d073a740322bb562e4b26" translate="yes" xml:space="preserve">
          <source>A: No, never. The hassle of keeping the project files up to date and do all the steps that constitute an OTP build from within the VC++ GUI is simply not worth it, maybe even impossible. A VC++ project file for Erlang/OTP will never happen.</source>
          <target state="translated">О:Нет,никогда.Суета в том,чтобы держать проектные файлы в актуальном состоянии и выполнять все шаги,которые составляют сборку OTP изнутри VC++GUI,просто не стоит,может быть,даже невозможна.Файл проекта VC++для Erlang/OTP никогда не случится.</target>
        </trans-unit>
        <trans-unit id="521d37ede1551a08a3beff1206807c9cd55ca94a" translate="yes" xml:space="preserve">
          <source>A: No, not really, but see this as a step in the right direction.</source>
          <target state="translated">О:Нет,не совсем,но рассматривайте это как шаг в правильном направлении.</target>
        </trans-unit>
        <trans-unit id="58e458048a7a9548592140528083c14b19023a3f" translate="yes" xml:space="preserve">
          <source>A: No, the result will be a pure Windows binary, and as far as I know, it's not possible to make a Cygwin binary yet. That is of course something desirable, but there are still some problems with the dynamic linking (dynamic Erlang driver loading) as well as the TCP/IP emulation in Cygwin, which, I'm sure of, will improve, but still has some problems. Fixing those problems might be easy or might be hard. I suggest you try yourself and share your experience. No one would be happier if a simple &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; would produce a fully fledged Cygwin binary.</source>
          <target state="translated">О: Нет, результатом будет чистый двоичный файл Windows, и, насколько мне известно, создать двоичный файл Cygwin пока невозможно. Это, конечно, желательно, но все еще есть проблемы с динамической компоновкой (динамическая загрузка драйвера Erlang), а также с эмуляцией TCP / IP в Cygwin, которая, я уверен, улучшится, но все еще имеет некоторые проблемы. , Устранение этих проблем может быть простым или трудным. Предлагаю вам попробовать себя и поделиться своим опытом. Никто не был бы счастливее, если бы простой &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; создал бы полноценный двоичный файл Cygwin.</target>
        </trans-unit>
        <trans-unit id="f58ec10da79cf14638b87d58a71fefc5754e9d5f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the Cygwin environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler. The Windows SDK is however enough to build Erlang, you do not need to buy Visual C++, just download the SDK (SDK version 8.1 == Visual studio 2013).</source>
          <target state="translated">О:Нет,к сожалению,нет.Вам понадобится Visual C++от Microsoft.Скрипт Bourne-shell (cc.sh)обёртывает компилятор Visual C++и запускает его из среды Cygwin.Все остальные инструменты,необходимые для сборки Erlang,являются свободно распространяемыми/открытыми исходными текстами,но не компилятор C.Однако для сборки Erlang достаточно Windows SDK,вам не нужно покупать Visual C++,просто скачайте SDK (SDK версии 8.1 ==Visual Studio 2013).</target>
        </trans-unit>
        <trans-unit id="a599e8e13ccfd4f3e0504f6192bcbcf31a59938f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately we haven't got time to help with Cygwin/MSYS/MSYS2 related user problems, please read related websites, newsgroups and mailing lists.</source>
          <target state="translated">A:Нет,к сожалению,у нас нет времени,чтобы помочь с проблемами пользователей,связанными с Cygwin/MSYS/MSYS2,пожалуйста,ознакомьтесь с соответствующими сайтами,новостными группами и списками рассылки.</target>
        </trans-unit>
        <trans-unit id="210dcbb21de47a153ba938b86b20600d7d480a0c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using Cygwin's or MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="translated">A: Хорошо, я допускаю, что один из файлов компилируется с использованием Cygwin или MinGW GCC, а полученный объектный код затем конвертируется в совместимый с MS VC ++ coff с помощью небольшого хака на C. Это потому, что этот конкретный файл, &lt;code&gt;beam_emu.c&lt;/code&gt; , очень выигрывает от возможности использовать расширение GCC labels-as-values, которое повышает производительность эмулятора до 50%. К сожалению, это (пока) не означает, что весь OTP может быть скомпилирован с использованием GCC. Этот конкретный исходный код не делает ничего специфичного для системы и фактически адаптирован к тому факту, что GCC используется для его компиляции в Windows.</target>
        </trans-unit>
        <trans-unit id="97fcb970b445ac9a87b96b37bf7ea3a4ab4cab29" translate="yes" xml:space="preserve">
          <source>A: Well, it's not expensive, it's free (as in free beer). Just download and install the latest Windows SDK from Microsoft and all the tools you need are there. The included debugger (WinDbg) is also quite usable. That's what I used when porting Erlang to 64bit Windows. Another reason to use later Microsoft compilers is DLL compatibility. DLL's using a new version of the standard library might not load if the VM is compiled with an old VC++ version. So we should aim to use the latest freely available SDK and compiler.</source>
          <target state="translated">О:Ну,это не дорого,это бесплатно (как в бесплатном пиве).Просто скачайте и установите последнюю версию Windows SDK от Microsoft,и все необходимые инструменты будут там.Входящий в комплект отладчик (WinDbg)также весьма удобен.Это то,что я использовал при переносе Erlang на 64-битную Windows.Другой причиной использования более поздних компиляторов Microsoft является совместимость с DLL.Использование DLL в новой версии стандартной библиотеки может не загружаться,если ВМ скомпилирована со старой версией VC++.Поэтому следует стремиться использовать новейший свободно доступный SDK и компилятор.</target>
        </trans-unit>
        <trans-unit id="c041ae7e57578688a11137a9916f0588de32a73f" translate="yes" xml:space="preserve">
          <source>A: Well, partly because it's a good compiler - really! Actually it's been possible in late R11-releases to build using mingw instead of visual C++ (you might see the remnants of that in some scripts and directories). Unfortunately the development of the SMP version for Windows broke the mingw build and we chose to focus on the VC++ build as the performance has been much better in the VC++ versions. The mingw build will possibly be back, but as long as VC++ gives better performance, the commercial build will be a VC++ one.</source>
          <target state="translated">О:Ну,отчасти потому,что это хороший компилятор-на самом деле! На самом деле,в поздних R11-релизах стало возможным собирать с помощью mingw вместо визуального C++(остатки этого можно увидеть в некоторых скриптах и каталогах).К сожалению,разработка версии SMP для Windows сломала сборку mingw,и мы решили сконцентрироваться на сборке VC++,так как в версиях VC++производительность была намного лучше.Возможно,сборка mingw и вернется,но пока VC++дает лучшую производительность,коммерческая сборка будет VC++.</target>
        </trans-unit>
        <trans-unit id="8315e42a391d74c84bc127e20d99aa2c7b6bc114" translate="yes" xml:space="preserve">
          <source>A: Yes, we use the exact same build procedure.</source>
          <target state="translated">О:Да,мы используем точно такую же процедуру построения.</target>
        </trans-unit>
        <trans-unit id="436942b9131313ac7f725ef0106016a7cb814a52" translate="yes" xml:space="preserve">
          <source>API for a SSL/TLS CRL (Certificate Revocation List) cache.</source>
          <target state="translated">API для кэша SSL/TLS CRL (Certificate Revocation List-список отзыва сертификатов).</target>
        </trans-unit>
        <trans-unit id="a23c8e20572073978952d048d9433a8575f6a97d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang NIF library.</source>
          <target state="translated">Функции API для библиотеки Erlang NIF.</target>
        </trans-unit>
        <trans-unit id="361d551affb47befd80fca6479fe8a167dc7036d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang driver.</source>
          <target state="translated">Функции API для драйвера Эрланга.</target>
        </trans-unit>
        <trans-unit id="d310425c434730e2f59306f932cf1691ae572d78" translate="yes" xml:space="preserve">
          <source>API functions to write customized SSH clients and servers applications</source>
          <target state="translated">Функции API для написания настраиваемых SSH клиентов и серверных приложений</target>
        </trans-unit>
        <trans-unit id="72bf5fea06a2041d232930267f67048618c99f45" translate="yes" xml:space="preserve">
          <source>API module for Logger, the standard logging facility in Erlang/OTP.</source>
          <target state="translated">API модуль для Журнала,стандартный журнал в Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="0be52be7a0efe4a62d99e98efb97a08aef84fe41" translate="yes" xml:space="preserve">
          <source>API module for public-key infrastructure.</source>
          <target state="translated">API модуль для инфраструктуры открытых ключей.</target>
        </trans-unit>
        <trans-unit id="76827dde5bd6ab1accea3ccbe25374a63afc24e6" translate="yes" xml:space="preserve">
          <source>ARM: ARMv5TE (i.e. XScale) processors should work. Both big-endian and little-endian modes are supported.</source>
          <target state="translated">ARM:Должны работать процессоры ARMv5TE (т.е.XScale).Поддерживаются режимы big-endian и little-endian.</target>
        </trans-unit>
        <trans-unit id="ca8c02ce6c85a255754680e86371209b9b2680ce" translate="yes" xml:space="preserve">
          <source>ARM: Linux</source>
          <target state="translated">ARM:Linux</target>
        </trans-unit>
        <trans-unit id="d9932f6f9e0505be61dc8fcd25736c1bf8cf818f" translate="yes" xml:space="preserve">
          <source>ASCII value or unicode code-point of the character &lt;strong&gt;&lt;code&gt;char&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Значение ASCII или кодовая точка Unicode символа &lt;strong&gt; &lt;code&gt;char&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="196ab313cd92b6ea93995c7fc93f081f77b30992" translate="yes" xml:space="preserve">
          <source>ASN.1 DER-encoded entity as an Erlang binary.</source>
          <target state="translated">ASN.1 Объект,закодированный в DER как двоичный Erlang.</target>
        </trans-unit>
        <trans-unit id="368efd7c5142e650553f401aa461d1b76d069901" translate="yes" xml:space="preserve">
          <source>ASN.1 compiler and compile-time support functions</source>
          <target state="translated">Функции компилятора и поддержки времени компиляции ASN.1</target>
        </trans-unit>
        <trans-unit id="c009d6d020f91e9075e192687145f1f9183e3b17" translate="yes" xml:space="preserve">
          <source>ASN.1 has both primitive and constructed types:</source>
          <target state="translated">ASN.1 имеет как примитивные,так и сконструированные типы:</target>
        </trans-unit>
        <trans-unit id="cfcd66d008f9b63d7b919bdf916303779861fe19" translate="yes" xml:space="preserve">
          <source>ASN.1 is a formal language for describing data structures to be exchanged between distributed computer systems. The purpose of ASN.1 is to have a platform and programming language independent notation to express types using a standardized set of rules for the transformation of values of a defined type into a stream of bytes. This stream of bytes can then be sent on any type of communication channel. This way, two applications written in different programming languages running on different computers, and with different internal representation of data, can exchange instances of structured data types.</source>
          <target state="translated">ASN.1 является формальным языком описания структур данных,которыми необходимо обмениваться между распределенными компьютерными системами.Назначение ASN.1-иметь независимую от платформы и языка программирования нотацию для выражения типов с использованием стандартизированного набора правил для преобразования значений определенного типа в поток байт.Этот поток байтов может затем передаваться по любому каналу связи.Таким образом,два приложения,написанные на разных языках программирования и работающие на разных компьютерах с разным внутренним представлением данных,могут обмениваться экземплярами структурированных типов данных.</target>
        </trans-unit>
        <trans-unit id="3b1ea2d9df3b25e2e5fe146441abf268990d9a8f" translate="yes" xml:space="preserve">
          <source>ASN.1 is used in two different ways in SNMP. The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1.</source>
          <target state="translated">ASN.1 используется в SNMP двумя различными способами.SMI основан на ASN.1,а сообщения в протоколе определяются с помощью ASN.1.</target>
        </trans-unit>
        <trans-unit id="18afe0241096372d9207a097906f4cc9e96ca40a" translate="yes" xml:space="preserve">
          <source>ASN.1 itself specifies indefinitely large integers. Erlang systems with version 4.3 and higher support very large integers, in practice indefinitely large integers.</source>
          <target state="translated">Сам ASN.1 определяет бесконечно большие целые числа.Системы Erlang версии 4.3 и выше поддерживают очень большие целые числа,на практике бесконечно большие целые числа.</target>
        </trans-unit>
        <trans-unit id="1b5feca556ffbb7ecdf53e29fcc97d476a5bf5f3" translate="yes" xml:space="preserve">
          <source>ASN.1 module &lt;code&gt;People&lt;/code&gt; is now accepted and the abstract syntax tree is saved in file &lt;code&gt;People.asn1db&lt;/code&gt;. The generated Erlang code is compiled using the Erlang compiler and loaded into the Erlang runtime system. There is now an API for &lt;code&gt;encode/2&lt;/code&gt; and &lt;code&gt;decode/2&lt;/code&gt; in module &lt;code&gt;People&lt;/code&gt;, which is called like:</source>
          <target state="translated">Модуль ASN.1 &lt;code&gt;People&lt;/code&gt; теперь принят, а абстрактное синтаксическое дерево сохраняется в файле &lt;code&gt;People.asn1db&lt;/code&gt; . Сгенерированный код Erlang компилируется с помощью компилятора Erlang и загружается в систему времени выполнения Erlang. Теперь в модуле &lt;code&gt;People&lt;/code&gt; есть API для &lt;code&gt;encode/2&lt;/code&gt; и &lt;code&gt;decode/2&lt;/code&gt; , который называется примерно так:</target>
        </trans-unit>
        <trans-unit id="38ab94405d2e97c97a998a6475af5251fa89b825" translate="yes" xml:space="preserve">
          <source>ASN.1 supports a wide variety of character sets. The main difference between an &lt;code&gt;OCTET STRING&lt;/code&gt; and a character string is that the &lt;code&gt;OCTET STRING&lt;/code&gt; has no imposed semantics on the bytes delivered.</source>
          <target state="translated">ASN.1 поддерживает широкий спектр наборов символов. Основное различие между &lt;code&gt;OCTET STRING&lt;/code&gt; и символьной строкой состоит в том, что &lt;code&gt;OCTET STRING&lt;/code&gt; не имеет навязанной семантики доставляемых байтов.</target>
        </trans-unit>
        <trans-unit id="00118b8d7398e0597bbf5e3a9b1a946f91c275ba" translate="yes" xml:space="preserve">
          <source>ASN.1 type present in the Public Key applications ASN.1 specifications.</source>
          <target state="translated">Тип ASN.1,присутствующий в спецификациях ASN.1 для приложений с открытым ключом.</target>
        </trans-unit>
        <trans-unit id="999234c8b850d2864e4971ba3f6a923f854d60c2" translate="yes" xml:space="preserve">
          <source>ASN1 file. It creates an &lt;code&gt;.erl&lt;/code&gt;, &lt;code&gt;.hrl&lt;/code&gt;, and &lt;code&gt;.asn1db&lt;/code&gt; file from an &lt;code&gt;.asn1&lt;/code&gt; file. Also compiles the &lt;code&gt;.erl&lt;/code&gt; using the Erlang compiler unless option &lt;code&gt;+noobj&lt;/code&gt; is specified.</source>
          <target state="translated">ASN1 файл. Он создает &lt;code&gt;.erl&lt;/code&gt; , &lt;code&gt;.hrl&lt;/code&gt; и &lt;code&gt;.asn1db&lt;/code&gt; из файла &lt;code&gt;.asn1&lt;/code&gt; . Также компилирует &lt;code&gt;.erl&lt;/code&gt; с помощью компилятора Erlang, если не указан параметр &lt;code&gt;+noobj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4ea8e8df4b539a09e4694a57b64fe87acc6aa2" translate="yes" xml:space="preserve">
          <source>AVP Codes</source>
          <target state="translated">AVP-коды</target>
        </trans-unit>
        <trans-unit id="5f07924d7df0ed6c7a91768f9fe2d84ed905e783" translate="yes" xml:space="preserve">
          <source>AVP Considerations</source>
          <target state="translated">Соображения АВП</target>
        </trans-unit>
        <trans-unit id="358dba47c0c1d2a1ab4897c5be6e756cf7939cf1" translate="yes" xml:space="preserve">
          <source>AVP Flags</source>
          <target state="translated">флаги AVP</target>
        </trans-unit>
        <trans-unit id="147e947b2ccddb2127e44e91cd77c7172c834c87" translate="yes" xml:space="preserve">
          <source>AVP Header</source>
          <target state="translated">заголовок AVP</target>
        </trans-unit>
        <trans-unit id="db689f171790fb1bc972a968ef05e4c119e28132" translate="yes" xml:space="preserve">
          <source>AVP Occurrence Tables</source>
          <target state="translated">Таблицы происхождений AVP</target>
        </trans-unit>
        <trans-unit id="7b38fc4069f3bc947361bf1d7d5e19953586e35e" translate="yes" xml:space="preserve">
          <source>AVP Values</source>
          <target state="translated">Значения AVP</target>
        </trans-unit>
        <trans-unit id="c483ce0c3913a6678d954f208b0703dcb0e25b18" translate="yes" xml:space="preserve">
          <source>AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types.</source>
          <target state="translated">Значения AVP,отправляемые в исходящих сообщениях CER или CEA во время обмена возможностями.Может быть сконфигурировано как на службе,так и на транспорте,значения на последнем имеют приоритет.Имеет один из следующих типов.</target>
        </trans-unit>
        <trans-unit id="2c0e57636791ead050a384bc77e79f8d2fe33260" translate="yes" xml:space="preserve">
          <source>AVPs are decoded into a list of diameter_avp records in &lt;code&gt;avps&lt;/code&gt; field of diameter_packet records independently of &lt;code&gt;decode_format&lt;/code&gt;.</source>
          <target state="translated">AVP декодируются в список записей &lt;code&gt;avps&lt;/code&gt; поле avps записей Diameter_packet независимо от &lt;code&gt;decode_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84bf21f5193b0af6e24655608ac0e30ceef7e07a" translate="yes" xml:space="preserve">
          <source>AVPs defined in the RFC are defined in dictionaries provided by diameter. Their proper use in application messages is the responsibility of the user.</source>
          <target state="translated">АВП,определенные в КСФ,определяются в словарях,предоставляемых по диаметру.Ответственность за их правильное использование в сообщениях приложения несет пользователь.</target>
        </trans-unit>
        <trans-unit id="6734299ae0f748faa6b52d7e11abf2d0c25ca64f" translate="yes" xml:space="preserve">
          <source>AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question.</source>
          <target state="translated">AVP,используемые для построения исходящих сообщений CER/CEA.Значения имеют приоритет над любыми указанными в данной услуге.</target>
        </trans-unit>
        <trans-unit id="5816a66e2c13a6d76644d2e1d9520bcb6dbe4591" translate="yes" xml:space="preserve">
          <source>Aa a list of binary digits (0 or 1). This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if option &lt;strong&gt;legacy_bit_string&lt;/strong&gt; is given.</source>
          <target state="translated">Список двоичных цифр (0 или 1). Этот формат принимается в качестве входных данных для функций кодирования, и &lt;code&gt;BIT STRING&lt;/code&gt; декодируется в этот формат, если &lt;strong&gt;задана&lt;/strong&gt; опция &lt;strong&gt;legacy_bit_string&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d5bdc897b18ae8c316a38939d3d1d0e98477ad32" translate="yes" xml:space="preserve">
          <source>Abandon carrier free block min limit. A valid &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; is a positive integer representing a block size limit. The largest free block in a carrier must be at least &lt;code&gt;bytes&lt;/code&gt; large, for the carrier to be abandoned. The default is zero but can be changed in the future.</source>
          <target state="translated">Отказаться от минимального ограничения на количество блоков без несущей. Допустимый &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; - это положительное целое число, представляющее ограничение на размер блока. Самый большой свободный блок на носителе должен быть не менее &lt;code&gt;bytes&lt;/code&gt; , чтобы носитель был оставлен. Значение по умолчанию равно нулю, но в будущем его можно будет изменить.</target>
        </trans-unit>
        <trans-unit id="2e058521811c5ddbaf236521691a6aac5c91e2d2" translate="yes" xml:space="preserve">
          <source>Abandon carrier number limit. A valid &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</source>
          <target state="translated">Отказаться от ограничения количества операторов связи. Допустимое &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; - это положительное целое число, представляющее максимальное количество брошенных несущих на экземпляр распределителя. По умолчанию 1000, что практически отключит ограничение, но это может быть изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="ddd8504b781a1a9f6d7b92f1aa500221a0c4787e" translate="yes" xml:space="preserve">
          <source>Abandon carrier utilization limit. A valid &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; is an integer in the range &lt;code&gt;[0, 100]&lt;/code&gt; representing utilization in percent. When a utilization value &amp;gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If &lt;code&gt;de&lt;/code&gt; (default enabled) is passed instead of a &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt;, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to &lt;code&gt;de&lt;/code&gt;, but this can be changed in the future.</source>
          <target state="translated">Отказаться от ограничения использования оператора связи. Допустимое значение &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; - это целое число в диапазоне &lt;code&gt;[0, 100]&lt;/code&gt; представляющее коэффициент использования в процентах. Когда используется значение использования&amp;gt; 0, экземплярам распределителя разрешается отказаться от многоблочных несущих. Если вместо &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; передается &lt;code&gt;de&lt;/code&gt; (по умолчанию включено) , используется рекомендованное ненулевое значение использования. Выбранное значение зависит от типа распределителя и может быть изменено между версиями ERTS. По умолчанию &lt;code&gt;de&lt;/code&gt; , но это может быть изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="99ed550f3cfb54b7e586b3d6dae1d5c6c29740db" translate="yes" xml:space="preserve">
          <source>Ability to start an Erlang emulator with more flags (any flags supported by &lt;code&gt;erl&lt;/code&gt; are supported).</source>
          <target state="translated">Возможность запустить эмулятор Erlang с большим количеством флагов (поддерживаются любые флаги, поддерживаемые &lt;code&gt;erl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31592e98a78da975e62737d1409cd4fb77bffb8e" translate="yes" xml:space="preserve">
          <source>Abnormally terminates the association specified by &lt;code&gt;Assoc&lt;/code&gt;, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and the socket can be used in new associations.</source>
          <target state="translated">Аномально завершает ассоциацию, указанную &lt;code&gt;Assoc&lt;/code&gt; , без сброса неотправленных данных. Сама розетка остается открытой. Другие ассоциации, открытые в этом сокете, все еще действительны, и сокет может использоваться в новых ассоциациях.</target>
        </trans-unit>
        <trans-unit id="54e07c4e032173c30d3e1d7eccc1fc09c4351b63" translate="yes" xml:space="preserve">
          <source>Abort-Session-Answer</source>
          <target state="translated">Abort-Session-Answer</target>
        </trans-unit>
        <trans-unit id="aa6a977eb79f01d2748881fca70eaba063d40819" translate="yes" xml:space="preserve">
          <source>Abort-Session-Request</source>
          <target state="translated">Abort-Session-Request</target>
        </trans-unit>
        <trans-unit id="53f8d6aa2f451847b8dbd7813ad859f16188a7eb" translate="yes" xml:space="preserve">
          <source>Aborting a Session</source>
          <target state="translated">Прерывание сессии</target>
        </trans-unit>
        <trans-unit id="b90030936dbb152015b9486771f1ada8423bb6a8" translate="yes" xml:space="preserve">
          <source>Aborts the current association without flushing any unsent data</source>
          <target state="translated">Прерывает текущую ассоциацию,не смывая не отправленные данные.</target>
        </trans-unit>
        <trans-unit id="32505d42e4f66e192dcee78817ac876d40a66d28" translate="yes" xml:space="preserve">
          <source>Aborts the currently executing test case. The user must know with certainty which test case is currently executing. The function is therefore only safe to call from a function that has been called (or synchronously invoked) by the test case.</source>
          <target state="translated">Отменяет выполняемый в настоящее время тест.Пользователь должен точно знать,какой тестовый случай выполняется в данный момент.Поэтому функция может быть безопасно вызвана только из функции,которая была вызвана (или синхронно вызвана)тестовым случаем.</target>
        </trans-unit>
        <trans-unit id="d5a894573c68d878cab4cb98be562e26f9a7f0d1" translate="yes" xml:space="preserve">
          <source>Aborts the test run if one or more suites fail to compile (described earlier).</source>
          <target state="translated">Прерывает выполнение теста,если один или несколько комплектов не скомпилированы (описано выше).</target>
        </trans-unit>
        <trans-unit id="0744eff0f05c525e12f11abc8717d631608439c4" translate="yes" xml:space="preserve">
          <source>Absolute &lt;code&gt;Time&lt;/code&gt; value. The &lt;code&gt;Time&lt;/code&gt; value is interpreted as an absolute Erlang monotonic time in milliseconds.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;Time&lt;/code&gt; . Значение &lt;code&gt;Time&lt;/code&gt; интерпретируется как абсолютное монотонное время Эрланга в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="6f0553231a05faffe297bc7acf9cdaa15d3ad0d6" translate="yes" xml:space="preserve">
          <source>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">Абсолютный максимальный размер кэша не подходит (в килобайтах). Сегмент в кэше сегментов памяти не используется повторно, если его размер превышает запрошенный размер, превышающий значение этого параметра. По умолчанию &lt;code&gt;4096&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06e7393a1c9fa0746c02d1ffbcea8603bb27631f" translate="yes" xml:space="preserve">
          <source>Absolute offset.</source>
          <target state="translated">Абсолютное смещение.</target>
        </trans-unit>
        <trans-unit id="44496adc987c03d870e59213dad3144a175329ee" translate="yes" xml:space="preserve">
          <source>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Абсолютный порог усадки одноблочного носителя (в килобайтах). Когда блок, расположенный в одноблочной несущей &lt;code&gt;mseg_alloc&lt;/code&gt; , сжимается, несущая остается неизменной, если объем неиспользуемой памяти меньше этого порога, в противном случае несущая уменьшается. См. Также &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff57be685f71df6825a00bb0dd0675ff72e59819" translate="yes" xml:space="preserve">
          <source>Absolute time-out time</source>
          <target state="translated">Абсолютный тайм-аут</target>
        </trans-unit>
        <trans-unit id="87b7af24fbc7dca667aaef7cedf788bba72797a9" translate="yes" xml:space="preserve">
          <source>Abstract Data Type for SNMP Indexing</source>
          <target state="translated">Аннотация Тип данных для SNMP индексирования</target>
        </trans-unit>
        <trans-unit id="5609a156333d78829625afc9b9f892be80c713da" translate="yes" xml:space="preserve">
          <source>Abstract Erlang syntax trees.</source>
          <target state="translated">Абстрактные синтаксические деревья Эрланга.</target>
        </trans-unit>
        <trans-unit id="0fc0a26f5661ecd86fced093abdeb714aebff28c" translate="yes" xml:space="preserve">
          <source>Abstract data type for FIFO queues.</source>
          <target state="translated">Абстрактный тип данных для FIFO-очереди.</target>
        </trans-unit>
        <trans-unit id="0036b597c9166dc75f5f416f3d4f8e2976e568cd" translate="yes" xml:space="preserve">
          <source>Abstract datatype for the annotations of the Erlang Compiler.</source>
          <target state="translated">Абстрактный тип данных для аннотаций компилятора Erlang.</target>
        </trans-unit>
        <trans-unit id="60de543c8b0a2bf7a7b2b18c9b9c6e2e54182daa" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang clause.</source>
          <target state="translated">Абстрактная форма пункта Эрланга.</target>
        </trans-unit>
        <trans-unit id="d6672e8badf7c19620dd4aaaf05ad582f5d5750e" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang expression.</source>
          <target state="translated">Абстрактная форма выражения Эрланга.</target>
        </trans-unit>
        <trans-unit id="39fe847d06d62d8e80b55d37a59200693c709fd2" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang form.</source>
          <target state="translated">Абстрактная форма формы Эрланга.</target>
        </trans-unit>
        <trans-unit id="b2f998c312eeafe0281400d148af41f390922671" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang type.</source>
          <target state="translated">Абстрактная форма типа Эрланг.</target>
        </trans-unit>
        <trans-unit id="9e50abdb48c5e81f25cc8ea3044d328ca8ac2fce" translate="yes" xml:space="preserve">
          <source>Accept the connection.</source>
          <target state="translated">Примите соединение.</target>
        </trans-unit>
        <trans-unit id="632efb93ff14184018a35197a6178c2417c5bf58" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the SSL/TLS/DTLS connection.</source>
          <target state="translated">Принимает входящий запрос на подключение к прослушивающему сокету. &lt;code&gt;ListenSocket&lt;/code&gt; должен быть сокетом, возвращенным из &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; . Возвращенный сокет должен быть передан на &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; для завершения квитирования, то есть установления соединения SSL / TLS / DTLS.</target>
        </trans-unit>
        <trans-unit id="69d043ef57e7745987475e175cb8e488f0827aa5" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listening socket. &lt;code&gt;Socket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out value in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Принимает входящий запрос на подключение к прослушивающему сокету. &lt;code&gt;Socket&lt;/code&gt; должен быть сокетом, возвращенным из &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;Timeout&lt;/code&gt; указывает значение тайм-аута в миллисекундах. По умолчанию &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cebb4f984dd0627e66700aca28cb0e1a5e9b377" translate="yes" xml:space="preserve">
          <source>Accepts from the listen socket identified by the specified identification number. The identification number is retrieved with the &lt;code&gt;uds_control&lt;/code&gt; routine.</source>
          <target state="translated">Принимает от прослушивающего сокета, идентифицированного указанным идентификационным номером. Идентификационный номер получается с &lt;code&gt;uds_control&lt;/code&gt; процедуры uds_control .</target>
        </trans-unit>
        <trans-unit id="804ff6a7ca49a544473ae24cb9339afd2154136e" translate="yes" xml:space="preserve">
          <source>Access globally registered names.</source>
          <target state="translated">Доступ к глобально зарегистрированным именам.</target>
        </trans-unit>
        <trans-unit id="119dea3e192ecc9326f47133ed54d5f5ec4367c3" translate="yes" xml:space="preserve">
          <source>Access rights must be set so that all nodes in the pool have the authority to access each other.</source>
          <target state="translated">Права доступа должны быть установлены таким образом,чтобы все узлы пула имели право доступа друг к другу.</target>
        </trans-unit>
        <trans-unit id="7a783c4df63409ddf4859d4d9c63884928a701bd" translate="yes" xml:space="preserve">
          <source>Access to TCP/IP protocols.</source>
          <target state="translated">Доступ к протоколам TCP/IP.</target>
        </trans-unit>
        <trans-unit id="cb621788e34fed8e0f28301fdda0b265d5b636b7" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/17/foo would cause the server to run the script /web/17/cgi-bin/foo.</source>
          <target state="translated">Доступ к http://your.server.org/cgi-bin/17/foo заставит сервер запустить скрипт /web/17/cgi-bin/foo.</target>
        </trans-unit>
        <trans-unit id="a462746b4ce0075f7024ce8c93ee0d727108ca1e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/foo would cause the server to run the script /web/cgi-bin/foo.</source>
          <target state="translated">Доступ к http://your.server.org/cgi-bin/foo заставит сервер запустить скрипт /web/cgi-bin/foo.</target>
        </trans-unit>
        <trans-unit id="50c06117af6e8e6670291bbfd27326b9ace3849a" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/docs/ would return http://your.server.org/docs/index.html or http://your.server.org/docs/welcome.html if index.html does not exist.</source>
          <target state="translated">Доступ к http://your.server.org/docs/вернет http://your.server.org/docs/index.html или http://your.server.org/docs/welcome.html,если index.html не существует.</target>
        </trans-unit>
        <trans-unit id="55663d7fd0c514824e934bdabda94079e8fc90bd" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/image/foo.gif would refer to the file /ftp/pub/image/foo.gif.</source>
          <target state="translated">Доступ по адресу http://your.server.org/image/foo.gif осуществляется по ссылке на файл /ftp/pub/image/foo.gif.</target>
        </trans-unit>
        <trans-unit id="7455d0c1b31ee765842e7d4c484ec0f7dd272b9e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif. In an Apache-like configuration file, &lt;code&gt;Re&lt;/code&gt; is separated from &lt;code&gt;Replacement&lt;/code&gt; with one single space, and as expected backslashes do not need to be backslash escaped, the same example would become:</source>
          <target state="translated">Доступ к http://your.server.org/~bob/foo.gif будет относиться к файлу /home/bob/public/foo.gif. В конфигурационном файле, подобном Apache, &lt;code&gt;Re&lt;/code&gt; отделяется от &lt;code&gt;Replacement&lt;/code&gt; одним пробелом, и, как ожидается, обратная косая черта не требует экранирования обратной косой черты, тот же пример будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="a5376bb41fa3654f4b966a3b6b6e89c5279df85f" translate="yes" xml:space="preserve">
          <source>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)</source>
          <target state="translated">AccessMod:all_keys(ActivityId,Opaque,Tab,LockKind)</target>
        </trans-unit>
        <trans-unit id="6f94df94a3e7a36d86e327efa5167226380b0374" translate="yes" xml:space="preserve">
          <source>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:delete(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="b5445c5aafa2ff9673bac795581de2bbc41c0c0f" translate="yes" xml:space="preserve">
          <source>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind)</source>
          <target state="translated">AccessMod:delete_object(ActivityId,Opaque,Tab,RecXS,LockKind)</target>
        </trans-unit>
        <trans-unit id="3e7316c12d79f02736aee472f82ff47536afd350" translate="yes" xml:space="preserve">
          <source>AccessMod:first(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:первый (ActivityId,непрозрачный,вкладка)</target>
        </trans-unit>
        <trans-unit id="b3f5ad115c23452c24775618b9441d204cbd0d17" translate="yes" xml:space="preserve">
          <source>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_match_object(ActivityId,Opaque,Tab,Pattern,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="64b8364a718a756d7a35ce5b28a17687b5f7875e" translate="yes" xml:space="preserve">
          <source>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_read(ActivityId,Opaque,Tab,SecondaryKey,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="405ecfd3752c77ca520244aedede4b5587dbac66" translate="yes" xml:space="preserve">
          <source>AccessMod:last(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:последний(ActivityId,непрозрачный,вкладка)</target>
        </trans-unit>
        <trans-unit id="0fe0be60df449ead6d34747d5036ed4f5deeb071" translate="yes" xml:space="preserve">
          <source>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)</source>
          <target state="translated">AccessMod:замок (ActivityId,Opaque,LockItem,LockKind)</target>
        </trans-unit>
        <trans-unit id="7f89b76e80a1cb03dd0d79dad619cfd7ed1b75a0" translate="yes" xml:space="preserve">
          <source>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind)</source>
          <target state="translated">AccessMod:match_object(ActivityId,Opaque,Tab,Pattern,LockKind)</target>
        </trans-unit>
        <trans-unit id="2eb39b70c8643684acb852d676bca64e66ecf08b" translate="yes" xml:space="preserve">
          <source>AccessMod:next(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:next(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="377e160f1491a996cf09b6412ddf1f19b01e4596" translate="yes" xml:space="preserve">
          <source>AccessMod:prev(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:prev(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="3240408ebba47649936190643d81115a2facdad7" translate="yes" xml:space="preserve">
          <source>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:read(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="f4ae75249d02d33c6b19d3db539b11ddf2e8c3b7" translate="yes" xml:space="preserve">
          <source>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)</source>
          <target state="translated">AccessMod:table_info(ActivityId,Opaque,Tab,InfoItem)</target>
        </trans-unit>
        <trans-unit id="593b1df980f5bc3e0025a26bd60fd36b84ab2a86" translate="yes" xml:space="preserve">
          <source>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)</source>
          <target state="translated">AccessMod:запись (ActivityId,Opaque,Tab,Rec,LockKind)</target>
        </trans-unit>
        <trans-unit id="38bb0b3771b790d4a4246ea93a50f0538d3b9ae5" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;Mnesia&lt;/code&gt; tables from a QLC list comprehension must always be done within a transaction. Consider the following function:</source>
          <target state="translated">Доступ к таблицам &lt;code&gt;Mnesia&lt;/code&gt; из списка QLC всегда должен выполняться в рамках транзакции. Рассмотрим следующую функцию:</target>
        </trans-unit>
        <trans-unit id="d4e0ceeb0457db320ec7c5e806ad2aa7f79465dd" translate="yes" xml:space="preserve">
          <source>Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size:</source>
          <target state="translated">Доступ к записи,выходящей за пределы последнего установленного значения,также возвращает значение по умолчанию,если массив не имеет фиксированного размера:</target>
        </trans-unit>
        <trans-unit id="555bba9fd6c14d06717b8dc43b3cc1f3a8debed5" translate="yes" xml:space="preserve">
          <source>Accessing an unset entry returns default value:</source>
          <target state="translated">Доступ к невыполненной записи возвращает значение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="436be26b911d05b439e447f05501826f189bbbef" translate="yes" xml:space="preserve">
          <source>According to good practices certificates should not use IP-addresses as &quot;server names&quot;. It would be very surprising if this happen outside a closed network.</source>
          <target state="translated">В соответствии с надлежащей практикой сертификаты не должны использовать IP-адреса в качестве &quot;имен серверов&quot;.Было бы очень удивительно,если бы это происходило за пределами закрытой сети.</target>
        </trans-unit>
        <trans-unit id="89a4478d0cf104e90423519324b8b69d771bbee7" translate="yes" xml:space="preserve">
          <source>According to the myth, using a tail-recursive function that builds a list in reverse followed by a call to &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; is faster than a body-recursive function that builds the list in correct order; the reason being that body-recursive functions use more memory than tail-recursive functions.</source>
          <target state="translated">Согласно мифу, использование хвостовой рекурсивной функции, которая создает список в обратном порядке, с последующим вызовом &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; быстрее, чем основная рекурсивная функция, которая строит список в правильном порядке; Причина в том, что функции с основной рекурсией используют больше памяти, чем функции с хвостовой рекурсией.</target>
        </trans-unit>
        <trans-unit id="2c1de79f36acb95726c8b2c2f40931be25c53188" translate="yes" xml:space="preserve">
          <source>Accounting</source>
          <target state="translated">Accounting</target>
        </trans-unit>
        <trans-unit id="576eaeceb1da93e9cd8653f97cabbf793c67007b" translate="yes" xml:space="preserve">
          <source>Accounting AVP Table</source>
          <target state="translated">Бухгалтерская таблица АВП</target>
        </trans-unit>
        <trans-unit id="76507b1aa8142b5faffaa0f07c625ec43966a2b9" translate="yes" xml:space="preserve">
          <source>Accounting AVPs</source>
          <target state="translated">АВП по бухгалтерскому учету</target>
        </trans-unit>
        <trans-unit id="9a7ff18e07e31b5c000920070a2994c9d40115bb" translate="yes" xml:space="preserve">
          <source>Accounting Application Extension and Requirements</source>
          <target state="translated">Продление срока действия и требования к бухгалтерским приложениям</target>
        </trans-unit>
        <trans-unit id="e635c0e384e30717aefe63c449ad41cb13b32539" translate="yes" xml:space="preserve">
          <source>Accounting Command Codes</source>
          <target state="translated">Командные коды бухгалтерского учёта</target>
        </trans-unit>
        <trans-unit id="50de3db981430abf69687c31bfddbc582f239b78" translate="yes" xml:space="preserve">
          <source>Accounting Records</source>
          <target state="translated">Бухгалтерская документация</target>
        </trans-unit>
        <trans-unit id="44b909aba948aa304a039b3c325904ad3054b180" translate="yes" xml:space="preserve">
          <source>Accounting Session State Machine</source>
          <target state="translated">Бухгалтерская сессия Государственная машина</target>
        </trans-unit>
        <trans-unit id="c15004aaef4f7a17d065e02f132efa0a95238fb5" translate="yes" xml:space="preserve">
          <source>Accounting is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">Бухгалтерский учет является обязанностью пользователя:диаметр не реализует эту государственную машину.</target>
        </trans-unit>
        <trans-unit id="3abb791315e4021643390d032dcd3ee861202b30" translate="yes" xml:space="preserve">
          <source>Accounting-Answer</source>
          <target state="translated">Accounting-Answer</target>
        </trans-unit>
        <trans-unit id="348fbc285b20d73c4251ffc831b8fc2daa3046c1" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP</source>
          <target state="translated">Учет-Реальное время-Требуется AVP</target>
        </trans-unit>
        <trans-unit id="4913676d8f98f760d1dc436d2423796cf2783306" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP Values</source>
          <target state="translated">Учет-Реальное время-Приобретенные значения AVP</target>
        </trans-unit>
        <trans-unit id="a41e3ac9cf5023d32cd91b4a3e716042b6c367b5" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Number AVP</source>
          <target state="translated">Учетная запись-учетная запись-номер AVP</target>
        </trans-unit>
        <trans-unit id="b804c4b652a1521f5cb9135277fefe013043b5f6" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP</source>
          <target state="translated">Учетная запись-видеозапись-AVP</target>
        </trans-unit>
        <trans-unit id="8df79aebdffebcd5564a4906eb6116d78fd976e9" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP Values</source>
          <target state="translated">Учетная запись-Тип записи-Значения AVP</target>
        </trans-unit>
        <trans-unit id="3f4954249bb9c6c0d9946303733718179dac9afc" translate="yes" xml:space="preserve">
          <source>Accounting-Request</source>
          <target state="translated">Accounting-Request</target>
        </trans-unit>
        <trans-unit id="cb2f33108011b0c4743b447ccd4a9acfb53d2777" translate="yes" xml:space="preserve">
          <source>Accounting-Sub-Session-Id AVP</source>
          <target state="translated">Бухгалтерия-Суб-сессия-Ид AVP</target>
        </trans-unit>
        <trans-unit id="356f92ff6ca6eed8d6a653c61fd409eb10ae68df" translate="yes" xml:space="preserve">
          <source>Accounting-related messages and AVPs are defined in provided dictionaries. Their proper use is the user's responsibility.</source>
          <target state="translated">Сообщения,связанные с учетными записями и AVP,определяются в предоставляемых словарях.Ответственность за их правильное использование лежит на пользователе.</target>
        </trans-unit>
        <trans-unit id="4b31db96c0a841f9a7113ac5bbc52a214e1829fa" translate="yes" xml:space="preserve">
          <source>Acct-Application-Id AVP</source>
          <target state="translated">Акт-приложение-Ид AVP</target>
        </trans-unit>
        <trans-unit id="4cabe3c0597d0d6af37709b22cdb0a59a5dae54e" translate="yes" xml:space="preserve">
          <source>Acct-Interim-Interval AVP</source>
          <target state="translated">Acct Interim Interval AVP</target>
        </trans-unit>
        <trans-unit id="1e0b1bf1afd755a9ceed94d413ee8713ddf31cc4" translate="yes" xml:space="preserve">
          <source>Acct-Multi-Session-Id AVP</source>
          <target state="translated">Акт-Мульти-Сессия-Ид AVP</target>
        </trans-unit>
        <trans-unit id="73a3b6a3e03bc80ba04f6bde167f6434da42cc10" translate="yes" xml:space="preserve">
          <source>Acct-Session-Id AVP</source>
          <target state="translated">АВП-аккаунт-сессия</target>
        </trans-unit>
        <trans-unit id="1a968060d9b2a6b964d729cfbd1eea55cfdc2c19" translate="yes" xml:space="preserve">
          <source>Accumulated waiting time for this lock. This could be greater than actual wall clock time, it is accumulated for all threads. Trylock conflicts does not accumulate time.</source>
          <target state="translated">Накопленное время ожидания этого замка.Это может быть больше,чем фактическое время настенных часов,оно накапливается для всех нитей.Конфликты трилока не накапливают время.</target>
        </trans-unit>
        <trans-unit id="d9ecd9efddc0ef5836c8bbbde646a0d66732f097" translate="yes" xml:space="preserve">
          <source>Accumulates cover results over multiple tests. See section &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; in the Users's Guide.</source>
          <target state="translated">Накапливает результаты покрытия за несколько тестов. См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="be2701277b8bc3bbce61a03a361606bf878d1187" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Точность и точность &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="875e7dcdc327d43caf0dcdf9d04b310d14d9feaf" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Точность и точность &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58eae709361b11b3ca7bd3fc358b5d94391cf26b" translate="yes" xml:space="preserve">
          <source>Acknowledges the start of the port.</source>
          <target state="translated">Подтверждает начало работы порта.</target>
        </trans-unit>
        <trans-unit id="788233b34a130f2756fb1eaafa64431bb5c3d2da" translate="yes" xml:space="preserve">
          <source>Acknowledgment of a successful TLS handshake. &lt;code&gt;Ref&lt;/code&gt; is the reference() received in the &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; message in response to which the reply is sent. A transport must exit if a handshake is not successful.</source>
          <target state="translated">Подтверждение успешного установления связи TLS. &lt;code&gt;Ref&lt;/code&gt; - это ссылка (), полученная в сообщении &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; в ответ на которое отправляется ответ. Транспорт должен выйти, если рукопожатие не удалось.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
