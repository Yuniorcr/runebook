<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="c68be6d33361ec0e77716005c64c0f636bd81f1e" translate="yes" xml:space="preserve">
          <source>Normally a trusted certificate, but it can also be a path-validation error that can be discovered while constructing the input to this function and that is to be run through the &lt;code&gt;verify_fun&lt;/code&gt;. Examples are &lt;code&gt;unknown_ca&lt;/code&gt; and &lt;code&gt;selfsigned_peer.&lt;/code&gt;</source>
          <target state="translated">Обычно это доверенный сертификат, но это также может быть ошибка проверки пути, которая может быть обнаружена при построении входных данных для этой функции и должна выполняться через &lt;code&gt;verify_fun&lt;/code&gt; . Примеры: &lt;code&gt;unknown_ca&lt;/code&gt; и &lt;code&gt;selfsigned_peer.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c1e2b2f12271535c195bd263adbd772fd1b1450" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added</source>
          <target state="translated">Обычно открытый ключ RSA,DSA или ECDSA,но можно добавить обработку других открытых ключей.</target>
        </trans-unit>
        <trans-unit id="32e8583c2f35a0fb6147ddcbc88cc5b16ce06fba" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">Обычно это RSA,DSA или ECDSA открытый ключ,но можно добавить обработку других открытых ключей.</target>
        </trans-unit>
        <trans-unit id="5a323154df5db7c6023a4765a91c3d178bc3620d" translate="yes" xml:space="preserve">
          <source>Normally an allocator creates a &quot;main multiblock carrier&quot;. Main multiblock carriers are never deallocated. The size of the main multiblock carrier is determined by the value of parameter &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обычно распределитель создает &amp;laquo;основную многоблочную несущую&amp;raquo;. Основные мультиблочные носители никогда не освобождаются. Размер основного мультиблочного носителя определяется значением параметра &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b4c50780b89a61508f82bc073504b8cf437882c" translate="yes" xml:space="preserve">
          <source>Normally in the range &lt;code&gt;-15..-8 | 8..15&lt;/code&gt;.</source>
          <target state="translated">Обычно в диапазоне &lt;code&gt;-15..-8 | 8..15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3591546de23ffebac17f3c960ad1cc664b2e7e" translate="yes" xml:space="preserve">
          <source>Normally it is the programmer's responsibility to free each Erlang term that has been returned from any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions. However, as many of the functions that build new Erlang terms in fact share objects with other existing terms, it can be difficult for the programmer to maintain pointers to all such terms to free them individually.</source>
          <target state="translated">Обычно ответственность за освобождение каждого термина Erlang, возвращенного любой из функций &lt;code&gt;Erl_Interface&lt;/code&gt; ,лежит на программисте . Однако, поскольку многие функции, которые создают новые термины Erlang, на самом деле имеют общие объекты с другими существующими терминами, программисту может быть сложно поддерживать указатели на все такие термины, чтобы освободить их по отдельности.</target>
        </trans-unit>
        <trans-unit id="1516500c60371d958d26c4174d5a863989b039fb" translate="yes" xml:space="preserve">
          <source>Normally the compiler treats calls to &lt;code&gt;is_record/2&lt;/code&gt; especially. It emits code to verify that &lt;code&gt;Term&lt;/code&gt; is a tuple, that its first element is &lt;code&gt;RecordTag&lt;/code&gt;, and that the size is correct. However, if &lt;code&gt;RecordTag&lt;/code&gt; is not a literal atom, the BIF &lt;code&gt;is_record/2&lt;/code&gt; is called instead and the size of the tuple is not verified.</source>
          <target state="translated">Обычно компилятор особенно обрабатывает вызовы &lt;code&gt;is_record/2&lt;/code&gt; . Он генерирует код, чтобы убедиться, что &lt;code&gt;Term&lt;/code&gt; является кортежем, что его первым элементом является &lt;code&gt;RecordTag&lt;/code&gt; , и что размер правильный. Однако, если &lt;code&gt;RecordTag&lt;/code&gt; не является буквальным атомом, вместо этого &lt;code&gt;is_record/2&lt;/code&gt; BIF is_record / 2 , и размер кортежа не проверяется.</target>
        </trans-unit>
        <trans-unit id="ca1a7de4987b858f3cc368eec0c0c2caaad58778" translate="yes" xml:space="preserve">
          <source>Normally the compiler verifies that the module name given in the source code is the same as the base name of the output file and refuses to generate an output file if there is a mismatch. If you have a good reason (or other reason) for having a module name unrelated to the name of the output file, this option disables that verification (there will not even be a warning if there is a mismatch).</source>
          <target state="translated">Обычно компилятор проверяет,что имя модуля,указанное в исходном коде,совпадает с базовым именем выходного файла,и в случае несоответствия отказывается генерировать выходной файл.Если у вас есть веская причина (или другая причина),по которой имя модуля не связано с именем выходного файла,эта опция отключает эту верификацию (при наличии несовпадения даже не будет предупреждения).</target>
        </trans-unit>
        <trans-unit id="c85cefd516f432dd52d61776ad47ad9e932cefa9" translate="yes" xml:space="preserve">
          <source>Normally the top directory of an application is located in library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt; or in a directory referred to by environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. At startup, when the initial code path is computed, the code server also looks for archive files in these directories and possibly adds &lt;code&gt;ebin&lt;/code&gt; directories in archives to the code path. The code path then contains paths to directories that look like &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; or &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">Обычно верхний каталог приложения находится в каталоге библиотеки &lt;code&gt;$OTPROOT/lib&lt;/code&gt; или в каталоге, на который указывает переменная среды &lt;code&gt;ERL_LIBS&lt;/code&gt; . При запуске, когда вычисляется начальный путь кода, сервер кода также ищет архивные файлы в этих каталогах и, возможно, добавляет &lt;code&gt;ebin&lt;/code&gt; в архивах к пути кода. Затем кодовый путь содержит пути к каталогам, которые выглядят как &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; или &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16dc8854601f473350bd4444afad1c3e95d0bfe6" translate="yes" xml:space="preserve">
          <source>Normally these are minimal stub implementations that throw an exception. But they can also be used as fallback implementations for functions that do not have native implemenations on some architectures.</source>
          <target state="translated">Обычно это минимальные реализации шлейфов,которые бросают исключение.Но они также могут использоваться в качестве резервных реализаций для функций,которые не имеют собственных реализаций на некоторых архитектурах.</target>
        </trans-unit>
        <trans-unit id="d7e199a9abb107c5708b3c551b3f4ac7d6bc7e25" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;Loaded&lt;/code&gt; is the absolute filename &lt;code&gt;Filename&lt;/code&gt; from which the code is obtained. If the module is preloaded (see &lt;code&gt;script(4)&lt;/code&gt;), &lt;code&gt;Loaded==preloaded&lt;/code&gt;. If the module is Cover-compiled (see &lt;code&gt;cover(3)&lt;/code&gt;), &lt;code&gt;Loaded==cover_compiled&lt;/code&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;Loaded&lt;/code&gt; - это абсолютное имя файла &lt;code&gt;Filename&lt;/code&gt; , из которого получается код. Если модуль предварительно загружен (см. &lt;code&gt;script(4)&lt;/code&gt; ), &lt;code&gt;Loaded==preloaded&lt;/code&gt; . Если модуль скомпилирован с помощью обложки (см. &lt;code&gt;cover(3)&lt;/code&gt; ), &lt;code&gt;Loaded==cover_compiled&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5203fe540eb93014569c65ea374e32f208fcdb8" translate="yes" xml:space="preserve">
          <source>Normally, after a pending message has been received, the request is not resent (since a pending message is an indication that the request has been received). But since the reply (to the request) can be lost, this behaviour has its values.</source>
          <target state="translated">Обычно после получения отложенного сообщения запрос не отправляется повторно (поскольку отложенное сообщение является признаком того,что запрос получен).Но поскольку ответ (на запрос)может быть утерян,такое поведение имеет свои значения.</target>
        </trans-unit>
        <trans-unit id="b537284cd04df03d36bf92033e8259f158494ca4" translate="yes" xml:space="preserve">
          <source>Normally, connections are established automatically when another node is referenced. This functionality can be disabled by setting Kernel configuration parameter &lt;code&gt;dist_auto_connect&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt;, see &lt;code&gt;kernel(6)&lt;/code&gt;. In this case, connections must be established explicitly by calling &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обычно соединения устанавливаются автоматически при обращении к другому узлу. Эту функциональность можно отключить, установив для параметра конфигурации ядра &lt;code&gt;dist_auto_connect&lt;/code&gt; значение &lt;code&gt;never&lt;/code&gt; , см. Kernel &lt;code&gt;kernel(6)&lt;/code&gt; . В этом случае соединения должны быть установлены явно путем вызова &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637694f595e135bf986d734041974495ca2f7d71" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;code&gt;/etc/ssh&lt;/code&gt; directory is only readable by root.</source>
          <target state="translated">Обычно каталог &lt;code&gt;/etc/ssh&lt;/code&gt; доступен для чтения только root.</target>
        </trans-unit>
        <trans-unit id="c133a4bf588437e7a024274a632985a8eb26b1b7" translate="yes" xml:space="preserve">
          <source>Normally, the functions described above behave exactly as shown, but they are free to perform other actions. For example, a get-request may have side effects such as setting some other variable, perhaps a global &lt;code&gt;lastAccessed&lt;/code&gt; variable.</source>
          <target state="translated">Обычно описанные выше функции ведут себя точно так, как показано, но они могут выполнять другие действия. Например, запрос на получение может иметь побочные эффекты, такие как установка какой-либо другой переменной, возможно, глобальной переменной &lt;code&gt;lastAccessed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="544ca2481d30ca25eb88bc4478419d207c6b42f3" translate="yes" xml:space="preserve">
          <source>Normally, there is no need to worry about the speed of &lt;code&gt;length/1&lt;/code&gt;, because it is efficiently implemented in C. In time-critical code, you might want to avoid it if the input list could potentially be very long.</source>
          <target state="translated">Обычно нет необходимости беспокоиться о скорости &lt;code&gt;length/1&lt;/code&gt; , потому что она эффективно реализована в C. В критичном ко времени коде вы можете захотеть избежать этого, если список ввода потенциально может быть очень длинным.</target>
        </trans-unit>
        <trans-unit id="432c6c8cb64925afd6f974d52af838a844075bba" translate="yes" xml:space="preserve">
          <source>Normally, when an Erlang process sends to a socket, the driver tries to send the data immediately. If that fails, the driver uses any means available to queue up the message to be sent whenever the operating system says it can handle it. Setting &lt;code&gt;{delay_send, true}&lt;/code&gt; makes &lt;strong&gt;all&lt;/strong&gt; messages queue up. The messages sent to the network are then larger but fewer. The option affects the scheduling of send requests versus Erlang processes instead of changing any real property of the socket. The option is implementation-specific. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Обычно, когда процесс Erlang отправляет данные в сокет, драйвер пытается отправить данные немедленно. Если это не удается, драйвер использует любые доступные средства для постановки сообщения в очередь для отправки всякий раз, когда операционная система говорит, что может его обработать. Установка &lt;code&gt;{delay_send, true}&lt;/code&gt; ставит &lt;strong&gt;все&lt;/strong&gt; сообщения в очередь. Сообщения, отправляемые в сеть, становятся больше, но их меньше. Этот параметр влияет на планирование запросов на отправку по сравнению с процессами Erlang вместо изменения каких-либо реальных свойств сокета. Вариант зависит от реализации. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fad0923dba8395d1d335b96e476819a3a071dc5" translate="yes" xml:space="preserve">
          <source>Normative References</source>
          <target state="translated">Нормативные ссылки</target>
        </trans-unit>
        <trans-unit id="4c829414eaf27118bfedf26c7e8237c300423db1" translate="yes" xml:space="preserve">
          <source>Not a &lt;code&gt;pid()&lt;/code&gt;.</source>
          <target state="translated">Не &lt;code&gt;pid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deed9da173527db14150ff0b085131feec28ae66" translate="yes" xml:space="preserve">
          <source>Not all fields of this map has to be present. The flags field can be used to test for some of the fields. For example &lt;code&gt;broadaddr&lt;/code&gt; will only be present if the &lt;code&gt;broadcast&lt;/code&gt; flag is present in flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c737921363d7d8bbbfc2bf38000b57e386aed1b1" translate="yes" xml:space="preserve">
          <source>Not all functions are provided on all platforms. In particular, the &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; functions are not provided on Windows.</source>
          <target state="translated">Не все функции доступны на всех платформах. В частности, в Windows не предусмотрены функции &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50eeaa129a18f1db0ba0b1a0b68ec33d5a9d6b03" translate="yes" xml:space="preserve">
          <source>Not all options are valid on all platforms. That is, even if &quot;we&quot; support an option, that does not mean that the underlying OS does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60564ddfb74e83034e43211b6dc56c962f055f4" translate="yes" xml:space="preserve">
          <source>Not all systems send signals. For details on valid string values, see RFC 4254, Section 6.10</source>
          <target state="translated">Не все системы посылают сигналы.Подробнее о действительных значениях строк см.RFC 4254,раздел 6.10.</target>
        </trans-unit>
        <trans-unit id="a834a9b315fc2a330e09ba52fb9c66fcf454a31e" translate="yes" xml:space="preserve">
          <source>Not being able to control the application remotely</source>
          <target state="translated">Не имея возможности управлять приложением удаленно</target>
        </trans-unit>
        <trans-unit id="1a46fcc227b8efe8fe76d1f3917346701207d128" translate="yes" xml:space="preserve">
          <source>Not built-in</source>
          <target state="translated">Не встроенный</target>
        </trans-unit>
        <trans-unit id="e5c26cb1806bfcc16aba23e2bcd43b6fab4a7dce" translate="yes" xml:space="preserve">
          <source>Not enough memory to create the port.</source>
          <target state="translated">Недостаточно памяти для создания порта.</target>
        </trans-unit>
        <trans-unit id="5a93ba71c6009e894f071984d5a041fabb7da94e" translate="yes" xml:space="preserve">
          <source>Not enough space left to write the file.</source>
          <target state="translated">Недостаточно места,чтобы записать файл.</target>
        </trans-unit>
        <trans-unit id="b498326e15a92ae0d8b8c9b12f4c1b41ff6d4998" translate="yes" xml:space="preserve">
          <source>Not equal to</source>
          <target state="translated">Не равный</target>
        </trans-unit>
        <trans-unit id="46885249352a064243a6dddeac62ab075a4dd8a5" translate="yes" xml:space="preserve">
          <source>Not recommended, as the machine will possibly be inaccessible to interactive users.</source>
          <target state="translated">Не рекомендуется,так как машина,возможно,будет недоступна для интерактивных пользователей.</target>
        </trans-unit>
        <trans-unit id="943fa3c1c3bedd251cb678cfcff592882249becf" translate="yes" xml:space="preserve">
          <source>Not recommended; use &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Не рекомендуется; используйте вместо этого &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a35d63cc7db198d75edb76a9f80fbc617cd6daa6" translate="yes" xml:space="preserve">
          <source>Not unexpectedly, we see that &lt;code&gt;file:write/2&lt;/code&gt; was called from &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; and &lt;code&gt;foo:create_file_slow/2&lt;/code&gt;. The number of calls in each case as well as the used time are also just confirms the previous results.</source>
          <target state="translated">Неудивительно, что мы видим, что &lt;code&gt;file:write/2&lt;/code&gt; был вызван из &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; и &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; . Количество звонков в каждом случае, а также использованное время также подтверждают предыдущие результаты.</target>
        </trans-unit>
        <trans-unit id="844262b1792d0ef92bc2117e202d50d8b150ea0d" translate="yes" xml:space="preserve">
          <source>Not using the code loading generations (or any other code duplication) means that &lt;code&gt;trace_pattern&lt;/code&gt; must at some point write to the active beam code in order for running processes to reach the staged breakpoints structures. This can be done with one single atomic write operation per instrumented function. The beam instruction words are however read with normal memory loads and not through the atomic API. The only guarantee we need is that the written instruction word is seen as atomic. Either fully written or not at all. This is true for word aligned write operation on all hardware architectures we use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2bc95e45520449726b41dddaa10d65e1171c4f" translate="yes" xml:space="preserve">
          <source>Not yet supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fb48271e25bdfecded1918413e5015fa92ec99a7" translate="yes" xml:space="preserve">
          <source>Note again that a successfull decode only returns a partially initiated message.</source>
          <target state="translated">Обратите внимание еще раз,что успешное декодирование возвращает только частично инициированное сообщение.</target>
        </trans-unit>
        <trans-unit id="8bb5fcd3ca24d41d35ec2f21eaba5915f96c6ec6" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;Options&lt;/code&gt; argument comes from the &lt;code&gt;options&lt;/code&gt; config option of the mib-storage config option, and is passed on as is.</source>
          <target state="translated">Также обратите внимание, что аргумент &lt;code&gt;Options&lt;/code&gt; поступает из &lt;code&gt;options&lt;/code&gt; конфигурации options параметра конфигурации mib-storage и передается как есть.</target>
        </trans-unit>
        <trans-unit id="0627636f71c6f80361b94f0198da347d52ca866f" translate="yes" xml:space="preserve">
          <source>Note also that the shared group leader (&lt;code&gt;SharedGL&lt;/code&gt;) must never be terminated by the user, only by Common Test. Group leader processes for parallel test case groups (&lt;code&gt;OtherGLs&lt;/code&gt;) may however be terminated in post_end_per_group hook functions.</source>
          <target state="translated">Также обратите внимание, что лидер совместно используемой группы ( &lt;code&gt;SharedGL&lt;/code&gt; ) никогда не должен завершаться пользователем, только с помощью общего теста. Однако процессы лидера группы для параллельных групп тестовых примеров ( &lt;code&gt;OtherGLs&lt;/code&gt; ) могут завершаться с помощью функций ловушки post_end_per_group.</target>
        </trans-unit>
        <trans-unit id="edc2e031b8dd55503b20741805cebfb2cf07a730" translate="yes" xml:space="preserve">
          <source>Note cleanup time. When storing a note in the note store, each note is given lifetime. Every &lt;code&gt;timeout&lt;/code&gt; the note_store process performs a GC to remove the expired note's. Time in milli-seconds.</source>
          <target state="translated">Обратите внимание на время очистки. При хранении заметки в хранилище заметок каждой заметке дается время жизни. Каждый &lt;code&gt;timeout&lt;/code&gt; -аут процесс note_store выполняет сборку мусора, чтобы удалить просроченную заметку. Время в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="0728c4c2bab748430bb05050c43d78407cdbf77b" translate="yes" xml:space="preserve">
          <source>Note of caution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e15564a2d085965b6a647a62b080ce57e8687b" translate="yes" xml:space="preserve">
          <source>Note support for legacy configuration file with Apache syntax is dropped in OTP-23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5960d916e9578d7d801b0cab9fba678951306b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;LIMIT_MATCH&lt;/code&gt; and &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; can only reduce the value of the limits set by the caller, not increase them.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;LIMIT_MATCH&lt;/code&gt; и &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; могут только уменьшить значение ограничений, установленных вызывающей стороной, но не увеличивать их.</target>
        </trans-unit>
        <trans-unit id="5fcd20ceeac028edcb91c3032d79c7d19a743557" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;daemon_info/1&lt;/code&gt; and &lt;code&gt;daemon_info/2&lt;/code&gt; returns different types due to compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24e50ca0ad0e8aeae5b135428467a7fb92766a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;verify_fun&lt;/code&gt; needs to be written in a different form than the corresponding SSL/TLS option, since funs are not accepted on the command line.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;verify_fun&lt;/code&gt; необходимо записать в другой форме, чем соответствующая опция SSL / TLS, поскольку funs не принимаются в командной строке.</target>
        </trans-unit>
        <trans-unit id="52b662fe1f129e8596062fb70fec226b6c4a68bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;verify_fun&lt;/code&gt; needs to be written in a different form than the corresponding TLS option, since funs are not accepted on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1c85c3f2e3a52e04f26f9459fd07fac45960dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;watchdog&lt;/code&gt;, &lt;code&gt;peer&lt;/code&gt;, &lt;code&gt;apps&lt;/code&gt;, &lt;code&gt;caps&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; entries depend on connectivity with the peer and may not be present. Note also that the &lt;code&gt;statistics&lt;/code&gt; entry presents values accumulated during the lifetime of the transport configuration.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;watchdog&lt;/code&gt; , &lt;code&gt;peer&lt;/code&gt; , &lt;code&gt;apps&lt;/code&gt; , &lt;code&gt;caps&lt;/code&gt; и записи &lt;code&gt;port&lt;/code&gt; зависят от связи с одноранговым узлом и могут отсутствовать. Также обратите внимание, что запись &lt;code&gt;statistics&lt;/code&gt; представляет значения, накопленные за время существования транспортной конфигурации.</target>
        </trans-unit>
        <trans-unit id="336af6e83620751fb885cf9732b59c5d61916d15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;{error,encode}&lt;/code&gt; is the only return value which guarantees that the request has &lt;strong&gt;not&lt;/strong&gt; been sent over the transport connection.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;{error,encode}&lt;/code&gt; - единственное возвращаемое значение, которое гарантирует, что запрос &lt;strong&gt;не&lt;/strong&gt; был отправлен через транспортное соединение.</target>
        </trans-unit>
        <trans-unit id="c43786df6d68a9130e86553a3fb94cd475618c7f" translate="yes" xml:space="preserve">
          <source>Note that EdDSA passhrases (Curves 25519 and 448) are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fbe442617bf7481c90ae87dcf9bb86893f3220" translate="yes" xml:space="preserve">
          <source>Note that Erlang shell specific functions and control sequences like for example &lt;code&gt;h().&lt;/code&gt; are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fdecc142de3ad70dcbabaed28cc8ece32529ae" translate="yes" xml:space="preserve">
          <source>Note that RFC 3588 did not allow 5xxx result codes in answers setting the E-bit, while RFC 6733 does. This is a potential interoperability problem since the Diameter protocol version has not changed.</source>
          <target state="translated">Обратите внимание,что RFC 3588 не разрешал коды результата 5xxx в ответах,задающих E-bit,в то время как RFC 6733 разрешает.Это потенциальная проблема совместимости,так как версия протокола Diameter не изменилась.</target>
        </trans-unit>
        <trans-unit id="383d8ab46c4dd3dcb7dacf32d96619c30112c096" translate="yes" xml:space="preserve">
          <source>Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of &lt;code&gt;N&lt;/code&gt;: at a rate of &lt;code&gt;R&lt;/code&gt; requests per second, an &lt;code&gt;N&lt;/code&gt;-bit counter traverses all of its values in &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; minutes, so the bound is &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что RFC 6733 требует, чтобы идентификаторы End-to-End оставались уникальными в течение периода не менее 4 минут, и что это и скорость вызовов устанавливают нижнюю границу для соответствующих значений &lt;code&gt;N&lt;/code&gt; : со скоростью &lt;code&gt;R&lt;/code&gt; запросов в секунду, &lt;code&gt;N&lt;/code&gt; -битных счетчик пересекает все его значения в &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; минут, так что граница &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab161900c8191797fce6b824ca72c3fe1be8d39b" translate="yes" xml:space="preserve">
          <source>Note that TLS-1.3 and TLS-1.2 cipher suites are not overlapping sets of cipher suites so to support both these versions cipher suites from both versions need to be included. If supporting TLS-1.3 versions prior to TLS-1.2 can not be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d954d0938e64e5c37a1b11f9fbf14279ee90b30d" translate="yes" xml:space="preserve">
          <source>Note that \0dd is always an octal code, and that \8 and \9 are the literal characters &quot;8&quot; and &quot;9&quot;.</source>
          <target state="translated">Обратите внимание,что \0dd-это всегда восьмеричный код,а \8 и \9-буквенные символы &quot;8&quot; и &quot;9&quot;.</target>
        </trans-unit>
        <trans-unit id="fa00a5e7155faa8238baf7626fd63ae2adafb209" translate="yes" xml:space="preserve">
          <source>Note that a &lt;strong&gt;state enter call&lt;/strong&gt;&lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this actually is not a &lt;strong&gt;state change&lt;/strong&gt;. In this case &lt;code&gt;OldState =:= State&lt;/code&gt;, which cannot happen for a subsequent state change, but will happen when repeating the &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8f4a584e7baae9c7b73d493c112b4faac49187" translate="yes" xml:space="preserve">
          <source>Note that a dictionary module should have a unique name so as not collide with existing modules in the system.</source>
          <target state="translated">Обратите внимание,что модуль словаря должен иметь уникальное имя,чтобы не сталкиваться с существующими модулями в системе.</target>
        </trans-unit>
        <trans-unit id="7d48dfa81ed35ed91309a0c63bf84e4d12b8db94" translate="yes" xml:space="preserve">
          <source>Note that a dictionary's &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, together with the &lt;code&gt;outdir&lt;/code&gt; option, determine the output paths when the &lt;code&gt;return&lt;/code&gt; option is not specified. The &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of a literal input dictionary defaults to &lt;code&gt;dictionary&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; словаря вместе с параметром &lt;code&gt;outdir&lt;/code&gt; определяют пути вывода, если параметр &lt;code&gt;return&lt;/code&gt; не указан. &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; буквального входного словаря по умолчанию для &lt;code&gt;dictionary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="592ecd079ddc2c5dbec2876bde4efe18192a7501" translate="yes" xml:space="preserve">
          <source>Note that a distributed node will fail to start if epmd is not running.</source>
          <target state="translated">Обратите внимание,что распределенный узел не запустится,если не запущен epmd.</target>
        </trans-unit>
        <trans-unit id="210dee4c712f6038124cea11c85e7ab317eb49aa" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; event for a given peer corresponds to multiple &lt;code&gt;peer_up/3&lt;/code&gt; or &lt;code&gt;peer_down/3&lt;/code&gt; callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications.</source>
          <target state="translated">Обратите внимание, что одно событие &lt;code&gt;up&lt;/code&gt; или &lt;code&gt;down&lt;/code&gt; для данного однорангового &lt;code&gt;peer_up/3&lt;/code&gt; соответствует множеству обратных вызовов peer_up / 3 или &lt;code&gt;peer_down/3&lt;/code&gt; , по одному для каждого приложения Diameter, согласованного во время обмена возможностями. То есть событие сообщает о возможности соединения с одноранговым узлом в целом, в то время как обратные вызовы сообщают о возможности соединения в отношении отдельных приложений Diameter.</target>
        </trans-unit>
        <trans-unit id="87238ebabfbb3a6373dc0cd859835703ac206a8a" translate="yes" xml:space="preserve">
          <source>Note that a state enter call &lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this formally is not a state change. In this case &lt;code&gt;OldState&lt;/code&gt; will be the same as &lt;code&gt;State&lt;/code&gt;, which can not happen for a subsequent state change, but will happen when repeating the state enter call.</source>
          <target state="translated">Обратите внимание, что вызов входа в состояние &lt;strong&gt;будет&lt;/strong&gt; выполнен прямо перед входом в исходное состояние, даже если формально это не изменение состояния. В этом случае &lt;code&gt;OldState&lt;/code&gt; будет таким же, как &lt;code&gt;State&lt;/code&gt; , что не может произойти при последующем изменении состояния, но произойдет при повторении вызова ввода состояния.</target>
        </trans-unit>
        <trans-unit id="1a1ae5ee8fe086b1e864731f91a5db626649b898" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb520f2054c75e0b1b39831bcf49afdb1c0b3e3f" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case). So either immediately call the function or &lt;code&gt;&lt;a href=&quot;socket#cancel-2&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea408404d235688202589e612b275a8ce277c9d" translate="yes" xml:space="preserve">
          <source>Note that all processing is done in the context of the calling process. A transport module could call this function via one of the &lt;code&gt;spawn&lt;/code&gt; functions (e.g. &lt;code&gt;spawn_opt&lt;/code&gt;). See also &lt;code&gt;receive_message/4,5&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что вся обработка выполняется в контексте вызывающего процесса. Транспортный модуль может вызвать эту функцию через одну из функций &lt;code&gt;spawn&lt;/code&gt; (например, &lt;code&gt;spawn_opt&lt;/code&gt; ). См. Также &lt;code&gt;receive_message/4,5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3db41f10bff721f3ee02192c83ee3f08a54b12b" translate="yes" xml:space="preserve">
          <source>Note that although guard expressions should only yield boolean values, this function does not guarantee that &lt;code&gt;Term&lt;/code&gt; is either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01d1482d475dcf2740463e55c6c430cd948d4e9" translate="yes" xml:space="preserve">
          <source>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.</source>
          <target state="translated">Обратите внимание,что SMIv2 MIB может импортировать SMIv1 MIB и наоборот.</target>
        </trans-unit>
        <trans-unit id="9b685cbc242545fbad15153c417da3182cac4fef" translate="yes" xml:space="preserve">
          <source>Note that an abstract atom may have several literal representations, and that the representation yielded by this function is not fixed; e.g., &lt;code&gt;atom_lit(c_atom(&quot;a\012b&quot;))&lt;/code&gt; could yield the string &lt;code&gt;&quot;\'a\\nb\'&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f6954c77f955dafa6a2e123d05e96d272275df" translate="yes" xml:space="preserve">
          <source>Note that an alias-name is only unique within the mib, so when loading several mib's into a manager, there might be several instances of the same aliasname.</source>
          <target state="translated">Обратите внимание,что псевдоним уникален только внутри mib,поэтому при загрузке нескольких mib в менеджер может быть несколько экземпляров одного и того же псевдонима.</target>
        </trans-unit>
        <trans-unit id="ffe0be9b4d38daeed36a33562bc4da5606bc0b2f" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well when you have for example a status call as in section &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d8f63bf6bc16034f55c5cb547506223b7f3f16" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well with when you have for example a status call as in &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">Обратите внимание, что тайм-аут события не работает, когда у вас есть, например, статусный вызов, как в &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; , или обработка неизвестных событий, поскольку все виды событий отменяют тайм-аут события.</target>
        </trans-unit>
        <trans-unit id="def0f5ad0a0ace41622689a594950eb3fe32da96" translate="yes" xml:space="preserve">
          <source>Note that an inherited AVP that sets the V flag takes its Vendor-Id from either &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inheriting dictionary or &lt;code&gt;@vendor&lt;/code&gt; in the inherited dictionary. In particular, &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inherited dictionary is ignored. Inheriting from a dictionary that specifies the required &lt;code&gt;@vendor&lt;/code&gt; is equivalent to using &lt;code&gt;@avp_vendor_id&lt;/code&gt; with a copy of the dictionary's definitions but the former makes for easier reuse.</source>
          <target state="translated">Обратите внимание, что унаследованный AVP, который устанавливает флаг V, берет свой идентификатор поставщика либо из &lt;code&gt;@avp_vendor_id&lt;/code&gt; в наследующем словаре, либо из &lt;code&gt;@vendor&lt;/code&gt; в унаследованном словаре. В частности, &lt;code&gt;@avp_vendor_id&lt;/code&gt; в унаследованном словаре. Наследование от словаря, в котором указан требуемый &lt;code&gt;@vendor&lt;/code&gt; , эквивалентно использованию &lt;code&gt;@avp_vendor_id&lt;/code&gt; с копией определений словаря, но первое упрощает повторное использование.</target>
        </trans-unit>
        <trans-unit id="6d33800347145579293148a2f5b8e31e3a2764de" translate="yes" xml:space="preserve">
          <source>Note that arguments for macros cannot be complex expressions, because the arguments are split on &lt;code&gt;,&lt;/code&gt;. For example, the following would not work because &lt;strong&gt;beam_makeops&lt;/strong&gt; would split the expression into two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5995dd05307d17cf1cf0275ae54c1c965044890" translate="yes" xml:space="preserve">
          <source>Note that both lists in &lt;code&gt;cipher&lt;/code&gt; has been changed to the provided value (&lt;code&gt;'aes128-ctr'&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что оба списка в &lt;code&gt;cipher&lt;/code&gt; были изменены на указанное значение ( &lt;code&gt;'aes128-ctr'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a24670d7b6d01336c8695b5d4d57a391c44adcb2" translate="yes" xml:space="preserve">
          <source>Note that capabilities for an outgoing hello can be passed directly to &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e251f553696cbbe8af62f9b6e14b96ffcbc62108" translate="yes" xml:space="preserve">
          <source>Note that clauses following a default action will be ignored.</source>
          <target state="translated">Обратите внимание,что пункты,следующие за действием по умолчанию,будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="0160a9b8ce02f625812816b1ccc97166a7bb4956" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random and master_secret are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">Обратите внимание,что значения client_random,server_random и master_secret влияют на безопасность соединения.Значимые атомы,не указанные выше,-это имена опций ssl.</target>
        </trans-unit>
        <trans-unit id="f5dd2f74718152ce40902beac42e0c7a6f30ccfb" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random, master_secret and keylog are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bf6b7b0630a07fa672109442d6b02fb72a8793" translate="yes" xml:space="preserve">
          <source>Note that doing the primary log level filtering through a filter and not through the level is quite a lot more expensive, so make sure to test that your system can handle the extra load before you enable it on a production node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fbc0b27f1c4b9334d7d0f187cdb9b5cc6eedece" translate="yes" xml:space="preserve">
          <source>Note that e.g. the result of &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; represents any and all of `x\ny'', `x\12y'', `x\012y'' and `x\^Jy\''; see &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что, например, результат &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; представляет все и все &amp;laquo;x \ ny&amp;raquo;, &amp;laquo;x \ 12y&amp;raquo;, &amp;laquo;x \ 012y&amp;raquo; и &amp;laquo;x \ ^ Jy \&amp;raquo; '; см. &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba188de7ea4673245bb93e421ced2f5246f6549c" translate="yes" xml:space="preserve">
          <source>Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.</source>
          <target state="translated">Обратите внимание,что каждый кортеж передает одно или несколько значений AVP.Ошибкой является указание дублирующих кортежей.</target>
        </trans-unit>
        <trans-unit id="edc604b194978efcbdba0cbc4b89b369a9c99a82" translate="yes" xml:space="preserve">
          <source>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported with ecdsa and ecdh.</source>
          <target state="translated">Обратите внимание,что ec_gf2m-это не строго алгоритм открытого ключа,а ограничение на то,какие кривые поддерживаются с помощью ecdsa и ecdh.</target>
        </trans-unit>
        <trans-unit id="29cd43d95778b2d115dbf308b03c62ae1c0160c0" translate="yes" xml:space="preserve">
          <source>Note that even if this function returns some &lt;code&gt;Tail&lt;/code&gt; that is not &lt;code&gt;none&lt;/code&gt;, the type of &lt;code&gt;Tail&lt;/code&gt; can be &lt;code&gt;nil&lt;/code&gt;, if the tail has been given explicitly, and the list skeleton has not been compacted (see &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что даже если эта функция возвращает некоторый &lt;code&gt;Tail&lt;/code&gt; , который не является &lt;code&gt;none&lt;/code&gt; , тип &lt;code&gt;Tail&lt;/code&gt; может быть равен &lt;code&gt;nil&lt;/code&gt; , если хвост был задан явно и скелет списка не был &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt; (см. Compact_list / 1 ).</target>
        </trans-unit>
        <trans-unit id="192c5999ce9ab89a2a2dbe3ec7c900d7ee1db0a4" translate="yes" xml:space="preserve">
          <source>Note that file and line have to be added in the metadata by the caller of &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log/3&lt;/a&gt;&lt;/code&gt; as otherwise Logger will not know from where it was called. The file and line number are automatically added if you use the &lt;code&gt;?LOG_ERROR&lt;/code&gt; macros in &lt;code&gt;kernel/include/logger.hrl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c389355e70f459658e087541ff06cacc40c70758" translate="yes" xml:space="preserve">
          <source>Note that for e.g. &lt;code&gt;protocol&lt;/code&gt; = &lt;code&gt;tcp&lt;/code&gt;, most implementations doing a close does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b99d2d0f80623c57fbaf51f6886234e7e4b951d" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;EngineId&lt;/code&gt; has the value &lt;code&gt;discovery&lt;/code&gt;, the agent cannot send &lt;code&gt;inform&lt;/code&gt; messages to that manager until it has performed the &lt;strong&gt;discovery&lt;/strong&gt; process with that manager.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;EngineId&lt;/code&gt; имеет значение &lt;code&gt;discovery&lt;/code&gt; , агент не может отправлять &lt;code&gt;inform&lt;/code&gt; сообщения этому диспетчеру, пока он не выполнит процесс &lt;strong&gt;обнаружения&lt;/strong&gt; с этим диспетчером.</target>
        </trans-unit>
        <trans-unit id="55bac8de272758448fe7d117efd8941f423d23e9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;udp&lt;/code&gt; is used, the same transport process could be used for several connections. This could make upgrading impossible.</source>
          <target state="translated">Обратите внимание, что если используется &lt;code&gt;udp&lt;/code&gt; , один и тот же транспортный процесс может использоваться для нескольких подключений. Это может сделать обновление невозможным.</target>
        </trans-unit>
        <trans-unit id="18ab9ea99f0d2ed9aaa93df42d7129d992c9c108" translate="yes" xml:space="preserve">
          <source>Note that if a length (&lt;code&gt;&amp;gt; 0&lt;/code&gt;) is specified, and only part of that amount of data is available, the function will return with that data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait for the remaining data, it must immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed4a9e62154b96609da080c17aec27f4dd9246b0" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;port&lt;/code&gt; is given and if &lt;code&gt;taddress&lt;/code&gt; does not contain a port number, the default value is used.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;port&lt;/code&gt; не указан и &lt;code&gt;taddress&lt;/code&gt; не содержит номера порта, используется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c6b057ff98ba4785947d02f48c8fb42e16a4c39b" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;tdomain&lt;/code&gt; is given, the default value, &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, is used.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;tdomain&lt;/code&gt; не указан, используется значение по умолчанию, &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de8909d667626be185465024dfa8ebbd745359a8" translate="yes" xml:space="preserve">
          <source>Note that if not all the data was sent, the function will return with the remaining data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait to be able to send the rest, it should immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c484d69e82a05974946be309952b5bc3d7f4c76d" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;gen_statem&lt;/code&gt; is started through &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt;, this callback will never be called. Since this callback is not optional it can in that case be implemented as:</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;gen_statem&lt;/code&gt; запускается через &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt; , этот обратный вызов никогда не будет вызван. Поскольку этот обратный вызов не является необязательным, в этом случае он может быть реализован как:</target>
        </trans-unit>
        <trans-unit id="9c87f385bbe639188084f38ba17c84501fe670ca" translate="yes" xml:space="preserve">
          <source>Note that if the Version argument is &lt;code&gt;dynamic&lt;/code&gt;, the decoder should try to figure out the actual version from the message itself and then use the proper decoder, e.g. version 1.</source>
          <target state="translated">Обратите внимание, что если аргумент Version является &lt;code&gt;dynamic&lt;/code&gt; , декодер должен попытаться определить фактическую версию из самого сообщения, а затем использовать правильный декодер, например версию 1.</target>
        </trans-unit>
        <trans-unit id="12f48a08b82dbcdbabc6e426452d1ee74de3e1a7" translate="yes" xml:space="preserve">
          <source>Note that if the body is small all data may be delivered in only one chunk and then the callback will be called with {last, Data::binary(), undefined} without getting called with &lt;code&gt;{first, Data::binary()}&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если тело маленькое, все данные могут быть доставлены только в одном фрагменте, а затем обратный вызов будет вызываться с помощью {last, Data :: binary (), undefined} без вызова с помощью &lt;code&gt;{first, Data::binary()}&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="edf8bcd8d88dd948c2709c3f285acd4c03e67af3" translate="yes" xml:space="preserve">
          <source>Note that if the fun returns &lt;code&gt;unknown&lt;/code&gt; for an extension marked as critical, validation will fail.</source>
          <target state="translated">Обратите внимание: если для расширения, помеченного как критическое, возвращается значение &lt;code&gt;unknown&lt;/code&gt; , проверка не удастся.</target>
        </trans-unit>
        <trans-unit id="9d0a053447ab79088b7ef6197ebb840d173587a7" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;warnings&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the option &lt;code&gt;verbosity&lt;/code&gt; is &lt;code&gt;silence&lt;/code&gt;, warning messages will still be shown.</source>
          <target state="translated">Обратите внимание, что если для параметра &lt;code&gt;warnings&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , а для параметра &lt;code&gt;verbosity&lt;/code&gt; - &lt;code&gt;silence&lt;/code&gt; , предупреждающие сообщения все равно будут отображаться.</target>
        </trans-unit>
        <trans-unit id="5dec77651df10446f2452013b0e653832ee5a101" translate="yes" xml:space="preserve">
          <source>Note that if the reply is segmented (split into several smaller messages; segments), then some extra info, segment number and an indication if all segments of a reply has been received or not, is also included in the &lt;code&gt;UserReply&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если ответ сегментирован (разбит на несколько сообщений меньшего размера; сегменты), то в &lt;code&gt;UserReply&lt;/code&gt; также включается некоторая дополнительная информация, номер сегмента и указание, были ли получены все сегменты ответа .</target>
        </trans-unit>
        <trans-unit id="3e84fec2f22c7d49771617b7f4326149f8363362" translate="yes" xml:space="preserve">
          <source>Note that in Erlang, a receive-expression must have at least one clause if no timeout part is specified.</source>
          <target state="translated">Обратите внимание,что в Erlang,выражение получения должно иметь,по крайней мере,один пункт,если не указана часть таймаута.</target>
        </trans-unit>
        <trans-unit id="08a96fc716918fe5871d98094662c927e7804b46" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_in_daemon_option&quot;&gt;tcpip_tunnel_in&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629d6084a6f0543f14df18dbc3535aef38711dc0" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_out_daemon_option&quot;&gt;tcpip_tunnel_out&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cef48befcd401dd112e3b47e9b84cfba29baac7" translate="yes" xml:space="preserve">
          <source>Note that in most implementations of TCP, doing a &lt;code&gt;close&lt;/code&gt; does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side. If you want to guarantee delivery of the data to the recipient there are two common ways to achieve this.</source>
          <target state="translated">Обратите внимание, что в большинстве реализаций TCP выполнение &lt;code&gt;close&lt;/code&gt; не гарантирует, что отправленные данные будут доставлены получателю до того, как закрытие будет обнаружено на удаленной стороне. Если вы хотите гарантировать доставку данных получателю, есть два распространенных способа добиться этого.</target>
        </trans-unit>
        <trans-unit id="b9a4adbac3d627161edb16842c38f7517677ffd5" translate="yes" xml:space="preserve">
          <source>Note that in order for reltool to sort application versions and thereby be able to select the latest, it is required that the version id for the application consits of integers and dots only, for example &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2.0&lt;/code&gt; or &lt;code&gt;3.17.1&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что для того, чтобы reltool мог отсортировать версии приложения и, таким образом, иметь возможность выбрать самую последнюю, необходимо, чтобы идентификатор версии для приложения состоял только из целых чисел и точек, например &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2.0&lt;/code&gt; или &lt;code&gt;3.17.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e044f396b1f21f65746f1535663887993d7e14da" translate="yes" xml:space="preserve">
          <source>Note that integers in the list always represent code points regardless of &lt;code&gt;InEncoding&lt;/code&gt; passed. If &lt;code&gt;InEncoding latin1&lt;/code&gt; is passed, only code points &amp;lt; 256 are allowed; otherwise, all valid unicode code points are allowed.</source>
          <target state="translated">Обратите внимание, что целые числа в списке всегда представляют собой кодовые точки независимо от &lt;code&gt;InEncoding&lt;/code&gt; . Если &lt;code&gt;InEncoding latin1&lt;/code&gt; передан, разрешены только кодовые точки &amp;lt;256; в противном случае разрешены все допустимые точки кода Unicode.</target>
        </trans-unit>
        <trans-unit id="6b71fac57eccdc841417bdc84d942c5ed4df483a" translate="yes" xml:space="preserve">
          <source>Note that it also blocks other operations than just &lt;code&gt;rpc:block_call()&lt;/code&gt; operations, so use it with care.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da41371a24cf2bfa4ed67187ea540808d0a4589a" translate="yes" xml:space="preserve">
          <source>Note that it is easiest to write this kind of recursive generator using a help function, like the &lt;code&gt;lazy_gen/1&lt;/code&gt; function above. It can also be written using a recursive fun, if you prefer to not clutter your function namespace and are comfortable with writing that kind of code.</source>
          <target state="translated">Обратите внимание, что такой рекурсивный генератор проще всего написать с помощью функции справки, такой как &lt;code&gt;lazy_gen/1&lt;/code&gt; выше. Его также можно написать с помощью рекурсивного развлечения, если вы предпочитаете не загромождать пространство имен функций и вам удобно писать такой код.</target>
        </trans-unit>
        <trans-unit id="b32d52e1a01dca7a3f60f88baf54204f13cb5c4b" translate="yes" xml:space="preserve">
          <source>Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event.</source>
          <target state="translated">Обратите внимание,что отменить этот тайм-аут невозможно и не нужно,так как он автоматически отменяется любым другим событием.</target>
        </trans-unit>
        <trans-unit id="3d2bc208d4ef85523a8bb2be7f7fe6957054fa30" translate="yes" xml:space="preserve">
          <source>Note that it is possible for this function to filter out targets (but &lt;strong&gt;not&lt;/strong&gt; to add its own) by returning an updated &lt;code&gt;Targets&lt;/code&gt; list (&lt;code&gt;NewTargets&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что эта функция может отфильтровывать цели (но &lt;strong&gt;не&lt;/strong&gt; добавлять свои собственные), возвращая обновленный список &lt;code&gt;Targets&lt;/code&gt; ( &lt;code&gt;NewTargets&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e68901639556f6e842921bc4c6aab5754c944701" translate="yes" xml:space="preserve">
          <source>Note that it is up to the user to ensure that correct code to execute via &lt;code&gt;erpc&lt;/code&gt; is available on the involved nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e083fd2ab9cd6e5f1715c135b9ad0cd6133523" translate="yes" xml:space="preserve">
          <source>Note that it seldom needs to be started explicitly since it is automatically started by the functions that need a running server.</source>
          <target state="translated">Обратите внимание,что его редко нужно запускать явно,так как он автоматически запускается функциями,которым нужен запущенный сервер.</target>
        </trans-unit>
        <trans-unit id="bf76532ed69f19d320e28943c7ea7794c8213294" translate="yes" xml:space="preserve">
          <source>Note that its implementation dependant (and also dependent on mib-storage is used) if a backup is possible.</source>
          <target state="translated">Обратите внимание,что его реализация зависит (а также зависит от mib-хранилища),если резервное копирование возможно.</target>
        </trans-unit>
        <trans-unit id="1fddaac0c2eba362c90fcf63bcdd71ddcd1d0713" translate="yes" xml:space="preserve">
          <source>Note that just because we have a documented and described option, it does &lt;strong&gt;not&lt;/strong&gt; mean that the OS supports it. So its recommended that the user reads the platform specific documentation for the option used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec78a15c5217c92c95a49b94462adac13df7646" translate="yes" xml:space="preserve">
          <source>Note that new types may be added in the future, so the caller must be prepared to handle unknown types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef50791d64ed0c0b90d9621e25834b3006be609" translate="yes" xml:space="preserve">
          <source>Note that no checking is done whether &lt;code&gt;Name&lt;/code&gt; is a reserved attribute name such as &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;: it is assumed that the attribute is &quot;wild&quot;.</source>
          <target state="translated">Обратите внимание, что не проверяется, является ли &lt;code&gt;Name&lt;/code&gt; зарезервированным именем атрибута, таким как &lt;code&gt;module&lt;/code&gt; или &lt;code&gt;export&lt;/code&gt; : предполагается, что атрибут является &amp;laquo;диким&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="da792409efb1d957a763465a0f90eb01b22a65de" translate="yes" xml:space="preserve">
          <source>Note that no global trace patterns are affected by this function.</source>
          <target state="translated">Обратите внимание,что эта функция не влияет на глобальные шаблоны трасс.</target>
        </trans-unit>
        <trans-unit id="c9dbd761e7b3ccf030e5d2634d121608a5fc566a" translate="yes" xml:space="preserve">
          <source>Note that not all individual &lt;code&gt;Option&lt;/code&gt;s are checked when the spawn request is sent. Some &lt;code&gt;Option&lt;/code&gt;s can only be checked on reception of the request. Therefore an invalid option does &lt;strong&gt;not&lt;/strong&gt; cause a &lt;code&gt;badarg&lt;/code&gt; exception, but will cause the spawn operation to fail with an error reason of &lt;code&gt;badopt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1046cde1e5db61beca0efc3f9616a4641ffd20" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:connect_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7f42298d81e647ec75e32ec8f0a6e4e85efbf7" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:listen_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb7d234e889fecf34a0a8cc44508f7dd715d1f4" translate="yes" xml:space="preserve">
          <source>Note that only one transport per kind for each transport domain can be configured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef85014f2633aed4a8852aa3b53ebbaf3622c48" translate="yes" xml:space="preserve">
          <source>Note that only the exec channel is closed after the one-time execution. The connection is still up and can handle previously opened channels. It is also possible to open a new channel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1047c06dfd85c28e322de4ae968c83146c41303a" translate="yes" xml:space="preserve">
          <source>Note that processes that execute configuration functions or test cases are never included in &lt;code&gt;TestProcs&lt;/code&gt;. It is therefore safe to use post configuration hook functions (such as post_end_per_suite, post_end_per_group, post_end_per_testcase) to terminate all processes in &lt;code&gt;TestProcs&lt;/code&gt; that have the current group leader process as its group leader.</source>
          <target state="translated">Обратите внимание, что процессы, которые выполняют функции конфигурации или тестовые примеры, никогда не включаются в &lt;code&gt;TestProcs&lt;/code&gt; . Поэтому безопасно использовать функции обработчика пост-конфигурации (такие как post_end_per_suite, post_end_per_group, post_end_per_testcase) для завершения всех процессов в &lt;code&gt;TestProcs&lt;/code&gt; , которые имеют текущий процесс лидера группы в качестве лидера группы.</target>
        </trans-unit>
        <trans-unit id="83100a56e14e247fd18ef628ef7f4b9f51213734" translate="yes" xml:space="preserve">
          <source>Note that raw filenames &lt;strong&gt;not&lt;/strong&gt; necessarily are encoded the same way as on the OS level.</source>
          <target state="translated">Обратите внимание, что необработанные имена файлов &lt;strong&gt;не&lt;/strong&gt; обязательно кодируются так же, как на уровне ОС.</target>
        </trans-unit>
        <trans-unit id="82914e4f408f26df4d5bb211a9e507c3fd9f2819" translate="yes" xml:space="preserve">
          <source>Note that some curves are disabled if FIPS is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb3e885aec0adb2e32b31326d16ceb9409b7c9f" translate="yes" xml:space="preserve">
          <source>Note that spaces are preserved and that no point (.) is needed at the end - that was required by the default evaluator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15df3770c93a08f3b7628f1b3671253fafbc1cf9" translate="yes" xml:space="preserve">
          <source>Note that special characters in the text (&amp;lt;, &amp;gt; and &amp;amp;) will be escaped by Common Test before the text is printed to the log file.</source>
          <target state="translated">Обратите внимание, что специальные символы в тексте (&amp;lt;,&amp;gt; и &amp;amp;) будут экранированы Common Test перед тем, как текст будет напечатан в файле журнала.</target>
        </trans-unit>
        <trans-unit id="863f3323e07ccde5b57c1b225a8cb6abcf3f22bb" translate="yes" xml:space="preserve">
          <source>Note that the &quot;super&quot; in super alignment and the &quot;super&quot; in super carrier has nothing to do with each other. We could have choosen another naming to avoid confusion, such as &quot;meta&quot; carrier or &quot;giant&quot; aligment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27bd01e0ed18a111b98018e635bbdb5be686872" translate="yes" xml:space="preserve">
          <source>Note that the (new) extended transport entries (including &lt;code&gt;Kind&lt;/code&gt; and &lt;code&gt;Opts&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; specify port-info as they ignore any value specified by &lt;code&gt;intAgentUDPPort&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7563ce9bbb8cb2de2be12e2c300f540e095441b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;RecordName&lt;/code&gt; and &lt;code&gt;Fields&lt;/code&gt; arguments my not be used in all implementations (they are actually only needed for mnesia-based implementations).</source>
          <target state="translated">Обратите внимание, что аргументы &lt;code&gt;RecordName&lt;/code&gt; и &lt;code&gt;Fields&lt;/code&gt; могут использоваться не во всех реализациях (на самом деле они необходимы только для реализаций на основе мнезии).</target>
        </trans-unit>
        <trans-unit id="79647059410cdcc68796c813c0ea00f1df08febf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;erl_parse&lt;/code&gt; representation is identical for &quot;&lt;code&gt;FunctionType&lt;/code&gt;&quot; and &quot;&lt;code&gt;fun(FunctionType)&lt;/code&gt;&quot;.</source>
          <target state="translated">Обратите внимание, что представление &lt;code&gt;erl_parse&lt;/code&gt; идентично для &amp;laquo; &lt;code&gt;FunctionType&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;fun(FunctionType)&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="77e8b76dc02c9cee773231d4002d964ee921a983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;sect&lt;/strong&gt; curves are GF2m (characteristic two) curves and are only supported if the underlying OpenSSL has support for them. See also &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Следует отметить , что &lt;strong&gt;секта&lt;/strong&gt; кривые GF2m (характерные две кривые) и поддерживается только если основной OpenSSL имеет поддержку для них. См. Также &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e846e6d7b0cd63a03e739f368b1e0f75bf3068da" translate="yes" xml:space="preserve">
          <source>Note that the AVP in question can be defined in an inherited dictionary in order to introduce additional values to an enumeration otherwise defined in another dictionary.</source>
          <target state="translated">Обратите внимание,что данный AVP может быть определен в унаследованном словаре для того,чтобы ввести дополнительные значения в перечисление,которое иначе определено в другом словаре.</target>
        </trans-unit>
        <trans-unit id="545f0e872a991ae7619c44fcd6c8013504712aeb" translate="yes" xml:space="preserve">
          <source>Note that the CCF of this AVP is not the same as in RFC 3588.</source>
          <target state="translated">Обратите внимание,что CCF этой AVP отличается от RFC 3588.</target>
        </trans-unit>
        <trans-unit id="3839e34d035de6fcffb30bf27e41d5c5ddbeeb10" translate="yes" xml:space="preserve">
          <source>Note that the actual definition of (some of) these records depend on the megaco protocol version used. For instance, the &lt;code&gt;'TransactionReply'&lt;/code&gt; record has two more fields in version 3, so a simple erlang type definition cannot be made here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8a5b787d8524598e83ff6424d17b88b62138a1" translate="yes" xml:space="preserve">
          <source>Note that the actual supported dss_digest_type depends on the underlying crypto library. In OpenSSL version &amp;gt;= 1.0.1 the listed digest are supported, while in 1.0.0 only sha, sha224 and sha256 are supported. In version 0.9.8 only sha is supported.</source>
          <target state="translated">Обратите внимание, что фактически поддерживаемый dss_digest_type зависит от базовой криптографической библиотеки. В версии OpenSSL&amp;gt; = 1.0.1 поддерживается перечисленный дайджест, а в 1.0.0 поддерживаются только sha, sha224 и sha256. В версии 0.9.8 поддерживается только sha.</target>
        </trans-unit>
        <trans-unit id="3b70bc0ac9ae266a36a7ccaa90cb46529ab3a596" translate="yes" xml:space="preserve">
          <source>Note that the algorithms in the file &lt;code&gt;ex2.config&lt;/code&gt; is not yet applied. They will be when we start ssh:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7c24f4a4a2d3cbb7e5f46db8ca5bbd93271e2c" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdefbbcdb7a6e85db537e1b6266c9775e69d082" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca45c6542e0b81fb0f24e8247dda5f01d933e7b" translate="yes" xml:space="preserve">
          <source>Note that the appended algorithm is removed from its original place and then appended to the same list.</source>
          <target state="translated">Обратите внимание,что добавленный алгоритм удаляется с исходного места,а затем добавляется в тот же список.</target>
        </trans-unit>
        <trans-unit id="3ccb116cfa36059b115c940833292db4f44f844b" translate="yes" xml:space="preserve">
          <source>Note that the buffer pointed to by the &lt;code&gt;outbuf&lt;/code&gt; argument must be large enough if a non &lt;code&gt;NULL&lt;/code&gt; value is passed as &lt;code&gt;outbuf&lt;/code&gt;. You typically want to call &lt;code&gt;ei_decode_iodata()&lt;/code&gt; twice. First with a non &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; argument and a &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;outbuf&lt;/code&gt; argument in order to determine the size of the buffer needed, and then once again in order to do the actual decoding. Note that the integer pointed to by &lt;code&gt;index&lt;/code&gt; will be updated by the call determining the size as well, so you need to reset it before the second call doing the actual decoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f612c010562004f09536ba4c9211c91bf97b929" translate="yes" xml:space="preserve">
          <source>Note that the category argument is not required in order to only specify the importance of a printout. Example:</source>
          <target state="translated">Обратите внимание,что аргумент категории не требуется для того,чтобы указать только важность распечатки.Пример:</target>
        </trans-unit>
        <trans-unit id="4b7df81861af684495c97c5fff7559eaf0915d2f" translate="yes" xml:space="preserve">
          <source>Note that the client is free to use any order and to exclude methods.</source>
          <target state="translated">Обратите внимание,что клиент может использовать любой заказ и исключать методы.</target>
        </trans-unit>
        <trans-unit id="468edd7f0dc67514b910bd2116ac92cf52f20c09" translate="yes" xml:space="preserve">
          <source>Note that the command specified with the &lt;code&gt;-rsh&lt;/code&gt; flag is treated as a file name which may contain spaces. It is thus not possible to include any command line options. The remote node will be launched as &lt;code&gt;&quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ...&lt;/code&gt;, so the &lt;code&gt;erl&lt;/code&gt; command must be found in the path on the remote host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035d18f56820efe86cdac35e4891682c6e3af7b9" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; will fail.</source>
          <target state="translated">Обратите внимание, что компилятор может оптимизировать атомы. Например, компилятор перепишет &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; в &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; . Если это выражение является единственным упоминанием атома &lt;code&gt;some_atom&lt;/code&gt; в содержащем модуле, атом не будет создан при загрузке модуля, и последующий вызов &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="f826da285ddceeccbdbefeb9bfa7b16ed554783f" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; will fail.</source>
          <target state="translated">Обратите внимание, что компилятор может оптимизировать атомы. Например, компилятор перепишет &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; в &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; . Если это выражение является единственным упоминанием атома &lt;code&gt;some_atom&lt;/code&gt; в содержащем модуле, атом не будет создан при загрузке модуля, и последующий вызов &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="b82f239fea0a2dc9f48ac7fd1ebc1ab0b5051a56" translate="yes" xml:space="preserve">
          <source>Note that the data extracted from the imported (loaded) mibs are stored partly by the mib-server and partly by the symbolic-store server. See the default mib-server data module, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; for details.</source>
          <target state="translated">Обратите внимание, что данные, извлеченные из импортированных (загруженных) mib-файлов, частично хранятся на mib-сервере и частично на сервере символьного хранилища. Подробнее см. Модуль данных mib-сервера по умолчанию, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bf74d56bb97406e9b99c3e9e52d5dbf134b453d" translate="yes" xml:space="preserve">
          <source>Note that the events &lt;code&gt;$s | $S&lt;/code&gt;, &lt;code&gt;l | $L&lt;/code&gt; and &lt;code&gt;$z | $Z&lt;/code&gt; has nothing to do with the timers using the same characters.</source>
          <target state="translated">Обратите внимание, что события &lt;code&gt;$s | $S&lt;/code&gt; , &lt;code&gt;l | $L&lt;/code&gt; и &lt;code&gt;$z | $Z&lt;/code&gt; имеет ничего общего с таймерами, использующими одни и те же символы.</target>
        </trans-unit>
        <trans-unit id="42629d78e6fdce7f2ed90c950f63dbfb4e3b847a" translate="yes" xml:space="preserve">
          <source>Note that the existing &lt;code&gt;.beam&lt;/code&gt; file must contain &lt;strong&gt;abstract code&lt;/strong&gt;, i.e. it must have been compiled with the &lt;code&gt;debug_info&lt;/code&gt; option. If not, the error reason &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; is returned. If the abstract code is encrypted, and no key is available for decrypting it, the error reason &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; is returned.</source>
          <target state="translated">Обратите внимание, что существующий файл &lt;code&gt;.beam&lt;/code&gt; должен содержать &lt;strong&gt;абстрактный код&lt;/strong&gt; , т.е. он должен быть скомпилирован с параметром &lt;code&gt;debug_info&lt;/code&gt; . В противном случае возвращается причина ошибки &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; . Если абстрактный код зашифрован, а ключ для его расшифровки недоступен &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; причина ошибки {encrypted_abstract_code, BeamFile} .</target>
        </trans-unit>
        <trans-unit id="efa3ec631430748847eae6fa5201d4a2accae7a7" translate="yes" xml:space="preserve">
          <source>Note that the first two instruction have three fragments, while the other two only have two fragments. Here are the fragments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a18b13a51422254edcdb84073c354c33a88853b" translate="yes" xml:space="preserve">
          <source>Note that the following will always be loaded:</source>
          <target state="translated">Обратите внимание,что всегда будет загружено следующее:</target>
        </trans-unit>
        <trans-unit id="d1a2e58d441f9e2f474d803ab6a32dc6712ae978" translate="yes" xml:space="preserve">
          <source>Note that the function does not check if this entry already exists.</source>
          <target state="translated">Обратите внимание,что функция не проверяет,существует ли уже эта запись.</target>
        </trans-unit>
        <trans-unit id="279bdf4d0a207f6c87ecb0b4e0489436649191bf" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they can not be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">Обратите внимание,что сгенерированные сертификаты и ключи не обеспечивают формально правильного PKIX-трастового цепочки и не могут быть использованы для достижения реальной безопасности.Данная функция предоставляется только для тестовых целей.</target>
        </trans-unit>
        <trans-unit id="078ffae6e673ee69ef0d8a166daaaedfa933f1dd" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they cannot be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6ba71f76cfedfe0e85aa82b7676692388cd2df" translate="yes" xml:space="preserve">
          <source>Note that the internal data that the &lt;code&gt;StateEnc&lt;/code&gt; and &lt;code&gt;StateDec&lt;/code&gt; references are destructivly updated by the calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt;. This is to gain time in the calls of the nifs interfacing the cryptolib. In a loop where the state is saved in the loop's state, it also saves one update of the loop state per crypto operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02818bfeb97510589873cb15d812dd13537919d3" translate="yes" xml:space="preserve">
          <source>Note that the internal database is (re-)initiated during the compilation, meaning any previously collected coverage data for the module will be lost.</source>
          <target state="translated">Обратите внимание,что в процессе компиляции происходит (пере)инициализация внутренней базы данных,т.е.любые ранее собранные данные о покрытии для модуля будут потеряны.</target>
        </trans-unit>
        <trans-unit id="cd70be69f8094d7d21e00a3313e50198d0e46168" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpa_net_if&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">Обратите внимание, что фильтр сетевого интерфейса - это то, что используется реализацией сетевого интерфейса, предоставляемой приложением ( &lt;code&gt;snmpa_net_if&lt;/code&gt; ). Фильтр по умолчанию принимает все сообщения.</target>
        </trans-unit>
        <trans-unit id="ec89ab3b5094ea790ba1c908f83fb43e535fef72" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpm_net_if&lt;/code&gt; and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">Обратите внимание, что фильтр сетевого интерфейса - это то, что используется реализацией сетевого интерфейса, предоставляемой приложением ( &lt;code&gt;snmpm_net_if&lt;/code&gt; и &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; ). Фильтр по умолчанию принимает все сообщения.</target>
        </trans-unit>
        <trans-unit id="34cd017ef347f58960dd48f7604233f91388b9db" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the agent in this way is to add the agent related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что единственный способ запустить агент таким образом - добавить конфигурацию, связанную с агентом, после запуска приложения (например, она не может быть частью обычной конфигурации приложения; sys.config). Это делается путем вызова: &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81acf13e164a6ca93c0ecb3350e2a756f1a26bc4" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the manager in this way is to add the manager related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что единственный способ запустить менеджер таким образом - это добавить конфигурацию, связанную с менеджером, после запуска приложения (например, она не может быть частью обычной конфигурации приложения; sys.config). Это делается путем вызова: &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1baccf1828d7692350ac5f909a060eecbece59" translate="yes" xml:space="preserve">
          <source>Note that the order of the tuples in the resulting list is undefined and may change at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cb3c0cb2baba7b63c67e88c6cd13cca1a7e679" translate="yes" xml:space="preserve">
          <source>Note that the order that things are printed have changed, and also I added a reverse-dns lookup of the IP address. This will not print as nicely when using a single line formatter, however you can also use a report_cb fun with 2 arguments where the second argument is the formatting options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a75f4183db30bfbd690aebb40a7591e31cfea3" translate="yes" xml:space="preserve">
          <source>Note that the ordering of the tuples in the lists didn't matter.</source>
          <target state="translated">Обратите внимание,что порядок расположения кортежей в списках не имеет значения.</target>
        </trans-unit>
        <trans-unit id="f94de51b2bccdc5fd6127e2ecc608b422d804fb9" translate="yes" xml:space="preserve">
          <source>Note that the process that calls this function &lt;strong&gt;must&lt;/strong&gt; be permanent. If it dies, the port(s) will exit and the driver unload.</source>
          <target state="translated">Обратите внимание, что процесс, вызывающий эту функцию, &lt;strong&gt;должен&lt;/strong&gt; быть постоянным. Если он умрет, порт (-ы) выйдет, а драйвер выгружается.</target>
        </trans-unit>
        <trans-unit id="112c3dfc73e40a04304d2c8d43acbdb9eb33ab97" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt;) are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">Обратите внимание, что специфические параметры запроса (такие как &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt; ) недоступны для инструментальных функций, если эта функция используется.</target>
        </trans-unit>
        <trans-unit id="290365691c0a5e60df1a89c122ce6576ebc4f890" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">Обратите внимание, что специфические параметры запроса (такие как &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; ) недоступны для инструментальных функций, если эта функция используется.</target>
        </trans-unit>
        <trans-unit id="becd11dbe64d3cd785c4bb1c3c28a2d4f227a406" translate="yes" xml:space="preserve">
          <source>Note that the segments are delivered to the user differently depending on which function is used to issue the original request. When issuing the request using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; function, the segments are delivered to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function one at a time, as they arrive. But this obviously doe not work for the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; function. In this case, the segments are accumulated and then delivered all at once as the function returns.</source>
          <target state="translated">Обратите внимание, что сегменты доставляются пользователю по-разному, в зависимости от того, какая функция используется для отправки исходного запроса. При &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; запроса с использованием функции megaco: cast сегменты доставляются пользователю через &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; обратного вызова handle_trans_reply по одному по мере их поступления. Но это явно не работает для функции &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; . В этом случае сегменты накапливаются, а затем доставляются сразу после возврата из функции.</target>
        </trans-unit>
        <trans-unit id="e78277755ce3bad3e06f00c82c4d07b3b9286ed6" translate="yes" xml:space="preserve">
          <source>Note that the ssl application is required for TLS and must be started before configuring TLS capability on diameter transports.</source>
          <target state="translated">Обратите внимание,что приложение ssl требуется для TLS и должно быть запущено перед настройкой возможности TLS на транспортировку диаметров.</target>
        </trans-unit>
        <trans-unit id="2dee8e68f59d0a0eec57cc8147e1a5be661efd08" translate="yes" xml:space="preserve">
          <source>Note that the unmentioned lists (&lt;code&gt;public_key&lt;/code&gt;, &lt;code&gt;cipher&lt;/code&gt;, &lt;code&gt;mac&lt;/code&gt; and &lt;code&gt;compression&lt;/code&gt;) are un-changed.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;public_key&lt;/code&gt; списки ( public_key , &lt;code&gt;cipher&lt;/code&gt; , &lt;code&gt;mac&lt;/code&gt; и &lt;code&gt;compression&lt;/code&gt; ) не изменены.</target>
        </trans-unit>
        <trans-unit id="d8989301ef700984d41bf0a2801b22ca08a2ce1f" translate="yes" xml:space="preserve">
          <source>Note that the use of the LocalEngineID argument is only intended for special cases, if the agent is to &quot;emulate&quot; multiple EngineIDs! By default, the agent uses the value of &lt;code&gt;SnmpEngineID&lt;/code&gt; (see SNMP-FRAMEWORK-MIB).</source>
          <target state="translated">Обратите внимание, что использование аргумента LocalEngineID предназначено только для особых случаев, если агент должен &amp;laquo;эмулировать&amp;raquo; несколько EngineID! По умолчанию агент использует значение &lt;code&gt;SnmpEngineID&lt;/code&gt; (см. SNMP-FRAMEWORK-MIB).</target>
        </trans-unit>
        <trans-unit id="f2ec007dbfec9a50f3790ddfb78b2d7470067938" translate="yes" xml:space="preserve">
          <source>Note that the very first thing done is to fetch the address to the next instruction. The reason is that it usually improves performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56e76ea1af9a17fd56fb02b811e895206d51eb5" translate="yes" xml:space="preserve">
          <source>Note that there is a special case when the value of &lt;code&gt;ReqId&lt;/code&gt; has the value of the atom &lt;code&gt;netif&lt;/code&gt;. This means that the NetIF process has suffered a &quot;fatal&quot; error and been restarted. With possible loss of traffic!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41a1b6fd82bf7a6c9a348c40309d8522ab51f73" translate="yes" xml:space="preserve">
          <source>Note that there may be multiple entries with the same &lt;code&gt;ref&lt;/code&gt;, in contrast to &lt;code&gt;transport&lt;/code&gt; info.</source>
          <target state="translated">Обратите внимание, что может быть несколько записей с одним и тем же &lt;code&gt;ref&lt;/code&gt; , в отличие от информации о &lt;code&gt;transport&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f8021919fad99cd5846d281ed37e3c831b466fa" translate="yes" xml:space="preserve">
          <source>Note that there need to be exactly one distribution controller per connection. A process or port can only be distribution controller for one connection. The registration as distribution controller cannot be undone. It will stick until the distribution controller terminates. The distribution controller should not ignore exit signals. It is allowed to trap exits, but it should then voluntarily terminate when an exit signal is received.</source>
          <target state="translated">Обратите внимание,что на каждое соединение должен приходиться ровно один распределительный контроллер.Процесс или порт может быть распределительным контроллером только для одного соединения.Нельзя отменить регистрацию в качестве распределительного контроллера.Она будет продолжаться до тех пор,пока распределительный контроллер не завершит свою работу.Контроллер распределения не должен игнорировать сигналы выхода.Допускается ловить выходы,но после получения сигнала о выходе он должен добровольно прекратить работу.</target>
        </trans-unit>
        <trans-unit id="35ca0442324d4811fd6417d30d9643d51d667192" translate="yes" xml:space="preserve">
          <source>Note that these functions is intended to be called by the instrumentation functions and &lt;strong&gt;only&lt;/strong&gt; if they are executed in the context of the agent process (e.g. it does not work if called from a spawned process).</source>
          <target state="translated">Обратите внимание, что эти функции предназначены для вызова функциями инструментария и &lt;strong&gt;только в том&lt;/strong&gt; случае, если они выполняются в контексте процесса агента (например, они не работают, если вызываются из порожденного процесса).</target>
        </trans-unit>
        <trans-unit id="05534c73155b84674fad449b2de6066e6ecf290c" translate="yes" xml:space="preserve">
          <source>Note that this can cause the message queue to overflow causing for example the virtual machine to run out of memory and crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6d3e9f0a111d997b09cc65e98dfb115cd9cb64" translate="yes" xml:space="preserve">
          <source>Note that this check use application versions that are loaded, or will be loaded when used. You might have application versions that satisfies all dependencies installed in the system, but if those are not loaded this check will fail. The system will of course also fail when used like this. This may happen when you have multiple &lt;code&gt;branched versions&lt;/code&gt; of the same application installed in the system, but you do not use a &lt;code&gt;boot script&lt;/code&gt; identifing the correct application version.</source>
          <target state="translated">Обратите внимание, что эта проверка использует версии приложения, которые загружены или будут загружены при использовании. У вас могут быть версии приложений, которые удовлетворяют всем установленным в системе зависимостям, но если они не загружены, эта проверка завершится ошибкой. Система, конечно, также выйдет из строя при таком использовании. Это может произойти, если в системе установлено несколько &lt;code&gt;branched versions&lt;/code&gt; одного и того же приложения, но вы не используете &lt;code&gt;boot script&lt;/code&gt; определяющий правильную версию приложения.</target>
        </trans-unit>
        <trans-unit id="99d2fbc3cc50eaf8d82652d3e7dfaf6a59e6d53e" translate="yes" xml:space="preserve">
          <source>Note that this does not effect the messages that are sent autonomously by the stack. They use the protocol_version of the connection info.</source>
          <target state="translated">Обратите внимание,что это не влияет на сообщения,которые отправляются стеком автономно.Они используют версию протокола_версии информации о соединении.</target>
        </trans-unit>
        <trans-unit id="caecb85cc20edb5c5424262ff84251833ebf6fc6" translate="yes" xml:space="preserve">
          <source>Note that this function is executed in the context of the master-agent process.</source>
          <target state="translated">Следует учитывать,что эта функция выполняется в контексте процесса &quot;Ведущий-агент&quot;.</target>
        </trans-unit>
        <trans-unit id="8fa22c35292c8c077560ab97a691881383aaa404" translate="yes" xml:space="preserve">
          <source>Note that this function will only be called if the user has set the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option to &lt;code&gt;true&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt; it is in fact a message resend. If not &lt;strong&gt;both&lt;/strong&gt; of these condition's are meet, &lt;code&gt;send_message&lt;/code&gt; will be called.</source>
          <target state="translated">Обратите внимание, что эта функция будет вызываться только в том случае, если пользователь установил для &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; конфигурации Resend_indication значение &lt;code&gt;true&lt;/code&gt; ,&lt;strong&gt;и&lt;/strong&gt; на самом деле это повторная отправка сообщения. Если не соблюдаются &lt;strong&gt;оба&lt;/strong&gt; этих условия, будет &lt;code&gt;send_message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="732f01521ba5984e435cb22a9ac9e6a45f29f1a3" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the actual sending of pending transactions. This is either implicit (e.g. when receiving a re-sent transaction request for a request which is being processed) or controlled by the pending_timer, see above.</source>
          <target state="translated">Обратите внимание,что это не влияет на фактическую отправку отложенных транзакций.Это либо неявно (например,при получении повторно отправленного запроса транзакции на запрос,который обрабатывается),либо контролируется функцией pending_timer,см.выше.</target>
        </trans-unit>
        <trans-unit id="5991c7ab4d7c54b2c691ce4af01a35ebe0bdc5ec" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</source>
          <target state="translated">Обратите внимание,что это не влияет на конфигурацию приложения,определенную конфигурационными файлами,поэтому перезагрузка узла вернет конфигурацию к тому,что находится в этих файлах.</target>
        </trans-unit>
        <trans-unit id="50e67d142a316144e7ab07bc77f835927707bee6" translate="yes" xml:space="preserve">
          <source>Note that this identifier occasionally has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but in order to keep backwards compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">Обратите внимание,что этот идентификатор иногда называется &quot;имя&quot;.В настоящее время,насколько это возможно,используются термины &quot;идентификатор&quot; или &quot;id&quot;,но,чтобы сохранить обратную совместимость,некоторые случаи &quot;name&quot; все еще могут быть найдены,например,в сообщениях об ошибках.</target>
        </trans-unit>
        <trans-unit id="4ccf4b0fd3e0f0b163b5d9f781f3e69fb98fcf9b" translate="yes" xml:space="preserve">
          <source>Note that this is also the maximum amount of data that can be received from a single recv call. If you are using higher than normal MTU consider setting buffer higher.</source>
          <target state="translated">Обратите внимание,что это также максимальный объем данных,который может быть получен от одного повторного вызова.Если вы используете MTU выше,чем обычно,рассмотрите возможность установки буфера выше.</target>
        </trans-unit>
        <trans-unit id="8d6bbf6c0b04bfae62fc7c2e9271769120f7387b" translate="yes" xml:space="preserve">
          <source>Note that this is just a utility function, which does all the work of splitting the given string into words separated by whitespace and setting up a &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; with the proper indentation, containing a list of &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; elements.</source>
          <target state="translated">Обратите внимание, что это всего лишь служебная функция, которая выполняет всю работу по разбиению заданной строки на слова, разделенные пробелами, и настройку &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; с правильным отступом, содержащего список &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="3e4569ecffb57e143102668b7a6dd11b0264d4d3" translate="yes" xml:space="preserve">
          <source>Note that this list might be reduced if the underlying libcrypto does not support all of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392cc3c5602edaac365f69343bd3fabeabbfabb8" translate="yes" xml:space="preserve">
          <source>Note that this might be an incomplete list of files that need to be updated.</source>
          <target state="translated">Обратите внимание,что это может быть неполный список файлов,которые необходимо обновить.</target>
        </trans-unit>
        <trans-unit id="7ccf435027f13cc4c4ea5f6a451c968311242f89" translate="yes" xml:space="preserve">
          <source>Note that this only works as specified if the &lt;code&gt;sent_pending_limit&lt;/code&gt; config option has been set to an integer value.</source>
          <target state="translated">Обратите внимание, что это работает только так, как указано, если для &lt;code&gt;sent_pending_limit&lt;/code&gt; конфигурации sent_pending_limit было задано целочисленное значение.</target>
        </trans-unit>
        <trans-unit id="14cde1c7fe3b7ab665fc387b99054848ce3fead5" translate="yes" xml:space="preserve">
          <source>Note that this whole module is experimental, and the representations used as well as the functionality is likely to change in the future.</source>
          <target state="translated">Обратите внимание,что весь этот модуль является экспериментальным,и используемые представления,а также функциональность,скорее всего,изменятся в будущем.</target>
        </trans-unit>
        <trans-unit id="6d0f64dc22706965239d477a1963f767ce3f8f64" translate="yes" xml:space="preserve">
          <source>Note that this will always be the default user that is called.</source>
          <target state="translated">Обратите внимание,что этот пользователь всегда будет вызываться по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2e15a72745c4b2259c54938521a47a61a3e00dfd" translate="yes" xml:space="preserve">
          <source>Note that to enable FIPS mode succesfully, OTP must be built with the configure option &lt;code&gt;--enable-fips&lt;/code&gt;, and the underlying libcrypto must also support FIPS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec3dbe2e4a9ded21164737c3e53b41c247a0435" translate="yes" xml:space="preserve">
          <source>Note that transaction id's are (currently) maintained on a per user basis so there is no way to be sure that the value returned will actually be used for a transaction sent on this connection (in case a user has several connections, which is not at all unlikely).</source>
          <target state="translated">Обратите внимание,что идентификаторы транзакций (в настоящее время)поддерживаются для каждого пользователя,поэтому нет никакой возможности быть уверенным в том,что возвращаемое значение будет действительно использовано для транзакции,отправленной по этому соединению (в случае,если пользователь имеет несколько соединений,что совсем не маловероятно).</target>
        </trans-unit>
        <trans-unit id="bfaf8929b2a813d73b67b54b1a840c42370aef06" translate="yes" xml:space="preserve">
          <source>Note that up until here it is not allowed to fragments the message. The entire atom cache and control message has to be part of the starting fragment. After the control message the payload of the message is sent using 128 bytes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c2bdc163cd56fda0bc897570388a7d7819f96a" translate="yes" xml:space="preserve">
          <source>Note that user defined custom &lt;code&gt;verify_fun&lt;/code&gt; may alter original path validation error (e.g &lt;code&gt;selfsigned_peer&lt;/code&gt;). Use with caution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfc282f9f5a7f60dc04c61e35f9a1919be96f74" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d60aba8258543e37473d13c94a9f81daa1cab90" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">Обратите внимание, что использование этого действия из &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; было бы странным на грани колдовства, поскольку на этом сервере не было ранее вызова &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f61aaf53fdf26271e4990884786f10164139b23" translate="yes" xml:space="preserve">
          <source>Note that when compiling a module &lt;strong&gt;all existing coverage data is removed&lt;/strong&gt;, including imported data. If a module is already compiled when data is imported, the imported data is &lt;strong&gt;added&lt;/strong&gt; to the existing coverage data.</source>
          <target state="translated">Обратите внимание, что при компиляции модуля &lt;strong&gt;все существующие данные о покрытии&lt;/strong&gt; , включая импортированные, &lt;strong&gt;удаляются&lt;/strong&gt; . Если модуль уже скомпилирован при импорте данных, импортированные данные &lt;strong&gt;добавляются&lt;/strong&gt; к существующим данным покрытия.</target>
        </trans-unit>
        <trans-unit id="df20ba18430e7a9839bde3720f0b99fc09d3133d" translate="yes" xml:space="preserve">
          <source>Note that when the value of the data to input is a string, it has to be quoted with &lt;code&gt;'&lt;/code&gt;. Example:</source>
          <target state="translated">Обратите внимание: когда значение вводимых данных является строкой, оно должно быть заключено в кавычки &lt;code&gt;'&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="686eb963081bb17804ec4126760703b99e0e06a4" translate="yes" xml:space="preserve">
          <source>Note that whenever a document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, it will be placed on a separate line. Thus, neither a layout such as</source>
          <target state="translated">Обратите внимание, что всякий раз, когда документ в &lt;code&gt;Docs&lt;/code&gt; содержит разрыв строки, он будет помещен в отдельную строку. Таким образом, ни такой макет, как</target>
        </trans-unit>
        <trans-unit id="f445dc35aa8bfa91f3e834a45f7fca092ded7275" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;TCP_NOPUSH&lt;/code&gt; socket option is available on OSX, its semantics is very different (e.g., unsetting it does not cause immediate send of accumulated data). Hence, &lt;code&gt;nopush&lt;/code&gt; option is intentionally ignored on OSX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ce8067681e0ca58dded25b6ecd3a75afe5a9e0" translate="yes" xml:space="preserve">
          <source>Note that work executing on dirty I/O schedulers are expected to mainly wait for I/O. That is, when you get high scheduler utilization on dirty I/O schedulers, CPU utilization is &lt;strong&gt;not&lt;/strong&gt; expected to be high due to this work.</source>
          <target state="translated">Обратите внимание, что работа, выполняемая на грязных планировщиках ввода-вывода, в основном ожидает ввода-вывода. То есть, когда вы получаете высокую загрузку планировщика на грязных планировщиках ввода-вывода, загрузка ЦП &lt;strong&gt;не&lt;/strong&gt; должна быть высокой из-за этой работы.</target>
        </trans-unit>
        <trans-unit id="523d72a03618b74e2aff0e449d66e6cc2c0c698a" translate="yes" xml:space="preserve">
          <source>Note that you cannot define arbitrary variables in a cross compilation configuration file. Only the ones listed below will be guaranteed to be visible throughout the whole execution of all &lt;code&gt;configure&lt;/code&gt; scripts. Other variables needs to be defined as arguments to &lt;code&gt;configure&lt;/code&gt; or exported in the environment.</source>
          <target state="translated">Обратите внимание, что вы не можете определять произвольные переменные в файле конфигурации кросс-компиляции. Гарантированно, что только перечисленные ниже будут видны на протяжении всего выполнения всех скриптов &lt;code&gt;configure&lt;/code&gt; . Другие переменные необходимо определить как аргументы для &lt;code&gt;configure&lt;/code&gt; или экспорта в среду.</target>
        </trans-unit>
        <trans-unit id="7bfec520257edb9cec974688079c41974b401d13" translate="yes" xml:space="preserve">
          <source>Note that you need to have run &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; in the particular shell before building anything on Windows. After doing a make opt you can test your result by running &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt;. If you want to copy the result to a release directory (say &lt;code&gt;/tmp/erl_release&lt;/code&gt;), you do this (still in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt;)</source>
          <target state="translated">Обратите внимание, что вам нужно запустить &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; в конкретной оболочке, прежде чем что-либо строить в Windows. После выполнения make opt вы можете проверить свой результат, запустив &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt; . Если вы хотите скопировать результат в каталог выпуска (скажем, &lt;code&gt;/tmp/erl_release&lt;/code&gt; ), вы делаете это (все еще в &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4a5f7a43dea5055412cd813699aecbdd4537ff72" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 21 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">Обратите внимание, что при этом на вашем пути должен появиться свежий Erlang, предпочтительно простой 21, который вы создали на предыдущих шагах. Вы также можете добавить &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; в свой &lt;code&gt;PATH&lt;/code&gt; перед восстановлением определенных библиотек. Это даст вам достаточно хорошую систему Erlang для компиляции любого кода OTP erlang. Правильная настройка пути немного сложна. Вам по-прежнему нужно иметь &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; и &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; &lt;strong&gt;перед&lt;/strong&gt; фактическим эмулятором в пути. Типичная настройка пути для использования компилятора начальной загрузки:</target>
        </trans-unit>
        <trans-unit id="0eb0b5bede55df32486ffb5e68143aaf83b271f3" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 23 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f59844103d6ba8ed4dae0a9ab2a29d364c2a6a4" translate="yes" xml:space="preserve">
          <source>Note that, as a way to indicate the newest file, &lt;code&gt;run_erl&lt;/code&gt; will delete the oldest log file to maintain a &quot;hole&quot; in the file sequences. For example, if log files #1, #2, #4 and #5 exists, that means #2 is the latest and #4 is the oldest. You will therefore at most get one less log file than the value set by &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что как способ указать самый новый файл, &lt;code&gt;run_erl&lt;/code&gt; удалит самый старый файл журнала, чтобы сохранить &amp;laquo;дыру&amp;raquo; в последовательностях файлов. Например, если существуют файлы журналов №1, №2, №4 и №5, это означает, что №2 - самый последний, а №4 - самый старый. Таким образом, вы получите в &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt; на один файл журнала меньше, чем значение, установленное параметром RUN_ERL_LOG_GENERATIONS .</target>
        </trans-unit>
        <trans-unit id="cc609e818cd60886eb0217d87244da60ff760651" translate="yes" xml:space="preserve">
          <source>Note the difference between &lt;code&gt;move c xy&lt;/code&gt; and &lt;code&gt;move c d&lt;/code&gt;. Note that &lt;code&gt;move c xy&lt;/code&gt; is equivalent to the following two definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c73dcf363499057947cccf47d8448b7dbaf012" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that can not return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">Обратите внимание на тот факт, что вы можете использовать &lt;code&gt;throw&lt;/code&gt; для возврата результата, что может быть полезно. Например, чтобы спастись с помощью &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; из глубины сложного кода, который не может вернуть &lt;code&gt;{next_state,State,Data}&lt;/code&gt; , потому что &lt;code&gt;State&lt;/code&gt; или &lt;code&gt;Data&lt;/code&gt; больше не входят в область видимости.</target>
        </trans-unit>
        <trans-unit id="7f3c2db9a65e908102a67487ed12c89a758f057f" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that cannot return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4317e03fcba152213e0ea0f2f44b86239f1e5599" translate="yes" xml:space="preserve">
          <source>Note this option is not needed in normal TLS usage and should not be used to implement new clients. But legacy clients that retries connections in the following manner</source>
          <target state="translated">Обратите внимание,что эта опция не нужна при обычном использовании TLS и не должна использоваться для реализации новых клиентов.Но старые клиенты,которые повторяют соединения следующим образом</target>
        </trans-unit>
        <trans-unit id="3157e5999d26e98c016dbd63bda9ac9a0dfb9593" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Clause&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308285ef58a3193174b243e20988fef230082fab" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;arity_qualifier&lt;/code&gt; nodes are recognized. This is to follow The Erlang Parser when it comes to wild attributes: both {F, A} and F/A are recognized, which makes it possible to turn wild attributes into recognized attributes without at the same time making it impossible to compile files using the new syntax with the old version of the Erlang Compiler.</source>
          <target state="translated">Примечание: узлы &lt;code&gt;arity_qualifier&lt;/code&gt; распознаются. Это необходимо для синтаксического анализатора Erlang, когда дело доходит до диких атрибутов: распознаются как {F, A}, так и F / A, что позволяет превращать дикие атрибуты в распознанные атрибуты, не делая в то же время невозможной компиляцию файлов с использованием новый синтаксис со старой версией компилятора Erlang.</target>
        </trans-unit>
        <trans-unit id="d81e2383b82cc4e91e2f04de6cf454f9653c7f46" translate="yes" xml:space="preserve">
          <source>Note: All instances of free variables will be given distinct labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b61204a294edc11d57ba05c5e469df9123163d6" translate="yes" xml:space="preserve">
          <source>Note: Because &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf9d511dcfa9aaf58ab7283975eec8497bcb0e4" translate="yes" xml:space="preserve">
          <source>Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0562ade2cea8acce9b76b0b4ab90737668e5d26" translate="yes" xml:space="preserve">
          <source>Note: Currently, the set of syntax trees which have a concrete representation is larger than the set of trees which can be built using the function &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt;. An abstract character will be concretised as an integer, while &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; does not at present yield an abstract character for any input. (Use the &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; function to explicitly create an abstract character.)</source>
          <target state="translated">Примечание. В настоящее время набор синтаксических деревьев, которые имеют конкретное представление, больше, чем набор деревьев, которые можно построить с помощью функции &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; . Абстрактный символ будет конкретизирован как целое число, в то время как &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; в настоящее время не дает абстрактного символа для любого ввода. (Используйте функцию &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; , чтобы явно создать абстрактный символ.)</target>
        </trans-unit>
        <trans-unit id="165ae8a32f7b6f64943274e92b98458ca7d19edd" translate="yes" xml:space="preserve">
          <source>Note: If some document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, the vertical layout will always be selected.</source>
          <target state="translated">Примечание. Если какой-либо документ в &lt;code&gt;Docs&lt;/code&gt; содержит разрыв строки, всегда будет выбран вертикальный макет.</target>
        </trans-unit>
        <trans-unit id="3840eb20d7586de2203199630f1c366ff144d8c6" translate="yes" xml:space="preserve">
          <source>Note: If you get a &quot;syntax error&quot; message when trying to merge files (and you know those files to be correct), then try the &lt;code&gt;preprocess&lt;/code&gt; option. It typically means that your code contains too strange macros to be handled without actually performing the preprocessor expansions.</source>
          <target state="translated">Примечание. Если вы получаете сообщение &amp;laquo;синтаксическая ошибка&amp;raquo; при попытке объединить файлы (и вы знаете, что эти файлы верны), попробуйте опцию &lt;code&gt;preprocess&lt;/code&gt; . Обычно это означает, что ваш код содержит слишком странные макросы для обработки без фактического выполнения расширений препроцессора.</target>
        </trans-unit>
        <trans-unit id="884eb65502e4a057112e64304a3aee60ecdc8306" translate="yes" xml:space="preserve">
          <source>Note: Since &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Примечание. Поскольку &lt;code&gt;Node&lt;/code&gt; представляет собой синтаксическое дерево, фактические значения времени выполнения, соответствующие его поддеревьям, часто могут быть частично или полностью неизвестными. Таким образом, если &lt;code&gt;Node&lt;/code&gt; представляет, например, &amp;laquo; &lt;code&gt;[... | Ns]&lt;/code&gt; &amp;raquo; (где &lt;code&gt;Ns&lt;/code&gt; - переменная), тогда функция вернет &lt;code&gt;false&lt;/code&gt; , потому что неизвестно, будет ли &lt;code&gt;Ns&lt;/code&gt; привязан к списку во время выполнения. Если &lt;code&gt;Node&lt;/code&gt; вместо этого представляет, например, &amp;laquo; &lt;code&gt;[1, 2, 3]&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;[A | []]&lt;/code&gt; &amp;raquo;, тогда функция вернет &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef01dc14c91674b058f1673b8d98cbd24605f910" translate="yes" xml:space="preserve">
          <source>Note: The Erlang language has distinct 1-tuples, i.e., &lt;code&gt;{X}&lt;/code&gt; is always distinct from &lt;code&gt;X&lt;/code&gt; itself.</source>
          <target state="translated">Примечание. В языке Erlang есть отдельные кортежи из единиц, т.е. &lt;code&gt;{X}&lt;/code&gt; всегда отличается от самого &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd9bd8a8c68fbfcb71e2f8c20f0bf3e55f2ea3f" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we can not be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">Примечание: различие между &amp;laquo;статическими&amp;raquo; и &amp;laquo;безопасными&amp;raquo; модулями необходимо, чтобы не нарушать семантику динамической замены кода. &amp;laquo;Статический&amp;raquo; исходный модуль не будет заменен, если не будет заменен и целевой модуль. Теперь представьте себе конечный автомат, реализованный путем помещения кода для каждого состояния в отдельный модуль, и предположим, что мы хотим объединить его в один целевой модуль, пометив все исходные модули как статические. Ожидается, что в каждой точке исходного кода, где выполняется вызов от одного из модулей к другому (т. Е. При переходе между состояниями), замена кода. Затем, если мы в объединенном коде, не проверяем в этих точках, если &lt;strong&gt;цель&lt;/strong&gt;модуль (результат слияния) был заменен, мы не можем быть уверены в целом, что сможем выполнить замену кода слитого конечного автомата - он может работать вечно, не обнаруживая изменения кода. Следовательно, все такие вызовы должны оставаться удаленными вызовами (обнаружение изменений кода), но могут напрямую вызывать целевой модуль.</target>
        </trans-unit>
        <trans-unit id="8daa2d5e45d509f284f5f3a9bb9a8c05ad568947" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we cannot be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9850cccf6fb6ccf68d12503d679738d939b63a6a" translate="yes" xml:space="preserve">
          <source>Note: The name of the primary constructor function for a node type is always the name of the type itself, prefixed by &quot;&lt;code&gt;c_&lt;/code&gt;&quot;; recognizer predicates are correspondingly prefixed by &quot;&lt;code&gt;is_c_&lt;/code&gt;&quot;. Furthermore, to simplify preservation of annotations (cf. &lt;code&gt;get_ann/1&lt;/code&gt;), there are analogous constructor functions prefixed by &quot;&lt;code&gt;ann_c_&lt;/code&gt;&quot; and &quot;&lt;code&gt;update_c_&lt;/code&gt;&quot;, for setting the annotation list of the new node to either a specific value or to the annotations of an existing node, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2872d7972612ca53705b122b06de88412b65023e" translate="yes" xml:space="preserve">
          <source>Note: The preprocessor macro definition directive &quot;&lt;code&gt;-define(Name, Body).&lt;/code&gt;&quot; has relatively few requirements on the syntactical form of &lt;code&gt;Body&lt;/code&gt; (viewed as a sequence of tokens). The &lt;code&gt;text&lt;/code&gt; node type can be used for a &lt;code&gt;Body&lt;/code&gt; that is not a normal Erlang construct.</source>
          <target state="translated">Примечание. Директива определения макроса препроцессора &amp;laquo; &lt;code&gt;-define(Name, Body).&lt;/code&gt; &amp;raquo; Предъявляет относительно мало требований к синтаксической форме &lt;code&gt;Body&lt;/code&gt; (рассматриваемой как последовательность токенов). Тип &lt;code&gt;text&lt;/code&gt; узла можно использовать для &lt;code&gt;Body&lt;/code&gt; , которое не является обычной конструкцией Erlang.</target>
        </trans-unit>
        <trans-unit id="6a3d6a31994b23aff112f18cb8ed90847216cb94" translate="yes" xml:space="preserve">
          <source>Note: The primary constructor functions for a node type should always have the same name as the node type itself.</source>
          <target state="translated">Замечание:Функции первичного конструктора для типа узла всегда должны иметь то же имя,что и сам тип узла.</target>
        </trans-unit>
        <trans-unit id="8ca2fedd6ed2548e302789ae2e0c23407f15fd76" translate="yes" xml:space="preserve">
          <source>Note: This is a constant time operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75af5c6559b7697b82cd55b9c2024ae62ccc77d" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="bb58e56411d72b2c5de64c07dff668396f493062" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="961e68d5ec80ea10407155400f5248fb08c77ba7" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;length(values_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cc9a8168087cf73aa91a1ca9a6fb283bef773c" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="d09be805d2731441552cb1761a72f29b924b8a7a" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="698437d5693811f218a0125173a54360a31fae26" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="94f64f74f43a14a0fd5a71cca82d5190660bfa22" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="1c349a183f568e3a4f03fe936ebb15f7b0b8d9c0" translate="yes" xml:space="preserve">
          <source>Note: all literals (cf. &lt;code&gt;is_literal/1&lt;/code&gt;) are leaf nodes, even if they represent structured (constant) values such as &lt;code&gt;{foo, [bar, baz]}&lt;/code&gt;. Also note that variables are leaf nodes but not literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ca5b0925ea2a2251f51d1eef2e90cac1124164" translate="yes" xml:space="preserve">
          <source>Note: catch-expressions can be rewritten as try-expressions, and will eventually be removed from Core Erlang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2cbae916b385a433641891fb2f65cb175003a34" translate="yes" xml:space="preserve">
          <source>Note: changing this value (and passing the resulting context to a continuation function) does not affect the normal formatting, but may affect user-defined behaviour in hook functions.</source>
          <target state="translated">Примечание:изменение этого значения (и передача результирующего контекста в функцию продолжения)не влияет на нормальное форматирование,но может повлиять на определяемое пользователем поведение в функциях перехвата.</target>
        </trans-unit>
        <trans-unit id="1e66a58313670e508e4d5829246111554fd79c2d" translate="yes" xml:space="preserve">
          <source>Note: each node in &lt;code&gt;Clauses&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e024adb668e3f8ad63658f3c7b61203ba9e048" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;M:F(...)&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;M:F&lt;/code&gt;&quot;.</source>
          <target state="translated">Примечание: если &lt;code&gt;Node&lt;/code&gt; представляет &amp;laquo; &lt;code&gt;M:F(...)&lt;/code&gt; &amp;raquo;, то результатом является поддерево, представляющее &amp;laquo; &lt;code&gt;M:F&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e950ce0b15b865ad70b6df0b8b6e16fd534c8751" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;fun N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;fun M:N/A&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;M:N/A&lt;/code&gt;&quot;, respectively.</source>
          <target state="translated">Примечание: если &lt;code&gt;Node&lt;/code&gt; представляет &amp;laquo; &lt;code&gt;fun N/A&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;fun M:N/A&lt;/code&gt; &amp;raquo;, то результатом будет поддерево, представляющее &amp;laquo; &lt;code&gt;N/A&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;M:N/A&lt;/code&gt; &amp;raquo;, соответственно.</target>
        </trans-unit>
        <trans-unit id="a650514ba11566a0849a47048d45d0a0ca77843f" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;cons&lt;/code&gt;, the number of subtrees is exactly two. If &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;{atomic, Value}&lt;/code&gt;, the number of subtrees is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024d798779fd03b9f02b44baf68e6e4bf1a905f4" translate="yes" xml:space="preserve">
          <source>Note: in &lt;code&gt;list(Elements, none)&lt;/code&gt;, the &quot;nil&quot; list terminator is implicit and has no associated information (see &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;), while in the seemingly equivalent &lt;code&gt;list(Elements, Tail)&lt;/code&gt; when &lt;code&gt;Tail&lt;/code&gt; has type &lt;code&gt;nil&lt;/code&gt;, the list terminator subtree &lt;code&gt;Tail&lt;/code&gt; may have attached attributes such as position, comments, and annotations, which will be preserved in the result.</source>
          <target state="translated">Примечание: в &lt;code&gt;list(Elements, none)&lt;/code&gt; терминатор списка &quot;nil&quot; является неявным и не имеет связанной информации (см. &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; ), в то время как в кажущемся эквивалентном &lt;code&gt;list(Elements, Tail)&lt;/code&gt; когда &lt;code&gt;Tail&lt;/code&gt; имеет тип &lt;code&gt;nil&lt;/code&gt; , терминатор списка поддерево &lt;code&gt;Tail&lt;/code&gt; может иметь прикрепленные атрибуты, такие как позиция, комментарии и аннотации, которые будут сохранены в результате.</target>
        </trans-unit>
        <trans-unit id="c912d0741e6afe02446fe862b8225b8a23da14f4" translate="yes" xml:space="preserve">
          <source>Note: no checking is done whether the character sequence represents a proper variable name, i.e., whether or not its first character is an uppercase Erlang character, or whether it does not contain control characters, whitespace, etc.</source>
          <target state="translated">Примечание:не производится проверка,является ли последовательность символов правильным именем переменной,т.е.является ли ее первый символ заглавным символом Erlang или не содержит управляющих символов,пробельных символов и т.д.</target>
        </trans-unit>
        <trans-unit id="0e16037ad2fddc6752207e81b2d23a2a536d6ff8" translate="yes" xml:space="preserve">
          <source>Note: not all literals are leaf nodes, and vice versa. E.g., tuples with nonzero arity and nonempty lists may be literals, but are not leaf nodes. Variables, on the other hand, are leaf nodes but not literals.</source>
          <target state="translated">Примечание:не все литералы являются узлами листа,и наоборот.Например,кортежи с ненулевыми и непустыми списками могут быть буквальными,но не являются узлами листа.Переменные,с другой стороны,являются узлами листа,но не литералами.</target>
        </trans-unit>
        <trans-unit id="3393ba242996126bd79b8530e4ba8690724e5617" translate="yes" xml:space="preserve">
          <source>Note: passing a string as argument to this function causes a corresponding atom to be created for the internal representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19a5f5e7535dfc22dce9d8f5ad97ff942d5f69e" translate="yes" xml:space="preserve">
          <source>Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the character &quot;&lt;code&gt;a&lt;/code&gt;&quot; can be written both as &quot;&lt;code&gt;$a&lt;/code&gt;&quot; and &quot;&lt;code&gt;$\141&lt;/code&gt;&quot;, and a Tab character can be written as &quot;&lt;code&gt;$\11&lt;/code&gt;&quot;, &quot;&lt;code&gt;$\011&lt;/code&gt;&quot; or &quot;&lt;code&gt;$\t&lt;/code&gt;&quot;.</source>
          <target state="translated">Примечание: литерал, соответствующий определенному значению символа, не определяется однозначно. Например, символ &amp;laquo; &lt;code&gt;a&lt;/code&gt; &amp;raquo; можно записать как &amp;laquo; &lt;code&gt;$a&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;$\141&lt;/code&gt; &amp;raquo;, а символ табуляции можно записать как &amp;laquo; &lt;code&gt;$\11&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;$\011&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;$\t&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6afc7eae3d94cce8a805b8208b70b9cbd6d1fee0" translate="yes" xml:space="preserve">
          <source>Note: the resulting list can contain more than one tuple &lt;code&gt;{ShortName, Name}&lt;/code&gt; for the same &lt;code&gt;ShortName&lt;/code&gt;, possibly with different values for &lt;code&gt;Name&lt;/code&gt;, depending on the given list.</source>
          <target state="translated">Примечание: итоговый список может содержать более одного кортежа &lt;code&gt;{ShortName, Name}&lt;/code&gt; для одного и того же &lt;code&gt;ShortName&lt;/code&gt; , возможно, с разными значениями для &lt;code&gt;Name&lt;/code&gt; , в зависимости от данного списка.</target>
        </trans-unit>
        <trans-unit id="e12fe9dbfa6c36c26ca8159eaa9cc67ee440fdd9" translate="yes" xml:space="preserve">
          <source>Note: the return value is &lt;code&gt;ok&lt;/code&gt; instead of &lt;code&gt;success&lt;/code&gt; unlike in other functions in this module. This is a fault that was introduced so long ago that any change would break a large number of existing software.</source>
          <target state="translated">Примечание: в отличие от других функций в этом модуле, возвращаемое значение является &lt;code&gt;ok&lt;/code&gt; а не &lt;code&gt;success&lt;/code&gt; . Это ошибка, которая была введена так давно, что любое изменение нарушило бы работу большого количества существующего программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="17b17be20c7e8e9810e58ea4c73486c73bfc67e7" translate="yes" xml:space="preserve">
          <source>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</source>
          <target state="translated">Примечание:текст,возвращаемый функцией форматирования,будет автоматически разбиваться на отдельные строки комментариев при каждом разрыве строки.Никакой дополнительной работы не требуется.</target>
        </trans-unit>
        <trans-unit id="41856edf3415d1e90c206e87cfe950bc7df0afeb" translate="yes" xml:space="preserve">
          <source>Note: these macros introduce a run-time dependency on the EUnit library code, if compiled with testing enabled.</source>
          <target state="translated">Замечание:эти макросы вводят зависимость от кода библиотеки EUnit,если они скомпилированы с включенным тестированием.</target>
        </trans-unit>
        <trans-unit id="bd0d2709ddf8a0638d0aff92ed2e6f15b3be5f7b" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(apply_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1209b617e8d5cc3c5cfc6c1377fd43e5ce41cd" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(call_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e53230502f03bb4733db74bc560eb0d865cde8" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(clause_pats(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd282e7fb8db35030f176c6215fe03b5567042d" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(fun_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca941f0b40db2f3695ecc15ccff4c8a24695250" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(let_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d78502c9d35d74b9f564b739de13ccb2a77f56" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(list_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание: это эквивалентно &lt;code&gt;length(list_elements(Node))&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="ebcca9b6d7e57fd06c7e8bed4e5fd7e93be99484" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(primop_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97dc47a811817d58377be776d262e5b3c05f6cf1" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание: это эквивалентно &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="ec59e73e9bc821017665db80dbf6cf98689682f7" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea075dee9256e89d461acd90fcf6f51117060f2" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, Annotations ++ get_ann(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4666d61b1ebe44a455ff212df8dfe43d5e4150ff" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание: это эквивалентно &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="cdbc84877e38d50c218ad5207d2faecbe10b2060" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание: это эквивалентно &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="a5386e79b58eda950a5274a7a0af8b6cfc746999" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">Примечание: это эквивалентно &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt; , но потенциально более эффективно.</target>
        </trans-unit>
        <trans-unit id="27b141a49bc96901cfd1d105a64d4c5f5a09eca3" translate="yes" xml:space="preserve">
          <source>Note: this is retained only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">Примечание:это сохраняется только для обратной совместимости с существующими парсерами и инструментами.</target>
        </trans-unit>
        <trans-unit id="9a585e3e15766522c8abd82fcb5ff8e1c6cca19e" translate="yes" xml:space="preserve">
          <source>Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order to form an Erlang module definition.</source>
          <target state="translated">Замечание:это просто способ сгруппировать формы исходного кода как единое синтаксическое дерево,обычно для того,чтобы сформировать определение модуля Erlang.</target>
        </trans-unit>
        <trans-unit id="7a43199c7c25f11800016e7472f3564571a0c7b8" translate="yes" xml:space="preserve">
          <source>Note: this is supported only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">Примечание:это поддерживается только для обратной совместимости с существующими парсерами и инструментами.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c32e67b1c4c65b813f5c5d3ba41235581ee4036f" translate="yes" xml:space="preserve">
          <source>Notes About MacOS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d325fef3978cce9c3fe25199318432f2a2956f8" translate="yes" xml:space="preserve">
          <source>Notes and Implementation Details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b98b21a7184296ef346762bd6728f411d329337" translate="yes" xml:space="preserve">
          <source>Notes concerning the Log Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="36d78a208c85e4ee9fbb30023fe1b73f1f6b5ac7" translate="yes" xml:space="preserve">
          <source>Notes: Floating documents appear to work well, but are currently less general than you might wish, losing effect when embedded in certain contexts. It is possible to nest floating-operators (even with different priorities), but the effects may be difficult to predict. In any case, note that the way the algorithm reorders floating documents amounts to a &quot;bubblesort&quot;, so don't expect it to be able to sort large sequences of floating documents quickly.</source>
          <target state="translated">Примечания:Плавающие документы,похоже,работают хорошо,но в настоящее время они менее общие,чем вы могли бы пожелать,теряя эффект при внедрении в определенных контекстах.Можно гнездить плавучих операторов (даже с разными приоритетами),но последствия может быть трудно предсказать.В любом случае,обратите внимание,что способ переупорядочивания плавающих документов алгоритмом равнозначен &quot;пузырьковому порту&quot;,поэтому не ожидайте,что он сможет быстро отсортировать большие последовательности плавающих документов.</target>
        </trans-unit>
        <trans-unit id="661b94995b5e8bdcfda9b5f651e69fddc51ef9bc" translate="yes" xml:space="preserve">
          <source>Notes: If a file contains too exotic definitions or uses of macros, it will not be possible to read it without preprocessing. Furthermore, Igor does not currently try to sort out multiple inclusions of the same file, or redefinitions of the same macro name. Therefore, when preprocessing is turned off, it may become necessary to edit the resulting source code, removing such re-inclusions and redefinitions.</source>
          <target state="translated">Примечания:Если файл содержит слишком экзотические определения или использует макросы,его невозможно будет прочитать без препроцессирования.Более того,в настоящее время Игорь не пытается разобрать несколько включений одного и того же файла,или переопределить одно и то же имя макроса.Поэтому при выключенной препроцессировке может возникнуть необходимость в редактировании результирующего исходного кода,удалении таких переопределений и переопределений.</target>
        </trans-unit>
        <trans-unit id="15f88e626a7699794907797465138c59374fcbea" translate="yes" xml:space="preserve">
          <source>Notes: if &lt;code&gt;Arguments&lt;/code&gt; is the empty list, the result will thus represent &quot;&lt;code&gt;?Name()&lt;/code&gt;&quot;, including a pair of matching parentheses.</source>
          <target state="translated">Примечания: если &lt;code&gt;Arguments&lt;/code&gt; - пустой список, результат будет представлять &amp;laquo; &lt;code&gt;?Name()&lt;/code&gt; &amp;raquo;, включая пару совпадающих скобок.</target>
        </trans-unit>
        <trans-unit id="99a1f1cf872f6e0e707f9c22cb3a2c5254119532" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt; из очереди, это нужно делать с помощью driver_deq .</target>
        </trans-unit>
        <trans-unit id="f4188a869e9e87b711a06e4a4b3f28fd00e2f8ef" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt; из очереди, это должно быть сделано с помощью enif_ioq_deq .</target>
        </trans-unit>
        <trans-unit id="65c645e6dc76f281bf44b4e98033d1a25ed3e13d" translate="yes" xml:space="preserve">
          <source>Notice also that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; is interpreted as &quot;&lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; which is a syntax error. The correct way is to write a space after '=': &quot;&lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что &amp;laquo; &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;raquo; интерпретируется как &amp;laquo; &lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;raquo;, что является синтаксической ошибкой. Правильный способ - написать пробел после '=': &quot; &lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e7821e854de5de8a4aacee0ff97239e9645aa44" translate="yes" xml:space="preserve">
          <source>Notice also that byte-oriented data is simplest sent using the ISO Latin-1 encoding.</source>
          <target state="translated">Заметьте также,что данные,ориентированные на байты,проще всего отправлять с использованием кодировки ISO Latin-1.</target>
        </trans-unit>
        <trans-unit id="8a4c53d6a09620002b97e1f8172f87b851fbd7a6" translate="yes" xml:space="preserve">
          <source>Notice also that the transient type is of little practical use, because when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что переходный тип имеет мало практического применения, потому что, когда дерево наблюдения завершается, причина устанавливается на &lt;code&gt;shutdown&lt;/code&gt; , а не на &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed33ac880989d641a4eeb80431d2338e759148c9" translate="yes" xml:space="preserve">
          <source>Notice also that when testing the program from the shell, the input is spread over two lines as the line was too long.</source>
          <target state="translated">Заметьте также,что при тестировании программы из оболочки,вход разбивается на две строки,так как строка была слишком длинной.</target>
        </trans-unit>
        <trans-unit id="831cedf2104bac2a5f0cad0d085a43c104fcbad7" translate="yes" xml:space="preserve">
          <source>Notice also that ~p is used instead of ~w in &lt;code&gt;io:format&lt;/code&gt;. To quote the manual: &quot;~p Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. It also tries to detect lists of printable characters and to output these as strings&quot;.</source>
          <target state="translated">Также обратите внимание, что ~ p используется вместо ~ w в &lt;code&gt;io:format&lt;/code&gt; . Чтобы процитировать руководство: &amp;laquo;~ p Записывает данные со стандартным синтаксисом так же, как ~ w, но разбивает термины, печатное представление которых длиннее одной строки, на множество строк и делает разумные отступы в каждой строке. Он также пытается обнаружить списки печатаемых символов и выводить их в виде строк &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c8bc316625e4c64bc96adbb50df0038f6cc5d2e3" translate="yes" xml:space="preserve">
          <source>Notice how the operator &quot;!&quot; is used to send messages. The syntax of &quot;!&quot; is:</source>
          <target state="translated">Обратите внимание,как оператор &quot;!&quot; используется для отправки сообщений.Синтаксис &quot;!&quot;:</target>
        </trans-unit>
        <trans-unit id="2981906ecbb99640904a52c6a3186e8def191ed9" translate="yes" xml:space="preserve">
          <source>Notice how to write the &lt;code&gt;server&lt;/code&gt; function so that it calls itself, through &lt;code&gt;server(User_List)&lt;/code&gt;, and thus creates a loop. The Erlang compiler is &quot;clever&quot; and optimizes the code so that this really is a sort of loop and not a proper function call. But this only works if there is no code after the call. Otherwise, the compiler expects the call to return and make a proper function call. This would result in the process getting bigger and bigger for every loop.</source>
          <target state="translated">Обратите внимание, как написать функцию &lt;code&gt;server&lt;/code&gt; чтобы она &lt;code&gt;server(User_List)&lt;/code&gt; себя через сервер (User_List) и, таким образом, создавала цикл. Компилятор Erlang &amp;laquo;умен&amp;raquo; и оптимизирует код так, что это действительно своего рода цикл, а не правильный вызов функции. Но это работает только в том случае, если после звонка нет кода. В противном случае компилятор ожидает, что вызов вернется и сделает правильный вызов функции. Это привело бы к тому, что процесс становился все больше и больше для каждого цикла.</target>
        </trans-unit>
        <trans-unit id="5b3e78ade17b6e0804c28534fc7f4b91db6f6042" translate="yes" xml:space="preserve">
          <source>Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if &lt;code&gt;{capture, all_names}&lt;/code&gt; is specified as an option to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;. You can therefore create a name-to-value mapping from the result of &lt;code&gt;run/3&lt;/code&gt; like this:</source>
          <target state="translated">Обратите внимание, что во втором примере повторяющееся имя встречается в возвращаемом списке только один раз и что список находится в алфавитном порядке, независимо от того, где имена расположены в регулярном выражении. Порядок имен совпадает с порядком захваченных подвыражений, если &lt;code&gt;{capture, all_names}&lt;/code&gt; указан в качестве параметра для &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; . Таким образом, вы можете создать сопоставление имени и значения из результата выполнения &lt;code&gt;run/3&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="686ddcda1c61a1ea244a057dd0d0172fe3f99230" translate="yes" xml:space="preserve">
          <source>Notice on line 16 that 5 inches is converted to centimeters and back again and reassuringly get back to the original value. That is, the argument to a function can be the result of another function. Consider how line 16 (above) works. The argument given to the function &lt;code&gt;{inch,5}&lt;/code&gt; is first matched against the first head clause of &lt;code&gt;convert_length&lt;/code&gt;, that is, &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt;. It can be seen that &lt;code&gt;{centimeter,X}&lt;/code&gt; does not match &lt;code&gt;{inch,5}&lt;/code&gt; (the head is the bit before the &quot;-&amp;gt;&quot;). This having failed, let us try the head of the next clause that is, &lt;code&gt;convert_length({inch,Y})&lt;/code&gt;. This matches, and &lt;code&gt;Y&lt;/code&gt; gets the value 5.</source>
          <target state="translated">Обратите внимание в строке 16, что 5 дюймов преобразуются в сантиметры и обратно и возвращаются к исходному значению. То есть аргумент функции может быть результатом другой функции. Посмотрите, как работает строка 16 (выше). Аргумент, передаваемый функции &lt;code&gt;{inch,5}&lt;/code&gt; , сначала сопоставляется с первым предложением &lt;code&gt;convert_length&lt;/code&gt; , то есть &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt; . Видно, что &lt;code&gt;{centimeter,X}&lt;/code&gt; не соответствует &lt;code&gt;{inch,5}&lt;/code&gt; (головка - это бит перед &quot;-&amp;gt;&quot;). Если это не удалось, давайте попробуем &lt;code&gt;convert_length({inch,Y})&lt;/code&gt; следующего предложения, а именно convert_length ({inch, Y}) . Это совпадает, и &lt;code&gt;Y&lt;/code&gt; получает значение 5.</target>
        </trans-unit>
        <trans-unit id="faf1518cd916f83fdab368cf16163b784374daaa" translate="yes" xml:space="preserve">
          <source>Notice that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; will be interpreted as &quot;&lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot;, which is a syntax error. The correct way to write the expression is: &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &amp;laquo; &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;raquo; будет интерпретировано как &amp;laquo; &lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;raquo;, что является синтаксической ошибкой. Правильный способ записать выражение: &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e48d2b215215558347b575f3ecbab79091a73b6" translate="yes" xml:space="preserve">
          <source>Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example:</source>
          <target state="translated">Обратите внимание,что (*COMMIT)в начале шаблона не является тем же самым,что и якорь,если только PCRE-оптимизация начала матча не отключена,как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="7645c19f8cada682b7b2ac8e343c6026994bf018" translate="yes" xml:space="preserve">
          <source>Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).</source>
          <target state="translated">Обратите внимание,что (*SKIP:NAME)ищет только имена,заданные (*MARK:NAME).Он игнорирует имена,которые устанавливаются с помощью (*PRUNE:NAME)или (*THEN:NAME).</target>
        </trans-unit>
        <trans-unit id="ac772e9232c60fd05e436000b3d65e5ba73ff0bb" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt; file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adcc07be0a21a37482a3bd3976227349972956b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;-relaxed_command_check&lt;/code&gt; is specified when starting the daemon that is to accept killing when it has live nodes registered. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect. A daemon that is started without relaxed command checking must be killed using, for example, signals or some other OS-specific method if it has active clients registered.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;-relaxed_command_check&lt;/code&gt; указывается при запуске демона, который должен принимать убийство, когда у него зарегистрированы живые узлы. При запуске &lt;code&gt;epmd&lt;/code&gt; в интерактивном режиме &lt;code&gt;-relaxed_command_check&lt;/code&gt; не действует. Демон, запущенный без упрощенной проверки команд, должен быть убит с помощью, например, сигналов или какого-либо другого специфичного для ОС метода, если у него зарегистрированы активные клиенты.</target>
        </trans-unit>
        <trans-unit id="70bfe90d5c883bf60d9637a901f3b97c4d3f704b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147f5f00692828642c9cf73812c37af283058699" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8218b491a4b3c0c5eb8370427f8e63bc8b619227" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ActiveSuspendCount&lt;/code&gt; and &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; are not the total suspend count on &lt;code&gt;Suspendee&lt;/code&gt;, only the parts contributed by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;ActiveSuspendCount&lt;/code&gt; и &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; не являются общим счетчиком приостановки для &lt;code&gt;Suspendee&lt;/code&gt; , а только частями, предоставленными &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd2f7d7216ad16040d03dfe0cd8ffeaa41f5fc9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ErlNifBinary&lt;/code&gt; is a semi-opaque type and you are only allowed to read fields &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;ErlNifBinary&lt;/code&gt; - это полупрозрачный тип, и вам разрешено только читать &lt;code&gt;size&lt;/code&gt; полей и &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6fa80e962aa12707d897541b088fcd511a7fff9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Filename&lt;/code&gt; can be either a list or a binary.</source>
          <target state="translated">Обратите внимание, что имя &lt;code&gt;Filename&lt;/code&gt; может быть списком или двоичным файлом.</target>
        </trans-unit>
        <trans-unit id="f14731d9c3c6fd3730587d810464f8a2d56ecc47" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Tracee&lt;/code&gt; must refer to a process currently or previously existing on the same node as the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; resides on. The special &lt;code&gt;Tracee&lt;/code&gt; atom &lt;code&gt;all&lt;/code&gt; denotes all processes that currently are traced in the node.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Tracee&lt;/code&gt; должна ссылаться на процесс, существующий в настоящее время или ранее на том же узле, что и вызывающий &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; . Специальный атом &lt;code&gt;Tracee&lt;/code&gt; &lt;code&gt;all&lt;/code&gt; обозначает все процессы, которые в данный момент отслеживаются в узле.</target>
        </trans-unit>
        <trans-unit id="e39772795b303f493c5e1f6ecf427eea0b844a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster according to the Unicode Standard.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;[$\r,$\n]&lt;/code&gt; - это один кластер графем в соответствии со стандартом Unicode.</target>
        </trans-unit>
        <trans-unit id="6aa2d6619dffc8bd3c3adb06ec4c9073939311ad" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;[$\r,$\n]&lt;/code&gt; - это один кластер графем.</target>
        </trans-unit>
        <trans-unit id="08897008ae2f97db9924c5cfdccc065044d13435" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;bind_address&lt;/code&gt; must be the IP address reported by function &lt;code&gt;info&lt;/code&gt; and cannot be the hostname that is allowed when putting in &lt;code&gt;bind_address&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;bind_address&lt;/code&gt; должен быть IP-адресом, указанным в &lt;code&gt;info&lt;/code&gt; о функции, и не может быть именем хоста, которое разрешено при вводе &lt;code&gt;bind_address&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c830556293b9a7bbf702aa85452de5ebbaf366" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;catch&lt;/code&gt; has low precedence and catch subexpressions often needs to be enclosed in a block expression or in parentheses:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;catch&lt;/code&gt; имеет низкий приоритет, и подвыражения catch часто необходимо заключать в выражение блока или в круглые скобки:</target>
        </trans-unit>
        <trans-unit id="bb283657c8b33fada586a3cb80cefd9a6fce3dd1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;enif_open_resource_type&lt;/code&gt; is only allowed to be called in the two callbacks &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;enif_open_resource_type&lt;/code&gt; разрешено вызывать только в двух обратных вызовах &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1773f52a457c6794f4a7d066fbfe3f05c2a765e3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;erlsrv&lt;/code&gt; is not a general service utility for Windows, but designed for embedded Erlang systems.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;erlsrv&lt;/code&gt; не является служебной программой общего назначения для Windows, а предназначена для встроенных систем Erlang.</target>
        </trans-unit>
        <trans-unit id="6e432f3e9c9e76ab03e11cf1eee130a983560aaa" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;file:read_link/1&lt;/code&gt; всегда возвращает ошибку, если ссылка указывает на недопустимое имя файла.</target>
        </trans-unit>
        <trans-unit id="2b5eb19b7b6106c9b1640932097ed40e803eee2b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt; are obeyed by Logger itself before forwarding the log events to each handler, while &lt;code&gt;formatter&lt;/code&gt; and all handler specific options are left to the handler implementation.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;level&lt;/code&gt; и &lt;code&gt;filters&lt;/code&gt; выполняются самим Logger перед пересылкой событий журнала каждому обработчику, в то время как &lt;code&gt;formatter&lt;/code&gt; и все специфические параметры обработчика оставлены на усмотрение реализации обработчика.</target>
        </trans-unit>
        <trans-unit id="dd581a406752603573ad8774cbe10adf7b5ab0d3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;n3&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;n3&lt;/code&gt; и &lt;code&gt;creation&lt;/code&gt; ограничены по точности, поэтому используются только младшие 18 и 2 бита этих чисел.</target>
        </trans-unit>
        <trans-unit id="5034ccb8d85a6d7fd7e77e33c704f31bb33968e9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;creation&lt;/code&gt; ограничены по точности, поэтому используются только младшие 18 и 2 бита этих чисел.</target>
        </trans-unit>
        <trans-unit id="8f334a2a965ad63c5f73db11176f314492958179" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; is different from &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt;; the list of one element is not identified with the element itself.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; отличается от &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt; ; список из одного элемента не отождествляется с самим элементом.</target>
        </trans-unit>
        <trans-unit id="d6bd7c1e7434d1dad6aeb762e0751cad3313447c" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary for table type &lt;code&gt;ordered_set&lt;/code&gt; and for traversals done by a single ETS function call, like &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3688c0644193c1e6416001dafdd6919064e11078" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are for buffered input/output and must &lt;strong&gt;not&lt;/strong&gt; be used for the communication with Erlang.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;stdin&lt;/code&gt; и &lt;code&gt;stdout&lt;/code&gt; предназначены для буферизованного ввода / вывода и &lt;strong&gt;не&lt;/strong&gt; должны использоваться для связи с Erlang.</target>
        </trans-unit>
        <trans-unit id="bc49c747fe59c837c18160b1da219cb9bb69f688" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; does not cause any condition to succeed. This leads to the run time error &lt;code&gt;if_clause&lt;/code&gt;, here nicely formatted by the shell. See &lt;code&gt;Guard Sequences&lt;/code&gt; for details of the many guard tests available.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; не вызывает успешного выполнения какого-либо условия. Это приводит к ошибке времени выполнения &lt;code&gt;if_clause&lt;/code&gt; , здесь красиво отформатировано оболочкой. См. &lt;code&gt;Guard Sequences&lt;/code&gt; защиты для получения подробной информации о многих доступных тестах защиты.</target>
        </trans-unit>
        <trans-unit id="d4a0e079c5d305d9ddb09850abdc7996b675aca1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;{active, true}&lt;/code&gt; mode provides no flow control; a fast sender can easily overflow the receiver with incoming messages. The same is true for &lt;code&gt;{active, N}&lt;/code&gt; mode, while the message count is greater than zero.</source>
          <target state="translated">Обратите внимание, что режим &lt;code&gt;{active, true}&lt;/code&gt; не обеспечивает управления потоком; быстрый отправитель может легко переполнить получателя входящими сообщениями. То же самое верно для режима &lt;code&gt;{active, N}&lt;/code&gt; , когда количество сообщений больше нуля.</target>
        </trans-unit>
        <trans-unit id="3d5d39b6d9eb6afa53058c47c7cffc48273fdd29" translate="yes" xml:space="preserve">
          <source>Notice that Logger automatically inserts a timestamp in the meta data unless it already exists. This function is exported for the rare case when the timestamp must be taken at a different point in time than when the log event is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da54ccbef9166436330bfc6fd162fc86bc65127" translate="yes" xml:space="preserve">
          <source>Notice that Mnesia can be connected to other nodes than those returned in &lt;code&gt;ReturnValue&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что Mnesia может быть подключен к другим узлам, кроме тех, которые возвращаются в &lt;code&gt;ReturnValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca1604ae3c36200717b82378dacc675667bae387" translate="yes" xml:space="preserve">
          <source>Notice that USM users are needed for SNMPv3 configuration and are not to be confused with users.</source>
          <target state="translated">Обратите внимание,что USM-пользователи необходимы для настройки SNMPv3 и не путайте с пользователями.</target>
        </trans-unit>
        <trans-unit id="2103331cf1bc333f91a2382aff0f9f89c72945ce" translate="yes" xml:space="preserve">
          <source>Notice that UTF-8 is &lt;strong&gt;not&lt;/strong&gt; compatible with bytewise representation for code points from 128 through 255, so an ISO Latin-1 bytewise representation is generally incompatible with UTF-8.</source>
          <target state="translated">Обратите внимание , что UTF-8 является &lt;strong&gt;не&lt;/strong&gt; совместимым с представлением однобайтного для кодовых точек от 128 до 255, так что Latin-1 побайтна представление ISO , как правило , несовместимо с UTF-8.</target>
        </trans-unit>
        <trans-unit id="4a6c1827f210e0e7a2b7f47b6b3a1bd1a9af4a39" translate="yes" xml:space="preserve">
          <source>Notice that \g{...} (Perl syntax) and \g&amp;lt;...&amp;gt; (Oniguruma syntax) are &lt;strong&gt;not&lt;/strong&gt; synonymous. The former is a back reference; the latter is a subroutine call.</source>
          <target state="translated">Обратите внимание, что \ g {...} (синтаксис Perl) и \ g &amp;lt;...&amp;gt; (синтаксис Oniguruma) &lt;strong&gt;не&lt;/strong&gt; являются синонимами. Первый - обратная ссылка; последний - вызов подпрограммы.</target>
        </trans-unit>
        <trans-unit id="8de6476a9a9e34e743ca7bda411e9e36e779275d" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_server&lt;/code&gt; process does not trap exit signals automatically, this must be explicitly initiated in the callback module.</source>
          <target state="translated">Обратите внимание, что процесс &lt;code&gt;gen_server&lt;/code&gt; не перехватывает сигналы выхода автоматически, это должно быть явно инициировано в модуле обратного вызова.</target>
        </trans-unit>
        <trans-unit id="c8c968975fc7502f69e3fa5a0ebf2c3346e29c96" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_statem&lt;/code&gt; does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;gen_statem&lt;/code&gt; не перехватывает сигналы выхода автоматически, это должно быть явно инициировано в модуле обратного вызова (путем вызова &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="755428447f434586578dae042ae0cabd4f3e660d" translate="yes" xml:space="preserve">
          <source>Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider:</source>
          <target state="translated">Обратите внимание,что условная подмаска не рассматривается как имеющая две альтернативы,так как используется только одна.То есть символ | в условной подмаскировке имеет другое значение.Игнорируя пробелы,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="88df944878b2dfd57638c11c5f3a67b0b37ab5eb" translate="yes" xml:space="preserve">
          <source>Notice that a driver binary has an internal reference counter. This means that calling &lt;code&gt;driver_free_binary&lt;/code&gt;, it may not actually dispose of it. If it is sent to the emulator, it can be referenced there.</source>
          <target state="translated">Обратите внимание, что у двоичного файла драйвера есть внутренний счетчик ссылок. Это означает, что вызывая &lt;code&gt;driver_free_binary&lt;/code&gt; , он не может фактически избавиться от него. Если он отправляется в эмулятор, на него можно ссылаться.</target>
        </trans-unit>
        <trans-unit id="e57d3be6f96e69f222e396adc45b370579e57d1d" translate="yes" xml:space="preserve">
          <source>Notice that a faked CPU topology that does not reflect how the real CPU topology looks like is likely to decrease the performance of the runtime system.</source>
          <target state="translated">Обратите внимание,что поддельная топология процессора,не отражающая реальную топологию процессора,скорее всего,снизит производительность системы времени выполнения.</target>
        </trans-unit>
        <trans-unit id="760aec758f8e9eb253ec969db2ad5ac99a17c5c4" translate="yes" xml:space="preserve">
          <source>Notice that a possessive quantifier can be used with an entire group, for example:</source>
          <target state="translated">Заметьте,что,например,притягательный квантификатор можно использовать с целой группой:</target>
        </trans-unit>
        <trans-unit id="1bc519a5e1193bcfddf9bfba3de07bc1233b4abf" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using decentralized counter groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the groups are distributed better between schedulers with this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbbc01405d36730105f83c66e9de97063c42e08" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using shared reader groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the reader groups are distributed better between schedulers.</source>
          <target state="translated">Обратите внимание, что система времени выполнения, использующая общие группы чтения, выигрывает от &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; , поскольку группы чтения лучше распределяются между планировщиками.</target>
        </trans-unit>
        <trans-unit id="b74f7fd747ff5bbe77c7879d54040bcdfa2b336e" translate="yes" xml:space="preserve">
          <source>Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.</source>
          <target state="translated">Обратите внимание,что планировщик также может быть занят,даже если операционная система запланировала выход из потока планировщика.</target>
        </trans-unit>
        <trans-unit id="1fb44615a33547638a4835f2bb25ba9f7f738524" translate="yes" xml:space="preserve">
          <source>Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</source>
          <target state="translated">Обратите внимание,что все дочерние процессы,реализованные с помощью стандартных модулей поведения OTP,автоматически придерживаются протокола выключения.</target>
        </trans-unit>
        <trans-unit id="022007469674875a658f3171e3ee5f06bc52c5ff" translate="yes" xml:space="preserve">
          <source>Notice that all eight levels can occur in the heading, not only &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;INFO&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; produces. And microseconds are added at the end of the timestamp.</source>
          <target state="translated">Обратите внимание, что в заголовке могут встречаться все восемь уровней, а не только &lt;code&gt;ERROR&lt;/code&gt; , &lt;code&gt;WARNING&lt;/code&gt; или &lt;code&gt;INFO&lt;/code&gt; , как выдает &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; . И микросекунды добавляются в конце метки времени.</target>
        </trans-unit>
        <trans-unit id="a99f104a56eef6a6e79ebf5f27128ede71470917" translate="yes" xml:space="preserve">
          <source>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</source>
          <target state="translated">Обратите внимание,что все записи в последнем фрагменте должны быть перемещены в другой фрагмент,так как весь фрагмент удаляется.</target>
        </trans-unit>
        <trans-unit id="43d4ab77c71efe5ed63400db11c28f943feb8544" translate="yes" xml:space="preserve">
          <source>Notice that all the output is received on gollum. This is because the I/O system finds out where the process is spawned from and sends all output there.</source>
          <target state="translated">Обратите внимание,что все выходные данные поступают на голлум.Это происходит потому,что система ввода/вывода выясняет,откуда берется процесс,и отправляет туда все выходные данные.</target>
        </trans-unit>
        <trans-unit id="b1caf8d4d97365e6e7817ea835b055cfc59c2108" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcf6c07d5d0261b9d60900ac2418148455d55af" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что хотя пользователь запросил привязку планировщиков, они могут молча не выполнить привязку. Чтобы проверить привязки планировщика, вызовите &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5737b0ee42e7396b1279449506400af6d4d0399" translate="yes" xml:space="preserve">
          <source>Notice that although the keyword &lt;code&gt;catch&lt;/code&gt; is used in the &lt;code&gt;try&lt;/code&gt; expression, there is not a &lt;code&gt;catch&lt;/code&gt; expression within the &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">Обратите внимание , что , хотя ключевое слово &lt;code&gt;catch&lt;/code&gt; используется в &lt;code&gt;try&lt;/code&gt; выражении, есть не &lt;code&gt;catch&lt;/code&gt; выражение в &lt;code&gt;try&lt;/code&gt; выражения.</target>
        </trans-unit>
        <trans-unit id="994f867c355c6f90c5d005f5efe72e6205d3566f" translate="yes" xml:space="preserve">
          <source>Notice that an application can always be stopped explicitly by calling &lt;code&gt;stop/1&lt;/code&gt;. Regardless of the type of the application, no other applications are affected.</source>
          <target state="translated">Обратите внимание, что приложение всегда можно остановить явным образом, вызвав &lt;code&gt;stop/1&lt;/code&gt; . Независимо от типа приложения, это не касается других приложений.</target>
        </trans-unit>
        <trans-unit id="da2ab21694a90b36239b6620bd78657b3c952a69" translate="yes" xml:space="preserve">
          <source>Notice that an event manager &lt;strong&gt;does&lt;/strong&gt; trap exit signals automatically.</source>
          <target state="translated">Обратите внимание , что менеджер событий &lt;strong&gt;делает&lt;/strong&gt; ловушку сигналы выхода автоматически.</target>
        </trans-unit>
        <trans-unit id="49dfb54eadef728066f7af6aab3f97cecf7b3fb1" translate="yes" xml:space="preserve">
          <source>Notice that an exiting port exists, but is not open.</source>
          <target state="translated">Обратите внимание,что выходной порт существует,но не открыт.</target>
        </trans-unit>
        <trans-unit id="e9791862f66b81843f5294813c5a3786cc4d5cd0" translate="yes" xml:space="preserve">
          <source>Notice that an exiting process exists, but is not alive. That is, &lt;code&gt;is_process_alive/1&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; for an exiting process, but its process identifier is part of the result returned from &lt;code&gt;processes/0&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что существующий процесс существует, но его нет. То есть &lt;code&gt;is_process_alive/1&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; для завершающегося процесса, но его идентификатор процесса является частью результата, возвращаемого &lt;code&gt;processes/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30baa54b514ae9385a376058a73878724a1d09c" translate="yes" xml:space="preserve">
          <source>Notice that any modifying operations, that is, &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt;, that are done between the &lt;code&gt;mnesia:select/4&lt;/code&gt; and &lt;code&gt;mnesia:select/1&lt;/code&gt; calls are not visible in the result.</source>
          <target state="translated">Обратите внимание, что любые операции изменения, то есть &lt;code&gt;mnesia:write&lt;/code&gt; или &lt;code&gt;mnesia:delete&lt;/code&gt; , которые выполняются между &lt;code&gt;mnesia:select/4&lt;/code&gt; и &lt;code&gt;mnesia:select/1&lt;/code&gt; , не отображаются в результате.</target>
        </trans-unit>
        <trans-unit id="96c91a61c3b4aa6acc5afde73b1f0c373cd23ed1" translate="yes" xml:space="preserve">
          <source>Notice that any process can close a port using &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">Обратите внимание, что любой процесс может закрыть порт с помощью &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; как если бы он сам был владельцем порта, но ответ всегда отправляется владельцу порта.</target>
        </trans-unit>
        <trans-unit id="d4cc8e9c5e1271318aa4ada63b47a96351832036" translate="yes" xml:space="preserve">
          <source>Notice that any process can send to a port using &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; as if it itself was the port owner.</source>
          <target state="translated">Обратите внимание, что любой процесс может отправлять на порт с помощью &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; как если бы он сам был владельцем порта.</target>
        </trans-unit>
        <trans-unit id="1824595a1c80b7075f5376bc1cd1c936c8d424db" translate="yes" xml:space="preserve">
          <source>Notice that any process can set the port owner using &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">Обратите внимание, что любой процесс может установить владельца порта с помощью &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; как если бы он сам был владельцем порта, но ответ всегда отправляется владельцу порта.</target>
        </trans-unit>
        <trans-unit id="a98b3f3c42ef6f33bfe8a7e8fccfe1473542b5f7" translate="yes" xml:space="preserve">
          <source>Notice that any tuple stored in the table must have at least &lt;code&gt;Pos&lt;/code&gt; number of elements.</source>
          <target state="translated">Обратите внимание, что любой кортеж, хранящийся в таблице, должен иметь не менее &lt;code&gt;Pos&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="dd5de2485d7d394ae933d91e2e848ae72df0affa" translate="yes" xml:space="preserve">
          <source>Notice that as a driver binary is shared by the driver and the emulator. A binary received from the emulator or sent to the emulator must not be changed by the driver.</source>
          <target state="translated">Обратите внимание,что в качестве двоичного драйвера двоичный файл совместно используется драйвером и эмулятором.Двоичный файл,полученный от эмулятора или отправленный на эмулятор,не должен изменяться драйвером.</target>
        </trans-unit>
        <trans-unit id="f889fc9740aed7e3095d419001ad1fb0ce64b212" translate="yes" xml:space="preserve">
          <source>Notice that as this is &lt;code&gt;server_transfer/5&lt;/code&gt;, it is not the same as the previous function &lt;code&gt;server_transfer/4&lt;/code&gt;. Another &lt;code&gt;keysearch&lt;/code&gt; is done on &lt;code&gt;User_List&lt;/code&gt; to find the pid of the client corresponding to fred:</source>
          <target state="translated">Обратите внимание: поскольку это &lt;code&gt;server_transfer/5&lt;/code&gt; , это не то же самое, что и предыдущая функция &lt;code&gt;server_transfer/4&lt;/code&gt; . Другой &lt;code&gt;keysearch&lt;/code&gt; выполняется в &lt;code&gt;User_List&lt;/code&gt; , чтобы найти pid клиента, соответствующего fred:</target>
        </trans-unit>
        <trans-unit id="8fe86ce5fa59a3562a829573aaf5b3dfd2379e17" translate="yes" xml:space="preserve">
          <source>Notice that bit string patterns cannot be nested.</source>
          <target state="translated">Обратите внимание,что вложенные битовые строки не могут быть вложены.</target>
        </trans-unit>
        <trans-unit id="aa80432fca6a469445d85d7dfaebe88b1a98b7f2" translate="yes" xml:space="preserve">
          <source>Notice that by passing the &lt;code&gt;positive&lt;/code&gt; modifier you will get heap allocated integers (bignums) quicker.</source>
          <target state="translated">Обратите внимание, что, передав &lt;code&gt;positive&lt;/code&gt; модификатор, вы быстрее получите целые числа, выделенные кучей (bignums).</target>
        </trans-unit>
        <trans-unit id="6a919935e37a99f7e411ad64d7426c9cc07d3818" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">Обратите внимание , что вызов (гнездовой) &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; внутри транзакции контекста наследует семантику транзакций.</target>
        </trans-unit>
        <trans-unit id="28de43964f8d0b0f5ebe0eeea1c37e096ff9f1e4" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) a &lt;code&gt;mnesia:ets&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">Обратите внимание, что вызов (вложение) &lt;code&gt;mnesia:ets&lt;/code&gt; внутри контекста транзакции наследует семантику транзакции.</target>
        </trans-unit>
        <trans-unit id="ccdf30109e045224354b9a92051a3710e7da0269" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;complex2:foo/1&lt;/code&gt; and &lt;code&gt;complex2:bar/1&lt;/code&gt; results in the tuple &lt;code&gt;{foo,X}&lt;/code&gt; or &lt;code&gt;{bar,Y}&lt;/code&gt; being sent to the &lt;code&gt;complex&lt;/code&gt; process, which codes them as binaries and sends them to the port. This means that the C program must be able to handle these two tuples.</source>
          <target state="translated">Обратите внимание , что вызов &lt;code&gt;complex2:foo/1&lt;/code&gt; и &lt;code&gt;complex2:bar/1&lt;/code&gt; приводит к кортежу &lt;code&gt;{foo,X}&lt;/code&gt; или &lt;code&gt;{bar,Y}&lt;/code&gt; , посылаемые на &lt;code&gt;complex&lt;/code&gt; процесс, который кодирует их как двоичные файлы и отправляет их в порт. Это означает, что программа C должна уметь обрабатывать эти два кортежа.</target>
        </trans-unit>
        <trans-unit id="76111f96a154ca2aa3dcd82c9fbe77397be7146e" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many children under low memory conditions can cause an out of memory exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66f156315ef693448711da956208a1b9d370baa" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">Обратите внимание,что вызов этой функции при надзоре за многими детьми в условиях нехватки памяти может привести к исключению из памяти.</target>
        </trans-unit>
        <trans-unit id="36d8020652ba123cb254176a43a2c994dabfe6c7" translate="yes" xml:space="preserve">
          <source>Notice that chunked encoding can add headers so that there are more headers in the &lt;code&gt;stream_end&lt;/code&gt; message than in &lt;code&gt;stream_start&lt;/code&gt;. When streaming to a file and the request is asynchronous, the message &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; is sent.</source>
          <target state="translated">Обратите внимание, что фрагментированное кодирование может добавлять заголовки, поэтому в сообщении &lt;code&gt;stream_end&lt;/code&gt; заголовков больше, чем в &lt;code&gt;stream_start&lt;/code&gt; . При потоковой передаче в файл и асинхронном запросе отправляется сообщение &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8eacfb231646f67a84dd48c38b3252b46ba678d6" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt; tables.</source>
          <target state="translated">Обратите внимание, что в настоящее время &lt;code&gt;ordered_set&lt;/code&gt; не поддерживается для таблиц &lt;code&gt;disc_only_copies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f86d7c1e62cac7ff19af2ed505338d552e40c3" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в настоящее время &lt;code&gt;ordered_set&lt;/code&gt; не поддерживается для &lt;code&gt;disc_only_copies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ba106fc749c03f0e8e929a856488e3fe0469ca" translate="yes" xml:space="preserve">
          <source>Notice that default option &lt;code&gt;{active, true}&lt;/code&gt; cannot be changed, for internal reasons.</source>
          <target state="translated">Обратите внимание, что параметр по умолчанию &lt;code&gt;{active, true}&lt;/code&gt; не может быть изменен по внутренним причинам.</target>
        </trans-unit>
        <trans-unit id="61f3baddeb0657db3f04655dfe751683be5006f5" translate="yes" xml:space="preserve">
          <source>Notice that deleted objects are not freed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c5bb258ea4f52af5df09054ae473cf25538fc1" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead they use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">Обратите внимание, что в распределительных сокетах запрещено использование &lt;code&gt;high_msgq_watermark&lt;/code&gt; и &lt;code&gt;low_msgq_watermark&lt;/code&gt; . Вместо этого они используют &lt;code&gt;distribution buffer busy limit&lt;/code&gt; , что является аналогичной функцией.</target>
        </trans-unit>
        <trans-unit id="8e359baa81f7be3463d30d7e81f74f0d6daa7f44" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">Обратите внимание, что в распределительных сокетах запрещено использование &lt;code&gt;high_msgq_watermark&lt;/code&gt; и &lt;code&gt;low_msgq_watermark&lt;/code&gt; . Вместо этого используйте &lt;code&gt;distribution buffer busy limit&lt;/code&gt; , которое является аналогичной функцией.</target>
        </trans-unit>
        <trans-unit id="8d5e701c93b303b29d937ac4bace336c512ed95b" translate="yes" xml:space="preserve">
          <source>Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does &lt;strong&gt;not&lt;/strong&gt; match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it does not match &quot;123abcfoo&quot;. A pattern to do that is the following:</source>
          <target state="translated">Обратите внимание, что каждое из утверждений применяется независимо в одной и той же точке в строке темы. Сначала проверяется, что все три предыдущих символа являются цифрами, а затем проверяется, что эти же три символа не являются цифрами &amp;laquo;999&amp;raquo;. Этот шаблон &lt;strong&gt;не&lt;/strong&gt; соответствует &quot;foo&quot;, которому предшествуют шесть символов, первые из которых являются цифрами, а последние три не равны &quot;999&quot;. Например, он не соответствует &amp;laquo;123abcfoo&amp;raquo;. Шаблон для этого следующий:</target>
        </trans-unit>
        <trans-unit id="5779934da069d89a75c4be1d8cdff80ec5c00bf4" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt; proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c69517c533a13ffb06612150fd12d6557f1bab" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">Обратите внимание, что очистка стека вызовов означает, что все окружающие &lt;code&gt;catch&lt;/code&gt; удаляются и должны быть повторно вставлены после гибернации. Одним из следствий этого является то, что процессы начали использовать &lt;code&gt;proc_lib&lt;/code&gt; (также косвенно, например, &lt;code&gt;gen_server&lt;/code&gt; процессов), должны использовать &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; вместо того , чтобы гарантировать , что обработчик исключений продолжает работу , когда процесс просыпается.</target>
        </trans-unit>
        <trans-unit id="c5a1bb27af980314db81c1b30e32509a27fc50e5" translate="yes" xml:space="preserve">
          <source>Notice that error handling is omitted from the code:</source>
          <target state="translated">Обратите внимание,что обработка ошибок пропущена из кода:</target>
        </trans-unit>
        <trans-unit id="ac90f95ed355ecf5e134f5c94815fdaaf2216766" translate="yes" xml:space="preserve">
          <source>Notice that every guard test has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">Обратите внимание,что каждый тест на защиту имеет ту же исходную форму,что и некоторое выражение,и представлен таким же образом,как и соответствующее выражение.</target>
        </trans-unit>
        <trans-unit id="12ac9f06be5d0c942954f11af7bd16a9c92f71af" translate="yes" xml:space="preserve">
          <source>Notice that every pattern has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">Обратите внимание,что каждый шаблон имеет ту же исходную форму,что и некоторое выражение,и представлен так же,как и соответствующее выражение.</target>
        </trans-unit>
        <trans-unit id="1dafff17410c30a74873fbb0f049fd6b36e0dd69" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_all/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d439f14c665f39e855a7716b502d1b790e81b7b" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_groups/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d44122084b22fa6c5e4d72f866f1a0cdc53879" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets this function returns only one of the socket addresses. Function &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">Обратите внимание, что для сокетов SCTP эта функция возвращает только один из адресов сокета. Функция &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; возвращает все.</target>
        </trans-unit>
        <trans-unit id="3eea76ec53bc50101ada93a2881a73a66d999f61" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets, this function returns only one of the peer addresses of the socket. Function &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">Обратите внимание, что для сокетов SCTP эта функция возвращает только один из одноранговых адресов сокета. Функция &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; возвращает все.</target>
        </trans-unit>
        <trans-unit id="8b549a78c27b0039d4ff0cb9fa34e52e88f8ae6e" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что по любой другой причине, кроме &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; или &lt;code&gt;{shutdown,Term}&lt;/code&gt; , предполагается , что процесс &lt;code&gt;gen_server&lt;/code&gt; завершился из-за ошибки, и с помощью &lt;code&gt;logger(3)&lt;/code&gt; выдается отчет об ошибке .</target>
        </trans-unit>
        <trans-unit id="0f2fde3695426d831d6f9a88359f21930dd08692" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что по любой другой причине, кроме &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; или &lt;code&gt;{shutdown,Term}&lt;/code&gt; , предполагается , что &lt;code&gt;gen_statem&lt;/code&gt; завершает работу из-за ошибки, и с помощью &lt;code&gt;logger(3)&lt;/code&gt; выдается отчет об ошибке .</target>
        </trans-unit>
        <trans-unit id="d6c994ab42bf95f015c8131e40fece01289a1526" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt; before a &lt;code&gt;mnesia:select&lt;/code&gt;. For efficiency, &lt;code&gt;NObjects&lt;/code&gt; is a recommendation only and the result can contain anything from an empty list to all available results.</source>
          <target state="translated">Обратите внимание, что для достижения наилучшей производительности следует использовать &lt;code&gt;select&lt;/code&gt; до того, как будут выполнены какие-либо операции изменения в этой таблице в той же транзакции. То есть, не используйте &lt;code&gt;mnesia:write&lt;/code&gt; или &lt;code&gt;mnesia:delete&lt;/code&gt; перед &lt;code&gt;mnesia:select&lt;/code&gt; . Для эффективности &lt;code&gt;NObjects&lt;/code&gt; - это только рекомендация, и результат может содержать что угодно, от пустого списка до всех доступных результатов.</target>
        </trans-unit>
        <trans-unit id="575b65587388a5c28bf652744375022398c20ce2" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; before a &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что для достижения наилучшей производительности следует использовать &lt;code&gt;select&lt;/code&gt; до того, как будут выполнены какие-либо операции изменения в этой таблице в той же транзакции. То есть не используйте &lt;code&gt;write&lt;/code&gt; или &lt;code&gt;delete&lt;/code&gt; перед &lt;code&gt;select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8e4ee50b8c86a9d97d28e810a76ef00e7ee22cf" translate="yes" xml:space="preserve">
          <source>Notice that for table type &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary, as calls to &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; always succeed.</source>
          <target state="translated">Обратите внимание , что для типа таблицы &lt;code&gt;ordered_set&lt;/code&gt; , &lt;code&gt;safe_fixtable/2&lt;/code&gt; не является необходимым, так как звонки на &lt;code&gt;first/1&lt;/code&gt; и &lt;code&gt;next/2&lt;/code&gt; всегда удается.</target>
        </trans-unit>
        <trans-unit id="fadf7fb473798e1c8fbe8d738e7d7fba94595b7d" translate="yes" xml:space="preserve">
          <source>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</source>
          <target state="translated">Обратите внимание,что для временных детей спецификация ребенка автоматически удаляется,когда ребенок прекращает свое существование;таким образом,перезапуск таких детей невозможен.</target>
        </trans-unit>
        <trans-unit id="b8f8d69fc55404a3f5202b0589ebb12fa1fbadb2" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; should be used when converting a string to be tested for equality.</source>
          <target state="translated">Обратите внимание, что функция &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; должна использоваться при преобразовании строки для проверки на равенство.</target>
        </trans-unit>
        <trans-unit id="405372cbb8689b7bb9d46fd60b33792430970cfc" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; can be used as help as follows:</source>
          <target state="translated">Обратите внимание, что функцию &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; можно использовать в качестве справки следующим образом:</target>
        </trans-unit>
        <trans-unit id="de0bcaa7532bb6bae36e73c3763ba087654d90d2" translate="yes" xml:space="preserve">
          <source>Notice that functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, and &lt;code&gt;chunk_step/3&lt;/code&gt; do not affect any value returned by &lt;code&gt;info/1&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что функции &lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; и &lt;code&gt;chunk_step/3&lt;/code&gt; не влияют ни на какое значение, возвращаемое &lt;code&gt;info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da3a6b0a2ad8ae3b2ff383a08f0cdcfac8ef3282" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; do not exist in the suite, &lt;code&gt;Common Test&lt;/code&gt; calls dummy functions (with the same names) instead, so that output generated by hook functions can be saved to the log files for these dummies. For details, see &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;init_per_suite&lt;/code&gt; и &lt;code&gt;end_per_suite&lt;/code&gt; не существуют в наборе, &lt;code&gt;Common Test&lt;/code&gt; вместо этого вызывает фиктивные функции (с теми же именами), так что вывод, сгенерированный функциями ловушки, может быть сохранен в файлах журнала для этих фиктивных функций. Подробнее см. &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aee52a26c1c7778ed0141e880006af8c079abe71" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;parallel_login&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, only one client at a time can be in the authentication phase.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;parallel_login&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , только один клиент одновременно может находиться в фазе аутентификации.</target>
        </trans-unit>
        <trans-unit id="e2ae74861195afaaaecbb5004aa3195b54b0af5d" translate="yes" xml:space="preserve">
          <source>Notice that if a &quot;technically built in function&quot; (that is, a function not written in Erlang) is traced, the &lt;code&gt;caller&lt;/code&gt; function sometimes returns the atom &lt;code&gt;undefined&lt;/code&gt;. The calling Erlang function is not available during such calls.</source>
          <target state="translated">Обратите внимание, что если отслеживается &amp;laquo;технически встроенная функция&amp;raquo; (то есть функция, написанная не на Erlang), &lt;code&gt;caller&lt;/code&gt; функция иногда возвращает атом &lt;code&gt;undefined&lt;/code&gt; . Вызывающая функция Erlang недоступна во время таких вызовов.</target>
        </trans-unit>
        <trans-unit id="f92e3c3fb0383592cf170b7659be5a996f925ab5" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt; parameter must not be modified.</source>
          <target state="translated">Обратите внимание, что при изменении конфигурации обработчика во время выполнения параметр &lt;code&gt;type&lt;/code&gt; изменять нельзя.</target>
        </trans-unit>
        <trans-unit id="ce90066e3aad3459d75c1fb55cecaec28fe2794d" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, or &lt;code&gt;modes&lt;/code&gt; parameters must not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ce68141a0a8640f5e5838bc1d59c39e01b55c0" translate="yes" xml:space="preserve">
          <source>Notice that if option &lt;code&gt;delayed_write&lt;/code&gt; was used when opening the file, &lt;code&gt;close/1&lt;/code&gt; can return an old write error and not even try to close the file. See &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если при открытии файла использовалась опция &lt;code&gt;delayed_write&lt;/code&gt; , команда &lt;code&gt;close/1&lt;/code&gt; может вернуть старую ошибку записи и даже не пытаться закрыть файл. См. &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f698c6b4cd9ababf8d72ba0d6e493d5ad2e7229c" translate="yes" xml:space="preserve">
          <source>Notice that if the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; are not in directory &lt;code&gt;/etc&lt;/code&gt;, the file path in the second and third command must be modified.</source>
          <target state="translated">Обратите внимание, что если файлы &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; и &lt;code&gt;syslog.conf.OTP&lt;/code&gt; не находятся в каталоге &lt;code&gt;/etc&lt;/code&gt; , путь к файлу во второй и третьей командах необходимо изменить.</target>
        </trans-unit>
        <trans-unit id="245b52374d4b97b1ff0d2029d95aaa06dad4396b" translate="yes" xml:space="preserve">
          <source>Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If &lt;code&gt;Expansions&lt;/code&gt; contains more than one property with the same key, only the first occurrence is used.</source>
          <target state="translated">Обратите внимание, что если исходный термин свойства должен быть сохранен в результате при расширении, он должен быть включен в список расширения. Вставленные термины не раскрываются рекурсивно. Если &lt;code&gt;Expansions&lt;/code&gt; содержит более одного свойства с одним и тем же ключом, используется только первое вхождение.</target>
        </trans-unit>
        <trans-unit id="bc08705bf71174fc6daf6d3117f962a241235e84" translate="yes" xml:space="preserve">
          <source>Notice that if you restore to a non-empty registry, objects in the table overwrite objects in the registry with the same keys. Also, the &lt;strong&gt;entire&lt;/strong&gt; contents of the registry is marked as unmodified after the restore, including any modified objects that were not overwritten by the restore operation. This may not be your intention.</source>
          <target state="translated">Обратите внимание, что при восстановлении в непустой реестр объекты в таблице заменяют объекты в реестре теми же ключами. Кроме того, &lt;strong&gt;все&lt;/strong&gt; содержимое реестра помечается как немодифицированное после восстановления, включая все измененные объекты, которые не были перезаписаны операцией восстановления. Возможно, это не было вашим намерением.</target>
        </trans-unit>
        <trans-unit id="aef1c34d22b7f466e6132c1e85ef582f650007b8" translate="yes" xml:space="preserve">
          <source>Notice that if you store binary objects that are context-dependent (for example, containing pointers or open file descriptors), they lose their meaning if they are backed up to a &lt;code&gt;Mnesia&lt;/code&gt; table and later restored in a different context.</source>
          <target state="translated">Обратите внимание, что если вы храните двоичные объекты, зависящие от контекста (например, содержащие указатели или дескрипторы открытых файлов), они теряют свое значение, если они копируются в таблицу &lt;code&gt;Mnesia&lt;/code&gt; , а затем восстанавливаются в другом контексте.</target>
        </trans-unit>
        <trans-unit id="c04eebf0253a2b09b02af48ec92f831c4ed73813" translate="yes" xml:space="preserve">
          <source>Notice that ignoring the return value from this function would result in an &lt;strong&gt;unreliable&lt;/strong&gt; message passing, which is contradictory to the Erlang programming model. The message is &lt;strong&gt;not&lt;/strong&gt; sent if this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что игнорирование значения, возвращаемого этой функцией, приведет к &lt;strong&gt;ненадежной&lt;/strong&gt; передаче сообщения, что противоречит модели программирования Erlang. Сообщение &lt;strong&gt;не&lt;/strong&gt; отправляется, если эта функция возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e0a7d0fec338c74c62f26d54f900722acf0e30d" translate="yes" xml:space="preserve">
          <source>Notice that in &lt;code&gt;ordered_set&lt;/code&gt; tables, the records are ordered per fragment, and the order is undefined in results returned by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;, as well as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в таблицах &lt;code&gt;ordered_set&lt;/code&gt; записи упорядочены по фрагментам, и порядок не определен в результатах, возвращаемых &lt;code&gt;select&lt;/code&gt; и &lt;code&gt;match_object&lt;/code&gt; , а также &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;prev&lt;/code&gt; и &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e87353c4be156a71ce7f89688b213b459834c505" translate="yes" xml:space="preserve">
          <source>Notice that in some cases, standard output of a command when called from another program (for example, &lt;code&gt;os:cmd/1&lt;/code&gt;) can differ, compared with the standard output of the command when called directly from an OS command shell.</source>
          <target state="translated">Обратите внимание, что в некоторых случаях стандартный вывод команды при вызове из другой программы (например, &lt;code&gt;os:cmd/1&lt;/code&gt; ) может отличаться от стандартного вывода команды при вызове непосредственно из командной оболочки ОС.</target>
        </trans-unit>
        <trans-unit id="3295423e0e8171c99eb1e9345ef25427a5a63801" translate="yes" xml:space="preserve">
          <source>Notice that in this unanchored example, the mark is retained from the match attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it.</source>
          <target state="translated">Обратите внимание,что в этом необъявленном примере метка сохраняется из попытки на матч,которая начиналась с буквы &quot;X&quot; в теме.Последующие попытки совпадения,начинающиеся с буквы &quot;P&quot;,а затем с пустой строки,не доходят до (*MARK)элемента,тем не менее,не сбрасывают его.</target>
        </trans-unit>
        <trans-unit id="9cc48f18a5b25966f4b54af3d4aabec2ba6f3d99" translate="yes" xml:space="preserve">
          <source>Notice that it did not write &quot;hello&quot; three times and then &quot;goodbye&quot; three times. Instead, the first process wrote a &quot;hello&quot;, the second a &quot;goodbye&quot;, the first another &quot;hello&quot; and so forth. But where did the &amp;lt;0.63.0&amp;gt; come from? The return value of a function is the return value of the last &quot;thing&quot; in the function. The last thing in the function &lt;code&gt;start&lt;/code&gt; is</source>
          <target state="translated">Обратите внимание, что он не написал &amp;laquo;привет&amp;raquo; три раза и затем &amp;laquo;до свидания&amp;raquo; три раза. Вместо этого первый процесс написал &amp;laquo;привет&amp;raquo;, второй - &amp;laquo;до свидания&amp;raquo;, первый - еще один &amp;laquo;привет&amp;raquo; и так далее. Но откуда взялось &amp;lt;0.63.0&amp;gt;? Возвращаемое значение функции - это возвращаемое значение последней &amp;laquo;вещи&amp;raquo; в функции. Последнее, что в &lt;code&gt;start&lt;/code&gt; функции -</target>
        </trans-unit>
        <trans-unit id="cf4175703ac6e9fdbe15e5acca7f10693ec63c07" translate="yes" xml:space="preserve">
          <source>Notice that it is also required to expand the &lt;code&gt;-export&lt;/code&gt; line with the information that there is another function &lt;code&gt;mult&lt;/code&gt; with two arguments.</source>
          <target state="translated">Обратите внимание, что также необходимо расширить строку &lt;code&gt;-export&lt;/code&gt; ,указав, что существует еще одна функция &lt;code&gt;mult&lt;/code&gt; с двумя аргументами.</target>
        </trans-unit>
        <trans-unit id="a1a5ba2084c75a9789fb8664c66476603427348b" translate="yes" xml:space="preserve">
          <source>Notice that it is always the &lt;code&gt;merge_tests&lt;/code&gt; setting in the source specification that is used when joined with other specifications. Say, for example, that a source specification A, with tests TA1 and TA2, has &lt;code&gt;{merge_tests,false}&lt;/code&gt; set, and that it includes another specification, B, with tests TB1 and TB2, that has &lt;code&gt;{merge_tests,true}&lt;/code&gt; set. The result is that the test series &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; is executed. The opposite &lt;code&gt;merge_tests&lt;/code&gt; settings would result in the test series &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что при объединении с другими спецификациями всегда &lt;code&gt;merge_tests&lt;/code&gt; параметр merge_tests в исходной спецификации. Скажем, например, что в исходной спецификации A с тестами TA1 и TA2 установлено &lt;code&gt;{merge_tests,false}&lt;/code&gt; , и что она включает другую спецификацию B с тестами TB1 и TB2, для которых установлено &lt;code&gt;{merge_tests,true}&lt;/code&gt; . В результате выполняется серия тестов &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; . Противоположные настройки &lt;code&gt;merge_tests&lt;/code&gt; приведут к &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt; серии тестов (слияние (TA1, TA2), TB1, TB2) .</target>
        </trans-unit>
        <trans-unit id="24bcac8813bad82252a8da44008063c6a9939ca8" translate="yes" xml:space="preserve">
          <source>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</source>
          <target state="translated">Обратите внимание,что грязные записи более чем в десять раз эффективнее,чем в рамках сделки.</target>
        </trans-unit>
        <trans-unit id="5fc580601d400a238482271cf80a8768aa43f791" translate="yes" xml:space="preserve">
          <source>Notice that it is normally the set of auto-imported BIFs that are referred to when talking about 'BIFs'.</source>
          <target state="translated">Обратите внимание,что обычно это набор автоматически импортируемых BIF,на которые ссылаются,когда говорят о 'BIF'.</target>
        </trans-unit>
        <trans-unit id="f48367941ecb417ce39721c36cb2f46ca431113b" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call &lt;code&gt;enif_consume_timeslice&lt;/code&gt; to determine if it is allowed to continue execution.</source>
          <target state="translated">Обратите внимание, что система времени выполнения должна определить, как использовать эту информацию. Реализации на некоторых платформах могут использовать другие средства для определения потребляемого процессорного времени. Длинные NIF должны независимо от этого часто вызывать &lt;code&gt;enif_consume_timeslice&lt;/code&gt; , чтобы определить, можно ли продолжить выполнение.</target>
        </trans-unit>
        <trans-unit id="ab3955ab8e83d7f2bb7bc498f1bd619814955ca0" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine the consumed fraction of the time-slice. Lengthy driver callbacks should, regardless of this, frequently call this function to determine if it is allowed to continue execution or not.</source>
          <target state="translated">Обратите внимание,что определение того,использовать ли эту информацию и как ее использовать,зависит от системы времени исполнения.На некоторых платформах для определения потребляемой доли времени могут использоваться другие средства.Длительные обратные вызовы драйверов должны,независимо от этого,часто вызывать эту функцию,чтобы определить,разрешено ли продолжение выполнения или нет.</target>
        </trans-unit>
        <trans-unit id="0e2ef46263bde688553324aea18d9c6d620ba48f" translate="yes" xml:space="preserve">
          <source>Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255. This function do not decode such strings, use &lt;code&gt;ei_decode_string()&lt;/code&gt; instead.</source>
          <target state="translated">Обратите внимание, что списки кодируются как строки, если они полностью состоят из целых чисел в диапазоне 0..255. Эта функция не декодирует такие строки, вместо этого используйте &lt;code&gt;ei_decode_string()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c29a9c8eeda96edcc7c5ce99dcb3efa7b2a52727" translate="yes" xml:space="preserve">
          <source>Notice that message &lt;code&gt;trace_delivered&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; imply that trace messages have been delivered. Instead it implies that all trace messages that &lt;strong&gt;are to be delivered&lt;/strong&gt; have been delivered. It is not an error if &lt;code&gt;Tracee&lt;/code&gt; is not, and has not been traced by someone, but if this is the case, &lt;strong&gt;no&lt;/strong&gt; trace messages have been delivered when the &lt;code&gt;trace_delivered&lt;/code&gt; message arrives.</source>
          <target state="translated">Обратите внимание , что сообщение &lt;code&gt;trace_delivered&lt;/code&gt; вовсе &lt;strong&gt;не&lt;/strong&gt; означает , что сообщения трассировки были доставлены. Вместо этого это означает, что все сообщения трассировки, &lt;strong&gt;которые должны быть доставлены&lt;/strong&gt; , были доставлены. Это не ошибка , если &lt;code&gt;Tracee&lt;/code&gt; нет, и не было прослежено кем - то, но если это так, то &lt;strong&gt;нет&lt;/strong&gt; трассировки сообщений не было доставлено , когда &lt;code&gt;trace_delivered&lt;/code&gt; приходит сообщение.</target>
        </trans-unit>
        <trans-unit id="013198e22f586360fbbdabe6dcc8ff964ca7ded8" translate="yes" xml:space="preserve">
          <source>Notice that most type test BIFs have older equivalents, without the &lt;code&gt;is_&lt;/code&gt; prefix. These old BIFs are retained for backwards compatibility only and are not to be used in new code. They are also only allowed at top level. For example, they are not allowed in Boolean expressions in guards.</source>
          <target state="translated">Обратите внимание, что у большинства типовых тестов BIF есть более старые эквиваленты без префикса &lt;code&gt;is_&lt;/code&gt; . Эти старые BIF сохранены только для обратной совместимости и не должны использоваться в новом коде. Они также разрешены только на верхнем уровне. Например, они не разрешены в логических выражениях в guards.</target>
        </trans-unit>
        <trans-unit id="d8a03c035117d8088ab8da75706b1955d4613585" translate="yes" xml:space="preserve">
          <source>Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards).</source>
          <target state="translated">Обратите внимание,что разрешено использовать несколько символов &quot;*&quot; (как в подстановочных знаках Unix,но в отличие от подстановочных знаков Windows/DOS).</target>
        </trans-unit>
        <trans-unit id="54221071699f0442ffc1867adb1c29b6517f290f" translate="yes" xml:space="preserve">
          <source>Notice that negative integer and float literals do not occur as such; they are parsed as an application of the unary negation operator.</source>
          <target state="translated">Обратите внимание,что отрицательные целочисленные и плавающие литералы как таковые не встречаются;они разбираются как применение унарного оператора отрицания.</target>
        </trans-unit>
        <trans-unit id="f22111bba803b0601fab83f0c4714a0a75aa87f8" translate="yes" xml:space="preserve">
          <source>Notice that no bounds checking is done on the buffer. It is the caller's responsibility to ensure that the buffer is large enough to hold the encoded terms. You can either use a static buffer that is large enough to hold the terms you expect to need in your program, or use &lt;code&gt;erl_term_len()&lt;/code&gt; to determine the exact requirements for a given term.</source>
          <target state="translated">Обратите внимание, что для буфера не выполняется проверка границ. Вызывающий объект отвечает за то, чтобы буфер был достаточно большим для хранения закодированных терминов. Вы можете либо использовать статический буфер, который достаточно велик для хранения терминов, которые, как вы ожидаете, понадобятся в вашей программе, либо использовать &lt;code&gt;erl_term_len()&lt;/code&gt; для определения точных требований для данного термина.</target>
        </trans-unit>
        <trans-unit id="68f6c800f695bdd5313479dc773780ed9ac1eaba" translate="yes" xml:space="preserve">
          <source>Notice that no deleted objects are removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">Обратите внимание,что удаленные объекты не удаляются из фиксированной таблицы до тех пор,пока она не будет освобождена.Если процесс исправляет таблицу,но никогда не освобождает ее,то память,используемая удаленными объектами,никогда не освобождается.Производительность операций с таблицей также значительно снижается.</target>
        </trans-unit>
        <trans-unit id="27077c84801a08f27f5df1e48d210573f24a2d7b" translate="yes" xml:space="preserve">
          <source>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</source>
          <target state="translated">Обратите внимание,что при выполнении программы операций записи в эти реплики не выполняется никаких операций с диском.Однако,если требуются постоянные реплики оперативной памяти,то доступны следующие альтернативы:</target>
        </trans-unit>
        <trans-unit id="0a597a819e1aa34d827c71c03375ea201eae9bbe" translate="yes" xml:space="preserve">
          <source>Notice that not all implementations support all these &lt;code&gt;Item&lt;/code&gt;s.</source>
          <target state="translated">Обратите внимание, что не все реализации поддерживают все эти &lt;code&gt;Item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b0bf74963177cf020fa41c6b9891ab9f9dfa55b" translate="yes" xml:space="preserve">
          <source>Notice that octal values &amp;gt;= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read.</source>
          <target state="translated">Обратите внимание, что восьмеричные значения&amp;gt; = 100, указанные с использованием этого синтаксиса, не должны начинаться с нуля в начале, так как когда-либо читается не более трех восьмеричных цифр.</target>
        </trans-unit>
        <trans-unit id="52b3caa006e96a4c992643ceef9a790dd9eaf91b" translate="yes" xml:space="preserve">
          <source>Notice that offsets are counted in bytes, not in characters. If the file is opened using some other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries. That is, to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position &lt;strong&gt;known&lt;/strong&gt; to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</source>
          <target state="translated">Обратите внимание, что смещения подсчитываются в байтах, а не в символах. Если файл открывается с использованием другой &lt;code&gt;encoding&lt;/code&gt; кроме &lt;code&gt;latin1&lt;/code&gt; , один байт не соответствует одному символу. Позиционирование в таком файле может быть выполнено только до известных границ символов. То есть в позицию, ранее полученную путем получения текущей позиции, в начало / конец файла или в какую-либо другую позицию, о которой &lt;strong&gt;известно,&lt;/strong&gt; что она находится на правильной границе символа другими средствами (обычно за пределами отметки порядка байтов в файле, который имеет известный размер в байтах).</target>
        </trans-unit>
        <trans-unit id="bf27ace1c7a3c2d0e720b1879eb1095858231ab1" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, this flag is only applicable for &lt;code&gt;werl&lt;/code&gt;, not &lt;code&gt;erl&lt;/code&gt; (&lt;code&gt;oldshell&lt;/code&gt;). Notice also that &lt;code&gt;Ctrl-Break&lt;/code&gt; is used instead of &lt;code&gt;Ctrl-C&lt;/code&gt; on Windows.</source>
          <target state="translated">Обратите внимание, что в Windows этот флаг применим только для &lt;code&gt;werl&lt;/code&gt; , а не для &lt;code&gt;erl&lt;/code&gt; ( &lt;code&gt;oldshell&lt;/code&gt; ). Также обратите внимание, что &lt;code&gt;Ctrl-Break&lt;/code&gt; используется вместо &lt;code&gt;Ctrl-C&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="b312389a960b6c4523a134c6d69a5e6dbd847cda" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must close the port explicitly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a6701d594a7f27b24d59d66fe69bc778606ca3" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must unregister the name explicitly:</source>
          <target state="translated">Обратите внимание, что в некоторых системах (например, VxWorks) отказавший узел не обнаруживается этим механизмом, поскольку операционная система не закрывает автоматически дескрипторы, которые остались открытыми при отказе узла. Если узел вышел из строя таким образом, &lt;code&gt;epmd&lt;/code&gt; не позволяет вам зарегистрировать новый узел со старым именем, так как считает, что старое имя все еще используется. В этом случае вы должны явно отменить регистрацию имени:</target>
        </trans-unit>
        <trans-unit id="43e1e5b7dc6da1a31388b14df1d6f6d64c3c0721" translate="yes" xml:space="preserve">
          <source>Notice that once &lt;code&gt;enif_make_resource&lt;/code&gt; creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely only on the garbage collector to deallocate the resource object eventually when it collects the term.</source>
          <target state="translated">Обратите внимание, что как только &lt;code&gt;enif_make_resource&lt;/code&gt; создает термин для возврата в Erlang, код может либо сохранить собственный собственный указатель на выделенную структуру и освободить его позже, либо немедленно освободить его и полагаться только на сборщик мусора для освобождения объекта ресурса в конечном итоге, когда он собирает термин.</target>
        </trans-unit>
        <trans-unit id="c711aa1c3890b7bd6065da8da6bc10f65058ad93" translate="yes" xml:space="preserve">
          <source>Notice that only nodes with disc are to be included in &lt;code&gt;DiscNodes&lt;/code&gt;. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</source>
          <target state="translated">Обратите внимание, что в &lt;code&gt;DiscNodes&lt;/code&gt; должны быть включены только узлы с диском . Бездисковые узлы, то есть узлы, где все таблицы, включая схему, находятся только в ОЗУ, не должны быть включены.</target>
        </trans-unit>
        <trans-unit id="67651cee75d5ac445a33e918dbfa7e4e883f716f" translate="yes" xml:space="preserve">
          <source>Notice that only one timer exists on each driver instance; setting a new timer replaces an older one.</source>
          <target state="translated">Обратите внимание,что только один таймер существует на каждом экземпляре драйвера;установка нового таймера заменяет старый.</target>
        </trans-unit>
        <trans-unit id="29d795d009d1ea7a8a290d1e73a04d2744f2a646" translate="yes" xml:space="preserve">
          <source>Notice that only schedulers online can be bound to logical processors.</source>
          <target state="translated">Обратите внимание,что только планировщики онлайн могут быть привязаны к логическим процессорам.</target>
        </trans-unit>
        <trans-unit id="f799abe642c8ae36124dcf7f5ee9ae1710bfa1f7" translate="yes" xml:space="preserve">
          <source>Notice that only tables of a certain format can be restored, that is, those that have been created and backed up to with &lt;code&gt;ei_reg_dump()&lt;/code&gt;. If the registry was not empty before the operation, the contents of the table are added to the contents of the registry. If the table contains objects with the same keys as those already in the registry, the registry objects are overwritten with the new values. If the registry contains objects that were not in the table, they are unchanged by this operation.</source>
          <target state="translated">Обратите внимание, что можно восстановить только таблицы определенного формата, то есть те, которые были созданы и &lt;code&gt;ei_reg_dump()&lt;/code&gt; с помощью ei_reg_dump () . Если до операции реестр не был пустым, содержимое таблицы добавляется к содержимому реестра. Если таблица содержит объекты с теми же ключами, что и те, которые уже находятся в реестре, объекты реестра перезаписываются новыми значениями. Если в реестре есть объекты, которых не было в таблице, они не изменяются этой операцией.</target>
        </trans-unit>
        <trans-unit id="23b04cc5100e31a53261bbb900a051cd16d9ea99" translate="yes" xml:space="preserve">
          <source>Notice that only the channel is closed. The connection is still up and can handle other channels:</source>
          <target state="translated">Обратите внимание,что закрыт только канал.Соединение все еще установлено и может работать с другими каналами:</target>
        </trans-unit>
        <trans-unit id="b15082a81f1a1a6e64b2d55298a12d9faa42eee1" translate="yes" xml:space="preserve">
          <source>Notice that only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</source>
          <target state="translated">Обратите внимание,что в Мнезии осуществляется только лексикографический заказ SNMP,а не фактический мониторинг SNMP.</target>
        </trans-unit>
        <trans-unit id="a5838dc3537f85f38eb4149ebbfa4d4cafe73f75" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. For one-to-many style sockets, the special value &lt;code&gt;0&lt;/code&gt; is defined to mean that the returned addresses must be without any particular association. How different SCTP implementations interpret this varies somewhat.</source>
          <target state="translated">Обратите внимание , что параметр &lt;code&gt;Assoc&lt;/code&gt; является по &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; определяются игнорироваться для один-к-одному розеток типа. Для сокетов стиля &amp;laquo;один ко многим&amp;raquo; определено специальное значение &lt;code&gt;0&lt;/code&gt; , означающее, что возвращаемые адреса не должны иметь какой-либо конкретной связи. То, как это интерпретируют разные реализации SCTP, несколько различается.</target>
        </trans-unit>
        <trans-unit id="d0d1f865bec9fd2105dd8d15020f4e5d9157f2b3" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. What the special value &lt;code&gt;0&lt;/code&gt; means, hence its behavior for one-to-many style sockets, is unfortunately undefined.</source>
          <target state="translated">Обратите внимание , что параметр &lt;code&gt;Assoc&lt;/code&gt; является по &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; определяются игнорироваться для один-к-одному розеток типа. Что означает специальное значение &lt;code&gt;0&lt;/code&gt; и , следовательно, его поведение для сокетов в стиле &amp;laquo;один ко многим&amp;raquo;, к сожалению, не определено.</target>
        </trans-unit>
        <trans-unit id="a961ff84865a0f166de5451a8f1bf3248cfbd6ea" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. For one-to-many style sockets, the special value &lt;code&gt;0&lt;/code&gt; is defined to mean that the returned addresses must be without any particular association. How different SCTP implementations interpret this varies somewhat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eabb91a13b84ca11eaf506a0373cba690438a9a" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. What the special value &lt;code&gt;0&lt;/code&gt; means, hence its behavior for one-to-many style sockets, is unfortunately undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ced3b5e4f7be44b8431fee61dd5559644b2a227" translate="yes" xml:space="preserve">
          <source>Notice that postponing buttons from the &lt;code&gt;open&lt;/code&gt; state to the &lt;code&gt;locked&lt;/code&gt; state feels like a strange thing to do for a code lock, but it at least illustrates event postponing.</source>
          <target state="translated">Обратите внимание, что перенос кнопок из &lt;code&gt;open&lt;/code&gt; состояния в &lt;code&gt;locked&lt;/code&gt; состояние кажется странным для кодовой блокировки, но это, по крайней мере, иллюстрирует перенос события.</target>
        </trans-unit>
        <trans-unit id="1c4f96f83f897de68ba3692f859901f16bc8520d" translate="yes" xml:space="preserve">
          <source>Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see &lt;code&gt;code/3&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что очистка кода означает, что любые процессы, оставшиеся в старом коде для модуля, завершаются без предупреждения. Для получения дополнительной информации см. &lt;code&gt;code/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c423ca269e9c8da0681587c3e65b43e4f6fcac32" translate="yes" xml:space="preserve">
          <source>Notice that relaxed command checking must enabled for the &lt;code&gt;epmd&lt;/code&gt; daemon contacted. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect.</source>
          <target state="translated">Обратите внимание, что для демона &lt;code&gt;epmd&lt;/code&gt; необходимо включить упрощенную проверку команд . При запуске &lt;code&gt;epmd&lt;/code&gt; в интерактивном режиме &lt;code&gt;-relaxed_command_check&lt;/code&gt; не действует.</target>
        </trans-unit>
        <trans-unit id="c9c86576f8186edb080a192562941feff98f7212" translate="yes" xml:space="preserve">
          <source>Notice that request for multiple parts of a document report a size of zero to the log file.</source>
          <target state="translated">Обратите внимание,что запрос нескольких частей документа сообщает размер нуля в лог-файле.</target>
        </trans-unit>
        <trans-unit id="e599e5f12a452819b319876058461d934b52f083" translate="yes" xml:space="preserve">
          <source>Notice that setting this value to &lt;code&gt;0&lt;/code&gt; does not turn of rotation. It only specifies that no archives are kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4443c6286a90c15343a889185dfe1fff15bfc5fd" translate="yes" xml:space="preserve">
          <source>Notice that settings saved by Erlang/OTP R16B01 or later cannot be read by Erlang/OTP R16B or earlier.</source>
          <target state="translated">Обратите внимание,что настройки,сохраненные Erlang/OTP R16B01 или более поздней версией,не могут быть прочитаны Erlang/OTP R16B или более ранней версией.</target>
        </trans-unit>
        <trans-unit id="649ed4989f050a560c2834e24c160ce1f14f0aab" translate="yes" xml:space="preserve">
          <source>Notice that since variables starting with an underscore are not anonymous, this matches:</source>
          <target state="translated">Обратите внимание,что поскольку переменные,начинающиеся с символа подчеркивания,не являются анонимными,это совпадает:</target>
        </trans-unit>
        <trans-unit id="d7a8cf550209c24a879718ffa59fcc7fbdaebab0" translate="yes" xml:space="preserve">
          <source>Notice that some system-internal events can also be received. Therefore a catch-all clause last in the definition of the event handler callback function &lt;code&gt;Module:handle_event/2&lt;/code&gt; is necessary. This also applies for &lt;code&gt;Module:handle_info/2&lt;/code&gt;, as the event handler must also take care of some system-internal messages.</source>
          <target state="translated">Обратите внимание, что также могут быть получены некоторые внутренние события системы. Следовательно, необходимо последнее предложение в определении функции обратного вызова обработчика событий &lt;code&gt;Module:handle_event/2&lt;/code&gt; . Это также относится к &lt;code&gt;Module:handle_info/2&lt;/code&gt; , так как обработчик событий также должен заботиться о некоторых внутренних сообщениях системы.</target>
        </trans-unit>
        <trans-unit id="4523f125f7da0a280c62ef57a22e6c4002553475" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;bin_opt_info&lt;/code&gt; is not meant to be a permanent option added to your &lt;code&gt;Makefile&lt;/code&gt;s, because all messages that it generates cannot be eliminated. Therefore, passing the option through the environment is in most cases the most practical approach.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;bin_opt_info&lt;/code&gt; не предназначен для постоянной опции, добавляемой в ваши &lt;code&gt;Makefile&lt;/code&gt; , потому что все сообщения, которые он генерирует, не могут быть удалены. Поэтому передача опции через среду в большинстве случаев является наиболее практичным подходом.</target>
        </trans-unit>
        <trans-unit id="9f25de8ce6849112886fde44cc358ca27b801415" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;get_until&lt;/code&gt; request allows for a function with the data specified as always being a list. Also, the return value data from such a function can be of any type (as is indeed the case when an &lt;code&gt;io:fread/2,3&lt;/code&gt; request is sent to an I/O server). The client must be prepared for data received as answers to those requests to be in various forms. However, the I/O server is to convert the results to binaries whenever possible (that is, when the function supplied to &lt;code&gt;get_until&lt;/code&gt; returns a list). This is done in the example in section &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что запрос &lt;code&gt;get_until&lt;/code&gt; разрешает функцию с указанными данными как всегда в виде списка. Кроме того, данные возвращаемого значения из такой функции могут быть любого типа (как это действительно бывает, когда на сервер ввода-вывода отправляется запрос &lt;code&gt;io:fread/2,3&lt;/code&gt; ). Клиент должен быть готов к тому, что данные, полученные в ответ на эти запросы, будут представлены в различных формах. Однако сервер ввода-вывода должен преобразовывать результаты в двоичные файлы, когда это возможно (то есть, когда функция, предоставленная &lt;code&gt;get_until&lt;/code&gt; , возвращает список). Это сделано в примере в разделе &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="869fe53220efffa9f2648be8687be1af3cac2f73" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;pid()&lt;/code&gt; of the I/O server is not explicitly present in tuple &lt;code&gt;io_reply&lt;/code&gt;. The reply can be sent from any process, not necessarily the actual I/O server.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;pid()&lt;/code&gt; сервера ввода-вывода явно не присутствует в кортеже &lt;code&gt;io_reply&lt;/code&gt; . Ответ может быть отправлен любым процессом, не обязательно фактическим сервером ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="f9bf7bd1d2a63adf57d1dd61e3e2c636ef718d87" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;start_link&lt;/code&gt; functions of the different behavior modules fulfill the above requirements.</source>
          <target state="translated">Обратите внимание, что функции &lt;code&gt;start_link&lt;/code&gt; различных модулей поведения удовлетворяют указанным выше требованиям.</target>
        </trans-unit>
        <trans-unit id="438a7860299a64ed5669574b6efede437e192860" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message can be the result of the link, but can also be the result of &lt;code&gt;Id&lt;/code&gt; calling &lt;code&gt;exit/2&lt;/code&gt;. Therefore, it &lt;strong&gt;can&lt;/strong&gt; be appropriate to clean up the message queue when trapping exits after the call to &lt;code&gt;unlink(Id)&lt;/code&gt;, as follows:</source>
          <target state="translated">Обратите внимание, что сообщение &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; может быть результатом ссылки, но также может быть результатом вызова &lt;code&gt;exit/2&lt;/code&gt; &lt;code&gt;Id&lt;/code&gt; . Следовательно, &lt;strong&gt;может&lt;/strong&gt; оказаться целесообразным очистить очередь сообщений при выходе из перехвата после вызова &lt;code&gt;unlink(Id)&lt;/code&gt; следующим образом:&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7d3b1ac2fe8c40d5c296cb9508ac5b63294a0ef" translate="yes" xml:space="preserve">
          <source>Notice that the BOM for UTF-8 is seldom used, and it is really not a &lt;strong&gt;byte order&lt;/strong&gt; mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.</source>
          <target state="translated">Обратите внимание, что спецификация для UTF-8 используется редко, и на самом деле это не метка &lt;strong&gt;порядка байтов&lt;/strong&gt; . Очевидно, что в UTF-8 нет проблем с порядком байтов, поэтому спецификация предназначена только для того, чтобы отличать кодировку UTF-8 от других форматов UTF.</target>
        </trans-unit>
        <trans-unit id="60ba36aa64236926d8fc38d4a0caadafb0e955a8" translate="yes" xml:space="preserve">
          <source>Notice that the C program is in a &lt;code&gt;while&lt;/code&gt;-loop, checking for the return value of &lt;code&gt;read_cmd/1&lt;/code&gt;. This is because the C program must detect when the port closes and terminates.</source>
          <target state="translated">Обратите внимание , что программа С в &lt;code&gt;while&lt;/code&gt; -loop, проверка возвращаемого значения &lt;code&gt;read_cmd/1&lt;/code&gt; . Это связано с тем, что программа C должна определять, когда порт закрывается и завершается.</target>
        </trans-unit>
        <trans-unit id="a63c691118a268393e4b6c047b61976f9f09e5f5" translate="yes" xml:space="preserve">
          <source>Notice that the Kernel variable &lt;code&gt;inetrc&lt;/code&gt; overrides this environment variable.</source>
          <target state="translated">Обратите внимание, что переменная ядра &lt;code&gt;inetrc&lt;/code&gt; переопределяет эту переменную среды.</target>
        </trans-unit>
        <trans-unit id="998c3bd807afb787e85df818d68896568ab1dac7" translate="yes" xml:space="preserve">
          <source>Notice that the above handler does not have any overload protection, and all log events are printed directly from the client process.</source>
          <target state="translated">Обратите внимание,что вышеуказанный обработчик не имеет никакой защиты от перегрузок,и все события журнала распечатываются непосредственно из клиентского процесса.</target>
        </trans-unit>
        <trans-unit id="5b06b14e5057923df74530d889d86c130c4599fb" translate="yes" xml:space="preserve">
          <source>Notice that the above specification does not restrict the input and output type in any way. These types can be constrained by guard-like subtype constraints and provide bounded quantification:</source>
          <target state="translated">Обратите внимание,что вышеуказанная спецификация никоим образом не ограничивает тип входа и выхода.Эти типы могут быть ограничены подтипами,подобными гарантовым,и обеспечивают ограниченное количественное определение:</target>
        </trans-unit>
        <trans-unit id="ffeb1c6cbb53bd413a17d7e4afa253b27c7a4334" translate="yes" xml:space="preserve">
          <source>Notice that the apparently similar pattern</source>
          <target state="translated">Обратите внимание,что похожая картина</target>
        </trans-unit>
        <trans-unit id="1865e3416dbeb17876187856aa08e4b5f4f9fd78" translate="yes" xml:space="preserve">
          <source>Notice that the application version specifies a source code version. One more, indirect, requirement is that the installed binary application of the specified version is built so that it is compatible with the rest of the system.</source>
          <target state="translated">Обратите внимание,что в версии приложения указана версия исходного кода.Еще одно косвенное требование состоит в том,чтобы установленное двоичное приложение указанной версии было собрано так,чтобы оно было совместимо с остальной частью системы.</target>
        </trans-unit>
        <trans-unit id="12430644918a731bc0331cb307bf4502fd57f823" translate="yes" xml:space="preserve">
          <source>Notice that the argument is a list with exactly one, two, or three arguments. &lt;code&gt;NameType&lt;/code&gt; defaults to &lt;code&gt;longnames&lt;/code&gt; and &lt;code&gt;Ticktime&lt;/code&gt; to &lt;code&gt;15000&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что аргумент - это список с одним, двумя или тремя аргументами. &lt;code&gt;NameType&lt;/code&gt; умолчанию для &lt;code&gt;longnames&lt;/code&gt; &lt;code&gt;Ticktime&lt;/code&gt; имена, а для Ticktime - &lt;code&gt;15000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e51fbbc05a639063fcd094a483d069e3e71d424" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this function for an SCTP one-to-many style socket is not defined by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что поведение этой функции для сокета типа &amp;laquo;один ко многим&amp;raquo; &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; не определяется расширениями API сокетов SCTP .</target>
        </trans-unit>
        <trans-unit id="a0a189752d90b470976b913f35dc97e3e7697503" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this function for an SCTP one-to-many style socket is not defined by the &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2695495d90a21bfbc215e48f946c97c1557c57eb" translate="yes" xml:space="preserve">
          <source>Notice that the compiler does not generate encode/decode functions for parameterized types, only for the instances of the parameterized types. Therefore, if a file contains the types &lt;code&gt;General{}&lt;/code&gt;, &lt;code&gt;T1&lt;/code&gt;, and &lt;code&gt;T2&lt;/code&gt; as in the previous example, encode/decode functions are only generated for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что компилятор не генерирует функции кодирования / декодирования для параметризованных типов, только для экземпляров параметризованных типов. Следовательно, если файл содержит типы &lt;code&gt;General{}&lt;/code&gt; , &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; , как в предыдущем примере, функции кодирования / декодирования создаются только для &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4bdb273ffa02e13186dc2814d4167dbf9f7eac3" translate="yes" xml:space="preserve">
          <source>Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed).</source>
          <target state="translated">Обратите внимание,что текущий ключ хранится в драйвере и может быть недействительным (например,если ключ был удален).</target>
        </trans-unit>
        <trans-unit id="3425e12704f1ae2e3dac5bdc4405aa18192ba618" translate="yes" xml:space="preserve">
          <source>Notice that the default options for TCP/IP sockets can be changed with the Kernel configuration parameters mentioned in the beginning of this manual page.</source>
          <target state="translated">Обратите внимание,что опции по умолчанию для TCP/IP сокетов могут быть изменены с помощью параметров конфигурации ядра,упомянутых в начале этой страницы руководства.</target>
        </trans-unit>
        <trans-unit id="8735534cfeef989ea973a36967fd6073321a2a23" translate="yes" xml:space="preserve">
          <source>Notice that the definition of type &lt;code&gt;SET OF&lt;/code&gt; implies that the order of the components is undefined, but in practice there is no difference between &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt;. The ASN.1 compiler for Erlang does not randomize the order of the &lt;code&gt;SET OF&lt;/code&gt; components before encoding.</source>
          <target state="translated">Обратите внимание, что определение типа &lt;code&gt;SET OF&lt;/code&gt; подразумевает, что порядок компонентов не определен, но на практике нет разницы между &lt;code&gt;SET OF&lt;/code&gt; и &lt;code&gt;SEQUENCE OF&lt;/code&gt; . Компилятор ASN.1 для Erlang не рандомизирует порядок компонентов &lt;code&gt;SET OF&lt;/code&gt; перед кодированием.</target>
        </trans-unit>
        <trans-unit id="85ee2b1beef42dfc51c38d1bdc5c48413f6418d8" translate="yes" xml:space="preserve">
          <source>Notice that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count. For example, consider the following pattern when &lt;code&gt;extended&lt;/code&gt; is set, and the default newline convention is in force:</source>
          <target state="translated">Обратите внимание, что конец этого типа комментария - это буквальная последовательность новой строки в шаблоне; escape-последовательности, которые представляют новую строку, не учитываются. Например, рассмотрите следующий шаблон, когда установлен &lt;code&gt;extended&lt;/code&gt; , и действует соглашение о новой строке по умолчанию:</target>
        </trans-unit>
        <trans-unit id="59c9761a4423dc8ba33d258174c0d7deb92180da" translate="yes" xml:space="preserve">
          <source>Notice that the file encoding options specified when opening a file has nothing to do with the filename encoding convention. You can very well open files containing data encoded in UTF-8, but having filenames in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding or conversely.</source>
          <target state="translated">Обратите внимание, что параметры кодировки файла, указанные при открытии файла, не имеют ничего общего с соглашением о кодировке имени файла. Вы можете очень хорошо открывать файлы, содержащие данные в кодировке UTF-8, но имеющие имена файлов в побайтной ( &lt;code&gt;latin1&lt;/code&gt; ) кодировке или наоборот.</target>
        </trans-unit>
        <trans-unit id="54b730627c759c2237c6a38f6ac21fcf1d73b83e" translate="yes" xml:space="preserve">
          <source>Notice that the filesystem containing the virtual machine executable (&lt;code&gt;beam.smp&lt;/code&gt; in the example) must be local, mounted without flag &lt;code&gt;nosetuid&lt;/code&gt;, support extended attributes, and the kernel must support file capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except that SCTP sockets appear to not support network namespaces.</source>
          <target state="translated">Обратите внимание, что файловая система, содержащая исполняемый файл виртуальной машины ( в примере &lt;code&gt;beam.smp&lt;/code&gt; ), должна быть локальной, монтироваться без флага &lt;code&gt;nosetuid&lt;/code&gt; , поддерживать расширенные атрибуты, а ядро ​​должно поддерживать возможности файлов. Все это запускается из коробки по крайней мере в Ubuntu 12.04 LTS, за исключением того, что сокеты SCTP не поддерживают сетевые пространства имен.</target>
        </trans-unit>
        <trans-unit id="856dd98224a317941549fceec575ed693a862a3b" translate="yes" xml:space="preserve">
          <source>Notice that the function &lt;code&gt;add_frag/2&lt;/code&gt; is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</source>
          <target state="translated">Обратите внимание, что функция &lt;code&gt;add_frag/2&lt;/code&gt; запускается один раз для каждого из других фрагментов (кроме номера 1) как часть процедуры создания таблицы.</target>
        </trans-unit>
        <trans-unit id="71fbea88394343530b7ae5da050f337473550603" translate="yes" xml:space="preserve">
          <source>Notice that the function can return &lt;code&gt;true&lt;/code&gt; for a module that in fact is not interpretable in the case where the module is marked as sticky or resides in a directory marked as sticky. The reason is that this is not discovered until the interpreter tries to load the module.</source>
          <target state="translated">Обратите внимание, что функция может возвращать значение &lt;code&gt;true&lt;/code&gt; для модуля, который фактически не интерпретируется в случае, когда модуль помечен как закрепленный или находится в каталоге, отмеченном как закрепленный. Причина в том, что это не обнаруживается, пока интерпретатор не попытается загрузить модуль.</target>
        </trans-unit>
        <trans-unit id="fc5ff5fc0775ca18d960b27958c2c310603beba9" translate="yes" xml:space="preserve">
          <source>Notice that the functions below perform an RPC using an open file descriptor provided by the caller. This file descriptor must not be used for other traffic during the global operation, as the function can then receive unexpected data and fail.</source>
          <target state="translated">Обратите внимание,что функции,перечисленные ниже,выполняют RPC,используя открытый файловый дескриптор,предоставляемый вызывающим абонентом.Этот файловый дескриптор не должен использоваться для другого трафика во время глобальной операции,так как в этом случае функция может получить неожиданные данные и выйти из строя.</target>
        </trans-unit>
        <trans-unit id="6344e9ae1d5d7f5e3378303250cff912dbc2282d" translate="yes" xml:space="preserve">
          <source>Notice that the history of the last trace is always available in file &lt;code&gt;ttb_last_config&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что история последней трассировки всегда доступна в файле &lt;code&gt;ttb_last_config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b4c212a61f0bb3f68fad2d68b59100bb913758e" translate="yes" xml:space="preserve">
          <source>Notice that the information returned is highly implementation-dependent and can be changed or removed at any time without prior notice. It was initially intended as a tool when developing new allocators, but as it can be of interest for others it has been briefly documented.</source>
          <target state="translated">Обратите внимание,что возвращаемая информация в значительной степени зависит от реализации и может быть изменена или удалена в любое время без предварительного уведомления.Первоначально она задумывалась как инструмент при разработке новых распределителей,но поскольку она может представлять интерес для других,она была вкратце документирована.</target>
        </trans-unit>
        <trans-unit id="ed442d55f4c83cba3d99e636fc5b3b8fb144e267" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eec770c656034420f67e24636825b21ba0fb080" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что целочисленное значение используется только внутри Logger. В API вы всегда должны использовать атом. Чтобы сравнить серьезность двух уровней журнала, используйте &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="913c6778d3ce72fc842456abadbdcd4a41900bd7" translate="yes" xml:space="preserve">
          <source>Notice that the last created atom is shown first.</source>
          <target state="translated">Обратите внимание,что первым показывается последний созданный атом.</target>
        </trans-unit>
        <trans-unit id="e6ee884138fcccc998b14a68323c7c49e44297a2" translate="yes" xml:space="preserve">
          <source>Notice that the last element in the &lt;code&gt;Request&lt;/code&gt; tuple (&lt;code&gt;[$\n]&lt;/code&gt;) is appended to the argument list when the function is called. The function is to be called like &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; by the I/O server.</source>
          <target state="translated">Обратите внимание, что последний элемент в кортеже &lt;code&gt;Request&lt;/code&gt; ( &lt;code&gt;[$\n]&lt;/code&gt; ) добавляется к списку аргументов при вызове функции. Функция должна вызываться сервером ввода-вывода как &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65e13b0553b24c92ba77e668391c89bbfe7c5f62" translate="yes" xml:space="preserve">
          <source>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что последняя часть - это &amp;laquo;ang&amp;raquo;, а не &amp;laquo;an&amp;raquo;, поскольку разделение было задано на две части, и разделение останавливается, когда дано достаточное количество частей, поэтому результат отличается от результата &lt;code&gt;trim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b0de072daf08ddb3bed5b003d16bec94ec3f838" translate="yes" xml:space="preserve">
          <source>Notice that the match context in &lt;code&gt;my_binary_to_list/1&lt;/code&gt; was discarded when the entire binary had been traversed. What happens if the iteration stops before it has reached the end of the binary? Will the optimization still work?</source>
          <target state="translated">Обратите внимание, что контекст совпадения в &lt;code&gt;my_binary_to_list/1&lt;/code&gt; был отброшен, когда был пройден весь двоичный файл. Что произойдет, если итерация остановится до того, как достигнет конца двоичного файла? Будет ли оптимизация работать?</target>
        </trans-unit>
        <trans-unit id="2d19f8166370c4661429c3cee25b80ade4ba9fb7" translate="yes" xml:space="preserve">
          <source>Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</source>
          <target state="translated">Обратите внимание,что порядок возвращаемых объектов не определен.В частности,порядок,в который вставлялись объекты,не отражается.</target>
        </trans-unit>
        <trans-unit id="90ee8d6704f5ea8a8da9ff5e648eb8db8d5bce43" translate="yes" xml:space="preserve">
          <source>Notice that the program resides in the emulator's &lt;code&gt;bin&lt;/code&gt; directory, not in the &lt;code&gt;bin&lt;/code&gt; directory directly under the Erlang root. The reasons for this are the subtle problem of upgrading the emulator on a running system, where a new version of the runtime system should not need to overwrite existing (and probably used) executables.</source>
          <target state="translated">Обратите внимание, что программа находится в каталоге &lt;code&gt;bin&lt;/code&gt; эмулятора , а не в каталоге &lt;code&gt;bin&lt;/code&gt; непосредственно под корнем Erlang. Причины этого - незаметная проблема обновления эмулятора в работающей системе, когда в новой версии исполняющей системы не должно быть необходимости перезаписывать существующие (и, возможно, используемые) исполняемые файлы.</target>
        </trans-unit>
        <trans-unit id="78b612195b425463060bd89b2b5fb48b2b6bc32f" translate="yes" xml:space="preserve">
          <source>Notice that the program runs slower if the data is located on a remote node.</source>
          <target state="translated">Обратите внимание,что программа работает медленнее,если данные находятся на удаленном узле.</target>
        </trans-unit>
        <trans-unit id="7527eddb37622ef5514d8dac4dc37568ecec15bd" translate="yes" xml:space="preserve">
          <source>Notice that the range &lt;code&gt;0..Range-1&lt;/code&gt; is different from the range of &lt;code&gt;phash/2&lt;/code&gt;, which is &lt;code&gt;1..Range&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что диапазон &lt;code&gt;0..Range-1&lt;/code&gt; отличается от диапазона &lt;code&gt;phash/2&lt;/code&gt; , который равен &lt;code&gt;1..Range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f5b1145658a0a3e84e5b5e128d226a353a792a5" translate="yes" xml:space="preserve">
          <source>Notice that the record name is the table name even when &lt;code&gt;record_name&lt;/code&gt; has another setting.</source>
          <target state="translated">Обратите внимание, что имя записи - это имя таблицы, даже если &lt;code&gt;record_name&lt;/code&gt; имеет другой параметр.</target>
        </trans-unit>
        <trans-unit id="f556bad20e55c532b765ee625a5af6afc2bd2580" translate="yes" xml:space="preserve">
          <source>Notice that the regular expression must match the complete version string, so this example works for, for example, &lt;code&gt;2.1.1&lt;/code&gt;, but not for &lt;code&gt;2.1.1.1&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что регулярное выражение должно соответствовать полной строке версии, поэтому этот пример работает, например, для &lt;code&gt;2.1.1&lt;/code&gt; , но не для &lt;code&gt;2.1.1.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88bf6f27cbb64880bfd54716d99abab3e050207e" translate="yes" xml:space="preserve">
          <source>Notice that the risk of loosing log events grows when the &lt;code&gt;file_check&lt;/code&gt; value grows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b783e1e390dc485584c1f74b3ed69a29fd778c4" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eea6a747947fcb8f655a220c818e740e96ba5d5" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что применяются те же предостережения, что и для &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe10cacd28855d9196c579eb8146305f91e16641" translate="yes" xml:space="preserve">
          <source>Notice that the sequences \A, \Z, and \z can be used to match the start and end of the subject in both modes. If all branches of a pattern start with \A, it is always anchored, regardless if &lt;code&gt;multiline&lt;/code&gt; is set.</source>
          <target state="translated">Обратите внимание, что последовательности \ A, \ Z и \ z могут использоваться для сопоставления начала и конца темы в обоих режимах. Если все ветви шаблона начинаются с \ A, он всегда привязан, независимо от того, установлена ​​ли &lt;code&gt;multiline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6724f506b54877b36a23e88d5de227a00d37732a" translate="yes" xml:space="preserve">
          <source>Notice that the shorthand for &lt;code&gt;list()&lt;/code&gt;, that is, the list of elements of unknown type, is &lt;code&gt;[_]&lt;/code&gt; (or &lt;code&gt;[any()]&lt;/code&gt;), not &lt;code&gt;[]&lt;/code&gt;. The notation &lt;code&gt;[]&lt;/code&gt; specifies the singleton type for the empty list.</source>
          <target state="translated">Обратите внимание, что сокращение для &lt;code&gt;list()&lt;/code&gt; , то есть списка элементов неизвестного типа, - это &lt;code&gt;[_]&lt;/code&gt; (или &lt;code&gt;[any()]&lt;/code&gt; ), а не &lt;code&gt;[]&lt;/code&gt; . Обозначение &lt;code&gt;[]&lt;/code&gt; указывает одноэлементный тип для пустого списка.</target>
        </trans-unit>
        <trans-unit id="73dac804c8d0ac669ce6f4344962d4b5c34961af" translate="yes" xml:space="preserve">
          <source>Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented.</source>
          <target state="translated">Обратите внимание,что структуры данных управления пространством,хранящиеся в оперативной памяти,системе &quot;приятель&quot;,также записываются на диск.Это может занять некоторое время,если таблица фрагментирована.</target>
        </trans-unit>
        <trans-unit id="2158fd0c30567923e783ca815a320fc6fd564c3e" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt; erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0e9479e312465b9ff5d6f711d535a3e0101b4" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что сумма этих значений &lt;strong&gt;не&lt;/strong&gt; является общим объемом памяти, выделенной эмулятором. Некоторые значения являются частью других значений, а некоторые области памяти не являются частью результата. Для получения информации об общем объеме памяти, выделенной эмулятором, см. &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5abbe6d966c5fc1edc96d1f28f1436c4958c4e8" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (or &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt;), not &lt;code&gt;#{}&lt;/code&gt;. The notation &lt;code&gt;#{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">Обратите внимание, что синтаксическим представлением &lt;code&gt;map()&lt;/code&gt; является &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (или &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt; ), а не &lt;code&gt;#{}&lt;/code&gt; . Обозначение &lt;code&gt;#{}&lt;/code&gt; определяет одноэлементный тип для пустой карты.</target>
        </trans-unit>
        <trans-unit id="d2c453c4a61a93e0e17811bf7efe3b048abd12f0" translate="yes" xml:space="preserve">
          <source>Notice that the template is here the same as for &lt;code&gt;single_line=false&lt;/code&gt;, but the resulting log entry differs in that there is only one line after the heading:</source>
          <target state="translated">Обратите внимание, что шаблон здесь тот же, что и для &lt;code&gt;single_line=false&lt;/code&gt; , но результирующая запись журнала отличается тем, что после заголовка есть только одна строка:</target>
        </trans-unit>
        <trans-unit id="1a0dfecdaad1fda603fa4229f911e862d71765b6" translate="yes" xml:space="preserve">
          <source>Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on.</source>
          <target state="translated">Обратите внимание,что сохраняется временной порядок вставок объектов;первый объект,вставленный с указанным ключом,является первым в результирующем списке,и так далее.</target>
        </trans-unit>
        <trans-unit id="6f7067f925d0363a33444938455ac91fcd09edfb" translate="yes" xml:space="preserve">
          <source>Notice that the use of an &lt;code&gt;.inetrc&lt;/code&gt; file, which was supported in earlier Erlang/OTP versions, is now obsolete.</source>
          <target state="translated">Обратите внимание, что использование файла &lt;code&gt;.inetrc&lt;/code&gt; , которое поддерживалось в более ранних версиях Erlang / OTP, теперь устарело.</target>
        </trans-unit>
        <trans-unit id="b338a89eefab229871069c1f47956c10a1d50274" translate="yes" xml:space="preserve">
          <source>Notice that the value fed into the selective decode functions must be a binary.</source>
          <target state="translated">Обратите внимание,что значение,подаваемое в функции селективного декодирования,должно быть двоичным.</target>
        </trans-unit>
        <trans-unit id="787fd319d83681555c07f1a96ca590fc08523120" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;;&quot; before &lt;code&gt;end&lt;/code&gt;. Conditions do the same as guards, that is, tests that succeed or fail. Erlang starts at the top and tests until it finds a condition that succeeds. Then it evaluates (performs) the action following the condition and ignores all other conditions and actions before the &lt;code&gt;end&lt;/code&gt;. If no condition matches, a run-time failure occurs. A condition that always succeeds is the atom &lt;code&gt;true&lt;/code&gt;. This is often used last in an &lt;code&gt;if&lt;/code&gt;, meaning, do the action following the &lt;code&gt;true&lt;/code&gt; if all other conditions have failed.</source>
          <target state="translated">Обратите внимание, что нет &quot;;&quot; до &lt;code&gt;end&lt;/code&gt; . Условия делают то же самое, что и охранники, т. Е. Успешные или неудачные тесты. Erlang начинает сверху и проверяет, пока не найдет условие, которое завершится успешно. Затем он оценивает (выполняет) действие, следующее за условием, и игнорирует все остальные условия и действия до его &lt;code&gt;end&lt;/code&gt; . Если ни одно из условий не соответствует, происходит сбой времени выполнения. Состояние, которое всегда выполняется, - это &lt;code&gt;true&lt;/code&gt; атом . Это часто используется последним в &lt;code&gt;if&lt;/code&gt; , что означает выполнение действия, следующего за &lt;code&gt;true&lt;/code&gt; если все другие условия не выполнены.</target>
        </trans-unit>
        <trans-unit id="c7902b9db4b62c4e9204bea0b7582aa107cd80a6" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;condition variable wait with time-out&quot; in the Erlang driver thread API. This because of issues with &lt;code&gt;pthread_cond_timedwait&lt;/code&gt;. When the system clock suddenly is changed, it is not always guaranteed that you will wake up from the call as expected. An Erlang runtime system must be able to cope with sudden changes of the system clock. Therefore, we have omitted it from the Erlang driver thread API. In the Erlang driver case, time-outs can and are to be handled with the timer functionality of the Erlang driver API.</source>
          <target state="translated">Обратите внимание, что в API потока драйвера Erlang нет &amp;laquo;ожидания переменной условия с тайм-аутом&amp;raquo;. Это из-за проблем с &lt;code&gt;pthread_cond_timedwait&lt;/code&gt; . Когда системные часы внезапно меняются, не всегда гарантируется, что вы проснетесь от вызова, как ожидалось. Система времени выполнения Erlang должна уметь справляться с внезапными изменениями системных часов. Поэтому мы исключили его из API потока драйвера Erlang. В случае драйвера Erlang тайм-ауты могут и должны обрабатываться с помощью функции таймера API драйвера Erlang.</target>
        </trans-unit>
        <trans-unit id="bceb9f4f6a6abdf1446e121be361b43261feb62c" translate="yes" xml:space="preserve">
          <source>Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt;. The default owner is the process that created the table. To transfer table ownership at process termination, use option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; or call &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что для таблиц нет автоматической сборки мусора. Даже если нет ссылок на таблицу из какого-либо процесса, она не уничтожается автоматически, если не завершится процесс-владелец. Чтобы явно уничтожить таблицу, используйте функцию &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; . Владелец по умолчанию - это процесс, создавший таблицу. Чтобы передать владение таблицей при завершении процесса, используйте опцию &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; или вызовите &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bab5c018b3dd7779861d18a2de3b850779eed22" translate="yes" xml:space="preserve">
          <source>Notice that these results are highly implementation-specific and can change in a future release.</source>
          <target state="translated">Обратите внимание,что эти результаты весьма специфичны для реализации и могут измениться в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="869e22e1f3c3acbe1295f4e3f5e543c0967d43d9" translate="yes" xml:space="preserve">
          <source>Notice that these values are not guaranteed to be the exact time spent in each state. This is because of various optimisation done to keep the overhead as small as possible.</source>
          <target state="translated">Обратите внимание,что эти значения не гарантируют точное время,проведенное в каждом штате.Это связано с различной оптимизацией,сделанной для того,чтобы накладные расходы были как можно меньше.</target>
        </trans-unit>
        <trans-unit id="1b2a4c91cbe5e730d179e66ad334733cf9b2f315" translate="yes" xml:space="preserve">
          <source>Notice that this can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control).</source>
          <target state="translated">Обратите внимание,что это может привести к переполнению очереди сообщений,так как в этом случае нет возможности дросселировать отправителя (отсутствует управление потоком).</target>
        </trans-unit>
        <trans-unit id="65c845a0c39116c9a8667488291653cb120ecdb8" translate="yes" xml:space="preserve">
          <source>Notice that this code never uses &lt;code&gt;ets:match/2&lt;/code&gt; but instead uses the &lt;code&gt;ets:lookup/2&lt;/code&gt; call. The &lt;code&gt;lists:map/2&lt;/code&gt; call is only used to traverse the &lt;code&gt;idno&lt;/code&gt;s matching the name &quot;Bryan&quot; in the table; thus the number of lookups in the master table is minimized.</source>
          <target state="translated">Обратите внимание, что этот код никогда не использует &lt;code&gt;ets:match/2&lt;/code&gt; , а вместо этого использует вызов &lt;code&gt;ets:lookup/2&lt;/code&gt; . &lt;code&gt;lists:map/2&lt;/code&gt; вызова используется только для обхода &lt;code&gt;idno&lt;/code&gt; s соответствия имени &amp;laquo;Bryan&amp;raquo; в таблице; таким образом, количество поисков в главной таблице сводится к минимуму.</target>
        </trans-unit>
        <trans-unit id="642ed222441e7d274dce20239475afe796aa6f92" translate="yes" xml:space="preserve">
          <source>Notice that this does not in any way tell how characters are to be put on the I/O device or handled by the I/O server. Different I/O servers can handle the characters however they want, this only tells the I/O server which format the data is expected to have. In the &lt;code&gt;Module&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt;/&lt;code&gt;Args&lt;/code&gt; case, &lt;code&gt;Encoding&lt;/code&gt; tells which format the designated function produces.</source>
          <target state="translated">Обратите внимание, что это никоим образом не говорит о том, как символы должны быть помещены на устройство ввода-вывода или обработаны сервером ввода-вывода. Различные серверы ввода-вывода могут обрабатывать символы по своему усмотрению, это только сообщает серверу ввода-вывода, какой формат данных ожидается. В &lt;code&gt;Module&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; / &lt;code&gt;Args&lt;/code&gt; случае &lt;code&gt;Encoding&lt;/code&gt; указывает , какой формат назначенная функция производит.</target>
        </trans-unit>
        <trans-unit id="349cea6fe5b002efa6f13c8a0b6d61002518bac7" translate="yes" xml:space="preserve">
          <source>Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section &lt;code&gt;Changing a Supervisor&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">Обратите внимание, что эту функцию также можно вызвать как часть процедуры обновления кода. Следовательно, функция не должна иметь побочных эффектов. Для получения дополнительной информации об обновлении кода супервизоров см. Раздел &amp;laquo; &lt;code&gt;Changing a Supervisor&lt;/code&gt; в Принципах разработки OTP.</target>
        </trans-unit>
        <trans-unit id="d5a602977aaafafa43a23557b7310cdf92b1e9ad" translate="yes" xml:space="preserve">
          <source>Notice that this function does not affect option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; of the table. A table owner can, for example, set &lt;code&gt;heir&lt;/code&gt; to itself, give the table away, and then get it back if the receiver terminates.</source>
          <target state="translated">Обратите внимание, что эта функция не влияет на опцию &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; таблицы. Владелец таблицы может, например, назначить себе &lt;code&gt;heir&lt;/code&gt; , отдать таблицу, а затем вернуть ее, если приемник завершает работу.</target>
        </trans-unit>
        <trans-unit id="0cb54426795679095e8a29fd043a79047773a14e" translate="yes" xml:space="preserve">
          <source>Notice that this function does not manipulate the Logger configuration directly, meaning that if the default Logger handler is already logging to a file, this function can potentially cause logging to a second file.</source>
          <target state="translated">Обратите внимание,что эта функция не управляет напрямую конфигурацией Журнала,а это означает,что если обработчик Журнала по умолчанию уже ведет журнал в файл,то эта функция потенциально может привести к записи журнала во второй файл.</target>
        </trans-unit>
        <trans-unit id="8b7b1e720e05da028ebe3dc53213402e40544038" translate="yes" xml:space="preserve">
          <source>Notice that this function is &lt;strong&gt;not&lt;/strong&gt; thread-safe, not even when the emulator with SMP support is used.</source>
          <target state="translated">Обратите внимание, что эта функция &lt;strong&gt;не&lt;/strong&gt; является потокобезопасной, даже если используется эмулятор с поддержкой SMP.</target>
        </trans-unit>
        <trans-unit id="8447f5b25cdb8a2cfab1f25034c52ae944a2138b" translate="yes" xml:space="preserve">
          <source>Notice that this function is located in the &lt;code&gt;Erl_Interface&lt;/code&gt; library.</source>
          <target state="translated">Обратите внимание, что эта функция находится в библиотеке &lt;code&gt;Erl_Interface&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47ba6495ef0d28a812199229a1ffda8befe21e10" translate="yes" xml:space="preserve">
          <source>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</source>
          <target state="translated">Обратите внимание,что эта функция должна использоваться только для подключения к вновь запускаемым узлам оперативной памяти (N.D.R.S.N.)с пустой схемой.Если,например,эта функция используется после разметки сети,это может привести к несовместимым таблицам.</target>
        </trans-unit>
        <trans-unit id="2a0080e2dd941529f19011486ca16886c12b3f0d" translate="yes" xml:space="preserve">
          <source>Notice that this identifier on occations has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but to keep backward compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">Обратите внимание,что этот идентификатор на инцидентах называется &quot;имя&quot;.Насколько это возможно,теперь используются термины &quot;идентификатор&quot; или &quot;id&quot;,но для сохранения обратной совместимости некоторые случаи &quot;name&quot; все же могут быть найдены,например,в сообщениях об ошибках.</target>
        </trans-unit>
        <trans-unit id="d730d26eb5bc6c258ec3f4a85decab69ff65e557" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; equivalent to reversing the result list of a &lt;code&gt;select/3&lt;/code&gt; call, as the result list is not only reversed, but also contains the last &lt;code&gt;Limit&lt;/code&gt; matching objects in the table, not the first.</source>
          <target state="translated">Обратите внимание, что это &lt;strong&gt;не&lt;/strong&gt; эквивалентно переворачиванию списка результатов вызова &lt;code&gt;select/3&lt;/code&gt; , поскольку список результатов не только инвертируется, но также содержит последние объекты сопоставления &lt;code&gt;Limit&lt;/code&gt; в таблице, а не первые.</target>
        </trans-unit>
        <trans-unit id="70914725ae02a1a2e612f1b985dfda4ff43284f0" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.11.4.</source>
          <target state="translated">Обратите внимание, что это &lt;strong&gt;не&lt;/strong&gt; гарантируется для версий ядра до 2.11.4.</target>
        </trans-unit>
        <trans-unit id="7dcda89d0c9ebc603749979d693cfd0901ccfd8f" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.13.</source>
          <target state="translated">Обратите внимание, что это &lt;strong&gt;не&lt;/strong&gt; гарантируется для версий ядра до 2.13.</target>
        </trans-unit>
        <trans-unit id="ebcfa6b14e436143f912db1c4d94b897ad5c396b" translate="yes" xml:space="preserve">
          <source>Notice that this is a snapshot of what the entries are exactly when the crash dump is starting to be generated. Therefore they are most likely different (and more telling) than the entries for the same processes found in the &lt;strong&gt;=proc&lt;/strong&gt; section. If there is no currently running process, only the &lt;strong&gt;Current Process&lt;/strong&gt; entry is shown.</source>
          <target state="translated">Обратите внимание, что это моментальный снимок того, что именно представляют собой записи в момент начала создания аварийного дампа. Поэтому они, скорее всего, отличаются (и более информативны), чем записи для тех же процессов, найденные в разделе &lt;strong&gt;= proc&lt;/strong&gt; . Если в данный момент запущенного процесса нет, отображается только запись &amp;laquo; &lt;strong&gt;Текущий процесс&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6b5fe898d5908bd62ba390154dbda59785193315" translate="yes" xml:space="preserve">
          <source>Notice that this list was so long that it did not fit on one line. This does not matter, Erlang allows line breaks at all &quot;sensible places&quot; but not, for example, in the middle of atoms, integers, and others.</source>
          <target state="translated">Обратите внимание,что этот список был настолько длинным,что не помещался на одной строке.Это не имеет значения,Эрланг допускает перерывы строк во всех &quot;разумных местах&quot;,но не,например,в середине атомов,целых чисел и других.</target>
        </trans-unit>
        <trans-unit id="bed5f26c2d951298be832ad680fbfcde5f6d0366" translate="yes" xml:space="preserve">
          <source>Notice that this only affects &lt;strong&gt;heuristic&lt;/strong&gt; interpretation of lists and binaries on output. For example, the &lt;code&gt;~ts&lt;/code&gt; format sequence always outputs a valid list of characters, regardless of the &lt;code&gt;+pc&lt;/code&gt; setting, as the programmer has explicitly requested string output.</source>
          <target state="translated">Обратите внимание, что это влияет только на &lt;strong&gt;эвристическую&lt;/strong&gt; интерпретацию списков и двоичных файлов на выходе. Например, последовательность формата &lt;code&gt;~ts&lt;/code&gt; всегда выводит допустимый список символов, независимо от настройки &lt;code&gt;+pc&lt;/code&gt; , поскольку программист явно запросил вывод строки.</target>
        </trans-unit>
        <trans-unit id="06bbb7eb9157769ac232caf919df5223a21c5714" translate="yes" xml:space="preserve">
          <source>Notice that this option does not change any guarantees about &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt;. Functions that makes such promises over many objects (like &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt;) gain less (or nothing) from this option.</source>
          <target state="translated">Обратите внимание, что этот параметр не меняет никаких гарантий относительно &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt; . Функции, которые выполняют такие обещания для многих объектов (например, &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; ), получают меньше (или ничего) от этого параметра.</target>
        </trans-unit>
        <trans-unit id="621939df6e7634c47047d2e081590d78eaf11831" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a &quot;.&quot; saying that there are no more parts of this function.</source>
          <target state="translated">Обратите внимание,что эта часть заканчивается на &quot;...&quot;,говоря,что больше нет частей этой функции.</target>
        </trans-unit>
        <trans-unit id="e6c419f8334737f0ba7bd3fd865a876302c62640" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a semicolon &quot;;&quot; that indicates that there is more of the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; to come.</source>
          <target state="translated">Обратите внимание, что эта часть заканчивается точкой с запятой &quot;;&quot; это указывает на то, что впереди еще больше функций &lt;code&gt;fac&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="846082f1f38f9d35784642322c9bebfb5b6dff1c" translate="yes" xml:space="preserve">
          <source>Notice that this state diagram does not specify how to handle a button event in the state &lt;code&gt;open&lt;/code&gt;. So, you need to read in some side notes, that is, here: that unspecified events shall be postponed (handled in some later state). Also, the state diagram does not show that the &lt;code&gt;code_length/0&lt;/code&gt; call must be handled in every state.</source>
          <target state="translated">Обратите внимание, что эта диаграмма состояний не указывает, как обрабатывать событие кнопки в &lt;code&gt;open&lt;/code&gt; состоянии . Итак, вам нужно прочитать в некоторых примечаниях, то есть здесь: что неуказанные события должны быть отложены (обработаны в более позднем состоянии). Кроме того, диаграмма состояний не показывает, что &lt;code&gt;code_length/0&lt;/code&gt; должен обрабатываться в каждом состоянии.</target>
        </trans-unit>
        <trans-unit id="6d7cfe9a38358e1080d2e905013781b2b4b7296d" translate="yes" xml:space="preserve">
          <source>Notice that type &lt;code&gt;ordered_set&lt;/code&gt; in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage.</source>
          <target state="translated">Обратите внимание, что тип &lt;code&gt;ordered_set&lt;/code&gt; в Ets еще не предоставляется Dets, как и ограниченная поддержка одновременных обновлений, которая делает последовательность &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; вызовов безопасной для использования в фиксированных таблицах ETS. Обе эти функции могут быть предоставлены Dets в будущих версиях Erlang / OTP. До тех пор для реализации безопасного параллелизма необходимо использовать приложение Mnesia (или какой-либо реализованный пользователем метод блокировки). В настоящее время ни одна библиотека Erlang / OTP не поддерживает упорядоченное хранение терминов на диске.</target>
        </trans-unit>
        <trans-unit id="49a7a915aea8e9d41179a8ea113e08f2ef1a2887" translate="yes" xml:space="preserve">
          <source>Notice that we only return data (with &lt;code&gt;driver_output&lt;/code&gt;) if there is an error here, otherwise we wait for the connection to be completed, in which case our &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">Обратите внимание, что мы возвращаем данные (с &lt;code&gt;driver_output&lt;/code&gt; ) только в том случае, если здесь есть ошибка, в противном случае мы ждем завершения подключения, и в этом случае &lt;code&gt;ready_io&lt;/code&gt; наша функция ready_io .</target>
        </trans-unit>
        <trans-unit id="ecb8672fadbd7174fe3603f747f5dd084a5c8a1f" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt; Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51f3b121bba411146620bcda978e5f491550a29" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что при вызове локальной функции существует разница между использованием неявного или полного имени функции. Последнее всегда относится к последней версии модуля. См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f8b34f22954b45969704565ba857ede0360296a" translate="yes" xml:space="preserve">
          <source>Notice that when changing the configuration of the handler in runtime, the disk_log options (&lt;code&gt;file&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;max_no_files&lt;/code&gt;, &lt;code&gt;max_no_bytes&lt;/code&gt;) must not be modified.</source>
          <target state="translated">Обратите внимание, что при изменении конфигурации обработчика во время выполнения параметры disk_log ( &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;max_no_files&lt;/code&gt; , &lt;code&gt;max_no_bytes&lt;/code&gt; ) не должны изменяться.</target>
        </trans-unit>
        <trans-unit id="290de7804d4ece9b07b182bd6263d67e874d7ab3" translate="yes" xml:space="preserve">
          <source>Notice that when manipulating the PLT, no warnings are emitted. To turn on warnings during (re)analysis of the PLT, use option &lt;code&gt;--get_warnings&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что при манипулировании PLT предупреждения не выдаются. Чтобы включить предупреждения во время (повторного) анализа PLT, используйте опцию &lt;code&gt;--get_warnings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45a6c9cf395e353cb2306cbfdb89cfe2d26435a1" translate="yes" xml:space="preserve">
          <source>Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a &lt;code&gt;hibernate&lt;/code&gt; request for the whole event manager to go into hibernation.</source>
          <target state="translated">Обратите внимание, что при вызове нескольких обработчиков событий достаточно, чтобы один единственный обработчик событий возвращал запрос &lt;code&gt;hibernate&lt;/code&gt; чтобы весь менеджер событий перешел в спящий режим.</target>
        </trans-unit>
        <trans-unit id="f33a5a292b9691e53af0ea35251a90bd5b70c0ab" translate="yes" xml:space="preserve">
          <source>Notice that when the restart strategy is &lt;code&gt;simple_one_for_one&lt;/code&gt;, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если стратегия перезапуска - &lt;code&gt;simple_one_for_one&lt;/code&gt; , список дочерних спецификаций должен быть списком только с одной дочерней спецификацией. (Идентификатор спецификации дочернего элемента игнорируется.) Затем на этапе инициализации дочерний процесс не запускается, но предполагается, что все &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt; запускаются динамически с использованием start_child / 2 .</target>
        </trans-unit>
        <trans-unit id="9634bd19d38caf45acf63a0abbac721e5ae1181a" translate="yes" xml:space="preserve">
          <source>Notice that you do not have to worry about the order you assign values to the various parts of the records when you create it. The advantage of using records is that by placing their definitions in header files you can conveniently define interfaces that are easy to change. For example, if you want to add a new field to the record, you only have to change the code where the new field is used and not at every place the record is referred to. If you leave out a field when creating a record, it gets the value of the atom &lt;code&gt;undefined&lt;/code&gt;. (*manual*)</source>
          <target state="translated">Обратите внимание, что вам не нужно беспокоиться о порядке присваивания значений различным частям записи при ее создании. Преимущество использования записей заключается в том, что, помещая их определения в файлы заголовков, вы можете удобно определять интерфейсы, которые легко изменить. Например, если вы хотите добавить новое поле к записи, вам нужно только изменить код, в котором используется новое поле, а не во всех местах, где упоминается запись. Если вы не укажете поле при создании записи, значение атома будет &lt;code&gt;undefined&lt;/code&gt; . (*руководство*)</target>
        </trans-unit>
        <trans-unit id="11459bdda73f31f4f445b7c1dd521d4fd85a0493" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator characters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of tokens.</source>
          <target state="translated">Обратите внимание, что, как показано в этом примере, два или более соседних символа-разделителя в &lt;code&gt;String&lt;/code&gt; обрабатываются как один. То есть в результирующем списке токенов нет пустых строк.</target>
        </trans-unit>
        <trans-unit id="e5f78a295d4a14f6cc590b49dc6f1d0455cd3aab" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator graphemes clusters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; which returns empty strings.</source>
          <target state="translated">Обратите внимание, что, как показано в этом примере, два или более соседних кластера графем-разделителей в &lt;code&gt;String&lt;/code&gt; обрабатываются как один. То есть в результирующем списке лексем нет пустых строк. См. Также &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; , который возвращает пустые строки.</target>
        </trans-unit>
        <trans-unit id="400b0bdc7183dd864f7a333eda26b469890b40f9" translate="yes" xml:space="preserve">
          <source>Notice that, for example, using a string literal as in &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что, например, использование строкового литерала в &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; является синтаксическим сахаром для &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87029cbee6aaa0d9b300e7ad0b9486370e279d2c" translate="yes" xml:space="preserve">
          <source>Notice that, using the binary syntax in Erlang, the driver application can match the header directly from the binary, so the header can be put in the binary, and &lt;code&gt;hlen&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что, используя двоичный синтаксис в Erlang, приложение-драйвер может сопоставить заголовок непосредственно с двоичным &lt;code&gt;hlen&lt;/code&gt; , поэтому заголовок можно поместить в двоичный файл, а для hlen можно установить значение &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7da0c41f09ad9eda092e8aa0b243d52520a156af" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;--&lt;/code&gt; delimiter in the second case.</source>
          <target state="translated">Обратите внимание на разделитель &lt;code&gt;--&lt;/code&gt; во втором случае.</target>
        </trans-unit>
        <trans-unit id="0a1c8d08a9994e288f56b821c9bf285da6f45d73" translate="yes" xml:space="preserve">
          <source>Notice the following:</source>
          <target state="translated">Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="d17e22e8a0b70553ac1713fc5aa1e39228341be7" translate="yes" xml:space="preserve">
          <source>Notice the introduction of decimals (floating point numbers) without any explanation. Hopefully you can cope with that.</source>
          <target state="translated">Обратите внимание на введение десятичных цифр (чисел с плавающей точкой)без каких-либо объяснений.Надеюсь,вы справитесь с этим.</target>
        </trans-unit>
        <trans-unit id="b434bf92c1158275f129698bacaf4280054d4c1a" translate="yes" xml:space="preserve">
          <source>Notice the order, the &lt;code&gt;&lt;a href=&quot;uri_string#normalize-2&quot;&gt;uri_string:normalize(URIMap, [return_map])&lt;/a&gt;&lt;/code&gt; that we used many times in this user guide is a shortcut in the normalization process returning the intermediate datastructure, and allowing us to inspect and apply further decoding on the remaining percent-encoded triplets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22b470f990ba70d08ad30ea4441dbab4491e4f1" translate="yes" xml:space="preserve">
          <source>Notice the subtle difference between &lt;strong&gt;matching&lt;/strong&gt; and &lt;strong&gt;comparing equal&lt;/strong&gt;, which is demonstrated by table types &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;ordered_set&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание на тонкую разницу между &lt;strong&gt;сопоставлением&lt;/strong&gt; и &lt;strong&gt;сравнением равных&lt;/strong&gt; , что демонстрируется типами таблиц &lt;code&gt;set&lt;/code&gt; и &lt;code&gt;ordered_set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e087413bca56723a464e980cdc7148c95c96c9f5" translate="yes" xml:space="preserve">
          <source>Notice the tags &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, which are used in the cover specification file and in the call to &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt;. The purpose of these is only to map the modules specified in the cover specification to the log directory specified in the call to the analyze function. The tag name has no meaning beyond this.</source>
          <target state="translated">Обратите внимание на теги &lt;code&gt;s1&lt;/code&gt; и &lt;code&gt;s2&lt;/code&gt; , которые используются в файле спецификации обложки и в вызове &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt; . Их цель - только отобразить модули, указанные в спецификации обложки, в каталог журналов, указанный в вызове функции анализа. Имя тега не имеет другого значения.</target>
        </trans-unit>
        <trans-unit id="7bb5bf565c03d21576042d149b51f71aca7f2ad7" translate="yes" xml:space="preserve">
          <source>Notice the use of brackets, the multiplication operator &quot;*&quot;, and the division operator &quot;/&quot;, as in normal arithmetic (see &lt;code&gt;Expressions&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание на использование скобок, оператора умножения &amp;laquo;*&amp;raquo; и оператора деления &amp;laquo;/&amp;raquo;, как в обычной арифметике (см. &lt;code&gt;Expressions&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1979d8b27f27698155a9b9f97c8dffec78cf1316" translate="yes" xml:space="preserve">
          <source>Notice there is no &quot;;&quot; before the &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &quot;;&quot; до &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b65c33941f0cec9bcc2027c063047fa6bab510b7" translate="yes" xml:space="preserve">
          <source>Notice, however, that the PCRE interpretation of \G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior.</source>
          <target state="translated">Заметьте,однако,что интерпретация PCRE сайта \G,как начало текущего матча,тонко отличается от интерпретации Perl,которая определяет его как конец предыдущего матча.В Perl они могут отличаться,если ранее сопоставленная строка была пустой.Так как PCRE делает только одно совпадение за раз,она не может воспроизвести такое поведение.</target>
        </trans-unit>
        <trans-unit id="741d95219191f3fd87708b3b502f3129d86f5b91" translate="yes" xml:space="preserve">
          <source>Notification Filters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc912e028896fb2120e68a26a7e2cec85b39064" translate="yes" xml:space="preserve">
          <source>Notification Sending</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37be39660f9e3a6ee200e243af96a9c97d0d2344" translate="yes" xml:space="preserve">
          <source>Notifications are defined in SMIv1 with the TRAP-TYPE macro in the definition of an MIB (see RFC1215). The corresponding macro in SMIv2 is NOTIFICATION-TYPE. When an application decides to send a notification, it calls one of the following functions:</source>
          <target state="translated">Уведомления определяются в SMIv1 с помощью макроса TRAP-TYPE в определении MIB (см.RFC1215).Соответствующий макрос в SMIv2 является ТИПом УВЕДОМЛЕНИЯ.Когда приложение решает отправить уведомление,оно вызывает одну из следующих функций:</target>
        </trans-unit>
        <trans-unit id="ac878d4197ecf46f67e006f7c94c70eec1e149de" translate="yes" xml:space="preserve">
          <source>Notifications/traps from an agent is delivered to the user that did the registration.</source>
          <target state="translated">Уведомления/-ловушки от агента доставляются пользователю,который произвел регистрацию.</target>
        </trans-unit>
        <trans-unit id="317ade20c16481c20d662a3475f005419790a5e3" translate="yes" xml:space="preserve">
          <source>Notifies when the driver is reloaded (or loaded if loading is underway). It only makes sense to monitor drivers that are in the process of being loaded or reloaded. A future driver name for loading cannot be monitored. That only results in a &lt;code&gt;DOWN&lt;/code&gt; message sent immediately. Monitoring for loading is therefore most useful when triggered by function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;, where the monitor is created &lt;strong&gt;because&lt;/strong&gt; the driver is in such a pending state.</source>
          <target state="translated">Уведомляет, когда драйвер перезагружается (или загружается, если идет загрузка). Имеет смысл отслеживать только те драйверы, которые находятся в процессе загрузки или перезагрузки. Следить за будущим именем драйвера для загрузки невозможно. Это приводит только к немедленной отправке сообщения &lt;code&gt;DOWN&lt;/code&gt; . Поэтому мониторинг загрузки наиболее полезен при &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; функцией try_load / 3 , где монитор создается, &lt;strong&gt;потому&lt;/strong&gt; что драйвер находится в таком состоянии ожидания.</target>
        </trans-unit>
        <trans-unit id="bb6282907337e9abaf6ab3833a675724d09d4658" translate="yes" xml:space="preserve">
          <source>Now &quot;Stack needed&quot; and &quot;Heap needed&quot; are in the same word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819549857bd0aea6faaa47a0d86a011bee67d2a5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;A&lt;/code&gt; has generated a digest and its own challenge. Those are sent together in a package to &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">Теперь &lt;code&gt;A&lt;/code&gt; создал дайджест и свою задачу. Они отправляются вместе в пакете &lt;code&gt;B&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="70500b06f7a8c7563bdbdac912b202c3e8bf3468" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex1:foo/1&lt;/code&gt; and &lt;code&gt;complex1:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following replies:</source>
          <target state="translated">Теперь можно &lt;code&gt;complex1:foo/1&lt;/code&gt; и &lt;code&gt;complex1:bar/1&lt;/code&gt; . Оба отправляют сообщение &lt;code&gt;complex&lt;/code&gt; процессу и получают следующие ответы:</target>
        </trans-unit>
        <trans-unit id="afe7e60fc725dac4a8db204c6383ede32658e8ba" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex5:foo/1&lt;/code&gt; and &lt;code&gt;complex5:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following reply:</source>
          <target state="translated">Теперь можно &lt;code&gt;complex5:foo/1&lt;/code&gt; и &lt;code&gt;complex5:bar/1&lt;/code&gt; . Оба отправляют сообщение &lt;code&gt;complex&lt;/code&gt; процессу и получают следующий ответ:</target>
        </trans-unit>
        <trans-unit id="1d972f3ac97809e6ef3b16135443e10b7f75eb60" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;format_temps(Rest)&lt;/code&gt; is called with the rest of the list as an argument. This way of doing things is similar to the loop constructs in other languages. (Yes, this is recursion, but do not let that worry you.) So the same &lt;code&gt;format_temps&lt;/code&gt; function is called again, this time &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; and the same procedure is repeated as before. This is done until the list becomes empty, that is [], which causes the first clause &lt;code&gt;format_temps([])&lt;/code&gt; to match. This simply returns (results in) the atom &lt;code&gt;ok&lt;/code&gt;, so the program ends.</source>
          <target state="translated">Теперь &lt;code&gt;format_temps(Rest)&lt;/code&gt; с остальной частью списка в качестве аргумента. Этот способ работы аналогичен конструкциям цикла в других языках. (Да, это рекурсия, но пусть это вас не беспокоит.) Итак, та же функция &lt;code&gt;format_temps&lt;/code&gt; вызывается снова, на этот раз &lt;code&gt;City&lt;/code&gt; получает значение &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; и повторяется та же процедура, что и раньше. Это выполняется до тех пор, пока список не станет пустым, то есть [], что приводит к совпадению первого предложения &lt;code&gt;format_temps([])&lt;/code&gt; . Это просто возвращает (приводит) атом в &lt;code&gt;ok&lt;/code&gt; , поэтому программа завершается.</target>
        </trans-unit>
        <trans-unit id="f056c1e349914f861b0ec8d256143b66ef033fa2" translate="yes" xml:space="preserve">
          <source>Now Peter logs on at c1@bilbo:</source>
          <target state="translated">Теперь Питер входит в систему c1@bilbo:</target>
        </trans-unit>
        <trans-unit id="3ad12f32c3c04aabc045c91300983e1a4fd664c4" translate="yes" xml:space="preserve">
          <source>Now Peter sends Fred a message:</source>
          <target state="translated">Теперь Питер посылает Фреду сообщение:</target>
        </trans-unit>
        <trans-unit id="229ad98b8db4a57370d88832d5c57bc6f3753fe1" translate="yes" xml:space="preserve">
          <source>Now a function has to be added to find the cities with the maximum and minimum temperatures. The following program is not the most efficient way of doing this as you walk through the list of cities four times. But it is better to first strive for clarity and correctness and to make programs efficient only if needed.</source>
          <target state="translated">Теперь необходимо добавить функцию поиска городов с максимальной и минимальной температурой.Следующая программа не является наиболее эффективным способом сделать это,так как вы пройдете по списку городов четыре раза.Но лучше сначала стремиться к ясности и корректности и делать программы эффективными только в случае необходимости.</target>
        </trans-unit>
        <trans-unit id="b4bcc5baaf2e6bf86762a62f818283a767c38c4d" translate="yes" xml:space="preserve">
          <source>Now an &lt;code&gt;ETERM&lt;/code&gt; struct that represents the integer result can be constructed using the function &lt;code&gt;erl_mk_int()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;. The function &lt;code&gt;erl_format()&lt;/code&gt; from the module &lt;code&gt;erl_format&lt;/code&gt; can also be used:</source>
          <target state="translated">Теперь структура &lt;code&gt;ETERM&lt;/code&gt; , представляющая целочисленный результат, может быть создана с помощью функции &lt;code&gt;erl_mk_int()&lt;/code&gt; из &lt;code&gt;erl_eterm&lt;/code&gt; . Также можно использовать функцию &lt;code&gt;erl_format()&lt;/code&gt; из модуля &lt;code&gt;erl_format&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d18575f2f97b95d7041b4a039a472881d09e334" translate="yes" xml:space="preserve">
          <source>Now an example of the ping pong example using links to terminate &quot;pong&quot;:</source>
          <target state="translated">Теперь пример пинг-понга с использованием ссылок для завершения &quot;пинг-понга&quot;:</target>
        </trans-unit>
        <trans-unit id="b5cee5cfc515b6296349cc8ee7e0cb8ec6901dca" translate="yes" xml:space="preserve">
          <source>Now an example of this when working with lists - reversing the order of a list:</source>
          <target state="translated">Теперь пример этого при работе со списками-изменение порядка следования списка:</target>
        </trans-unit>
        <trans-unit id="df7fd43be1dfcb89d9363916c80f74e8a91feb79" translate="yes" xml:space="preserve">
          <source>Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of calls. If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of calls (M1, M2) such that the interpretation of the expression contains a call from some function of M1 to some function of M2. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all function calls (F1, F2) such that the interpretation of the expression contains a call (M1, M2) and F1 is a function of M1 and F2 is a function of M2 (in &lt;code&gt;modules&lt;/code&gt; mode, there are no functions calls, so a cast to &lt;code&gt;Fun&lt;/code&gt; always yields an empty set). Again, the conversions to and from applications and releases work analogously.</source>
          <target state="translated">Теперь предположим, что интерпретация &lt;code&gt;Expression&lt;/code&gt; - это набор вызовов. Если именованный тип более общий, чем тип выражения, скажем, &lt;code&gt;Mod&lt;/code&gt; и &lt;code&gt;Fun&lt;/code&gt; соответственно, то интерпретация выражения приведения - это набор вызовов (M1, M2), так что интерпретация выражения содержит вызов из некоторой функции M1 некоторой функции от M2. Если именованный тип более особенный, чем тип выражения, например &lt;code&gt;Fun&lt;/code&gt; и &lt;code&gt;Mod&lt;/code&gt; , то интерпретация - это набор всех вызовов функций (F1, F2), так что интерпретация выражения содержит вызов (M1, M2), а F1 - это функция M1 и F2 является функцией M2 (в режиме &lt;code&gt;modules&lt;/code&gt; нет вызовов функций, поэтому приведение к &lt;code&gt;Fun&lt;/code&gt; всегда дает пустой набор). Опять же, преобразования в приложения и выпуски и обратно работают аналогично.</target>
        </trans-unit>
        <trans-unit id="d27e97cc64e73bbb29e8593d9319f121ee940fec" translate="yes" xml:space="preserve">
          <source>Now back to the ping pong example.</source>
          <target state="translated">Теперь вернемся к примеру пинг-понга.</target>
        </trans-unit>
        <trans-unit id="e1c4d378028d5d21080c935ee35d85591b2310e0" translate="yes" xml:space="preserve">
          <source>Now change directory into the base directory and set the &lt;code&gt;$ERL_TOP&lt;/code&gt; variable.</source>
          <target state="translated">Теперь перейдите в базовый каталог и установите переменную &lt;code&gt;$ERL_TOP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8740487b8c6e4f56dfebcaaf8cf6bd3325bab300" translate="yes" xml:space="preserve">
          <source>Now for a larger example to consolidate what you have learnt so far. Assume that you have a list of temperature readings from a number of cities in the world. Some of them are in Celsius and some in Fahrenheit (as in the previous list). First let us convert them all to Celsius, then let us print the data neatly.</source>
          <target state="translated">Теперь для большего примера,чтобы закрепить то,что вы узнали до сих пор.Предположим,что у вас есть список показаний температуры из нескольких городов мира.Некоторые из них находятся в Цельсию,а некоторые в Фаренгейте (как и в предыдущем списке).Сначала перевезем их все в Цельсий,затем распечатаем данные аккуратно.</target>
        </trans-unit>
        <trans-unit id="960dcce598e07679e1563922d8c8ce1be7e2353e" translate="yes" xml:space="preserve">
          <source>Now for a larger example with a simple &quot;messenger&quot;. The messenger is a program that allows users to log in on different nodes and send simple messages to each other.</source>
          <target state="translated">Теперь для большего примера с простым &quot;посыльным&quot;.Мессенджер-это программа,которая позволяет пользователям входить в систему на разных узлах и посылать друг другу простые сообщения.</target>
        </trans-unit>
        <trans-unit id="8f9a8082924a3a55b208b60dc3c2a35c271485ed" translate="yes" xml:space="preserve">
          <source>Now for a more complicated example, the factorial of a number. For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</source>
          <target state="translated">Теперь для более сложного примера,факториал числа.Например,факториал 4 равен 4*3*2*1,что равно 24.</target>
        </trans-unit>
        <trans-unit id="85b87f3295c00771011c50c29b24763361547f32" translate="yes" xml:space="preserve">
          <source>Now let us get back to the cities and temperatures, but take a more structured approach this time. First let us convert the whole list to Celsius as follows:</source>
          <target state="translated">Теперь давайте вернемся к городам и температуре,но на этот раз используем более структурированный подход.Сначала давайте преобразовывать весь список в Цельсий следующим образом:</target>
        </trans-unit>
        <trans-unit id="f815262fb97682c5acd6fb931562748d09976dd2" translate="yes" xml:space="preserve">
          <source>Now let us get back to the first two lines of the code. Erlang programs are written in files. Each file contains an Erlang &lt;strong&gt;module&lt;/strong&gt;. The first line of code in the module is the module name (see &lt;code&gt;Modules&lt;/code&gt;):</source>
          <target state="translated">Теперь вернемся к первым двум строкам кода. Программы на Erlang записываются в файлы. Каждый файл содержит &lt;strong&gt;модуль&lt;/strong&gt; Erlang . Первая строка кода в модуле - это имя модуля (см. &lt;code&gt;Modules&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0937bc21f5c355b7556a59cf5f4dbd1a5ec043f5" translate="yes" xml:space="preserve">
          <source>Now let us look at the process &quot;ping&quot;. Recall that it was started by executing:</source>
          <target state="translated">Теперь давайте посмотрим на процесс &quot;пинг&quot;.Напомним,что он был запущен во время выполнения:</target>
        </trans-unit>
        <trans-unit id="6eddc3d3ff799bf232cc855fb7b548b211ee7ca5" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of &lt;code&gt;move_xx&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a7fa9dfcc333d467dd81b0a30c1df103da8ee8" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of the &lt;code&gt;move&lt;/code&gt; instruction. There are multiple files containing implementations of instructions in the &lt;code&gt;erts/emulator/beam&lt;/code&gt; directory. The &lt;code&gt;move&lt;/code&gt; instruction is defined in &lt;code&gt;instrs.tab&lt;/code&gt;. It looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0930d4eadca76ecb3a8d6bfa6d074f842ec248fa" translate="yes" xml:space="preserve">
          <source>Now run the program:</source>
          <target state="translated">Теперь запустите программу:</target>
        </trans-unit>
        <trans-unit id="7e848956566e548f1d9ae0d0b8013c74e6d83d3a" translate="yes" xml:space="preserve">
          <source>Now that we have defined the fragments, we need to inform &lt;strong&gt;beam_makeops&lt;/strong&gt; how they should be connected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eb0e0626fb4ef4258288a934f71110a41abd31" translate="yes" xml:space="preserve">
          <source>Now the &quot;pong&quot; process on gollum is started:</source>
          <target state="translated">Теперь начинается процесс &quot;понг&quot; на голлуме:</target>
        </trans-unit>
        <trans-unit id="5f18e66183fccf43dd04a3319e9abe480c44266d" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;relup&lt;/code&gt; file can be generated:</source>
          <target state="translated">Теперь можно сгенерировать файл &lt;code&gt;relup&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="419ad4c19e6962a17e264cf0565e8680fba59965" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;tut2&lt;/code&gt; program is hardly good programming style. Consider:</source>
          <target state="translated">Теперь программа &lt;code&gt;tut2&lt;/code&gt; вряд ли является хорошим стилем программирования. Рассматривать:</target>
        </trans-unit>
        <trans-unit id="034e7984504e96eaaa52341007b573729c1bfa18" translate="yes" xml:space="preserve">
          <source>Now the C node can be initiated. If short node names are used, this is done by calling &lt;code&gt;erl_connect_init()&lt;/code&gt;:</source>
          <target state="translated">Теперь можно инициировать узел C. Если используются короткие имена узлов, это делается путем вызова &lt;code&gt;erl_connect_init()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cdf6ba8b610923726e867dc5eac6994fcbdfa5a4" translate="yes" xml:space="preserve">
          <source>Now the C node server can accept connections from Erlang nodes:</source>
          <target state="translated">Теперь сервер узлов C может принимать соединения от узлов Erlang:</target>
        </trans-unit>
        <trans-unit id="f57b2ed1c1f99cc47795c85e2110f62964631a09" translate="yes" xml:space="preserve">
          <source>Now we can publish the structure in the table by writing the the pointer to the process structure in the slot previously reserved in 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3630e70ae8e40d246b34002925292898bb67186e" translate="yes" xml:space="preserve">
          <source>Now we come to something more interesting:</source>
          <target state="translated">Теперь мы пришли к чему-то более интересному:</target>
        </trans-unit>
        <trans-unit id="790582ffcd379351fda4ad80a8805b29abc3d15b" translate="yes" xml:space="preserve">
          <source>Now we have a target system that can be started in various ways. We start it as a &lt;strong&gt;basic target system&lt;/strong&gt; by invoking:</source>
          <target state="translated">Теперь у нас есть целевая система, которую можно запускать разными способами. Мы запускаем его как &lt;strong&gt;базовую целевую систему&lt;/strong&gt; , вызывая:</target>
        </trans-unit>
        <trans-unit id="07e2005a0a6deb7487edffb7259d4bbae161649b" translate="yes" xml:space="preserve">
          <source>Now we look at another interesting pseudo function, &lt;code&gt;garbage_collect&lt;/code&gt;:</source>
          <target state="translated">Теперь посмотрим на еще одну интересную &lt;code&gt;garbage_collect&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7baae9db7349907407d97b8497ef107b8eef0dbb" translate="yes" xml:space="preserve">
          <source>Now we want to read data from the table. Function &lt;code&gt;get_until/5&lt;/code&gt; reads data and applies the function until it says that it is done. The result is sent back to the client:</source>
          <target state="translated">Теперь мы хотим прочитать данные из таблицы. Функция &lt;code&gt;get_until/5&lt;/code&gt; считывает данные и применяет функцию до тех пор, пока не скажет, что это сделано. Результат отправляется обратно клиенту:</target>
        </trans-unit>
        <trans-unit id="841ad6881ed808c0b00a3ce8e4425eac2fdd57ad" translate="yes" xml:space="preserve">
          <source>Now when the list is converted, a function to print it is added:</source>
          <target state="translated">Теперь,когда список преобразован,добавляется функция его печати:</target>
        </trans-unit>
        <trans-unit id="f946da2eb954f3f3431f7eaa1a17198b4a4bcad5" translate="yes" xml:space="preserve">
          <source>Now you are set up for some Unicode input and output. The simplest thing to do is to enter a string in the shell:</source>
          <target state="translated">Теперь вы настроены на некоторый вход и выход Unicode.Самое простое-это ввести строку в оболочку:</target>
        </trans-unit>
        <trans-unit id="4101ddb4b1ba4c623fe01975aae255730951fb95" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; or &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt;.</source>
          <target state="translated">Теперь вы можете проверить, какой у вас &lt;code&gt;type erlc&lt;/code&gt; в командной строке erlc . Он должен находиться в &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; или &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd9b4b08ad2850cc0852933844bf5bbc09109e4" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fd06da4ec350e2c1cd2afa53dc7213e2209fc9" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_21.exe&lt;/code&gt; or &lt;code&gt;otp_win64_21.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">Теперь у вас будет файл с именем &lt;code&gt;otp_win32_21.exe&lt;/code&gt; или &lt;code&gt;otp_win64_21.exe&lt;/code&gt; в &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; , то есть &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf27925b0551dd76b6d0908cbb333e95a400dac2" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_23.exe&lt;/code&gt; or &lt;code&gt;otp_win64_23.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716d0540851d08f95b750091b9b63ae2e0b978fa" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;fact(0)&lt;/code&gt; is called, and the function clauses are scanned sequentially again. First, the pattern &lt;code&gt;N&lt;/code&gt; is matched against 0. The matching succeeds, but the guard (&lt;code&gt;N&amp;gt;0&lt;/code&gt;) is false. Second, the pattern 0 is matched against 0. The matching succeeds and the body is evaluated:</source>
          <target state="translated">Теперь вызывается &lt;code&gt;fact(0)&lt;/code&gt; , и предложения функций снова просматриваются последовательно. Сначала шаблон &lt;code&gt;N&lt;/code&gt; сопоставляется с 0. Сопоставление успешно, но защита ( &lt;code&gt;N&amp;gt;0&lt;/code&gt; ) ложна. Во-вторых, шаблон 0 сопоставляется с 0. Сопоставление успешно, и выполняется оценка тела:</target>
        </trans-unit>
        <trans-unit id="98445b1d7f9952b03aea3c602d6261fd2d8aa394" translate="yes" xml:space="preserve">
          <source>Now, back to the example where we wanted to make the output more arranged. With the template:</source>
          <target state="translated">Теперь вернемся к примеру,где мы хотели сделать вывод более упорядоченным.С помощью шаблона:</target>
        </trans-unit>
        <trans-unit id="0ccacd93bad121d635d3ee2cf04a4a93d66d91bb" translate="yes" xml:space="preserve">
          <source>Now, imagine that as &lt;code&gt;m1&lt;/code&gt; is a library module, it is also often used by system &lt;code&gt;s2&lt;/code&gt;. Test run &lt;code&gt;s2&lt;/code&gt; does not specifically test &lt;code&gt;m1&lt;/code&gt;, but it can still be interesting to see which parts of &lt;code&gt;m1&lt;/code&gt; that are covered by the &lt;code&gt;s2&lt;/code&gt; tests. To do this, &lt;code&gt;m1&lt;/code&gt; can be included also in the cover specification of &lt;code&gt;s2&lt;/code&gt; as follows:</source>
          <target state="translated">Теперь представьте, что, поскольку &lt;code&gt;m1&lt;/code&gt; - это библиотечный модуль, он также часто используется системой &lt;code&gt;s2&lt;/code&gt; . Тестовый прогон &lt;code&gt;s2&lt;/code&gt; специально не тестирует &lt;code&gt;m1&lt;/code&gt; , но все же может быть интересно посмотреть, какие части &lt;code&gt;m1&lt;/code&gt; покрываются тестами &lt;code&gt;s2&lt;/code&gt; . Для этого &lt;code&gt;m1&lt;/code&gt; может быть также включен в спецификацию покрытия &lt;code&gt;s2&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="33cc55d98c68e73ea0d743377235f62740c45f57" translate="yes" xml:space="preserve">
          <source>Now, such a call to &lt;code&gt;monitor&lt;/code&gt; will instead succeed and a monitor is created. But the monitor will only supervise the connection. That is, a &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; is the only message that may be received, as the primitive node have no way of reporting the status of the monitored process.</source>
          <target state="translated">Теперь такой вызов &lt;code&gt;monitor&lt;/code&gt; вместо этого будет успешным, и монитор будет создан. Но монитор будет только контролировать соединение. То есть &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; - единственное сообщение, которое может быть получено, поскольку примитивный узел не имеет возможности сообщить о состоянии отслеживаемого процесса.</target>
        </trans-unit>
        <trans-unit id="815213b4b20368b41071811d96af96cae0ecf6af" translate="yes" xml:space="preserve">
          <source>Now, the fold and the map can be done at the same time:</source>
          <target state="translated">Теперь складка и карта могут быть сделаны одновременно:</target>
        </trans-unit>
        <trans-unit id="2bd172c2b14d17bdd3e0bc285216399b7bf359fd" translate="yes" xml:space="preserve">
          <source>Nowadays, the compiler rewrites list comprehensions into an ordinary recursive function. Using a tail-recursive function with a reverse at the end would be still faster. Or would it? That leads us to the myth that tail-recursive functions are faster than body-recursive functions.</source>
          <target state="translated">В настоящее время компилятор переписывает понимания списков в обычную рекурсивную функцию.Использование хвостовой рекурсивной функции с реверсом в конце было бы еще быстрее.Или было бы быстрее? Это приводит нас к мифу о том,что хвост-рекурсивные функции быстрее,чем боди-рекурсивные.</target>
        </trans-unit>
        <trans-unit id="b2b91a3dd3c62a3480c6550b4ca1758c4ca00cfd" translate="yes" xml:space="preserve">
          <source>Nullary callback function &lt;code&gt;PostFun&lt;/code&gt; is called once after the table was last read. The return value, which is caught, is ignored. If &lt;code&gt;PreFun&lt;/code&gt; has been called for a table, &lt;code&gt;PostFun&lt;/code&gt; is guaranteed to be called for that table, even if the evaluation of the query fails for some reason.</source>
          <target state="translated">Обнуляющая функция обратного вызова &lt;code&gt;PostFun&lt;/code&gt; вызывается один раз после последнего чтения таблицы. Возвращаемое значение, которое было перехвачено, игнорируется. Если &lt;code&gt;PreFun&lt;/code&gt; был вызван для таблицы, &lt;code&gt;PostFun&lt;/code&gt; гарантированно будет вызываться для этой таблицы, даже если оценка запроса по какой-либо причине не удалась.</target>
        </trans-unit>
        <trans-unit id="e386a6937b577f217d46833120530e874cdb7e8a" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system (optional) You need this to build the self installing package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11c0821f05eac62af0f028d86dc3849bfa606ca" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system. You need this to build the self installing package. It's a free open source installer that's much nicer to use than the commercial Wise and Install shield installers. This is the installer we use for commercial releases as well.</source>
          <target state="translated">Нульlsoft системы установки NSIS.Это необходимо для сборки самоустанавливающегося пакета.Это бесплатная программа установки с открытым исходным кодом,которая гораздо приятнее в использовании,чем коммерческие программы установки Wise и Install shield.Это инсталлятор,который мы используем и для коммерческих релизов.</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="576c424c360acfd1497ea21294f140f3cec38c19" translate="yes" xml:space="preserve">
          <source>Number ::= - same as non-negative Erlang integers -</source>
          <target state="translated">Число ::=-то же самое,что и неотрицательные целые числа Эрланга -</target>
        </trans-unit>
        <trans-unit id="b120174b0ca1d364c35e309340c2699137e93cf3" translate="yes" xml:space="preserve">
          <source>Number of Atoms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436ff201e33fbebe2f89621894a2abd1c168a9b3" translate="yes" xml:space="preserve">
          <source>Number of acquisitions of this lock.</source>
          <target state="translated">Количество приобретений этого замка.</target>
        </trans-unit>
        <trans-unit id="156e52de6b6c52ca3695d88a4c555445a9d76e09" translate="yes" xml:space="preserve">
          <source>Number of arguments to a function or fun</source>
          <target state="translated">Количество аргументов к функции или веселью</target>
        </trans-unit>
        <trans-unit id="5f360155f999f4bc86536b7ac3f8776370a01909" translate="yes" xml:space="preserve">
          <source>Number of bits may be divisible by 8, which means a binary decodable by &lt;code&gt;ei_decode_binary&lt;/code&gt; is also decodable by &lt;code&gt;ei_decode_bitstring&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed917e86d9f18f03dbcccf6e65ab949d58ed88b7" translate="yes" xml:space="preserve">
          <source>Number of bytes received by the socket.</source>
          <target state="translated">Количество байт,полученных сокетами.</target>
        </trans-unit>
        <trans-unit id="42046ff77420f4d17e7571e95bf522b706d2b214" translate="yes" xml:space="preserve">
          <source>Number of bytes sent from the socket.</source>
          <target state="translated">Количество байт,отправленных из сокета.</target>
        </trans-unit>
        <trans-unit id="2f05c7528a7c09c8ca7b40c3010abfa2c48aee95" translate="yes" xml:space="preserve">
          <source>Number of bytes waiting to be sent by the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abaddc1ab230437389138952dc901cca420ce997" translate="yes" xml:space="preserve">
          <source>Number of calls from exported functions.</source>
          <target state="translated">Количество вызовов из экспортированных функций.</target>
        </trans-unit>
        <trans-unit id="b6dc3a193a64eb663d8300e32005cd15708c2213" translate="yes" xml:space="preserve">
          <source>Number of collisions when a thread tried to acquire this lock. This is when a trylock is EBUSY, a write try on read held rw_lock, a try read on write held rw_lock, a thread tries to lock an already locked lock. (Internal states supervises this).</source>
          <target state="translated">Количество столкновений,когда нить пыталась заполучить этот замок.Это когда триблок EBUSY,попытка записи на чтение с удержанием rw_lock,попытка чтения на запись с удержанием rw_lock,поток пытается заблокировать уже заблокированный замок.(Внутренние состояния контролируют это).</target>
        </trans-unit>
        <trans-unit id="b5befc3bf1ef58e74135162c0668ade7be2434a8" translate="yes" xml:space="preserve">
          <source>Number of data chunks pending receipt</source>
          <target state="translated">Количество фрагментов данных в ожидании получения</target>
        </trans-unit>
        <trans-unit id="1788092af3b8a586296aa9df2406a866bfcd033f" translate="yes" xml:space="preserve">
          <source>Number of inbound streams</source>
          <target state="translated">Количество входящих потоков</target>
        </trans-unit>
        <trans-unit id="0d39785385699f304d2bb821ff68b08bc05cf178" translate="yes" xml:space="preserve">
          <source>Number of lines (processes) to display.</source>
          <target state="translated">Количество отображаемых строк (процессов).</target>
        </trans-unit>
        <trans-unit id="c7246b6b50502576f0a38d8a27451c68c1a94bf1" translate="yes" xml:space="preserve">
          <source>Number of links to the file (this is always 1 for file systems that have no concept of links).</source>
          <target state="translated">Количество ссылок на файл (это всегда 1 для файловых систем,которые не имеют понятия ссылок).</target>
        </trans-unit>
        <trans-unit id="86b7d74929b08d37a5d6bbdc6ce558fa981b1e22" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an incoming DPR if the peer does not close the connection.</source>
          <target state="translated">Количество миллисекунд,по истечении которых транспортное соединение прерывается после входящего DPR,если пиринг не закрывает соединение.</target>
        </trans-unit>
        <trans-unit id="ad84b78a0ee803a8e44abc5c45068c551a8be685" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an outgoing DPR if DPA is not received.</source>
          <target state="translated">Количество миллисекунд,по истечении которых транспортное соединение прерывается после исходящего DPR,если DPA не получено.</target>
        </trans-unit>
        <trans-unit id="d143428966dbf2e9b35f53fde260f63542ea0ceb" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry. For a listening transport, the peer determines the timing.</source>
          <target state="translated">Количество миллисекунд, по истечении которых транспортный процесс, имеющий установленное транспортное соединение, будет завершен, если от однорангового узла не получено ожидаемое сообщение обмена возможностями (CER или CEA). Для подключающегося транспорта время попыток подключения определяется сроком действия &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; . Для прослушивающего транспорта время определяет партнер.</target>
        </trans-unit>
        <trans-unit id="2a4f3d8f10ea95abb768e6ff37dcd2d263075314" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the request should timeout. Defaults to 5000.</source>
          <target state="translated">Количество миллисекунд,по истечении которых запрос должен быть отменен.По умолчанию 5000.</target>
        </trans-unit>
        <trans-unit id="4d5f53d55e482f8b255f961e8335b47ecc984cf9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to the value of &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Количество миллисекунд, по истечении которых транспортный процесс завершается, если DPA не получен. По умолчанию используется значение &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b185f82b1b5bfaa8854d705b869060e9935cb3a" translate="yes" xml:space="preserve">
          <source>Number of milliseconds left until the message would have been sent.</source>
          <target state="translated">Количество миллисекунд,оставшихся до отправки сообщения.</target>
        </trans-unit>
        <trans-unit id="1d3a9ba15cb753485b84a2ad953f8633c6b1bd33" translate="yes" xml:space="preserve">
          <source>Number of outbound streams</source>
          <target state="translated">Количество исходящих потоков</target>
        </trans-unit>
        <trans-unit id="7cc577409a125b78cfe2310bff5b33c90e99d779" translate="yes" xml:space="preserve">
          <source>Number of packets received by the socket.</source>
          <target state="translated">Количество пакетов,полученных гнездом.</target>
        </trans-unit>
        <trans-unit id="6cc46ab9febecbfd1c32816e8e1c042fb0b2037b" translate="yes" xml:space="preserve">
          <source>Number of packets sent from the socket.</source>
          <target state="translated">Количество пакетов,отправленных из гнезда.</target>
        </trans-unit>
        <trans-unit id="0b905814d3355622795966fbb7336f35dc784aab" translate="yes" xml:space="preserve">
          <source>Number of transport processes to start. For a listening transport, determines the size of the pool of accepting transport processes, a larger number being desirable for processing multiple concurrent peer connection attempts. For a connecting transport, determines the number of connections to the peer in question that will be attempted to be establshed: the &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;restrict_connections&lt;/code&gt; should also be configured on the service in question to allow multiple connections to the same peer.</source>
          <target state="translated">Количество запускаемых транспортных процессов. Для прослушивающего транспорта определяет размер пула принимающих транспортных процессов, большее количество желательно для обработки нескольких одновременных попыток однорангового соединения. Для подключающегося транспорта определяет количество подключений к рассматриваемому одноранговому узлу, которое будет предпринято попытка установить: &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;restrict_connections&lt;/code&gt; также следует настроить для рассматриваемой службы, чтобы разрешить несколько подключений к одному и тому же узлу.</target>
        </trans-unit>
        <trans-unit id="66bc96661d8742ae05329a683dcb3f84683507cc" translate="yes" xml:space="preserve">
          <source>Number of unacked data chunks</source>
          <target state="translated">Количество неупакованных фрагментов данных</target>
        </trans-unit>
        <trans-unit id="0b1af9772e5bb4a2a3309eeb320fd315552f0cb5" translate="yes" xml:space="preserve">
          <source>NumberOfAtomCacheRefs/2+1 | 0</source>
          <target state="translated">NumberOfAtomCacheRefs/2+1 | 0</target>
        </trans-unit>
        <trans-unit id="8e1b0dd3b8942a6f418c72794efaf599fa638602" translate="yes" xml:space="preserve">
          <source>Numbers are generated in batches and cached for speed reasons. The cache size can be changed from its default value using the &lt;code&gt; crypto app's &lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742119a1b0ee0bffbdb7123efbae98b4d4cf4508" translate="yes" xml:space="preserve">
          <source>ODBC Data Type</source>
          <target state="translated">ODBC Тип данных</target>
        </trans-unit>
        <trans-unit id="a10c3f25c81a857c7ec7c54210e6931745d9810e" translate="yes" xml:space="preserve">
          <source>OPTIONAL</source>
          <target state="translated">OPTIONAL</target>
        </trans-unit>
        <trans-unit id="7025579510c04aa01d4607a0e0aca5cbec9f5502" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe255781a97feef0174934e6b7b818e19746a2b3" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">ПО ЖЕЛАНИЮ; если эта функция определена, то также необходимо определить &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6aa8960d1405b5237c6590a23f7510a292a61f98" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;Module:end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7020f99e2ebb79e7dec7703e4dde7e6f7d3ab62" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">ПО ЖЕЛАНИЮ; если эта функция определена, то также необходимо определить &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="178a184607add52e5bb5d680a1449c26c616fc56" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt; Module:end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2b3bf247d98944fbe75b41c4379902fac4c0ed" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">ПО ЖЕЛАНИЮ; если эта функция определена, то также необходимо определить &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01588880c00f5e2abc030e7f6d3e755195174bd7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811daf24de9dd5fef2b06f207387f6fa44818576" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">ПО ЖЕЛАНИЮ; если эта функция определена, то также должна быть определена &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7438774d77f88e98fd2822354fa0458e5289e97d" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f3a1ee83f65c6b4212698c759ac143edb39e85" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">ПО ЖЕЛАНИЮ; если эта функция определена, то также необходимо определить &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0552e661b2ea6fc224f8f95384fb27a6c1bfc0f7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt; Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da40ab1589249e13637d8f194c28172da2bf88bf" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">ПО ЖЕЛАНИЮ; если эта функция определена, то также необходимо определить &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00ff70d59339a0ed84894894c61d1c1f2ef4d4e9" translate="yes" xml:space="preserve">
          <source>OS Monotonic Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6942daa3866fbe3e050507e50fbe84fe8347bcc" translate="yes" xml:space="preserve">
          <source>OS System Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d5721686b9afbeb78f01e3fc667ce57e89931f" translate="yes" xml:space="preserve">
          <source>OS X (Darwin)</source>
          <target state="translated">OS X (Дарвин)</target>
        </trans-unit>
        <trans-unit id="70a99f3723b01cca80b99d24bb0c2a412b59bf1d" translate="yes" xml:space="preserve">
          <source>OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion and probably newer versions.</source>
          <target state="translated">OS X 10.6.x/Snow Leopard,OS X 10.7.x/Lion и,возможно,более новые версии.</target>
        </trans-unit>
        <trans-unit id="337dc1124caacdd89c2450e56842d52c3f0e6fad" translate="yes" xml:space="preserve">
          <source>OS X/Darwin: Darwin 9.8.0 in 32-bit mode should work.</source>
          <target state="translated">OS X/Darwin:Darwin 9.8.0 в 32-битном режиме должна работать.</target>
        </trans-unit>
        <trans-unit id="164a0c0837ae1b007b5e17a0056a34ade5f8ce3b" translate="yes" xml:space="preserve">
          <source>OS messages are formatted as a tuple &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt;:</source>
          <target state="translated">Сообщения ОС форматируются как кортеж &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a67749980ef635fc8a670abb9e6fe74b4789978f" translate="yes" xml:space="preserve">
          <source>OS standard client and Erlang daemon (server)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1d16f43b9dc83cb0dfdf26c6b908a0323be7d3" translate="yes" xml:space="preserve">
          <source>OS system time can also be retreived by &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Системное время ОС также можно получить с помощью &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253b34ed7414f8bd95bdcad3ec3b4eb61f4c6738" translate="yes" xml:space="preserve">
          <source>OS system time must be correct when the user finalizes the time offset.</source>
          <target state="translated">Системное время операционной системы должно быть корректным,когда пользователь завершает смещение по времени.</target>
        </trans-unit>
        <trans-unit id="6a1aec662bcb7daef4aac0bdc11df31e66bf2d12" translate="yes" xml:space="preserve">
          <source>OTP 17.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de82a1d6e138a112b2ca58f2dba4eb38c8d2b810" translate="yes" xml:space="preserve">
          <source>OTP 17.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37bb2cd4f43310f6b07a381a40baa26e515175a" translate="yes" xml:space="preserve">
          <source>OTP 17.1.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e91f185f69a2ee4d0fbc84adbe27a2af2afdba2" translate="yes" xml:space="preserve">
          <source>OTP 17.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5349cafd1d20ce8426e0b816e9c62b481bf800e1" translate="yes" xml:space="preserve">
          <source>OTP 17.4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7470cc6ea6636b34aed5c1b324e72d549188877" translate="yes" xml:space="preserve">
          <source>OTP 17.5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303ea13a1fd386fe9f485b047ad9fbdd6c02040e" translate="yes" xml:space="preserve">
          <source>OTP 17.5.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43fb89bd5f06bbf79eb565ca69b6861d91f7db23" translate="yes" xml:space="preserve">
          <source>OTP 17.5.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80c6f60adc5b870c25fb7c1013052f9d969c1e6" translate="yes" xml:space="preserve">
          <source>OTP 18.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb7af0c267d730fc45b68514cdc898b04ecd498" translate="yes" xml:space="preserve">
          <source>OTP 18.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bc05cb3765c17f769bcb5b7fb96b731b1c3725" translate="yes" xml:space="preserve">
          <source>OTP 18.1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd3b841b2d92c0b1abf38595d7acccf3845a2fa" translate="yes" xml:space="preserve">
          <source>OTP 18.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc6e46df551f13559fc03eedfe953522eb1359b" translate="yes" xml:space="preserve">
          <source>OTP 18.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c51896e23a1d1a678491db0ebaac921c06655" translate="yes" xml:space="preserve">
          <source>OTP 18.3.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda7846ff22cbff28cabbc39495e00ce1b7a18c2" translate="yes" xml:space="preserve">
          <source>OTP 19.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932d95768670e0cd5fdbc1095ed0d1b993a8b2d9" translate="yes" xml:space="preserve">
          <source>OTP 19.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05083dc18d014647306ef002a92e31b47deb28fc" translate="yes" xml:space="preserve">
          <source>OTP 19.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae471f5364f5af28f7619f0b3d347819f821f34c" translate="yes" xml:space="preserve">
          <source>OTP 19.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfa396d52da21e038d97a4ee414f99969525781" translate="yes" xml:space="preserve">
          <source>OTP 20.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c37e3f1567db3d2ab061a53dad37370ec3d4a22" translate="yes" xml:space="preserve">
          <source>OTP 20.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f3a32e48ff7a1dda6db9c262b2f8cbf4924dab" translate="yes" xml:space="preserve">
          <source>OTP 20.1.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1ec79e85f251b1426541568df1755b478c8f13" translate="yes" xml:space="preserve">
          <source>OTP 20.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571eb6245a94eb851a6d7f90f3a8e74e0ae0d599" translate="yes" xml:space="preserve">
          <source>OTP 20.2.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e47bfe8e3a87617385f6f0d76f42d53dc879d6" translate="yes" xml:space="preserve">
          <source>OTP 20.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00961db21191f2944a9b797a6cdbf961bf46d33" translate="yes" xml:space="preserve">
          <source>OTP 21.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5be130ed3c502555d8f25e673de0b9efaa0941" translate="yes" xml:space="preserve">
          <source>OTP 21.0.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6021644865848073f992bae8b9c943c4afc7f8d3" translate="yes" xml:space="preserve">
          <source>OTP 21.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bbe1165ae35f17f43e710bfcffbe55c6ef69a2" translate="yes" xml:space="preserve">
          <source>OTP 21.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e689e6310bfe6136b48d902e26821ce9f123a9" translate="yes" xml:space="preserve">
          <source>OTP 21.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1028e9221844cfd633f1eb008eaabcd781d51f96" translate="yes" xml:space="preserve">
          <source>OTP 21.3.8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c232413f3213891452a5c261023c072ccd809791" translate="yes" xml:space="preserve">
          <source>OTP 22.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48773e8bb6bc4865bc681e3589d114b4e76b24a" translate="yes" xml:space="preserve">
          <source>OTP 22.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91df35b0c49a83fd12aa5367b8122925620295d9" translate="yes" xml:space="preserve">
          <source>OTP 22.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e767c5320fed5f340e4813fb7b81851515b9db" translate="yes" xml:space="preserve">
          <source>OTP 23.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645ad46075735cc44ee0b79de93dee14343f8e64" translate="yes" xml:space="preserve">
          <source>OTP 23.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7aca3e13ec5787bed988186babbcbbb08e4d83" translate="yes" xml:space="preserve">
          <source>OTP 23.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5cb3c43764b6e3642d0cc6e9870ab0a059e023" translate="yes" xml:space="preserve">
          <source>OTP R13B04</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c6138485cd68240ee15c2a9a5be15cfec50775" translate="yes" xml:space="preserve">
          <source>OTP R14B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1b5b8bc61568f039950359e0853f2bf506f077" translate="yes" xml:space="preserve">
          <source>OTP R14B01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2068218ce2ddac80161a50fcee5791fada3771a" translate="yes" xml:space="preserve">
          <source>OTP R14B02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9beac3fef36e94cdbe62f62d9631b02ce56c0c" translate="yes" xml:space="preserve">
          <source>OTP R14B03</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2cafa05f322e10fce6e2a71d88c24e3384148b" translate="yes" xml:space="preserve">
          <source>OTP R14B04</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c661581e56206ae5fffaf6b280a8cebf6df8545" translate="yes" xml:space="preserve">
          <source>OTP R15B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de524763778e0a0702eb821d76e1813ba58749a" translate="yes" xml:space="preserve">
          <source>OTP R15B01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af10a49ebba90d9d20eaf701836dad0d8942390f" translate="yes" xml:space="preserve">
          <source>OTP R15B02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927bd5757ada2536880868ac83237b0ba7d7267a" translate="yes" xml:space="preserve">
          <source>OTP R15B03</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d49d7f1b267727894067d4e17bd61989d7f900" translate="yes" xml:space="preserve">
          <source>OTP R16B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf5721a7a707f5795c8ede7966ac925475590f0" translate="yes" xml:space="preserve">
          <source>OTP R16B01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a6f83de13304461ed514ae1410a25c30bef92f" translate="yes" xml:space="preserve">
          <source>OTP R16B02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72498ce41f5658d95091b6ea2350ae21b5605581" translate="yes" xml:space="preserve">
          <source>OTP R16B03</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d85f4d55d00adcbdf0c015b765c1dbf0415d274" translate="yes" xml:space="preserve">
          <source>OTP Versions Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8e226d4cd37fd7c5b423ed6b5c26f687955027" translate="yes" xml:space="preserve">
          <source>OTP also supports changing the internal state of behaviour processes, see &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTP также поддерживает изменение внутреннего состояния поведенческих процессов, см. &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d6221b6a86032737a577d124bf2adb0a2907b66" translate="yes" xml:space="preserve">
          <source>OTP and (in consequence) the Mnesia database.</source>
          <target state="translated">OTP и (как следствие)база данных Мнезии.</target>
        </trans-unit>
        <trans-unit id="a850f204ff4cd54ef41e013bea894026258c1347" translate="yes" xml:space="preserve">
          <source>OTP application Config</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1f0506b65365d10c75cb9d39c0d18910b4731c" translate="yes" xml:space="preserve">
          <source>OTP of a specific version is a set of applications of specific versions. The application versions identified by an OTP version corresponds to application versions that have been tested together by the Erlang/OTP team at Ericsson AB. An OTP system can, however, be put together with applications from different OTP versions. Such a combination of application versions has not been tested by the Erlang/OTP team. It is therefore &lt;strong&gt;always preferred to use OTP applications from one single OTP version&lt;/strong&gt;.</source>
          <target state="translated">OTP определенной версии - это набор приложений определенных версий. Версии приложения, идентифицированные версией OTP, соответствуют версиям приложений, которые были совместно протестированы командой Erlang / OTP в Ericsson AB. Однако система OTP может быть объединена с приложениями из разных версий OTP. Такое сочетание версий приложения не тестировалось командой Erlang / OTP. Поэтому &lt;strong&gt;всегда предпочтительно использовать приложения OTP из одной версии OTP&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2611693947bb5144c4c4a537a229fe14dfc567db" translate="yes" xml:space="preserve">
          <source>OTP start script example for Unix.</source>
          <target state="translated">Пример стартового скрипта OTP для Unix.</target>
        </trans-unit>
        <trans-unit id="44ed97d7d2bc021f13ae4421351ee910df8ab6f2" translate="yes" xml:space="preserve">
          <source>OTP supports a set of &lt;strong&gt;release handling instructions&lt;/strong&gt; that are used when creating &lt;code&gt;.appup&lt;/code&gt; files. The release handler understands a subset of these, the &lt;strong&gt;low-level&lt;/strong&gt; instructions. To make it easier for the user, there are also a number of &lt;strong&gt;high-level&lt;/strong&gt; instructions, which are translated to low-level instructions by &lt;code&gt;systools:make_relup&lt;/code&gt;.</source>
          <target state="translated">OTP поддерживает набор &lt;strong&gt;инструкций по обработке релизов&lt;/strong&gt; , которые используются при создании файлов &lt;code&gt;.appup&lt;/code&gt; . Обработчик выпуска понимает подмножество этих инструкций &lt;strong&gt;низкого уровня&lt;/strong&gt; . Чтобы упростить пользователю задачу, существует также ряд инструкций &lt;strong&gt;высокого уровня&lt;/strong&gt; , которые переводятся в инструкции низкого уровня с помощью &lt;code&gt;systools:make_relup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab311b5a61d5450520dde937fd634cbc9976caf" translate="yes" xml:space="preserve">
          <source>OTP thus provides no support for changing residence modules except in the case of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Таким образом, OTP не поддерживает изменение модулей проживания, за исключением &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad15f1b38f41249c946792c972d910fa729db9d3" translate="yes" xml:space="preserve">
          <source>OTP-22 introduces support for TLS 1.3. The current implementation supports a selective set of cryptographic algorithms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96fc983a2c3eaec3d8d2f2620f536bca0494a75" translate="yes" xml:space="preserve">
          <source>OTP-22.0</source>
          <target state="translated">OTP-22.0</target>
        </trans-unit>
        <trans-unit id="e91f35ba89b72bce378114917c30a606df1775f6" translate="yes" xml:space="preserve">
          <source>OTP-23</source>
          <target state="translated">OTP-23</target>
        </trans-unit>
        <trans-unit id="7a931e0d87dd0cc978b0822251977a0aacd4fc45" translate="yes" xml:space="preserve">
          <source>OTP-SNMPEA-MIB</source>
          <target state="translated">OTP-SNMPEA-MIB</target>
        </trans-unit>
        <trans-unit id="15c4e1f1a4334a82cc1247671dd99e92e6bbd166" translate="yes" xml:space="preserve">
          <source>OTP/Crypto requires that the user provides two or three items of information about the key. The application used by the user is usually on a higher level, for example in &lt;code&gt;SSL&lt;/code&gt;. If using the crypto application directly, it is required that:</source>
          <target state="translated">OTP / Crypto требует, чтобы пользователь предоставил два или три элемента информации о ключе. Приложение, используемое пользователем, обычно находится на более высоком уровне, например, в &lt;code&gt;SSL&lt;/code&gt; . Если вы используете криптографическое приложение напрямую, необходимо, чтобы:</target>
        </trans-unit>
        <trans-unit id="e00f6c999c0a17c02e9b5c79025ff5ac5261cb4a" translate="yes" xml:space="preserve">
          <source>Object identifier, a tuple of integers as generated by the &lt;code&gt;ASN.1&lt;/code&gt; compiler.</source>
          <target state="translated">Идентификатор объекта, набор целых чисел, созданный компилятором &lt;code&gt;ASN.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d389e1fd4f8140b1a2e4262dca91df97551e6b3f" translate="yes" xml:space="preserve">
          <source>Object-based programming with &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">Объектно-ориентированное программирование с &lt;code&gt;Mnesia&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9756e31b402ef2beef3722149ad80b87a0cb1c1" translate="yes" xml:space="preserve">
          <source>Objects are stored and retrieved through set and get functions. The following example shows how to store integers, floats, strings, and arbitrary binary objects:</source>
          <target state="translated">Объекты хранятся и извлекаются через множество и получают функции.Следующий пример показывает,как хранить целые числа,с плавающей точкой,строки и произвольные двоичные объекты:</target>
        </trans-unit>
        <trans-unit id="13dfd2b8ca88ce5b44fe927b518926c1e0325e95" translate="yes" xml:space="preserve">
          <source>Objects can be removed from the registry:</source>
          <target state="translated">Объекты могут быть удалены из реестра:</target>
        </trans-unit>
        <trans-unit id="c5b9dd639a75a9d87bd4d53f043c544fbedd0e4c" translate="yes" xml:space="preserve">
          <source>Observe that E2 may differ from E if for instance there are default values defined in &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что E2 может отличаться от E, если, например, есть значения по умолчанию, определенные в &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb56c5f19fbe9c5d32b08c312c11052dd5b634b7" translate="yes" xml:space="preserve">
          <source>Observe that the 'TerminationId' record is not used in the internal form. It has been replaced with a megaco_term_id record (defined in &quot;megaco/include/megaco.hrl&quot;).</source>
          <target state="translated">Обратите внимание,что запись 'TerminationId' не используется во внутренней форме.Она была заменена на запись megaco_term_id (определена в &quot;megaco/include/megaco.hrl&quot;).</target>
        </trans-unit>
        <trans-unit id="0bd7b307bc7f8afe70fed7a42de3d9fbb7b82fbb" translate="yes" xml:space="preserve">
          <source>Observe that white space: each space, tab or line feed, between mark-up results in an xmlText record.</source>
          <target state="translated">Обратите внимание на то,что пробел:каждый пробел,табуляция или поток строк между разметками приводит к записи xmlText.</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="92d3bdde80720a307b847a6b8a1080bcd444b6aa" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables and contains a front end for Erlang tracing.</source>
          <target state="translated">Наблюдатель-графический инструмент для наблюдения за характеристиками систем Эрланга.Observer отображает системную информацию,деревья супервизора приложений,информацию о процессах,таблицы ETS,таблицы Mnesia и содержит фронтальную часть для трассировки Erlang.</target>
        </trans-unit>
        <trans-unit id="28cd1180f301b3154359b73583ee4c15ce0124d5" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. The tool Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables, and contains a front end for Erlang tracing with module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Observer - это графический инструмент для наблюдения за характеристиками систем Erlang. Инструмент Observer отображает системную информацию, деревья супервизора приложений, информацию о процессах, таблицы ETS, таблицы Mnesia и содержит интерфейс для трассировки Erlang с модулем &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8160323258aa98f01ffae3a9b4dd4732b06a4950" translate="yes" xml:space="preserve">
          <source>Obsolete API functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828b44c38dbd9a16becde3e71362fe411c4b2d3c" translate="yes" xml:space="preserve">
          <source>Obsolete flag without any effect and common misspelling for &lt;code&gt;-setcookie&lt;/code&gt;. Use &lt;code&gt;-setcookie&lt;/code&gt; instead.</source>
          <target state="translated">Устаревший флаг без каких-либо последствий и обычная &lt;code&gt;-setcookie&lt;/code&gt; написании -setcookie . &lt;code&gt;-setcookie&lt;/code&gt; этого используйте -setcookie .</target>
        </trans-unit>
        <trans-unit id="c8219545b990a3e898482be1f33bdc7f5472c0ab" translate="yes" xml:space="preserve">
          <source>Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10.</source>
          <target state="translated">Очевидно,что PCRE не может поддерживать интерполяцию Perl кода.Вместо этого,он поддерживает специальный синтаксис для рекурсии всего шаблона,а также для рекурсии отдельных подшаблонов.После внедрения в PCRE и Python,этот вид рекурсии был позже введен в Perl в версии 5.10.</target>
        </trans-unit>
        <trans-unit id="b15614a1ab393e5aeea9a1c392c3fa0e2e84f379" translate="yes" xml:space="preserve">
          <source>Obviously, that code does not work if the original order of the list is important. If the order of the list must be preserved, do as follows:</source>
          <target state="translated">Очевидно,что этот код не работает,если важен исходный порядок списка.Если порядок списка должен быть сохранен,сделайте следующее:</target>
        </trans-unit>
        <trans-unit id="8e8dc61a9436adab84db0adcc2c88c413a482fca" translate="yes" xml:space="preserve">
          <source>Of ECDSA keys, only the Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">Из ключей ECDSA можно добавить только обычный открытый ключ RSA,DSA или ECDSA,но можно добавить обработку других открытых ключей.</target>
        </trans-unit>
        <trans-unit id="cf5975c0e8398e81740d7e6c9235666c7fc797c5" translate="yes" xml:space="preserve">
          <source>Off: Normal black and white display.</source>
          <target state="translated">Выключено:Нормальный черно-белый дисплей.</target>
        </trans-unit>
        <trans-unit id="5e3b98e05dad157bd1a4bd5b9b0d226314cec835" translate="yes" xml:space="preserve">
          <source>Offline support - &lt;code&gt;systools&lt;/code&gt; for generating scripts and building release packages</source>
          <target state="translated">Автономная поддержка - &lt;code&gt;systools&lt;/code&gt; для создания сценариев и сборки пакетов выпуска</target>
        </trans-unit>
        <trans-unit id="f14b6c908a17fd970288025ad39d8151e0e31dda" translate="yes" xml:space="preserve">
          <source>Offset from the current position.</source>
          <target state="translated">Смещение от текущего положения.</target>
        </trans-unit>
        <trans-unit id="48274bc06ce68fdb7834b5006c17db38cfd5bca3" translate="yes" xml:space="preserve">
          <source>Offset from the end of file.</source>
          <target state="translated">Смещение от конца файла.</target>
        </trans-unit>
        <trans-unit id="74f0c027755f3a641da0ac7fb4fdc91ca752be19" translate="yes" xml:space="preserve">
          <source>Offset to the next byte to write which also equals the amount of bytes currently written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21c3314a2e6470603bd3c8f84047cb484b50ba5" translate="yes" xml:space="preserve">
          <source>Ogham</source>
          <target state="translated">Ogham</target>
        </trans-unit>
        <trans-unit id="b9c65c4bca9e4ad28b61b07b9af83fd8c0fb84c8" translate="yes" xml:space="preserve">
          <source>Ogham space mark</source>
          <target state="translated">Космический знак Огама</target>
        </trans-unit>
        <trans-unit id="80a20b8493b41152418b7eebcae86cbcce091a38" translate="yes" xml:space="preserve">
          <source>Okasaki API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8e3c9a997d8c6ac6d8e0cee37f365cfccbf2c1" translate="yes" xml:space="preserve">
          <source>Ol_Chiki</source>
          <target state="translated">Ol_Chiki</target>
        </trans-unit>
        <trans-unit id="5d9e0077e7780f989a1ceec9b3ec38c49f01d731" translate="yes" xml:space="preserve">
          <source>Old API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e62dbf3fb5370db410bc5b62d0381b5e3d16213" translate="yes" xml:space="preserve">
          <source>Old Crypto API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ffd367297aa558fd23448e1c93eab612c4b2b7" translate="yes" xml:space="preserve">
          <source>Old URI utility module, use uri_string instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b178b6946982a11f1126a949ec15c4d708664fde" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae910bfed0c2daf647c1a19f49b4a126bc16739" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Старые драйверы (скомпилированные с помощью &lt;code&gt;erl_driver.h&lt;/code&gt; из версии ERTS до 5.9) должны быть обновлены и должны использовать расширенный интерфейс (с &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13302e0d3a7dec730ee4bc597d731b5ec3f28913" translate="yes" xml:space="preserve">
          <source>Old-style exec specification that are kept for compatibility, but should not be used in new programs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157d75488b894d1cda756fa16127123d4d8b2331" translate="yes" xml:space="preserve">
          <source>OldBindType</source>
          <target state="translated">OldBindType</target>
        </trans-unit>
        <trans-unit id="7f70150bb048b630bda877379e329b1cba4ccf5d" translate="yes" xml:space="preserve">
          <source>OldBlockState</source>
          <target state="translated">OldBlockState</target>
        </trans-unit>
        <trans-unit id="dc265f2b8ca2bd1379067a84bcb36eee5f10c186" translate="yes" xml:space="preserve">
          <source>OldBoolean</source>
          <target state="translated">OldBoolean</target>
        </trans-unit>
        <trans-unit id="787f17ec93244a470977d9765b05c214ad524302" translate="yes" xml:space="preserve">
          <source>OldCpuTopology</source>
          <target state="translated">OldCpuTopology</target>
        </trans-unit>
        <trans-unit id="05284679f579d778eb76c6cb35f0adb51c1143c0" translate="yes" xml:space="preserve">
          <source>OldDirtyCPUSchedulersOnline</source>
          <target state="translated">OldDirtyCPUSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="d3e43fe6cc5ed7e93ad3fb3737bbd4c693602579" translate="yes" xml:space="preserve">
          <source>OldLevel :: &lt;code&gt;&lt;a href=&quot;#type-debug_level&quot;&gt;debug_level()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1967122f5b0089c8c148736f325420c2e6e602a" translate="yes" xml:space="preserve">
          <source>OldMaxHeapSize</source>
          <target state="translated">OldMaxHeapSize</target>
        </trans-unit>
        <trans-unit id="44bb9d52af1c27b72d85ec222d49edbefed7f191" translate="yes" xml:space="preserve">
          <source>OldMinBinVHeapSize</source>
          <target state="translated">OldMinBinVHeapSize</target>
        </trans-unit>
        <trans-unit id="f03c39aabd48a51861a01442c2abd764c60f8791" translate="yes" xml:space="preserve">
          <source>OldMinHeapSize</source>
          <target state="translated">OldMinHeapSize</target>
        </trans-unit>
        <trans-unit id="a2eedd11d2145f39f33a241d59529adc2aae480c" translate="yes" xml:space="preserve">
          <source>OldSchedulersOnline</source>
          <target state="translated">OldSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="145ae46273aca133d92d9931894007faba8a6122" translate="yes" xml:space="preserve">
          <source>OldState</source>
          <target state="translated">OldState</target>
        </trans-unit>
        <trans-unit id="47ef70f9915b940884f76385b871fac7afb63176" translate="yes" xml:space="preserve">
          <source>OldValue</source>
          <target state="translated">OldValue</target>
        </trans-unit>
        <trans-unit id="d31721795f21dfce26688a7f8239a17ca4259705" translate="yes" xml:space="preserve">
          <source>Old_Italic</source>
          <target state="translated">Old_Italic</target>
        </trans-unit>
        <trans-unit id="2c0a6c802c2e969dfccf2fc785162a6f2b61c2bf" translate="yes" xml:space="preserve">
          <source>Old_North_Arabian</source>
          <target state="translated">Old_North_Arabian</target>
        </trans-unit>
        <trans-unit id="18fae1f67a0f3b95f77e39e31f33b8e9c0d5f5cb" translate="yes" xml:space="preserve">
          <source>Old_Permic</source>
          <target state="translated">Old_Permic</target>
        </trans-unit>
        <trans-unit id="40f6b23336b20230fad65810979b94941509719d" translate="yes" xml:space="preserve">
          <source>Old_Persian</source>
          <target state="translated">Old_Persian</target>
        </trans-unit>
        <trans-unit id="338432c6b8828a6dc79884aa878e0a2867c42479" translate="yes" xml:space="preserve">
          <source>Old_South_Arabian</source>
          <target state="translated">Old_South_Arabian</target>
        </trans-unit>
        <trans-unit id="3641abb7a588932eef54e644e9d1dff8f948abbf" translate="yes" xml:space="preserve">
          <source>Old_Turkic</source>
          <target state="translated">Old_Turkic</target>
        </trans-unit>
        <trans-unit id="ba2f4398b4a78c8c3781b266ce8f8b6790397950" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;, and reduce the paths in stack traces to the module name alone. This option will make it easier to achieve reproducible builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4dff48e0bc069d363085bc649284833fa87dbe" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">Не указывайте &lt;code&gt;options&lt;/code&gt; и &lt;code&gt;source&lt;/code&gt; кортежи в списке, возвращаемом &lt;code&gt;Module:module_info(compile)&lt;/code&gt; . Эта опция упростит получение воспроизводимых сборок.</target>
        </trans-unit>
        <trans-unit id="d1489713bac73f4571aa2114bb6a0e8bece846ba" translate="yes" xml:space="preserve">
          <source>Omits line number information to produce a slightly smaller output file.</source>
          <target state="translated">Опускает информацию о номере строки,чтобы создать немного меньший выходной файл.</target>
        </trans-unit>
        <trans-unit id="ece5ff7a95f46bc465af7ccdd8565b862f2ad117" translate="yes" xml:space="preserve">
          <source>Omitted fields then get the value of evaluating &lt;code&gt;ExprL&lt;/code&gt; instead of their default values. This feature is primarily intended to be used to create patterns for ETS and Mnesia match functions.</source>
          <target state="translated">Пропущенные поля затем получают значение оценки &lt;code&gt;ExprL&lt;/code&gt; вместо значений по умолчанию. Эта функция в первую очередь предназначена для создания шаблонов для функций сопоставления ETS и Mnesia.</target>
        </trans-unit>
        <trans-unit id="2b4336bcea263f419ca09551f44528b242f15a01" translate="yes" xml:space="preserve">
          <source>On 32 bit systems, there is not enough virtual memory space to allocate 1 GB for just literals, so instead small 256 KB sized literal regions are created on demand and a card mark bit-array of the entire 32 bit memory space is then used to determine if a term is a literal or not. Since the total memory space is only 32 bits, the card mark bit-array is only 256 words large. On a 64 bit system the same bit-array would have to be 1 tera words large, so this technique is only viable on 32 bit systems. Doing &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319&quot;&gt;lookups in the array&lt;/a&gt;&lt;/code&gt; is a little more expensive then just doing the pointer checks that can be done in 64 bit systems, but not extremely so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837ccb981f94461d47fadaa07a7f5c5a91558bf2" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: -134217729 &amp;lt; i &amp;lt; 134217728 (28 bits).</source>
          <target state="translated">На 32-битных архитектурах: -134217729 &amp;lt;i &amp;lt;134217728 (28 бит).</target>
        </trans-unit>
        <trans-unit id="07aa96ddf4a255f77698c1f72e8dbbc6f7d0ac40" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 4 words.</source>
          <target state="translated">На 32-битных архитектурах:4 слова.</target>
        </trans-unit>
        <trans-unit id="0aaea3805ba5a1657f963cc5531935c14dbff051" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 5 words for a reference from the current local node + 7 words for a reference from another node.</source>
          <target state="translated">На 32-битных архитектурах:5 слов для ссылки с текущего локального узла+7 слов для ссылки с другого узла.</target>
        </trans-unit>
        <trans-unit id="d729d6c56ff45c63b971639d2a3f12703da39867" translate="yes" xml:space="preserve">
          <source>On 64 bit systems that allow mapping of unreserved virtual memory areas (most operating systems except Windows), an area of size 1 GB (by default) is mapped and then all literals are placed within that area. Then all that has to be done to determine if something is a literal or not is &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324&quot;&gt;two quick pointer checks&lt;/a&gt;&lt;/code&gt;. This system relies on the fact that a memory page that has not been touched yet does not take any actual space. So even if 1 GB of virtual memory is mapped, only the memory which is actually needed for literals is allocated in ram. The size of the literal area is configurable through the +MIscs erts_alloc option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee722acfea1218e0e9779b8fb79277f2b70e2b3" translate="yes" xml:space="preserve">
          <source>On 64 bit windows, on which erts_alloc cannot do unreserved virtual memory mappings, a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59&quot;&gt;special tag&lt;/a&gt;&lt;/code&gt; within the Erlang term object is used to determine if something &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252&quot;&gt;is a literal or not&lt;/a&gt;&lt;/code&gt;. This is very cheap, however, the tag is only available on 64 bit machines, and it is possible to do a great deal of other nice optimizations with this tag in the future (like for instance a more compact list implementation) so it is not used on operating systems where it is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7773ad37cb673ee9b7860d0d4b67f31e39b62273" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: -576460752303423489 &amp;lt; i &amp;lt; 576460752303423488 (60 bits).</source>
          <target state="translated">На 64-битных архитектурах: -576460752303423489 &amp;lt;i &amp;lt;576460752303423488 (60 бит).</target>
        </trans-unit>
        <trans-unit id="ccffdbcaffb960350b1f03947273d32a77218dd0" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 3 words.</source>
          <target state="translated">На 64-битных архитектурах:3 слова.</target>
        </trans-unit>
        <trans-unit id="f4432adb4e3eddcf803da55fd62c8256f8c01dca" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 4 words for a reference from the current local node + 6 words for a reference from another node.</source>
          <target state="translated">На 64-битных архитектурах:4 слова для ссылки с текущего локального узла+6 слов для ссылки с другого узла.</target>
        </trans-unit>
        <trans-unit id="883c639f7255c347e035338f052f0ec88dae56ed" translate="yes" xml:space="preserve">
          <source>On C-nodes, &lt;code&gt;erl_interface&lt;/code&gt; has support for registry tables. These tables reside in RAM on the C-node, but can also be dumped into Mnesia tables. By default, the dumping of registry tables through &lt;code&gt;erl_interface&lt;/code&gt; causes a corresponding Mnesia table to be created with &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt;, if necessary.</source>
          <target state="translated">На C-узлах &lt;code&gt;erl_interface&lt;/code&gt; поддерживает таблицы реестра. Эти таблицы находятся в ОЗУ на C-узле, но также могут быть выгружены в таблицы Mnesia. По умолчанию &lt;code&gt;erl_interface&lt;/code&gt; таблиц реестра через erl_interface приводит к созданию соответствующей таблицы Mnesia с помощью &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt; , если это необходимо.</target>
        </trans-unit>
        <trans-unit id="53c351034515d0f74abb562de89183321dc3361d" translate="yes" xml:space="preserve">
          <source>On Darwin:</source>
          <target state="translated">На Дарвина:</target>
        </trans-unit>
        <trans-unit id="452d25bd3843cd164bb696cf08ee12ab9733accf" translate="yes" xml:space="preserve">
          <source>On Linux or UNIX you can safely ignore this and simply create a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in the directory you get to after executing the command &lt;code&gt;cd&lt;/code&gt; without any argument.</source>
          <target state="translated">В Linux или UNIX вы можете спокойно игнорировать это и просто создать файл с именем &lt;code&gt;.erlang.cookie&lt;/code&gt; в каталоге, в который вы попадете после выполнения команды &lt;code&gt;cd&lt;/code&gt; без каких-либо аргументов.</target>
        </trans-unit>
        <trans-unit id="1abae7c719ffd5227ee01660d1ddd20cb3841aa3" translate="yes" xml:space="preserve">
          <source>On Linux systems the following changes will be made:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ddff816a143447a28cf2b2f9c5227d387e78f6" translate="yes" xml:space="preserve">
          <source>On Linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b320892e617ecd19e1d9117dbdaedf7a5983f2" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt;.</source>
          <target state="translated">В Linux: &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; переменную среды ОС XDG_CACHE_HOME .</target>
        </trans-unit>
        <trans-unit id="6c57c64ae3b58fcb5970a5f623f9d3c0f6952789" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt;.</source>
          <target state="translated">В Linux: &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; переменную среды ОС XDG_CONFIG_DIRS .</target>
        </trans-unit>
        <trans-unit id="99ba5d0f7bf487770a0030a3221eab9acf0e29cb" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt;.</source>
          <target state="translated">В Linux: &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; переменную среды ОС XDG_CONFIG_HOME .</target>
        </trans-unit>
        <trans-unit id="53587ca09ddf330890e10222f1f28d673e022a4f" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;.</source>
          <target state="translated">В Linux: &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; переменную среды ОС XDG_DATA_DIRS .</target>
        </trans-unit>
        <trans-unit id="d2fc503485c3bbe6875742c0c55de66f8b01c934" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_HOME&lt;/code&gt;.</source>
          <target state="translated">В Linux: &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; переменную среды ОС XDG_DATA_HOME .</target>
        </trans-unit>
        <trans-unit id="0127285f8943bba8fbcf06e2c56b836011b620f8" translate="yes" xml:space="preserve">
          <source>On UNIX, the release handler tells the &lt;code&gt;heart&lt;/code&gt; program which command to use to reboot the system. The environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt;, normally used by the &lt;code&gt;heart&lt;/code&gt; program, is ignored in this case. The command instead defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;. Another command can be set by using the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, see the &lt;code&gt;sasl(6)&lt;/code&gt; manual page.</source>
          <target state="translated">В UNIX обработчик выпуска сообщает &lt;code&gt;heart&lt;/code&gt; программе, какую команду использовать для перезагрузки системы. Переменная окружения &lt;code&gt;HEART_COMMAND&lt;/code&gt; , обычно используемая программой- &lt;code&gt;heart&lt;/code&gt; , в этом случае игнорируется. Вместо этого по умолчанию используется команда &lt;code&gt;$ROOT/bin/start&lt;/code&gt; . Другая команда может быть установлена ​​с помощью параметра конфигурации SASL &lt;code&gt;start_prg&lt;/code&gt; , см. &lt;code&gt;sasl(6)&lt;/code&gt; руководства sasl (6) .</target>
        </trans-unit>
        <trans-unit id="9712a16713ddd036d7484cde8377ae9fea3bea13" translate="yes" xml:space="preserve">
          <source>On Ubuntu this can be installed via &lt;code&gt;aptitude&lt;/code&gt;:</source>
          <target state="translated">В Ubuntu это можно установить с помощью &lt;code&gt;aptitude&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="945f7eb32fc020ed4cd606f8c4ad2c5835f8ead0" translate="yes" xml:space="preserve">
          <source>On Unix platforms, other bits than those listed above may be set.</source>
          <target state="translated">На Unix-платформах могут быть установлены другие биты,отличные от перечисленных выше.</target>
        </trans-unit>
        <trans-unit id="bbea9d064da3b38737aba3e1e6b3c867dfe36620" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the environment is set using UTF-8 encoding if Unicode filename translation is in effect. On Windows, the environment is set using wide character interfaces.</source>
          <target state="translated">На Unix-платформах среда задается в кодировке UTF-8,если действует трансляция имен файлов в кодировке Unicode.На Windows окружение устанавливается с использованием широких символьных интерфейсов.</target>
        </trans-unit>
        <trans-unit id="864179103393e4079015a89879456910e0840ba4" translate="yes" xml:space="preserve">
          <source>On Unix systems, the Erlang runtime will interpret two types of signals.</source>
          <target state="translated">На Unix-системах время выполнения Erlang будет интерпретировать два типа сигналов.</target>
        </trans-unit>
        <trans-unit id="42f4a0b9ff2bf60e97136e578acd75fee6a21d57" translate="yes" xml:space="preserve">
          <source>On Unix the &lt;code&gt;event&lt;/code&gt; is a pipe or socket handle (or something that the &lt;code&gt;select&lt;/code&gt; system call understands).</source>
          <target state="translated">В Unix &lt;code&gt;event&lt;/code&gt; представляет собой дескриптор канала или сокета (или что-то, что понимает системный вызов &lt;code&gt;select&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="89488e0941b289b30ca17db0724ef6eb3f8cddfc" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;Osname&lt;/code&gt; has the same value as &lt;code&gt;uname -s&lt;/code&gt; returns, but in lower case. For example, on Solaris 1 and 2, it is &lt;code&gt;sunos&lt;/code&gt;.</source>
          <target state="translated">В Unix &lt;code&gt;Osname&lt;/code&gt; имеет то же значение, что и &lt;code&gt;uname -s&lt;/code&gt; , но в нижнем регистре. Например, в Solaris 1 и 2 это &lt;code&gt;sunos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f9abb41d788d59d3b3b9428af793da0ceb8018a" translate="yes" xml:space="preserve">
          <source>On Unix, any value specified for this field is ignored (the &quot;ctime&quot; for the file is set to the current time). On Windows, this field is the new creation time to set for the file.</source>
          <target state="translated">В Unix любое значение,указанное для этого поля,игнорируется (значение &quot;ctime&quot; для файла устанавливается на текущее время).В Windows это поле является новым временем создания для файла.</target>
        </trans-unit>
        <trans-unit id="2f21108f8f59c58399736174f45da9282d8305fe" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, parameters are expected to be UTF-8 without translation if Unicode filenames are enabled.</source>
          <target state="translated">В Unix-подобных операционных системах параметры должны быть UTF-8 без трансляции,если включены Unicode имена файлов.</target>
        </trans-unit>
        <trans-unit id="624724bf76a78b8d09ce52016c5a6eefce217dcc" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the terminal is to be able to handle UTF-8 on input and output (this is done by, for example, modern versions of XTerm, KDE Konsole, and the Gnome terminal) and your locale settings must be proper. As an example, a &lt;code&gt;LANG&lt;/code&gt; environment variable can be set as follows:</source>
          <target state="translated">В Unix-подобных операционных системах терминал должен иметь возможность обрабатывать UTF-8 при вводе и выводе (это делается, например, с помощью современных версий XTerm, KDE Konsole и терминала Gnome), и ваши языковые настройки должны быть собственно. Например, переменная среды &lt;code&gt;LANG&lt;/code&gt; может быть установлена ​​следующим образом:</target>
        </trans-unit>
        <trans-unit id="3343aa00325e17effeba793420c23aae68f68a75" translate="yes" xml:space="preserve">
          <source>On Windows XP, select &lt;strong&gt;Control Panel&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Language Options&lt;/strong&gt;, select tab &lt;strong&gt;Language&lt;/strong&gt;, and click button &lt;strong&gt;Details...&lt;/strong&gt; in the square named &lt;strong&gt;Text Services and Input Languages&lt;/strong&gt;.</source>
          <target state="translated">В Windows XP выберите &lt;strong&gt;Панель управления&lt;/strong&gt; &amp;gt; &lt;strong&gt;Язык и региональные стандарты&lt;/strong&gt; , выберите вкладку &lt;strong&gt;Язык&lt;/strong&gt; и нажмите кнопку &lt;strong&gt;Подробнее ...&lt;/strong&gt; в квадрате с названием &amp;laquo; &lt;strong&gt;Текстовые службы и языки ввода&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7bdd9c7b68e080175354bdf3fad784b9f495039c" translate="yes" xml:space="preserve">
          <source>On Windows platforms, Erlang searches the system registry rather than looks for configuration files when started in long name distributed mode.</source>
          <target state="translated">На платформах Windows Erlang ищет в системном реестре,а не в файлах конфигурации при запуске в распределенном режиме с длинным именем.</target>
        </trans-unit>
        <trans-unit id="e26d25aabbde72aeec251ac7d6d7e8b7d5ff65e1" translate="yes" xml:space="preserve">
          <source>On Windows systems the home directory is the directory pointed out by the environment variable $HOME - you may need to set this.</source>
          <target state="translated">На системах Windows домашним каталогом является каталог,на который указывает переменная окружения $HOME-вам может понадобиться установить это.</target>
        </trans-unit>
        <trans-unit id="5c1eb5371b5194cdf64f66156f192b541e886e24" translate="yes" xml:space="preserve">
          <source>On Windows the &lt;code&gt;event&lt;/code&gt; is an &lt;code&gt;Event&lt;/code&gt; or &lt;code&gt;Semaphore&lt;/code&gt; (or something that the &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API function understands). (Some trickery in the emulator allows more than the built-in limit of 64 &lt;code&gt;Events&lt;/code&gt; to be used.)</source>
          <target state="translated">В Windows &lt;code&gt;event&lt;/code&gt; - это &lt;code&gt;Event&lt;/code&gt; или &lt;code&gt;Semaphore&lt;/code&gt; (или что-то, что понимает функция API &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; ). (Некоторые хитрости в эмуляторе позволяют использовать больше встроенных 64 &lt;code&gt;Events&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="07f408912d4e25cbe3e69c344bbf252be7275718" translate="yes" xml:space="preserve">
          <source>On Windows the default value is set to &lt;code&gt;8196&lt;/code&gt; because the normal OS limitations are set higher than most machines can handle.</source>
          <target state="translated">В Windows значение по умолчанию установлено на &lt;code&gt;8196&lt;/code&gt; , потому что обычные ограничения ОС установлены выше, чем может справиться большинство машин.</target>
        </trans-unit>
        <trans-unit id="d4b05412a62bc9a89fb50987de22114d258a3cec" translate="yes" xml:space="preserve">
          <source>On Windows the maximum number of nodes allowed in one epmd instance is 60. This is because of limitations in the current implementation. If you need more nodes, you should look into using and erlang based epmd implementation such as &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/epmd&quot;&gt;Erlang EPMD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818c5818d712a93bb76a90d8f6ce9237479e8047" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Osname&lt;/code&gt; is &lt;code&gt;nt&lt;/code&gt;.</source>
          <target state="translated">В Windows &lt;code&gt;Osname&lt;/code&gt; - это &lt;code&gt;nt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08a45149384450c4928eab3da298a998b5209ee6" translate="yes" xml:space="preserve">
          <source>On Windows, proper operation requires that a suitable font is installed and selected for the Erlang application to use. If no suitable font is available on your system, try installing the &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt;, which are freely available, and then select that font in the Erlang shell application.</source>
          <target state="translated">В Windows для правильной работы необходимо установить подходящий шрифт и выбрать его для использования в приложении Erlang. Если в вашей системе нет подходящего шрифта, попробуйте установить &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt; , которые находятся в свободном доступе, а затем выберите этот шрифт в приложении оболочки Erlang.</target>
        </trans-unit>
        <trans-unit id="73a6c028854ad01eefd9a69b170bcc32b5780e1c" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values can be calculated, just as some &lt;code&gt;Flag&lt;/code&gt; values. Report flagrant bugs.</source>
          <target state="translated">В операционной системе Windows, данные извлекаются из различных функций OS API, поэтому &lt;code&gt;Netmask&lt;/code&gt; и &lt;code&gt;Broadaddr&lt;/code&gt; значение может быть вычислены, так же как некоторый &lt;code&gt;Flag&lt;/code&gt; значение. Сообщайте о вопиющих ошибках.</target>
        </trans-unit>
        <trans-unit id="47575c57c43d9b6b182dce9d049d1942967994c2" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values may be calculated, just as some &lt;code&gt;Flags&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e5200c5fc7e9186939f4793a54da361f708e107" translate="yes" xml:space="preserve">
          <source>On Windows, the preferred way to start the Erlang system for interactive use is as follows:</source>
          <target state="translated">В Windows предпочтительным способом запуска системы Erlang для интерактивного использования является следующий:</target>
        </trans-unit>
        <trans-unit id="e3c787c6250b0d27168a0579a029fe138a257fab" translate="yes" xml:space="preserve">
          <source>On Windows, use semi-colon as separator.</source>
          <target state="translated">На Windows,используйте полуколонну в качестве разделителя.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">На Windows:</target>
        </trans-unit>
        <trans-unit id="91de63a646561418f6b7e070668224cb4764e75e" translate="yes" xml:space="preserve">
          <source>On a Unix system you can view the manual pages from the command line using</source>
          <target state="translated">На Unix-системе вы можете просматривать ручные страницы из командной строки с помощью команды</target>
        </trans-unit>
        <trans-unit id="3c1e7fbc1efc10479b9f342b1427cfdbfeabd446" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, &lt;code&gt;ERL_LIBS&lt;/code&gt; can be set to the following</source>
          <target state="translated">В Unix-подобной системе для &lt;code&gt;ERL_LIBS&lt;/code&gt; может быть установлено следующее</target>
        </trans-unit>
        <trans-unit id="a74d3fb56059df82993a50e11000b4ec43a6e044" translate="yes" xml:space="preserve">
          <source>On a conceptual level starting a database connection using the Erlang ODBC API is a basic client server application. The client process uses the API to start and communicate with the server process that manages the connection. The strategy of the Erlang ODBC application is that programming faults in the application itself will cause the connection process to terminate abnormally.(When a process terminates abnormally its supervisor will log relevant error reports.) Calls to API functions during or after termination of the connection process, will return &lt;code&gt;{error, connection_closed}&lt;/code&gt;. Contextual errors on the other hand will not terminate the connection it will only return &lt;code&gt;{error, Reason}&lt;/code&gt; to the client, where &lt;code&gt;Reason&lt;/code&gt; may be any erlang term.</source>
          <target state="translated">На концептуальном уровне запуск соединения с базой данных с помощью Erlang ODBC API представляет собой базовое клиент-серверное приложение. Клиентский процесс использует API для запуска и взаимодействия с серверным процессом, который управляет соединением. Стратегия приложения Erlang ODBC заключается в том, что ошибки программирования в самом приложении приводят к аварийному завершению процесса подключения (при аварийном завершении процесса его супервизор регистрирует соответствующие отчеты об ошибках). Вызовы функций API во время или после завершения соединения. процесса, вернет &lt;code&gt;{error, connection_closed}&lt;/code&gt; . С другой стороны, контекстные ошибки не прерывают соединение, они возвращают клиенту только &lt;code&gt;{error, Reason}&lt;/code&gt; , где &lt;code&gt;Reason&lt;/code&gt; может быть любым термином Erlang.</target>
        </trans-unit>
        <trans-unit id="8d392ddbe029a1a10ad20de9a806356a9c906b21" translate="yes" xml:space="preserve">
          <source>On a file, a term is represented by a header and a binary. Two options define the format of terms on files:</source>
          <target state="translated">В файле термин представлен заголовком и двоичным файлом.Два параметра определяют формат терминов в файлах:</target>
        </trans-unit>
        <trans-unit id="0a1100e7bfb6397c36a4da859d5dfb1b68d51802" translate="yes" xml:space="preserve">
          <source>On a single core system or if it's a non-reentrant scanner, a single port is created. On a multi-core system with a reentrant scanner, several ports will be created (one for each scheduler).</source>
          <target state="translated">На одноядерной системе или,если это не входящий в систему сканер,создается один порт.На многоядерной системе с реентерабельным сканером будет создано несколько портов (по одному для каждого планировщика).</target>
        </trans-unit>
        <trans-unit id="b61c13a696c2951dde75411aaee46764defe2d53" translate="yes" xml:space="preserve">
          <source>On a system where release handling is used, this is always to be set to &lt;code&gt;ignore&lt;/code&gt;. Use &lt;code&gt;heart&lt;/code&gt; to restart the service on failure instead.</source>
          <target state="translated">В системе, где используется обработка релизов, всегда следует устанавливать &lt;code&gt;ignore&lt;/code&gt; . Вместо этого используйте &lt;code&gt;heart&lt;/code&gt; чтобы перезапустить службу в случае сбоя.</target>
        </trans-unit>
        <trans-unit id="ca5dabff07309a8980fe16e2ce2d9b17947978e9" translate="yes" xml:space="preserve">
          <source>On a system without OS monotonic time, Erlang monotonic time guarantees monotonicity, but cannot give other guarantees. The frequency adjustments made to Erlang monotonic time depend on the time warp mode used.</source>
          <target state="translated">На системе без ОС монотонное время,Эрланг монотонное время гарантирует монотонность,но не может дать других гарантий.Регулировка частоты монотонного времени Эрланга зависит от используемого режима искривления времени.</target>
        </trans-unit>
        <trans-unit id="78bd91cdbb8d95fdca3d6cb73e168bf34bd8e3ca" translate="yes" xml:space="preserve">
          <source>On all platforms that we provide atomic memory operations, this is just a &lt;code&gt;volatile&lt;/code&gt; read, preventing the compiler to use values in registers, forcing the a read from memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10079e3d3b4af33197f73508809dcf8be943c1b" translate="yes" xml:space="preserve">
          <source>On an embedded system it is not uncommon that the system has no power supply, not even a battery, when it is shut off. The system clock on such a system is typically way off when the system boots. If &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, and the Erlang runtime system is started before OS system time has been corrected, Erlang system time can be wrong for a long time, centuries or even longer.</source>
          <target state="translated">Во встроенной системе нередко бывает, что в выключенной системе нет источника питания, даже батареи. Системные часы в такой системе обычно не работают при загрузке системы. Если &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; не используется и система времени выполнения Erlang запускается до того, как системное время ОС будет исправлено, системное время Erlang может быть неправильным в течение долгого времени, столетий или даже дольше.</target>
        </trans-unit>
        <trans-unit id="94848f950b79b2c5a62062642414a0d81b6809e5" translate="yes" xml:space="preserve">
          <source>On an embedded system, the &lt;code&gt;erlsrv&lt;/code&gt; module is to be used to install the Erlang process as a Windows system service. This service can start after Windows NT has booted.</source>
          <target state="translated">Во встроенной системе модуль &lt;code&gt;erlsrv&lt;/code&gt; должен использоваться для установки процесса Erlang как системной службы Windows. Эта служба может запускаться после загрузки Windows NT.</target>
        </trans-unit>
        <trans-unit id="d6e74b9f0f9fc530f5a5a031fbc8a47d65641b3d" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;app&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">На уровне приложения ( &lt;code&gt;app&lt;/code&gt; ) поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="8c2c100f87c410005b9664bcf1790490ce2930c4" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;escript&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">На уровне приложения ( &lt;code&gt;escript&lt;/code&gt; ) поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="1f2ca7be500feda1d827cc1f5458cea971c16dda" translate="yes" xml:space="preserve">
          <source>On builds without &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; there is a failed test case for undefined functions. Verify that the failed test case log only shows calls to skipped applications.</source>
          <target state="translated">В сборках без &lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;ssl&lt;/code&gt; и &lt;code&gt;ssh&lt;/code&gt; есть неудачный тестовый пример для неопределенных функций. Убедитесь, что в журнале неудачных тестов отображаются только вызовы пропущенных приложений.</target>
        </trans-unit>
        <trans-unit id="7b33a0aa47e36eff9a9acf946284dbd48855b743" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time a message with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">На каждом узле Erlang процесс может быть установлен как &lt;strong&gt;системный трассировщик&lt;/strong&gt; . Этот процесс будет получать сообщения трассировки каждый раз, когда отправляется или принимается сообщение с токеном трассировки (если установлен флаг &lt;code&gt;send&lt;/code&gt; или &lt;code&gt;'receive'&lt;/code&gt; токена трассировки ). Затем системный трассировщик может распечатать каждое событие трассировки, записать его в файл или что-то еще.</target>
        </trans-unit>
        <trans-unit id="91f3ac52e30283e286d347e915ad6557b2459808" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time information with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa1503e3bb1ca6d6b1d5db02a4ead78c2138817" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() IPv4 address is parsed in the usual x.x.x.x format while an IPv6 address is parsed in any of the formats specified by section 2.2 of RFC 2373, &quot;Text Representation of Addresses&quot;. An IPv4 tuple() has length 4 and contains values of type 0..255. An IPv6 tuple() has length 8 and contains values of type 0..65535. The tuple representation is used on decode.</source>
          <target state="translated">При кодировании,IPv4-адрес OctetString()анализируется в обычном формате x.x.x.x,в то время как IPv6-адрес анализируется в любом из форматов,указанных в разделе 2.2 RFC 2373 &quot;Текстовое представление адресов&quot;.IPv4 tuple()имеет длину 4 и содержит значения типа 0...255.IPv6 tuple()имеет длину 8 и содержит значения типа 0...65535.Представление кортежа используется при декодировании.</target>
        </trans-unit>
        <trans-unit id="5d15ad498425526235871ebf68fcb9399fdea277" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() can be specified as an iolist(), excessively large floats (in absolute value) are equivalent to &lt;code&gt;infinity&lt;/code&gt; or &lt;code&gt;'-infinity'&lt;/code&gt; and excessively large integers result in encode failure. The records for grouped AVPs are as discussed in the previous section.</source>
          <target state="translated">При кодировании OctetString () может быть определен как iolist (), чрезмерно большие числа с плавающей запятой (по абсолютной величине) эквивалентны &lt;code&gt;infinity&lt;/code&gt; или &lt;code&gt;'-infinity'&lt;/code&gt; а чрезмерно большие целые числа приводят к сбою кодирования. Записи для сгруппированных AVP описаны в предыдущем разделе.</target>
        </trans-unit>
        <trans-unit id="c7844a2c02e87c5568f9be53b564891e2298588d" translate="yes" xml:space="preserve">
          <source>On encode, fields port, transport and protocol default to 3868, sctp and diameter respectively. The grammar of an OctetString-valued DiameterURI() is as specified in section 4.3 of RFC 6733. The record representation is used on decode.</source>
          <target state="translated">При кодировании полей порт,транспорт и протокол по умолчанию 3868,sctp и диаметр соответственно.Грамматика функции OctetString-значения DiameterURI()приведена в разделе 4.3 RFC 6733.Представление записи используется при декодировании.</target>
        </trans-unit>
        <trans-unit id="d66c2d9ea2e818fe35630d0324d41a67f4905d83" translate="yes" xml:space="preserve">
          <source>On encode, values can be specified using the macros defined in a dictionary's hrl file.</source>
          <target state="translated">При кодировании,значения могут быть заданы с помощью макросов,определенных в hrl-файле словаря.</target>
        </trans-unit>
        <trans-unit id="731614e2c441caf07c5c36a9a260f1d7987a91b7" translate="yes" xml:space="preserve">
          <source>On encountering character #, &lt;code&gt;pcre_compile()&lt;/code&gt; skips along, looking for a newline in the pattern. The sequence \n is still literal at this stage, so it does not terminate the comment. Only a character with code value 0x0a (the default newline) does so.</source>
          <target state="translated">При обнаружении символа # &lt;code&gt;pcre_compile()&lt;/code&gt; переходит к поиску новой строки в шаблоне. Последовательность \ n на этом этапе все еще буквальная, поэтому она не завершает комментарий. Это делает только символ с кодовым значением 0x0a (новая строка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="6046ea4ed169ee86943dd8f909d8a57065f20fd4" translate="yes" xml:space="preserve">
          <source>On failure, that is, no such environment variable was found, a value &amp;lt; &lt;code&gt;0&lt;/code&gt; is returned. When the size of the &lt;code&gt;value&lt;/code&gt; buffer is too small, a value &amp;gt; &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;*value_size&lt;/code&gt; has been set to the buffer size needed.</source>
          <target state="translated">В случае сбоя, т. Е. Такой переменной среды не найдено, возвращается значение &amp;lt; &lt;code&gt;0&lt;/code&gt; . Если размер буфера &lt;code&gt;value&lt;/code&gt; слишком мал, возвращается значение&amp;gt; &lt;code&gt;0&lt;/code&gt; , а &lt;code&gt;*value_size&lt;/code&gt; устанавливается равным необходимому размеру буфера.</target>
        </trans-unit>
        <trans-unit id="e7d6dfc6c6549f9a2bde9d0b09efa932ae04ee7b" translate="yes" xml:space="preserve">
          <source>On gollum:</source>
          <target state="translated">На Голлуме:</target>
        </trans-unit>
        <trans-unit id="2fb361775fa49f574bf571176cefd50d9c38320a" translate="yes" xml:space="preserve">
          <source>On kosken (on a Linux/UNIX system):</source>
          <target state="translated">На kosken (в системе Linux/UNIX):</target>
        </trans-unit>
        <trans-unit id="254bbc8618baf4df2c0d1ded28631159588b541c" translate="yes" xml:space="preserve">
          <source>On line 1-10 the OS headers needed for the driver are included. As this driver is written for Solaris, we know that the header &lt;code&gt;uio.h&lt;/code&gt; exists. So the preprocessor variable &lt;code&gt;HAVE_UIO_H&lt;/code&gt; can be defined before &lt;code&gt;erl_driver.h&lt;/code&gt; is included on line 12. The definition of &lt;code&gt;HAVE_UIO_H&lt;/code&gt; will make the I/O vectors used in Erlang's driver queues to correspond to the operating systems ditto, which is very convenient.</source>
          <target state="translated">В строках 1-10 указаны заголовки ОС, необходимые для драйвера. Поскольку этот драйвер написан для Solaris, мы знаем, что существует заголовок &lt;code&gt;uio.h&lt;/code&gt; .Таким образом, переменная препроцессора &lt;code&gt;HAVE_UIO_H&lt;/code&gt; может быть определена до того, как &lt;code&gt;erl_driver.h&lt;/code&gt; будет включен в строку 12. Определение &lt;code&gt;HAVE_UIO_H&lt;/code&gt; приведет к тому, что векторы ввода-вывода, используемые в очередях драйверов Erlang, будут соответствовать аналогичным операционным системам, что очень удобно.</target>
        </trans-unit>
        <trans-unit id="233d0459679e240e1a43d6003a0eed16b1b6db16" translate="yes" xml:space="preserve">
          <source>On line 16-23 the different callback functions are declared (&quot;forward declarations&quot;).</source>
          <target state="translated">В строках 16-23 объявлены различные функции обратного вызова (&quot;прямые объявления&quot;).</target>
        </trans-unit>
        <trans-unit id="1829525dba56c919f35e7fe241f7a7f27d37779d" translate="yes" xml:space="preserve">
          <source>On line 4-8 is handled the case where the port is in &lt;code&gt;data&lt;/code&gt; mode or &lt;code&gt;intermediate&lt;/code&gt; mode and the remaining routine handles the different commands. The routine uses the &lt;code&gt;driver_failure_posix()&lt;/code&gt; routine to report errors (see, for example, line 15). Notice that the failure routines make a call to the &lt;code&gt;uds_stop&lt;/code&gt; routine, which will remove the internal port data. The handle (and the casted handle &lt;code&gt;ud&lt;/code&gt;) is therefore &lt;strong&gt;invalid pointers&lt;/strong&gt; after a &lt;code&gt;driver_failure&lt;/code&gt; call and we should &lt;strong&gt;return immediately&lt;/strong&gt;. The runtime system will send exit signals to all linked processes.</source>
          <target state="translated">В строке 4-8 обрабатывается случай, когда порт находится в режиме &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;intermediate&lt;/code&gt; режиме, а оставшаяся процедура обрабатывает различные команды. Подпрограмма использует процедуру &lt;code&gt;driver_failure_posix()&lt;/code&gt; для сообщения об ошибках (см., Например, строку 15). Обратите внимание на то, что процедуры отказа &lt;code&gt;uds_stop&lt;/code&gt; процедуру uds_stop , которая удаляет данные внутреннего порта. Таким образом, дескриптор (и приведенный дескриптор &lt;code&gt;ud&lt;/code&gt; ) являются &lt;strong&gt;недопустимыми указателями&lt;/strong&gt; после вызова &lt;code&gt;driver_failure&lt;/code&gt; , и мы должны &lt;strong&gt;немедленно вернуться&lt;/strong&gt; . Система времени выполнения будет отправлять сигналы выхода всем связанным процессам.</target>
        </trans-unit>
        <trans-unit id="0784da7963dd222dfcf8b747a5d57b72650b03dc" translate="yes" xml:space="preserve">
          <source>On linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">В Linux для эмулятора доступна память &lt;code&gt;cached_memory&lt;/code&gt; и &lt;code&gt;buffered_memory&lt;/code&gt; в дополнение к &lt;code&gt;free_memory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d908b49426b880b5a485931417759cde36bd6fa" translate="yes" xml:space="preserve">
          <source>On many platforms, the OS supports only status codes 0-255. A too large status code is truncated by clearing the high bits.</source>
          <target state="translated">На многих платформах ОС поддерживает только коды статуса 0-255.Слишком большой код статуса усекается за счет очистки старших битов.</target>
        </trans-unit>
        <trans-unit id="01e5aeaef327e8644ba3de200b1361c56477bc67" translate="yes" xml:space="preserve">
          <source>On module (&lt;code&gt;mod&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">На уровне модуля ( &lt;code&gt;mod&lt;/code&gt; ) поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="625fa204254a0a02e9def2bcc01ac2eefa5a78a4" translate="yes" xml:space="preserve">
          <source>On most platforms this option must be set on the socket before associating it to an address. It is therefore only reasonable to specify it when creating the socket and not to use it when calling function (&lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt;) containing this description.</source>
          <target state="translated">На большинстве платформ эту опцию необходимо установить для сокета перед тем, как связать его с адресом. Поэтому разумно указывать его только при создании сокета, а не использовать его при вызове функции ( &lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt; ), содержащей это описание.</target>
        </trans-unit>
        <trans-unit id="83547004e7613d3d63f0a97fcec4dde6aca4cb59" translate="yes" xml:space="preserve">
          <source>On one of the two nodes:</source>
          <target state="translated">На одном из двух узлов:</target>
        </trans-unit>
        <trans-unit id="cc0bc87e9803dd29ab16d01f2771141460043748" translate="yes" xml:space="preserve">
          <source>On operating systems with mandatory Unicode filenames, this means that you more easily conform to the filenames of other (non-Erlang) applications. You can also process filenames that, at least on Windows, were inaccessible (because of having names that could not be represented in ISO Latin-1). Also, you avoid creating incomprehensible filenames on MacOS X, as the &lt;code&gt;vfs&lt;/code&gt; layer of the operating system accepts all your filenames as UTF-8 does not rewrite them.</source>
          <target state="translated">В операционных системах с обязательными именами файлов Unicode это означает, что вам легче согласовывать имена файлов других (не Erlang) приложений. Вы также можете обрабатывать имена файлов, которые, по крайней мере, в Windows, были недоступны (из-за того, что их имена не могли быть представлены в ISO Latin-1). Кроме того, вы избегаете создания непонятных имен файлов в MacOS X, поскольку уровень &lt;code&gt;vfs&lt;/code&gt; операционной системы принимает все ваши имена файлов, поскольку UTF-8 не перезаписывает их.</target>
        </trans-unit>
        <trans-unit id="c01b078903bea1781dc2ed9488460d3b352c3b71" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming (for example, all Unix systems except MacOS X), default is &lt;code&gt;utf8&lt;/code&gt; if the terminal supports UTF-8, otherwise &lt;code&gt;latin1&lt;/code&gt;. The default can be overridden using &lt;code&gt;+fnl&lt;/code&gt; (to force &lt;code&gt;latin1&lt;/code&gt; mode) or &lt;code&gt;+fnu&lt;/code&gt; (to force &lt;code&gt;utf8&lt;/code&gt; mode) when starting &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">В операционных системах с прозрачным именованием (например, все системы Unix, кроме MacOS X) по умолчанию используется &lt;code&gt;utf8&lt;/code&gt; , если терминал поддерживает UTF-8, в противном случае - &lt;code&gt;latin1&lt;/code&gt; . Значение по умолчанию можно изменить с помощью &lt;code&gt;+fnl&lt;/code&gt; (для принудительного режима &lt;code&gt;latin1&lt;/code&gt; ) или &lt;code&gt;+fnu&lt;/code&gt; (для принудительного использования режима &lt;code&gt;utf8&lt;/code&gt; ) при запуске &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd025a43addf4cf8a811c722598b09ff48bc9cb" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming, files can be inconsistently named, for example, some files are encoded in UTF-8 while others are encoded in ISO Latin-1. The concept of &lt;strong&gt;raw filenames&lt;/strong&gt; is introduced to handle file systems with inconsistent naming when running in &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">В операционных системах с прозрачным именованием файлы могут иметь непоследовательные имена, например, некоторые файлы имеют кодировку UTF-8, а другие - ISO Latin-1. Концепция &lt;strong&gt;сырых имен файлов&lt;/strong&gt; вводится для обработки файловых систем с несогласованными именами при работе в режиме &lt;code&gt;utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0eed5fde65bb7a382758dcc51496a31ac264639" translate="yes" xml:space="preserve">
          <source>On other supported systems, see &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; on how to enable HiPE.</source>
          <target state="translated">В других поддерживаемых системах см. &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; , чтобы узнать, как включить HiPE.</target>
        </trans-unit>
        <trans-unit id="553a2be33582dd908d9294011101091577e2f096" translate="yes" xml:space="preserve">
          <source>On platforms supporting it, enables the POSIX &lt;code&gt;O_SYNC&lt;/code&gt; synchronous I/O flag or its platform-dependent equivalent (for example, &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; on Windows) so that writes to the file block until the data is physically written to disk. However, be aware that the exact semantics of this flag differ from platform to platform. For example, none of Linux or Windows guarantees that all file metadata are also written before the call returns. For precise semantics, check the details of your platform documentation. On platforms with no support for POSIX &lt;code&gt;O_SYNC&lt;/code&gt; or equivalent, use of the &lt;code&gt;sync&lt;/code&gt; flag causes &lt;code&gt;open&lt;/code&gt; to return &lt;code&gt;{error, enotsup}&lt;/code&gt;.</source>
          <target state="translated">На поддерживающих его платформах включает &lt;code&gt;O_SYNC&lt;/code&gt; синхронного ввода-вывода POSIX O_SYNC или его платформо-зависимый эквивалент (например, &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; в Windows), чтобы записывать в файловый блок до тех пор, пока данные не будут физически записаны на диск. Однако имейте в виду, что точная семантика этого флага различается от платформы к платформе. Например, ни одна из Linux или Windows не гарантирует, что все метаданные файла также будут записаны перед возвратом вызова. Чтобы узнать точную семантику, проверьте подробную информацию в документации вашей платформы. На платформах, не поддерживающих POSIX &lt;code&gt;O_SYNC&lt;/code&gt; или аналогичный, использование флага &lt;code&gt;sync&lt;/code&gt; приводит к тому, что &lt;code&gt;open&lt;/code&gt; возвращает &lt;code&gt;{error, enotsup}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d150b84d58ca2e7d5f356e3aff31a3d84da95bdf" translate="yes" xml:space="preserve">
          <source>On some operating systems &lt;strong&gt;syslog&lt;/strong&gt; will be used for error reporting when &lt;code&gt;epmd&lt;/code&gt; runs as a daemon. To enable the error logging, you must edit the /etc/syslog.conf file and add an entry:</source>
          <target state="translated">В некоторых операционных системах &lt;strong&gt;системный журнал&lt;/strong&gt; будет использоваться для сообщения об ошибках, когда &lt;code&gt;epmd&lt;/code&gt; работает как демон. Чтобы включить ведение журнала ошибок, вы должны отредактировать файл /etc/syslog.conf и добавить запись:</target>
        </trans-unit>
        <trans-unit id="47544928855d61173caf643cd7bfa90a251b1e29" translate="yes" xml:space="preserve">
          <source>On some platforms Perl may behave strangely if certain locales are set. If you get errors when building, try setting the LANG variable:</source>
          <target state="translated">На некоторых платформах Perl может вести себя странно,если установлены определенные локали.Если при сборке возникают ошибки,попробуйте установить переменную LANG:</target>
        </trans-unit>
        <trans-unit id="c557f429b8f8be575f4e9231e0c0e909cbf4d560" translate="yes" xml:space="preserve">
          <source>On some platforms its &lt;strong&gt;necessary&lt;/strong&gt; to provide the &lt;code&gt;protocol&lt;/code&gt; as its impossible to retrieve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a78afab7d6e8dd2e7a981b5139d692992694b9a" translate="yes" xml:space="preserve">
          <source>On some platforms, the only allowed value for this option is &lt;code&gt;true&lt;/code&gt;, for example, OpenBSD and Windows. Trying to set this option to &lt;code&gt;false&lt;/code&gt;, when creating the socket, fails in this case.</source>
          <target state="translated">На некоторых платформах единственное допустимое значение этой опции - &lt;code&gt;true&lt;/code&gt; , например, OpenBSD и Windows. Попытка установить для этого параметра значение &lt;code&gt;false&lt;/code&gt; при создании сокета в этом случае не удалась.</target>
        </trans-unit>
        <trans-unit id="36908e6d72c2b03311eb938d2432a12b5ab335ef" translate="yes" xml:space="preserve">
          <source>On some platforms, this function might have no effect.</source>
          <target state="translated">На некоторых платформах эта функция может не иметь никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="4e64396927ca10116aa5e806980b90b12fcdc017" translate="yes" xml:space="preserve">
          <source>On some systems it can be necessary to link with some more libraries (for example, &lt;code&gt;libnsl.a&lt;/code&gt; and &lt;code&gt;libsocket.a&lt;/code&gt; on Solaris, or &lt;code&gt;wsock32.lib&lt;/code&gt; on Windows) to use the communication facilities of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">В некоторых системах может потребоваться соединение с некоторыми дополнительными библиотеками (например, &lt;code&gt;libnsl.a&lt;/code&gt; и &lt;code&gt;libsocket.a&lt;/code&gt; в Solaris или &lt;code&gt;wsock32.lib&lt;/code&gt; в Windows), чтобы использовать средства связи &lt;code&gt;Erl_Interface&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0471b1a417f337e7d9ebce0c70ef9a7679a721c" translate="yes" xml:space="preserve">
          <source>On success a pointer to the process identifier is returned. On failure &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd76559ef60de76711ee9a78bc983a284264cd1" translate="yes" xml:space="preserve">
          <source>On success it should set &lt;code&gt;*ctx&lt;/code&gt; to point to a context for the created socket. This context will be passed to all other socket callbacks. This function will be passed the same &lt;code&gt;setup_context&lt;/code&gt; as passed to the preceeding &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd81851a39ee097fec934afda86c40e9cc8f6b19" translate="yes" xml:space="preserve">
          <source>On success zero is returned. On failure a posix error code is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e61d475574f0ccdd55488d9e0d991962394b15" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*sz&lt;/code&gt; should be set to the handshake packet header size to use. Valid values are &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;. Erlang TCP distribution use a handshake packet size of &lt;code&gt;2&lt;/code&gt; and Erlang TLS distribution use a handshake packet size of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb868b4886e090c126e2950aab6d84ed7dcb16dc" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;obuf&lt;/code&gt; is initialized to contain table statistics, otherwise &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">В случае успеха возвращается &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;obuf&lt;/code&gt; инициализируется для хранения статистики таблицы, в противном случае возвращается &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b55c599082e06de776c0bd626fd828b706a34179" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned, the value of the environment variable has been written to the &lt;code&gt;value&lt;/code&gt; buffer, and &lt;code&gt;*value_size&lt;/code&gt; contains the string length (excluding the terminating &lt;code&gt;NULL&lt;/code&gt; character) of the value written to the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">В случае успеха возвращается &lt;code&gt;0&lt;/code&gt; , значение переменной среды было записано в буфер &lt;code&gt;value&lt;/code&gt; , а &lt;code&gt;*value_size&lt;/code&gt; содержит длину строки (исключая завершающий символ &lt;code&gt;NULL&lt;/code&gt; ) значения, записанного в буфер &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eddebcdb76f9fab8ab2298752db267fa58432d28" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;conp&lt;/code&gt; is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">В случае успеха &lt;code&gt;conp&lt;/code&gt; заполняется адресом и именем узла подключающегося клиента, и возвращается дескриптор файла. В случае неудачи, &lt;code&gt;ERL_ERROR&lt;/code&gt; возвращается и &lt;code&gt;erl_errno&lt;/code&gt; установлен в &lt;code&gt;EIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc86d5b291cc284bbc0ca0e72d47d0adc2e32d6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;v&lt;/code&gt; (and &lt;code&gt;size&lt;/code&gt; if the object is binary) is initialized with the value associated with &lt;code&gt;key&lt;/code&gt;, and the function returns &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_STR&lt;/code&gt;, or &lt;code&gt;EI_BIN&lt;/code&gt;, indicating the type of object. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and the arguments are not updated.</source>
          <target state="translated">В случае успеха &lt;code&gt;v&lt;/code&gt; (и &lt;code&gt;size&lt;/code&gt; если объект является двоичным) инициализируется значением, связанным с &lt;code&gt;key&lt;/code&gt; , и функция возвращает &lt;code&gt;EI_INT&lt;/code&gt; , &lt;code&gt;EI_FLT&lt;/code&gt; , &lt;code&gt;EI_STR&lt;/code&gt; или &lt;code&gt;EI_BIN&lt;/code&gt; , указывая тип объекта. В случае ошибки возвращается &lt;code&gt;-1&lt;/code&gt; , а аргументы не обновляются.</target>
        </trans-unit>
        <trans-unit id="969e908d49a7fbc3a7e280f38ab4f55f6067faf3" translate="yes" xml:space="preserve">
          <source>On success, a descriptor connecting the calling process to EPMD is returned. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to:</source>
          <target state="translated">В случае успеха возвращается дескриптор, соединяющий вызывающий процесс с EPMD. В случае ошибки возвращается &lt;code&gt;-1&lt;/code&gt; , а &lt;code&gt;erl_errno&lt;/code&gt; устанавливается в:</target>
        </trans-unit>
        <trans-unit id="c0dc3f3e2f8d8457d666d03550d6d2ac2fec8095" translate="yes" xml:space="preserve">
          <source>On success, a file descriptor is returned which can be used in a call to &lt;code&gt;ei_accept()&lt;/code&gt;. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aec08e035ff2227fedf237e8aaf81890b198c99" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*key&lt;/code&gt; and &lt;code&gt;*value&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if the iterator is positioned at head (before first entry) or tail (beyond last entry).</source>
          <target state="translated">В случае успеха устанавливает &lt;code&gt;*key&lt;/code&gt; и &lt;code&gt;*value&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; . Возвращает &lt;code&gt;false&lt;/code&gt; , если итератор расположен в начале (перед первой записью) или хвосте (после последней записи).</target>
        </trans-unit>
        <trans-unit id="7ef0a43f7b72b72b522ca36cd55aa1e746822b9f" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*pid&lt;/code&gt; to the local process registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered process, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*pid&lt;/code&gt; is unchanged.</source>
          <target state="translated">В случае успеха устанавливает &lt;code&gt;*pid&lt;/code&gt; для локального процесса, зарегистрированного с &lt;code&gt;name&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; . Если &lt;code&gt;name&lt;/code&gt; не зарегистрированный процесс или не атом, возвращается &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;*pid&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="073e4acf139e5d3ba364bb27e432c64851509f50" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*port&lt;/code&gt; to the port registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered port, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*port&lt;/code&gt; is unchanged.</source>
          <target state="translated">В случае успеха устанавливает &lt;code&gt;*port&lt;/code&gt; на порт, зарегистрированный с &lt;code&gt;name&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; . Если &lt;code&gt;name&lt;/code&gt; не является зарегистрированным портом или не является атомом, возвращается &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;*port&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="939344767976749cae972a1349799f2c2eaf12ef" translate="yes" xml:space="preserve">
          <source>On success, stores the resulting term at &lt;code&gt;*term&lt;/code&gt; and returns the number of bytes read. Returns &lt;code&gt;0&lt;/code&gt; if decoding fails or if &lt;code&gt;opts&lt;/code&gt; is invalid.</source>
          <target state="translated">В случае успеха сохраняет полученный термин в &lt;code&gt;*term&lt;/code&gt; и возвращает количество прочитанных байтов. Возвращает &lt;code&gt;0&lt;/code&gt; , если декодирование не &lt;code&gt;opts&lt;/code&gt; или если параметр opts недействителен.</target>
        </trans-unit>
        <trans-unit id="2e2b683cb27a455b0e37378b692f0fae65bff5e5" translate="yes" xml:space="preserve">
          <source>On success, the function returns 0, updates the &lt;code&gt;erlang_pid&lt;/code&gt; pointed to by the pid parameter, and the &lt;code&gt;node&lt;/code&gt; parameter is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, a negative number is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c049046abd946d86db876a1e3d6ab44c243545" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;Emsg&lt;/code&gt; struct is initialized as described above, or &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">В случае успеха функция возвращает &lt;code&gt;ERL_MSG&lt;/code&gt; , и структура &lt;code&gt;Emsg&lt;/code&gt; инициализируется, как описано выше, или &lt;code&gt;ERL_TICK&lt;/code&gt; , в этом случае сообщение не возвращается. В случае ошибки функция возвращает &lt;code&gt;ERL_ERROR&lt;/code&gt; и устанавливает &lt;code&gt;erl_errno&lt;/code&gt; в одно из:</target>
        </trans-unit>
        <trans-unit id="629b14be4c544ff9f65dc57b340e61cbbb39aafa" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the function returns an opaque error, except the &lt;code&gt;pending_process&lt;/code&gt; error described earlier. The opaque errors are to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае успеха функция возвращает &lt;code&gt;ok&lt;/code&gt; . В случае сбоя функция возвращает непрозрачную ошибку, за исключением ошибки &lt;code&gt;pending_process&lt;/code&gt; , описанной ранее. Непрозрачные ошибки должны быть переведены в удобочитаемую форму функцией &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5f40438c31e5fae2d92b0ab21e0ba8037f1d866" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the return value is &lt;code&gt;{error,ErrorDesc}&lt;/code&gt;, where &lt;code&gt;ErrorDesc&lt;/code&gt; is an opaque term to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае успеха функция возвращает &lt;code&gt;ok&lt;/code&gt; . При &lt;code&gt;{error,ErrorDesc}&lt;/code&gt; возвращается значение {error, ErrorDesc} , где &lt;code&gt;ErrorDesc&lt;/code&gt; - непрозрачный термин, который должен быть переведен в удобочитаемую форму функцией &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9434e82ca19ea4e7015799cf03a1286d4e4d6516" translate="yes" xml:space="preserve">
          <source>On success, the function returns a descriptor connecting the calling process to EPMD. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">В случае успеха функция возвращает дескриптор, соединяющий вызывающий процесс с EPMD. В случае ошибки возвращается &lt;code&gt;-1&lt;/code&gt; , а для &lt;code&gt;erl_errno&lt;/code&gt; устанавливается значение &lt;code&gt;EIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4a5876f3c7f9a8dde05d398be614c4d3bae58d6" translate="yes" xml:space="preserve">
          <source>On success, the function returns a pointer to the resource type and &lt;code&gt;*tried&lt;/code&gt; is set to either &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; or &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; to indicate what was done. On failure, returns &lt;code&gt;NULL&lt;/code&gt; and sets &lt;code&gt;*tried&lt;/code&gt; to &lt;code&gt;flags&lt;/code&gt;. It is allowed to set &lt;code&gt;tried&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">В случае успеха функция возвращает указатель на тип ресурса, а &lt;code&gt;*tried&lt;/code&gt; &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; устанавливается в ERL_NIF_RT_CREATE или &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; , чтобы указать, что было сделано. В случае отказа, возвращается &lt;code&gt;NULL&lt;/code&gt; и наборы &lt;code&gt;*tried&lt;/code&gt; к &lt;code&gt;flags&lt;/code&gt; . Допускается установить &amp;laquo; &lt;code&gt;tried&lt;/code&gt; в &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fed20a53218971de1395aaff5c9c60036d53fb8" translate="yes" xml:space="preserve">
          <source>On success, the function returns an Erlang pid containing the address of the specified name, and the node is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;node&lt;/code&gt; is not modified.</source>
          <target state="translated">В случае успеха функция возвращает идентификатор Erlang, содержащий адрес указанного имени, и узел инициализируется именем узла, в котором найдено &lt;code&gt;name&lt;/code&gt; . В случае ошибки возвращается &lt;code&gt;NULL&lt;/code&gt; и &lt;code&gt;node&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="337efc03ad89d708d3afb77816250b7b6e5ac95d" translate="yes" xml:space="preserve">
          <source>On success, the function returns an array of strings, each containing a single registered name, and sets &lt;code&gt;count&lt;/code&gt; to the number of names found. The array is terminated by a single &lt;code&gt;NULL&lt;/code&gt; pointer. On failure, the function returns &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; is not modified.</source>
          <target state="translated">В случае успеха функция возвращает массив строк, каждая из которых содержит одно зарегистрированное имя, и устанавливает &lt;code&gt;count&lt;/code&gt; на количество найденных имен. Массив завершается единственным указателем &lt;code&gt;NULL&lt;/code&gt; . В случае неудачи функция возвращает &lt;code&gt;NULL&lt;/code&gt; , и &lt;code&gt;count&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="b4272e6f5e6ca873a7a08ed89c16a8a80ef49afd" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt; and indicates its length in &lt;code&gt;size&lt;/code&gt;. If the object is not found or if it is not a binary object, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">В случае успеха функция возвращает значение, связанное с &lt;code&gt;key&lt;/code&gt; и указывает его длину в &lt;code&gt;size&lt;/code&gt; . Если объект не найден или не является двоичным объектом, возвращается &lt;code&gt;NULL&lt;/code&gt; . Чтобы избежать проблем с внутриполосным сообщением об ошибках (то есть, если вы не можете различить &lt;code&gt;NULL&lt;/code&gt; и действительный результат), используйте вместо этого более общую функцию &lt;code&gt;ei_reg_getval()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05d5be1ae587938fb787490f4e22f1def9a340ce" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a floating point object, &lt;code&gt;-1.0&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1.0&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">В случае успеха функция возвращает значение, связанное с &lt;code&gt;key&lt;/code&gt; . Если объект не найден или это не объект с плавающей запятой, возвращается &lt;code&gt;-1.0&lt;/code&gt; . Чтобы избежать проблем с внутриполосным сообщением об ошибках (то есть, если вы не можете отличить &lt;code&gt;-1.0&lt;/code&gt; от действительного результата), используйте вместо этого более общую функцию &lt;code&gt;ei_reg_getval()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3820a5ea0fe718970e9f3bbe04885da2999ec49" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a string, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">В случае успеха функция возвращает значение, связанное с &lt;code&gt;key&lt;/code&gt; . Если объект не найден или не является строкой, возвращается &lt;code&gt;NULL&lt;/code&gt; . Чтобы избежать проблем с внутриполосным сообщением об ошибках (то есть, если вы не можете различить &lt;code&gt;NULL&lt;/code&gt; и действительный результат), используйте вместо этого более общую функцию &lt;code&gt;ei_reg_getval()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f63666e52d190298b2a061e3c8a1ed17bebbd73f" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not an integer object, &lt;code&gt;-1&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">В случае успеха функция возвращает значение, связанное с &lt;code&gt;key&lt;/code&gt; . Если объект не найден или если это не целочисленный объект, возвращается &lt;code&gt;-1&lt;/code&gt; . Чтобы избежать проблем с внутриполосным сообщением об ошибках (то есть, если вы не можете отличить &lt;code&gt;-1&lt;/code&gt; от действительного результата), используйте вместо этого более общую функцию &lt;code&gt;ei_reg_getval()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1519b2c5db86ccdb596ec05a28c63cbcfef77f9b" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;#erlang_msg&quot;&gt;msg&lt;/a&gt;&lt;/code&gt; struct is initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826f3f3c68edb8d6a8417ffe459589634fbc1144" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;msg&lt;/code&gt; struct is initialized. &lt;code&gt;erlang_msg&lt;/code&gt; is defined as follows:</source>
          <target state="translated">В случае успеха функции возвращают &lt;code&gt;ERL_MSG&lt;/code&gt; и инициализируется структура &lt;code&gt;msg&lt;/code&gt; . &lt;code&gt;erlang_msg&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="2e36d3c841193235e57c861682cf6d25481358db" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">В случае успеха сообщение помещается в указанный буфер, и функция возвращает количество фактически прочитанных байтов. В случае сбоя функция возвращает &lt;code&gt;ERL_ERROR&lt;/code&gt; и устанавливает &lt;code&gt;erl_errno&lt;/code&gt; в одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="5b25bb3efb4ee6e26cac0f259c10a630574681e4" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns a negative value and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">В случае успеха сообщение помещается в указанный буфер, и функция возвращает количество фактически прочитанных байтов. В случае сбоя функция возвращает отрицательное значение и устанавливает &lt;code&gt;erl_errno&lt;/code&gt; в одно из:</target>
        </trans-unit>
        <trans-unit id="772f9d0d6c197237442ca0a6e490f7b7f2ebb396" translate="yes" xml:space="preserve">
          <source>On success, the registry is resized, all contents rehashed, and &lt;code&gt;0&lt;/code&gt; is returned. On failure, the registry is left unchanged and &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">В случае успеха размер реестра изменяется, все содержимое повторно хешируется и возвращается &lt;code&gt;0&lt;/code&gt; . В случае сбоя реестр остается неизменным и возвращается &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b55ff64c65276715f5cf5ac620e52f2b4c69380a" translate="yes" xml:space="preserve">
          <source>On systems that support OS signals, it is also possible to stop the runtime system and generate a crash dump by sending the &lt;code&gt;SIGUSR1&lt;/code&gt; signal.</source>
          <target state="translated">В системах, поддерживающих сигналы ОС, также можно остановить систему времени выполнения и создать аварийный дамп, отправив сигнал &lt;code&gt;SIGUSR1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8295dab59d105fcadee920c83d7a0087818d1ff8" translate="yes" xml:space="preserve">
          <source>On tab &lt;strong&gt;Internal Tables&lt;/strong&gt; you can from the left-hand menu select &lt;strong&gt;Hash Tables&lt;/strong&gt;, &lt;strong&gt;Index Tables&lt;/strong&gt;, or &lt;strong&gt;Internal ETS Tables&lt;/strong&gt;.</source>
          <target state="translated">На вкладке &amp;laquo; &lt;strong&gt;Внутренние таблицы&amp;raquo;&lt;/strong&gt; в левом меню можно выбрать &amp;laquo; &lt;strong&gt;Хеш-таблицы&amp;raquo;&lt;/strong&gt; , &amp;laquo; &lt;strong&gt;Индексные таблицы&amp;raquo;&lt;/strong&gt; или &amp;laquo; &lt;strong&gt;Внутренние таблицы ETS&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c2fcf0646802d9dc8e8b2dc7ce9d29177a614ac1" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Code&lt;/code&gt; page the Erlang source code is displayed. It is possible to search forwards and backwards for text in the module. Enter a regular expression in the &lt;code&gt;Find&lt;/code&gt; field and press enter. It is also possible to go to a certain line in the module. The &lt;code&gt;Back&lt;/code&gt; button can be used to go back to the previous position.</source>
          <target state="translated">На &lt;code&gt;Code&lt;/code&gt; страницы отображается исходный код Erlang. В модуле можно искать вперед и назад текст. Введите регулярное выражение в поле &amp;laquo; &lt;code&gt;Find&lt;/code&gt; и нажмите клавишу ВВОД. Также можно перейти на определенную строку в модуле. Кнопку &amp;laquo; &lt;code&gt;Back&lt;/code&gt; можно использовать для возврата к предыдущей позиции.</target>
        </trans-unit>
        <trans-unit id="6f72d7009505c0a635de5a33f1a164f62ac37178" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the SSL/TLS distribution adds when creating a socket.</source>
          <target state="translated">В командной строке &lt;code&gt;erl&lt;/code&gt; вы можете указать параметры, которые дистрибутив SSL / TLS добавляет при создании сокета.</target>
        </trans-unit>
        <trans-unit id="6a9c767404e4bacdf3f831aff6d5d541c2d1a85f" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the TLS distribution adds when creating a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58dd19bfb0b41f363c09999a6e4ad4b9c8bdfec9" translate="yes" xml:space="preserve">
          <source>On the C side, it is necessary to write functions for receiving and sending data with 2 byte length indicators from/to Erlang. By default, the C program is to read from standard input (file descriptor 0) and write to standard output (file descriptor 1). Examples of such functions, &lt;code&gt;read_cmd/1&lt;/code&gt; and &lt;code&gt;write_cmd/2&lt;/code&gt;, follows:</source>
          <target state="translated">На стороне C необходимо написать функции для приема и отправки данных с 2-х байтовыми индикаторами длины из / в Erlang. По умолчанию программа C читает из стандартного ввода (дескриптор файла 0) и записывает в стандартный вывод (дескриптор файла 1). Примеры таких функций, &lt;code&gt;read_cmd/1&lt;/code&gt; и &lt;code&gt;write_cmd/2&lt;/code&gt; , приведены ниже:</target>
        </trans-unit>
        <trans-unit id="b1adca5c0bfea4b4b3f2870a27e174b7d50075f9" translate="yes" xml:space="preserve">
          <source>On the client side the ssl application will save session data to try to automate session reuse on behalf of the client processes on the Erlang node. Note that only verified sessions will be saved for security reasons, that is session resumption relies on the certificate validation to have been run in the original handshake. To minimize memory consumption only unique sessions will be saved unless the special &lt;code&gt;save&lt;/code&gt; value is specified for the following option &lt;code&gt;{reuse_sessions, boolean() | save}&lt;/code&gt; in which case a full handhake will be performed and that specific session will have been saved before the handshake returns. The session id and even an opaque binary containing the session data can be retrieved using &lt;code&gt;ssl:connection_information/1&lt;/code&gt; function. A saved session (guaranteed by the save option) can be explicitly reused using &lt;code&gt;{reuse_session, SessionId}&lt;/code&gt;. Also it is possible for the client to reuse a session that is not saved by the ssl application using &lt;code&gt;{reuse_session, {SessionId, SessionData}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62b54f6f16d351431e8df23105f4a3d3614069f" translate="yes" xml:space="preserve">
          <source>On the client side, function &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; spawn a temporary client process establishing contact with a TFTP daemon and perform the file transfer.</source>
          <target state="translated">На стороне клиента функции &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; порождают временный клиентский процесс, устанавливающий контакт с демоном TFTP и выполняющий передачу файлов.</target>
        </trans-unit>
        <trans-unit id="de8d284e24c9173448479649ca3673e3b9453805" translate="yes" xml:space="preserve">
          <source>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to &lt;code&gt;prepare/5&lt;/code&gt; with the same arguments as &lt;code&gt;open/5&lt;/code&gt; takes. &lt;code&gt;prepare/5&lt;/code&gt; is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function &lt;code&gt;open/5&lt;/code&gt; on the client side. On the client side, function &lt;code&gt;open/5&lt;/code&gt; must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt;, the returned state is forwarded to the user and returned from &lt;code&gt;read_file&lt;/code&gt;/3 or &lt;code&gt;write_file/3&lt;/code&gt;.</source>
          <target state="translated">На стороне клиента взаимодействие обратного вызова такое же, но начинается и заканчивается по-разному. Он начинается с вызова &lt;code&gt;prepare/5&lt;/code&gt; с теми же аргументами, что и &lt;code&gt;open/5&lt;/code&gt; . Предполагается, что &lt;code&gt;prepare/5&lt;/code&gt; проверит параметры TFTP, предложенные пользователем, и вернет их подмножество, которое он принимает. Затем параметры отправляются на сервер, который выполняет ту же процедуру согласования параметров TFTP. Опции, которые принимает сервер, передаются в функцию &lt;code&gt;open/5&lt;/code&gt; на стороне клиента. На стороне клиента функция &lt;code&gt;open/5&lt;/code&gt; должна принимать все параметры как есть или отклонять передачу. Затем взаимодействие обратного вызова следует по той же схеме, что и на стороне сервера. Когда последний блок встречается в &lt;code&gt;read/1&lt;/code&gt; или &lt;code&gt;write/2&lt;/code&gt; , возвращаемое состояние пересылается пользователю и возвращается из &lt;code&gt;read_file&lt;/code&gt; / 3 или &lt;code&gt;write_file/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fb24826c266fe2b7d30c2585ff68e6ee2e2233f" translate="yes" xml:space="preserve">
          <source>On the client side, where the &lt;code&gt;open/5&lt;/code&gt; call has been preceded by a call to &lt;code&gt;prepare/5&lt;/code&gt;, all options must be accepted or rejected.</source>
          <target state="translated">На стороне клиента, где вызову &lt;code&gt;open/5&lt;/code&gt; предшествовал вызов &lt;code&gt;prepare/5&lt;/code&gt; , все варианты должны быть приняты или отклонены.</target>
        </trans-unit>
        <trans-unit id="30bc1d9225132fab91da41cb1dc8196b10d81a6f" translate="yes" xml:space="preserve">
          <source>On the destination side the transport service waits for messages. Each message is forwarded to the Megaco application via the megaco:receive_message/4 callback function. The transport service may or may not provide means for blocking and unblocking the reception of the incoming messages.</source>
          <target state="translated">На стороне назначения транспортная служба ждет сообщений.Каждое сообщение пересылается в приложение Megaco через функцию megaco:receive_message/4 callback.Транспортная служба может предоставлять или не предоставлять средства для блокирования и разблокирования приема входящих сообщений.</target>
        </trans-unit>
        <trans-unit id="8a6a0caacfe77936a01171aa4a2af7bcafb1d066" translate="yes" xml:space="preserve">
          <source>On the heap tuples require a word size for each of its elements as well as for the header. Cons cells always require two words. Adding these things together, we get seven words for the tuples and 26 words for the cons cells. The string &lt;code&gt;&quot;hello world!&quot;&lt;/code&gt; is a list of cons cells and thus requires 24 words. The atom &lt;code&gt;tag&lt;/code&gt; and the integer &lt;code&gt;42&lt;/code&gt; do not require any additional heap memory since it is an &lt;strong&gt;immediate&lt;/strong&gt;. Adding all the terms together, the heap space required in this example should be 33 words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d08ce8dca231cb0c413cc427e0f7b3615dc40e4" translate="yes" xml:space="preserve">
          <source>On the library page it is possible to control which sources the tool will use. The page is organized as a tree which can be expanded and collapsed by clicking on the little symbol in the beginning of the expandable/collapsible lines.</source>
          <target state="translated">На странице библиотеки можно контролировать,какие источники будет использовать инструмент.Страница организована в виде дерева,которое можно развернуть и свернуть щелчком по маленькому символу в начале раскрывающихся/складывающихся строк.</target>
        </trans-unit>
        <trans-unit id="359fa7aa2c051b4488b5e4f004a78d6117f975d2" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;a@gin&lt;/code&gt;:</source>
          <target state="translated">На узле &lt;code&gt;a@gin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4dcf5e92ec7cf6d33837ea0dba4f2cf9a86307f9" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;b@skeppet&lt;/code&gt;:</source>
          <target state="translated">На узле &lt;code&gt;b@skeppet&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="504dd890d20c855491af2a80a9207cca701308e3" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;stack&lt;/code&gt; there's an Erlang node &lt;code&gt;ant@stack&lt;/code&gt;, in the shell, type the following:</source>
          <target state="translated">В &lt;code&gt;stack&lt;/code&gt; узлов есть узел Erlang &lt;code&gt;ant@stack&lt;/code&gt; , в оболочке введите следующее:</target>
        </trans-unit>
        <trans-unit id="72075800ddf3add147be6be68bd87c4adad1f4d0" translate="yes" xml:space="preserve">
          <source>On the node where the application is started, there is a transaction coordinator process. If the transaction is distributed, there is also a transaction participant process on all the other nodes where commit-work needs to be performed.</source>
          <target state="translated">На узле,где запускается приложение,происходит процесс координатора транзакций.Если транзакция распространяется,то на всех остальных узлах,где необходимо выполнить коммит-работу,также присутствует процесс-участник транзакции.</target>
        </trans-unit>
        <trans-unit id="30fba55f8fe9ca566a03374554f0601d38f82b56" translate="yes" xml:space="preserve">
          <source>On the other hand it worth mentioning that at least all cipher suites that would rely on non-validated algorithms are automatically disabled in FIPS mode.</source>
          <target state="translated">С другой стороны,стоит отметить,что,по крайней мере,все наборы шифров,которые полагались бы на непроверенные алгоритмы,автоматически отключаются в режиме FIPS.</target>
        </trans-unit>
        <trans-unit id="3d6f6cddc5dd538a25571ab6dae15764b54f7d33" translate="yes" xml:space="preserve">
          <source>On the other hand,</source>
          <target state="translated">С другой стороны,</target>
        </trans-unit>
        <trans-unit id="048ff061e68af3024276eb158992cafe58ebd7ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;move c d&lt;/code&gt; is a single instruction. At runtime, the &lt;code&gt;d&lt;/code&gt; operand will be tested to see whether it refers to an X register or a Y register, and a pointer to the register will be set up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d5245ba64d69949e15fc6366d11aa934acec96" translate="yes" xml:space="preserve">
          <source>On the receiving side the transport module receives the message and forwards it to the protocol engine, which decodes it and invokes user callback functions for each transaction. When a user has handled its action requests, it simply returns a list of action replies (or a message error) and the protocol engine uses the encoding module and transport module to compose and forward the message to the originating user.</source>
          <target state="translated">На принимающей стороне транспортный модуль получает сообщение и направляет его протокольному движку,который расшифровывает его и вызывает функции обратного вызова пользователя для каждой транзакции.Когда пользователь обработал свои запросы на действия,он просто возвращает список ответов на действия (или сообщение об ошибке),а протокольный движок использует модуль кодирования и транспортный модуль для составления и пересылки сообщения пользователю,отправившему его.</target>
        </trans-unit>
        <trans-unit id="823b2c02cd0160bf197b81f01b9301ddf6d5a739" translate="yes" xml:space="preserve">
          <source>On the server side the the &lt;code&gt;{reuse_sessions, boolean()}&lt;/code&gt; option determines if the server will save session data and allow session reuse or not. This can be further customized by the option &lt;code&gt;{reuse_session, fun()}&lt;/code&gt; that may introduce a local policy for session reuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2efe7a16721a2ea4eaaca280d15198cd82819c" translate="yes" xml:space="preserve">
          <source>On the server side, the callback interaction starts with a call to &lt;code&gt;open/5&lt;/code&gt; with the registered initial callback state. &lt;code&gt;open/5&lt;/code&gt; is expected to open the (virtual) file. Then either function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is expected to close the (virtual) file and return its last state. Function &lt;code&gt;abort/3&lt;/code&gt; is only used in error situations. Function &lt;code&gt;prepare/5&lt;/code&gt; is not used on the server side.</source>
          <target state="translated">На стороне сервера взаимодействие обратного вызова начинается с вызова &lt;code&gt;open/5&lt;/code&gt; с зарегистрированным начальным состоянием обратного вызова. &lt;code&gt;open/5&lt;/code&gt; должен открыть (виртуальный) файл. Затем многократно вызывается функция &lt;code&gt;read/1&lt;/code&gt; или &lt;code&gt;write/2&lt;/code&gt; , один раз для каждого передаваемого блока. При каждом вызове функции получается состояние, возвращенное из предыдущего вызова. Когда встречается последний блок, ожидается , что функция &lt;code&gt;read/1&lt;/code&gt; или &lt;code&gt;write/2&lt;/code&gt; закроет (виртуальный) файл и вернет его последнее состояние. Функция &lt;code&gt;abort/3&lt;/code&gt; используется только в ошибочных ситуациях. Функция &lt;code&gt;prepare/5&lt;/code&gt; не используется на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="7f688e5da429c0dc3dd18d9eb9bf400ae2b1e54a" translate="yes" xml:space="preserve">
          <source>On the server side, where there is no preceding &lt;code&gt;prepare/5&lt;/code&gt; call, no new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">На стороне сервера, где нет предыдущей &lt;code&gt;prepare/5&lt;/code&gt; вызова, никакие новые параметры не могут быть добавлены, но которые присутствуют в &lt;code&gt;SuggestedOptions&lt;/code&gt; могут быть опущены или заменены новыми значениями в &lt;code&gt;AcceptedOptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d544406993542a47ac30874abf36e8f76938251" translate="yes" xml:space="preserve">
          <source>On the system settings page it is possible to control some global settings that are used as defaults for all applications. Set the &lt;code&gt;Application inclusion policy&lt;/code&gt; to &lt;code&gt;include&lt;/code&gt; to include all applications that are not explicitly excluded. See &lt;code&gt;incl_cond&lt;/code&gt; (application inclusion) and &lt;code&gt;mod_cond&lt;/code&gt; (module inclusion) in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt; for more info.</source>
          <target state="translated">На странице системных настроек можно управлять некоторыми глобальными настройками, которые используются по умолчанию для всех приложений. Установите &lt;code&gt;Application inclusion policy&lt;/code&gt; для &lt;code&gt;include&lt;/code&gt; , чтобы включить все приложения, которые явно не исключены. См. &lt;code&gt;incl_cond&lt;/code&gt; (включение приложения) и &lt;code&gt;mod_cond&lt;/code&gt; (включение модуля) в справочном руководстве для модуля &lt;code&gt;reltool&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="200db783be88f8550d4a8913f57876ec9c489e2e" translate="yes" xml:space="preserve">
          <source>On the third line (or second line depending on the presence of the Emacs directive), arguments can be specified to the emulator, for example:</source>
          <target state="translated">В третьей строке (или во второй строке в зависимости от наличия директивы Emacs)аргументы могут быть заданы,например,эмулятору:</target>
        </trans-unit>
        <trans-unit id="919203571b510b75243e5425885ce5fd82bf64cd" translate="yes" xml:space="preserve">
          <source>On time-out, the test run is aborted when the current test job is finished. If &lt;code&gt;skip_rest&lt;/code&gt; is provided, the remaining test cases in the current test job are skipped (described later).</source>
          <target state="translated">По истечении времени тестовый запуск прерывается по завершении текущего тестового задания. Если предоставляется &lt;code&gt;skip_rest&lt;/code&gt; , оставшиеся тестовые примеры в текущем тестовом задании пропускаются (описано ниже).</target>
        </trans-unit>
        <trans-unit id="94d0fdbeb40f8b7248647cabbfc52c99b7c568d4" translate="yes" xml:space="preserve">
          <source>On unix you can view the manual pages in emacs. In order to find the manual pages, the variable `erlang-root-dir' should be bound to the name of the directory containing the Erlang installation. The name should not include the final slash. Practically, you should add a line on the following form to your ~/.emacs,</source>
          <target state="translated">В unix Вы можете просматривать страницы руководства в emacs.Для поиска страниц руководства необходимо привязать переменную `erlang-root-dir' к имени каталога,содержащего установку Erlang.Имя не должно содержать последней косой черты.Практически,вы должны добавить строку в ~/.emacs в следующей форме,</target>
        </trans-unit>
        <trans-unit id="f23caa93086babb9143d00576ee2b68575ed59f9" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt; demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730b25cb05ff67e83ca2df0e26ea964cf618b32a" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">Как только &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; возвращается, гарантируется, что никакое сообщение &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; из-за монитора не будет помещено в очередь сообщений вызывающего абонента в будущем. Однако сообщение &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; могло быть помещено в очередь сообщений вызывающего абонента перед вызовом. Поэтому обычно рекомендуется удалить такое сообщение &lt;code&gt;'DOWN'&lt;/code&gt; из очереди сообщений после того, как мониторинг был остановлен. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; можно использовать вместо &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; если требуется эта очистка.</target>
        </trans-unit>
        <trans-unit id="8eb33ed8277cd53945b8bd1336967ae012eaa432" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;unlink(Id)&lt;/code&gt; has returned, it is guaranteed that the link between the caller and the entity referred to by &lt;code&gt;Id&lt;/code&gt; has no effect on the caller in the future (unless the link is setup again). If the caller is trapping exits, an &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message from the link can have been placed in the caller's message queue before the call.</source>
          <target state="translated">После &lt;code&gt;unlink(Id)&lt;/code&gt; гарантируется, что связь между вызывающим абонентом и объектом, на который указывает &lt;code&gt;Id&lt;/code&gt; , не повлияет на вызывающего абонента в будущем (если ссылка не будет настроена снова). Если вызывающий абонент перехватывает выходы, сообщение &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; из ссылки могло быть помещено в очередь сообщений вызывающего абонента перед вызовом.</target>
        </trans-unit>
        <trans-unit id="c2da2fd243f88b2358a1e72df5b1691b330413f0" translate="yes" xml:space="preserve">
          <source>Once a port data lock has been created, it must be locked during all operations on the driver queue of the &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">После создания блокировки данных порта она должна быть заблокирована во время всех операций с очередью драйверов &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="472161e0880a728a8d14ba236e81c941cac5bdc2" translate="yes" xml:space="preserve">
          <source>Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">После загрузки библиотека NIF является постоянной.Она не будет выгружена до тех пор,пока не будет очищена версия кода модуля,к которому она принадлежит.</target>
        </trans-unit>
        <trans-unit id="6ae5090c73eef20a1901a4262fb628566dc03086" translate="yes" xml:space="preserve">
          <source>Once read, this file produces the same configuration variables as the following text file:</source>
          <target state="translated">После чтения этот файл выдает те же самые переменные конфигурации,что и следующий текстовый файл:</target>
        </trans-unit>
        <trans-unit id="2874f79a41ab6a4167b9cad282ba54a8323fe29c" translate="yes" xml:space="preserve">
          <source>Once the CTH is installed into a certain test run it remains there until its scope is expired. The scope of a CTH depends on when it is installed, see the following table. Function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; is called at the beginning of the scope and function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; is called when the scope ends.</source>
          <target state="translated">После того, как CTH установлен в определенный тестовый прогон, он остается там до истечения срока его действия. Объем CTH зависит от того, когда он установлен, см. Следующую таблицу. Функция &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; вызывается в начале области видимости, а функция &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; вызывается, когда область действия заканчивается.</target>
        </trans-unit>
        <trans-unit id="f3e0d89fa4414f90c8258d08a4cc02467fbf1279" translate="yes" xml:space="preserve">
          <source>Once the appropriate modules are interpreted, breakpoints can be set at relevant locations in the source code. Breakpoints are specified on a line basis. When a process reaches a breakpoint, it stops and waits for commands (&lt;strong&gt;Step&lt;/strong&gt;, &lt;strong&gt;Skip&lt;/strong&gt;, &lt;strong&gt;Continue&lt;/strong&gt; ...) from the user.</source>
          <target state="translated">После того, как соответствующие модули интерпретированы, точки останова могут быть установлены в соответствующих местах исходного кода. Точки останова указываются для каждой строки. Когда процесс достигает точки останова, он останавливается и ждет команд ( &lt;strong&gt;Шаг&lt;/strong&gt; , &lt;strong&gt;Пропустить&lt;/strong&gt; , &lt;strong&gt;Продолжить&lt;/strong&gt; ...) от пользователя.</target>
        </trans-unit>
        <trans-unit id="706354aec2cc6d6f0642591cdb86cf2c478e223c" translate="yes" xml:space="preserve">
          <source>Once the data is collected to the server it can be filtered, sorted and printed in many different ways.</source>
          <target state="translated">После сбора данных на сервер они могут быть отфильтрованы,отсортированы и распечатаны различными способами.</target>
        </trans-unit>
        <trans-unit id="55fa9be76565d3bf8388ee77c4576ca0c50c0cab" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt; driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt; driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac354611c2ceba110708f663296284723c689ebb" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">После создания блокировки данных порта каждый доступ к данным, связанным с блокировкой данных порта, должен выполняться, пока блокировка данных порта заблокирована. Блокировка данных порта блокируется и разблокируется с помощью &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="d4566776ad00ac441fb67a63e43838839e8da21d" translate="yes" xml:space="preserve">
          <source>Once the system is built, you might want to change it. Having a test release in some nice directory might be useful, but you can also run Erlang from within the source tree. The target &lt;code&gt;local_setup&lt;/code&gt;, makes the program &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; usable and it also uses all the OTP libraries in the source tree.</source>
          <target state="translated">Когда система построена, вы можете захотеть ее изменить. Наличие тестовой версии в каком-нибудь хорошем каталоге может быть полезно, но вы также можете запустить Erlang из дерева исходных текстов. Целевой &lt;code&gt;local_setup&lt;/code&gt; делает программу &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; пригодной для использования, а также использует все библиотеки OTP в исходном дереве.</target>
        </trans-unit>
        <trans-unit id="ad8f7b7317e234e5165d7fda5e02abbb7d93475a" translate="yes" xml:space="preserve">
          <source>Once you have a lock counting enabled VM the module &lt;code&gt;lcnt&lt;/code&gt; can be used. The module is intended to be used from the current running nodes shell. To access remote nodes use &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; and &lt;code&gt;lcnt:collect(Node)&lt;/code&gt;.</source>
          <target state="translated">Если у вас включена виртуальная машина с &lt;code&gt;lcnt&lt;/code&gt; можно использовать модуль lcnt . Модуль предназначен для использования из оболочки текущих запущенных узлов. Для доступа к удаленным узлам используйте &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; и &lt;code&gt;lcnt:collect(Node)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe6fa81042f05838c7c931d240a87fc23ec1e33e" translate="yes" xml:space="preserve">
          <source>Once you have chosen the modules or directories you want to analyze, click the &lt;strong&gt;Run&lt;/strong&gt; button to start the analysis. If you for some reason want to stop the analysis while it is running, click the &lt;strong&gt;Stop&lt;/strong&gt; button.</source>
          <target state="translated">После того, как вы выбрали модули или каталоги, которые хотите проанализировать, нажмите кнопку &amp;laquo; &lt;strong&gt;Выполнить&amp;raquo;&lt;/strong&gt; , чтобы начать анализ. Если вы по какой-то причине хотите остановить анализ во время его выполнения, нажмите кнопку &amp;laquo; &lt;strong&gt;Стоп&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f1866013abe7a3a8a91c1626525b2105bdb78c26" translate="yes" xml:space="preserve">
          <source>One MIB can communicate with many applications.</source>
          <target state="translated">Один MIB может общаться со многими приложениями.</target>
        </trans-unit>
        <trans-unit id="ae6ac6f5e1f4c553d516e35fd92ef8609ef86d4a" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit(1, second, native)&lt;/a&gt;&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7314739d088633c38ec313d94ecdc0d77f14a5ba" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">Можно получить приближение &lt;code&gt;native&lt;/code&gt; единицы времени, вызвав &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt; . Результат равен количеству целых &lt;code&gt;native&lt;/code&gt; единиц времени в секунду. Если количество &lt;code&gt;native&lt;/code&gt; единиц времени в секунду не дает в сумме целого числа, результат округляется в меньшую сторону.</target>
        </trans-unit>
        <trans-unit id="ef10c93f15b1c52938ec7e181160a865ba85041c" translate="yes" xml:space="preserve">
          <source>One critical issue to note here is that any term on the young heap can reference terms on the old heap but &lt;strong&gt;no&lt;/strong&gt; term on the old heap may refer to a term on the young heap. This is due to the nature of the copy algorithm. Anything referenced by an old heap term is not included in the reference tree, root-set and its followers, and hence is not copied. If it was, the data would be lost, fire and brimstone would rise to cover the earth. Fortunately, this comes naturally for Erlang because the terms are immutable and thus there can be no pointers modified on the old heap to point to the young heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c004d9fe4418301daaece7534ddb42246eb9542" translate="yes" xml:space="preserve">
          <source>One entry per allocator. See &lt;code&gt;Allocator&lt;/code&gt; in section &quot;How to Interpret the Erlang Crash Dumps&quot; in ERTS.</source>
          <target state="translated">Одна запись на распределитель. См &lt;code&gt;Allocator&lt;/code&gt; в разделе &amp;laquo;Как интерпретировать Erlang аварийных дампов&amp;raquo; в ЭРЦЕ.</target>
        </trans-unit>
        <trans-unit id="a5ae873b8dbf85d90619c54d5534f4bb29cc5b20" translate="yes" xml:space="preserve">
          <source>One example for this is to pre-process incoming data, for example decrypting chunks or collecting characters up to a line break.</source>
          <target state="translated">В качестве примера можно привести предварительную обработку поступающих данных,например,расшифровку кусков или сбор символов до разрыва строки.</target>
        </trans-unit>
        <trans-unit id="a14d428a902184f6d393d8bd6140890e2ae77f4b" translate="yes" xml:space="preserve">
          <source>One exception is pattern matching of binaries. The compiler does not rearrange clauses that match binaries. Placing the clause that matches against the empty binary &lt;strong&gt;last&lt;/strong&gt; is usually slightly faster than placing it &lt;strong&gt;first&lt;/strong&gt;.</source>
          <target state="translated">Единственным исключением является сопоставление двоичных файлов с образцом. Компилятор не изменяет порядок предложений, соответствующих двоичным файлам. Размещение предложения, которое совпадает с пустым двоичным файлом &lt;strong&gt;последним&lt;/strong&gt; , обычно немного быстрее, чем размещение его &lt;strong&gt;первым&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7d94c70dc04626571d8ea05626b35349d3398b38" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function</source>
          <target state="translated">Один для конечных автоматов ( например, &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; ), который требует, чтобы состояние было атомом, и использует это состояние в качестве имени текущей функции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="3f8d27506d8e90d0a22e543f80e99c7ae08237b4" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3770c544733aa5fb6e0292ae22987354af0a4e69" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to ignore and pass on directly to the emulator (those following &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">Одна группа, которую &lt;code&gt;Common Test&lt;/code&gt; игнорирует и передает непосредственно эмулятору (следующие за &lt;code&gt;-erl_args&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d6a260162de88ba81cc22f21bd78e10fba85db33" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to process (those preceding &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">Одна группа, которую должен обрабатывать &lt;code&gt;Common Test&lt;/code&gt; (предшествующие &lt;code&gt;-erl_args&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="614890ec6bea0b6110430c451657204a01ec779e" translate="yes" xml:space="preserve">
          <source>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</source>
          <target state="translated">Возвращается одна строка из файла,включая трейлинговый LF,но с последовательностями CRLF,замененными одним LF (см.выше).</target>
        </trans-unit>
        <trans-unit id="cdb5ea69a08925e346c04bb8f306808dfae21189" translate="yes" xml:space="preserve">
          <source>One log file, &lt;code&gt;run_erl.log&lt;/code&gt;, which logs progress and warnings from the &lt;code&gt;run_erl&lt;/code&gt; program itself.</source>
          <target state="translated">Один файл журнала, &lt;code&gt;run_erl.log&lt;/code&gt; , в котором регистрируется прогресс и предупреждения самой программы &lt;code&gt;run_erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19cc7e16964b3af0e44bb854d9aa8967052724d4" translate="yes" xml:space="preserve">
          <source>One may also convert arbitrary data to XML. So it for instance is easy to make it readable by humans. In this case you first create xmerl data structures out of your data, then transform it to XML.</source>
          <target state="translated">Можно также конвертировать произвольные данные в XML.Так,например,его легко сделать читаемым человеком.В этом случае вы сначала создаете структуры данных xmerl из своих данных,а затем преобразовываете их в XML.</target>
        </trans-unit>
        <trans-unit id="ed6a90e414ee1584a7c5f1f7c5472363c8f0e272" translate="yes" xml:space="preserve">
          <source>One must be careful not to create infinite loops. For example, if we for some reason would want to reverse the operand order for the &lt;code&gt;move&lt;/code&gt; instruction, we must not do like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d6f92b8658a1866e9d8146c603570466b38bb9" translate="yes" xml:space="preserve">
          <source>One network RPC (two messages) to acquire the write lock</source>
          <target state="translated">Один сетевой RPC (два сообщения)для получения блокировки записи.</target>
        </trans-unit>
        <trans-unit id="00a56ba397ce141f9962051dd004c70978ba6dd8" translate="yes" xml:space="preserve">
          <source>One nice thing with the &lt;code&gt;trace_pattern&lt;/code&gt; is that it provides a very simple way of minimizing the amount of generated trace data by allowing you to explicitly control the detail level of the tracing. As you may have seen the &lt;code&gt;et_viewer&lt;/code&gt; have a slider called &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; that allows you to control the detail level of the trace &lt;code&gt;Events&lt;/code&gt; displayed in the &lt;code&gt;Viewer&lt;/code&gt;. On the other hand if you set a low detail level in the &lt;code&gt;trace_pattern&lt;/code&gt;, lots of the trace data will never be generated and thus not sent over the socket to the trace client and stored in the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">Одна хорошая вещь с &lt;code&gt;trace_pattern&lt;/code&gt; заключается в том, что он предоставляет очень простой способ минимизировать количество генерируемых данных трассировки, позволяя вам явно контролировать уровень детализации трассировки. Как вы, возможно, видели, у &lt;code&gt;et_viewer&lt;/code&gt; есть ползунок под названием &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; который позволяет вам контролировать уровень детализации &lt;code&gt;Events&lt;/code&gt; трассировки, отображаемых в &lt;code&gt;Viewer&lt;/code&gt; . С другой стороны, если вы установите низкий уровень детализации в &lt;code&gt;trace_pattern&lt;/code&gt; , многие данные трассировки никогда не будут сгенерированы и, следовательно, не будут отправлены через сокет клиенту трассировки и сохранены в &lt;code&gt;Collector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4529738d7c5d95ab24a59e21df7882f76ad41b01" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&quot;Error&quot;&lt;/code&gt;, &lt;code&gt;&quot;Warning&quot;&lt;/code&gt;, &lt;code&gt;&quot;Informational&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; or, in case of a currently unknown Windows NT version &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt;.</source>
          <target state="translated">Одно из &lt;code&gt;&quot;Error&quot;&lt;/code&gt; , &lt;code&gt;&quot;Warning&quot;&lt;/code&gt; , &lt;code&gt;&quot;Informational&quot;&lt;/code&gt; , &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt; , &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; или, в случае неизвестной на данный момент версии Windows NT, &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8715b5dac001f8acd8e786d5f72ce95270b48d8" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ea7befab7a1376dc38a902be4e17f510f6d524" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a6b0b2d35c017b6e03a9c4a65c9d58e6870f08" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">Один из &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; вызывается для получения статуса &lt;code&gt;gen_event&lt;/code&gt; . &lt;code&gt;Opt&lt;/code&gt; устанавливается на атом, &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7da5bbc0da1569bb676eb4407e53fc819a024b48" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Один из &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; вызывается для получения статуса &lt;code&gt;gen_server&lt;/code&gt; . &lt;code&gt;Opt&lt;/code&gt; установлен на &lt;code&gt;normal&lt;/code&gt; атом .</target>
        </trans-unit>
        <trans-unit id="eb296f4b0ca5c3593de75916329b44424ed9130b" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_statem&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">Один из &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; вызывается для получения статуса &lt;code&gt;gen_statem&lt;/code&gt; . &lt;code&gt;Opt&lt;/code&gt; устанавливается на атом, &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdb44fc1b32a8df8e66016b4df34ca5e01e3c2a5" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Один из вариантов &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4929df166f7d8de83e743d85b22e80a274c8fcf4" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;Host&lt;/code&gt; and &lt;code&gt;Service&lt;/code&gt; may be &lt;code&gt;undefined&lt;/code&gt; but &lt;strong&gt;not&lt;/strong&gt; both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56827b36a41cbbd74b980c5f475d1ddd1caffbc8" translate="yes" xml:space="preserve">
          <source>One of the UTF-encodings, which is specified as parameter &lt;code&gt;InEncoding&lt;/code&gt;.</source>
          <target state="translated">Одна из UTF-кодировок, которая указывается в параметре &lt;code&gt;InEncoding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2585f7fa5d9239f75ea13c3267959aa775292560" translate="yes" xml:space="preserve">
          <source>One of the cornerstones of security in SSH is cryptography. The development in crypto analysis is fast, and yesterday's secure algorithms are unsafe today. Therefore some algorithms are no longer enabled by default and that group grows with time. See the &lt;code&gt;SSH (App)&lt;/code&gt; for a list of supported and of disabled algorithms. In the User's Guide the chapter &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; describes the options for enabling or disabling algorithms - &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5094e20e8e0457a5a8f2279ba88b4ba2472732" translate="yes" xml:space="preserve">
          <source>One of the kernel processes could not start. This is probably because of faulty arguments (like errors in a &lt;code&gt;-config&lt;/code&gt; argument) or faulty configuration files. Check that all files are in their correct location and that the configuration files (if any) are not damaged. Usually messages are also written to the controlling terminal and/or the error log explaining what is wrong.</source>
          <target state="translated">Не удалось запустить один из процессов ядра. Вероятно, это связано с ошибочными аргументами (например, ошибками в аргументе &lt;code&gt;-config&lt;/code&gt; ) или ошибочными файлами конфигурации. Убедитесь, что все файлы находятся в правильном месте и что файлы конфигурации (если есть) не повреждены. Обычно в управляющий терминал и / или в журнал ошибок также записываются сообщения, объясняющие, что не так.</target>
        </trans-unit>
        <trans-unit id="0841995ee62550fe5206c50f4fb1982a4e801b20" translate="yes" xml:space="preserve">
          <source>One of the main reasons for using Erlang instead of other functional languages is Erlang's ability to handle concurrency and distributed programming. By concurrency is meant programs that can handle several threads of execution at the same time. For example, modern operating systems allow you to use a word processor, a spreadsheet, a mail client, and a print job all running at the same time. Each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs at such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an Erlang program and to allow these threads to communicate with each other. In Erlang, each thread of execution is called a &lt;strong&gt;process&lt;/strong&gt;.</source>
          <target state="translated">Одной из основных причин использования Erlang вместо других функциональных языков является способность Erlang обрабатывать параллелизм и распределенное программирование. Под параллелизмом подразумеваются программы, которые могут обрабатывать несколько потоков выполнения одновременно. Например, современные операционные системы позволяют одновременно использовать текстовый процессор, электронную таблицу, почтовый клиент и задание на печать. Каждый процессор (ЦП) в системе, вероятно, обрабатывает только один поток (или задание) за раз, но он переключается между заданиями с такой скоростью, что создается иллюзия выполнения их всех одновременно. В программе Erlang легко создать параллельные потоки выполнения и позволить этим потокам взаимодействовать друг с другом. В Erlang каждый поток выполнения называется &lt;strong&gt;процессом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3a03a73b3fd84a50282a6c958644d8dd3d3c26" translate="yes" xml:space="preserve">
          <source>One of the possible &lt;strong&gt;transition actions&lt;/strong&gt; is to postpone the current event. Then it is not retried in the current state. The &lt;code&gt;gen_statem&lt;/code&gt; engine keeps a queue of events divided into the postponed events and the events still to process. After a &lt;strong&gt;state change&lt;/strong&gt; the queue restarts with the postponed events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c1395f01aa6569ad6f5518bd05795ed28e86fb" translate="yes" xml:space="preserve">
          <source>One of the things you can specify is where Erlang/OTP should be installed. By default Erlang/OTP will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. To keep the same structure but install in a different place, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; say, use the &lt;code&gt;--prefix&lt;/code&gt; argument like this: &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вы можете указать, где должен быть установлен Erlang / OTP. По умолчанию Erlang / OTP будет установлен в &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; . Чтобы сохранить ту же структуру, но установить в другом месте, скажем , &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; , используйте аргумент &lt;code&gt;--prefix&lt;/code&gt; следующим образом: &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eeb7842fcafd703c9e0619139450ba12ea61a05" translate="yes" xml:space="preserve">
          <source>One of the tuples is &lt;code&gt;{timeout, GcTime}&lt;/code&gt;, where &lt;code&gt;GcTime&lt;/code&gt; is the time for the garbage collection in milliseconds. The other tuples are tagged with &lt;code&gt;heap_size&lt;/code&gt;, &lt;code&gt;heap_block_size&lt;/code&gt;, &lt;code&gt;stack_size&lt;/code&gt;, &lt;code&gt;mbuf_size&lt;/code&gt;, &lt;code&gt;old_heap_size&lt;/code&gt;, and &lt;code&gt;old_heap_block_size&lt;/code&gt;. These tuples are explained in the description of trace message &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;). New tuples can be added, and the order of the tuples in the &lt;code&gt;Info&lt;/code&gt; list can be changed at any time without prior notice.</source>
          <target state="translated">Один из кортежей - &lt;code&gt;{timeout, GcTime}&lt;/code&gt; , где &lt;code&gt;GcTime&lt;/code&gt; - время сборки мусора в миллисекундах. Другие кортежи помечены тегами &lt;code&gt;heap_size&lt;/code&gt; , &lt;code&gt;heap_block_size&lt;/code&gt; , &lt;code&gt;stack_size&lt;/code&gt; , &lt;code&gt;mbuf_size&lt;/code&gt; , &lt;code&gt;old_heap_size&lt;/code&gt; и &lt;code&gt;old_heap_block_size&lt;/code&gt; . Эти кортежи объясняются в описании сообщения трассировки &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; (см. &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; ). Могут быть добавлены новые кортежи, а порядок кортежей в списке &lt;code&gt;Info&lt;/code&gt; может быть изменен в любое время без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="69a9014859b12f37b0519806ad1834d826c6c31a" translate="yes" xml:space="preserve">
          <source>One of these MIBs is always loaded. If only SNMPv1 is used, STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.</source>
          <target state="translated">Один из этих MIB всегда загружен.Если используется только SNMPv1,загружается СТАНДАРТНЫЙ MIB,в противном случае загружается SNMPv2-MIB.</target>
        </trans-unit>
        <trans-unit id="7e580959901caa525ce54698db0283f68f4a7825" translate="yes" xml:space="preserve">
          <source>One option is available:</source>
          <target state="translated">Доступен один вариант:</target>
        </trans-unit>
        <trans-unit id="6ff4f2ec7cb45924fc22a9581c0d12e7c6a17439" translate="yes" xml:space="preserve">
          <source>One or more records have possibly been deleted. All records with the key &lt;code&gt;Key&lt;/code&gt; in the table &lt;code&gt;Tab&lt;/code&gt; have been deleted.</source>
          <target state="translated">Возможно, были удалены одна или несколько записей. Все записи с ключом &lt;code&gt;Key&lt;/code&gt; в таблице &lt;code&gt;Tab&lt;/code&gt; удалены.</target>
        </trans-unit>
        <trans-unit id="6fa66ab663063997cdb9c048f7104f3433cd5c89" translate="yes" xml:space="preserve">
          <source>One or more selective decode functions can be described in a configuration file. Use the following notation:</source>
          <target state="translated">Одна или несколько селективных функций декодирования могут быть описаны в конфигурационном файле.Используйте следующую нотацию:</target>
        </trans-unit>
        <trans-unit id="2e8538d4b29bcc1590b46f99d089134dbfb209ae" translate="yes" xml:space="preserve">
          <source>One possible use of this function is to compute a fixed layout for a document, which can then be included as part of a larger document. For example:</source>
          <target state="translated">Одним из возможных способов использования этой функции является вычисление фиксированного макета документа,который затем может быть включен в более крупный документ.Например:</target>
        </trans-unit>
        <trans-unit id="f814b315540a519172775a3b2360fd1f8b22e518" translate="yes" xml:space="preserve">
          <source>One process can block multi-scheduling and normal multi-scheduling multiple times. If a process has blocked multiple times, it must unblock exactly as many times as it has blocked before it has released its multi-scheduling block. If a process that has blocked multi-scheduling or normal multi-scheduling exits, it automatically releases its blocking of multi-scheduling and normal multi-scheduling.</source>
          <target state="translated">Один процесс может блокировать многократное и обычное многократное планирование.Если процесс блокировался несколько раз,он должен разблокировать ровно столько раз,сколько раз блокировался,прежде чем освободить свой блок мультипрограммирования.Если процесс,заблокировавший многократное или нормальное многократное расписание,выходит из процесса,то он автоматически снимает блокировку многократного и нормального многократного расписания.</target>
        </trans-unit>
        <trans-unit id="4e1d0d9b681492f79f0f0d77d94d063833656c4e" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">Одна из причин для использования этого - когда у вас есть элемент состояния, который при изменении должен отменять &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; , или тот, который влияет на обработку событий в сочетании с отложенными событиями. Мы воспользуемся последним и усложним предыдущий пример, введя настраиваемую кнопку блокировки (это рассматриваемый элемент состояния), которая в &lt;code&gt;open&lt;/code&gt; состоянии немедленно блокирует дверь, и функцию API &lt;code&gt;set_lock_button/1&lt;/code&gt; для установки кнопки блокировки.</target>
        </trans-unit>
        <trans-unit id="f23d4aa95b25f50a19f9b6b4374f1b88dac66685" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a0ffbab932f1acb483f5ff3812f8940806157e" translate="yes" xml:space="preserve">
          <source>One slight difference is that &lt;code&gt;length(L)&lt;/code&gt; fails if &lt;code&gt;L&lt;/code&gt; is an improper list, while the pattern in the second code fragment accepts an improper list.</source>
          <target state="translated">Одно небольшое отличие состоит в том, что &lt;code&gt;length(L)&lt;/code&gt; не выполняется, если &lt;code&gt;L&lt;/code&gt; - неправильный список, в то время как шаблон во втором фрагменте кода принимает неправильный список.</target>
        </trans-unit>
        <trans-unit id="131ac9dcf4813fc8eef42652b85941c718619c49" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to make the snmp application a distributed Erlang application, and that means, the agent may be configured to run on one of several nodes. If the node where it runs goes down, another node restarts the agent. This is called &lt;strong&gt;failover&lt;/strong&gt;. When the node starts again, it may &lt;strong&gt;takeover&lt;/strong&gt; the application. This solution to the problem adds another problem. Generally, the new node has another IP address than the first one, which may cause problems in the communication between the SNMP managers and the agent.</source>
          <target state="translated">Одно из решений этой проблемы - сделать приложение snmp распределенным приложением Erlang, а это означает, что агент может быть настроен для работы на одном из нескольких узлов. Если узел, на котором он работает, выходит из строя, другой узел перезапускает агент. Это называется &lt;strong&gt;аварийным переключением&lt;/strong&gt; . Когда узел запускается снова, он может &lt;strong&gt;захватить&lt;/strong&gt; приложение. Это решение проблемы добавляет еще одну проблему. Как правило, новый узел имеет IP-адрес, отличный от первого, что может вызвать проблемы при обмене данными между менеджерами SNMP и агентом.</target>
        </trans-unit>
        <trans-unit id="4512e5220c29e6a7833a429e6e4b986d799dd593" translate="yes" xml:space="preserve">
          <source>One such debug functionality is the &lt;strong&gt;lock checker&lt;/strong&gt;, which can detect locking order violations and thereby potential deadlock bugs. For the lock checker to work the &lt;code&gt;name&lt;/code&gt; should be on the format &lt;code&gt;&quot;App.Type&quot;&lt;/code&gt; or &lt;code&gt;&quot;App.Type[Instance]&quot;&lt;/code&gt;, where App is the name of the application, Type is the name of the lock type and Instance is optional information about each lock instance. &quot;App.Type&quot; should be a unique name for the lock checker to detect lock order violations between locks of different types. The Instance information is currently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de0b12460a91c3f5fd94e39bda2873b3f5b7b16" translate="yes" xml:space="preserve">
          <source>One that allows the state to be any term and that uses one callback function for all states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae865e27e4e371daac0c98d141254785bdec512" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log.</source>
          <target state="translated">Одним из способов использования этой функции является возврат компактных альтернативных представлений состояния,чтобы избежать распечатывания больших терминов состояния в лог-файлах.Другое применение-скрытие конфиденциальных данных от записи в журнал ошибок.</target>
        </trans-unit>
        <trans-unit id="2344ac8a5a53008ccbf114aa5bb4b2144babab77" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.</source>
          <target state="translated">Одним из способов использования этой функции является возврат компактных альтернативных представлений состояния во избежание того,чтобы в лог-файлах распечатывались большие термины состояния.</target>
        </trans-unit>
        <trans-unit id="ecf62d4adfa3a80a6880d79089f74bc1229726c5" translate="yes" xml:space="preserve">
          <source>One valid &lt;code&gt;Item&lt;/code&gt; for events exists:</source>
          <target state="translated">Существует один действительный &lt;code&gt;Item&lt;/code&gt; для событий:</target>
        </trans-unit>
        <trans-unit id="a1de3f4f0701ff8998dbe849ff16761b4287d4cb" translate="yes" xml:space="preserve">
          <source>One way to handle this is to use the &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;shutdown&lt;/a&gt;&lt;/code&gt; function (&lt;code&gt;socket:shutdown(Socket, write)&lt;/code&gt;) to signal that no more data is to be sent and then wait for the read side of the socket to be closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dac560fa843dd6f0f972d52ed8040ce20cb74d" translate="yes" xml:space="preserve">
          <source>One way to reduce the risk of intrusion is to not convey which software and which version the intruder is connected to. This limits the risk of an intruder exploiting known faults or peculiarities learned by reading the public code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0530e4915fd69c53963bcd7d20091d18ef6b916a" translate="yes" xml:space="preserve">
          <source>One without restriction on the state data type that uses one callback function for all states</source>
          <target state="translated">Один без ограничения типа данных состояния,который использует одну функцию обратного вызова для всех состояний.</target>
        </trans-unit>
        <trans-unit id="125ef9e0e55df17c031033b5d420b053905b830e" translate="yes" xml:space="preserve">
          <source>Online Help</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbd38dfe616170f1b6def311df7bb7a510f025b" translate="yes" xml:space="preserve">
          <source>Online support - &lt;code&gt;release_handler&lt;/code&gt; for unpacking and installing release packages</source>
          <target state="translated">Онлайн-поддержка - &lt;code&gt;release_handler&lt;/code&gt; для распаковки и установки релизных пакетов</target>
        </trans-unit>
        <trans-unit id="ae87ac2b337c683a338363cdb6dd6e6e3a876d81" translate="yes" xml:space="preserve">
          <source>Only a subset is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e8ca2afe642fa985ec03b77e6580554e8210e3" translate="yes" xml:space="preserve">
          <source>Only a subset of all &lt;code&gt;erts_alloc&lt;/code&gt; flags can be changed at run time. This subset is currently only the flag &lt;code&gt;sbct&lt;/code&gt;.</source>
          <target state="translated">Только часть всех флагов &lt;code&gt;erts_alloc&lt;/code&gt; может быть изменена во время выполнения. Это подмножество в настоящее время представляет собой только флаг &lt;code&gt;sbct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fc50435c4f101d7fcbdd1178cc4fb637fb7e775" translate="yes" xml:space="preserve">
          <source>Only a subset of the function clauses are show above. The full set of valid combinations of input parameters is as follows:</source>
          <target state="translated">Выше показано только подмножество положений о функциях.Полный набор действительных комбинаций входных параметров выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a71b05d84131dd4964afd0db7b460b38e844ff2b" translate="yes" xml:space="preserve">
          <source>Only actual parameters with other than default values are returned, for example not directives that specify other sources for configuration parameters nor directives that clear parameters.</source>
          <target state="translated">Возвращаются только фактические параметры,отличные от значений по умолчанию,например,не директивы,указывающие другие источники для конфигурационных параметров,и не директивы,очищающие параметры.</target>
        </trans-unit>
        <trans-unit id="143811c603bbe64ab0e87b64c4ca39d3733d06c3" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;if&lt;/code&gt; or another &lt;code&gt;elif&lt;/code&gt; directive. If the preceding &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;elif&lt;/code&gt; directives do not evaluate to true, and the &lt;code&gt;Condition&lt;/code&gt; evaluates to true, the lines following the &lt;code&gt;elif&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">Разрешено только после &lt;code&gt;if&lt;/code&gt; или другой директивы &lt;code&gt;elif&lt;/code&gt; . Если предыдущие директивы &lt;code&gt;if&lt;/code&gt; или &lt;code&gt;elif&lt;/code&gt; не оцениваются как истинные, а &lt;code&gt;Condition&lt;/code&gt; оценивается как истинное, вместо этого оцениваются строки, следующие за &lt;code&gt;elif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e65766f3d400fa0c4ec2ec7f3b23a8557087a78" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;ifdef&lt;/code&gt; or &lt;code&gt;ifndef&lt;/code&gt; directive. If that condition is false, the lines following &lt;code&gt;else&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">Допустимо только после &lt;code&gt;ifdef&lt;/code&gt; или &lt;code&gt;ifndef&lt;/code&gt; директивы. Если это условие ложно, вместо этого оцениваются строки, следующие за &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03727b1fe9878a4627e85a8cbe80d475296b011b" translate="yes" xml:space="preserve">
          <source>Only allowed for connection-oriented sockets.</source>
          <target state="translated">Разрешается использовать только розетки,ориентированные на подключение.</target>
        </trans-unit>
        <trans-unit id="b872c6846f1badf545548103fe27329f7bb9d68b" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags &lt;/code&gt; emulator option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a32ac3b85acdfc340d76cd1ade965319d5c1792" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; emulator option.</source>
          <target state="translated">По умолчанию тегами помечаются только двоичные файлы и выделения, сделанные NIF и драйверами, но это можно настроить для каждого распределителя с помощью &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; эмулятора + M &amp;lt;S&amp;gt; atags .</target>
        </trans-unit>
        <trans-unit id="3f8fcfa18b8b4298ae4d967d6d04b8aabbe6553a" translate="yes" xml:space="preserve">
          <source>Only exceptions occurring during the evaluation of &lt;code&gt;Exprs&lt;/code&gt; can be caught by the &lt;code&gt;catch&lt;/code&gt; section. Exceptions occurring in a &lt;code&gt;Body&lt;/code&gt; or due to a failed match are not caught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ee0b816fb973da72fef21bb99316a4666d0fe2" translate="yes" xml:space="preserve">
          <source>Only explicit connection set-ups are used.</source>
          <target state="translated">Используются только явные настройки соединения.</target>
        </trans-unit>
        <trans-unit id="965fd205ec4a5be006cc4bdca91e080bb904b491" translate="yes" xml:space="preserve">
          <source>Only files with exactly these extensions are compressed.</source>
          <target state="translated">Сжимаются только файлы с такими расширениями.</target>
        </trans-unit>
        <trans-unit id="d800e233c81231deb85380be879f6765bb0a09d1" translate="yes" xml:space="preserve">
          <source>Only if a shell script or &lt;code&gt;.bat&lt;/code&gt; file is executed, the appropriate command interpreter is invoked implicitly, but there is still no command-argument expansion or implicit &lt;code&gt;PATH&lt;/code&gt; search.</source>
          <target state="translated">Только если сценарий оболочки или &lt;code&gt;.bat&lt;/code&gt; - файл выполняется, соответствующий командный интерпретатор вызывается неявно, но до сих пор никакого расширения командной аргумент или неявной &lt;code&gt;PATH&lt;/code&gt; поиска.</target>
        </trans-unit>
        <trans-unit id="6e308954fb7661938a56cab2015555144c20f290" translate="yes" xml:space="preserve">
          <source>Only if a string contains code points &amp;lt; 256, can it be directly converted to a binary by using, for example, &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; or can be sent directly to a port. If the string contains Unicode characters &amp;gt; 255, an encoding must be decided upon and the string is to be converted to a binary in the preferred encoding using &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt;. Strings are not generally lists of bytes, as they were before Erlang/OTP R13, they are lists of characters. Characters are not generally bytes, they are Unicode code points.</source>
          <target state="translated">Только если строка содержит кодовые точки &amp;lt;256, она может быть напрямую преобразована в двоичный файл, используя, например, &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; , или может быть отправлена ​​непосредственно в порт. Если строка содержит символы Unicode&amp;gt; 255, необходимо выбрать кодировку и преобразовать строку в двоичный код в предпочтительной кодировке с использованием &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; . Строки обычно не являются списками байтов, как это было до Erlang / OTP R13, это списки символов. Символы обычно не являются байтами, это кодовые точки Unicode.</target>
        </trans-unit>
        <trans-unit id="660019367304634239f33b92fdff61cb41611c83" translate="yes" xml:space="preserve">
          <source>Only if the server is in the confirmed commit phase, the configuration is restored to its state before entering the confirmed commit phase. Otherwise, no configuration rollback is performed.</source>
          <target state="translated">Только если сервер находится в фазе подтверждённой фиксации,конфигурация восстанавливается до входа в фазу подтверждённой фиксации.В противном случае откат конфигурации не производится.</target>
        </trans-unit>
        <trans-unit id="cbd2fd09cd558a21021b0e71892ab5c5ffaa9a70" translate="yes" xml:space="preserve">
          <source>Only matters for matching and when the type is &lt;code&gt;integer&lt;/code&gt;. The default is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">Имеет значение только для соответствия и когда тип является &lt;code&gt;integer&lt;/code&gt; . По умолчанию &lt;code&gt;unsigned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ac47075244f080582d68564475ba1c72e44655e" translate="yes" xml:space="preserve">
          <source>Only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted. Non-interpretable modules are displayed within parenthesis in the Interpret Modules window.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; можно только модули, скомпилированные с установленной опцией debug_info . Неинтерпретируемые модули отображаются в круглых скобках в окне &amp;laquo;Интерпретировать модули&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2d63c1fd79def5aea280eb8e5551a9a4f8acf4ef" translate="yes" xml:space="preserve">
          <source>Only on 64-bit halfword emulator. The total amount of memory allocated in low memory areas that are restricted to &amp;lt; 4 GB, although the system can have more memory.</source>
          <target state="translated">Только на 64-битном эмуляторе полуслова. Общий объем памяти, выделенной в областях с низким объемом памяти, которые ограничены &amp;lt;4 ГБ, хотя в системе может быть больше памяти.</target>
        </trans-unit>
        <trans-unit id="f8b4dc2954832ab8284b54f1deee60e8ee9f12e3" translate="yes" xml:space="preserve">
          <source>Only one &lt;code&gt;MonitorOption&lt;/code&gt; can be specified. It is one of the following:</source>
          <target state="translated">Можно указать только один параметр &lt;code&gt;MonitorOption&lt;/code&gt; . Это одно из следующих:</target>
        </trans-unit>
        <trans-unit id="16b381e1eb19d06546da0fffa061890639f875ed" translate="yes" xml:space="preserve">
          <source>Only one byte long and only two bits are significant, the rest must be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1021bb495145f4a605a8bf15b6c7510ce41d42c" translate="yes" xml:space="preserve">
          <source>Only one copy of T exists on the heap and during the garbage collection only the first time T is encountered will it be copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d25510eb44623309c6a466f80982b971e3a79b" translate="yes" xml:space="preserve">
          <source>Only one entry of this type is allowed.</source>
          <target state="translated">Разрешена только одна запись этого типа.</target>
        </trans-unit>
        <trans-unit id="2f8db1c5a163c86ad59a6d1922863061872c37b3" translate="yes" xml:space="preserve">
          <source>Only one table is loaded by &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt;. Since committed transactions can have caused updates in several tables, the tables can become inconsistent because of the forced load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; загружает только одну таблицу : force_load_table (Tab) . Поскольку зафиксированные транзакции могут вызвать обновления в нескольких таблицах, таблицы могут стать несовместимыми из-за принудительной загрузки.</target>
        </trans-unit>
        <trans-unit id="203a271e69e1e6f8cf93e61cb78904664002dc4b" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt; erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt; erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92ee7eb3618038b399f136fb76be40e18e1bc01" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">Здесь представлены только некоторые значения по умолчанию. Для получения информации о текущих настройках и текущем состоянии распределителей см. &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; и &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17e89dc2513b107dcc6a0275a1a3c98d68b4387b" translate="yes" xml:space="preserve">
          <source>Only support running Cover on the local node. This function must be called before any modules have been compiled or any nodes added. When running in this mode, modules will be Cover compiled in a more efficient way, but the resulting code will only work on the same node they were compiled on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e55a508bb5366d1ba41f1b8cc19d785d5f6e26" translate="yes" xml:space="preserve">
          <source>Only supported if ERTS was compiled with zlib &amp;gt;= 1.2.8.</source>
          <target state="translated">Поддерживается, только если ERTS был скомпилирован с zlib&amp;gt; = 1.2.8.</target>
        </trans-unit>
        <trans-unit id="e0c3b6c96d4a056b1891213af8fe63652b6f147a" translate="yes" xml:space="preserve">
          <source>Only supported when the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_SPAWN&quot;&gt;DFLAG_SPAWN&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flag&lt;/a&gt;&lt;/code&gt; has been passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1405eb7cb56be68779595f26b14d02a57896c6d6" translate="yes" xml:space="preserve">
          <source>Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported.</source>
          <target state="translated">Поддерживаются только методы DEFLATE (zlib-сжатие)и STORE (несжатые данные)zip.</target>
        </trans-unit>
        <trans-unit id="be533a124805e79fe90a76852bcb557c73fc2e89" translate="yes" xml:space="preserve">
          <source>Only the Erlang process that opened the file can use it.</source>
          <target state="translated">Использовать его может только процесс Erlang,который открыл файл.</target>
        </trans-unit>
        <trans-unit id="eff26c5132f4e18c3af8859f76e7ae06eef0123a" translate="yes" xml:space="preserve">
          <source>Only the currently connected job can 'talk' to the shell.</source>
          <target state="translated">Только работа,подключенная в данный момент,может &quot;разговаривать&quot; с оболочкой.</target>
        </trans-unit>
        <trans-unit id="a03597ea953bd3b370af7ca4b5066ffbc33977b3" translate="yes" xml:space="preserve">
          <source>Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</source>
          <target state="translated">Только первая захваченная подмаска,которая всегда является полностью соответствующей частью объекта.Все явно захваченные подмаски отбрасываются.</target>
        </trans-unit>
        <trans-unit id="b70de51c32ae79e58749256bc1925f2b5088935f" translate="yes" xml:space="preserve">
          <source>Only the following metacharacters are recognized in character classes:</source>
          <target state="translated">В классах символов распознаются только следующие мета-символы:</target>
        </trans-unit>
        <trans-unit id="f8c7ec7f774783186ec033a3872a8ed95ec657d5" translate="yes" xml:space="preserve">
          <source>Only the owner process can read or write to the table.</source>
          <target state="translated">Читать или записывать в таблицу может только владелец процесса.</target>
        </trans-unit>
        <trans-unit id="ae72d9870b541f6e2a7d88226bfd5d4e90663a8e" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function unless an alternate input handler process has been registered using &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt;. If an alternate input handler has been registered, only the registered input handler process is allowed to call this function.</source>
          <target state="translated">Только процесс, зарегистрированный как контроллер распределения для канала распространения, идентифицированного &lt;code&gt;DHandle&lt;/code&gt; , может вызывать эту функцию, если альтернативный процесс обработчика ввода не был зарегистрирован с помощью &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt; . Если зарегистрирован альтернативный обработчик ввода, только зарегистрированный процесс обработчика ввода может вызывать эту функцию.</target>
        </trans-unit>
        <trans-unit id="0120f9c54ff86c06696b34a4219af2378345acdb" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function.</source>
          <target state="translated">Только процесс, зарегистрированный как контроллер распределения для канала распределения, идентифицированного &lt;code&gt;DHandle&lt;/code&gt; , может вызывать эту функцию.</target>
        </trans-unit>
        <trans-unit id="97a2d2b2787c40ce488cca6bc1ab1989c6ad75b7" translate="yes" xml:space="preserve">
          <source>Only the process that created the digraph is allowed to update it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7ef46b3f7713cb10f8c8f5e86db36f63612540" translate="yes" xml:space="preserve">
          <source>Only the specified part is searched. Return values still have offsets from the beginning of &lt;code&gt;Subject&lt;/code&gt;. A negative &lt;code&gt;Length&lt;/code&gt; is allowed as described in section Data Types in this manual.</source>
          <target state="translated">Ищется только указанная часть. Возвращаемые значения по-прежнему имеют смещения от начала &lt;code&gt;Subject&lt;/code&gt; . Допускается отрицательная &lt;code&gt;Length&lt;/code&gt; как описано в разделе &amp;laquo;Типы данных&amp;raquo; этого руководства.</target>
        </trans-unit>
        <trans-unit id="92b1c560a3c609b6630ba6369a93d7159051e3e5" translate="yes" xml:space="preserve">
          <source>Only these exact character sequences are recognized. A sequence such as [a[:&amp;lt;:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \b matches at the start and the end of a word (see &quot;Simple assertions&quot; above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour.</source>
          <target state="translated">Распознаются только эти точные последовательности символов. Последовательность, такая как [a [: &amp;lt;:] b], вызывает ошибку для нераспознанного имени класса POSIX. Эта поддержка несовместима с Perl. Он предоставляется для облегчения миграции из других сред, и его лучше не использовать в каких-либо новых шаблонах. Обратите внимание, что \ b соответствует началу и концу слова (см. &amp;laquo;Простые утверждения&amp;raquo; выше), а в шаблоне в стиле Perl предшествующий или следующий символ обычно показывает, что требуется, без необходимости использования утверждений. выше, чтобы точно передать поведение POSIX.</target>
        </trans-unit>
        <trans-unit id="17d1fba9658ded214a434ab7601d513e4c6c5aaf" translate="yes" xml:space="preserve">
          <source>Only total</source>
          <target state="translated">Всего</target>
        </trans-unit>
        <trans-unit id="b466165e837dbf10eadb47e4bc9b893d7bb50387" translate="yes" xml:space="preserve">
          <source>Only trace messages from a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">Отслеживать сообщения только от определенного &lt;code&gt;Pid&lt;/code&gt; процесса :</target>
        </trans-unit>
        <trans-unit id="e5bfc32b55921a00a28f4c0d1a74dc4ff5f9f2ba" translate="yes" xml:space="preserve">
          <source>Only trace messages from other nodes:</source>
          <target state="translated">Отслеживать только сообщения с других узлов:</target>
        </trans-unit>
        <trans-unit id="78247ecb104811399c3277cdd7d4c731768a72b0" translate="yes" xml:space="preserve">
          <source>Only trace messages matching &lt;code&gt;{reply, _}&lt;/code&gt;:</source>
          <target state="translated">Отслеживать только сообщения, соответствующие &lt;code&gt;{reply, _}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7666550505039a9e83e909935389e4f3ca8ed6d8" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to other nodes:</source>
          <target state="translated">Отслеживать только сообщения,отправленные на другие узлы:</target>
        </trans-unit>
        <trans-unit id="550dd65f9f1635f5b26d39adb415360c2a92434a" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to the sender itself:</source>
          <target state="translated">Отслеживаются только сообщения,отправленные самому отправителю:</target>
        </trans-unit>
        <trans-unit id="2500bda55ee606fa893cbad9220ec886375e6705" translate="yes" xml:space="preserve">
          <source>Only trace messages to a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">Отслеживать сообщения только до определенного &lt;code&gt;Pid&lt;/code&gt; процесса :</target>
        </trans-unit>
        <trans-unit id="42b574e1ef29bfa437b36acb9027769673eb223a" translate="yes" xml:space="preserve">
          <source>Only two arguments, of which one must be &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;false&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt;; otherwise &lt;code&gt;'xor'&lt;/code&gt; returns false.</source>
          <target state="translated">Только два аргумента, из которых один должен быть &lt;code&gt;true&lt;/code&gt; а другой - &lt;code&gt;false&lt;/code&gt; чтобы вернуть &lt;code&gt;true&lt;/code&gt; ; в противном случае &lt;code&gt;'xor'&lt;/code&gt; возвращает false.</target>
        </trans-unit>
        <trans-unit id="a84b39b2c86b869fad86343fd9fef89839964e4b" translate="yes" xml:space="preserve">
          <source>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</source>
          <target state="translated">Используйте эти флаги только в том случае,если вы уверены в том,что делаете.Неподходящие настройки могут привести к серьезному снижению производительности и даже к сбою системы в любой момент во время работы.</target>
        </trans-unit>
        <trans-unit id="4d7818114df4175719fb624ea7ed7fe90002e953" translate="yes" xml:space="preserve">
          <source>Only used during handshake phase.</source>
          <target state="translated">Используется только во время фазы рукопожатия.</target>
        </trans-unit>
        <trans-unit id="63f8061fc22c121f41217cd28e783b48e49934d5" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. It allows the standard input and output (file descriptors 0 and 1) of the spawned (Unix) process for communication with Erlang.</source>
          <target state="translated">Действительно только для &lt;code&gt;{spawn, Command}&lt;/code&gt; и &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; . Он позволяет стандартный ввод и вывод (файловые дескрипторы 0 и 1) порожденного (Unix) процесса для связи с Erlang.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
