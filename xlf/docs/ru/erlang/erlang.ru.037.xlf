<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="d651b987b0a7139ea05af6dee8d526234f2fc5bb" translate="yes" xml:space="preserve">
          <source>Type &quot;2 + 5.&quot; in the shell and then press Enter (carriage return). Notice that you tell the shell you are done entering code by finishing with a full stop &quot;.&quot; and a carriage return.</source>
          <target state="translated">Введите &quot;2+5.&quot; в оболочку и нажмите Enter (возврат каретки).Обратите внимание,что вы сообщите оболочке,что ввод кода завершен,завершив полный стоп &quot;...&quot; и возврат каретки.</target>
        </trans-unit>
        <trans-unit id="58364f896fc728f993e560667ecfb60de4f30fa0" translate="yes" xml:space="preserve">
          <source>Type &quot;a&quot; to leave the Erlang system.</source>
          <target state="translated">Введите &quot;а&quot;,чтобы покинуть систему Эрланга.</target>
        </trans-unit>
        <trans-unit id="bb5acf833432a1b10201899b4168eeb24706098c" translate="yes" xml:space="preserve">
          <source>Type ::= &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</source>
          <target state="translated">Тип :: = &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eca7274bab6669941602b10cce52d6006cb9d4c5" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt;, that is, the HTTP method.</source>
          <target state="translated">Введите &lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt; , то есть метод HTTP.</target>
        </trans-unit>
        <trans-unit id="7b17bb0639b15e0f667e2fd419629250d1fac8bc" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt;. &lt;code&gt;parsed_header&lt;/code&gt; contains all HTTP header fields from the HTTP request stored in a list as key-value tuples. See &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; for a listing of all header fields. For example, the date field is stored as &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt;. RFC 2616 defines that HTTP is a case-insensitive protocol and the header fields can be in lower case or upper case. &lt;code&gt;httpd&lt;/code&gt; ensures that all header field names are in lower case.</source>
          <target state="translated">Введите &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt; . &lt;code&gt;parsed_header&lt;/code&gt; содержит все поля заголовка HTTP из HTTP-запроса, хранящегося в списке в виде кортежей &quot;ключ-значение&quot;. См. &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; для получения списка всех полей заголовка. Например, поле даты хранится как &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt; . RFC 2616 определяет, что HTTP - это протокол без учета регистра, а поля заголовка могут быть в нижнем или верхнем регистре. &lt;code&gt;httpd&lt;/code&gt; гарантирует, что все имена полей заголовка будут в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="88ea934d5b010cb0dc7ac9b9cf16bdd13e544370" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; is used to propagate data between modules. Depicted &lt;code&gt;interaction_data()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">Тип &lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; используется для передачи данных между модулями. Изображено &lt;code&gt;interaction_data()&lt;/code&gt; в объявлениях типов функций.</target>
        </trans-unit>
        <trans-unit id="1a1f7e9e5b0f8e672e72370d1ca9a97b0c0c8e01" translate="yes" xml:space="preserve">
          <source>Type UTF8String is represented as a UTF-8 encoded binary in Erlang. Such binaries can be created directly using the binary syntax or by converting from a list of Unicode code points using function &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">Тип UTF8String представлен в Erlang как двоичный код в кодировке UTF-8. Такие двоичные файлы могут быть созданы непосредственно с использованием двоичного синтаксиса или путем преобразования из списка кодовых точек Unicode с помощью функции &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b347ce4e1bb3f750a45e84a0eec8e47bcbc5d1c" translate="yes" xml:space="preserve">
          <source>Type declarations can also be parameterized by including type variables between the parentheses. The syntax of type variables is the same as Erlang variables, that is, starts with an upper-case letter. Naturally, these variables can - and is to - appear on the RHS of the definition. A concrete example follows:</source>
          <target state="translated">Объявления типов также могут быть параметризованы путем включения переменных типов между скобками.Синтаксис переменных типа аналогичен синтаксису переменных типа Erlang,т.е.начинается с заглавной буквы.Естественно,эти переменные могут-и должны-появляться на RHS определения.Ниже приводится конкретный пример:</target>
        </trans-unit>
        <trans-unit id="6300b103de258ff822aa6629b9e4238dd2a5ce7d" translate="yes" xml:space="preserve">
          <source>Type definitions related to HTTP:</source>
          <target state="translated">Определения типов,связанных с HTTP:</target>
        </trans-unit>
        <trans-unit id="833b41c81d15ae09af14347e83ccba5147adbd10" translate="yes" xml:space="preserve">
          <source>Type definitions that are related to URI:</source>
          <target state="translated">Определения типов,которые связаны с URI:</target>
        </trans-unit>
        <trans-unit id="b644ccc50476a72e86f7c39296fad76704713706" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module, or abstractions to indicate the intended use of the data type, or both:</source>
          <target state="translated">Определения типов,которые используются более одного раза в данном модуле,или абстракции для обозначения предполагаемого использования типа данных,или и то,и другое:</target>
        </trans-unit>
        <trans-unit id="d2cf34335496de985396b3065117c3a7c2a8fa2b" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module:</source>
          <target state="translated">Определения типов,которые используются более одного раза в данном модуле:</target>
        </trans-unit>
        <trans-unit id="dfb0b5d119973a2ca756d65efb3094aa7a2749aa" translate="yes" xml:space="preserve">
          <source>Type information can be used for the following:</source>
          <target state="translated">Типовая информация может быть использована для следующих целей:</target>
        </trans-unit>
        <trans-unit id="3ebeb58712dc090b9f1c0c555b88300efc0c9f1b" translate="yes" xml:space="preserve">
          <source>Type makensis at the bash prompt and you should get a list of options if everything is OK.</source>
          <target state="translated">Введите makensis в строке bash,и вы должны получить список опций,если все в порядке.</target>
        </trans-unit>
        <trans-unit id="e5d444f8eae5fc410e04ffff9e480446db812725" translate="yes" xml:space="preserve">
          <source>Type of lock: &lt;code&gt;rw_mutex&lt;/code&gt;, &lt;code&gt;mutex&lt;/code&gt;, &lt;code&gt;spinlock&lt;/code&gt;, &lt;code&gt;rw_spinlock&lt;/code&gt; or &lt;code&gt;proclock&lt;/code&gt;.</source>
          <target state="translated">Тип замка: &lt;code&gt;rw_mutex&lt;/code&gt; , &lt;code&gt;mutex&lt;/code&gt; , &lt;code&gt;spinlock&lt;/code&gt; , &lt;code&gt;rw_spinlock&lt;/code&gt; или &lt;code&gt;proclock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab1c2b1113b129c21326cea282b309a413da68f9" translate="yes" xml:space="preserve">
          <source>Type tests: &lt;code&gt;is_atom&lt;/code&gt;, &lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_integer&lt;/code&gt;, &lt;code&gt;is_list&lt;/code&gt;, &lt;code&gt;is_number&lt;/code&gt;, &lt;code&gt;is_pid&lt;/code&gt;, &lt;code&gt;is_port&lt;/code&gt;, &lt;code&gt;is_reference&lt;/code&gt;, &lt;code&gt;is_tuple&lt;/code&gt;, &lt;code&gt;is_binary&lt;/code&gt;, &lt;code&gt;is_function&lt;/code&gt;, &lt;code&gt;is_record&lt;/code&gt;</source>
          <target state="translated">Типовые тесты: &lt;code&gt;is_atom&lt;/code&gt; , &lt;code&gt;is_float&lt;/code&gt; , &lt;code&gt;is_integer&lt;/code&gt; , &lt;code&gt;is_list&lt;/code&gt; , &lt;code&gt;is_number&lt;/code&gt; , &lt;code&gt;is_pid&lt;/code&gt; , &lt;code&gt;is_port&lt;/code&gt; , &lt;code&gt;is_reference&lt;/code&gt; , &lt;code&gt;is_tuple&lt;/code&gt; , &lt;code&gt;is_binary&lt;/code&gt; , &lt;code&gt;is_function&lt;/code&gt; , &lt;code&gt;is_record&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca8a72020b7154672a01a7e0906d7d4fb8f5305d" translate="yes" xml:space="preserve">
          <source>Type variables can be used in specifications to specify relations for the input and output arguments of a function. For example, the following specification defines the type of a polymorphic identity function:</source>
          <target state="translated">Переменные типа могут быть использованы в спецификациях для задания соотношений для входных и выходных аргументов функции.Например,следующая спецификация определяет тип полиморфной функции идентификации:</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="d9cf88052e09b9cf4919f33ab2053b176aa31518" translate="yes" xml:space="preserve">
          <source>Types corresponding to RFC 6733 AVP Data Formats. Defined in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типы, соответствующие форматам данных AVP RFC 6733. Определяется в &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19b63cf79ea9c163682784b133c791343ee64d2c" translate="yes" xml:space="preserve">
          <source>Types declared as &lt;code&gt;opaque&lt;/code&gt; represent sets of terms whose structure is not supposed to be visible from outside of their defining module. That is, only the module defining them is allowed to depend on their term structure. Consequently, such types do not make much sense as module local - module local types are not accessible by other modules anyway - and is always to be exported.</source>
          <target state="translated">Типы, объявленные как &lt;code&gt;opaque&lt;/code&gt; представляют собой наборы терминов, структура которых не должна быть видимой извне их определяющего модуля. То есть только определяющий их модуль может зависеть от их временной структуры. Следовательно, такие типы не имеют особого смысла, поскольку локальные модули модуля - локальные типы модулей в любом случае недоступны другим модулям - и всегда должны быть экспортированы.</target>
        </trans-unit>
        <trans-unit id="535782a993effddbcbcaf96e815b800bf2866b08" translate="yes" xml:space="preserve">
          <source>Types describe sets of Erlang terms. Types consist of, and are built from, a set of predefined types, for example, &lt;code&gt;integer()&lt;/code&gt;, &lt;code&gt;atom()&lt;/code&gt;, and &lt;code&gt;pid()&lt;/code&gt;. Predefined types represent a typically infinite set of Erlang terms that belong to this type. For example, the type &lt;code&gt;atom()&lt;/code&gt; denotes the set of all Erlang atoms.</source>
          <target state="translated">Типы описывают наборы терминов Erlang. Типы состоят из набора предопределенных типов, например &lt;code&gt;integer()&lt;/code&gt; , &lt;code&gt;atom()&lt;/code&gt; и &lt;code&gt;pid()&lt;/code&gt; , и построены из него . Предопределенные типы обычно представляют собой бесконечный набор терминов Erlang, принадлежащих этому типу. Например, тип &lt;code&gt;atom()&lt;/code&gt; обозначает набор всех атомов Эрланга.</target>
        </trans-unit>
        <trans-unit id="4826f9f1cd21548c629153b4f8bdd98bd55b49d6" translate="yes" xml:space="preserve">
          <source>Types that refer to themselves are called recursive types. Example:</source>
          <target state="translated">Типы,которые ссылаются на себя,называются рекурсивными.Пример:</target>
        </trans-unit>
        <trans-unit id="1c02047b4473ab1d57fc7225f4164216e6bcfaf2" translate="yes" xml:space="preserve">
          <source>Types:</source>
          <target state="translated">Types:</target>
        </trans-unit>
        <trans-unit id="2f711f90b7022e079d8d5f49cef08ad4c28d080c" translate="yes" xml:space="preserve">
          <source>Typical &lt;code&gt;Reasons&lt;/code&gt;s:</source>
          <target state="translated">Типичные &lt;code&gt;Reasons&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="translated">Типичными причинами ошибок являются:</target>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="translated">Типичные причины ошибок:</target>
        </trans-unit>
        <trans-unit id="a875996fe6fd67197a25c652eb601e185ed5cc23" translate="yes" xml:space="preserve">
          <source>Typical error reasons: as for &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; if a file had to be opened, and as for &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типичные причины ошибки: как для &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; , если файл нужно было открыть, так и для &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc74151b7056fe15fd99a84d554133408c7c5852" translate="yes" xml:space="preserve">
          <source>Typical usage when writing to a file descriptor looks like this:</source>
          <target state="translated">Типичное использование при записи в дескриптор файла выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">Типичное использование:</target>
        </trans-unit>
        <trans-unit id="fa0583dc7b5aaef5f34ea3fa51cd6e026a525fd0" translate="yes" xml:space="preserve">
          <source>Typically high &lt;code&gt;time&lt;/code&gt; values are bad and this is often the thing to look for. However, one should also look for high lock acquisition frequencies (#tries) since locks generate overhead and because high frequency could become problematic if they begin to have conflicts even if it is not shown in a particular test.</source>
          <target state="translated">Обычно высокие значения &lt;code&gt;time&lt;/code&gt; - это плохо, и часто это то, что нужно искать. Однако следует также обратить внимание на высокие частоты захвата блокировок (# попыток), поскольку блокировки создают накладные расходы и потому, что высокая частота может стать проблематичной, если они начнут конфликтовать, даже если это не показано в конкретном тесте.</target>
        </trans-unit>
        <trans-unit id="2c47ac130c9d90117072288c85fcf5d65c5fe895" translate="yes" xml:space="preserve">
          <source>Typically the operator, possibly running hundreds or thousands of test cases, does not want to fill the console with details about, or printouts from, specific test cases. By default, the operator only sees the following:</source>
          <target state="translated">Обычно оператор,возможно,выполняющий сотни или тысячи тестовых заданий,не хочет заполнять консоль деталями или распечатками с конкретных тестовых заданий.По умолчанию оператор видит только следующее:</target>
        </trans-unit>
        <trans-unit id="97e9960729125226aaee305f3d87924465b5abf5" translate="yes" xml:space="preserve">
          <source>Typically you want to substitute negations first, then aliases, then perform one or more expansions (sometimes you want to pre-expand particular entries before doing the main expansion). You might want to substitute negations and/or aliases repeatedly, to allow such forms in the right-hand side of aliases and expansion lists.</source>
          <target state="translated">Обычно вы хотите сначала заменить отрицания,затем псевдонимы,а затем выполнить одно или несколько расширений (иногда вы хотите предварительно расширить определенные записи перед выполнением основного расширения).Вы можете захотеть многократно подставлять отрицания и/или псевдонимы,чтобы разрешить такие формы в правой части псевдонимов и списков расширений.</target>
        </trans-unit>
        <trans-unit id="4535970fd788996603de7fcae8b5b1132c50cf1f" translate="yes" xml:space="preserve">
          <source>Typically, OpenSSL engines provide a hardware implementation of specific cryptographic operations. The hardware implementation usually offers improved performance over its software-based counterpart, which is known as cryptographic acceleration.</source>
          <target state="translated">Как правило,OpenSSL-движки обеспечивают аппаратную реализацию специфических криптографических операций.Аппаратная реализация обычно обеспечивает более высокую производительность по сравнению со своим программным аналогом,который известен как криптографическое ускорение.</target>
        </trans-unit>
        <trans-unit id="c81772f74c1a9d8da4ff099d810781ce160aacf0" translate="yes" xml:space="preserve">
          <source>Typographic conventions:</source>
          <target state="translated">Типографические конвенции:</target>
        </trans-unit>
        <trans-unit id="0d3d0996d3543e832deef4b0344dd80b1d22ba4d" translate="yes" xml:space="preserve">
          <source>UDP packets from the network</source>
          <target state="translated">UDP-пакеты от сети</target>
        </trans-unit>
        <trans-unit id="50aa3ec0f92e35711e8ffb982901d2c7f9850924" translate="yes" xml:space="preserve">
          <source>UDP queries are used unless resolver option &lt;code&gt;usevc&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which forces TCP queries. If the query is too large for UDP, TCP is used instead. For regular DNS queries, 512 bytes is the size limit.</source>
          <target state="translated">Запросы UDP используются, если параметр резолвера &lt;code&gt;usevc&lt;/code&gt; не имеет значения &lt;code&gt;true&lt;/code&gt; , что вызывает запросы TCP. Если запрос слишком велик для UDP, вместо него используется TCP. Для обычных DNS-запросов ограничение на размер составляет 512 байт.</target>
        </trans-unit>
        <trans-unit id="486c66a0286294375958525f91cdfdb3f82c9cb3" translate="yes" xml:space="preserve">
          <source>URI processing functions.</source>
          <target state="translated">Функции обработки URI.</target>
        </trans-unit>
        <trans-unit id="1d057bddb70164b040386e82de4c64661e29e8f2" translate="yes" xml:space="preserve">
          <source>URI to filename translation.</source>
          <target state="translated">URI для перевода имени файла.</target>
        </trans-unit>
        <trans-unit id="52c3521da24366089045fe93222bbbea327aa8ee" translate="yes" xml:space="preserve">
          <source>URI utility module</source>
          <target state="translated">утилитный модуль URI</target>
        </trans-unit>
        <trans-unit id="2497da8c1e8f3017cb461e9ead3580ed94a9004a" translate="yes" xml:space="preserve">
          <source>URL Aliasing</source>
          <target state="translated">Псевдонизирование URL-адреса</target>
        </trans-unit>
        <trans-unit id="f09d741a3ad78a10aeac235b7eda60b472c1c7ea" translate="yes" xml:space="preserve">
          <source>URL aliasing.</source>
          <target state="translated">Название URL-адреса.</target>
        </trans-unit>
        <trans-unit id="284501aa026d810fca5e30ec3e6fbb8b907a7d92" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2390079739ca194b6adba26faaa714759aa93368" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d52349cc271c6019348a86ea4c491c0478f8cdd3" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0133be96d80a337735afdf94d4b6d5617e90e15" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a52ac449904e56f2f8f4257d980b456503a1c2" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b683663e96daabab32de2bda24157392f5a1dc1c" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="276871ba1190025d3a896ad5f2648a68709c0037" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53f076fb21dd236ea02ee81db09d3c6d1a9c2d70" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c130e8186817488b08e47f250bc88b4918c57145" translate="yes" xml:space="preserve">
          <source>URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c0cd56da21e982f4424f294a92af6cffab886e5" translate="yes" xml:space="preserve">
          <source>UTF-8 is designed so that ISO Latin-1 characters with numbers beyond the 7-bit ASCII range are seldom considered valid when decoded as UTF-8. Therefore one can usually use heuristics to determine if a file is in UTF-8 or if it is encoded in ISO Latin-1 (one byte per character). The &lt;code&gt;unicode&lt;/code&gt; module can be used to determine if data can be interpreted as UTF-8:</source>
          <target state="translated">UTF-8 разработан таким образом, что символы ISO Latin-1 с числами за пределами 7-битного диапазона ASCII редко считаются допустимыми при декодировании как UTF-8. Поэтому обычно можно использовать эвристику, чтобы определить, находится ли файл в UTF-8 или в кодировке ISO Latin-1 (один байт на символ). Модуль &lt;code&gt;unicode&lt;/code&gt; может использоваться, чтобы определить, можно ли интерпретировать данные как UTF-8:</target>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="translated">Ugaritic</target>
        </trans-unit>
        <trans-unit id="7a2f970d37032e17cb13a44bc956fa4e60bba4ed" translate="yes" xml:space="preserve">
          <source>Unary +</source>
          <target state="translated">Унарный +</target>
        </trans-unit>
        <trans-unit id="898ecd6a265af9abef6adb306b4c0c9c0e00c767" translate="yes" xml:space="preserve">
          <source>Unary + - bnot not</source>
          <target state="translated">Унарный+-нет</target>
        </trans-unit>
        <trans-unit id="684c6ddd5eb8c278f83bc5399212042f5f7e16e9" translate="yes" xml:space="preserve">
          <source>Unary -</source>
          <target state="translated">Унарный -</target>
        </trans-unit>
        <trans-unit id="637d4f607a8fd2105b314306ae4c76ef4925ad36" translate="yes" xml:space="preserve">
          <source>Unary bitwise NOT</source>
          <target state="translated">Единобитный НЕ</target>
        </trans-unit>
        <trans-unit id="c9d35054fa41b42db47e25b9d91e662cc93e9f89" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;FormatFun&lt;/code&gt; is used by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; for displaying the call that created the query handle of the table. Defaults to &lt;code&gt;undefined&lt;/code&gt;, which means that &lt;code&gt;info/1,2&lt;/code&gt; displays a call to &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt;. It is up to &lt;code&gt;FormatFun&lt;/code&gt; to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation, it must be an Erlang expression that can be scanned and parsed (a trailing dot is added by &lt;code&gt;info/1,2&lt;/code&gt; though).</source>
          <target state="translated">&lt;code&gt;FormatFun&lt;/code&gt; функция обратного вызова FormatFun используется &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; для отображения вызова, создавшего дескриптор запроса таблицы. По умолчанию &lt;code&gt;undefined&lt;/code&gt; , что означает, что &lt;code&gt;info/1,2&lt;/code&gt; отображает вызов &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt; . Это до &lt;code&gt;FormatFun&lt;/code&gt; , чтобы представить выбранные объекты таблицы соответствующим образом. Однако, если для представления выбран список символов, это должно быть выражение Erlang, которое можно сканировать и анализировать ( хотя завершающая точка добавляется с помощью &lt;code&gt;info/1,2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8a8cf6ea70815c5c8dc6febb5bc34ace0255c96a" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;InfoFun&lt;/code&gt; is to return information about the table. &lt;code&gt;undefined&lt;/code&gt; is to be returned if the value of some tag is unknown:</source>
          <target state="translated">&lt;code&gt;InfoFun&lt;/code&gt; функция обратного вызова InfoFun предназначена для возврата информации о таблице. &lt;code&gt;undefined&lt;/code&gt; должно быть возвращено, если значение некоторого тега неизвестно:</target>
        </trans-unit>
        <trans-unit id="1442c4ded70572e00f428d9108e7ae55df7a65b5" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;PreFun&lt;/code&gt; is called once before the table is read for the first time. If the call fails, the query evaluation fails.</source>
          <target state="translated">&lt;code&gt;PreFun&lt;/code&gt; функция обратного вызова PreFun вызывается один раз перед первым чтением таблицы. Если вызов завершился неудачно, оценка запроса не удалась.</target>
        </trans-unit>
        <trans-unit id="5a92175579f60db68a9c361cc251147f8debf6b0" translate="yes" xml:space="preserve">
          <source>Unary logical NOT</source>
          <target state="translated">Унарная логика НЕ</target>
        </trans-unit>
        <trans-unit id="27bb4c7fe8d37999952aa5b0af1c3595bd259bdb" translate="yes" xml:space="preserve">
          <source>UnaryGraphOp ::= &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</source>
          <target state="translated">UnaryGraphOp :: = &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01c0a17c153449bd9a04099f8971f3292a601fb" translate="yes" xml:space="preserve">
          <source>UnarySetOp ::= &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="translated">UnarySetOp :: = &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="translated">Unassigned</target>
        </trans-unit>
        <trans-unit id="8707e2ffeef5fa8b41de5e679969a877cb9db6f0" translate="yes" xml:space="preserve">
          <source>Unblocks a log. A log can only be unblocked by the blocking process.</source>
          <target state="translated">Разблокирует журнал.Разблокировать журнал можно только в процессе блокировки.</target>
        </trans-unit>
        <trans-unit id="fe39591d424d43f7cc9d6d4ca1303c1c24c48eab" translate="yes" xml:space="preserve">
          <source>Unbound and unsafe variables</source>
          <target state="translated">Несвязанные и небезопасные переменные</target>
        </trans-unit>
        <trans-unit id="b13fe86cfdf1fdbc7031b4349a4b6f2fc354ab38" translate="yes" xml:space="preserve">
          <source>Uncompressed Size</source>
          <target state="translated">Размер без сжатия</target>
        </trans-unit>
        <trans-unit id="0a4c7b6c3e87ff86f41e836e792f67b6c2bdf902" translate="yes" xml:space="preserve">
          <source>Uncompressed size (unsigned 32-bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded:</source>
          <target state="translated">Несжатый размер (беззнаковое 32-битное целое число в порядке байт big-endian)-это размер данных до их сжатия.При расширении сжатые данные имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="848b92d8de0252bd79df355552090abc0668ced9" translate="yes" xml:space="preserve">
          <source>Uncompresses data with gz headers and checksum.</source>
          <target state="translated">Распакуйте данные с помощью заголовков и контрольной суммы gz.</target>
        </trans-unit>
        <trans-unit id="79897564d08477a4d49effa829f40061f9569280" translate="yes" xml:space="preserve">
          <source>Uncompresses data with zlib headers and checksum.</source>
          <target state="translated">Распаковка данных с помощью заголовков zlib и контрольной суммы.</target>
        </trans-unit>
        <trans-unit id="6ad0694c3152ef1643cde8ba2d996a0323a6b4d2" translate="yes" xml:space="preserve">
          <source>Uncompresses data without zlib headers and checksum.</source>
          <target state="translated">Распаковка данных без заголовков zlib и контрольной суммы.</target>
        </trans-unit>
        <trans-unit id="a1c0570481ff7f3e6ed039d51cc86442ea076a33" translate="yes" xml:space="preserve">
          <source>Undefined thread that is not a scheduler thread.</source>
          <target state="translated">Неопределенный поток,который не является потоком планировщика.</target>
        </trans-unit>
        <trans-unit id="f7aa71224a65884ef564916a9d0da2f89835d7d4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;$ROOT/releases&lt;/code&gt;, a new directory &lt;code&gt;B&lt;/code&gt; is created, containing &lt;code&gt;ch_rel-2.rel&lt;/code&gt;, &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;$ROOT/releases&lt;/code&gt; &lt;code&gt;ch_rel-2.rel&lt;/code&gt; создается новый каталог &lt;code&gt;B&lt;/code&gt; , содержащий ch_rel-2.rel , &lt;code&gt;start.boot&lt;/code&gt; , &lt;code&gt;sys.config&lt;/code&gt; и &lt;code&gt;relup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9db2e4f4f838b5c44fe9cf387c90abe7108283e8" translate="yes" xml:space="preserve">
          <source>Under Windows, batch file &lt;code&gt;etop.bat&lt;/code&gt; can be used.</source>
          <target state="translated">Под Windows можно использовать командный файл &lt;code&gt;etop.bat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3264cd9d9eb75df44ac7458f032202c1c187eb3e" translate="yes" xml:space="preserve">
          <source>Under Windows, the batch file &lt;code&gt;cdv.bat&lt;/code&gt; can be used.</source>
          <target state="translated">Под Windows можно использовать командный файл &lt;code&gt;cdv.bat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5c9e5a121880663dee4769e1af65faa7b494736" translate="yes" xml:space="preserve">
          <source>Under a key, any number of named values can be stored. They have names, types, and data.</source>
          <target state="translated">Под ключом может быть сохранено любое количество именованных значений.У них есть имена,типы и данные.</target>
        </trans-unit>
        <trans-unit id="dd8f3b0e81b0f054de52ff314e53658c55941c1a" translate="yes" xml:space="preserve">
          <source>Under certain circumstances incompatible changes might be introduced even in parts of the system that should be compatible between releases. Things that might trigger incompatible changes like this are:</source>
          <target state="translated">При определенных обстоятельствах могут вноситься несовместимые изменения даже в те части системы,которые должны быть совместимы между выпусками.Вещи,которые могут вызывать несовместимые изменения,например,такие,как это:</target>
        </trans-unit>
        <trans-unit id="572aa08aba747d5d8b7a4a50d789147e2afaec76" translate="yes" xml:space="preserve">
          <source>Under the &lt;strong&gt;Warnings&lt;/strong&gt; pull-down menu, there are buttons that control which discrepancies are reported to the user in the &lt;strong&gt;Warnings&lt;/strong&gt; window. By clicking these buttons, you can enable/disable a whole class of warnings. Information about the classes of warnings is found on the &quot;Warnings&quot; item under the &lt;strong&gt;Help&lt;/strong&gt; menu (in the rightmost top corner).</source>
          <target state="translated">В раскрывающемся меню &amp;laquo; &lt;strong&gt;Предупреждения&amp;raquo;&lt;/strong&gt; есть кнопки, которые определяют, о каких расхождениях сообщать пользователю в окне &amp;laquo; &lt;strong&gt;Предупреждения&amp;raquo;&lt;/strong&gt; . Нажимая эти кнопки, вы можете включить / отключить целый класс предупреждений. Информация о классах предупреждений находится в пункте &amp;laquo;Предупреждения&amp;raquo; в меню &amp;laquo; &lt;strong&gt;Справка&amp;raquo;&lt;/strong&gt; (в правом верхнем углу).</target>
        </trans-unit>
        <trans-unit id="ae6ad23ca12e3d31111c9342b18cb40e19aa690d" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocated_areas&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt;.</source>
          <target state="translated">Под тегом tag &lt;strong&gt;= allocated_areas&lt;/strong&gt; отображается информация, аналогичная той, которую можно получить на живом узле с помощью &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4c5641fd04e324ff84f71ed58f45687d78170d8" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocator:&amp;lt;A&amp;gt;&lt;/strong&gt; is shown various information about allocator &amp;lt;A&amp;gt;. The information is similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt;. For more information, see also &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Под тегом &lt;strong&gt;= allocator: &amp;lt;A&amp;gt;&lt;/strong&gt; отображается различная информация о распределителе &amp;lt;A&amp;gt;. Информация аналогична той, которую можно получить на живом узле с помощью &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt; . Для получения дополнительной информации см. Также &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d37cd225e87fcc610bec30b5a05911619436d89" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=memory&lt;/strong&gt; is shown information similar to what can be obtainted on a living node with &lt;code&gt;erlang:memory()&lt;/code&gt;.</source>
          <target state="translated">Под тегом tag &lt;strong&gt;= memory&lt;/strong&gt; отображается информация, аналогичная той, которую можно получить на живом узле с помощью &lt;code&gt;erlang:memory()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63ce4685b2bc584945411c035f09d36043b054a2" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=scheduler&lt;/strong&gt; is shown information about the current state and statistics of the schedulers in the runtime system. On operating systems that allow suspension of other threads, the data within this section reflects what the runtime system looks like when a crash occurs.</source>
          <target state="translated">Под тегом &lt;strong&gt;= scheduler&lt;/strong&gt; отображается информация о текущем состоянии и статистика планировщиков в системе времени выполнения. В операционных системах, допускающих приостановку других потоков, данные в этом разделе отражают то, как выглядит система времени выполнения в случае сбоя.</target>
        </trans-unit>
        <trans-unit id="c4dc6bd20baf250db6e40693e866b1962ff4e8bc" translate="yes" xml:space="preserve">
          <source>Under the tags &lt;strong&gt;=hash_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; and &lt;strong&gt;=index_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; is shown internal tables. These are mostly of interest for runtime system developers.</source>
          <target state="translated">Под тегами &lt;strong&gt;= hash_table: &amp;lt;table_name&amp;gt;&lt;/strong&gt; и &lt;strong&gt;= index_table: &amp;lt;table_name&amp;gt;&lt;/strong&gt; показаны внутренние таблицы. Они в основном представляют интерес для разработчиков систем времени выполнения.</target>
        </trans-unit>
        <trans-unit id="2cc501eac2fcb3163225e3af20fdf997e537c7a6" translate="yes" xml:space="preserve">
          <source>Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before.</source>
          <target state="translated">Недокументированные (старые)алгоритмы устарели,но все же реализованы так,что старый код,полагаясь на них,будет производить те же псевдослучайные последовательности,что и раньше.</target>
        </trans-unit>
        <trans-unit id="87e34279dd28e6f111c12cefa204d1bbe4761338" translate="yes" xml:space="preserve">
          <source>Undocumented functions in this module are not to be used.</source>
          <target state="translated">Недокументированные функции в этом модуле не должны использоваться.</target>
        </trans-unit>
        <trans-unit id="196d8f0f66ad490a457b6fb5d6806ec3993a5c10" translate="yes" xml:space="preserve">
          <source>Unfolds all occurrences of atoms in &lt;code&gt;ListIn&lt;/code&gt; to tuples &lt;code&gt;{Atom, true}&lt;/code&gt;.</source>
          <target state="translated">Разворачивает все вхождения атомов в &lt;code&gt;ListIn&lt;/code&gt; в кортежи &lt;code&gt;{Atom, true}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ab34ddc2bf3b987c39e2558abfd1de510704f88" translate="yes" xml:space="preserve">
          <source>Unicode binary encoded as UTF16 little endian.</source>
          <target state="translated">Двоичный Unicode кодируется как UTF16 little endian.</target>
        </trans-unit>
        <trans-unit id="9476616408be8ddee79977abc7989cebfe910910" translate="yes" xml:space="preserve">
          <source>Unicode filename translation is turned on with switch &lt;code&gt;+fnu&lt;/code&gt;. On Linux, a VM started without explicitly stating the filename translation mode defaults to &lt;code&gt;latin1&lt;/code&gt; as the native filename encoding. On Windows and MacOS X, the default behavior is that of Unicode filename translation. Therefore &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; by default returns &lt;code&gt;utf8&lt;/code&gt; on those systems (Windows does not use UTF-8 on the file system level, but this can safely be ignored by the Erlang programmer). The default behavior can, as stated earlier, be changed using option &lt;code&gt;+fnu&lt;/code&gt; or &lt;code&gt;+fnl&lt;/code&gt; to the VM, see the &lt;code&gt;erl&lt;/code&gt; program. If the VM is started in Unicode filename translation mode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns atom &lt;code&gt;utf8&lt;/code&gt;. Switch &lt;code&gt;+fnu&lt;/code&gt; can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported.</source>
          <target state="translated">Перевод файлов в Юникоде включается переключателем &lt;code&gt;+fnu&lt;/code&gt; . В Linux виртуальная машина запускалась без явного указания режима трансляции имени файла по умолчанию &lt;code&gt;latin1&lt;/code&gt; в качестве собственной кодировки имени файла. В Windows и MacOS X поведение по умолчанию - это перевод имени файла в Юникоде. Поэтому &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; по умолчанию возвращает &lt;code&gt;utf8&lt;/code&gt; в этих системах (Windows не использует UTF-8 на уровне файловой системы, но программист на Erlang может спокойно это игнорировать). Поведение по умолчанию, как было сказано ранее, можно изменить с помощью опции &lt;code&gt;+fnu&lt;/code&gt; или &lt;code&gt;+fnl&lt;/code&gt; для виртуальной машины, см. Программу &lt;code&gt;erl&lt;/code&gt; . Если виртуальная машина запущена в режиме преобразования имени файла Unicode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; возвращает атом &lt;code&gt;utf8&lt;/code&gt; . За переключателем &lt;code&gt;+fnu&lt;/code&gt; могут следовать &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; или &lt;code&gt;e&lt;/code&gt; , чтобы указать, как следует сообщать о неправильно закодированных именах файлов.</target>
        </trans-unit>
        <trans-unit id="988784de449d7b8cbc0704eff09bcd0c69371d5a" translate="yes" xml:space="preserve">
          <source>Unicode is a standard defining code points (numbers) for all known, living or dead, scripts. In principle, every symbol used in any language has a Unicode code point. Unicode code points are defined and published by the Unicode Consortium, which is a non-profit organization.</source>
          <target state="translated">Юникод-это стандартный определяющий код точек (чисел)для всех известных,живых или мертвых скриптов.В принципе,каждый символ,используемый в любом языке,имеет точку кода Юникода.Точки кода Юникод определяются и публикуются Консорциумом Юникод,который является некоммерческой организацией.</target>
        </trans-unit>
        <trans-unit id="753a9fc18dc38abc9e40310e1511762a587d6d68" translate="yes" xml:space="preserve">
          <source>Unicode metadata stored in PAX headers is preserved</source>
          <target state="translated">Сохраняются метаданные Юникода,хранящиеся в заголовках PAX.</target>
        </trans-unit>
        <trans-unit id="717d423333854e072ef433389e96fff5bd03e76d" translate="yes" xml:space="preserve">
          <source>Unicode support is basically UTF-8 based. To use Unicode characters, you either call &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; with option &lt;code&gt;unicode&lt;/code&gt;, or the pattern must start with one of these special sequences:</source>
          <target state="translated">Поддержка Unicode в основном основана на UTF-8. Чтобы использовать символы Unicode, вы либо вызываете &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; с опцией &lt;code&gt;unicode&lt;/code&gt; , либо шаблон должен начинаться с одной из этих специальных последовательностей:</target>
        </trans-unit>
        <trans-unit id="9619f5cd0ede72c7dc62df2d3b5ff34d2c75b610" translate="yes" xml:space="preserve">
          <source>Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced.</source>
          <target state="translated">Равномерные поплавки имели неоднородную плотность,поэтому малые значения,т.е.менее 0.5,уменьшались с уменьшением интервалов по мере приближения полученного значения к 0.0,хотя все еще равномерно распределены для достаточно больших поддиапазонов.Новые алгоритмы производят равномерно распределенные плавающие с плавающей точкой на форме N*2.0^(-53),следовательно,равномерно распределенные интервалы.</target>
        </trans-unit>
        <trans-unit id="4488ef1f56a2d01fb6e741f79e8378c71279a1d3" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator's precision the probability to produce a low number could be twice the probability for a high.</source>
          <target state="translated">Унифицированные целочисленные диапазоны имели перекос в распределении вероятностей,который не был заметен для малых диапазонов,но для больших диапазонов с точностью ниже точности генератора вероятность произвести низкое число может быть в два раза выше вероятности для высокого.</target>
        </trans-unit>
        <trans-unit id="adabbdf2f0cec9c6d0d246d5a204f96b7e74b355" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges larger than or equal to the generator's precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce.</source>
          <target state="translated">В единообразных целочисленных диапазонах,превышающих или равных точности генератора,использовался метод отката с плавающей точкой,который вычислялся только с 52 битами,что меньше запрашиваемого диапазона,и поэтому не все числа в запрашиваемом диапазоне можно было даже получить.</target>
        </trans-unit>
        <trans-unit id="36e839dc7592fa37041cd55253f794215f4f6c06" translate="yes" xml:space="preserve">
          <source>Union of &lt;code&gt;rsa_digest_type()&lt;/code&gt;, &lt;code&gt;dss_digest_type()&lt;/code&gt;, and &lt;code&gt;ecdsa_digest_type()&lt;/code&gt;.</source>
          <target state="translated">Объединение &lt;code&gt;rsa_digest_type()&lt;/code&gt; , &lt;code&gt;dss_digest_type()&lt;/code&gt; и &lt;code&gt;ecdsa_digest_type()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a878275b775589505d998070ad22ad6d0081609" translate="yes" xml:space="preserve">
          <source>Unique Integers on a Runtime System Instance</source>
          <target state="translated">Уникальные Интеграторы на Экземпляре системы исполнения</target>
        </trans-unit>
        <trans-unit id="a2cc5144e25dba2fec68e539fbd788a730b7301a" translate="yes" xml:space="preserve">
          <source>Unique References on a Runtime System Instance</source>
          <target state="translated">Уникальные ссылки на экземпляр системы исполнения</target>
        </trans-unit>
        <trans-unit id="a306f316fd3f985303c362b8053185a26f2e0d45" translate="yes" xml:space="preserve">
          <source>Unique identifier for the application in the scope of the service. Defaults to the value of the &lt;code&gt;dictionary&lt;/code&gt; option.</source>
          <target state="translated">Уникальный идентификатор приложения в рамках услуги. По умолчанию используется значение параметра &lt;code&gt;dictionary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5724b00a081ae3e8a4cc6f50314a3e776bc6f0d2" translate="yes" xml:space="preserve">
          <source>Unit Testing is testing of individual program &quot;units&quot; in relative isolation. There is no particular size requirement: a unit can be a function, a module, a process, or even a whole application, but the most typical testing units are individual functions or modules. In order to test a unit, you specify a set of individual tests, set up the smallest necessary environment for being able to run those tests (often, you don't need to do any setup at all), you run the tests and collect the results, and finally you do any necessary cleanup so that the test can be run again later. A Unit Testing Framework tries to help you in each stage of this process, so that it is easy to write tests, easy to run them, and easy to see which tests failed (so you can fix the bugs).</source>
          <target state="translated">Блок-тестирование-это тестирование отдельных программных &quot;единиц&quot; в относительной изоляции.Никаких особых требований к размеру не предъявляется:единица может быть функцией,модулем,процессом или даже целым приложением,но наиболее типичными тестируемыми единицами являются отдельные функции или модули.Для того чтобы протестировать модуль,вы указываете набор отдельных тестов,настраиваете самую маленькую среду,необходимую для запуска этих тестов (часто вообще не требуется никаких настроек),запускаете тесты и собираете результаты,и,наконец,делаете всю необходимую очистку,чтобы тест можно было запустить еще раз позже.Структура модульного тестирования пытается помочь Вам на каждом этапе этого процесса,чтобы было легко писать тесты,легко их запускать и легко видеть,какие тесты провалились (так что Вы можете исправить ошибки).</target>
        </trans-unit>
        <trans-unit id="9caddb3cd5b7265345df4fab350e48f214540b46" translate="yes" xml:space="preserve">
          <source>Universal Time. UT1 is based on the rotation of the earth and conceptually means solar time at 0&amp;deg; longitude.</source>
          <target state="translated">Мировое время. UT1 основан на вращении Земли и концептуально означает солнечное время на нулевой долготе.</target>
        </trans-unit>
        <trans-unit id="67fdab77a1c02655cb90e9076adda573749aee76" translate="yes" xml:space="preserve">
          <source>Universaltime</source>
          <target state="translated">Universaltime</target>
        </trans-unit>
        <trans-unit id="f0fd69818de3f9565ba68951c5c09c08312d1123" translate="yes" xml:space="preserve">
          <source>Unix 'tar' utility for reading and writing tar archives.</source>
          <target state="translated">Утилита Unix 'tar' для чтения и записи архивов tar.</target>
        </trans-unit>
        <trans-unit id="c497be34c3d12775e6c6e249a2bb96e5096e4688" translate="yes" xml:space="preserve">
          <source>Unix example: &lt;code&gt;/usr/local/bin&lt;/code&gt;</source>
          <target state="translated">Пример Unix: &lt;code&gt;/usr/local/bin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52db1f36f26e76a3a2c634008d80678e33f56bbd" translate="yes" xml:space="preserve">
          <source>Unknown Functions.</source>
          <target state="translated">Неизвестные функции.</target>
        </trans-unit>
        <trans-unit id="b20270332ab7fc1d7887105b864abda119f91200" translate="yes" xml:space="preserve">
          <source>Unknown Modules.</source>
          <target state="translated">Неизвестные модули.</target>
        </trans-unit>
        <trans-unit id="42c65364e9fb4489250a3ae7948a13788521c35e" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns a list containing object &lt;code&gt;I&lt;/code&gt; in Erlang term order.</source>
          <target state="translated">Если таблица типа &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; или &lt;code&gt;duplicate_bag&lt;/code&gt; не защищена с помощью &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; , обход может завершиться неудачно, если в таблицу производятся одновременные обновления. Для типа таблицы &lt;code&gt;ordered_set&lt;/code&gt; функция возвращает список, содержащий объект &lt;code&gt;I&lt;/code&gt; в порядке терминов Erlang.</target>
        </trans-unit>
        <trans-unit id="efdfb6336f1dc28fe44fc86849dcd9997db099f2" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns the next key in order, even if the object does no longer exist.</source>
          <target state="translated">Если таблица типа &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; или &lt;code&gt;duplicate_bag&lt;/code&gt; не защищена с помощью &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; , обход может завершиться неудачно, если в таблицу производятся одновременные обновления. Для типа таблицы &lt;code&gt;ordered_set&lt;/code&gt; функция возвращает следующий ключ по порядку, даже если объект больше не существует.</target>
        </trans-unit>
        <trans-unit id="743984ff40a29e25f3a91777282531a480bea68e" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified by the options, all modules are assumed to be at least &quot;static&quot;, and all except the target module are assumed to be &quot;safe&quot;. See the &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;safe&lt;/code&gt; options for details.</source>
          <target state="translated">Если в параметрах не указано иное, все модули считаются как минимум &amp;laquo;статическими&amp;raquo;, и все, кроме целевого модуля, считаются &amp;laquo;безопасными&amp;raquo;. Подробнее см. &lt;code&gt;static&lt;/code&gt; и &lt;code&gt;safe&lt;/code&gt; параметры.</target>
        </trans-unit>
        <trans-unit id="6fd12a82bf92d67e237725f9648f0226fb3bb44f" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type and encoding are the same as the input type and encoding. That is, binary input returns binary output, list input returns a list output but mixed input returns list output.</source>
          <target state="translated">Если не указано иное,тип возвращаемого значения и кодировка совпадают с типом и кодировкой входа.То есть,двоичный вход возвращает двоичный выход,листовой вход возвращает листовой выход,но смешанный вход возвращает листовой выход.</target>
        </trans-unit>
        <trans-unit id="2452df07cb8ca79cfe0600811352c2e7e3686be8" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type is the same as the input type. That is, binary input returns binary output, list input returns a list output, and mixed input can return a mixed output.</source>
          <target state="translated">Если не указано иное,тип возвращаемого значения совпадает с типом входного сигнала.То есть,двоичный вход возвращает двоичный выход,листовой вход возвращает листовой выход,а смешанный вход может возвращать смешанный выход.</target>
        </trans-unit>
        <trans-unit id="f3df395f5cdf2fa36eee4743206fa60a6a1a66c2" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide.</source>
          <target state="translated">Если не указано иное,ведущий пробел игнорируется для всех управляющих последовательностей.Поле ввода не может быть более одной строки шириной.</target>
        </trans-unit>
        <trans-unit id="4a1cc2b0ee63b4df93cb4cef8c16bee9110c56a5" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, the order of the registered filters will be the order in which they are registered.</source>
          <target state="translated">Если не указано иное,то порядок зарегистрированных фильтров будет соответствовать порядку,в котором они зарегистрированы.</target>
        </trans-unit>
        <trans-unit id="336e16f5b15c1bb3924a2d4ee1f281da2f5d2f39" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1.</source>
          <target state="translated">Если не указано иное,все функции предполагают,что нумерация позиций начинается с позиции 1,то есть первый элемент списка находится в позиции 1.</target>
        </trans-unit>
        <trans-unit id="a5744f08804fbcbd546e4dfc2b0e6fcafee559f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_server&lt;/code&gt; process does not exist or if bad arguments are specified.</source>
          <target state="translated">Если не указано иное, все функции в этом модуле завершаются ошибкой, если указанный процесс &lt;code&gt;gen_server&lt;/code&gt; не существует или если указаны неверные аргументы.</target>
        </trans-unit>
        <trans-unit id="33f0b9bf676eb2bfd97e1ca14eb9192d3876198f" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_statem&lt;/code&gt; does not exist or if bad arguments are specified.</source>
          <target state="translated">Если не указано иное, все функции в этом модуле &lt;code&gt;gen_statem&lt;/code&gt; ошибкой, если указанное gen_statem не существует или если указаны неверные аргументы.</target>
        </trans-unit>
        <trans-unit id="2130ed65fd03b5efa6f9266bb204f3dc0f269a98" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified.</source>
          <target state="translated">Если не указано иное,все функции в этом модуле не будут работать,если указанного менеджера событий не существует или если указаны плохие аргументы.</target>
        </trans-unit>
        <trans-unit id="94ecf2431ac506145df210d3f762df7ef9ac568e" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor bridge does not exist or if bad arguments are specified.</source>
          <target state="translated">Если не указано иначе,все функции в этом модуле не будут работать,если указанный мост супервизора не существует или если указаны плохие аргументы.</target>
        </trans-unit>
        <trans-unit id="ce6e960d5712a50515c10d0e5588263e19e9ce6b" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified.</source>
          <target state="translated">Если не указано иначе,все функции в этом модуле не будут работать,если указанного супервизора не существует или если указаны плохие аргументы.</target>
        </trans-unit>
        <trans-unit id="5c7ee08644b98d18eca27766dd86d186eaca4f73" translate="yes" xml:space="preserve">
          <source>Unless specified by the user when the array is created, the default value is the atom &lt;code&gt;undefined&lt;/code&gt;. There is no difference between an unset entry and an entry that has been explicitly set to the same value as the default one (compare &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt;). If you need to differentiate between unset and set entries, ensure that the default value cannot be confused with the values of set entries.</source>
          <target state="translated">Если не указано пользователем при создании массива, значением по умолчанию является атом &lt;code&gt;undefined&lt;/code&gt; . Нет никакой разницы между неустановленной записью и записью, для которой явно задано то же значение, что и значение по умолчанию (сравните &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt; ). Если вам нужно различать неустановленные и установленные записи, убедитесь, что значение по умолчанию нельзя спутать со значениями установленных записей.</target>
        </trans-unit>
        <trans-unit id="dd13caf6027b189cef2a36a20e0fd13e56485aad" translate="yes" xml:space="preserve">
          <source>Unless the file name is absolute, the file is first searched for relative to the current directory, and then using the normal search path (&lt;code&gt;code:get_path()&lt;/code&gt;). This means that the names of typical &quot;app&quot; files can be used directly, without a path, e.g., &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt;.</source>
          <target state="translated">Если имя файла не является абсолютным, файл сначала ищется относительно текущего каталога, а затем используется обычный путь поиска ( &lt;code&gt;code:get_path()&lt;/code&gt; ). Это означает, что имена типичных файлов &amp;laquo;приложений&amp;raquo; можно использовать напрямую, без пути, например, &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a837b10265d2be2c9f800bf253594222b1cdf6" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, calls to &lt;code&gt;bchunk/2&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">Если таблица не защищена с помощью &lt;code&gt;safe_fixtable/2&lt;/code&gt; , вызовы &lt;code&gt;bchunk/2&lt;/code&gt; , возможно, не работают должным образом, если в таблицу выполняются одновременные обновления.</target>
        </trans-unit>
        <trans-unit id="ec243991d25d3f676894294544e13f5bc4cfeae2" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, subsequent calls to &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">Если таблица не защищена с помощью &lt;code&gt;safe_fixtable/2&lt;/code&gt; , последующие вызовы &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; , возможно, не будут работать должным образом, если в таблицу выполняются одновременные обновления.</target>
        </trans-unit>
        <trans-unit id="f2c55317241e5b2c59b25e3b0df5f88453b5f333" translate="yes" xml:space="preserve">
          <source>Unless the value is &lt;code&gt;none&lt;/code&gt;, the given function is called for each node whose list of annotations is not empty; see below for details. The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">Если значение не равно &lt;code&gt;none&lt;/code&gt; , данная функция вызывается для каждого узла, список аннотаций которого не пуст; подробности см. ниже. Значение по умолчанию - &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdff867eb339963be03bd21021856778c904302c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt;, Ifname is encoded a binary. In the unlikely case that a system is using non-7-bit-ASCII characters in network device names, special care has to be taken when encoding this argument.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt; , Ifname кодируется двоичным кодом. В том маловероятном случае, когда система использует не-7-битные символы ASCII в именах сетевых устройств, следует соблюдать особую осторожность при кодировании этого аргумента.</target>
        </trans-unit>
        <trans-unit id="ae5c0bd0a60e997d1705e91f30f45cde14782afc" translate="yes" xml:space="preserve">
          <source>Unlike data tables, information in schema tables can only be accessed and modified by using the schema-related functions described in this section.</source>
          <target state="translated">В отличие от таблиц данных,доступ к информации в таблицах схем и ее модификация возможны только с помощью функций,связанных со схемами,описанных в данном разделе.</target>
        </trans-unit>
        <trans-unit id="315fbdc2014934db1db457f44c68e1cf848dbeb6" translate="yes" xml:space="preserve">
          <source>Unlike in &quot;plain Erlang&quot;, &lt;code&gt;proc_lib&lt;/code&gt; processes will not generate &lt;strong&gt;error reports&lt;/strong&gt;, which are written to the terminal by the emulator. All exceptions are converted to &lt;strong&gt;exits&lt;/strong&gt; which are ignored by the default &lt;code&gt;logger&lt;/code&gt; handler.</source>
          <target state="translated">В отличие от &amp;laquo;простого Erlang&amp;raquo;, процессы &lt;code&gt;proc_lib&lt;/code&gt; не будут генерировать &lt;strong&gt;отчеты об ошибках&lt;/strong&gt; , которые записываются в терминал эмулятором. Все исключения преобразуются в &lt;strong&gt;выходы,&lt;/strong&gt; которые игнорируются обработчиком &lt;code&gt;logger&lt;/code&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="4f0b46a073145149fc17e2f042255d68220cd4a4" translate="yes" xml:space="preserve">
          <source>Unload &lt;code&gt;Mibs&lt;/code&gt; from an agent. If it cannot unload all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where unloading was aborted.</source>
          <target state="translated">Выгрузить &lt;code&gt;Mibs&lt;/code&gt; из агента. Если он не может выгрузить все MIB (значение по умолчанию для аргумента &lt;code&gt;Force&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; ), он укажет, где выгрузка была прервана.</target>
        </trans-unit>
        <trans-unit id="01b2dca21a4f55d7d0fa16561ba72c0a5a938d9c" translate="yes" xml:space="preserve">
          <source>Unload a &lt;code&gt;Mib&lt;/code&gt; from the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">Выгрузите &lt;code&gt;Mib&lt;/code&gt; из менеджера. &lt;code&gt;MibName&lt;/code&gt; это имя Mib, включая путь туда , где находится скомпилированный МИБ. Например,</target>
        </trans-unit>
        <trans-unit id="318d9f4d5f03a67d10200c73fcad432663d2f29b" translate="yes" xml:space="preserve">
          <source>Unload a single &lt;code&gt;Mib&lt;/code&gt; from an agent.</source>
          <target state="translated">Выгрузите один &lt;code&gt;Mib&lt;/code&gt; из агента.</target>
        </trans-unit>
        <trans-unit id="769b903ce1d90a72efda3ccafb33dcd1f3d777a4" translate="yes" xml:space="preserve">
          <source>Unload the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument from the mib-server.</source>
          <target state="translated">Выгрузите mib, указанный аргументом &lt;code&gt;Filename&lt;/code&gt; , с mib-сервера.</target>
        </trans-unit>
        <trans-unit id="ddd4c00f912e6ef2189a832da23d9650d2872c8c" translate="yes" xml:space="preserve">
          <source>Unloading can be described as the process of telling the emulator that this particular part of the code in this particular process (that is, this &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;) no longer needs the driver. That can, if there are no other users, trigger unloading of the driver, in which case the driver name disappears from the system and (if possible) the memory occupied by the driver executable code is reclaimed.</source>
          <target state="translated">Выгрузку можно описать как процесс сообщения эмулятору, что эта конкретная часть кода в этом конкретном процессе (то есть этому &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ) больше не нуждается в драйвере. Это может, если нет других пользователей, вызвать выгрузку драйвера, и в этом случае имя драйвера исчезнет из системы и (если возможно) будет освобождена память, занятая исполняемым кодом драйвера.</target>
        </trans-unit>
        <trans-unit id="7779518675ffce53110af3008d7744e065e1a5f3" translate="yes" xml:space="preserve">
          <source>Unloads the MIBs from agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">Выгружает MIB из агента &lt;code&gt;snmp_master_agent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a3d6a062d2d5ee9eda88a5ecd1085fce084994" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-MIB.</source>
          <target state="translated">Разгружает OTP-MIB.</target>
        </trans-unit>
        <trans-unit id="c48f8e606621c6fa11b525d4c336815899ff648e" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-OS-MON-MIB.</source>
          <target state="translated">Разгружает OTP-OS-MON-MIB.</target>
        </trans-unit>
        <trans-unit id="38ed8242b3b1b71902fb9d376310f5c95786abfe" translate="yes" xml:space="preserve">
          <source>Unloads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt;. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">Выгружает движок OpenSSL, заданный &lt;code&gt;EngineId&lt;/code&gt; . Если двигатель не может быть выгружен, возвращается кортеж ошибок.</target>
        </trans-unit>
        <trans-unit id="5cff9e0ced01393a829b38eaa7e0451df21ea9d5" translate="yes" xml:space="preserve">
          <source>Unloads the application specification for &lt;code&gt;Application&lt;/code&gt; from the application controller. It also unloads the application specifications for any included applications. Notice that the function does not purge the Erlang object code.</source>
          <target state="translated">Выгружает спецификацию приложения для &lt;code&gt;Application&lt;/code&gt; из контроллера приложения. Он также выгружает спецификации приложений для всех включенных приложений. Обратите внимание, что функция не очищает объектный код Erlang.</target>
        </trans-unit>
        <trans-unit id="351a6f889a5ded537e77bca6799737838e6f4f76" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, all remaining open ports using the driver are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; and the driver eventually gets unloaded.</source>
          <target state="translated">Выгружает или, по крайней мере, разыменовывает драйвер с именем &lt;code&gt;Name&lt;/code&gt; . Если вызывающий является последним &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; драйвера, все оставшиеся открытые порты, использующие драйвер, уничтожаются по причине &lt;code&gt;driver_unloaded&lt;/code&gt; , и драйвер в конечном итоге выгружается.</target>
        </trans-unit>
        <trans-unit id="2061febf2aa265ba0d12f05d42293814e13d57b8" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and no more open ports use the driver, the driver gets unloaded. Otherwise, unloading is delayed until all ports are closed and no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; remain.</source>
          <target state="translated">Выгружает или, по крайней мере, разыменовывает драйвер с именем &lt;code&gt;Name&lt;/code&gt; . Если вызывающий абонент является последним &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; драйвера, и более открытые порты не используют драйвер, драйвер выгружается. В противном случае выгрузка откладывается до тех пор, пока не закроются все порты и не останется &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38ad66e7caef87bb85f8df32ab5caabf7bf35995" translate="yes" xml:space="preserve">
          <source>Unlocks a mutex. The mutex currently must be locked by the calling thread.</source>
          <target state="translated">Отпирает мьютекс.В настоящее время мьютекс должен быть заблокирован вызывающей нитью.</target>
        </trans-unit>
        <trans-unit id="3b9b1fba9416c1278f7484dce6e469b9ce20199f" translate="yes" xml:space="preserve">
          <source>Unlocks the configuration target.</source>
          <target state="translated">Разблокирует цель конфигурации.</target>
        </trans-unit>
        <trans-unit id="19786a83cc46632e0d13d564e393de3e1de085fe" translate="yes" xml:space="preserve">
          <source>Unlocks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">Разблокирует блокировку данных порта, переданную как аргумент ( &lt;code&gt;pdl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9e529736ebba8b22ec528fcbede64fa669b39cc8" translate="yes" xml:space="preserve">
          <source>Unordered sending is configurable in &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt;. There is no special handling of DPR/DPA: since a user that cares about pending answers should wait for them before initiating DPR.</source>
          <target state="translated">Неупорядоченная отправка настраивается в &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt; . Особой обработки DPR / DPA не существует: поскольку пользователь, который заботится об ожидающих ответах, должен дождаться их, прежде чем инициировать DPR.</target>
        </trans-unit>
        <trans-unit id="cdfeac47c5892b6d5954da0f63cd683192cebcee" translate="yes" xml:space="preserve">
          <source>Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set.</source>
          <target state="translated">Неупорядоченные и упорядоченные наборы ортогональны,опять же в этом модуле;нет неупорядоченного набора,равного любому упорядоченному набору.</target>
        </trans-unit>
        <trans-unit id="0315bcb1361b2c68fa29fded47a0e3b15d0b5028" translate="yes" xml:space="preserve">
          <source>Unpacking and Installation of Release Packages</source>
          <target state="translated">Распаковка и установка релизационных пакетов</target>
        </trans-unit>
        <trans-unit id="3b45b03b4626e1a53bac859dec0524861ec0a57e" translate="yes" xml:space="preserve">
          <source>Unpacks a release package &lt;code&gt;Name.tar.gz&lt;/code&gt; located in the &lt;code&gt;releases&lt;/code&gt; directory.</source>
          <target state="translated">Распаковывает релиз-пакет &lt;code&gt;Name.tar.gz&lt;/code&gt; , расположенный в каталоге &lt;code&gt;releases&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a99a056cf6ecaf575d784978bf9746e5f0db64d" translate="yes" xml:space="preserve">
          <source>Unrecognized options are ignored.</source>
          <target state="translated">Неопознанные опции игнорируются.</target>
        </trans-unit>
        <trans-unit id="c3e8f759a055d6a9097dc478f2320ca3772d6837" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored but are returned unmodified by &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; and can be referred to in predicate functions passed to &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Нераспознанные параметры игнорируются, но возвращаются в неизмененном виде с &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; и на них можно ссылаться в функциях предиката, передаваемых в &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcf136da00ab173645906b6446844bfeeb401e42" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored.</source>
          <target state="translated">Непризнанные опции игнорируются.</target>
        </trans-unit>
        <trans-unit id="db0b20da3e0471bc484aaa9c62ebfd991d58e416" translate="yes" xml:space="preserve">
          <source>Unregister a notification filter.</source>
          <target state="translated">Не регистрировать фильтр уведомлений.</target>
        </trans-unit>
        <trans-unit id="4e280e10a8485894674391e4d6645db6545aff52" translate="yes" xml:space="preserve">
          <source>Unregister a sub-agent. If the second argument is a pid, then that sub-agent will be unregistered from all trees in &lt;code&gt;Agent&lt;/code&gt;.</source>
          <target state="translated">Отмените регистрацию субагента. Если вторым аргументом является pid, тогда этот субагент будет отменен для всех деревьев в &lt;code&gt;Agent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f03ca80c8e4fbe50cea94aadfa5356b1cefa6ea2" translate="yes" xml:space="preserve">
          <source>Unregister the agent.</source>
          <target state="translated">Отмените регистрацию агента.</target>
        </trans-unit>
        <trans-unit id="b5f3dba02392fc14b01a49c5237fb9ba133abd12" translate="yes" xml:space="preserve">
          <source>Unregister the subagent, handling part of the mib-tree, as specified by the &lt;code&gt;oid()&lt;/code&gt; or &lt;code&gt;pid()&lt;/code&gt; (&lt;code&gt;PidOrOid&lt;/code&gt;).</source>
          <target state="translated">Отмените регистрацию подагента, обрабатывающего часть mib-дерева, как указано в &lt;code&gt;oid()&lt;/code&gt; или &lt;code&gt;pid()&lt;/code&gt; ( &lt;code&gt;PidOrOid&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f8277a7a1c1b3585ee2c7d6442d480190db4efc" translate="yes" xml:space="preserve">
          <source>Unregister the user.</source>
          <target state="translated">Отмените регистрацию пользователя.</target>
        </trans-unit>
        <trans-unit id="a8a27c51fcd7b00626a6adb2154cd8c213ef4ec1" translate="yes" xml:space="preserve">
          <source>Unregister this USM user.</source>
          <target state="translated">Отмените регистрацию этого пользователя USM.</target>
        </trans-unit>
        <trans-unit id="e8d7b4bee0a41ee99a7b5f42eb631d46c2797262" translate="yes" xml:space="preserve">
          <source>Unregisters a name from &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">Отменяет регистрацию имени в &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="778ebac023e85b1f0510378d21c9e5c1fcf345ea" translate="yes" xml:space="preserve">
          <source>Unregisters all USM users.</source>
          <target state="translated">Отменяет регистрацию всех пользователей USM.</target>
        </trans-unit>
        <trans-unit id="3c58e843a4c38141952ae3478058bdba2218974e" translate="yes" xml:space="preserve">
          <source>Unregisters all managed agents.</source>
          <target state="translated">Отменить все управляемые агенты.</target>
        </trans-unit>
        <trans-unit id="246367dd21663f20ce31444da8332f55bea35d97" translate="yes" xml:space="preserve">
          <source>Unregisters all users.</source>
          <target state="translated">Отменить регистрацию всех пользователей.</target>
        </trans-unit>
        <trans-unit id="32c40ce96fa1e83b3bd9616363397a86b832aa70" translate="yes" xml:space="preserve">
          <source>Unregisters the crypto key fun and terminates the process holding it, started by &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Отменяет регистрацию криптографического ключа fun и завершает удерживающий его процесс, запущенный &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c5ba8d70542c76fd25b8d56f14442cbc2255390" translate="yes" xml:space="preserve">
          <source>Unregisters the specified USM users.</source>
          <target state="translated">Отменяет регистрацию указанных пользователей USM.</target>
        </trans-unit>
        <trans-unit id="01d1e628f578a9203fd5dd6ce46d237fc06cee37" translate="yes" xml:space="preserve">
          <source>Unregisters the specified managed agents.</source>
          <target state="translated">Отмените регистрацию указанных управляемых агентов.</target>
        </trans-unit>
        <trans-unit id="b35f5d367e4318dedf6e9eecba89fb487eb5ab44" translate="yes" xml:space="preserve">
          <source>Unregisters the specified users.</source>
          <target state="translated">Отменяет регистрацию указанных пользователей.</target>
        </trans-unit>
        <trans-unit id="39827e01c383c5bfbd3766c32b34efde1bf35451" translate="yes" xml:space="preserve">
          <source>Unresolved Calls. Empty in &lt;code&gt;modules&lt;/code&gt; mode.</source>
          <target state="translated">Неразрешенные вызовы. Пусто в режиме &lt;code&gt;modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f30d44760477c48d3263ea185339929d64ed8c" translate="yes" xml:space="preserve">
          <source>Unresolved calls make module data incomplete, which implies that the results of analyses may be invalid.</source>
          <target state="translated">Неразрешенные вызовы делают данные модуля неполными,что подразумевает,что результаты анализа могут быть недействительными.</target>
        </trans-unit>
        <trans-unit id="6d813c57ac643b33b15704ddfaac2f69f436d7ab" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer.</source>
          <target state="translated">Беззнаковое 8-битное целое число.</target>
        </trans-unit>
        <trans-unit id="c196c4cb59b173e8333c1a8a5df703d2addbca5b" translate="yes" xml:space="preserve">
          <source>Unspecified connection shutdown.</source>
          <target state="translated">Неопределенное отключение соединения.</target>
        </trans-unit>
        <trans-unit id="23ba21b928bd868bd499fdc4e16f1fbae6b293bf" translate="yes" xml:space="preserve">
          <source>Unsticks a directory that is marked as sticky.</source>
          <target state="translated">Отключает директорию,помеченную как &quot;липкая&quot;.</target>
        </trans-unit>
        <trans-unit id="2277446510c2f9009fdeac95bbe80a1168ba956b" translate="yes" xml:space="preserve">
          <source>Unsubscribe to event messages from a service.</source>
          <target state="translated">Отказ от подписки на сообщения о событиях от службы.</target>
        </trans-unit>
        <trans-unit id="bcf5dcc3da0cf64b87e972ea01a22a51c15d8495" translate="yes" xml:space="preserve">
          <source>Unused Functions (*). All local and exported functions of analyzed modules that have not been used.</source>
          <target state="translated">Неиспользуемые функции (*).Все локальные и экспортированные функции анализируемых модулей,которые не были использованы.</target>
        </trans-unit>
        <trans-unit id="48532263f2300b60babe28fff5fbbc91ed7d708c" translate="yes" xml:space="preserve">
          <source>Unused functions and imports</source>
          <target state="translated">Неиспользуемые функции и импорт</target>
        </trans-unit>
        <trans-unit id="e9b3d935e2fe5c05c6efefdff41786dcbb306041" translate="yes" xml:space="preserve">
          <source>Unused variables</source>
          <target state="translated">Неиспользуемые переменные</target>
        </trans-unit>
        <trans-unit id="b7745c954ca016fa895b408f407a03e565617f6b" translate="yes" xml:space="preserve">
          <source>Up to five log files at maximum 100 KB each with the content of the standard streams from and to the command. (Both the number of logs and sizes can be changed by environment variables, see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; below.)</source>
          <target state="translated">До пяти файлов журнала размером не более 100 КБ каждый с содержимым стандартных потоков от и до команды. (Как количество журналов, так и размеры могут быть изменены с помощью переменных среды, см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="9dd274c7d6098a1a4d8932d92e9e158a8e9dd4b8" translate="yes" xml:space="preserve">
          <source>Up to now, examples of a number of functions that can be used inside a transaction have been shown. The following list shows the &lt;strong&gt;simplest&lt;/strong&gt;&lt;code&gt;Mnesia&lt;/code&gt; functions that work with transactions. Notice that these functions must be embedded in a transaction. If no enclosing transaction (or other enclosing &lt;code&gt;Mnesia&lt;/code&gt; activity) exists, they all fail.</source>
          <target state="translated">До сих пор были показаны примеры ряда функций, которые можно использовать внутри транзакции. В следующем списке показаны &lt;strong&gt;простейшие&lt;/strong&gt; функции &lt;code&gt;Mnesia&lt;/code&gt; , которые работают с транзакциями. Обратите внимание, что эти функции должны быть встроены в транзакцию. Если закрывающая транзакция (или другая включающая активность &lt;code&gt;Mnesia&lt;/code&gt; ) не существует, все они терпят неудачу.</target>
        </trans-unit>
        <trans-unit id="01b4c751d26980e5035738b359c986debcfcf4b4" translate="yes" xml:space="preserve">
          <source>Up until ERTS version 8.*, the check process code operation checks for all types of references to the old code. That is, direct references (e.g. return addresses on the process stack), indirect references (&lt;code&gt;fun&lt;/code&gt;s in process context), and references to literals in the code.</source>
          <target state="translated">До ERTS версии 8. * операция кода процесса проверки проверяет все типы ссылок на старый код. То есть прямые ссылки (например, адреса возврата в стеке процесса), косвенные ссылки ( &lt;code&gt;fun&lt;/code&gt; в контексте процесса) и ссылки на литералы в коде.</target>
        </trans-unit>
        <trans-unit id="4c2624bab6b3cfd68919c56a6d5e5cfd349d334b" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. An exception &lt;code&gt;{badkey,Key}&lt;/code&gt; is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the map.</source>
          <target state="translated">Обновите значение в &lt;code&gt;Map1&lt;/code&gt; , связанном с &lt;code&gt;Key&lt;/code&gt; , вызвав &lt;code&gt;Fun&lt;/code&gt; для старого значения, чтобы получить новое значение. Если &lt;code&gt;Key&lt;/code&gt; отсутствует на карте, генерируется исключение &lt;code&gt;{badkey,Key}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c9b1268f0c338627a3b15658c74da637dde057f" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in &lt;code&gt;Map1&lt;/code&gt; then &lt;code&gt;Init&lt;/code&gt; will be associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">Обновите значение в &lt;code&gt;Map1&lt;/code&gt; , связанном с &lt;code&gt;Key&lt;/code&gt; , вызвав &lt;code&gt;Fun&lt;/code&gt; для старого значения, чтобы получить новое значение. Если &lt;code&gt;Key&lt;/code&gt; отсутствует в &lt;code&gt;Map1&lt;/code&gt; , то &lt;code&gt;Init&lt;/code&gt; будет связан с &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2fca097e563aa25bfd5fb033663686a751ded2" translate="yes" xml:space="preserve">
          <source>Update agent config. The function &lt;code&gt;update_agent_info/3&lt;/code&gt; should be used when several values needs to be updated atomically.</source>
          <target state="translated">Конфигурация агента обновления. Функцию &lt;code&gt;update_agent_info/3&lt;/code&gt; следует использовать, когда несколько значений необходимо обновить атомарно.</target>
        </trans-unit>
        <trans-unit id="e65320d77653af5410845622a9ee939279e72f69" translate="yes" xml:space="preserve">
          <source>Update an MD5 &lt;code&gt;Context&lt;/code&gt; with &lt;code&gt;Data&lt;/code&gt; and returns a &lt;code&gt;NewContext&lt;/code&gt;.</source>
          <target state="translated">Обновите &lt;code&gt;Context&lt;/code&gt; MD5 с &lt;code&gt;Data&lt;/code&gt; и возвращает &lt;code&gt;NewContext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c23ed960405748d119e2cf48c12e3dfbd628b3" translate="yes" xml:space="preserve">
          <source>Update configuration data for the specified handler. This function behaves as if it was implemented as follows:</source>
          <target state="translated">Обновите данные конфигурации для указанного обработчика.Эта функция ведет себя так,как если бы она была реализована следующим образом:</target>
        </trans-unit>
        <trans-unit id="fe58a4200c84c77e18dad55e69d7d322faa4c745" translate="yes" xml:space="preserve">
          <source>Update information about a user</source>
          <target state="translated">Обновить информацию о пользователе</target>
        </trans-unit>
        <trans-unit id="312c6091d8eac0e5b07d6cd16487ac2bd404f20a" translate="yes" xml:space="preserve">
          <source>Update information about an active connection</source>
          <target state="translated">Обновить информацию об активном подключении</target>
        </trans-unit>
        <trans-unit id="1fe0611d972ddd201356bf6556896ed52b2f48ec" translate="yes" xml:space="preserve">
          <source>Update primary configuration data for Logger. This function behaves as if it was implemented as follows:</source>
          <target state="translated">Обновление данных первичной конфигурации для логгера.Эта функция ведет себя так,как если бы она была реализована следующим образом:</target>
        </trans-unit>
        <trans-unit id="764a554dd6a058f4ee8b2a49aff080d148edb108" translate="yes" xml:space="preserve">
          <source>Update the application version number in the &lt;code&gt;.app&lt;/code&gt; file and write an &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">Обновите номер версии приложения в файле &lt;code&gt;.app&lt;/code&gt; и напишите файл &lt;code&gt;.appup&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="df2e0eab67dde01477b9adecadae6f860b5f68c2" translate="yes" xml:space="preserve">
          <source>Update the connection info protocol_version.</source>
          <target state="translated">Обновите версию протокола_соответствия.</target>
        </trans-unit>
        <trans-unit id="1ae0552d56ac843dfab3a0e0e90394739c437be4" translate="yes" xml:space="preserve">
          <source>Update the formatter configuration for the specified handler.</source>
          <target state="translated">Обновите конфигурацию формата для указанного обработчика.</target>
        </trans-unit>
        <trans-unit id="e12a74739554e4908ca08a51e98ff68b92ec211d" translate="yes" xml:space="preserve">
          <source>Update the receive handle of the control process (e.g. after having changed protocol version).</source>
          <target state="translated">Обновите приемную оболочку процесса управления (например,после изменения версии протокола).</target>
        </trans-unit>
        <trans-unit id="4ff8cf55883e7040256c251d18a9776b47973fa6" translate="yes" xml:space="preserve">
          <source>Update the receive handle with the encoding-config (the &lt;code&gt;encoding_config&lt;/code&gt; field).</source>
          <target state="translated">Обновите дескриптор приема с помощью encoding-config ( поле &lt;code&gt;encoding_config&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b4e75d0ad461333a3e5a1fa13055100c26a0e7bc" translate="yes" xml:space="preserve">
          <source>Update usm user config.</source>
          <target state="translated">Обновить пользовательскую конфигурацию usm.</target>
        </trans-unit>
        <trans-unit id="5ff39bab1bf1708cca0909e3396800e9779cd838" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is present in the tree.</source>
          <target state="translated">Обновления &lt;code&gt;Key&lt;/code&gt; к значению &lt;code&gt;Value&lt;/code&gt; в &lt;code&gt;Tree1&lt;/code&gt; и возвращает новое дерево. Предполагает, что ключ присутствует в дереве.</target>
        </trans-unit>
        <trans-unit id="ce52fdc3093dff8fef11813ce4ce3d448b0c6f2e" translate="yes" xml:space="preserve">
          <source>Updates a running Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the checksum.</source>
          <target state="translated">Обновляет текущую контрольную сумму Adler-32 для &lt;code&gt;Data&lt;/code&gt; . Если &lt;code&gt;Data&lt;/code&gt; - пустой двоичный файл или пустой список iolist, эта функция возвращает требуемое начальное значение для контрольной суммы.</target>
        </trans-unit>
        <trans-unit id="39a616ffbea893cd0d7caf81f5c475e558b40da3" translate="yes" xml:space="preserve">
          <source>Updates a running CRC checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the CRC.</source>
          <target state="translated">Обновляет текущую контрольную сумму CRC для &lt;code&gt;Data&lt;/code&gt; . Если &lt;code&gt;Data&lt;/code&gt; - это пустой двоичный файл или пустой список iolist, эта функция возвращает необходимое начальное значение для CRC.</target>
        </trans-unit>
        <trans-unit id="b8d39f7d480179f5db485862d26b6c6e7aed7b81" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. An exception is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary.</source>
          <target state="translated">Обновляет значение в словаре, вызывая &lt;code&gt;Fun&lt;/code&gt; для значения, чтобы получить новое значение. Если &lt;code&gt;Key&lt;/code&gt; отсутствует в словаре, создается исключение .</target>
        </trans-unit>
        <trans-unit id="ab59d74f46080461c39369f0019171f2f23af955" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as follows:</source>
          <target state="translated">Обновляет значение в словаре, вызывая &lt;code&gt;Fun&lt;/code&gt; для значения, чтобы получить новое значение. Если &lt;code&gt;Key&lt;/code&gt; отсутствует в словаре, &lt;code&gt;Initial&lt;/code&gt; сохраняется как первое значение. Например, &lt;code&gt;append/3&lt;/code&gt; можно определить следующим образом:</target>
        </trans-unit>
        <trans-unit id="9f6a761f1dc7fcd9496ff0fc00ba409b036ce20c" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as:</source>
          <target state="translated">Обновляет значение в словаре, вызывая &lt;code&gt;Fun&lt;/code&gt; для значения, чтобы получить новое значение. Если &lt;code&gt;Key&lt;/code&gt; отсутствует в словаре, &lt;code&gt;Initial&lt;/code&gt; сохраняется как первое значение. Например, &lt;code&gt;append/3&lt;/code&gt; можно определить как:</target>
        </trans-unit>
        <trans-unit id="37c90a4670b3f9486158db598e8de0114e5577be" translate="yes" xml:space="preserve">
          <source>Updates an accumulator by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt;. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The final value of the accumulator is returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">Обновляет аккумулятор, применяя &lt;code&gt;Fun&lt;/code&gt; на каждую коллекции аннотаций в &lt;code&gt;erl_parse&lt;/code&gt; дереве &lt;code&gt;Abstr&lt;/code&gt; . Первый вызов &lt;code&gt;Fun&lt;/code&gt; имеет аргумент &lt;code&gt;AccIn&lt;/code&gt; , возвращенный аккумулятор &lt;code&gt;AccOut&lt;/code&gt; передается следующему вызову и так далее. Возвращается окончательное значение аккумулятора. &lt;code&gt;erl_parse&lt;/code&gt; дерево проходится в глубину первой слева направо моды.</target>
        </trans-unit>
        <trans-unit id="e6ebcf826afc7224f3463dd215eb5352561a6434" translate="yes" xml:space="preserve">
          <source>Updates information about debugged processes. Information about all terminated processes are removed from the window. All Attach Process windows for terminated processes are closed.</source>
          <target state="translated">Обновляет информацию об отлаженных процессах.Информация обо всех завершенных процессах удаляется из окна.Закрыты все окна Attach Process для завершенных процессов.</target>
        </trans-unit>
        <trans-unit id="a4db32f627e995a84c52631b1bbbde821d611764" translate="yes" xml:space="preserve">
          <source>Updates the HMAC represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using an HMAC init function (such as &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hmac_update&lt;/code&gt; or to one of the functions &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Обновляет HMAC, представленный &lt;code&gt;Context&lt;/code&gt; с использованием заданных &lt;code&gt;Data&lt;/code&gt; . &lt;code&gt;Context&lt;/code&gt; должен быть сгенерирован с использованием функции инициализации HMAC (например, &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;Data&lt;/code&gt; могут быть любой длины. &lt;code&gt;NewContext&lt;/code&gt; должен быть передан при следующем вызове &lt;code&gt;hmac_update&lt;/code&gt; или одной из функций &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cc7f14f3a3fed19f2f8c9a020605209d8a12c68" translate="yes" xml:space="preserve">
          <source>Updates the digest represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; or a previous call to this function. &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hash_update&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обновляет дайджест, представленный &lt;code&gt;Context&lt;/code&gt; с использованием заданных &lt;code&gt;Data&lt;/code&gt; . &lt;code&gt;Context&lt;/code&gt; должен быть создан с помощью &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; или предыдущего вызова этой функции. &lt;code&gt;Data&lt;/code&gt; могут быть любой длины. &lt;code&gt;NewContext&lt;/code&gt; должен быть передан в следующий вызов &lt;code&gt;hash_update&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a37f581698786fafdf7275742d9f7c793868104" translate="yes" xml:space="preserve">
          <source>Updates the hook function field of the prettyprinter context.</source>
          <target state="translated">Обновление поля функции перехвата в контексте красивого принтера.</target>
        </trans-unit>
        <trans-unit id="c2e71d06680882c2ec32b2dc6bea400636a79824" translate="yes" xml:space="preserve">
          <source>Updates the line widh field of the prettyprinter context.</source>
          <target state="translated">Обновление поля вида строк в контексте красивого принтера.</target>
        </trans-unit>
        <trans-unit id="06a0436ed02af4ad242287fe8c27e31aafc0067b" translate="yes" xml:space="preserve">
          <source>Updates the object with key &lt;code&gt;Key&lt;/code&gt; stored in table &lt;code&gt;Name&lt;/code&gt; of type &lt;code&gt;set&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at the &lt;code&gt;Pos&lt;/code&gt;:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated.</source>
          <target state="translated">Обновляет объект с помощью ключа &lt;code&gt;Key&lt;/code&gt; , хранящегося в таблице &lt;code&gt;Name&lt;/code&gt; типа, &lt;code&gt;set&lt;/code&gt; путем добавления &lt;code&gt;Incr&lt;/code&gt; к элементу в позиции &lt;code&gt;Pos&lt;/code&gt; : th. Возвращается новое значение счетчика. Если позиция не указана, обновляется элемент, следующий за ключом.</target>
        </trans-unit>
        <trans-unit id="74b81e579810979a583fac3a15071ea6d7e0648e" translate="yes" xml:space="preserve">
          <source>Updates the operator precedence field of the prettyprinter context. See the &lt;code&gt;erl_parse(3)&lt;/code&gt; module for operator precedences.</source>
          <target state="translated">Обновляет поле приоритета оператора в контексте prettyprinter. См. &lt;code&gt;erl_parse(3)&lt;/code&gt; для получения информации о приоритетах операторов.</target>
        </trans-unit>
        <trans-unit id="63d2d102522483d5460d1744c9d5282ecfc3df2b" translate="yes" xml:space="preserve">
          <source>Updates the paper widh field of the prettyprinter context.</source>
          <target state="translated">Обновляет видо-поле бумаги контекста красивого принтера.</target>
        </trans-unit>
        <trans-unit id="1f9326e8e858c536ca9e794bc54c6e439dd4f44b" translate="yes" xml:space="preserve">
          <source>Updates the user data field of the prettyprinter context.</source>
          <target state="translated">Обновляет поле пользовательских данных контекста красивого принтера.</target>
        </trans-unit>
        <trans-unit id="eb57e471df554364292c825fe5e79967d1cd792b" translate="yes" xml:space="preserve">
          <source>Updating a map has a similar syntax as constructing it.</source>
          <target state="translated">Обновление карты имеет такой же синтаксис,как и ее построение.</target>
        </trans-unit>
        <trans-unit id="a4ccacf954181a7d1504665a82641050052eb900" translate="yes" xml:space="preserve">
          <source>Upgrade the connection associated with &lt;code&gt;Handle&lt;/code&gt; to a tls connection if possible.</source>
          <target state="translated">Если возможно, обновите соединение, связанное с &lt;code&gt;Handle&lt;/code&gt; , до tls.</target>
        </trans-unit>
        <trans-unit id="ca4651bcfd7cc66e9b643622e9b6fa5cf9be97fb" translate="yes" xml:space="preserve">
          <source>Upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, connected socket to an TLS socket, that is, performs the client-side TLS handshake.</source>
          <target state="translated">Обновляет подключенный сокет &lt;code&gt;gen_tcp&lt;/code&gt; или эквивалентный ему до TLS-сокета, то есть выполняет подтверждение TLS на стороне клиента.</target>
        </trans-unit>
        <trans-unit id="0885a1400bd730b033aa9a97c94e31cdcc2976c9" translate="yes" xml:space="preserve">
          <source>Upgrades an application &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt; according to the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="translated">Обновляет приложение &lt;code&gt;App&lt;/code&gt; с текущей версии до новой версии, расположенной в &lt;code&gt;.appup&lt;/code&gt; &lt;code&gt;Dir&lt;/code&gt; ,в соответствии с файлом .appup .</target>
        </trans-unit>
        <trans-unit id="fe465284017475712d39dd7e9e97f804a2375abf" translate="yes" xml:space="preserve">
          <source>Upon failure to reopen the log, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">При неудачном открытии журнала процесс журнала диска завершается с сообщением EXIT &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt; . Другие процессы, у которых есть запросы в очереди, получают сообщение &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="313cdf1a747cf13f7fb3ba0b75e218a96c2914cd" translate="yes" xml:space="preserve">
          <source>Uppercase letter</source>
          <target state="translated">прописная буква</target>
        </trans-unit>
        <trans-unit id="655dc371ef84593d2a9260f8648168e35e59595a" translate="yes" xml:space="preserve">
          <source>Uppercase letters</source>
          <target state="translated">заглавные буквы</target>
        </trans-unit>
        <trans-unit id="42df97f2f6a736b6736486799c452f7ab2ae5c74" translate="yes" xml:space="preserve">
          <source>Uppercase letters signify real identifiers and lowercase letters signify fake identifiers only used for description of the topology. Identifiers passed as real identifiers can be used by the runtime system when trying to access specific hardware; if they are incorrect the behavior is undefined. Faked logical CPU identifiers are not accepted, as there is no point in defining the CPU topology without real logical CPU identifiers. Thread, core, processor, and node identifiers can be omitted. If omitted, the thread ID defaults to &lt;code&gt;t0&lt;/code&gt;, the core ID defaults to &lt;code&gt;c0&lt;/code&gt;, the processor ID defaults to &lt;code&gt;p0&lt;/code&gt;, and the node ID is left undefined. Either each logical processor must belong to only one NUMA node, or no logical processors must belong to any NUMA nodes.</source>
          <target state="translated">Прописные буквы означают реальные идентификаторы, а строчные буквы означают поддельные идентификаторы, используемые только для описания топологии. Идентификаторы, переданные как реальные идентификаторы, могут использоваться системой времени выполнения при попытке доступа к определенному оборудованию; если они неверны, поведение не определено. Поддельные логические идентификаторы ЦП не принимаются, поскольку нет смысла определять топологию ЦП без реальных логических идентификаторов ЦП. Идентификаторы потока, ядра, процессора и узла можно не указывать. Если он опущен, идентификатор потока по умолчанию &lt;code&gt;t0&lt;/code&gt; , идентификатор ядра по умолчанию - &lt;code&gt;c0&lt;/code&gt; , идентификатор процессора по умолчанию - &lt;code&gt;p0&lt;/code&gt; , а идентификатор узла остается неопределенным. Либо каждый логический процессор должен принадлежать только одному узлу NUMA, либо никакие логические процессоры не должны принадлежать каким-либо узлам NUMA.</target>
        </trans-unit>
        <trans-unit id="19370c86dcca239b2f891f36eb2a0c4f475f930f" translate="yes" xml:space="preserve">
          <source>Uri data types</source>
          <target state="translated">Uri-типы данных</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="2c9af3bf645c9bf6cb6b56eedb88807aad3f66ae" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; with an absolute path after &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; с абсолютным путем после &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c47962432a46afd10354bf7faf78b77ebd176482" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; together with &lt;code&gt;enif_select&lt;/code&gt; to detect failing Erlang processes and prevent them from causing permanent leakage of resources and their contained OS event objects.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; вместе с &lt;code&gt;enif_select&lt;/code&gt; для обнаружения сбойных процессов Erlang и предотвращения их постоянной утечки ресурсов и содержащихся в них объектов событий ОС.</target>
        </trans-unit>
        <trans-unit id="f81221a29d13782207a78cbfa816c0cbf3c464d7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; to signal that no more data is to be sent and wait for the read side of the socket to be closed.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; чтобы сигнализировать о том, что больше не нужно отправлять данные, и дождитесь закрытия стороны чтения сокета.</target>
        </trans-unit>
        <trans-unit id="71bd29e8e106825432b11d0f4aa2b931f6f8bf79" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; to retrieve the current Erlang system time on the &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; of your choice.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; , чтобы получить текущее системное время Erlang в выбранной вами &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c6d38128136d372de87b2cca11fa0fc14d3b6dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; используйте net_adm: ping (Node) .</target>
        </trans-unit>
        <trans-unit id="611de99bd7fd476bf937c72c0e0fd5671d5f5338" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; to see the content of the history buffer and &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; to re-execute one of the entries.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; , чтобы увидеть содержимое буфера истории, и &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; , чтобы повторно выполнить одну из записей.</target>
        </trans-unit>
        <trans-unit id="03a0a6dcdb4bb774d1d742179139e2e450523f30" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; as &lt;code&gt;mode&lt;/code&gt; in order to safely close an event object that has been passed to &lt;code&gt;enif_select&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback of the resource &lt;code&gt;obj&lt;/code&gt; will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received and no further calls to &lt;code&gt;enif_select&lt;/code&gt; have been made.</source>
          <target state="translated">Используйте &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; в качестве &lt;code&gt;mode&lt;/code&gt; , чтобы безопасно закрыть объект события, переданный в &lt;code&gt;enif_select&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; обратного вызова ресурса &lt;code&gt;obj&lt;/code&gt; будет вызываться , когда это безопасно , чтобы закрыть объект события. Этот безопасный способ закрытия объектов событий должен использоваться, даже если все уведомления были получены и никаких дальнейших вызовов &lt;code&gt;enif_select&lt;/code&gt; не производилось.</target>
        </trans-unit>
        <trans-unit id="4dbf19e8e181869d7824e230cc259b4296e049dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;M-x compile&lt;/code&gt; to compile an MIB from inside Emacs, and enter:</source>
          <target state="translated">Используйте &lt;code&gt;M-x compile&lt;/code&gt; для компиляции MIB из Emacs и введите:</target>
        </trans-unit>
        <trans-unit id="43487582b9c31bb61fd048104c15adf5df0fcbcf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:is_compiled/1&lt;/code&gt; or &lt;code&gt;code:which/1&lt;/code&gt; to see if a module is Cover compiled (and still loaded) or not.</source>
          <target state="translated">Используйте &lt;code&gt;cover:is_compiled/1&lt;/code&gt; или &lt;code&gt;code:which/1&lt;/code&gt; , чтобы узнать, скомпилирован ли модуль Cover (и все еще загружен) или нет.</target>
        </trans-unit>
        <trans-unit id="7f85d8a08505e2b0a869a54c5dd45740db5b3406" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:start/1&lt;/code&gt; and &lt;code&gt;cover:stop/1&lt;/code&gt; to add or remove nodes. The same Cover compiled code will be loaded on each node, and analysis will collect and sum up coverage data results from all nodes.</source>
          <target state="translated">Используйте &lt;code&gt;cover:start/1&lt;/code&gt; и &lt;code&gt;cover:stop/1&lt;/code&gt; для добавления или удаления узлов. Один и тот же скомпилированный код Cover будет загружен на каждый узел, и анализ будет собирать и суммировать результаты данных покрытия со всех узлов.</target>
        </trans-unit>
        <trans-unit id="5b51e4203eb742f5eb4fc26e38e7eb765f543077" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;driver_alloc_binary()&lt;/code&gt; to allocate a binary.</source>
          <target state="translated">Используйте &lt;code&gt;driver_alloc_binary()&lt;/code&gt; для выделения двоичного файла .</target>
        </trans-unit>
        <trans-unit id="c95131c00c47173f141a21936f6eef73f82cca9f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:get_cookie()&lt;/code&gt; in ERTS instead.</source>
          <target state="translated">&lt;code&gt;erlang:get_cookie()&lt;/code&gt; используйте erlang: get_cookie () в ERTS.</target>
        </trans-unit>
        <trans-unit id="7c041275bff1db161bb6bcf06b8c664a175f0746" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:now/0&lt;/code&gt; to retrieve the current Erlang system time.</source>
          <target state="translated">Используйте &lt;code&gt;erlang:now/0&lt;/code&gt; , чтобы получить текущее системное время Erlang.</target>
        </trans-unit>
        <trans-unit id="de069253a09bf6a9eebbd010c198840f5e87a703" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; instead.</source>
          <target state="translated">Использование &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="4290f2a7a214d1f9ba5e3a266d300f53024ef971" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;hipe:help_options/0&lt;/code&gt; to print out the available options.</source>
          <target state="translated">Используйте &lt;code&gt;hipe:help_options/0&lt;/code&gt; , чтобы распечатать доступные параметры.</target>
        </trans-unit>
        <trans-unit id="ae0a3e8fb6ea6a46c1431393956ad0cdb131d016" translate="yes" xml:space="preserve">
          <source>Use Compiler option &lt;code&gt;{debug_info_key,Key}&lt;/code&gt;, see &lt;code&gt;compile(3)&lt;/code&gt; and function &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; to register a fun that returns the key whenever &lt;code&gt;beam_lib&lt;/code&gt; must decrypt the debug information.</source>
          <target state="translated">Используйте параметр компилятора &lt;code&gt;{debug_info_key,Key}&lt;/code&gt; , см. Compile &lt;code&gt;compile(3)&lt;/code&gt; и функцию &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; , чтобы зарегистрировать забаву, которая возвращает ключ всякий раз, когда &lt;code&gt;beam_lib&lt;/code&gt; должен расшифровать отладочную информацию.</target>
        </trans-unit>
        <trans-unit id="cf76996b770b568aba2d669a4a4c375802561542" translate="yes" xml:space="preserve">
          <source>Use Dialyzer from the command line to detect defects in the specified files or directories containing &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.beam&lt;/code&gt; files, depending on the type of the analysis.</source>
          <target state="translated">Используйте Dialyzer из командной строки для обнаружения дефектов в указанных файлах или каталогах, содержащих &lt;code&gt;.erl&lt;/code&gt; или &lt;code&gt;.beam&lt;/code&gt; , в зависимости от типа анализа.</target>
        </trans-unit>
        <trans-unit id="52ecd59359aa11823ae3489c4b92ca323d2f8686" translate="yes" xml:space="preserve">
          <source>Use Mnesia with the following types of applications:</source>
          <target state="translated">Используйте Mnesia со следующими типами приложений:</target>
        </trans-unit>
        <trans-unit id="cd0851048c67fb91d296c17c79d984235168aa8a" translate="yes" xml:space="preserve">
          <source>Use STDLIB application variable &lt;code&gt;restricted_shell&lt;/code&gt; and specify, as its value, the name of the callback module. Example (with callback functions implemented in &lt;code&gt;callback_mod.erl&lt;/code&gt;): &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt;.</source>
          <target state="translated">Используйте переменную приложения STDLIB &lt;code&gt;restricted_shell&lt;/code&gt; и укажите в качестве ее значения имя модуля обратного вызова. Пример (с функциями обратного вызова, реализованными в &lt;code&gt;callback_mod.erl&lt;/code&gt; ): &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9de9466c5fd84c1497ee031330a8bf3182295b3" translate="yes" xml:space="preserve">
          <source>Use a parameterized query to insert many rows in one go.</source>
          <target state="translated">Используйте параметризованный запрос для вставки многих строк за один заход.</target>
        </trans-unit>
        <trans-unit id="4246bdbd0514a46c24c66d6a824bf38823f49b83" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm with a constant seed:</source>
          <target state="translated">Используйте заданный алгоритм с постоянным посевным материалом:</target>
        </trans-unit>
        <trans-unit id="98d7bed7136a80ee2a1f391e37af7b4e25791949" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm:</source>
          <target state="translated">Используйте указанный алгоритм:</target>
        </trans-unit>
        <trans-unit id="0ef43eef2287dfb39d5045b73777b94383dd1809" translate="yes" xml:space="preserve">
          <source>Use active mode only if your high-level protocol provides its own flow control (for example, acknowledging received messages) or the amount of data exchanged is small. &lt;code&gt;{active, false}&lt;/code&gt; mode, use of the &lt;code&gt;{active, once}&lt;/code&gt; mode, or &lt;code&gt;{active, N}&lt;/code&gt; mode with values of &lt;code&gt;N&lt;/code&gt; appropriate for the application provides flow control. The other side cannot send faster than the receiver can read.</source>
          <target state="translated">Используйте активный режим только в том случае, если ваш протокол высокого уровня обеспечивает собственное управление потоком (например, подтверждение полученных сообщений) или объем передаваемых данных невелик. Режим &lt;code&gt;{active, false}&lt;/code&gt; , использование режима &lt;code&gt;{active, once}&lt;/code&gt; или &lt;code&gt;{active, N}&lt;/code&gt; со значениями &lt;code&gt;N&lt;/code&gt; , подходящими для приложения, обеспечивает управление потоком. Другая сторона не может отправить быстрее, чем может прочитать получатель.</target>
        </trans-unit>
        <trans-unit id="0cb9f5afdf0431967f44f8bc5907c7bc9106a55e" translate="yes" xml:space="preserve">
          <source>Use batch file &lt;code&gt;etop.bat&lt;/code&gt;, for example, &lt;code&gt;etop -node tiger@durin&lt;/code&gt;.</source>
          <target state="translated">Используйте командный файл &lt;code&gt;etop.bat&lt;/code&gt; , например, &lt;code&gt;etop -node tiger@durin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804cbb37615425c1f58bef26b23df4ccbb998e2d" translate="yes" xml:space="preserve">
          <source>Use bitwise AND to test for specific bits in the return value. New significant bits may be added in future releases to give more detailed information for both failed and successful calls. Do NOT use equality tests like &lt;code&gt;==&lt;/code&gt;, as that may cause your application to stop working.</source>
          <target state="translated">Используйте побитовое И для проверки наличия определенных битов в возвращаемом значении. В будущих версиях могут быть добавлены новые значащие биты для предоставления более подробной информации как для неудачных, так и для успешных вызовов. НЕ используйте тесты на равенство, такие как &lt;code&gt;==&lt;/code&gt; , так как это может привести к прекращению работы вашего приложения.</target>
        </trans-unit>
        <trans-unit id="28d05d6e3c0c6496475b27e170aa3c9890b934a6" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; to obtain a basic pattern, which matches all records in a table, or use the default value in record creation. Do not make the pattern hard-coded, as this makes the code more vulnerable to future changes of the record definition.</source>
          <target state="translated">Используйте функцию &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; чтобы получить базовый шаблон, который соответствует всем записям в таблице, или используйте значение по умолчанию при создании записи. Не делайте шаблон жестко запрограммированным, так как это делает код более уязвимым для будущих изменений определения записи.</target>
        </trans-unit>
        <trans-unit id="36fef5f536ab55188b5441adeba6150367c3ff02" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; to list all loaded reports:</source>
          <target state="translated">Используйте функцию &lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; чтобы просмотреть все загруженные отчеты:</target>
        </trans-unit>
        <trans-unit id="b28b25ff39058f6138bbe1ff3ebce8f3b6ccb94a" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; to show details of a specific report:</source>
          <target state="translated">Используйте функцию &lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; чтобы отобразить детали конкретного отчета:</target>
        </trans-unit>
        <trans-unit id="a0eac0e99e0695efffadbf6a76c731707faeeeea" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; to stop the &lt;code&gt;rb_server&lt;/code&gt;:</source>
          <target state="translated">Используйте функцию &lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; чтобы остановить &lt;code&gt;rb_server&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="012887c588a915c59771e087bcd639512c6a8489" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; to get all flags for features that require strict order delivery.</source>
          <target state="translated">Используйте функцию &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; , чтобы получить все флаги для функций, которые требуют доставки в строгом порядке.</target>
        </trans-unit>
        <trans-unit id="7f83ae95c5e5857514f24ca4885f3294c1f168dd" translate="yes" xml:space="preserve">
          <source>Use its graphical interface to investigate the state of the current test case.</source>
          <target state="translated">Используйте его графический интерфейс для исследования состояния текущего тестового случая.</target>
        </trans-unit>
        <trans-unit id="66df33ce491bfcd444a606b910f4cb9ff07688b9" translate="yes" xml:space="preserve">
          <source>Use maps instead of records to represent the &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; types. No &lt;code&gt;.hrl&lt;/code&gt; files will be generated. See the Section &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">Используйте карты вместо записей для представления типов &lt;code&gt;SEQUENCE&lt;/code&gt; и &lt;code&gt;SET&lt;/code&gt; . Нет &lt;code&gt;.hrl&lt;/code&gt; файлов не будет. Для получения дополнительной информации см. &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; на карте раздела .</target>
        </trans-unit>
        <trans-unit id="d6e7a5bbaac2fe1d22a38124df53d79bef29a950" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;killproc&lt;/code&gt; procedure in the above script can be combined with a call to &lt;code&gt;erl_call&lt;/code&gt;, for example:</source>
          <target state="translated">Использование процедуры &lt;code&gt;killproc&lt;/code&gt; в приведенном выше сценарии может быть объединено с вызовом &lt;code&gt;erl_call&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="b3ca6ef9bc0eb0fd175268e16b224fb66ca6f3fe" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to receive messages:</source>
          <target state="translated">Для приема сообщений используйте одну из следующих двух функций:</target>
        </trans-unit>
        <trans-unit id="889a7015472f4f91d80360afa19301c38e311202" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to send messages:</source>
          <target state="translated">Для отправки сообщений используйте одну из следующих двух функций:</target>
        </trans-unit>
        <trans-unit id="4154e7c45ed1c09b28a8e036ce840111c118baa6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; to name directories to be searched for application files (equivalent to the &lt;code&gt;path&lt;/code&gt; in the option list for &lt;code&gt;systools:make_script/2&lt;/code&gt;).</source>
          <target state="translated">Используйте опцию &lt;code&gt;-I&lt;/code&gt; для именования каталогов, в которых будет производиться поиск файлов приложения (эквивалент &lt;code&gt;path&lt;/code&gt; в списке опций для &lt;code&gt;systools:make_script/2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c5e91c4910f51c44ca054a05924c3387fce83e6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; with the name of a file to use that file as a customized prologue file (option &lt;code&gt;includefile&lt;/code&gt;).</source>
          <target state="translated">Используйте опцию &lt;code&gt;-I&lt;/code&gt; с именем файла, чтобы использовать этот файл в качестве настраиваемого файла пролога (опция &lt;code&gt;includefile&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d55bb82b3630e22429844da6211b0339bba98ea8" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;strong_validation&lt;/code&gt; to generate all warnings that the compiler would generate.</source>
          <target state="translated">Используйте параметр &lt;code&gt;strong_validation&lt;/code&gt; , чтобы генерировать все предупреждения, которые будет генерировать компилятор.</target>
        </trans-unit>
        <trans-unit id="7937b3339663cb4514ac276573d7e2c9e0dfd606" translate="yes" xml:space="preserve">
          <source>Use relaxed command checking only on systems with very limited interactive usage.</source>
          <target state="translated">Используйте расслабленную проверку команд только на системах с очень ограниченным интерактивным использованием.</target>
        </trans-unit>
        <trans-unit id="7e8be1e3581d1297371b0474f66ebe7774bd9957" translate="yes" xml:space="preserve">
          <source>Use script &lt;code&gt;etop&lt;/code&gt;.</source>
          <target state="translated">Используйте скрипт &lt;code&gt;etop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecdd13a57f7a43ae5c5be43fc2ede21e975f620a" translate="yes" xml:space="preserve">
          <source>Use selective decode instead of exclusive decode if you are interested in only a single subvalue.</source>
          <target state="translated">Используйте выборочное декодирование вместо эксклюзивного,если вас интересует только одно подзначение.</target>
        </trans-unit>
        <trans-unit id="edc8ad2b93f84080dbc37116f7108a665d7b55ac" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SEND_SENDER&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; instead of the &lt;code&gt;SEND&lt;/code&gt; control message and use the &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message instead of the &lt;code&gt;SEND_TT&lt;/code&gt; control message.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; &lt;code&gt;SEND_SENDER&lt;/code&gt; вместо управляющего сообщения &lt;code&gt;SEND&lt;/code&gt; и используйте управляющее сообщение &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; вместо управляющего сообщения &lt;code&gt;SEND_TT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb13f68ed22ba4a08751c4363250d2b2b3fba90" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bin_opt_info&lt;/code&gt; option to have the compiler print a lot of information about binary optimizations. It can be given either to the compiler or &lt;code&gt;erlc&lt;/code&gt;:</source>
          <target state="translated">Используйте параметр &lt;code&gt;bin_opt_info&lt;/code&gt; , чтобы компилятор распечатал много информации об оптимизации двоичных файлов. Его можно передать компилятору или &lt;code&gt;erlc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c30d8bd130bb93833dc88f2efb2369af2066111" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;file&lt;/code&gt; module for files opened for bytewise access (&lt;code&gt;{encoding,latin1}&lt;/code&gt;).</source>
          <target state="translated">Используйте &lt;code&gt;file&lt;/code&gt; модуль для файлов, открытых для побайтного доступа ( &lt;code&gt;{encoding,latin1}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cec2d14858ca56aa4886d5cb596e4d1c4389bb5d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;io&lt;/code&gt; module when accessing files with any other encoding (for example &lt;code&gt;{encoding,uf8}&lt;/code&gt;).</source>
          <target state="translated">Используйте модуль &lt;code&gt;io&lt;/code&gt; при доступе к файлам с любой другой кодировкой (например, &lt;code&gt;{encoding,uf8}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9e21bc6d17c5f3138b318feb1664293ef1335717" translate="yes" xml:space="preserve">
          <source>Use the GUI.</source>
          <target state="translated">Используй графический интерфейс.</target>
        </trans-unit>
        <trans-unit id="e3f1aa1f6c936dd4bbcc665fff827922973d80d2" translate="yes" xml:space="preserve">
          <source>Use the following command to generate a .hrl file from an MIB:</source>
          <target state="translated">Используйте следующую команду для генерации файла .hrl из MIB:</target>
        </trans-unit>
        <trans-unit id="285645e77ad81adce8bdc1256d83d49b2f715165" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described here and in the User's Guide:</source>
          <target state="translated">Используйте следующую директиву для получения доступа к записям и постоянным макросам,описанным здесь и в руководстве пользователя:</target>
        </trans-unit>
        <trans-unit id="26340e5bfdecd44f5d627a8bf499337d449c9b39" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described in the following sections:</source>
          <target state="translated">Используйте следующую директиву include для получения доступа к записям и постоянным макросам,описанным в следующих разделах:</target>
        </trans-unit>
        <trans-unit id="eaf38e520f81f823bc5c2944fc89ede2ea27b2c7" translate="yes" xml:space="preserve">
          <source>Use the function &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; to add new fragments and apply the usual schema manipulation functions (such as &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt;) on each fragment to perform the actual redistribution.</source>
          <target state="translated">Используйте функцию &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; , чтобы добавить новые фрагменты и применить обычные функции манипулирования схемой (такие как &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; ) для каждого фрагмента, чтобы выполнить фактическое перераспределение.</target>
        </trans-unit>
        <trans-unit id="81d58859492a0e6cf67a695fecde344397df4fa0" translate="yes" xml:space="preserve">
          <source>Use the function describe_table/[2,3] to find out which ODBC data type that is expected for each column of that table. If a column has a data type that is described with capital letters, alas it is not currently supported by the param_query function. Too know which Erlang data type corresponds to an ODBC data type see the Erlang to ODBC data type &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Используйте функцию describe_table / [2,3], чтобы узнать, какой тип данных ODBC ожидается для каждого столбца этой таблицы. Если столбец имеет тип данных, описанный заглавными буквами, увы, в настоящее время он не поддерживается функцией param_query. Чтобы узнать, какой тип данных Erlang соответствует типу данных ODBC, см. &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; типов данных Erlang с ODBC в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="6e938f8eaaf7a2fb5db93a5741c75b6c3d2b1e56" translate="yes" xml:space="preserve">
          <source>Use the functional API with a non-constant seed:</source>
          <target state="translated">Используйте функциональный API с нестандартным посевным материалом:</target>
        </trans-unit>
        <trans-unit id="541ddc36dcd95bdf4f3b7b106057bafcf839da79" translate="yes" xml:space="preserve">
          <source>Use the map in the ssl key option:</source>
          <target state="translated">Используйте карту в параметре клавиши ssl:</target>
        </trans-unit>
        <trans-unit id="8bedd4105b0c918e36403c94a86cea217070bfac" translate="yes" xml:space="preserve">
          <source>Use the same Erlang types to represent &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; as in OTP R16.</source>
          <target state="translated">Используйте те же типы Erlang для представления &lt;code&gt;BIT STRING&lt;/code&gt; и &lt;code&gt;OCTET STRING&lt;/code&gt; , что и в OTP R16.</target>
        </trans-unit>
        <trans-unit id="203bf7370538dd892cf94b38b1e17b25aedb4cc9" translate="yes" xml:space="preserve">
          <source>Use the socket option &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (or something similar) to make it possible for the receiver to close the connection when it knowns it has received all the data.</source>
          <target state="translated">Используйте опцию сокета &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (или что-то подобное), чтобы получатель мог закрыть соединение, когда он узнает, что получил все данные.</target>
        </trans-unit>
        <trans-unit id="57d720aadc70a1b56241025a699cc74ef9ea249d" translate="yes" xml:space="preserve">
          <source>Use the specified PLT as the initial PLT. If the PLT was built during setup, the files are checked for consistency.</source>
          <target state="translated">В качестве исходного PLT используйте указанный PLT.Если PLT был построен во время установки,файлы проверяются на соответствие.</target>
        </trans-unit>
        <trans-unit id="0ad77542229ec1d771e4e02b6524ee184d641040" translate="yes" xml:space="preserve">
          <source>Use the value returned from &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; to create a name unique on the current runtime system instance. If you only want positive integers, you can use &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте значение, возвращаемое из &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; , чтобы создать имя, уникальное для текущего экземпляра системы времени выполнения. Если вам нужны только положительные целые числа, вы можете использовать &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e36f8f2cb8b647a47cca517ff03d541469491a2" translate="yes" xml:space="preserve">
          <source>Use the values returned from &lt;code&gt;erlang:now/0&lt;/code&gt; to create a name unique on the current runtime system instance.</source>
          <target state="translated">Используйте значения, возвращенные из &lt;code&gt;erlang:now/0&lt;/code&gt; , чтобы создать имя, уникальное для текущего экземпляра системы времени выполнения.</target>
        </trans-unit>
        <trans-unit id="5a1a3d93db801fcbd6f501d39eac8cc569d5150c" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure, and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">Используйте эту функцию после сбоя системного вызова. Сообщение, предоставленное вызывающей стороной, печатается, за которой следует строка, описывающая причину сбоя, и процесс завершается со значением выхода &lt;code&gt;1&lt;/code&gt; . Эта функция не возвращается.</target>
        </trans-unit>
        <trans-unit id="60cd4eee7b91477f96873aee8f0c08a0e1659942" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure.</source>
          <target state="translated">Используйте эту функцию после неудачного системного вызова.Сообщение вызывающего абонента выводится на печать,за ним следует строка,описывающая причину сбоя.</target>
        </trans-unit>
        <trans-unit id="ac3be946393c47f35eede2756d19558abc69e73e" translate="yes" xml:space="preserve">
          <source>Use this function only if you know what you are doing, that is, on your own applications. It is very application-dependent and configuration parameter-dependent when and how often the value is read by the application. Careless use of this function can put the application in a weird, inconsistent, and malfunctioning state.</source>
          <target state="translated">Используйте эту функцию только в том случае,если вы знаете,что делаете,то есть в собственных приложениях.Она очень сильно зависит от приложения,а конфигурация-от того,когда и как часто значение считывается приложением.Небрежное использование этой функции может привести приложение в странное,непоследовательное и неисправное состояние.</target>
        </trans-unit>
        <trans-unit id="8d1a6a43cff399c18914850f099af42f99ff52a6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; a specific match specification saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте эту функцию, чтобы &amp;laquo;забыть&amp;raquo; конкретную спецификацию совпадения, сохраненную во время вызовов &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6bca535e578b8f96edf192f36e88f0568555ba6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; all match specifications saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. This is useful when one wants to restore other match specifications from a file with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; to delete specific saved match specifications.</source>
          <target state="translated">Используйте эту функцию, чтобы &amp;laquo;забыть&amp;raquo; все спецификации совпадений, сохраненные во время вызовов &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; . Это полезно, когда нужно восстановить другие спецификации совпадений из файла с помощью &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; . Используйте &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; для удаления определенных сохраненных спецификаций совпадений.</target>
        </trans-unit>
        <trans-unit id="d051de59e60744864ad96b5d4970120ccdf3ce13" translate="yes" xml:space="preserve">
          <source>Use this function to recall all match specifications previously used in the session (i. e. previously saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, and built-in match specifications. This is very useful, as a complicated match_spec can be quite awkward to write. Note that the match specifications are lost if &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Используйте эту функцию для вызова всех спецификаций совпадений, ранее использовавшихся в сеансе (т. Е. Ранее сохраненных во время вызовов &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; , и встроенных спецификаций совпадений. Это очень полезно, так как сложный match_spec может быть довольно неудобным для написания. Обратите внимание, что спецификации соответствия теряются при вызове &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c941b9c92bccb005e3755850980e1a4c93df1aed" translate="yes" xml:space="preserve">
          <source>Use this function to set, or modify, the verbosity level for a logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to set the general verbosity level.</source>
          <target state="translated">Используйте эту функцию, чтобы установить или изменить уровень детализации для категории ведения журнала. Подробности см. В &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; . Используйте значение по &lt;code&gt;default&lt;/code&gt; чтобы установить общий уровень детализации.</target>
        </trans-unit>
        <trans-unit id="cb4f981450d616f53002b2dbe1a22bf77c775fe2" translate="yes" xml:space="preserve">
          <source>Use this function when a fatal error has occurred that is not because of a system call. The message provided by the caller is printed and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">Используйте эту функцию, если произошла фатальная ошибка не из-за системного вызова. Сообщение, предоставленное вызывающим абонентом, распечатывается, и процесс завершается со значением выхода &lt;code&gt;1&lt;/code&gt; . Эта функция не возвращается.</target>
        </trans-unit>
        <trans-unit id="927c6ba6b883da5a944bc17195e2455b95cac07d" translate="yes" xml:space="preserve">
          <source>Use this function with extreme caution, as it makes existing persistent data obsolete. Think twice before using it.</source>
          <target state="translated">Используйте эту функцию с крайней осторожностью,так как она делает существующие постоянные данные устаревшими.Подумайте дважды,прежде чем использовать ее.</target>
        </trans-unit>
        <trans-unit id="03f95d87f375280efaeeb6fe8cafb649410d718d" translate="yes" xml:space="preserve">
          <source>Use this module to set up Telnet connections, send commands, and perform string matching on the result. For information about how to use &lt;code&gt;ct_telnet&lt;/code&gt; and configure connections, specifically for UNIX hosts, see the &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Используйте этот модуль для установки соединений Telnet, отправки команд и выполнения сопоставления строк в результате. Для получения информации о том, как использовать &lt;code&gt;ct_telnet&lt;/code&gt; и настроить соединения, особенно для хостов UNIX, см. &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; руководства unix_telnet .</target>
        </trans-unit>
        <trans-unit id="d5d50bad282c0804f9a7e02550f10159ee185809" translate="yes" xml:space="preserve">
          <source>Use this option when receiving binaries from an untrusted source.</source>
          <target state="translated">Используйте эту опцию,когда получаете двоичные файлы из недоверенного источника.</target>
        </trans-unit>
        <trans-unit id="01f5382feca2bb4947c345ec5297001b4439de6e" translate="yes" xml:space="preserve">
          <source>Use with extreme care.</source>
          <target state="translated">Используйте с крайней осторожностью.</target>
        </trans-unit>
        <trans-unit id="926a25ba00ec3f71fce83c4ae2a582227ec44542" translate="yes" xml:space="preserve">
          <source>Used BIFs. &lt;code&gt;B&lt;/code&gt; is empty if &lt;code&gt;builtins&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all analyzed modules.</source>
          <target state="translated">Использовали BIF. &lt;code&gt;B&lt;/code&gt; пусто, если для всех анализируемых модулей &lt;code&gt;builtins&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c11ee9255f50f3fa3a1ac060817b8601274af33d" translate="yes" xml:space="preserve">
          <source>Used Library Modules.</source>
          <target state="translated">Библиотечные модули.</target>
        </trans-unit>
        <trans-unit id="aaea96d1f0adade7428605a5b6a71a977e21c17f" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; to return information about the runtime system. Contains the same content as &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используется &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; для возврата информации о системе времени выполнения. Содержит то же содержимое, что и &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42d74dbb12b0fb1f6ea1d95300289917f6910dc7" translate="yes" xml:space="preserve">
          <source>Used by a process to redefine the error handler for undefined function calls and undefined registered processes. Inexperienced users are not to use this flag, as code auto-loading depends on the correct operation of the error handling module.</source>
          <target state="translated">Используется процессом для переопределения обработчика ошибок для неопределенных вызовов функций и неопределенных зарегистрированных процессов.Неопытные пользователи не должны использовать этот флаг,так как автозагрузка кода зависит от корректной работы модуля обработки ошибок.</target>
        </trans-unit>
        <trans-unit id="021e8894d4cd8efeb3800e902cce4283561eaa59" translate="yes" xml:space="preserve">
          <source>Used by a server process to accept a connection from a client process.</source>
          <target state="translated">Используется серверным процессом для приема соединения от клиентского процесса.</target>
        </trans-unit>
        <trans-unit id="6c49623f58e59d8735fea69dd29c4f20e63decdd" translate="yes" xml:space="preserve">
          <source>Used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling either of these functions, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="translated">Используется серверным процессом для регистрации на локальном сервере имен EPMD, тем самым позволяя другим процессам отправлять сообщения, используя зарегистрированное имя. Перед вызовом любой из этих функций процесс должен был вызвать &lt;code&gt;bind()&lt;/code&gt; и &lt;code&gt;listen()&lt;/code&gt; для открытого сокета.</target>
        </trans-unit>
        <trans-unit id="5f5237d3789fea5df1f7ffca0fba9777e1547c1e" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Size&lt;/code&gt; is an expression that is to evaluate to an integer.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; используемый в построении битовой строки, представляет собой выражение, которое должно оцениваться как целое число.</target>
        </trans-unit>
        <trans-unit id="a7cde552a3551769508a6d34af2b5b84e289881d" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Value&lt;/code&gt; is an expression that is to evaluate to an integer, float, or bit string. If the expression is not a single literal or variable, it is to be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;Value&lt;/code&gt; используемое в построении битовой строки, представляет собой выражение, которое должно оценивать целое число, число с плавающей запятой или битовую строку. Если выражение не является отдельным литералом или переменной, его следует заключить в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="e7fa51f6619aef90e556b2317c4e8c8b56b58094" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Size&lt;/code&gt; must be an integer, or a variable bound to an integer.</source>
          <target state="translated">Используемый в сопоставлении битовой строки, &lt;code&gt;Size&lt;/code&gt; должен быть целым числом или переменной, связанной с целым числом.</target>
        </trans-unit>
        <trans-unit id="a2ea25edea36db50d30cde55ba8333dc776429fb" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Value&lt;/code&gt; must be a variable, or an integer, float, or string.</source>
          <target state="translated">Используемое при сопоставлении битовой строки &lt;code&gt;Value&lt;/code&gt; должно быть переменной, целым числом, числом с плавающей запятой или строкой.</target>
        </trans-unit>
        <trans-unit id="00b8635528024d62633ce26ebc8ade8bf9cf1f13" translate="yes" xml:space="preserve">
          <source>Used in socket close message.</source>
          <target state="translated">Используется в сообщении о закрытии сокета.</target>
        </trans-unit>
        <trans-unit id="37771a4a8b87640f401b1b514090e62c25bfd4a6" translate="yes" xml:space="preserve">
          <source>Used in socket data message.</source>
          <target state="translated">Используется в сообщении данных сокета.</target>
        </trans-unit>
        <trans-unit id="94de0e417f3f0b14c77f33a57c9b9d9d4a4e16c3" translate="yes" xml:space="preserve">
          <source>Used to perform codec measurements. That is, to see what kind of performance can be expected by the different codecs provided by the megaco application.</source>
          <target state="translated">Используется для выполнения измерений кодеков.То есть,чтобы увидеть,какую производительность можно ожидать от различных кодеков,предоставляемых приложением megaco.</target>
        </trans-unit>
        <trans-unit id="4ea4aa7eefddb763ba10cb9daaf61feb433c13d7" translate="yes" xml:space="preserve">
          <source>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используется для установки трассировки распределения. Уровни бывают разной степени детализации. Более высокий уровень означает больше информации. См. Также раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e0558fbc4bfc3f98f9c0aff78f8bf8c889c7ae8" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; to uniquely identify a HTTP server. This can be useful in a virtualized environment, where there can be more that one server that has the same bind_address and port. If this property is not explicitly set, it is assumed that the &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt;uniquely identifies the HTTP server.</source>
          <target state="translated">Используется вместе с &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; для однозначной идентификации HTTP-сервера. Это может быть полезно в виртуализированной среде, где может быть несколько серверов с одинаковым bind_address и портом. Если это свойство не задано явно, предполагается, что &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; однозначно идентифицируют HTTP-сервер.</target>
        </trans-unit>
        <trans-unit id="770e0b9f1dc73dcbf183dcbbbc53e3cf5e4375d4" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; to uniquely identify a ssh daemon. This can be useful in a virtualized environment, where there can be more that one server that has the same &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;. If this property is not explicitly set, it is assumed that the the &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; uniquely identifies the SSH daemon.</source>
          <target state="translated">Используется вместе с &lt;code&gt;ip-address&lt;/code&gt; и &lt;code&gt;port&lt;/code&gt; для однозначной идентификации демона ssh. Это может быть полезно в виртуализированной среде, где может быть несколько серверов с одним и тем же &lt;code&gt;ip-address&lt;/code&gt; и &lt;code&gt;port&lt;/code&gt; . Если это свойство не задано явно, предполагается, что &lt;code&gt;ip-address&lt;/code&gt; и &lt;code&gt;port&lt;/code&gt; однозначно идентифицируют демон SSH.</target>
        </trans-unit>
        <trans-unit id="adce6622f9543e73767624ada8f13763e382d86b" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;send_timeout&lt;/code&gt; to specify whether the socket is to be automatically closed when the send operation returns &lt;code&gt;{error,timeout}&lt;/code&gt;. The recommended setting is &lt;code&gt;true&lt;/code&gt;, which automatically closes the socket. Defaults to &lt;code&gt;false&lt;/code&gt; because of backward compatibility.</source>
          <target state="translated">Используется вместе с &lt;code&gt;send_timeout&lt;/code&gt; , чтобы указать, должен ли сокет автоматически закрываться, когда операция отправки возвращает &lt;code&gt;{error,timeout}&lt;/code&gt; . Рекомендуемая настройка - &lt;code&gt;true&lt;/code&gt; , которая автоматически закрывает сокет. По умолчанию &lt;code&gt;false&lt;/code&gt; из-за обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="07eb868bef5aa368e19bb894ec05dbc37d91a59f" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;{verify, verify_peer}&lt;/code&gt; by an TLS/DTLS server. If set to &lt;code&gt;true&lt;/code&gt;, the server fails if the client does not have a certificate to send, that is, sends an empty certificate. If set to &lt;code&gt;false&lt;/code&gt;, it fails only if the client sends an invalid certificate (an empty certificate is considered valid). Defaults to false.</source>
          <target state="translated">Используется вместе с &lt;code&gt;{verify, verify_peer}&lt;/code&gt; сервером TLS / DTLS. Если установлено значение &lt;code&gt;true&lt;/code&gt; , сервер не работает, если у клиента нет сертификата для отправки, то есть отправляет пустой сертификат. Если установлено значение &lt;code&gt;false&lt;/code&gt; , он не работает, только если клиент отправляет недействительный сертификат (пустой сертификат считается действительным). По умолчанию false.</target>
        </trans-unit>
        <trans-unit id="5ec279a6fe9dd1161f2aa08b6ed9eb431c51ce40" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; has called &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; and has a trace token with flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; set to &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">Используется, когда процесс &lt;code&gt;From&lt;/code&gt; вызвал &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; и имеет токен трассировки с флагом &lt;code&gt;print&lt;/code&gt; , установленным на &lt;code&gt;true&lt;/code&gt; , а &lt;code&gt;label&lt;/code&gt; - на &lt;code&gt;Label&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec8ed9ea4c0a02770b19230ee831fc7eabc65212" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; with its trace token flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; has sent a message.</source>
          <target state="translated">Используется , когда процесс &lt;code&gt;From&lt;/code&gt; своей трассировки маркера флаг &lt;code&gt;print&lt;/code&gt; установлен в &lt;code&gt;true&lt;/code&gt; послал сообщение.</target>
        </trans-unit>
        <trans-unit id="f532ecd45390412a4c37f8eaaaf1dd3a2bc7a9e4" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;To&lt;/code&gt; receives a message with a trace token that has flag &lt;code&gt;'receive'&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Используется, когда процесс &lt;code&gt;To&lt;/code&gt; получает сообщение с токеном трассировки, для которого установлен флаг &lt;code&gt;'receive'&lt;/code&gt; в значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed866b317195673cc57f0bfced4e8f18f9deb039" translate="yes" xml:space="preserve">
          <source>Used when a restart of the emulator is required after all other upgrade instructions are executed. For more information about this instruction, see restart_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используется, когда требуется перезапуск эмулятора после выполнения всех остальных инструкций по обновлению. Дополнительные сведения об этой инструкции см. В разделе restart_emulator (низкоуровневый) в &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b51ce444943f18b5b406c12d5de312dd469de6a1" translate="yes" xml:space="preserve">
          <source>Used when connection is up.</source>
          <target state="translated">Используется,когда соединение установлено.</target>
        </trans-unit>
        <trans-unit id="98f3f0d6b5fe552d6fdd9e8a1ac4b1dbc95a1e0a" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. &lt;code&gt;{M, F, Arity}&lt;/code&gt; is specified instead of &lt;code&gt;{M, F, Args}&lt;/code&gt; in call trace messages.</source>
          <target state="translated">Используется с флагом трассировки &lt;code&gt;call&lt;/code&gt; . &lt;code&gt;{M, F, Arity}&lt;/code&gt; указывается вместо &lt;code&gt;{M, F, Args}&lt;/code&gt; в сообщениях отслеживания вызовов.</target>
        </trans-unit>
        <trans-unit id="35c8c1e7148c094e7f1037898138a703736b5c71" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. The &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;return_from&lt;/code&gt;, and &lt;code&gt;return_to&lt;/code&gt; trace messages are inhibited if this flag is set, but they are executed as normal if there are match specifications.</source>
          <target state="translated">Используется с флагом трассировки &lt;code&gt;call&lt;/code&gt; . В &lt;code&gt;call&lt;/code&gt; , &lt;code&gt;return_from&lt;/code&gt; и &lt;code&gt;return_to&lt;/code&gt; сообщения трассировки блокируются , если этот флаг установлен, но они выполняются в обычном режиме , если есть спецификации совпадают.</target>
        </trans-unit>
        <trans-unit id="35f97b1230868a1d952f070b44e014ae71c9b348" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option &lt;code&gt;local&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используется с флагом трассировки &lt;code&gt;call&lt;/code&gt; . Отслеживает возврат от отслеживаемой функции к ее вызывающей стороне. Работает только для функций, отслеживаемых с помощью параметра &lt;code&gt;local&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0771df2c0469ced91bfba340e5621231c3eb3f97" translate="yes" xml:space="preserve">
          <source>Useful for debugging. Prints the arguments sent to the emulator.</source>
          <target state="translated">Полезно для отладки.Распечатывает аргументы,посылаемые в эмулятор.</target>
        </trans-unit>
        <trans-unit id="bda40ec80a6280d040ae6cb2132464ae8868382d" translate="yes" xml:space="preserve">
          <source>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</source>
          <target state="translated">Полезно только для настройки производительности.Не используйте эту опцию,если не знаете,что есть проблемы со временем выполнения или потреблением памяти,и убедитесь,что эта опция улучшает качество работы.</target>
        </trans-unit>
        <trans-unit id="1b5232bbae53583af327fbf580fd761e961eb1ae" translate="yes" xml:space="preserve">
          <source>Useful options for the ASN.1 compiler:</source>
          <target state="translated">Полезные опции для компилятора ASN.1:</target>
        </trans-unit>
        <trans-unit id="108800af422d061f509679723cbd223daa96eb6e" translate="yes" xml:space="preserve">
          <source>User Authentication (using Mnesia, Dets or plain text database)</source>
          <target state="translated">Аутентификация пользователя (с помощью Mnesia,Dets или базы данных с обычным текстом)</target>
        </trans-unit>
        <trans-unit id="b6d7d2ae9aeff0edfea9298508c33c3156394dee" translate="yes" xml:space="preserve">
          <source>User authentication using text files, Dets, or Mnesia database.</source>
          <target state="translated">Аутентификация пользователей с использованием текстовых файлов,базы данных Dets или Mnesia.</target>
        </trans-unit>
        <trans-unit id="fdf44c259444d43d89a931e2c5f009d59f5246ec" translate="yes" xml:space="preserve">
          <source>User does not have privileges to create symbolic links (&lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; on Windows).</source>
          <target state="translated">У пользователя нет прав на создание символических ссылок ( &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; в Windows).</target>
        </trans-unit>
        <trans-unit id="bfa1d0c7af0339d4d928dbeac41cc561fc954a37" translate="yes" xml:space="preserve">
          <source>User info - Information related to megaco users. Read/Write.</source>
          <target state="translated">Информация для пользователей-Информация,относящаяся к пользователям megaco.Читать/Писать.</target>
        </trans-unit>
        <trans-unit id="5943eb1d1f04ded83e3e46ef3224b51f634ef059" translate="yes" xml:space="preserve">
          <source>User is not logged in.</source>
          <target state="translated">Пользователь не вошел в систему.</target>
        </trans-unit>
        <trans-unit id="ad777a4590258aa35737d9328314ce537d2c9cb8" translate="yes" xml:space="preserve">
          <source>User login information</source>
          <target state="translated">регистрационные данные пользователя</target>
        </trans-unit>
        <trans-unit id="6fb1ac68e43ee6fa885af993d59c13a42fa4cd33" translate="yes" xml:space="preserve">
          <source>User owning the public key.</source>
          <target state="translated">Пользователь владеет открытым ключом.</target>
        </trans-unit>
        <trans-unit id="ba07b0c96db1af8dcefb2d9162e61ba1cb1cc53b" translate="yes" xml:space="preserve">
          <source>User's private key(s)</source>
          <target state="translated">личный ключ(и)пользователя</target>
        </trans-unit>
        <trans-unit id="31f9f489aed30f7126e13ae2a6c8aa3e1dfb69c4" translate="yes" xml:space="preserve">
          <source>User's public key</source>
          <target state="translated">открытый ключ пользователя</target>
        </trans-unit>
        <trans-unit id="38a1ad1d15fcc5f9e499bc1732d0978996617997" translate="yes" xml:space="preserve">
          <source>User-Name AVP</source>
          <target state="translated">Имя пользователя AVP</target>
        </trans-unit>
        <trans-unit id="12d9701932fd2b8fbf1ff963e66877b3fb9d5041" translate="yes" xml:space="preserve">
          <source>User-defined entries can also be written to a configuration file by calling function &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt;, where &lt;code&gt;ConfigList&lt;/code&gt; is a list of &lt;code&gt;{Module,Function,Args}&lt;/code&gt;.</source>
          <target state="translated">Пользовательские записи также могут быть записаны в файл конфигурации путем вызова функции &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt; , где &lt;code&gt;ConfigList&lt;/code&gt; - это список &lt;code&gt;{Module,Function,Args}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56ea86a7fa1494da2715a81abce4cab0c8f4eb29" translate="yes" xml:space="preserve">
          <source>User-defined event handlers can be added to handle application-specific events.</source>
          <target state="translated">Для обработки событий,специфичных для конкретного приложения,могут быть добавлены пользовательские обработчики событий.</target>
        </trans-unit>
        <trans-unit id="d44e29b83c2f61db1703ca0d31d257ddfa7ed010" translate="yes" xml:space="preserve">
          <source>User-specific data for use in hook functions. The default value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Пользовательские данные для использования в функциях ловушки. Значение по умолчанию не &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18e7327216976d6005c52f79eedee5271cbeaf73" translate="yes" xml:space="preserve">
          <source>User-specific event handlers can be plugged into a &lt;code&gt;Common Test&lt;/code&gt; event manager, either by telling &lt;code&gt;Common Test&lt;/code&gt; to install them before the test run (described later), or by adding the handlers dynamically during the test run using &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; or &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt;. In the latter scenario, the reference of the &lt;code&gt;Common Test&lt;/code&gt; event manager is required. To get it, call &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; or (on the &lt;code&gt;Common Test&lt;/code&gt; Master node) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Пользовательские обработчики событий могут быть подключены к диспетчеру событий &lt;code&gt;Common Test&lt;/code&gt; , либо указав &lt;code&gt;Common Test&lt;/code&gt; установить их перед тестовым запуском (описано ниже), либо добавив обработчики динамически во время тестового запуска с помощью &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; или &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt; . В последнем случае требуется ссылка на диспетчер событий &lt;code&gt;Common Test&lt;/code&gt; . Чтобы получить его, вызовите &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; или (на узле &lt;code&gt;Common Test&lt;/code&gt; Master) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca5c1acac21d9a3b6102ae9dadcfac83499ca32" translate="yes" xml:space="preserve">
          <source>UserMod:handle_connect/2</source>
          <target state="translated">UserMod:handle_connect/2</target>
        </trans-unit>
        <trans-unit id="f0d3fd03fc3def42c8da5fe622ad791ccaa1a0ea" translate="yes" xml:space="preserve">
          <source>UserMod:handle_message_error/3</source>
          <target state="translated">UserMod:handle_message_error/3</target>
        </trans-unit>
        <trans-unit id="a3bdb9436158799687b4418588b8647662e27155" translate="yes" xml:space="preserve">
          <source>UserMod:handle_syntax_error/3</source>
          <target state="translated">UserMod:handle_syntax_error/3</target>
        </trans-unit>
        <trans-unit id="7e0a148d93ed9e16bd5599754876deca380f643d" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_ack/4</source>
          <target state="translated">UserMod:handle_trans_ack/4</target>
        </trans-unit>
        <trans-unit id="d345f713a7834aaf56186658aec2115bcc13351b" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_reply/4</source>
          <target state="translated">UserMod:handle_trans_reply/4</target>
        </trans-unit>
        <trans-unit id="3884319e28f9e311d120dba2fbc454b53cead5a4" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_request/3</source>
          <target state="translated">UserMod:handle_trans_request/3</target>
        </trans-unit>
        <trans-unit id="3f6d997ef0e4d563bff3ecdcaff66971fd6b9762" translate="yes" xml:space="preserve">
          <source>Users are advised not to unregister system processes.</source>
          <target state="translated">Пользователям рекомендуется не отменять регистрацию системных процессов.</target>
        </trans-unit>
        <trans-unit id="2d7d513ec1d0fa107e592cfc1c6289d5e8f86f88" translate="yes" xml:space="preserve">
          <source>Users are not allowed to define types with the same names as the predefined or built-in ones. This is checked by the compiler and its violation results in a compilation error.</source>
          <target state="translated">Пользователям не разрешается определять типы с теми же именами,что и предопределенные или встроенные.Это проверяется компилятором и его нарушение приводит к ошибке компиляции.</target>
        </trans-unit>
        <trans-unit id="259b250e47199fdb387584511bbacec343b879b8" translate="yes" xml:space="preserve">
          <source>Users may either explicitly be registered with megaco:start_user/2 and/or be statically configured by setting the application environment variable 'users' to a list of {UserMid, Config} tuples. See the function megaco:start_user/2 for details.</source>
          <target state="translated">Пользователи могут быть либо явно зарегистрированы в megaco:start_user/2,либо статически сконфигурированы,установив переменную окружения приложения 'users' в список кортежей {UserMid,Config}.Подробности смотрите в функции megaco:start_user/2.</target>
        </trans-unit>
        <trans-unit id="944ad3a48b1f08bbcf2fb59d662131185d4fa39c" translate="yes" xml:space="preserve">
          <source>Uses a separate log file for every invocation of the service (&amp;lt;servicename&amp;gt;&lt;code&gt;.debug.&lt;/code&gt;&amp;lt;N&amp;gt;).</source>
          <target state="translated">Использует отдельный файл журнала для каждого вызова службы (&amp;lt; &lt;code&gt;.debug.&lt;/code&gt; &amp;gt; .debug. &amp;lt;N&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="66ba2c7044af64caa2e9580c9ae81af796b430d1" translate="yes" xml:space="preserve">
          <source>Uses a sequence of wrap log files of limited size. As a wrap log file is filled up, further items are logged on to the next file in the sequence, starting all over with the first file when the last file is filled up.</source>
          <target state="translated">Использует последовательность оберточных лог-файлов ограниченного размера.По мере заполнения оберточного лог-файла,последующие элементы регистрируются в следующем файле в последовательности,начиная с первого файла,когда последний файл заполнен.</target>
        </trans-unit>
        <trans-unit id="63cc551f28fdc9de0a6c288edb557951e593faa7" translate="yes" xml:space="preserve">
          <source>Uses a specific or customised prologue file instead of default &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; which is otherwise included.</source>
          <target state="translated">Использует определенный или настроенный файл пролога вместо &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; по умолчанию, который в противном случае включен.</target>
        </trans-unit>
        <trans-unit id="cfb35a958a3524ef916a2dee520c654de0d97728" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a deep list of characters that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure (described in section &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;) is processed.</source>
          <target state="translated">Использует &lt;code&gt;ErrorDescriptor&lt;/code&gt; и возвращает подробный список символов, описывающих ошибку. Эта функция обычно вызывается неявно при &lt;code&gt;ErrorInfo&lt;/code&gt; структуры ErrorInfo (описанной в разделе &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c4139194e768c251d84b03abf5cd321d1df4d02c" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error or warning. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Использует &lt;code&gt;ErrorDescriptor&lt;/code&gt; и возвращает строку, описывающую ошибку или предупреждение. Эта функция обычно вызывается неявно при &lt;code&gt;ErrorInfo&lt;/code&gt; структуры ErrorInfo (см. Раздел &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c93cef9ab961b13c52c3ee1286af209a4ef5d08b" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Использует &lt;code&gt;ErrorDescriptor&lt;/code&gt; и возвращает строку, описывающую ошибку. Эта функция обычно вызывается неявно при &lt;code&gt;ErrorInfo&lt;/code&gt; структуры ErrorInfo (см. Раздел &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e240ed0f46a0e7052bee5a3dec802b98fe462d1" translate="yes" xml:space="preserve">
          <source>Uses test specification as input (described later).</source>
          <target state="translated">Использует спецификацию теста в качестве входной информации (описана ниже).</target>
        </trans-unit>
        <trans-unit id="713999a06cadf66964b72d923b13701c303aa173" translate="yes" xml:space="preserve">
          <source>Uses the Pseudo-Random Function (PRF) of a TLS session to generate extra key material. It either takes user-generated values for &lt;code&gt;Secret&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; or atoms directing it to use a specific value from the session security parameters.</source>
          <target state="translated">Использует псевдослучайную функцию (PRF) сеанса TLS для генерации дополнительного ключевого материала. Он либо принимает значения, созданные пользователем для &lt;code&gt;Secret&lt;/code&gt; и &lt;code&gt;Seed&lt;/code&gt; , либо атомы, указывающие ему использовать конкретное значение из параметров безопасности сеанса.</target>
        </trans-unit>
        <trans-unit id="29fb0bd5ac8937f75326b05d56a7b9c426068b8d" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang Web Server API interaction data:</source>
          <target state="translated">Использует следующие данные взаимодействия API веб-сервера Erlang:</target>
        </trans-unit>
        <trans-unit id="6542021570e55732848d7c4ecf584a9f1fce4a50" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang web server API interaction data:</source>
          <target state="translated">Использует следующие данные взаимодействия API веб-сервера Erlang:</target>
        </trans-unit>
        <trans-unit id="9c87b085bc59aac65ced245c43dfb66c0a327d57" translate="yes" xml:space="preserve">
          <source>Uses the return value of command &lt;code&gt;N&lt;/code&gt; in the current command, if &lt;code&gt;N&lt;/code&gt; is positive. If it is negative, the return value of the &lt;code&gt;N&lt;/code&gt;th previous command is used (that is, &lt;code&gt;v(-1)&lt;/code&gt; uses the value of the previous command).</source>
          <target state="translated">Использует возвращаемое значение команды &lt;code&gt;N&lt;/code&gt; в текущей команде, если &lt;code&gt;N&lt;/code&gt; положительно. Если он отрицательный, используется возвращаемое значение &lt;code&gt;N&lt;/code&gt; - й предыдущей команды (то есть &lt;code&gt;v(-1)&lt;/code&gt; использует значение предыдущей команды).</target>
        </trans-unit>
        <trans-unit id="d7825c5becf2a7bc58af7be09180ec50f46648e4" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.)</source>
          <target state="translated">Использует указанный каталог как текущий каталог. Он добавляется к именам файлов при их извлечении из zip-архива. ( &lt;code&gt;file:set_cwd/1&lt;/code&gt; как file: set_cwd / 1 в ядре, но без изменения глобального свойства &lt;code&gt;cwd&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="f356880e1a29c6875ae88d729105f2618d77c27f" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current work directory (&lt;code&gt;cwd&lt;/code&gt;). This is prepended to filenames when adding them, although not in the zip archive (acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.).</source>
          <target state="translated">Использует указанный каталог как текущий рабочий каталог ( &lt;code&gt;cwd&lt;/code&gt; ). Это добавляется к именам файлов при их добавлении, хотя и не в zip-архиве (действует как &lt;code&gt;file:set_cwd/1&lt;/code&gt; в ядре, но без изменения глобального свойства &lt;code&gt;cwd&lt;/code&gt; .).</target>
        </trans-unit>
        <trans-unit id="3b24dbe95482357a59b64bc1da6d8ac53437250c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-group top1 top2&lt;/code&gt;, or &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; gives the same result.</source>
          <target state="translated">Использование &lt;code&gt;-group top1 top2&lt;/code&gt; или &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; дает тот же результат.</target>
        </trans-unit>
        <trans-unit id="88f4f21380171a61e0164a29d94211d35a1afc8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; enables this transform, unless the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined first.</source>
          <target state="translated">Использование &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; включает это преобразование, если макрос &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; не определен первым.</target>
        </trans-unit>
        <trans-unit id="c20e26276eb3aeb9f802837228801c44d2e93f19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; and a match specification, one can filter out rows of a table and construct a list of tuples containing relevant parts of the data in these rows. One can use &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; instead, but the &lt;code&gt;ets:select/2&lt;/code&gt; call is far more efficient. Without the translation provided by &lt;code&gt;ms_transform&lt;/code&gt;, one must struggle with writing match specifications terms to accommodate this.</source>
          <target state="translated">Используя &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; и спецификацию соответствия, можно отфильтровать строки таблицы и построить список кортежей, содержащих соответствующие части данных в этих строках. &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; этого можно использовать ets: foldl / 3 , но вызов ets &lt;code&gt;ets:select/2&lt;/code&gt; намного эффективнее. Без перевода, предоставленного &lt;code&gt;ms_transform&lt;/code&gt; , придется бороться с написанием терминов спецификаций соответствия, чтобы учесть это.</target>
        </trans-unit>
        <trans-unit id="c82c027de482fad19a39ea9d254bbafa02b405e5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cprof:analyse()&lt;/code&gt; in this example also shows approximately the same background work as in the first example.</source>
          <target state="translated">Использование &lt;code&gt;cprof:analyse()&lt;/code&gt; в этом примере также показывает примерно ту же фоновую работу, что и в первом примере.</target>
        </trans-unit>
        <trans-unit id="8c0e8375352b28a80765ea773ca843308851404f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ct_run -step [opts]&lt;/code&gt;, or by passing option &lt;code&gt;{step,Opts}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, the following is possible:</source>
          <target state="translated">Используя &lt;code&gt;ct_run -step [opts]&lt;/code&gt; или передав параметр &lt;code&gt;{step,Opts}&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; , возможно следующее:</target>
        </trans-unit>
        <trans-unit id="8f64a2837eaf7b8603ee4f3b40320c612c90d80f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;erl_drv_output_term()&lt;/code&gt; or &lt;code&gt;erl_drv_send_term()&lt;/code&gt;, a binary can be included in an Erlang term.</source>
          <target state="translated">Используя &lt;code&gt;erl_drv_output_term()&lt;/code&gt; или &lt;code&gt;erl_drv_send_term()&lt;/code&gt; , двоичный файл может быть включен в термин Erlang.</target>
        </trans-unit>
        <trans-unit id="22c339dd691e6a37b987bcf7700c90e985445f81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, we can combine the ease of use of the &lt;code&gt;ets:foldr/3&lt;/code&gt; and the efficiency of the pure &lt;code&gt;ets:select/2&lt;/code&gt; example:</source>
          <target state="translated">Используя &lt;code&gt;ets:fun2ms/1&lt;/code&gt; , мы можем объединить простоту использования &lt;code&gt;ets:foldr/3&lt;/code&gt; и эффективность чистого примера &lt;code&gt;ets:select/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d06eaee0affa1e9d7ed35b71b0a99a0f3c00b54" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;list_to_atom/1&lt;/code&gt; to construct an atom that is passed to &lt;code&gt;apply/3&lt;/code&gt; as follows, is quite expensive and not recommended in time-critical code:</source>
          <target state="translated">Использование &lt;code&gt;list_to_atom/1&lt;/code&gt; для создания атома, который передается в &lt;code&gt;apply/3&lt;/code&gt; следующим образом, довольно затратно и не рекомендуется в критичном ко времени коде:</target>
        </trans-unit>
        <trans-unit id="81394dd93922176e47458d5f3c15c2b0804bd134" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;scheduler_wall_time&lt;/code&gt; to calculate scheduler utilization:</source>
          <target state="translated">Использование &lt;code&gt;scheduler_wall_time&lt;/code&gt; для расчета использования планировщика:</target>
        </trans-unit>
        <trans-unit id="862378469cf87dc0f0b44de7c775b81caef36dd4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;skip_suites&lt;/code&gt; and &lt;code&gt;skip_cases&lt;/code&gt; terms in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;skip_suites&lt;/code&gt; и &lt;code&gt;skip_cases&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf508ced4ee281be2348cd08d12f83a3f75cac1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; makes SSL or TLS vulnerable to the BEAST attack.</source>
          <target state="translated">Использование &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; делает SSL или TLS уязвимыми для атаки BEAST.</target>
        </trans-unit>
        <trans-unit id="8e8a3b96a977f8581a203f0cc7479a4fa622cf64" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; makes TLS vulnerable to the Poodle attack.</source>
          <target state="translated">Использование &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; делает TLS уязвимым для атаки Poodle .</target>
        </trans-unit>
        <trans-unit id="12c74ea67a8bf514e98bacaa08d939dc388ff2c9" translate="yes" xml:space="preserve">
          <source>Using HiPE</source>
          <target state="translated">Использование HiPE</target>
        </trans-unit>
        <trans-unit id="787b8b2ecfeeac0dc6c8b30eb4f29ae6e32df930" translate="yes" xml:space="preserve">
          <source>Using Mnesia Functions</source>
          <target state="translated">Использование функций Мнезии</target>
        </trans-unit>
        <trans-unit id="69b70d7925c3d595457eb50569e18e9253b0f84e" translate="yes" xml:space="preserve">
          <source>Using Mnesia tables as SNMP tables</source>
          <target state="translated">Использование таблиц Мнезии в качестве SNMP-таблиц</target>
        </trans-unit>
        <trans-unit id="d4556d3a05908d3a2fd5b120b9264ae977bdd001" translate="yes" xml:space="preserve">
          <source>Using QLC</source>
          <target state="translated">Использование QLC</target>
        </trans-unit>
        <trans-unit id="eb75491192cbec18ddc3193ff609070567e4f298" translate="yes" xml:space="preserve">
          <source>Using QLC can be more expensive than using &lt;code&gt;Mnesia&lt;/code&gt; functions directly but offers a nice syntax.</source>
          <target state="translated">Использование QLC может быть дороже, чем использование функций &lt;code&gt;Mnesia&lt;/code&gt; напрямую, но предлагает приятный синтаксис.</target>
        </trans-unit>
        <trans-unit id="b888e7581a06a39525c04389ba7f49f831878208" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;msg_env&lt;/code&gt; of &lt;code&gt;NULL&lt;/code&gt; is an optimization, which groups together calls to &lt;code&gt;enif_alloc_env&lt;/code&gt;, &lt;code&gt;enif_make_copy&lt;/code&gt;, &lt;code&gt;enif_port_command&lt;/code&gt;, and &lt;code&gt;enif_free_env&lt;/code&gt; into one call. This optimization is only useful when a majority of the terms are to be copied from &lt;code&gt;env&lt;/code&gt; to &lt;code&gt;msg_env&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;msg_env&lt;/code&gt; в &lt;code&gt;NULL&lt;/code&gt; является оптимизация, которая группирует вызовы &lt;code&gt;enif_alloc_env&lt;/code&gt; , &lt;code&gt;enif_make_copy&lt;/code&gt; , &lt;code&gt;enif_port_command&lt;/code&gt; и &lt;code&gt;enif_free_env&lt;/code&gt; в один вызов. Эта оптимизация полезна только тогда, когда большая часть терминов должна быть скопирована из &lt;code&gt;env&lt;/code&gt; в &lt;code&gt;msg_env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e05aace796b827cc7de5108dc65985d67668971" translate="yes" xml:space="preserve">
          <source>Using a bridge that maps control messages in a proprietary protocol to a standardized management protocol and conversely</source>
          <target state="translated">Используя мост,который сопоставляет контрольные сообщения в проприетарном протоколе со стандартизованным протоколом управления,и наоборот.</target>
        </trans-unit>
        <trans-unit id="23f87dc632b3b3a497eda26d1e0fd7f024ede833" translate="yes" xml:space="preserve">
          <source>Using a configuration target name (an alias) as reference.</source>
          <target state="translated">Использование имени цели конфигурации (псевдоним)в качестве ссылки.</target>
        </trans-unit>
        <trans-unit id="1bd7819b4238a75d18eacbc298988f60839565ee" translate="yes" xml:space="preserve">
          <source>Using a driver binary instead of a normal buffer is often faster, as the emulator needs not to copy the data, only the pointer is used.</source>
          <target state="translated">Использование двоичного драйвера вместо обычного буфера часто происходит быстрее,так как эмулятору не нужно копировать данные,используется только указатель.</target>
        </trans-unit>
        <trans-unit id="5a4f00d83853b9a89087a2b4d34b93f85e90b8b4" translate="yes" xml:space="preserve">
          <source>Using a proprietary control protocol</source>
          <target state="translated">Использование проприетарного протокола управления</target>
        </trans-unit>
        <trans-unit id="8e93a7f8043acf2f93881fdb114964f55246a652" translate="yes" xml:space="preserve">
          <source>Using a pure password-based authentication scheme. Here, the plain text password is encrypted before sent over the network.</source>
          <target state="translated">Используя чистую схему аутентификации на основе пароля.Здесь пароль в виде чистого текста зашифровывается перед отправкой по сети.</target>
        </trans-unit>
        <trans-unit id="b61ea81dc7d1d41a9c00c2e18e56e9bb004eb512" translate="yes" xml:space="preserve">
          <source>Using a trace port significantly lowers the overhead imposed by using tracing.</source>
          <target state="translated">Использование порта трассировки значительно снижает накладные расходы,связанные с использованием трассировки.</target>
        </trans-unit>
        <trans-unit id="ef1a11e39ee5139ba5f2dcc235a18443f44a0583" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;Timeout&lt;/code&gt; less than the maximum time taken by the OS to establish an association (around 4.5 minutes if the default values from &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; are used), can result in inconsistent or incorrect return values. This is especially relevant for associations sharing the same &lt;code&gt;Socket&lt;/code&gt; (that is, source address and port), as the controlling process blocks until &lt;code&gt;connect/*&lt;/code&gt; returns. &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; provides an alternative without this limitation.</source>
          <target state="translated">Использование значения &lt;code&gt;Timeout&lt;/code&gt; меньше максимального времени, затрачиваемого ОС на установление связи (около 4,5 минут, если используются значения по умолчанию из &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; ), может привести к несогласованным или неправильным возвращаемым значениям. Это особенно актуально для ассоциаций, использующих один и тот же &lt;code&gt;Socket&lt;/code&gt; (то есть исходный адрес и порт), поскольку управляющий процесс блокируется до тех пор, пока не вернется &lt;code&gt;connect/*&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; предоставляет альтернативу без этого ограничения.</target>
        </trans-unit>
        <trans-unit id="5ba9ca7df52061ff3c5b19d7603144639874aa7f" translate="yes" xml:space="preserve">
          <source>Using behaviours also makes it easier to read and understand code written by other programmers. Improvised programming structures, while possibly more efficient, are always more difficult to understand.</source>
          <target state="translated">Использование поведения также облегчает чтение и понимание кода,написанного другими программистами.Импровизированные структуры программирования,хотя,возможно,и более эффективные,всегда сложнее понять.</target>
        </trans-unit>
        <trans-unit id="be49034820244435a044e90d7061836773df04c0" translate="yes" xml:space="preserve">
          <source>Using binaries is faster if more than a few bytes are returned.</source>
          <target state="translated">Использование двоичных файлов происходит быстрее,если возвращается больше,чем несколько байт.</target>
        </trans-unit>
        <trans-unit id="86c27bef1bf11875cf4524858dc2b5b6d1f57e8f" translate="yes" xml:space="preserve">
          <source>Using global names</source>
          <target state="translated">Использование глобальных имен</target>
        </trans-unit>
        <trans-unit id="83523a7442b26b6b81628c22227c3e6adc4deb1a" translate="yes" xml:space="preserve">
          <source>Using keyboard-interactive authentication. This is suitable for interactive authentication methods that do not need any special software support on the client side. Instead, all authentication data is entered from the keyboard.</source>
          <target state="translated">С помощью клавиатуры-интерактивной аутентификации.Подходит для интерактивных методов аутентификации,не требующих специальной программной поддержки на стороне клиента.Вместо этого все данные аутентификации вводятся с клавиатуры.</target>
        </trans-unit>
        <trans-unit id="1a390fb32c6eae4e12e20eb0d4d9a4b34d640e2f" translate="yes" xml:space="preserve">
          <source>Using one of the latter three requires good knowledge about the protocol and is not covered by this tutorial. See the SNMP, Inets, and Orber applications, respectively.</source>
          <target state="translated">Использование одной из последних трех требует хорошего знания протокола и не является предметом данного руководства.См.приложения SNMP,Inets и Orber соответственно.</target>
        </trans-unit>
        <trans-unit id="5809e3cc4f955b265b3823ad9d7e5a15c18140e7" translate="yes" xml:space="preserve">
          <source>Using public key technology. RSA and DSA, X509-certificates are not supported.</source>
          <target state="translated">Используя технологию открытых ключей.Сертификаты RSA и DSA,X509 не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="e0f94a2e35a5586c99778544bf1babebc9b68874" translate="yes" xml:space="preserve">
          <source>Using raw socket options requires detailed knowledge about the current operating system and TCP stack.</source>
          <target state="translated">Использование опций сырых сокетов требует детального знания текущей операционной системы и стека TCP.</target>
        </trans-unit>
        <trans-unit id="c43bcf358f1478cc031c03e30ad078b80a07cfdf" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;monitor&lt;/code&gt; параметров появления не допускается, это приводит к сбою функции по причине &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35f019fb91f46510f8e2ab9ec3e19f04bc02403c" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes this function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;monitor&lt;/code&gt; параметров &lt;code&gt;badarg&lt;/code&gt; не допускается, это приводит к сбою этой функции по причине badarg .</target>
        </trans-unit>
        <trans-unit id="5a580b4208da4e796317767a96b5a26cf22e6b99" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed. It causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;monitor&lt;/code&gt; опций возрождения запрещено. Это приводит к сбою функции по причине &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a9c674a9710324d1b88cb77d06f6cc4e6cfec2" translate="yes" xml:space="preserve">
          <source>Using state functions:</source>
          <target state="translated">Используя государственные функции:</target>
        </trans-unit>
        <trans-unit id="d6a2d079afcf63d89e623e699169fa524219390a" translate="yes" xml:space="preserve">
          <source>Using the &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator to delete an element from a list is not a performance problem:</source>
          <target state="translated">Использование оператора &amp;laquo; &lt;code&gt;--&lt;/code&gt; &amp;raquo; для удаления элемента из списка не является проблемой производительности:</target>
        </trans-unit>
        <trans-unit id="2b4f7382590545933da8c1a5ca844a0b2dbf266e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF, the size of the deep list can be calculated if sharing is ignored. It becomes the size of the list when it has been sent to another process or stored in an Ets table:</source>
          <target state="translated">Используя &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF, можно рассчитать размер глубокого списка, если совместное использование игнорируется. Он становится размером списка, когда он был отправлен другому процессу или сохранен в таблице Ets:</target>
        </trans-unit>
        <trans-unit id="f45d11e06ad9c8b5b97c2a1d3733d7810b2b6a1d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, it can be seen that the deep list only requires 22 words of heap space:</source>
          <target state="translated">Используя &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, можно увидеть, что для глубокого списка требуется только 22 слова в куче:</target>
        </trans-unit>
        <trans-unit id="69d1d8837258e11d9f37b8093e934034d0224323" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;match_object&lt;/code&gt; functions for traversing all table objects is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">Использование функций &lt;code&gt;match_object&lt;/code&gt; для обхода всех объектов таблицы более эффективно, чем вызов &lt;code&gt;first/1&lt;/code&gt; и &lt;code&gt;next/2&lt;/code&gt; или &lt;code&gt;slot/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88489091684544e2ce31ba031314c433818b9650" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;select&lt;/code&gt; functions for traversing all objects of a table is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">Использование функций &lt;code&gt;select&lt;/code&gt; для обхода всех объектов таблицы более эффективно, чем вызов &lt;code&gt;first/1&lt;/code&gt; и &lt;code&gt;next/2&lt;/code&gt; или &lt;code&gt;slot/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61a624a4dabba21043f9ab83195b8048f47a13d2" translate="yes" xml:space="preserve">
          <source>Using the &lt;strong&gt;Options&lt;/strong&gt; menu, you can set which areas to be displayed. By default, all areas except the Trace area are displayed.</source>
          <target state="translated">Используя меню &lt;strong&gt;опций&lt;/strong&gt; , вы можете установить, какие области будут отображаться. По умолчанию отображаются все области, кроме области трассировки.</target>
        </trans-unit>
        <trans-unit id="deaaf3fd831f16ebe5c78cc725732bfa850f0ae7" translate="yes" xml:space="preserve">
          <source>Using the BIFs &lt;code&gt;tuple_size/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; gives the compiler and the runtime system more opportunities for optimization. Another advantage is that the BIFs give Dialyzer more type information.</source>
          <target state="translated">Использование BIF &lt;code&gt;tuple_size/1&lt;/code&gt; и &lt;code&gt;byte_size/1&lt;/code&gt; дает компилятору и системе времени выполнения больше возможностей для оптимизации. Еще одно преимущество состоит в том, что BIF предоставляют Dialyzer больше информации о типе.</target>
        </trans-unit>
        <trans-unit id="5ffd8340dfb4e279ea5e33db1e4fc34776f3431f" translate="yes" xml:space="preserve">
          <source>Using the Erlang Port Mapper Daemon (EPMD)</source>
          <target state="translated">Использование даемона Erlang Port Mapper Daemon (EPMD)</target>
        </trans-unit>
        <trans-unit id="74a23b01b4aba69b50c3d95e7b04c3987e9060d6" translate="yes" xml:space="preserve">
          <source>Using the Kernel configuration parameters above, one can set default options for all TCP sockets on a node, but use this with care. Options such as &lt;code&gt;{delay_send,true}&lt;/code&gt; can be specified in this way. The following is an example of starting an Erlang node with all sockets using delayed send:</source>
          <target state="translated">Используя параметры конфигурации ядра выше, можно установить параметры по умолчанию для всех сокетов TCP на узле, но используйте это с осторожностью. Таким образом можно указать такие параметры, как &lt;code&gt;{delay_send,true}&lt;/code&gt; . Ниже приведен пример запуска узла Erlang со всеми сокетами с использованием отложенной отправки:</target>
        </trans-unit>
        <trans-unit id="c13013135bcccdcdbbd4af4075c0fbd41fe4a1df" translate="yes" xml:space="preserve">
          <source>Using the configuration variable as reference.</source>
          <target state="translated">Использование переменной конфигурации в качестве ориентира.</target>
        </trans-unit>
        <trans-unit id="6387e670864aedf383cf907c6d29480da77d049e" translate="yes" xml:space="preserve">
          <source>Using the erlc program, write like this</source>
          <target state="translated">Используя программу erlc,пишите так.</target>
        </trans-unit>
        <trans-unit id="48fe6335c37dc35de5485bc852958929b084eb85" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;broadcast&lt;/code&gt; becomes:</source>
          <target state="translated">Используя функцию &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;broadcast&lt;/code&gt; функции становится такой :</target>
        </trans-unit>
        <trans-unit id="3bd90c46e2dfc7b2e3d344d9519f155f341267df" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;print_list&lt;/code&gt; becomes:</source>
          <target state="translated">Используя функцию &lt;code&gt;foreach&lt;/code&gt; , функция &lt;code&gt;print_list&lt;/code&gt; становится:</target>
        </trans-unit>
        <trans-unit id="b09520015307c351db8684a091c45386c6ce9fb4" translate="yes" xml:space="preserve">
          <source>Using the monitor triggers in the call to &lt;code&gt;try_unload&lt;/code&gt; ensures that the monitor is added before the unloading is executed, meaning that the monitor is always properly triggered, which is not the case if &lt;code&gt;monitor/2&lt;/code&gt; is called separately.</source>
          <target state="translated">Использование триггеров монитора в вызове &lt;code&gt;try_unload&lt;/code&gt; гарантирует, что монитор добавляется до выполнения выгрузки, а это означает, что монитор всегда запускается правильно, чего не происходит, если &lt;code&gt;monitor/2&lt;/code&gt; вызывается отдельно.</target>
        </trans-unit>
        <trans-unit id="e7fa3b27587f43d236bfc06bb5036ddb2f4e6201" translate="yes" xml:space="preserve">
          <source>Using the registry</source>
          <target state="translated">Использование реестра</target>
        </trans-unit>
        <trans-unit id="ffb1c5489112873955c3175cf9ad9aba4db225d6" translate="yes" xml:space="preserve">
          <source>Using the same snapshots to calculate a total scheduler utilization:</source>
          <target state="translated">Использование одних и тех же снимков для расчета общей загрузки планировщика:</target>
        </trans-unit>
        <trans-unit id="a20644602b05608c2ad01e03c87f70e3ffe5b61d" translate="yes" xml:space="preserve">
          <source>Using the single time warp mode, the time offset is handled in two phases:</source>
          <target state="translated">В режиме одиночной искривления времени смещение времени обрабатывается в два этапа:</target>
        </trans-unit>
        <trans-unit id="8eee4ea386e884fcda7fe99030e661fbbf1aa947" translate="yes" xml:space="preserve">
          <source>Using the specific path &lt;code&gt;-group [sub121]&lt;/code&gt; or &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; gives the same result in this example.</source>
          <target state="translated">Использование определенного пути &lt;code&gt;-group [sub121]&lt;/code&gt; или &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; дает тот же результат в этом примере.</target>
        </trans-unit>
        <trans-unit id="5c52f9666d83bbf64ddaeeafc9ca31c5700aca1b" translate="yes" xml:space="preserve">
          <source>Using these facts, the two small circles in the picture below can be combined.</source>
          <target state="translated">Используя эти факты,можно совместить два маленьких круга на рисунке ниже.</target>
        </trans-unit>
        <trans-unit id="86aadd39c7dc4683cf62fc0ed24ee58375d7f5d3" translate="yes" xml:space="preserve">
          <source>Using transactions is a way to guarantee that the distributed Mnesia database remains consistent, even when many different processes update it in parallel. However, if you have real-time requirements it is recommended to use &lt;code&gt;dirty&lt;/code&gt; operations instead of transactions. When using &lt;code&gt;dirty&lt;/code&gt; operations, you lose the consistency guarantee; this is usually solved by only letting one process update the table. Other processes must send update requests to that process.</source>
          <target state="translated">Использование транзакций - это способ гарантировать, что распределенная база данных Mnesia остается согласованной, даже если множество различных процессов обновляют ее параллельно. Однако, если у вас есть требования к реальному времени, рекомендуется использовать &lt;code&gt;dirty&lt;/code&gt; операции вместо транзакций. При использовании &lt;code&gt;dirty&lt;/code&gt; операций вы теряете гарантию согласованности; обычно это решается путем разрешения обновлять таблицу только одному процессу. Другие процессы должны отправлять этому процессу запросы на обновление.</target>
        </trans-unit>
        <trans-unit id="2cb7bee577205f37d65f9821375accf63f59b42f" translate="yes" xml:space="preserve">
          <source>Usually a few managers communicate with many agents.</source>
          <target state="translated">Обычно несколько менеджеров общаются со многими агентами.</target>
        </trans-unit>
        <trans-unit id="cdaebc21aedbdaa85649f3457b904bb990d3b2ea" translate="yes" xml:space="preserve">
          <source>Usually a line is added that is to state:</source>
          <target state="translated">Обычно добавляется строка,которая должна состояться:</target>
        </trans-unit>
        <trans-unit id="f7c9ebf9950b5eb0782b3cd23c9a753ea0c5e533" translate="yes" xml:space="preserve">
          <source>Usually it suffices to detect time-outs on receive, as most protocols include some sort of acknowledgment from the server, but if the protocol is strictly one way, option &lt;code&gt;send_timeout&lt;/code&gt; comes in handy.</source>
          <target state="translated">Обычно достаточно обнаружить тайм-ауты при получении, поскольку большинство протоколов включают в себя какое-то подтверждение от сервера, но если протокол строго односторонний, &lt;code&gt;send_timeout&lt;/code&gt; опция send_timeout .</target>
        </trans-unit>
        <trans-unit id="72f960a27f294ee8a3a2af0d51fbe8531fe5bf1b" translate="yes" xml:space="preserve">
          <source>Usually one of &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;Application&quot;&lt;/code&gt; or &lt;code&gt;&quot;Security&quot;&lt;/code&gt;. Note that the NT eventlog viewer has another notion of category, which in most cases is totally meaningless and therefore not imported into Erlang. What is called a category here is one of the main three types of events occurring in a normal NT system.</source>
          <target state="translated">Обычно один из &lt;code&gt;&quot;System&quot;&lt;/code&gt; , &lt;code&gt;&quot;Application&quot;&lt;/code&gt; или &lt;code&gt;&quot;Security&quot;&lt;/code&gt; . Обратите внимание, что программа просмотра журнала событий NT имеет другое понятие категории, которое в большинстве случаев совершенно бессмысленно и поэтому не импортируется в Erlang. То, что здесь называется категорией, является одним из трех основных типов событий, происходящих в нормальной системе NT.</target>
        </trans-unit>
        <trans-unit id="eaa3a8b7b3a6f1f39061eab776dd864c04df5840" translate="yes" xml:space="preserve">
          <source>Usually, the entities defined in the MIB are called &lt;strong&gt;Managed Objects (MOs)&lt;/strong&gt;, although they do not have to be objects in the object-oriented way. For example, a simple scalar variable defined in a MIB is called an MO. The MOs are logical objects, not necessarily with a one-to-one mapping to the resources.</source>
          <target state="translated">Обычно объекты, определенные в MIB, называются &lt;strong&gt;управляемыми объектами (MO)&lt;/strong&gt; , хотя они не обязательно должны быть объектами объектно-ориентированным способом. Например, простая скалярная переменная, определенная в MIB, называется MO. MO являются логическими объектами, не обязательно с однозначным отображением ресурсов.</target>
        </trans-unit>
        <trans-unit id="34333d124dba7ee56119ecbb8915169706ed629f" translate="yes" xml:space="preserve">
          <source>Utility for reading and creating 'zip' archives.</source>
          <target state="translated">Утилита для чтения и создания 'zip' архивов.</target>
        </trans-unit>
        <trans-unit id="4587d8ae182b07cd6c5ddcc7013d5c9b99960884" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;BITS&lt;/code&gt; to &lt;code&gt;OCTET-STRING&lt;/code&gt;.</source>
          <target state="translated">Служебная функция для преобразования значения типа &lt;code&gt;BITS&lt;/code&gt; в &lt;code&gt;OCTET-STRING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e44844d0966f1f6069d31b91bf4a8abdb72b4d1" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;OCTET-STRING&lt;/code&gt; to &lt;code&gt;BITS&lt;/code&gt;.</source>
          <target state="translated">Служебная функция для преобразования значения типа &lt;code&gt;OCTET-STRING&lt;/code&gt; в &lt;code&gt;BITS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4388b46bdace9a8dd94930d061cd808992ffbdfc" translate="yes" xml:space="preserve">
          <source>Utility function that starts the applications &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;. Default type is &lt;code&gt;temporary&lt;/code&gt;. For more information, see the &lt;code&gt;application(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">Служебная функция, запускающая приложения &lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;public_key&lt;/code&gt; и &lt;code&gt;ssh&lt;/code&gt; . Тип по умолчанию - &lt;code&gt;temporary&lt;/code&gt; . Для получения дополнительной информации см. Справочную страницу &lt;code&gt;application(3)&lt;/code&gt; в ядре.</target>
        </trans-unit>
        <trans-unit id="4c7f90797d67794eeec5a51cfe794b557e3c3507" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formated printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions.</source>
          <target state="translated">Функция полезности для получения форматированной распечатки информации версии , порожденной &lt;code&gt;versions1&lt;/code&gt; и &lt;code&gt;versions2&lt;/code&gt; функций.</target>
        </trans-unit>
        <trans-unit id="0bbbc215beb617665e30c05f1df892f3ab385b7d" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions</source>
          <target state="translated">Служебная функция для создания форматированной распечатки информации о версиях, созданной функциями &lt;code&gt;versions1&lt;/code&gt; и &lt;code&gt;versions2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9ca3adcd5764dc7d65f56277bec220d9992d1f5" translate="yes" xml:space="preserve">
          <source>Utility function(s) to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; function</source>
          <target state="translated">Служебная функция (ы) для создания форматированной распечатки информации о версиях, созданной функцией &lt;code&gt;versions1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9d38534bb1763cd2ba3d18a6d7ecd6c0ae55401" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the agent config files.</source>
          <target state="translated">Функции утилиты для работы с файлами конфигурации агентов.</target>
        </trans-unit>
        <trans-unit id="2afa581e37f140ef78590e09404a9aae431c2390" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the manager config files.</source>
          <target state="translated">Функции утилиты для работы с конфигурационными файлами менеджера.</target>
        </trans-unit>
        <trans-unit id="6433ab0ec2c7394b801c26a999984771d7a0ae8b" translate="yes" xml:space="preserve">
          <source>Utility functions used to retrieve some system and application info.</source>
          <target state="translated">Функции утилиты,используемые для получения некоторой информации о системе и приложениях.</target>
        </trans-unit>
        <trans-unit id="aa9f46ccd3ba41c02d70b7e973f34c959fc38d56" translate="yes" xml:space="preserve">
          <source>VACM is described in detail in RFC2275. Here is only a brief description given.</source>
          <target state="translated">VACM подробно описан в RFC2275.Приведем лишь краткое описание.</target>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="translated">Vai</target>
        </trans-unit>
        <trans-unit id="c8a5c44daefed8fa60457df49456ebe3ace77f95" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BackupItems&lt;/code&gt; are the following tuples:</source>
          <target state="translated">Допустимые &lt;code&gt;BackupItems&lt;/code&gt; - это следующие кортежи:</target>
        </trans-unit>
        <trans-unit id="8f005ec226ccd5bd77580fd1619b366495013be6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BindType&lt;/code&gt;s:</source>
          <target state="translated">Действительный &lt;code&gt;BindType&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3768a7ccfdefa3ace61d00f77e188549db26cf0f" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;InfoTuple&lt;/code&gt;s with corresponding &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="translated">Допустимые &lt;code&gt;InfoTuple&lt;/code&gt; с соответствующими &lt;code&gt;Item&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc05afbe09b2e8c8117fcc39f7f35cc60250e0d4" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for functions:</source>
          <target state="translated">Допустимые &lt;code&gt;Item&lt;/code&gt; для функций:</target>
        </trans-unit>
        <trans-unit id="cf53d05dcad2f68d3d2da7de03839fc48e89fb6c" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for ports and processes:</source>
          <target state="translated">Допустимые &lt;code&gt;Item&lt;/code&gt; для портов и процессов:</target>
        </trans-unit>
        <trans-unit id="267195f93799c6c9557e8b18de85ebfc710db9e1" translate="yes" xml:space="preserve">
          <source>Valid Erlang expressions and guard sequences are described in &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Допустимые выражения Erlang и защитные последовательности описаны в &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b338a1ad5b1c7b18820779179ab41de826744b2b" translate="yes" xml:space="preserve">
          <source>Valid Return Values</source>
          <target state="translated">Valid Return Values</target>
        </trans-unit>
        <trans-unit id="efbf48a6212e82d31e363fa76b710eb93043cb0c" translate="yes" xml:space="preserve">
          <source>Valid categories are:</source>
          <target state="translated">Действующие категории:</target>
        </trans-unit>
        <trans-unit id="e1cdb0f6fd9b5c7ae6270cdbd6aa6489ff170a68" translate="yes" xml:space="preserve">
          <source>Valid limits are values in the range &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt;. Limits are automatically adjusted to be sane. That is, the system adjusts values so that the low limit used is lower than or equal to the high limit used. By default the high limit is 8 kB and the low limit is 4 kB.</source>
          <target state="translated">Допустимые пределы - это значения в диапазоне &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt; . Пределы автоматически корректируются до разумных. То есть система регулирует значения так, чтобы используемый нижний предел был ниже или равен используемому верхнему пределу. По умолчанию верхний предел составляет 8 кБ, а нижний предел - 4 кБ.</target>
        </trans-unit>
        <trans-unit id="ead2bf03d6fc68d606be1689e0611b409e03bb2a" translate="yes" xml:space="preserve">
          <source>Valid option:</source>
          <target state="translated">Действительный вариант:</target>
        </trans-unit>
        <trans-unit id="2c6356256194f4dacdd3ceac883fb104c7079f63" translate="yes" xml:space="preserve">
          <source>Valid options &lt;code&gt;set_options&lt;/code&gt; are:</source>
          <target state="translated">Допустимые параметры &lt;code&gt;set_options&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="850c962c3f063b586578621ee12bbb84d6f38bb7" translate="yes" xml:space="preserve">
          <source>Valid options:</source>
          <target state="translated">Действительные варианты:</target>
        </trans-unit>
        <trans-unit id="e4f1c0729761400496e047f8f256412e68cceee0" translate="yes" xml:space="preserve">
          <source>Valid return values</source>
          <target state="translated">Действительные возвращаемые значения</target>
        </trans-unit>
        <trans-unit id="1630b32c9530f31c96e521c8cf0ccc55338fbbc7" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;NodeType&lt;/code&gt;:</source>
          <target state="translated">Допустимые значения для &lt;code&gt;NodeType&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="82b8127698b8ef2cfa8edc57143af42260620903" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element (Element).</source>
          <target state="translated">Проверяет правильность разбора хорошо сформированного XML-элемента (Element).</target>
        </trans-unit>
        <trans-unit id="b239d15c1167b7afc50fb4ba90a070cafbcead1e" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element towards an XML schema.</source>
          <target state="translated">Проверяет правильность разбора хорошо сформированного XML-элемента по отношению к XML-схеме.</target>
        </trans-unit>
        <trans-unit id="30aa57af8387dd9dda72f74225d0c83ea7830682" translate="yes" xml:space="preserve">
          <source>Validates in two steps. First it processes the schema, saves the type and structure info in an ets table and then validates the element towards the schema.</source>
          <target state="translated">Проверяется в два этапа.Сначала он обрабатывает схему,сохраняет информацию о типе и структуре в таблице ets,а затем проверяет элемент по направлению к схеме.</target>
        </trans-unit>
        <trans-unit id="d81dc9238e6ae4be4cef7714f7fca70a30cc0272" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;default&lt;/code&gt; states that the predefined properties are to be used.</source>
          <target state="translated">Значение по &lt;code&gt;default&lt;/code&gt; указывает, что должны использоваться предопределенные свойства.</target>
        </trans-unit>
        <trans-unit id="8f4b4232752a2d39d8445512cde28d28668f7d1f" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;force&lt;/code&gt; means that a reparation is made even if the table is properly closed. This is a seldom needed option.</source>
          <target state="translated">Значение &lt;code&gt;force&lt;/code&gt; означает, что возмещение производится, даже если стол правильно закрыт. Это редко используемый вариант.</target>
        </trans-unit>
        <trans-unit id="9fbeacf98f8026e5fab1b1d01a773952a1337a76" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables burst control and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">Значение &lt;code&gt;true&lt;/code&gt; включает контроль пакетов, а &lt;code&gt;false&lt;/code&gt; - отключает.</target>
        </trans-unit>
        <trans-unit id="e3e5e9f151e03304f82baa34e7f4f70c22fcd0d8" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables the feature and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">Значение &lt;code&gt;true&lt;/code&gt; включает функцию, а &lt;code&gt;false&lt;/code&gt; - отключает.</target>
        </trans-unit>
        <trans-unit id="54db79fce832cc1178c718ad9c79945056373188" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;undefined&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt; (the argument list) is only to be used internally in &lt;code&gt;supervisor&lt;/code&gt;. If the restart type of the child is &lt;code&gt;temporary&lt;/code&gt;, the process is never to be restarted and therefore there is no need to store the real argument list. Value &lt;code&gt;undefined&lt;/code&gt; is then stored instead.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; значение для &lt;code&gt;A&lt;/code&gt; (список аргументов) должно использоваться только внутри &lt;code&gt;supervisor&lt;/code&gt; . Если тип перезапуска дочернего элемента является &lt;code&gt;temporary&lt;/code&gt; , процесс никогда не должен быть перезапущен, и поэтому нет необходимости хранить реальный список аргументов. Вместо этого сохраняется &lt;code&gt;undefined&lt;/code&gt; значение .</target>
        </trans-unit>
        <trans-unit id="b4c13cbe61dee9b68ffaef6134995ebd910fbd5e" translate="yes" xml:space="preserve">
          <source>Value = IOString | atom() | integer()</source>
          <target state="translated">Значение=IOString | atom()| integer()</target>
        </trans-unit>
        <trans-unit id="1bbca064dbc2becbd7d3555273dcd4ac5b367fab" translate="yes" xml:space="preserve">
          <source>Value of a configuration parameter.</source>
          <target state="translated">Значение параметра конфигурации.</target>
        </trans-unit>
        <trans-unit id="384e64d4c66abb9cfb384072bb26c3dd0bab6612" translate="yes" xml:space="preserve">
          <source>Value to convert time unit for.</source>
          <target state="translated">Значение для преобразования единицы времени.</target>
        </trans-unit>
        <trans-unit id="768d2b954af31866b6e32d7a85e19622323f08f3" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;atom()&lt;/code&gt;</source>
          <target state="translated">Значение: &lt;code&gt;atom()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97045cfdad33dd3dba2b9ed63a6c87874f526b4d" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">Значение: &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a052394fb5d5289ec24690454284914e11a61275" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;integer()&lt;/code&gt;</source>
          <target state="translated">Значение: &lt;code&gt;integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="813cf4fbeafa5124c59029940c3b8ba23a170cb6" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;on | off&lt;/code&gt;</source>
          <target state="translated">Значение: включено &lt;code&gt;on | off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65c8d38d0b9fb94d17867d4881ce4e1d9d89030a" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</source>
          <target state="translated">Значение: &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6970e248833158e8e073b58247bd68dcfc9cbf85" translate="yes" xml:space="preserve">
          <source>Values can be assigned in Erlang as follows:</source>
          <target state="translated">Значения в Эрланге могут быть назначены следующим образом:</target>
        </trans-unit>
        <trans-unit id="2cb45cee19fe1842c7fe4075c27f3b1076ddd053" translate="yes" xml:space="preserve">
          <source>Values can be assigned to an ASN.1 type within the ASN.1 code itself, as opposed to the actions in the previous section where a value was assigned to an ASN.1 type in Erlang. The full value syntax of ASN.1 is supported and X.680 describes in detail how to assign values in ASN.1. A short example:</source>
          <target state="translated">Значения могут быть назначены типу ASN.1 в самом коде ASN.1,в отличие от действий,описанных в предыдущем разделе,где значение было назначено типу ASN.1 в Erlang.Поддерживается синтаксис полного значения в ASN.1,и X.680 подробно описывает,как назначать значения в ASN.1.Краткий пример:</target>
        </trans-unit>
        <trans-unit id="0cebf5af2c916d50162daf2371942434d298c322" translate="yes" xml:space="preserve">
          <source>Values corresponding to the R(equest), P(roxiable), E(rror) and T(Potentially re-transmitted message) flags of the Diameter header.</source>
          <target state="translated">Значения,соответствующие флагам R(equest),P(roxiable),E(rror)и T(Potentially re-transmitted message)заголовка Diameter.</target>
        </trans-unit>
        <trans-unit id="96ef06f93f26e99ce4292fa7f5fd3f23d636c4eb" translate="yes" xml:space="preserve">
          <source>Values in the AVP header, corresponding to AVP Code, the M flag, P flags and Vendor-ID respectively. A Vendor-ID other than &lt;code&gt;undefined&lt;/code&gt; implies a set V flag.</source>
          <target state="translated">Значения в заголовке AVP, соответствующие коду AVP, флагу M, флагам P и идентификатору поставщика соответственно. Идентификатор поставщика, отличный от &lt;code&gt;undefined&lt;/code&gt; , подразумевает установленный флаг V.</target>
        </trans-unit>
        <trans-unit id="a0444f2cacebf8b2705dc3aa6c687df85244bfd3" translate="yes" xml:space="preserve">
          <source>Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-to-End Identifier fields of the Diameter header.</source>
          <target state="translated">Значения полей Версии,Длина сообщения,Командный код,Идентификатор приложения,Идентификатор хопа по хопу и Идентификатор завершения в заголовке Диаметра.</target>
        </trans-unit>
        <trans-unit id="25b7b3117ec67f563a385f6a6bbb3fc464310423" translate="yes" xml:space="preserve">
          <source>Values of these types are not currently parsed by diameter.</source>
          <target state="translated">Значения этих типов в настоящее время не анализируются по диаметрам.</target>
        </trans-unit>
        <trans-unit id="d14186fcac41fa3af58224092399d938dd7267c2" translate="yes" xml:space="preserve">
          <source>Values of this type can be assigned a value as an ordinary string as follows:</source>
          <target state="translated">Значения этого типа могут быть присвоены в виде обычной строки следующим образом:</target>
        </trans-unit>
        <trans-unit id="297576f454c4d00030676aa9862a2b6c6efbd141" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;Emb&lt;/code&gt; can be assigned as follows:</source>
          <target state="translated">Значения типа &lt;code&gt;Emb&lt;/code&gt; можно присвоить следующим образом:</target>
        </trans-unit>
        <trans-unit id="cee70396c85e9d16e65df42fd317982706258e73" translate="yes" xml:space="preserve">
          <source>Variable ::= - same as Erlang variables -</source>
          <target state="translated">Переменная ::=-то же самое,что и переменные Эрланга -</target>
        </trans-unit>
        <trans-unit id="748e5ba4cc296f39b4935e55b1705fc8ee581ce2" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;A&lt;/code&gt; is bound to the evaluated value of the list comprehension (&lt;code&gt;[1,2]&lt;/code&gt;). The compiler complains with an error message (&quot;argument is not a query list comprehension&quot;); the shell process stops with a &lt;code&gt;badarg&lt;/code&gt; reason.</source>
          <target state="translated">Переменная &lt;code&gt;A&lt;/code&gt; связана с оцененным значением понимания списка ( &lt;code&gt;[1,2]&lt;/code&gt; ). Компилятор выдает сообщение об ошибке (&amp;laquo;аргумент не является пониманием списка запросов&amp;raquo;); процесс оболочки останавливается по причине &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a90e8a96c62ffb5d1cd6f65922e2fc9c80f1799" translate="yes" xml:space="preserve">
          <source>Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused.</source>
          <target state="translated">Сохраняются привязки переменных,а также изменения в словаре локального процесса,которые генерируются в пользовательских выражениях,и переменные могут быть использованы в последующих командах для доступа к их значениям.Связки также можно забыть,чтобы переменные могли быть использованы повторно.</target>
        </trans-unit>
        <trans-unit id="d0a8ee25c863aa2419107fceb204e47f57f1db36" translate="yes" xml:space="preserve">
          <source>Variable key length from 32 bits up to 448 bits</source>
          <target state="translated">Переменная длина ключа от 32 бит до 448 бит</target>
        </trans-unit>
        <trans-unit id="bfc036b2b9309c7bdc08e56f286b100a63accced" translate="yes" xml:space="preserve">
          <source>Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</source>
          <target state="translated">Переменная длина ключа от 8 бит до 2048 бит (обычно от 40 до 256).</target>
        </trans-unit>
        <trans-unit id="98c3d8899ac90eda2399d72ac989d5a5b85bf50c" translate="yes" xml:space="preserve">
          <source>Variables are bound to values through the &lt;strong&gt;pattern matching&lt;/strong&gt; mechanism. Pattern matching occurs when evaluating a function call, &lt;code&gt;case&lt;/code&gt;- &lt;code&gt;receive&lt;/code&gt;- &lt;code&gt;try&lt;/code&gt;- expressions and match operator (=) expressions.</source>
          <target state="translated">Переменные привязываются к значениям с помощью механизма &lt;strong&gt;сопоставления с образцом&lt;/strong&gt; . Сопоставление с образцом происходит при оценке вызова функции, выражений &lt;code&gt;case&lt;/code&gt; - &lt;code&gt;receive&lt;/code&gt; - &lt;code&gt;try&lt;/code&gt; и операторов сопоставления (=).</target>
        </trans-unit>
        <trans-unit id="2184e01d1f22737f67295ee5c99577b7f02640c4" translate="yes" xml:space="preserve">
          <source>Variables are bound to values using &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt;. Erlang uses &lt;strong&gt;single assignment&lt;/strong&gt;, that is, a variable can only be bound once.</source>
          <target state="translated">Переменные привязываются к значениям с использованием &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt; . Erlang использует &lt;strong&gt;однократное присваивание&lt;/strong&gt; , то есть переменную можно привязать только один раз.</target>
        </trans-unit>
        <trans-unit id="af1686696b0da48d910d4a99c77d1e302b425bc7" translate="yes" xml:space="preserve">
          <source>Variables can also be used to improve the readability of programs. For example, in function &lt;code&gt;list_max/2&lt;/code&gt; above, you can write:</source>
          <target state="translated">Переменные также можно использовать для улучшения читабельности программ. Например, в функции &lt;code&gt;list_max/2&lt;/code&gt; выше вы можете написать:</target>
        </trans-unit>
        <trans-unit id="e040ee86e634cf4aa0be3ce9492a2d6be860d5dc" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a fun.</source>
          <target state="translated">Переменные нельзя экспортировать из забавы.</target>
        </trans-unit>
        <trans-unit id="9c57858e4cc8b9cf7467d2261e8b3c42734717f8" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a list comprehension.</source>
          <target state="translated">Переменные не могут быть экспортированы из понимания списка.</target>
        </trans-unit>
        <trans-unit id="f8d2854195ed04278e5b7b15a33240c69501a326" translate="yes" xml:space="preserve">
          <source>Variables exported from &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">Переменные, экспортированные из &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;case&lt;/code&gt; / &lt;code&gt;receive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5eb952951e49a9b2fcfc380fe82f3b23f85123e9" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that the following works:</source>
          <target state="translated">Переменные из окружающей среды можно импортировать,чтобы работали следующие:</target>
        </trans-unit>
        <trans-unit id="ed92f2d37abdcb00aafc2e8c807cfc991b6f8842" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that this works:</source>
          <target state="translated">Переменные из среды можно импортировать,чтобы это работало:</target>
        </trans-unit>
        <trans-unit id="e88c0b53ad71637f25dfbd793cc2441d427e3881" translate="yes" xml:space="preserve">
          <source>Variables imported into matches</source>
          <target state="translated">Переменные,импортируемые в спички</target>
        </trans-unit>
        <trans-unit id="1b2ab1f9eb238cbc2cccee8878b2d4f07a335e18" translate="yes" xml:space="preserve">
          <source>Variables in a fun head shadow the function name and both shadow variables in the function clause surrounding the fun expression. Variables bound in a fun body are local to the fun body.</source>
          <target state="translated">Переменные в тени веселой головы имя функции и обе теневые переменные в пункте функции,окружающем выражение веселости.Переменные,связанные в теле веселья,локальны к телу веселья.</target>
        </trans-unit>
        <trans-unit id="18d218f35a2e3577a6c500538445abcceb060b64" translate="yes" xml:space="preserve">
          <source>Variables in this section are only used, when configuring Erlang/OTP for cross compilation using &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt;.</source>
          <target state="translated">Переменные в этом разделе используются только при настройке Erlang / OTP для кросс-компиляции с помощью &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08df3acc57d3675cf908a2f26030ccd4ae2beb38" translate="yes" xml:space="preserve">
          <source>Variables occurring in the head of the fun are replaced by match specification variables in the order of occurrence, so that fragment &lt;code&gt;fun({A,B,C})&lt;/code&gt; is replaced by &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt;, and so on. Every occurrence of such a variable in the match specification is replaced by a match specification variable in the same way, so that the fun &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; is translated into &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt;.</source>
          <target state="translated">Переменные, встречающиеся в заголовке развлечения, заменяются переменными спецификации соответствия в порядке появления, так что фрагментное &lt;code&gt;fun({A,B,C})&lt;/code&gt; заменяется на &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt; , и так далее. Каждое вхождение такой переменной в спецификации соответствия заменяется переменной спецификации соответствия таким же образом, так что забавное &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; переводится в &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0ae0e8be972f79e65125dff2b6c4f9cdfb890f0" translate="yes" xml:space="preserve">
          <source>Variables of type &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; can refer to any Erlang term. This is an opaque type and values of it can only by used either as arguments to API functions or as return values from NIFs. All &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;s belong to an environment (&lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt;). A term cannot be destructed individually, it is valid until its environment is destructed.</source>
          <target state="translated">Переменные типа &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; могут ссылаться на любой термин Erlang. Это непрозрачный тип, и его значения могут использоваться только как аргументы для функций API или как возвращаемые значения из NIF. Все &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; принадлежат среде ( &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt; ). Термин не может быть разрушен индивидуально, он действителен до тех пор, пока не будет разрушена его среда.</target>
        </trans-unit>
        <trans-unit id="debd1f76422a0d8de3199d01bf29f5e66c2af413" translate="yes" xml:space="preserve">
          <source>Variables shadowed in funs and list comprehensions</source>
          <target state="translated">Переменные,затененные весельем и понятиями списка</target>
        </trans-unit>
        <trans-unit id="d19ebfb8e1f3e97056afbbe53540cc96bcfb11ed" translate="yes" xml:space="preserve">
          <source>Variables start with an uppercase letter or underscore (_). Variables can contain alphanumeric characters, underscore and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">Переменные начинаются с заглавной буквы или символа подчеркивания (_). Переменные могут содержать буквенно-цифровые символы, подчеркивание и &lt;code&gt;@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09f862d436d21532b455bff8e767c989deff6bc5" translate="yes" xml:space="preserve">
          <source>Variables starting with &lt;code&gt;_@&lt;/code&gt;, for example &lt;code&gt;_@bar&lt;/code&gt; or &lt;code&gt;_@Bar&lt;/code&gt;</source>
          <target state="translated">Переменные, начинающиеся с &lt;code&gt;_@&lt;/code&gt; , например &lt;code&gt;_@bar&lt;/code&gt; или &lt;code&gt;_@Bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1225854353b77d49f7cc40d13247de7c80827209" translate="yes" xml:space="preserve">
          <source>Variables starting with underscore (_), for example, &lt;code&gt;_Height&lt;/code&gt;, are normal variables, not anonymous. They are however ignored by the compiler in the sense that they do not generate any warnings for unused variables.</source>
          <target state="translated">Переменные, начинающиеся с подчеркивания (_), например &lt;code&gt;_Height&lt;/code&gt; , являются обычными переменными, а не анонимными. Однако они игнорируются компилятором в том смысле, что они не генерируют никаких предупреждений для неиспользуемых переменных.</target>
        </trans-unit>
        <trans-unit id="024d797490e6edf809ed5b6c2e34f4bc4f3bebd1" translate="yes" xml:space="preserve">
          <source>Variables take the form &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt;, where &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; is an integer between 0 and 100,000,000 (1e+8). The behavior if the number is outside these limits is &lt;strong&gt;undefined&lt;/strong&gt;. In the &lt;code&gt;MatchHead&lt;/code&gt; part, the special variable &lt;code&gt;'_'&lt;/code&gt; matches anything, and never gets bound (like &lt;code&gt;_&lt;/code&gt; in Erlang).</source>
          <target state="translated">Переменные имеют вид &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; , где &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; - целое число от 0 до 100 000 000 (1e + 8). Поведение, если число выходит за эти пределы, не &lt;strong&gt;определено&lt;/strong&gt; . В части &lt;code&gt;MatchHead&lt;/code&gt; специальная переменная &lt;code&gt;'_'&lt;/code&gt; соответствует чему угодно и никогда не связывается (как &lt;code&gt;_&lt;/code&gt; в Erlang).</target>
        </trans-unit>
        <trans-unit id="00bf9ad78f5cec1dd65d66ced1104921a78f995a" translate="yes" xml:space="preserve">
          <source>Variables that are defined before the fun, and that occur in function calls or guard tests within the fun, have the values they had outside the fun.</source>
          <target state="translated">Переменные,которые определяются перед весельем,и которые происходят в вызовах функций или тестах защиты внутри веселья,имеют значения,которые они имели вне веселья.</target>
        </trans-unit>
        <trans-unit id="bf0dcb58581abd4fe80849d394380c5cd405dc3e" translate="yes" xml:space="preserve">
          <source>Variables that are not included in the head are imported from the environment and made into match specification &lt;code&gt;const&lt;/code&gt; expressions. Example from the shell:</source>
          <target state="translated">Переменные, которые не включены в заголовок, импортируются из среды и преобразуются в &lt;code&gt;const&lt;/code&gt; выражения спецификации соответствия . Пример из оболочки:</target>
        </trans-unit>
        <trans-unit id="55df9f3ef32c412357dbc3a18bd56c7d4ce619de" translate="yes" xml:space="preserve">
          <source>Variance :: number(),</source>
          <target state="translated">Variance ::number(),</target>
        </trans-unit>
        <trans-unit id="0e31c4461c806559eaf12528c8fe9a9d293a746d" translate="yes" xml:space="preserve">
          <source>Various &quot;isolate&quot;s</source>
          <target state="translated">различные &quot;изолированные&quot;</target>
        </trans-unit>
        <trans-unit id="a1d64fcf9bb61fad40e3871e66b33e563f5b1f28" translate="yes" xml:space="preserve">
          <source>Various Erlang net administration routines.</source>
          <target state="translated">Различные процедуры администрирования сети Эрланг.</target>
        </trans-unit>
        <trans-unit id="f6b924712003f40d3f2878b1cac363cf1976078c" translate="yes" xml:space="preserve">
          <source>Vendor-Id AVP</source>
          <target state="translated">Vendor-Id AVP</target>
        </trans-unit>
        <trans-unit id="48eb606505901d94f78b31e43f73e095bdf04786" translate="yes" xml:space="preserve">
          <source>Vendor-Specific-Application-Id AVP</source>
          <target state="translated">AVP-специфические приложения для конкретного поставщика</target>
        </trans-unit>
        <trans-unit id="e96f73110a27dcecf42e3942850fdb9a84214cad" translate="yes" xml:space="preserve">
          <source>Verbose = &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">Verbose = &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="adb0c527629b97acddda692f399e9ccb978796eb" translate="yes" xml:space="preserve">
          <source>Verbosity for a SNMP process. This specifies now much debug info is printed.</source>
          <target state="translated">Тяжеловесность для процесса SNMP.Это указывает на то,что теперь будет напечатано много отладочной информации.</target>
        </trans-unit>
        <trans-unit id="fee450697a5689ff92f9f50edecbf9c5c91da171" translate="yes" xml:space="preserve">
          <source>Verifies PKIX x.509 certificate signature.</source>
          <target state="translated">Проверяет подпись сертификата PKIX x.509.</target>
        </trans-unit>
        <trans-unit id="4326ee1947d5233b0586b451628ad661e97a0e04" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature</source>
          <target state="translated">Проверяет цифровую подпись</target>
        </trans-unit>
        <trans-unit id="d9ade396ed77dbd522a02203fe6942326134914f" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature.</source>
          <target state="translated">Проверяет цифровую подпись.</target>
        </trans-unit>
        <trans-unit id="b9525ebe014b53689fa4e11b528180aae4abeb4b" translate="yes" xml:space="preserve">
          <source>Verifies that the current location of the execution is visible in the code area.</source>
          <target state="translated">Убедитесь,что текущее место выполнения видно в области кода.</target>
        </trans-unit>
        <trans-unit id="1dc4741dffd06fe660bc6cd57000623888541a03" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;Cert&lt;/code&gt; is the &lt;code&gt;CRL&lt;/code&gt; signer.</source>
          <target state="translated">Убедитесь в том, что &lt;code&gt;Cert&lt;/code&gt; является &lt;code&gt;CRL&lt;/code&gt; подписавшего.</target>
        </trans-unit>
        <trans-unit id="d5417e5a99f86d22c5664ec343d3a6c2609ec65a" translate="yes" xml:space="preserve">
          <source>Version 1.6.10 or later of the &lt;strong&gt;asn1&lt;/strong&gt; application.</source>
          <target state="translated">Версия 1.6.10 или &lt;strong&gt;новее&lt;/strong&gt; приложения &lt;strong&gt;asn1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a661417de642bc6b468d76fe5b3c6bc8775de7ac" translate="yes" xml:space="preserve">
          <source>Version 3.11 or later of &lt;strong&gt;this&lt;/strong&gt; application.</source>
          <target state="translated">Версия 3.11 или новее &lt;strong&gt;этого&lt;/strong&gt; приложения.</target>
        </trans-unit>
        <trans-unit id="56e5ca082097444de77af1c9fd7d0a5134aed383" translate="yes" xml:space="preserve">
          <source>Version management is enabled for drivers that have set the &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; field of their &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;. &lt;code&gt;erl_driver.h&lt;/code&gt; defines:</source>
          <target state="translated">Управление &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; включено для драйверов, которые установили поле &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; в записи_драйвера на &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; . &lt;code&gt;erl_driver.h&lt;/code&gt; определяет:</target>
        </trans-unit>
        <trans-unit id="21b8714f6e355164babd4f77276d9b70c8b55f19" translate="yes" xml:space="preserve">
          <source>Version numbers in general are only partially ordered. However, normal version numbers (with three parts) as of OTP 17.0 have a total or linear order. This applies both to normal OTP versions and normal application versions.</source>
          <target state="translated">Номера версий в целом заказываются только частично.Однако,обычные номера версий (с тремя частями),начиная с OTP 17.0,имеют полный или линейный порядок.Это относится как к обычным версиям OTP,так и к обычным версиям приложения.</target>
        </trans-unit>
        <trans-unit id="e126978ac6222c855c920d79411bed5cf12c2966" translate="yes" xml:space="preserve">
          <source>Version of an application included in the release.</source>
          <target state="translated">Версия приложения,включенная в релиз.</target>
        </trans-unit>
        <trans-unit id="473be10b81925976c7e4903e9b43ac593c8ae1c5" translate="yes" xml:space="preserve">
          <source>Version of the application.</source>
          <target state="translated">Версия приложения.</target>
        </trans-unit>
        <trans-unit id="9a7876f7a0f780d649e426501cf895ebbd7b0903" translate="yes" xml:space="preserve">
          <source>Vertical bar characters are used to separate alternative patterns. For example, the following pattern matches either &quot;gilbert&quot; or &quot;sullivan&quot;:</source>
          <target state="translated">Символы вертикальных полос используются для разделения альтернативных шаблонов.Например,следующая деталь соответствует либо &quot;gilbert&quot;,либо &quot;sullivan&quot;:</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">Вертикальная вкладка</target>
        </trans-unit>
        <trans-unit id="5fd82a7e8d422aaa4b53ae82c82d9414739c27a0" translate="yes" xml:space="preserve">
          <source>Vertical tab (VT)</source>
          <target state="translated">Вертикальная вкладка (VT)</target>
        </trans-unit>
        <trans-unit id="089b74a153ec7d14e48cc1b72fe57aef02d54503" translate="yes" xml:space="preserve">
          <source>Vertical tab.</source>
          <target state="translated">Вертикальная вкладка.</target>
        </trans-unit>
        <trans-unit id="29e9914d64c8384c209127eaf16006134a978f22" translate="yes" xml:space="preserve">
          <source>Very similar to &lt;code&gt;portTypeAcceptor&lt;/code&gt;, an intermediate stage between the request for a connect operation and that the socket is connected to an accepting ditto in the other end. When the sockets are connected, the port switches type to &lt;code&gt;portTypeCommand&lt;/code&gt;.</source>
          <target state="translated">Очень похоже на &lt;code&gt;portTypeAcceptor&lt;/code&gt; , промежуточный этап между запросом операции подключения и тем, что сокет подключен к принимающему то же самое на другом конце. Когда сокеты подключены, тип порта переключается на &lt;code&gt;portTypeCommand&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e64e0bec8b57844c72ad51fbe4f769f2b726868" translate="yes" xml:space="preserve">
          <source>Viewer menu:</source>
          <target state="translated">Меню просмотра:</target>
        </trans-unit>
        <trans-unit id="a76c37f0a0334ff643407ad5eae8341e4157dd19" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 (Visual Studio 12.0). Download and run the web installer from:</source>
          <target state="translated">Visual Studio 2013 (Visual Studio 12.0).Скачать и запустить веб-инсталлятор:</target>
        </trans-unit>
        <trans-unit id="c915e18af7a75d3dbbd7d92286c7e2d9ac312998" translate="yes" xml:space="preserve">
          <source>Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; starts the Erlang Windows shell.</source>
          <target state="translated">Вуаля! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; запускает оболочку Erlang Windows.</target>
        </trans-unit>
        <trans-unit id="716dd3292ee085b4712046407eb276268b149ea2" translate="yes" xml:space="preserve">
          <source>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt;, except that &lt;code&gt;yield()&lt;/code&gt; is faster.</source>
          <target state="translated">Добровольно позволяет другим процессам (если таковые имеются) получить возможность выполняться. Использование этой функции похоже на &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt; , за исключением того, что &lt;code&gt;yield()&lt;/code&gt; работает быстрее.</target>
        </trans-unit>
        <trans-unit id="5ebf20f8d1333c6ed323b151df8d0b75baeab5a0" translate="yes" xml:space="preserve">
          <source>Wait for an ack.</source>
          <target state="translated">Подожди.</target>
        </trans-unit>
        <trans-unit id="4d14f3abfec373cbe89f6626aa814e6ca203b696" translate="yes" xml:space="preserve">
          <source>Wait for reply after having received a pending message.</source>
          <target state="translated">Дождитесь ответа после получения ожидающего ответа.</target>
        </trans-unit>
        <trans-unit id="03a3dd1877c6b650ce26278dad8e2fb191a587d5" translate="yes" xml:space="preserve">
          <source>Wait for reply.</source>
          <target state="translated">Ждите ответа.</target>
        </trans-unit>
        <trans-unit id="2c5a9ccfb857e48896b332926f19499a3bf34466" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive...after&lt;/code&gt;.</source>
          <target state="translated">Ожидание &lt;code&gt;receive...after&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e59facfb286b560b3bd7e76028f43e2127a06c" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">Ожидание &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3d6ef3cb84dde159db4dc284cfdc308ccef71dd" translate="yes" xml:space="preserve">
          <source>Waiting. This state is currently only identified on Solaris.</source>
          <target state="translated">Жду.В настоящее время это состояние идентифицировано только на Соларисе.</target>
        </trans-unit>
        <trans-unit id="7c806137ff16518173274ba603d62ffafc3bdf63" translate="yes" xml:space="preserve">
          <source>Waits for a reply.</source>
          <target state="translated">Ждет ответа.</target>
        </trans-unit>
        <trans-unit id="bd2ac24407b3f1c35309d00d94c7cf3be1ef6a8a" translate="yes" xml:space="preserve">
          <source>Waits on a condition variable. The calling thread is blocked until another thread wakes it by signaling or broadcasting on the condition variable. Before the calling thread is blocked, it unlocks the mutex passed as argument. When the calling thread is woken, it locks the same mutex before returning. That is, the mutex currently must be locked by the calling thread when calling this function.</source>
          <target state="translated">Ждет переменной состояния.Вызовной поток блокируется до тех пор,пока другой поток не разбудит его сигналом или трансляцией на переменной состояния.Перед тем,как вызывающий поток заблокируется,он разблокирует мьютекс,переданный в качестве аргумента.Когда вызывающий поток пробуждается,он блокирует этот же мьютекс перед возвращением.То есть,при вызове этой функции мьютекс в данный момент должен быть заблокирован вызывающим потоком.</target>
        </trans-unit>
        <trans-unit id="ab9651595cb08f88e44fd940126d1c71dd69f853" translate="yes" xml:space="preserve">
          <source>Waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt;.</source>
          <target state="translated">Ожидает, пока данные не будут зафиксированы и записаны на диск (если диск используется) на каждом задействованном узле, прежде чем &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt; , в противном случае он ведет себя как mnesia: transaction / [1,2,3] .</target>
        </trans-unit>
        <trans-unit id="7d95099fabbff08dd069c5c4ee916cb8f9b1a506" translate="yes" xml:space="preserve">
          <source>Wallclock_Time_Since_Last_Call}</source>
          <target state="translated">Wallclock_Time_Since_Last_Call}</target>
        </trans-unit>
        <trans-unit id="c3b288f7da975708a0f5e331c0f162ed064cf7c2" translate="yes" xml:space="preserve">
          <source>Warang_Citi</source>
          <target state="translated">Warang_Citi</target>
        </trans-unit>
        <trans-unit id="73cea05d9ab0a2033c2e880c88d16336c1ad4134" translate="yes" xml:space="preserve">
          <source>Warn about overspecified functions (the specification is strictly less allowing than the success typing).</source>
          <target state="translated">Предупреждать о переопределенных функциях (спецификация строго менее допустима,чем успешный набор).</target>
        </trans-unit>
        <trans-unit id="09d2b974a5e842f51243b3499495df6bdd13bcaa" translate="yes" xml:space="preserve">
          <source>Warn about underspecified functions (the specification is strictly more allowing than the success typing).</source>
          <target state="translated">Предупреждать о неуказанных функциях (спецификация строго более допустима,чем успешный набор).</target>
        </trans-unit>
        <trans-unit id="6cccd5dcb30984a83e1ff196e1800d93a16fd24a" translate="yes" xml:space="preserve">
          <source>Warn when the specification is different than the success typing.</source>
          <target state="translated">Предупреждать,когда спецификация отличается от успешной печати.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="83bd22f6ddfb4c6af6ec49ac28fc7020e55db1cb" translate="yes" xml:space="preserve">
          <source>Warning events were introduced in Erlang/OTP R9C and are enabled by default as from Erlang/OTP 18.0. To retain backwards compatibility with existing user-defined event handlers, the warning events can be tagged as &lt;code&gt;errors&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt; using command-line flag &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt;, thus showing up as &lt;code&gt;ERROR REPORT&lt;/code&gt; or &lt;code&gt;INFO REPORT&lt;/code&gt; in the logs.</source>
          <target state="translated">Предупреждающие события были введены в Erlang / OTP R9C и включены по умолчанию, начиная с Erlang / OTP 18.0. Чтобы сохранить обратную совместимость с существующими пользовательскими обработчиками событий, предупреждающие события могут быть помечены как &lt;code&gt;errors&lt;/code&gt; или &lt;code&gt;info&lt;/code&gt; с помощью флага командной строки &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt; , таким образом, отображаясь в журналах как &lt;code&gt;ERROR REPORT&lt;/code&gt; &lt;code&gt;INFO REPORT&lt;/code&gt; или ИНФОРМАЦИОННЫЙ ОТЧЕТ .</target>
        </trans-unit>
        <trans-unit id="6c71f2eab8af60b63ce0e407c87968c7af135f73" translate="yes" xml:space="preserve">
          <source>Warning option &lt;code&gt;-Wrace_conditions&lt;/code&gt; has no effect when set in source files.</source>
          <target state="translated">&lt;code&gt;-Wrace_conditions&lt;/code&gt; предупреждения -Wrace_conditions не действует, если задан в исходных файлах.</target>
        </trans-unit>
        <trans-unit id="b855954419a97257855c46e228014ea8104ff80a" translate="yes" xml:space="preserve">
          <source>Warning options can be restricted to functions:</source>
          <target state="translated">Опции предупреждения могут быть ограничены функциями:</target>
        </trans-unit>
        <trans-unit id="350f98fe7365f5591c6175d100ed10f345354502" translate="yes" xml:space="preserve">
          <source>Warning: you wanted to visit the site www.example.com, but the certificate is for shop.example.com. Accept anyway (yes/no)?&quot;</source>
          <target state="translated">Предупреждение:вы хотели посетить сайт www.example.com,но сертификат выдан для сайта shop.example.com.Согласны ли вы (да/нет)?&quot;.</target>
        </trans-unit>
        <trans-unit id="bfa481bc1014e68bf8d7481ee0ba5e89fda097c2" translate="yes" xml:space="preserve">
          <source>We add &lt;code&gt;-heart&lt;/code&gt; to &lt;code&gt;bin/start&lt;/code&gt;:</source>
          <target state="translated">Добавим &lt;code&gt;-heart&lt;/code&gt; в &lt;code&gt;bin/start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="73b280a7b7aba8731e641abebde7cc0face25615" translate="yes" xml:space="preserve">
          <source>We already have the data as (Unicode) lists and therefore only split the list in runs of a predefined size and put each run in the table at the current position (and forward). Functions &lt;code&gt;split_data/3&lt;/code&gt; and &lt;code&gt;apply_update/2&lt;/code&gt; are implemented below.</source>
          <target state="translated">У нас уже есть данные в виде списков (Unicode), поэтому мы разбиваем список только на прогоны заранее определенного размера и помещаем каждый прогон в таблицу в текущую позицию (и далее). Функции &lt;code&gt;split_data/3&lt;/code&gt; и &lt;code&gt;apply_update/2&lt;/code&gt; реализованы ниже.</target>
        </trans-unit>
        <trans-unit id="5226f0d44c399be112d6e2c67714235696a1e7cd" translate="yes" xml:space="preserve">
          <source>We also see that the call to &lt;code&gt;file:write/2&lt;/code&gt; that writes 1/4 of the file contents takes very little time in itself. What takes time is to build the data (&lt;code&gt;lists:seq/2&lt;/code&gt; and &lt;code&gt;lists:map/2&lt;/code&gt;).</source>
          <target state="translated">Мы также видим, что вызов &lt;code&gt;file:write/2&lt;/code&gt; , который записывает 1/4 содержимого файла, сам по себе занимает очень мало времени. На создание данных ( &lt;code&gt;lists:seq/2&lt;/code&gt; и &lt;code&gt;lists:map/2&lt;/code&gt; ) требуется время .</target>
        </trans-unit>
        <trans-unit id="d49ee7e4ad5636419e727eed1a3416350054ba7c" translate="yes" xml:space="preserve">
          <source>We always strive to remain as compatible as possible even in the cases where we give no compatibility guarantees.</source>
          <target state="translated">Мы всегда стремимся оставаться максимально совместимыми даже в тех случаях,когда не даем никаких гарантий совместимости.</target>
        </trans-unit>
        <trans-unit id="62c06b23c2a34df45341a353c1d6915221b4316d" translate="yes" xml:space="preserve">
          <source>We belive that the truth finally has caught with the following, retired myths.</source>
          <target state="translated">Мы верим,что правда наконец-то уловила следующие,отставные мифы.</target>
        </trans-unit>
        <trans-unit id="a21d18a0aa2c147b58a169cb973ed1ce3338cf1f" translate="yes" xml:space="preserve">
          <source>We call a set of ordered sets (x[1], ..., x[n]) an &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-ary) relation&lt;/strong&gt;, and say that the relation is a subset of the Cartesian product X[1] &amp;times; ... &amp;times; X[n], where x[i] is an element of X[i], 1 &amp;lt;= i &amp;lt;= n.</source>
          <target state="translated">Мы называем набор упорядоченных множеств (x [1], ..., x [n]) &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-арным) отношением&lt;/strong&gt; и говорим, что отношение является подмножеством декартова произведения X [1] &amp;times; ... &amp;times; X [n], где x [i] - элемент X [i], 1 &amp;lt;= i &amp;lt;= n.</target>
        </trans-unit>
        <trans-unit id="413c823c35b15bc9d9bba19b8e901ed4a84786b5" translate="yes" xml:space="preserve">
          <source>We call disconnect to log out from the database. (This should have been done from Erlang, but just in case.)</source>
          <target state="translated">Мы называем разъединение,чтобы выйти из базы данных.(Это должно было быть сделано от Эрланга,но на всякий случай).</target>
        </trans-unit>
        <trans-unit id="a622cc685c06ebc1847f597b7b757bf135bf65a2" translate="yes" xml:space="preserve">
          <source>We can also start a distributed system (requires &lt;code&gt;bin/epmd&lt;/code&gt;).</source>
          <target state="translated">Мы также можем запустить распределенную систему (требуется &lt;code&gt;bin/epmd&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d27be01791833f5e7361c562bc0586ab7a53f67b" translate="yes" xml:space="preserve">
          <source>We can in this example hibernate in the &lt;code&gt;{open,_}&lt;/code&gt; state, because what normally occurs in that state is that the state time-out after a while triggers a transition to &lt;code&gt;{locked,_}&lt;/code&gt;:</source>
          <target state="translated">В этом примере мы можем перейти в спящий режим в состоянии &lt;code&gt;{open,_}&lt;/code&gt; , потому что в этом состоянии обычно происходит то, что тайм-аут состояния через некоторое время запускает переход в &lt;code&gt;{locked,_}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="723ac72181a0f65089e1039932052a9e46e076de" translate="yes" xml:space="preserve">
          <source>We can now continue with further analyses, or we can delete the Xref server:</source>
          <target state="translated">Теперь мы можем продолжить дальнейший анализ,или мы можем удалить Xref сервер:</target>
        </trans-unit>
        <trans-unit id="256ebb1297d3c5168e6d4942a26c829b8f6be203" translate="yes" xml:space="preserve">
          <source>We continue trying to write until the queue is empty or the writing blocks.</source>
          <target state="translated">Мы продолжаем пытаться писать до тех пор,пока очередь не будет пуста или блокировки записи.</target>
        </trans-unit>
        <trans-unit id="598054eadf14bd6e3fc4f983c0ea4bf5d2acfe0d" translate="yes" xml:space="preserve">
          <source>We could find the size of the closure of the module graph with a loop similar to one used for the function graph, but since the module graph is so much smaller, a more direct method is feasible.</source>
          <target state="translated">Можно было бы найти размер замыкания модульного графа циклом,аналогичным циклу,используемому для функционального графа,но так как модульный граф намного меньше,то возможен более прямой метод.</target>
        </trans-unit>
        <trans-unit id="1991f07b9f9058aea6db1e8f77c1b4a56e270edc" translate="yes" xml:space="preserve">
          <source>We could say that the button was pressed too early so it is not to be recognized as the lock button. Or we can make the lock button part of the state so when we then change the lock button in the locked state, the change becomes a state change and all postponed events are retried, therefore the lock is immediately locked!</source>
          <target state="translated">Можно сказать,что кнопка была нажата слишком рано,чтобы ее нельзя было распознать как кнопку блокировки.Или же мы можем сделать кнопку блокировки частью состояния,так что когда мы затем меняем кнопку блокировки в заблокированном состоянии,изменение становится изменением состояния,и все отложенные события перепроверяются,поэтому блокировка немедленно блокируется!</target>
        </trans-unit>
        <trans-unit id="5a9ed4b8c10518737f16e11ac495badece57b9c4" translate="yes" xml:space="preserve">
          <source>We create the table using:</source>
          <target state="translated">Мы создаем стол,используя:</target>
        </trans-unit>
        <trans-unit id="32473b5c4698fb40d28c5576c29bf1a8447287f7" translate="yes" xml:space="preserve">
          <source>We define the state as &lt;code&gt;{StateName,LockButton}&lt;/code&gt;, where &lt;code&gt;StateName&lt;/code&gt; is as before and &lt;code&gt;LockButton&lt;/code&gt; is the current lock button:</source>
          <target state="translated">Мы определяем состояние как &lt;code&gt;{StateName,LockButton}&lt;/code&gt; , где &lt;code&gt;StateName&lt;/code&gt; как и раньше, а &lt;code&gt;LockButton&lt;/code&gt; - текущая кнопка блокировки:</target>
        </trans-unit>
        <trans-unit id="7e5b4ef345a93f5049df742fe31287578cf4c7e2" translate="yes" xml:space="preserve">
          <source>We do not need a sub-agent for each table holder. Normally, the sub-agent is needed to take care of communication, but in Distributed Erlang we use ordinary message passing.</source>
          <target state="translated">Нам не нужен субагент для каждого держателя стола.Обычно субагент нужен для общения,но в Distributed Erlang мы используем обычную передачу сообщений.</target>
        </trans-unit>
        <trans-unit id="3dcce44305924654369f1be725b80d831eab3129" translate="yes" xml:space="preserve">
          <source>We execute a query and encode the result. Encoding is done in another C module, &lt;code&gt;pg_encode.c&lt;/code&gt;, which is also provided as sample code.</source>
          <target state="translated">Выполняем запрос и кодируем результат. Кодирование выполняется в другом модуле C, &lt;code&gt;pg_encode.c&lt;/code&gt; , который также предоставляется в качестве образца кода.</target>
        </trans-unit>
        <trans-unit id="c0fc2d127a89f720c3128d44e169672e74e15c80" translate="yes" xml:space="preserve">
          <source>We fill the table with randomly chosen data:</source>
          <target state="translated">Мы заполняем таблицу случайно выбранными данными:</target>
        </trans-unit>
        <trans-unit id="3c1b0d2fdb890ab43ab70bb52624aa632e05a8ee" translate="yes" xml:space="preserve">
          <source>We find no particulary long suspend times, so no function seems to have waited in a receive statement. Actually, &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; contains a receive statement, but in this test program, the message lies in the process receive buffer when the receive statement is entered. We also see that the total suspend time for the test run is small.</source>
          <target state="translated">Мы не находим особо длительных периодов ожидания, поэтому, похоже, ни одна функция не ожидала в операторе приема. Фактически, &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; содержит оператор приема, но в этой тестовой программе сообщение находится в буфере приема процесса, когда вводится оператор приема. Мы также видим, что общее время ожидания для тестового запуска невелико.</target>
        </trans-unit>
        <trans-unit id="539abdc8c79a99e16a54fd4c1353932c38835c6d" translate="yes" xml:space="preserve">
          <source>We get all features of Mnesia, such as fault tolerance, persistent data storage, replication, and so on.</source>
          <target state="translated">Мы получаем все функции Мнезии,такие как отказоустойчивость,постоянное хранение данных,репликация и так далее.</target>
        </trans-unit>
        <trans-unit id="162b9af34243f4c75d056a06375ee57f22d03768" translate="yes" xml:space="preserve">
          <source>We handle the requests for retrieving data:</source>
          <target state="translated">Мы обрабатываем запросы на получение данных:</target>
        </trans-unit>
        <trans-unit id="82bb167cd1f1aaced33ce89ec08193896c8c8861" translate="yes" xml:space="preserve">
          <source>We have a structure to store state needed by the driver, in this case we only need to keep the database connection:</source>
          <target state="translated">У нас есть структура для хранения состояния,необходимого драйверу,в этом случае нам нужно только поддерживать соединение с базой данных:</target>
        </trans-unit>
        <trans-unit id="f0f2ae2c27d8d0a5f2644b532540797a414ff961" translate="yes" xml:space="preserve">
          <source>We have included some simple tool(s) for codec measurement (meas), performance tests (mstone1 and mstone2) and message transformation.</source>
          <target state="translated">Мы включили несколько простых инструментов для измерения (измерения)кодеков,тестов производительности (mstone1 и mstone2)и преобразования сообщений.</target>
        </trans-unit>
        <trans-unit id="8d35a0217a0c4d25516c55c6b13eeb0ee82ce246" translate="yes" xml:space="preserve">
          <source>We have instrumented our code in order to enable tracing. Running the application with tracing deactivated, causes a negligible performance overhead (an external call to a function which returns an atom). Activation of tracing does not require any recompilation of the code, since we rely on Erlang/OTP's built in support for dynamic trace activation. In our case tracing of calls to a given external function.</source>
          <target state="translated">Мы пристрастили наш код,чтобы включить трассировку.Запуск приложения с отключенной трассировкой приводит к незначительным накладным расходам (внешний вызов функции,которая возвращает атом).Активация трассировки не требует перекомпиляции кода,так как мы полагаемся на встроенную поддержку динамической активации трассировки Erlang/OTP.В нашем случае трассировка обращений к заданной внешней функции.</target>
        </trans-unit>
        <trans-unit id="19f3224f897b7485ee092aee943fad0f50d468c0" translate="yes" xml:space="preserve">
          <source>We have introduced the term &quot;user&quot; as a generic term for either an MG or an MGC, since most of the functionality we support, is common for both MG's and MGC's. A (local) user may be configured in various ways and it may establish any number of connections to its counterpart, the remote user. Once a connection has been established, the connection is supervised and it may be used for the purpose of sending messages. N.B. according to the standard an MG is connected to at most one MGC, while an MGC may be connected to any number of MG's.</source>
          <target state="translated">Мы ввели термин &quot;пользователь&quot; в качестве общего термина либо для MG,либо для MGC,так как большая часть функциональности,которую мы поддерживаем,является общей как для MG,так и для MGC.Локальный пользователь может быть сконфигурирован различными способами и может устанавливать любое количество соединений со своим аналогом,удаленным пользователем.Как только соединение установлено,оно контролируется и может быть использовано для отправки сообщений.N.B.согласно стандарту,к которому MG подключается максимум к одному MGC,в то время как MGC может быть подключено к любому количеству MG.</target>
        </trans-unit>
        <trans-unit id="877518c89585383e3076c104aa3cd7f7e23bc498" translate="yes" xml:space="preserve">
          <source>We have made four different measurements of our Erlang/OTP implementation of the Megaco/H.248 protocol stack, in order to compare our different encoders/decoders. The result of each one is summarized in the table below.</source>
          <target state="translated">Мы провели четыре различных измерения реализации стека протоколов Erlang/OTP протокола Megaco/H.248 для того,чтобы сравнить наши различные кодировщики/декодировщики.Результат каждого из них приведен в таблице ниже.</target>
        </trans-unit>
        <trans-unit id="e594586e3be21133f5db0b9bde85bb9f42084bb6" translate="yes" xml:space="preserve">
          <source>We have sometimes experienced problems with Oracle's &lt;code&gt;java&lt;/code&gt; running out of memory when running &lt;code&gt;fop&lt;/code&gt;. Increasing the amount of memory available as follows has in our case solved the problem.</source>
          <target state="translated">Иногда мы сталкивались с проблемами, связанными с &lt;code&gt;java&lt;/code&gt; памяти Oracle java при запуске &lt;code&gt;fop&lt;/code&gt; . Увеличение объема доступной памяти следующим образом решило проблему.</target>
        </trans-unit>
        <trans-unit id="0bc0044e17c922875d4350027f6b2f290ff7821f" translate="yes" xml:space="preserve">
          <source>We include &lt;code&gt;FromPid&lt;/code&gt; just in case we want to trace this.</source>
          <target state="translated">Мы включаем &lt;code&gt;FromPid&lt;/code&gt; на всякий случай, если хотим это отследить.</target>
        </trans-unit>
        <trans-unit id="62c14d96eb9053e2cc8b3f1d2c457d07c9567687" translate="yes" xml:space="preserve">
          <source>We loop through the requests one at the time, stopping when we either encounter an error or the list is exhausted. The last return value is sent back to the client (it is first returned to the main loop and then sent back by function &lt;code&gt;io_reply&lt;/code&gt;).</source>
          <target state="translated">Мы циклически перебираем запросы по одному, останавливаясь, когда либо обнаруживаем ошибку, либо список исчерпан. Последнее возвращаемое значение отправляется обратно клиенту (оно сначала возвращается в основной цикл, а затем отправляется обратно функцией &lt;code&gt;io_reply&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a36c7a61f34ba2a33c8e34b5446fa5e93cb80751" translate="yes" xml:space="preserve">
          <source>We match on the top element and embed the inner parts in an HTML body. Then we extract the string values of all motorcycle brands, sort them and removes duplicates by &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt;. We also process the substructure of the top element and pass it to a function that sorts all motorcycle information by brand according to the task formulation in the beginning of this example.</source>
          <target state="translated">Мы сопоставляем верхний элемент и встраиваем внутренние части в тело HTML. Затем мы извлекаем строковые значения всех марок мотоциклов, сортируем их и удаляем дубликаты с помощью &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt; . Мы также обрабатываем подструктуру верхнего элемента и передаем ее функции, которая сортирует всю информацию о мотоциклах по маркам в соответствии с формулировкой задачи в начале этого примера.</target>
        </trans-unit>
        <trans-unit id="7fc0e2937cea34ba0f1d5aa2eb64c711b2673f69" translate="yes" xml:space="preserve">
          <source>We need to handle backward compatibility and the &lt;code&gt;file&lt;/code&gt; module (which uses the old requests until backward compatibility with pre-R13 nodes is no longer needed). Notice that the I/O server does not work with a simple &lt;code&gt;file:write/2&lt;/code&gt; if these are not added:</source>
          <target state="translated">Нам нужно обработать обратную совместимость и &lt;code&gt;file&lt;/code&gt; модуль (который использует старые запросы до тех пор, пока обратная совместимость с узлами до R13 больше не понадобится). Обратите внимание, что сервер ввода-вывода не работает с простым &lt;code&gt;file:write/2&lt;/code&gt; если они не добавлены:</target>
        </trans-unit>
        <trans-unit id="4d6ac95529809d2ef950ae107e48095fe8aabd08" translate="yes" xml:space="preserve">
          <source>We need to handle some requests. First the requests for writing characters:</source>
          <target state="translated">Нам нужно обработать несколько запросов.Сначала запросы на написание символов:</target>
        </trans-unit>
        <trans-unit id="65164610102defaf9d5b21fb95ba5620406fc14d" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;-callback&lt;/code&gt; attribute rather than the &lt;code&gt;behaviour_info()&lt;/code&gt; function. The reason is that the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">Мы рекомендуем использовать атрибут &lt;code&gt;-callback&lt;/code&gt; , а не функцию behavior_info &lt;code&gt;behaviour_info()&lt;/code&gt; . Причина в том, что дополнительная информация о типе может использоваться инструментами для создания документации или поиска расхождений.</target>
        </trans-unit>
        <trans-unit id="346c9aa8780b8aa277233c8030ef3ce8528b2a4f" translate="yes" xml:space="preserve">
          <source>We refer to these as &quot;automatic metavariables&quot;. If in addition the name ends with &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;_@Foo@&lt;/code&gt;, the value of the variable as an Erlang term will be automatically converted to the corresponding abstract syntax tree when used to construct a larger tree. For example, in:</source>
          <target state="translated">Мы называем их &amp;laquo;автоматическими метапеременными&amp;raquo;. Если, кроме того, имя заканчивается на &lt;code&gt;@&lt;/code&gt; , как в &lt;code&gt;_@Foo@&lt;/code&gt; , значение переменной как термин Erlang будет автоматически преобразовано в соответствующее абстрактное синтаксическое дерево при использовании для построения большего дерева. Например, в:</target>
        </trans-unit>
        <trans-unit id="16a9f8a4bc23ba990af592e409f5c51b8ea523ef" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;file:write/2&lt;/code&gt; only calls &lt;code&gt;prim_file:write/2&lt;/code&gt;, but let us refrain from digging into the internals of the kernel application.</source>
          <target state="translated">Мы видим, что &lt;code&gt;file:write/2&lt;/code&gt; вызывает только &lt;code&gt;prim_file:write/2&lt;/code&gt; , но давайте воздержимся от копания во внутренностях приложения ядра.</target>
        </trans-unit>
        <trans-unit id="8c3b22518344463198707dd795380094d0c8925a" translate="yes" xml:space="preserve">
          <source>We see that the new release version is &lt;code&gt;permanent&lt;/code&gt;, so it would be safe to restart the node.</source>
          <target state="translated">Мы видим, что новая версия релиза является &lt;code&gt;permanent&lt;/code&gt; , поэтому перезапустить узел можно безопасно.</target>
        </trans-unit>
        <trans-unit id="b50565a62199c6c141d92fc8afb4546283ef2fd4" translate="yes" xml:space="preserve">
          <source>We simply pick out an I/O vector from the queue (which is the whole queue as a &lt;code&gt;SysIOVec&lt;/code&gt;). If the I/O vector is too long (&lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; is defined to 16), the vector length is decreased (line 15), otherwise the &lt;code&gt;writev&lt;/code&gt; call (line 17) fails. Writing is tried and anything written is dequeued (line 27). If the write fails with &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (notice that all sockets are in non-blocking mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_output&lt;/code&gt; routine be called when there is space to write again.</source>
          <target state="translated">Мы просто выбираем вектор ввода-вывода из очереди (которая представляет собой всю очередь как &lt;code&gt;SysIOVec&lt;/code&gt; ). Если вектор ввода-вывода слишком длинный ( &lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; определен равным 16), длина вектора уменьшается (строка 15), в противном случае вызов &lt;code&gt;writev&lt;/code&gt; (строка 17) не выполняется. Выполняется попытка записи, и все написанное удаляется из очереди (строка 27). Если запись завершается неудачно с &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (обратите внимание, что все сокеты находятся в неблокирующем режиме), &lt;code&gt;driver_select&lt;/code&gt; чтобы &lt;code&gt;uds_output&lt;/code&gt; подпрограмму uds_output , когда есть место для повторной записи.</target>
        </trans-unit>
        <trans-unit id="d0ada7dbfa4e9b0738c600e7e0aaa004c64d9416" translate="yes" xml:space="preserve">
          <source>We specify the filter, we want to view calls that resemble &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt;:</source>
          <target state="translated">Мы указываем фильтр, мы хотим просматривать вызовы, похожие на &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1235892250491b3de3e5ff2495a68e9d2682e8e0" translate="yes" xml:space="preserve">
          <source>We start a &lt;strong&gt;simple target system&lt;/strong&gt; as above. The only difference is that also the file &lt;code&gt;releases/RELEASES&lt;/code&gt; is present for code replacement in runtime to work.</source>
          <target state="translated">Мы запускаем &lt;strong&gt;простую целевую систему,&lt;/strong&gt; как указано выше. Единственное отличие состоит в том, что также присутствует файл &lt;code&gt;releases/RELEASES&lt;/code&gt; для работы замены кода во время выполнения.</target>
        </trans-unit>
        <trans-unit id="c601e5855e0a64b0a4dc2997f72bc0154a5ac01a" translate="yes" xml:space="preserve">
          <source>We start writing the example Unix domain sockets driver by declaring prototypes and filling in a static &lt;code&gt;ErlDrvEntry&lt;/code&gt; structure:</source>
          <target state="translated">Мы начинаем писать пример драйвера сокетов домена Unix с объявления прототипов и заполнения статической структуры &lt;code&gt;ErlDrvEntry&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="644c408e343363fe6260f95a6a30cda576bd3ce6" translate="yes" xml:space="preserve">
          <source>We store the &lt;code&gt;creation&lt;/code&gt; serial number in the file. The &lt;code&gt;creation&lt;/code&gt; is a number that is to change between different instances of different Erlang emulators with the same name, so that process identifiers from one emulator do not become valid when sent to a new emulator with the same distribution name. The creation can be from 0 through 3 (two bits) and is stored in every process identifier sent to another node.</source>
          <target state="translated">Мы храним серийный номер &lt;code&gt;creation&lt;/code&gt; в файле. &lt;code&gt;creation&lt;/code&gt; это число , которое является изменение между различными экземплярами различных эмуляторов Эрланга с тем же именем, так что процесс идентификаторы из одного эмулятора не вступают в силу при отправке на новый эмулятор с таким же названием распределения. Создание может быть от 0 до 3 (два бита) и сохраняется в каждом идентификаторе процесса, отправляемом на другой узел.</target>
        </trans-unit>
        <trans-unit id="63a6ffdb62bb132307bcc5f5fe297a041b9ec3d7" translate="yes" xml:space="preserve">
          <source>We strongly encourage the use of the &lt;code&gt;RowStatus&lt;/code&gt; convention for every table that can be modified from the manager, even for newly designed SNMPv1 MIBs. In SNMPv1, everybody has invented their own scheme for emulating table operations, which has led to numerous inconsistencies. The convention in SNMPv2 is flexible and powerful and has been tested successfully. If the table is read only, no RowStatus column should be used.</source>
          <target state="translated">Мы настоятельно рекомендуем использовать соглашение &lt;code&gt;RowStatus&lt;/code&gt; для каждой таблицы, которая может быть изменена из диспетчера, даже для недавно разработанных MIB SNMPv1. В SNMPv1 каждый изобрел свою собственную схему эмуляции табличных операций, что привело к многочисленным несоответствиям. Соглашение в SNMPv2 является гибким и мощным и успешно протестировано. Если таблица предназначена только для чтения, столбец RowStatus использовать не следует.</target>
        </trans-unit>
        <trans-unit id="508ccb34921947b5beb2005777369f595ad7c8a8" translate="yes" xml:space="preserve">
          <source>We study the state that is needed for the ports. Notice that not all fields are used for all types of ports. Some space could be saved by using unions, but that would clutter the code with multiple indirections, so here is used one struct for all types of ports, for readability:</source>
          <target state="translated">Мы изучаем состояние,которое необходимо для портов.Обратите внимание,что не все поля используются для всех типов портов.Некоторое пространство можно было бы сэкономить,используя союзы,но это загромождало бы код множеством ссылок,поэтому здесь используется одна структура для всех типов портов,для удобочитаемости:</target>
        </trans-unit>
        <trans-unit id="0570780114e9fc609087371872169fccbd297f49" translate="yes" xml:space="preserve">
          <source>We suspect the &lt;code&gt;ets:new/2&lt;/code&gt; call, as we match hard on the return value, but want only the particular &lt;code&gt;new/2&lt;/code&gt; call with &lt;code&gt;toy_table&lt;/code&gt; as first parameter. So we start a default tracer on the node:</source>
          <target state="translated">Мы подозреваем вызов &lt;code&gt;ets:new/2&lt;/code&gt; , так как мы &lt;code&gt;toy_table&lt;/code&gt; возвращаемое значение, но хотим, чтобы только конкретный вызов &lt;code&gt;new/2&lt;/code&gt; с toy_table в качестве первого параметра. Итак, мы запускаем трассировщик по умолчанию на узле:</target>
        </trans-unit>
        <trans-unit id="f5bbffab7f95f81cee247421bd092ab29a87848d" translate="yes" xml:space="preserve">
          <source>We turn on call tracing for all processes, we want to make a pretty restrictive trace pattern, so there is no need to call trace only a few processes (usually it is not):</source>
          <target state="translated">Мы включаем трассировку вызова для всех процессов,мы хотим сделать довольно ограничительный шаблон трассировки,поэтому нет необходимости вызывать трассировку только для нескольких процессов (обычно это не так):</target>
        </trans-unit>
        <trans-unit id="59f43c3a056dd53d064433399740ce5398c03179" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;dbg:tpl/3&lt;/code&gt; to ensure to catch local calls (assume that the module has grown since the smaller version and we are unsure if this inserting of atoms is not done locally). When in doubt, always use local call tracing.</source>
          <target state="translated">Мы используем &lt;code&gt;dbg:tpl/3&lt;/code&gt; , чтобы гарантировать перехват локальных вызовов (предположим, что модуль вырос по сравнению с меньшей версией, и мы не уверены, не выполняется ли эта вставка атомов локально). В случае сомнений всегда используйте локальную трассировку вызовов.</target>
        </trans-unit>
        <trans-unit id="3db459c71765166584b222966eebe056c8bcb451" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;port_control/3&lt;/code&gt; function for all calls into the driver. The result from the driver is returned immediately and converted to terms by calling &lt;code&gt;binary_to_term/1&lt;/code&gt;. (We trust that the terms returned from the driver are well-formed, otherwise the &lt;code&gt;binary_to_term&lt;/code&gt; calls could be contained in a &lt;code&gt;catch&lt;/code&gt;.)</source>
          <target state="translated">Мы используем &lt;code&gt;port_control/3&lt;/code&gt; для всех вызовов драйвера. Результат от драйвера немедленно возвращается и преобразуется в термины путем вызова &lt;code&gt;binary_to_term/1&lt;/code&gt; . (Мы уверены, что термины, возвращаемые драйвером, имеют правильный &lt;code&gt;binary_to_term&lt;/code&gt; , иначе вызовы binary_to_term могут содержаться в &lt;code&gt;catch&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="02fb426878fcef94b8e18d9576286ad65ac4ed4a" translate="yes" xml:space="preserve">
          <source>We use the binary format only to return data to the emulator; input data is a string parameter for &lt;code&gt;connect&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;. The returned data consists of Erlang terms.</source>
          <target state="translated">Мы используем двоичный формат только для возврата данных в эмулятор; входные данные - это строковый параметр для &lt;code&gt;connect&lt;/code&gt; и &lt;code&gt;select&lt;/code&gt; . Возвращенные данные состоят из терминов Erlang.</target>
        </trans-unit>
        <trans-unit id="014d84a4d3abb1236ee92db9f5f0d5547ff6a186" translate="yes" xml:space="preserve">
          <source>We use the function &lt;code&gt;Rep&lt;/code&gt; to denote the mapping from an Erlang source construct &lt;code&gt;C&lt;/code&gt; to its abstract format representation &lt;code&gt;R&lt;/code&gt;, and write &lt;code&gt;R = Rep(C)&lt;/code&gt;.</source>
          <target state="translated">Мы используем функцию &lt;code&gt;Rep&lt;/code&gt; для обозначения отображения исходной конструкции Erlang &lt;code&gt;C&lt;/code&gt; в ее представление абстрактного формата &lt;code&gt;R&lt;/code&gt; и пишем &lt;code&gt;R = Rep(C)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b955b8cc53f04946e7906d8bccd83ad77bc547a4" translate="yes" xml:space="preserve">
          <source>We use the same internal form for both the binary and text encoding. Our internal form of Megaco/H.248 messages is heavily influenced by the internal format used by ASN.1 encoders/decoders:</source>
          <target state="translated">Мы используем одну и ту же внутреннюю форму как для двоичной,так и для текстовой кодировки.На нашу внутреннюю форму сообщений Megaco/H.248 сильно влияет внутренний формат,используемый кодировщиками/декодировщиками ASN.1:</target>
        </trans-unit>
        <trans-unit id="09eafdf76bfe34feacf5ab1510c6a7720bed3f57" translate="yes" xml:space="preserve">
          <source>We use the simplest possible &lt;code&gt;sys.config&lt;/code&gt;, which we store in &lt;code&gt;releases/FIRST&lt;/code&gt;:</source>
          <target state="translated">Мы используем самый простой из возможных &lt;code&gt;sys.config&lt;/code&gt; , который храним в Release &lt;code&gt;releases/FIRST&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b0d8589e4a15b7a5013c9800a611e86facb44e60" translate="yes" xml:space="preserve">
          <source>We very much welcome user feedback - even wishlists! If you notice anything weird, especially if Dialyzer reports any discrepancy that is a false positive, please send an error report describing the symptoms and how to reproduce them.</source>
          <target state="translated">Мы очень рады отзывам пользователей-даже пожеланиям! Если вы заметили что-то странное,особенно если Dialyzer сообщает о несоответствии,которое является ложноположительным,пожалуйста,отправьте отчет об ошибке,описывающий симптомы и как их воспроизвести.</target>
        </trans-unit>
        <trans-unit id="c5f285e2cc8e54c3430820d9c7f8e8768e8a5b79" translate="yes" xml:space="preserve">
          <source>We want a locking mechanism that gives no race conditions, to be sure if another Erlang node uses the listen socket name we require or if the file is only left there from a previous (crashed) session.</source>
          <target state="translated">Нам нужен механизм блокировки,который не дает условий гонки,чтобы быть уверенным,что другой узел Erlang использует имя слушающего сокета,которое мы требуем,или что файл остался там только с предыдущего (аварийного)сеанса.</target>
        </trans-unit>
        <trans-unit id="b3d62af079f72041cf5e740a82dc4dbd33004d95" translate="yes" xml:space="preserve">
          <source>We want to find the reduction of the closure of the function graph to modules. The direct expression for doing that would be &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt;, but then we would have to represent all of the transitive closure of E in memory. Instead the number of indirectly used modules is found for each analyzed module, and the sum over all modules is calculated.</source>
          <target state="translated">Мы хотим найти сокращение замыкания графа функций до модулей. Прямым выражением для этого будет &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt; , но тогда нам нужно будет представить все транзитивное замыкание E в памяти. Вместо этого для каждого анализируемого модуля определяется количество косвенно используемых модулей и вычисляется сумма по всем модулям.</target>
        </trans-unit>
        <trans-unit id="d1cec4b25e7ec82e4a29c249c1772265612c2f98" translate="yes" xml:space="preserve">
          <source>We will first go through the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure which people probably are most familiar with.</source>
          <target state="translated">Мы сначала пройти через &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; процедуры сборки , которые люди , вероятно , являются наиболее знакомы.</target>
        </trans-unit>
        <trans-unit id="e5ff38c2602baf56bc8c3440d3937fb894b7ad10" translate="yes" xml:space="preserve">
          <source>We will not be bug-compatible. A bug fix might introduce incompatible changes. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">Мы не будем совместимы с ошибками.Исправление ошибки может привести к несовместимым изменениям.Подобная несовместимость может возникнуть в патче.</target>
        </trans-unit>
        <trans-unit id="aad9e6cc5dd978296e9f3155b1fac5bd4e904894" translate="yes" xml:space="preserve">
          <source>We will see more details of this later. If you want to experiment with distributed Erlang, but you only have one computer to work on, you can start two separate Erlang systems on the same computer but give them different names. Each Erlang system running on a computer is called an &lt;strong&gt;Erlang node&lt;/strong&gt;.</source>
          <target state="translated">Мы увидим более подробную информацию об этом позже. Если вы хотите поэкспериментировать с распределенным Erlang, но у вас есть только один компьютер для работы, вы можете запустить две отдельные системы Erlang на одном компьютере, но дать им разные имена. Каждая система Erlang, работающая на компьютере, называется &lt;strong&gt;узлом Erlang&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6fd397370c00ee4d81771bc1a4690627c9a9c47d" translate="yes" xml:space="preserve">
          <source>We would recommend using 1.0.2d.</source>
          <target state="translated">Мы рекомендуем использовать 1.0.2d.</target>
        </trans-unit>
        <trans-unit id="843043fadfaea89e297baed2f38224161728a8fc" translate="yes" xml:space="preserve">
          <source>We write it using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;:</source>
          <target state="translated">Мы пишем его с помощью &lt;code&gt;ets:fun2ms/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d11ec20af5e84fd81824db4ba0a8cd93159b8e2" translate="yes" xml:space="preserve">
          <source>We've tried up to 1.0, but the latest version should do. Make sure you download the &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt;, not a linux version. You unzip the package on top of your MinGW installation (&lt;code&gt;c:\MinGW&lt;/code&gt;) and that's it.</source>
          <target state="translated">Мы пробовали до 1.0, но подойдет последняя версия. Убедитесь, что вы загрузили &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt; , а не версию для Linux. Вы распаковываете пакет поверх своей установки MinGW ( &lt;code&gt;c:\MinGW&lt;/code&gt; ) и все.</target>
        </trans-unit>
        <trans-unit id="b8eef6e94eb7100a713ed2ea56c1d7018de92907" translate="yes" xml:space="preserve">
          <source>We've used this build procedure for a couple of releases, and it has worked fine for us. Still, there might be all sorts of troubles on different machines and with different setups. We'll try to give hints wherever we've encountered difficulties, but please share your experiences by using the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; mailing list. We cannot, of course, help everyone with all their issues, so please try to solve such issues and submit solutions/workarounds.</source>
          <target state="translated">Мы использовали эту процедуру сборки для нескольких выпусков, и у нас она отлично сработала. Тем не менее, на разных машинах и с разными настройками могут быть самые разные проблемы. Мы постараемся дать подсказки везде, где столкнемся с трудностями, но, пожалуйста, поделитесь своим опытом, используя список рассылки &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; . Мы, конечно, не можем помочь всем со всеми их проблемами, поэтому попробуйте решить такие проблемы и представить решения / обходные пути.</target>
        </trans-unit>
        <trans-unit id="b36b032611690f561af6ed7868e7f249080a2d29" translate="yes" xml:space="preserve">
          <source>Web server users without server administrative privileges that need to manage authentication of web pages that are local to their user can use the per-directory runtime configurable user-authentication scheme &lt;code&gt;htaccess&lt;/code&gt;. It works as follows:</source>
          <target state="translated">Пользователи веб-сервера без административных привилегий сервера, которым необходимо управлять аутентификацией веб-страниц, локальных для их пользователя, могут использовать настраиваемую для каждого каталога схему аутентификации пользователя &lt;code&gt;htaccess&lt;/code&gt; . Это работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="3ee3b99c66ed2c1f02ee33b7f98ce7fdcb23b424" translate="yes" xml:space="preserve">
          <source>Welcome to Erlang/OTP, a complete development environment for concurrent programming.</source>
          <target state="translated">Добро пожаловать в Erlang/OTP,полную среду разработки для параллельного программирования.</target>
        </trans-unit>
        <trans-unit id="22c886918035c78f6182ee187f960d0ece83d0bb" translate="yes" xml:space="preserve">
          <source>What is a printable character in this case is determined by startup flag &lt;code&gt;+pc&lt;/code&gt; to the Erlang VM; see &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Что такое печатный символ в этом случае, определяется флагом запуска &lt;code&gt;+pc&lt;/code&gt; для виртуальной машины Erlang; см. &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4edfb9d438187e25e8117b3d96348c8b942d6ff3" translate="yes" xml:space="preserve">
          <source>What is captured in this example is the part of the work the shell does while interpreting the command line that occurs between the actual calls to &lt;code&gt;cprof:start()&lt;/code&gt; and &lt;code&gt;cprof:analyse()&lt;/code&gt;.</source>
          <target state="translated">В этом примере &lt;code&gt;cprof:start()&lt;/code&gt; часть работы, которую оболочка выполняет при интерпретации командной строки, которая происходит между фактическими вызовами cprof: start () и &lt;code&gt;cprof:analyse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8308f9197a4bcfd38df815152af92e5bca4b765b" translate="yes" xml:space="preserve">
          <source>What makes the &lt;code&gt;Mnesia&lt;/code&gt; data model an extended relational model is the ability to store arbitrary Erlang terms in the attribute fields. One attribute value can, for example, be a whole tree of OIDs leading to other terms in other tables. This type of record is difficult to model in traditional relational DBMSs.</source>
          <target state="translated">Что делает модель данных &lt;code&gt;Mnesia&lt;/code&gt; расширенной реляционной моделью, так это возможность хранить произвольные термины Erlang в полях атрибутов. Одно значение атрибута может, например, быть целым деревом OID, ведущим к другим терминам в других таблицах. Этот тип записи сложно смоделировать в традиционных реляционных СУБД.</target>
        </trans-unit>
        <trans-unit id="405eee64426a95cf4618da03e92872e8805137ae" translate="yes" xml:space="preserve">
          <source>What more can you do? A simple answer is: see the documentation of &lt;code&gt;match specifications&lt;/code&gt; in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt;. It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by &lt;code&gt;ets:fun2ms/1&lt;/code&gt;. The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of &lt;code&gt;ets:select/2&lt;/code&gt; compared to &lt;code&gt;ets:foldl/foldr&lt;/code&gt;.</source>
          <target state="translated">Что еще ты можешь сделать? Простой ответ: см. Документацию по &lt;code&gt;match specifications&lt;/code&gt; в Руководстве пользователя ERTS. Тем не менее, ниже приводится краткий обзор наиболее полезных &amp;laquo;встроенных функций&amp;raquo;, которые вы можете использовать, когда удовольствие должно быть преобразовано в спецификацию соответствия с помощью &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; . Невозможно вызвать другие функции, кроме разрешенных в спецификациях соответствия. Никакой &quot;обычный&quot; код на Erlang не может быть выполнен с помощью функции fun, переведенной с помощью &lt;code&gt;ets:fun2ms/1&lt;/code&gt; . Удовольствие ограничивается точно мощностью спецификаций соответствия, что, к сожалению, но цена, которую приходится платить за скорость выполнения &lt;code&gt;ets:select/2&lt;/code&gt; по сравнению с &lt;code&gt;ets:foldl/foldr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be9abe5ff356944e50659de71982880b18848dd6" translate="yes" xml:space="preserve">
          <source>What reservation of physical memory means, highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behavior.</source>
          <target state="translated">Что означает резервирование физической памяти,сильно зависит от операционной системы,и от того,как она настроена.Например,различные настройки перекоммутации памяти в Linux радикально меняют поведение.</target>
        </trans-unit>
        <trans-unit id="587af77c14f789357e51980e72003df91f480665" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;qlc&lt;/code&gt; module primarily adds to list comprehensions is that data can be read from QLC tables in small chunks. A QLC table is created by calling &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Usually &lt;code&gt;qlc:table/2&lt;/code&gt; is not called directly from the query but through an interface function of some data structure. Erlang/OTP includes a few examples of such functions: &lt;code&gt;mnesia:table/1,2&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt;. For a given data structure, many functions can create QLC tables, but common for these functions is that they return a query handle created by &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Using the QLC tables provided by Erlang/OTP is usually probably sufficient, but for the more advanced user section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; describes the implementation of a function calling &lt;code&gt;qlc:table/2&lt;/code&gt;.</source>
          <target state="translated">Что &lt;code&gt;qlc&lt;/code&gt; модуль в первую очередь добавляет к списковому является то , что данные могут быть считаны из таблиц QLC небольших порций. Таблица QLC создается путем вызова &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; . Обычно &lt;code&gt;qlc:table/2&lt;/code&gt; вызывается не напрямую из запроса, а через интерфейсную функцию некоторой структуры данных. Erlang / OTP включает несколько примеров таких функций: &lt;code&gt;mnesia:table/1,2&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt; . Для данной структуры данных многие функции могут создавать таблицы QLC, но общим для этих функций является то, что они возвращают дескриптор запроса, созданный &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; . Обычно достаточно использовать таблицы QLC, предоставляемые Erlang / OTP, но для более продвинутых пользователей. &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; описывает реализацию функции, вызывающей &lt;code&gt;qlc:table/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e307252350d5f0ef992b3ab620b890f8bd198517" translate="yes" xml:space="preserve">
          <source>What the I/O server sends when there is no data.</source>
          <target state="translated">Что посылает сервер ввода/вывода при отсутствии данных.</target>
        </trans-unit>
        <trans-unit id="1804d21d5ef8f5b8cb1f89c4e94fe07aef9672aa" translate="yes" xml:space="preserve">
          <source>What this means, if anything, is implementation dependent.</source>
          <target state="translated">То,что это значит,если что,зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="a86e62a665b180d594c01dd61c21371b36d33af5" translate="yes" xml:space="preserve">
          <source>What you have to do in such cases is to write your metavariable in a syntactically valid position, and use lifting markers to denote where it should really apply, as in:</source>
          <target state="translated">В таких случаях необходимо написать метастабильную переменную в синтаксически правильном положении и использовать подъемные маркеры для обозначения того,где она действительно должна применяться,как в случае с синтаксической переменной:</target>
        </trans-unit>
        <trans-unit id="c5c621a34cc77c693f796b9c9a4e0202b514808a" translate="yes" xml:space="preserve">
          <source>Whatever added by &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; in the test suite.</source>
          <target state="translated">Что бы ни добавили &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; в тестовом наборе.</target>
        </trans-unit>
        <trans-unit id="0e65ac25edcc6a715cbfb229eba192595c676d46" translate="yes" xml:space="preserve">
          <source>When (*SKIP) has an associated name, its behavior is modified:</source>
          <target state="translated">Когда (*SKIP)имеет ассоциированное имя,его поведение изменяется:</target>
        </trans-unit>
        <trans-unit id="04fe958830198355cc811da35c494d7c1c3c2d18" translate="yes" xml:space="preserve">
          <source>When (finally?) everything is in order with the locale settings, fonts. and the terminal emulator, you have probably found a way to input characters in the script you desire. For testing, the simplest way is to add some keyboard mappings for other languages, usually done with some applet in your desktop environment.</source>
          <target state="translated">Когда (наконец?)все в порядке с настройками локали,шрифтов и эмулятора терминала,вы,вероятно,нашли способ ввода символов в желаемый вами скрипт.Для тестирования самым простым способом является добавление некоторых связок клавиатуры для других языков,обычно выполняемых с помощью какого-либо апплета в вашей настольной среде.</target>
        </trans-unit>
        <trans-unit id="0c61293396a0994c6191d7911346e57c38611cf9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,NewConfig1}&lt;/code&gt;, Logger writes &lt;code&gt;NewConfig1&lt;/code&gt; to the configuration database.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; , Logger вызывает &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt; . Если эта функция возвращает &lt;code&gt;{ok,NewConfig1}&lt;/code&gt; , Logger записывает &lt;code&gt;NewConfig1&lt;/code&gt; в базу данных конфигурации.</target>
        </trans-unit>
        <trans-unit id="93e75014a8819db24d123ffe574cf1058af1d7b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Addr&lt;/code&gt; does not contain a port number, the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">Когда &lt;code&gt;Addr&lt;/code&gt; не содержит номера порта, используется значение &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af3df4cc98d21f4d7157a7f5c03ed4afe7255c29" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:cancel_timer()&lt;/code&gt;. otherwise &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="translated">Когда &lt;code&gt;Async&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; : если &lt;code&gt;Info&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Result&lt;/code&gt; возвращается &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; . в противном случае возвращается &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c3055751c190947148414125cb3febf1e8f6f5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a message on the form &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; when the cancellation operation has been performed, otherwise no message is sent.</source>
          <target state="translated">Когда &lt;code&gt;Async&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; : если &lt;code&gt;Info&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , сообщение в форме &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; отправляется вызывающему &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; после выполнения операции отмены, в противном случае сообщение не отправляется.</target>
        </trans-unit>
        <trans-unit id="166a240b6e5cc60a7634b1583a60930de57018f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Common Test&lt;/code&gt; starts, it automatically attempts to compile any suites included in the specified tests. If particular suites are specified, only those suites are compiled. If a particular test object directory is specified (meaning all suites in this directory are to be part of the test), &lt;code&gt;Common Test&lt;/code&gt; runs function &lt;code&gt;make:all/1&lt;/code&gt; in the directory to compile the suites.</source>
          <target state="translated">При запуске &lt;code&gt;Common Test&lt;/code&gt; он автоматически пытается скомпилировать любые наборы, включенные в указанные тесты. Если указаны конкретные комплекты, компилируются только эти комплекты. Если указан конкретный каталог тестовых объектов (это означает, что все наборы в этом каталоге должны быть частью теста), &lt;code&gt;Common Test&lt;/code&gt; запускает функцию &lt;code&gt;make:all/1&lt;/code&gt; в каталоге для компиляции наборов.</target>
        </trans-unit>
        <trans-unit id="42507199eef19752873563b14392dfa940c65fc9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Mnesia&lt;/code&gt; loads many tables, the default load order is used. However, the load order can be affected, by explicitly changing property &lt;code&gt;load_order&lt;/code&gt; for the tables, with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;LoadOrder&lt;/code&gt; is by default &lt;code&gt;0&lt;/code&gt; for all tables, but it can be set to any integer. The table with the highest &lt;code&gt;load_order&lt;/code&gt; is loaded first. Changing the load order is especially useful for applications that need to ensure early availability of fundamental tables. Large peripheral tables are to have a low load order value, perhaps less than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">Когда &lt;code&gt;Mnesia&lt;/code&gt; загружает много таблиц, используется порядок загрузки по умолчанию. Однако на порядок загрузки можно повлиять, явно изменив свойство &lt;code&gt;load_order&lt;/code&gt; для таблиц с помощью функции &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;LoadOrder&lt;/code&gt; по умолчанию равен &lt;code&gt;0&lt;/code&gt; для всех таблиц, но может быть установлен на любое целое число. Таблица с наибольшим &lt;code&gt;load_order&lt;/code&gt; загружается первой. Изменение порядка загрузки особенно полезно для приложений, которым необходимо обеспечить раннюю доступность основных таблиц. Большие периферийные столы должны иметь низкое значение порядка загрузки, возможно, меньше &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69de3dae19f69610dd34e83bd997df060a7428e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Arguments&lt;/code&gt; are provided, we apply it and do the same with the result as if the data was provided directly.</source>
          <target state="translated">Когда предоставляются &lt;code&gt;Module&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; и &lt;code&gt;Arguments&lt;/code&gt; , мы применяем их и делаем то же самое с результатом, как если бы данные были предоставлены напрямую.</target>
        </trans-unit>
        <trans-unit id="c52ee13a4dcb299f5a385cfe15fc42403a860bc7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; calls a traced function. The return values of calls are never supplied, only the call and its arguments.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; вызывает отслеживаемую функцию. Возвращаемые значения вызовов никогда не передаются, только вызов и его аргументы.</target>
        </trans-unit>
        <trans-unit id="323d59db6fafd89e5c07401fb7993540b99d690e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits &lt;strong&gt;from&lt;/strong&gt; the specified function because of an exception. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with an &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; выходит &lt;strong&gt;из&lt;/strong&gt; указанной функции из-за исключения. Это сообщение трассировки отправляется, если установлен &lt;code&gt;call&lt;/code&gt; флага , и функция имеет спецификацию соответствия с действием &lt;code&gt;exception_trace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc3d1426688af7f3815ab8ffb8557afa8cf69def" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits with reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; уходит по причине &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a10c0e2595bc6a45b793e623dbb1d7e74c4840d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled out. The process was running in function {M, F, Arity}. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; не работает. Процесс выполнялся в функции {M, F, Arity}. В некоторых редких случаях текущая функция не может быть определена, тогда последний элемент равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="885b32e12e9f0ba67537b4a0349bf3e528dd7008" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled to run. The process runs in function &lt;code&gt;{M, F, Arity}&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Когда запланирован запуск &lt;code&gt;Pid&lt;/code&gt; . Процесс выполняется в функции &lt;code&gt;{M, F, Arity}&lt;/code&gt; . В некоторых редких случаях текущая функция не может быть определена, тогда последний элемент равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2579456f2ac4547aa51c7500a5011980e64fed27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is spawned by process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; &lt;code&gt;Pid2&lt;/code&gt; процессом Pid2 с указанным вызовом функции в качестве точки входа.</target>
        </trans-unit>
        <trans-unit id="ee6d840360c675d28fb4189ea75bcf500ea96744" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; links to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; ссылается на процесс &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0d2e5fb513b27fbae59d57a8659f003a4ecf83" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; opens a new port &lt;code&gt;Port&lt;/code&gt; with the running &lt;code&gt;Driver&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; открывает новый порт &lt;code&gt;Port&lt;/code&gt; с запущенным &lt;code&gt;Driver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ed889ebc9aca15515c2b45ca1a374fd67cf415" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; removes the link from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; удаляет ссылку из процесса &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5751eed2112a0c8b568fa52ffcbeb3e9cb0f2b8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;from&lt;/strong&gt; the specified function. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with a &lt;code&gt;return_trace&lt;/code&gt; or &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; возвращается &lt;strong&gt;из&lt;/strong&gt; указанной функции. Это сообщение трассировки отправляется, если установлен флаг &lt;code&gt;call&lt;/code&gt; и функция имеет спецификацию соответствия с действием &lt;code&gt;return_trace&lt;/code&gt; или &lt;code&gt;exception_trace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcbfdb05819ccf5c6584d296609a8e52d12c64f1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;to&lt;/strong&gt; the specified function. This trace message is sent if both the flags &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; are set, and the function is set to be traced on &lt;strong&gt;local&lt;/strong&gt; function calls. The message is only sent when returning from a chain of tail recursive function calls, where at least one call generated a &lt;code&gt;call&lt;/code&gt; trace message (that is, the functions match specification matched, and &lt;code&gt;{message, false}&lt;/code&gt; was not an action).</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; вернется &lt;strong&gt;к&lt;/strong&gt; указанной функции. Это сообщение трассировки отправляется, если установлены оба флага &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;return_to&lt;/code&gt; , а функция настроена на отслеживание при вызовах &lt;strong&gt;локальных&lt;/strong&gt; функций. Сообщение отправляется только при возврате из цепочки хвостовых рекурсивных вызовов функций, где по крайней мере один вызов сгенерировал сообщение трассировки &lt;code&gt;call&lt;/code&gt; (то есть, функции соответствуют спецификации, и &lt;code&gt;{message, false}&lt;/code&gt; не было действием).</target>
        </trans-unit>
        <trans-unit id="ba46a646e37ed8b7d35c674ed3b3e32924ba03e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; spawns a new process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">Когда &lt;code&gt;Pid&lt;/code&gt; порождает новый процесс &lt;code&gt;Pid2&lt;/code&gt; с указанным вызовом функции в качестве точки входа.</target>
        </trans-unit>
        <trans-unit id="5cc371b2356f9951c5abbb937169272313d56c71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets linked to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;PidPort&lt;/code&gt; связывается с процессом &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="972a925137e0ccb08bc5aeffdfecb3782e3bc889" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; registered.</source>
          <target state="translated">Когда &lt;code&gt;PidPort&lt;/code&gt; получает зарегистрированное имя &lt;code&gt;RegName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="162e33555c86a661514ef9d4a857ec534b5a22a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; unregistered. This is done automatically when a registered process or port exits.</source>
          <target state="translated">Когда &lt;code&gt;PidPort&lt;/code&gt; получает незарегистрированное имя &lt;code&gt;RegName&lt;/code&gt; . Это делается автоматически при выходе из зарегистрированного процесса или порта.</target>
        </trans-unit>
        <trans-unit id="feb1d708bf63c2940ea863c472a540929d8d0a03" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets unlinked from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;PidPort&lt;/code&gt; отключается от процесса &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a6470e961b2d5912dd59eb5021ef79f690f562" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; receives message &lt;code&gt;Msg&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is set to time-out, a receive statement can have timed out, or the process received a message with the payload &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;PidPort&lt;/code&gt; получает сообщение &lt;code&gt;Msg&lt;/code&gt; . Если для &lt;code&gt;Msg&lt;/code&gt; задано значение тайм-аута, время ожидания для оператора приема могло истечь или процесс получил сообщение с &lt;code&gt;timeout&lt;/code&gt; полезной нагрузки .</target>
        </trans-unit>
        <trans-unit id="e87cde17521c68e2a936fe17936bf5ceeb2c3d14" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;PidPort&lt;/code&gt; отправляет сообщение &lt;code&gt;Msg&lt;/code&gt; для обработки &lt;code&gt;To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61e6201a42785b41b69c2b7a25abb9b7fd4f07c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to the non-existing process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;PidPort&lt;/code&gt; отправляет сообщение &lt;code&gt;Msg&lt;/code&gt; несуществующему процессу &lt;code&gt;To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15233790daaa8247a54c54b5c9b5074f4bf171a9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; closes with &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;Port&lt;/code&gt; закрывается по &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80787715e672faf25567796cfbe4be1ecff2d7f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled out. The last command run was &lt;code&gt;Command&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;Command&lt;/code&gt; can contain the same commands as &lt;code&gt;in&lt;/code&gt;</source>
          <target state="translated">Когда &lt;code&gt;Port&lt;/code&gt; отключен. Последней запущенной командой была &lt;code&gt;Command&lt;/code&gt; . В некоторых редких случаях текущая функция не может быть определена, тогда последний элемент равен &lt;code&gt;0&lt;/code&gt; . &lt;code&gt;Command&lt;/code&gt; может содержать те же команды, что и &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9ef0bd2183c0bb797164fa66a45ee2bd8c3d2cf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled to run. &lt;code&gt;Command&lt;/code&gt; is the first thing the port will execute, it can however run several commands before being scheduled out. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;Port&lt;/code&gt; запланирован для запуска. &lt;code&gt;Command&lt;/code&gt; - это первое, что выполнит порт, однако он может выполнить несколько команд до того, как будет запланировано выполнение. В некоторых редких случаях текущая функция не может быть определена, тогда последний элемент равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="763a821ae322d45ebff08f1076aa08fd98dc4152" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;accept&lt;/code&gt; is issued, the values of the listening socket options are inherited. No such application variable is therefore needed for &lt;code&gt;accept&lt;/code&gt;.</source>
          <target state="translated">Когда выдается &lt;code&gt;accept&lt;/code&gt; , значения параметров прослушивающего сокета наследуются. Следовательно, для &lt;code&gt;accept&lt;/code&gt; такая переменная приложения не требуется .</target>
        </trans-unit>
        <trans-unit id="1a84fa4a21d8059b923917b5063cf77ca5a084f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/2,3&lt;/code&gt; is used with wrap logs, the returned continuation might not be valid in the next call to &lt;code&gt;chunk()&lt;/code&gt;. This is because the log can wrap and delete the file into which the continuation points. To prevent this, the log can be blocked during the search.</source>
          <target state="translated">Когда &lt;code&gt;chunk/2,3&lt;/code&gt; используется с журналами переноса, возвращенное продолжение может быть недействительным при следующем вызове &lt;code&gt;chunk()&lt;/code&gt; . Это связано с тем, что журнал может обернуть и удалить файл, на который указывает продолжение. Чтобы этого не произошло, журнал можно заблокировать во время поиска.</target>
        </trans-unit>
        <trans-unit id="b575a5e86459930acb9d9587352f01c78bb4d138" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 64 kilobyte chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that the end of the file is reached.</source>
          <target state="translated">Когда вызывается &lt;code&gt;chunk/3&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; контролирует максимальное количество терминов, считываемых из журнала в каждом фрагменте. По умолчанию используется &lt;code&gt;infinity&lt;/code&gt; , что означает, что все термины, содержащиеся в блоке размером 64 килобайта, читаются. Если возвращается менее &lt;code&gt;N&lt;/code&gt; терминов, это не обязательно означает, что достигнут конец файла.</target>
        </trans-unit>
        <trans-unit id="ea8aa73939a31b631da4d86b608b56e6f570baca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 8K chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that end of file is reached.</source>
          <target state="translated">Когда вызывается &lt;code&gt;chunk/3&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; контролирует максимальное количество терминов, считываемых из журнала в каждом фрагменте. По умолчанию &lt;code&gt;infinity&lt;/code&gt; , что означает, что все термины, содержащиеся в блоке 8K, читаются. Если возвращается менее &lt;code&gt;N&lt;/code&gt; терминов, это не обязательно означает, что достигнут конец файла.</target>
        </trans-unit>
        <trans-unit id="e99ff5779b67a6b782f749fc2ebb582cf983dde5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; is called, an asynchronous signal is sent to all schedulers online, causing them to try to bind or unbind as requested.</source>
          <target state="translated">Когда &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; , всем планировщикам в сети отправляется асинхронный сигнал, заставляющий их пытаться привязать или отменить привязку по запросу.</target>
        </trans-unit>
        <trans-unit id="0f7f20feb6d8e86e2be7182c1146591f5b2c10e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;float/1&lt;/code&gt; is used in an expression in a guard, such as '&lt;code&gt;float(A) == 4.0&lt;/code&gt;', it converts a number as described earlier.</source>
          <target state="translated">Когда &lt;code&gt;float/1&lt;/code&gt; используется в выражении в защите, таком как ' &lt;code&gt;float(A) == 4.0&lt;/code&gt; ', он преобразует число, как описано ранее.</target>
        </trans-unit>
        <trans-unit id="71613609aa61c62cf20cbe58dfba008b2ab16c3a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;format_temps&lt;/code&gt; is called the first time, &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; and &lt;code&gt;Rest&lt;/code&gt; is the rest of the list. So the function &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; is called.</source>
          <target state="translated">Когда &lt;code&gt;format_temps&lt;/code&gt; вызывается в первый раз, &lt;code&gt;City&lt;/code&gt; получает значение &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; , а &lt;code&gt;Rest&lt;/code&gt; - это оставшаяся часть списка. Так &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; функция print_temp (convert_to_celsius ({moscow, {c, -10}})) .</target>
        </trans-unit>
        <trans-unit id="5bb83110e8f27a779d6f37f6cb1a70e2e21776a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;handle_connect/2,3&lt;/code&gt; is triggered by an explicit call to &lt;code&gt;megaco:connect/4,5&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;handle_connect/2,3&lt;/code&gt; запускается явным вызовом &lt;code&gt;megaco:connect/4,5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672bdd7739faf4a0068adc26b9d59100e10bc739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;httpd&lt;/code&gt; is shut down, it tries to execute &lt;code&gt;remove/1&lt;/code&gt; in each Erlang web server callback module. The programmer can use this function to clean up resources created in the store function.</source>
          <target state="translated">Когда &lt;code&gt;httpd&lt;/code&gt; завершается, он пытается выполнить &lt;code&gt;remove/1&lt;/code&gt; в каждом модуле обратного вызова веб-сервера Erlang. Программист может использовать эту функцию для очистки ресурсов, созданных в функции хранилища.</target>
        </trans-unit>
        <trans-unit id="e34c8eb52d34fbd9a9b37c654c599a9d1639ad3b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;make install&lt;/code&gt; has finished, change directory into &lt;code&gt;$DESTDIR&lt;/code&gt;, package the system, move it to the target machine, and unpack it. Note that the installation will only be working on the target machine at the location determined by &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;make install&lt;/code&gt; будет завершена, перейдите в каталог &lt;code&gt;$DESTDIR&lt;/code&gt; , упакуйте систему, переместите ее на целевой компьютер и распакуйте. Обратите внимание, что установка будет работать только на целевой машине в месте, определенном &lt;code&gt;configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6458c29bc8527ea3593b744f1b95db5d14bc00a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;schema_location&lt;/code&gt; is set to &lt;code&gt;opt_disc&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; can be used to change the storage type of the schema. This is illustrated as follows:</source>
          <target state="translated">Когда &lt;code&gt;schema_location&lt;/code&gt; имеет значение &lt;code&gt;opt_disc&lt;/code&gt; , функция &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; может использоваться для изменения типа хранения схемы. Это проиллюстрировано следующим образом:</target>
        </trans-unit>
        <trans-unit id="8f7039593357562dd4f3df83c986379cb1c6cf4e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sys:get_status/1,2&lt;/code&gt; is called, &lt;code&gt;gen_event&lt;/code&gt; ensures that its return value contains &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">Когда &lt;code&gt;sys:get_status/1,2&lt;/code&gt; , &lt;code&gt;gen_event&lt;/code&gt; гарантирует, что его возвращаемое значение содержит &lt;code&gt;Status&lt;/code&gt; вместо термина состояния обработчика события.</target>
        </trans-unit>
        <trans-unit id="5455489a72db154806b1402161102765e042f513" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_ack_maxcount&lt;/code&gt; number of ack's has been received.</source>
          <target state="translated">Когда было &lt;code&gt;trans_ack_maxcount&lt;/code&gt; количество подтверждений.</target>
        </trans-unit>
        <trans-unit id="2d6f023a935d787f78f929b26ccb79c057c7e544" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_req_maxcount&lt;/code&gt; number of requests's has been received.</source>
          <target state="translated">Когда было &lt;code&gt;trans_req_maxcount&lt;/code&gt; количество запросов.</target>
        </trans-unit>
        <trans-unit id="4691b74e02fcb2a43c31be2ce08725b89f8c00a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_timer&lt;/code&gt; expires.</source>
          <target state="translated">Когда истечет время &lt;code&gt;trans_timer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f62e8b515ecdd9f175ebeef24a151629f33f401" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, exit signals arriving to a process are converted to &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; messages, which can be received as ordinary messages. If &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, the process exits if it receives an exit signal other than &lt;code&gt;normal&lt;/code&gt; and the exit signal is propagated to its linked processes. Application processes are normally not to trap exits.</source>
          <target state="translated">Когда &lt;code&gt;trap_exit&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , сигналы выхода, поступающие в процесс, преобразуются в сообщения &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; , которые могут быть получены как обычные сообщения. Если &lt;code&gt;trap_exit&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , процесс завершается, если он получает сигнал выхода, отличный от &lt;code&gt;normal&lt;/code&gt; и сигнал выхода распространяется на связанные процессы. Прикладные процессы обычно не задерживают выходов.</target>
        </trans-unit>
        <trans-unit id="fb45a25cdcc4004483ae5e0296eb6055f647d85a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, sent multicast packets are looped back to the local sockets.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , отправленные многоадресные пакеты возвращаются в локальные сокеты.</target>
        </trans-unit>
        <trans-unit id="10db437ea36ac965fd403789d69242cf01a29208" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;{active, true}&lt;/code&gt;, data is delivered on the form &lt;code&gt;port&lt;/code&gt; : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; or &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;{active, true}&lt;/code&gt; , данные доставляются через &lt;code&gt;port&lt;/code&gt; формы : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; или &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50818e5b2ee1eb06b98eca2c46320af1c49650c8" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;ActualReason&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">Если &lt;strong&gt;причина&lt;/strong&gt; равна &lt;strong&gt;{send_failed, ...},&lt;/strong&gt; это означает, что процессу net_if не удалось отправить сообщение. Это могло произойти по любому количеству причин, например, ошибка кодирования. &lt;strong&gt;ActualReason&lt;/strong&gt; является истинной причиной в данном случае.</target>
        </trans-unit>
        <trans-unit id="9f41f432bb6d6b04eaeac809774055cb313c3684" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;R&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">Если &lt;strong&gt;причина&lt;/strong&gt; равна &lt;strong&gt;{send_failed, ...},&lt;/strong&gt; это означает, что процессу net_if не удалось отправить сообщение. Это могло произойти по любому количеству причин, например, ошибка кодирования. Фактическая причина в этом случае - &lt;strong&gt;R.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8aec189a88e9a30ca27fcd657c83b4b7d31fa73" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;var_and_val()&lt;/strong&gt; is &lt;strong&gt;{oid(), value()}&lt;/strong&gt;, the manager makes an educated guess based on the loaded mibs.</source>
          <target state="translated">Когда &lt;strong&gt;var_and_val ()&lt;/strong&gt; равно &lt;strong&gt;{oid (), value ()}&lt;/strong&gt; , менеджер делает обоснованное предположение на основе загруженных mib.</target>
        </trans-unit>
        <trans-unit id="ccaef80e646aaabd78d92b0630d31df5f39a479a" translate="yes" xml:space="preserve">
          <source>When Cover is stopped, all Cover compiled modules are unloaded.</source>
          <target state="translated">Когда Cover останавливается,все скомпилированные Cover модули выгружаются.</target>
        </trans-unit>
        <trans-unit id="ce23e1563e5351f589159eb5b770cd3cbd2e8d8c" translate="yes" xml:space="preserve">
          <source>When Debugger is started in global mode (which is the default, see &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt;), modules added (or deleted) for interpretation are added (or deleted) on all known Erlang nodes.</source>
          <target state="translated">Когда отладчик запускается в глобальном режиме (который используется по умолчанию, см. Debugger &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt; ), модули, добавленные (или удаленные) для интерпретации, добавляются (или удаляются) на всех известных узлах Erlang.</target>
        </trans-unit>
        <trans-unit id="ab8c9662238adfc3364171ed2abae67b6db526e0" translate="yes" xml:space="preserve">
          <source>When EDNS is enabled (resolver option &lt;code&gt;edns&lt;/code&gt; is set to the EDNS version (that is, &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;false&lt;/code&gt;), resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; sets the limit. If a name server replies with the TC bit set (truncation), indicating that the answer is incomplete, the query is retried to that name server using TCP. Resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; also sets the advertised size for the maximum allowed reply size, if EDNS is enabled, otherwise the name server uses the limit 512 bytes. If the reply is larger, it gets truncated, forcing a TCP requery.</source>
          <target state="translated">Когда EDNS включен (параметр преобразователя &lt;code&gt;edns&lt;/code&gt; установлен на версию EDNS (то есть &lt;code&gt;0&lt;/code&gt; вместо &lt;code&gt;false&lt;/code&gt; ), параметр преобразователя &lt;code&gt;udp_payload_size&lt;/code&gt; устанавливает предел. Если сервер имен отвечает установленным битом TC (усечение), указывая, что ответ неполный, запрос повторяется к этому серверу имен с помощью TCP. &lt;code&gt;udp_payload_size&lt;/code&gt; также устанавливает объявленный размер для максимально допустимого размера ответа, если EDNS включен, в противном случае сервер имен использует ограничение в 512 байт. Если ответ больше, он усекается, вызывая запрос TCP.</target>
        </trans-unit>
        <trans-unit id="360f7568d87827777af3aa56a826957938118e43" translate="yes" xml:space="preserve">
          <source>When EUnit traverses the test representation in order to run the tests, the new generator will not be called to produce the next test until the previous test has been executed.</source>
          <target state="translated">Когда EUnit пройдет через тестовое представление для запуска тестов,новый генератор не будет вызван для создания следующего теста,пока не будет выполнен предыдущий тест.</target>
        </trans-unit>
        <trans-unit id="f08e2448799430bb11532279edecae41a087b4a7" translate="yes" xml:space="preserve">
          <source>When Erlang is started with &lt;code&gt;-oldshell&lt;/code&gt; or &lt;code&gt;-noshell&lt;/code&gt;, the I/O server for &lt;code&gt;standard_io&lt;/code&gt; is by default set to bytewise encoding, while an interactive shell defaults to what the environment variables says.</source>
          <target state="translated">Когда Erlang запускается с &lt;code&gt;-oldshell&lt;/code&gt; или &lt;code&gt;-noshell&lt;/code&gt; , сервер ввода-вывода для &lt;code&gt;standard_io&lt;/code&gt; по умолчанию настроен на побайтное кодирование, в то время как интерактивная оболочка по умолчанию использует то, что говорят переменные среды.</target>
        </trans-unit>
        <trans-unit id="e501fa18494f297571df6ce7eaf406fc86c93dea" translate="yes" xml:space="preserve">
          <source>When Erlang starts up it reads the Kernel variable &lt;code&gt;inetrc&lt;/code&gt;, which, if defined, is to specify the location and name of a user configuration file. Example:</source>
          <target state="translated">Когда Erlang запускается, он читает переменную ядра &lt;code&gt;inetrc&lt;/code&gt; , которая, если она определена, должна указывать местоположение и имя файла конфигурации пользователя. Пример:</target>
        </trans-unit>
        <trans-unit id="128caf28b58716150fb0bb58c207dbe8dd83fd4e" translate="yes" xml:space="preserve">
          <source>When Erlang was designed, it was assumed that the wall clock time in the system showed a monotonic time moving forward at exactly the same pace as the definition of time. This more or less meant that an atomic clock (or better time source) was expected to be attached to your hardware and that the hardware was then expected to be locked away from any human tinkering forever. While this can be a compelling thought, it is simply never the case.</source>
          <target state="translated">При проектировании Эрланга предполагалось,что время настенных часов в системе показывало монотонное время,движущееся вперед с точно такой же скоростью,как и определение времени.Это более или менее означало,что атомные часы (или лучший источник времени)должны были быть прикреплены к вашему оборудованию,и что тогда оборудование должно было быть навсегда заблокировано от любой человеческой суеты.Хотя это может быть убедительной мыслью,это просто никогда не бывает так.</target>
        </trans-unit>
        <trans-unit id="50fa1c320969db01352828d7fe383abc4a1895e0" translate="yes" xml:space="preserve">
          <source>When Erlang/OTP is started, the system searches for a file named &lt;code&gt;.erlang&lt;/code&gt; in the user's home directory.</source>
          <target state="translated">При запуске Erlang / OTP система ищет файл с именем &lt;code&gt;.erlang&lt;/code&gt; в домашнем каталоге пользователя.</target>
        </trans-unit>
        <trans-unit id="f3f71d6c7e7a2c0c5ada3244d6eb663b401f9b01" translate="yes" xml:space="preserve">
          <source>When PER is used, there is a significant difference in the encoding scheme between &lt;code&gt;OCTET STRING&lt;/code&gt;s and other strings. The constraints specified for a type are especially important for PER, where they affect the encoding.</source>
          <target state="translated">Когда используется PER, существует значительная разница в схеме кодирования между &lt;code&gt;OCTET STRING&lt;/code&gt; и другими строками. Ограничения, указанные для типа, особенно важны для PER, поскольку они влияют на кодировку.</target>
        </trans-unit>
        <trans-unit id="1b03f5d92803d36900a526928289b233412ad464" translate="yes" xml:space="preserve">
          <source>When SSL/TLS performs certificate path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; it should also perform CRL validation checks. To enable the CRL checks the application needs access to CRLs. A database of CRLs can be set up in many different ways. This module provides the behavior of the API needed to integrate an arbitrary CRL cache with the erlang ssl application. It is also used by the application itself to provide a simple default implementation of a CRL cache.</source>
          <target state="translated">Когда SSL / TLS выполняет проверку пути сертификата в соответствии с &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; , он также должен выполнять проверки проверки CRL. Чтобы включить проверки CRL, приложению необходим доступ к CRL. База данных списков отзыва сертификатов может быть создана разными способами. Этот модуль обеспечивает поведение API, необходимое для интеграции произвольного кеша CRL с приложением erlang ssl. Он также используется самим приложением, чтобы обеспечить простую реализацию по умолчанию кэша CRL.</target>
        </trans-unit>
        <trans-unit id="d27327d683c2a19be0af9413a3ffb06c50231cc3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Addr&lt;/code&gt; is not specified i.e by using only a &lt;code&gt;Domain&lt;/code&gt; atom, the host's name is resolved to find the IP address, and the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">Когда &lt;code&gt;Addr&lt;/code&gt; не указан, то есть с использованием только атома &lt;code&gt;Domain&lt;/code&gt; , имя хоста разрешается, чтобы найти IP-адрес, и используется значение &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dab5adc2b60fbe4714b50e24055b1753a3e2460" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CHOICE&lt;/code&gt; contains an extension marker and the decoder detects an unknown alternative of the &lt;code&gt;CHOICE&lt;/code&gt;, the value is represented as follows:</source>
          <target state="translated">Когда &lt;code&gt;CHOICE&lt;/code&gt; содержит маркер расширения, а декодер обнаруживает неизвестную альтернативу &lt;code&gt;CHOICE&lt;/code&gt; , значение представляется следующим образом:</target>
        </trans-unit>
        <trans-unit id="8d1d4d39dc5b42bbde592ff2e91a12f51026609b" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SEQUENCE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt; contains an extension marker and extension components as the following, the type can get more components in newer versions of the ASN.1 spec:</source>
          <target state="translated">Когда &lt;code&gt;SEQUENCE&lt;/code&gt; или &lt;code&gt;SET&lt;/code&gt; содержат маркер расширения и компоненты расширения, как показано ниже, тип может получить больше компонентов в более новых версиях спецификации ASN.1:</target>
        </trans-unit>
        <trans-unit id="6259eac0d0652866c8be2d5774deb52d326c9816" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered, a &lt;code&gt;'DOWN'&lt;/code&gt; message is sent that has the following pattern:</source>
          <target state="translated">Когда запускается монитор &lt;code&gt;process&lt;/code&gt; или &lt;code&gt;port&lt;/code&gt; отправляется сообщение &lt;code&gt;'DOWN'&lt;/code&gt; , имеющее следующий шаблон:</target>
        </trans-unit>
        <trans-unit id="dabb982d5bde66066a06ee6a787d40663b30219a" translate="yes" xml:space="preserve">
          <source>When a NETCONF server receives a &lt;code&gt;close-session&lt;/code&gt; request, it gracefully closes the session. The server releases any locks and resources associated with the session and gracefully closes any associated connections. Any NETCONF requests received after a &lt;code&gt;close-session&lt;/code&gt; request are ignored.</source>
          <target state="translated">Когда сервер NETCONF получает запрос на &lt;code&gt;close-session&lt;/code&gt; , он корректно закрывает сеанс. Сервер снимает любые блокировки и ресурсы, связанные с сеансом, и корректно закрывает все связанные подключения. Любые запросы NETCONF, полученные после запроса &lt;code&gt;close-session&lt;/code&gt; , игнорируются.</target>
        </trans-unit>
        <trans-unit id="6aef919ab5c9d7ca0a1f781798e898aede6e2d15" translate="yes" xml:space="preserve">
          <source>When a NIF library is built, information about the NIF API version is compiled into the library. When a NIF library is loaded, the runtime system verifies that the library is of a compatible version. &lt;code&gt;erl_nif.h&lt;/code&gt; defines the following:</source>
          <target state="translated">При создании библиотеки NIF информация о версии NIF API компилируется в библиотеку. Когда загружается библиотека NIF, система времени выполнения проверяет, имеет ли библиотека совместимую версию. &lt;code&gt;erl_nif.h&lt;/code&gt; определяет следующее:</target>
        </trans-unit>
        <trans-unit id="618a279b6e67c1feb5bfb9caf244cc07fcd0fd4b" translate="yes" xml:space="preserve">
          <source>When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after</source>
          <target state="translated">При повторном захвате подмаски,захваченное значение является той подстрокой,которая соответствовала окончательной итерации.Например,после</target>
        </trans-unit>
        <trans-unit id="a65b284abe74e6a02c174667276a95aa7be67345" translate="yes" xml:space="preserve">
          <source>When a client checks a server certificate there are a number of checks available like checks that the certificate is not revoked, not forged or not out-of-date.</source>
          <target state="translated">Когда клиент проверяет сертификат сервера,есть ряд доступных проверок,таких как проверка того,что сертификат не отозван,не подделан или не устарел.</target>
        </trans-unit>
        <trans-unit id="3aadc5d6a9fff7e5e64260bfe5a84b55671b941b" translate="yes" xml:space="preserve">
          <source>When a combining transaction writes with &quot;dirty_reads&quot;, that is, the functions &lt;code&gt;dirty_match_object&lt;/code&gt;, &lt;code&gt;dirty_read&lt;/code&gt;, &lt;code&gt;dirty_index_read&lt;/code&gt;, &lt;code&gt;dirty_select&lt;/code&gt;, and so on.</source>
          <target state="translated">Когда объединяющая транзакция записывает &quot;dirty_reads&quot;, то есть функции &lt;code&gt;dirty_match_object&lt;/code&gt; , &lt;code&gt;dirty_read&lt;/code&gt; , &lt;code&gt;dirty_index_read&lt;/code&gt; , &lt;code&gt;dirty_select&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="1a2b39b4ebe51a72b88123d3bad51bb926bc1540" translate="yes" xml:space="preserve">
          <source>When a complete sequence of valid events has been received, the result is returned as a list of letters.</source>
          <target state="translated">После получения полной последовательности действительных событий результат возвращается в виде списка букв.</target>
        </trans-unit>
        <trans-unit id="3ab3080f29934aab21a3904dcbbbf54ca9667260" translate="yes" xml:space="preserve">
          <source>When a configuration function fails (that is, terminates unexpectedly), the test cases depending on the configuration function are skipped automatically by &lt;code&gt;Common Test&lt;/code&gt;. The status of the test cases is then &quot;auto-skipped&quot;. Test cases are also &quot;auto-skipped&quot; by &lt;code&gt;Common Test&lt;/code&gt; if the required configuration data is unavailable at runtime.</source>
          <target state="translated">Когда функция конфигурации не работает (то есть неожиданно завершается), тестовые примеры, зависящие от функции конфигурации, автоматически пропускаются &lt;code&gt;Common Test&lt;/code&gt; . Статус тестовых случаев затем &amp;laquo;автоматически пропускается&amp;raquo;. Тестовые наборы также автоматически пропускаются &lt;code&gt;Common Test&lt;/code&gt; , если необходимые данные конфигурации недоступны во время выполнения.</target>
        </trans-unit>
        <trans-unit id="a5b5a638207ad9c6b58bc05153489fdb31694f0d" translate="yes" xml:space="preserve">
          <source>When a configuration variable name is used as reference to the data specifying the connection, the handle returned as a result of opening the connection must be used in all subsequent calls (also for closing the connection). Repeated calls to the open function with the same variable name as reference results in multiple connections being opened. This can be useful, for example, if a test case needs to open multiple connections to the same server on the target node (using the same configuration data for each connection).</source>
          <target state="translated">Когда имя конфигурационной переменной используется в качестве ссылки на данные,указывающие на соединение,ручка,возвращенная в результате открытия соединения,должна использоваться во всех последующих вызовах (также для закрытия соединения).При многократных вызовах функции open с тем же именем переменной,что и ссылка,открывается несколько соединений.Это может быть полезно,например,если в тестовом случае необходимо открыть несколько соединений с одним и тем же сервером на целевом узле (используя одни и те же данные конфигурации для каждого соединения).</target>
        </trans-unit>
        <trans-unit id="a40f1ad1022ce7c7ff4a72defc83b1ece3312d0f" translate="yes" xml:space="preserve">
          <source>When a correct code has been given, the door is unlocked and the following tuple is returned from &lt;code&gt;locked/2&lt;/code&gt;:</source>
          <target state="translated">Когда введен правильный код, дверь разблокируется, и из &lt;code&gt;locked/2&lt;/code&gt; возвращается следующий кортеж :</target>
        </trans-unit>
        <trans-unit id="6c237674f28de05213f857e3fa04838ee21db142" translate="yes" xml:space="preserve">
          <source>When a directory is added to the code path and when the entire code path is (re)set, the code server decides which subdirectories in an application that are to be read from the archive and which that are to be read as regular files. If directories are added or removed afterwards, the file access can fail if the code path is not updated (possibly to the same path as before, to trigger the directory resolution update).</source>
          <target state="translated">Когда каталог добавляется в путь к коду и когда весь путь к коду (ре)устанавливается,сервер кода решает,какие подкаталоги в приложении должны быть прочитаны из архива и какие должны быть прочитаны как обычные файлы.Если после этого каталоги добавляются или удаляются,то доступ к файлам может не состояться,если путь к коду не обновляется (возможно,по тому же самому пути,что и раньше,чтобы инициировать обновление разрешения каталога).</target>
        </trans-unit>
        <trans-unit id="08512ee349a9c8aac50037692c41425ea5af4861" translate="yes" xml:space="preserve">
          <source>When a disk log is opened in read-write mode, any existing log file is checked for. If there is none, a new empty log is created, otherwise the existing file is opened at the position after the last logged item, and the logging of items starts from there. If the format is &lt;code&gt;internal&lt;/code&gt; and the existing file is not recognized as an internally formatted log, a tuple &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; is returned.</source>
          <target state="translated">Когда журнал диска открывается в режиме чтения-записи, проверяется наличие любого существующего файла журнала. Если его нет, создается новый пустой журнал, в противном случае существующий файл открывается в позиции после последнего зарегистрированного элемента, и регистрация элементов начинается оттуда. Если формат является &lt;code&gt;internal&lt;/code&gt; и существующий файл не распознается как журнал с внутренним форматом, возвращается кортеж &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd89c709c241e9c3808c6d9ef3bbf0c663231656" translate="yes" xml:space="preserve">
          <source>When a distributed node is started it registers itself in the EPMD. The message &lt;code&gt;ALIVE2_REQ&lt;/code&gt; described below is sent from the node to the EPMD. The response from the EPMD is &lt;code&gt;ALIVE2_RESP&lt;/code&gt;.</source>
          <target state="translated">Когда распределенный узел запускается, он регистрируется в EPMD. &lt;code&gt;ALIVE2_REQ&lt;/code&gt; ниже сообщение ALIVE2_REQ отправляется от узла к EPMD. Ответ от EPMD - &lt;code&gt;ALIVE2_RESP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a52fed0cfcde5066a985fe2bdb039481aa8004a" translate="yes" xml:space="preserve">
          <source>When a driver creates a monitor for a process, a &lt;code&gt;ErlDrvMonitor&lt;/code&gt; is filled in. This is an opaque data type that can be assigned to, but not compared without using the supplied compare function (that is, it behaves like a struct).</source>
          <target state="translated">Когда драйвер создает монитор для процесса, &lt;code&gt;ErlDrvMonitor&lt;/code&gt; . Это непрозрачный тип данных, которому можно назначить, но нельзя сравнивать без использования предоставленной функции сравнения (то есть он ведет себя как структура).</target>
        </trans-unit>
        <trans-unit id="7d91cc2fa6325a0dec9adb1ac103e1c55c09f52b" translate="yes" xml:space="preserve">
          <source>When a driver is loaded it is executed in the context of the emulator, shares the same memory and the same thread. This means that all operations in the driver must be non-blocking, and that any crash in the driver brings the whole emulator down. In short, be careful.</source>
          <target state="translated">Когда драйвер загружен,он выполняется в контексте эмулятора,совместно использует одну и ту же память и один и тот же поток.Это означает,что все операции в драйвере должны быть неблокирующими,и любой сбой в драйвере приводит к падению всего эмулятора.Одним словом,будьте осторожны.</target>
        </trans-unit>
        <trans-unit id="23ef058276dd33859a9cf8494fcadec228e0e9ee" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for input. This callback is called when the emulator detects input on a file descriptor that the driver has marked for monitoring by using the interface &lt;code&gt;driver_select&lt;/code&gt;. The mechanism of driver select makes it possible to read non-blocking from file descriptors by calling &lt;code&gt;driver_select&lt;/code&gt; when reading is needed, and then do the reading in this callback (when reading is possible). The typical scenario is that &lt;code&gt;driver_select&lt;/code&gt; is called when an Erlang process orders a read operation, and that this routine sends the answer when data is available on the file descriptor.</source>
          <target state="translated">Когда дескриптор файла сигнализируется для ввода. Этот обратный вызов вызывается, когда эмулятор обнаруживает ввод в файловом дескрипторе, который драйвер пометил для мониторинга с помощью интерфейса &lt;code&gt;driver_select&lt;/code&gt; . Механизм выбора драйвера позволяет читать неблокирующее из файловых дескрипторов, вызывая &lt;code&gt;driver_select&lt;/code&gt; , когда требуется чтение, а затем выполнять чтение в этом обратном вызове (когда чтение возможно). Типичный сценарий состоит в том, что &lt;code&gt;driver_select&lt;/code&gt; вызывается, когда процесс Erlang заказывает операцию чтения, и эта подпрограмма отправляет ответ, когда данные доступны в файловом дескрипторе.</target>
        </trans-unit>
        <trans-unit id="a679df0f77926839147106039935be1d682ca28a" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for output. This callback is called in a similar way as the previous, but when writing to a file descriptor is possible. The usual scenario is that Erlang orders writing on a file descriptor and that the driver calls &lt;code&gt;driver_select&lt;/code&gt;. When the descriptor is ready for output, this callback is called and the driver can try to send the output. Queuing can be involved in such operations, and there are convenient queue routines available to the driver writer to use.</source>
          <target state="translated">Когда дескриптор файла сигнализируется для вывода. Этот обратный вызов вызывается аналогично предыдущему, но при записи в файловый дескриптор возможна. Обычный сценарий заключается в том, что Erlang заказывает запись в файловый дескриптор, а драйвер вызывает &lt;code&gt;driver_select&lt;/code&gt; . Когда дескриптор готов к выводу, вызывается этот обратный вызов, и драйвер может попытаться отправить вывод. В таких операциях может быть задействована организация очередей, и разработчику драйвера доступны удобные процедуры очереди.</target>
        </trans-unit>
        <trans-unit id="cff5a25a671ee65d3e016e0e72ebcef87ec1e190" translate="yes" xml:space="preserve">
          <source>When a file is saved the name in the &lt;code&gt;-module().&lt;/code&gt; line is checked against the file name. Should they mismatch Emacs can change the module specifier so that it matches the file name. By default, the user is asked before the change is performed.</source>
          <target state="translated">Когда файл сохраняется, имя в &lt;code&gt;-module().&lt;/code&gt; строка проверяется по имени файла. Если они не совпадают, Emacs может изменить спецификатор модуля так, чтобы он соответствовал имени файла. По умолчанию перед внесением изменения пользователю предлагается запрос.</target>
        </trans-unit>
        <trans-unit id="3f363e70739be22c64648901764e5ee5e3346b81" translate="yes" xml:space="preserve">
          <source>When a filter includes the &lt;code&gt;no&lt;/code&gt; atom, it excludes the reports that match that filter.</source>
          <target state="translated">Когда фильтр не включает в себя &lt;code&gt;no&lt;/code&gt; атома, он исключает отчеты , которые соответствуют этому фильтру.</target>
        </trans-unit>
        <trans-unit id="11b080dca26694157c4bd883a5fe6d59a076fa4f" translate="yes" xml:space="preserve">
          <source>When a function &lt;code&gt;m:f/N&lt;/code&gt; is called, first the code for the function is located. If the function cannot be found, an &lt;code&gt;undef&lt;/code&gt; runtime error occurs. Notice that the function must be exported to be visible outside the module it is defined in.</source>
          <target state="translated">Когда вызывается функция &lt;code&gt;m:f/N&lt;/code&gt; , сначала находится код функции. Если функция не может быть найдена, возникает ошибка времени выполнения &lt;code&gt;undef&lt;/code&gt; . Обратите внимание, что функция должна быть экспортирована, чтобы быть видимой за пределами модуля, в котором она определена.</target>
        </trans-unit>
        <trans-unit id="74208e09de14be7d14103a45ed652bc9fc053707" translate="yes" xml:space="preserve">
          <source>When a function defined elsewhere is used as a fun, it can be referred to as &lt;code&gt;Function/Arity&lt;/code&gt; (remember that &lt;code&gt;Arity&lt;/code&gt; = number of arguments). So in the &lt;code&gt;map&lt;/code&gt;-call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; is written. As shown, &lt;code&gt;convert_list_to_c&lt;/code&gt; becomes much shorter and easier to understand.</source>
          <target state="translated">Когда функция, определенная в другом месте, используется как развлечение, ее можно назвать &lt;code&gt;Function/Arity&lt;/code&gt; (помните, что &lt;code&gt;Arity&lt;/code&gt; = количество аргументов). Итак, в &lt;code&gt;map&lt;/code&gt; -call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; написано. Как показано, &lt;code&gt;convert_list_to_c&lt;/code&gt; становится намного короче и проще для понимания.</target>
        </trans-unit>
        <trans-unit id="74001e8b9e330c78c97c92b41f6d0fc8532d215e" translate="yes" xml:space="preserve">
          <source>When a function is inlined, the original function is kept if it is exported (either by an explicit export or if the option &lt;code&gt;export_all&lt;/code&gt; was given) or if not all calls to the function are inlined.</source>
          <target state="translated">Когда функция встроена, исходная функция сохраняется, если она экспортируется (либо путем явного экспорта, либо если &lt;code&gt;export_all&lt;/code&gt; опция export_all ), или если не все вызовы функции встроены.</target>
        </trans-unit>
        <trans-unit id="f80601e5580fc09c93533fc9ff760c5048491df1" translate="yes" xml:space="preserve">
          <source>When a functional module has been changed, for example, if a new function has been added or a bug has been corrected, simple code replacement is sufficient, for example:</source>
          <target state="translated">При изменении функционального модуля,например,при добавлении новой функции или исправлении ошибки,достаточно простой замены кода:</target>
        </trans-unit>
        <trans-unit id="177c42f544b61e4f56d8eebb388d0ad5082dd374" translate="yes" xml:space="preserve">
          <source>When a grammar rule is used by the parser to parse (part of) the input string as a grammatical phrase, the associated code is evaluated, and the value of the last expression becomes the value of the parsed phrase. This value may be used by the parser later to build structures that are values of higher phrases of which the current phrase is a part. The values initially associated with terminal category phrases, i.e. input tokens, are the token tuples themselves.</source>
          <target state="translated">При использовании грамматического правила парсером для разбора (части)входной строки в качестве грамматической фразы вычисляется соответствующий код,а значение последнего выражения становится значением обработанной фразы.Это значение может быть впоследствии использовано синтаксическим анализатором для построения структур,являющихся значениями более высоких фраз,частью которых является текущая фраза.Значения,изначально связанные с терминальными фразами категории,т.е.входными токенами,являются сами токеновыми кортежами.</target>
        </trans-unit>
        <trans-unit id="b974112391a6bf5f0b5186bac330512807e3d96c" translate="yes" xml:space="preserve">
          <source>When a group of subtrees (as e.g., the argument list of an &lt;code&gt;application&lt;/code&gt; node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by &lt;code&gt;Node&lt;/code&gt; even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if &lt;code&gt;Tree&lt;/code&gt; represents a list of integers &quot;&lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt;&quot;, the result of &lt;code&gt;limit(Tree, 5)&lt;/code&gt; will represent &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt;.</source>
          <target state="translated">Когда группа поддеревьев (например, список аргументов узла &lt;code&gt;application&lt;/code&gt; ) находится на указанной глубине и в группе есть два или более поддерева, они будут все вместе заменены &lt;code&gt;Node&lt;/code&gt; даже если они являются конечными узлами. Группы поддеревьев, превышающие заданную глубину, будут ограничены по размеру, как если бы каждое последующее дерево в группе было на один уровень глубже предыдущего. Например, если &lt;code&gt;Tree&lt;/code&gt; представляет собой список целых чисел &amp;laquo; &lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt; &amp;raquo;, результат &lt;code&gt;limit(Tree, 5)&lt;/code&gt; будет представлять &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546a7cd5ad3598834756b341e22241b28b75ab4c" translate="yes" xml:space="preserve">
          <source>When a halt log has reached its maximum size, all attempts to log more items are rejected. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which for halt implies that there is no maximum size.</source>
          <target state="translated">Когда журнал останова достиг максимального размера, все попытки записать в журнал другие элементы отклоняются. По умолчанию - &lt;code&gt;infinity&lt;/code&gt; , что для остановки означает, что максимального размера нет.</target>
        </trans-unit>
        <trans-unit id="0173ad86ffa8dc5a72f7880331dbb41cadacb3d5" translate="yes" xml:space="preserve">
          <source>When a handler is added, by for example a call to &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt;, Logger first calls &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,Config1}&lt;/code&gt;, Logger writes &lt;code&gt;Config1&lt;/code&gt; to the configuration database, and the &lt;code&gt;logger:add_handler/3&lt;/code&gt; call returns. After this, the handler is installed and must be ready to receive log events as calls to &lt;code&gt;HModule:log/2&lt;/code&gt;.</source>
          <target state="translated">Когда добавляется обработчик, например, посредством вызова &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt; , Logger сначала вызывает &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt; . Если эта функция возвращает &lt;code&gt;{ok,Config1}&lt;/code&gt; , Logger записывает &lt;code&gt;Config1&lt;/code&gt; в базу данных конфигурации, а вызов &lt;code&gt;logger:add_handler/3&lt;/code&gt; возвращается. После этого обработчик установлен и должен быть готов к приему событий журнала в виде вызовов &lt;code&gt;HModule:log/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b3fa26b8c4473c5e6353f135f20edbe40b9dc4c" translate="yes" xml:space="preserve">
          <source>When a line ending is defined as a single character, dot never matches that character. When the two-character sequence CRLF is used, dot does not match CR if it is immediately followed by LF, otherwise it matches all characters (including isolated CRs and LFs). When any Unicode line endings are recognized, dot does not match CR, LF, or any of the other line-ending characters.</source>
          <target state="translated">Когда окончание строки определяется как один символ,точка никогда не совпадает с этим символом.При использовании двухсимвольной последовательности CRLF точка не совпадает с CR,если за ней сразу следует LF,в противном случае она совпадает со всеми символами (включая изолированные CR и LF).При распознавании любых окончаний строк Юникода точка не совпадает с CR,LF или любым другим символом конца строки.</target>
        </trans-unit>
        <trans-unit id="c40d296ef828ecaf94ab88122caa6be54ba75b8f" translate="yes" xml:space="preserve">
          <source>When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; is specified as &lt;code&gt;Pattern&lt;/code&gt;, this means either &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt;&quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant.</source>
          <target state="translated">Когда указан список двоичных файлов, он обозначает набор альтернативных двоичных файлов для поиска. Например, если &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; указан как &lt;code&gt;Pattern&lt;/code&gt; , это означает &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt; &quot;. набор альтернатив; когда указан только один двоичный файл, набор имеет только один элемент.Порядок альтернатив в шаблоне не имеет значения.</target>
        </trans-unit>
        <trans-unit id="5e35511e71a7b0fd611ce8579dd128d7b017ba30" translate="yes" xml:space="preserve">
          <source>When a log file is opened (for appending or created), a time stamp is written to the file. If nothing has been written to the log files for 15 minutes, a record is inserted that says that we are still alive.</source>
          <target state="translated">При открытии лог-файла (для добавления или создания)в него записывается временная метка.Если в течение 15 минут в лог-файл ничего не было записано,то в него вставляется запись о том,что мы еще живы.</target>
        </trans-unit>
        <trans-unit id="06e4937e775c2f940892fdab2739edda1362aa4d" translate="yes" xml:space="preserve">
          <source>When a log macro is used, Logger also inserts location information:</source>
          <target state="translated">При использовании макроса журнала журнал также вставляет информацию о местоположении:</target>
        </trans-unit>
        <trans-unit id="aad0f82e057ba4854abcfc52c2eb835c19bd6591" translate="yes" xml:space="preserve">
          <source>When a managed object is referenced in an SNMP operation, the associated &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; is called. The function is applied to some standard arguments (for example, the operation type) and the extra arguments supplied by the user.</source>
          <target state="translated">Когда управляемый объект упоминается в операции SNMP &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; связанный {Module, Function, ListOfExtraArguments} . Функция применяется к некоторым стандартным аргументам (например, типу операции) и дополнительным аргументам, предоставленным пользователем.</target>
        </trans-unit>
        <trans-unit id="1bea9285e0f879b126068ba7917e2a2ade25429d" translate="yes" xml:space="preserve">
          <source>When a manager makes a request to the agent, the following illustrates the situation:</source>
          <target state="translated">Когда менеджер делает запрос агенту,ситуация иллюстрируется следующим образом:</target>
        </trans-unit>
        <trans-unit id="092784e3d7c652eb428c18ea5b4a28b1c8500ff7" translate="yes" xml:space="preserve">
          <source>When a match succeeds, the name of the last encountered (*MARK:NAME), (*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed back to the caller as described in section &quot;Extra data for &lt;code&gt;pcre_exec()&lt;/code&gt;&quot; in the &lt;code&gt;pcreapi&lt;/code&gt; documentation. In the following example of &lt;code&gt;pcretest&lt;/code&gt; output, the /K modifier requests the retrieval and outputting of (*MARK) data:</source>
          <target state="translated">При успешном совпадении имя последнего встреченного (* MARK: NAME), (* PRUNE: NAME) или (* THEN: NAME) в соответствующем пути передается обратно вызывающей стороне, как описано в разделе &amp;laquo;Дополнительные данные для &lt;code&gt;pcre_exec()&lt;/code&gt; &quot;в документации &lt;code&gt;pcreapi&lt;/code&gt; . В следующем примере вывода &lt;code&gt;pcretest&lt;/code&gt; модификатор / K запрашивает получение и вывод данных (* MARK):</target>
        </trans-unit>
        <trans-unit id="b9ff74687968e879951bb5da792862457fd61b73" translate="yes" xml:space="preserve">
          <source>When a message has been received, it is the caller's responsibility to free the received message &lt;code&gt;emsg.msg&lt;/code&gt; and &lt;code&gt;emsg.to&lt;/code&gt; or &lt;code&gt;emsg.from&lt;/code&gt;, depending on the type of message received.</source>
          <target state="translated">Когда сообщение получено, вызывающий абонент обязан освободить полученное сообщение от &lt;code&gt;emsg.msg&lt;/code&gt; и &lt;code&gt;emsg.to&lt;/code&gt; или &lt;code&gt;emsg.from&lt;/code&gt; , в зависимости от типа полученного сообщения.</target>
        </trans-unit>
        <trans-unit id="4ed264eb2a6ed34dada4086d909002ae020169ab" translate="yes" xml:space="preserve">
          <source>When a message is received</source>
          <target state="translated">При получении сообщения</target>
        </trans-unit>
        <trans-unit id="8503be402b4e5542f8b3e1bb21c05d662a4228ff" translate="yes" xml:space="preserve">
          <source>When a message is sent to a process on another Erlang node, it is first encoded to the Erlang External Format before being sent through a TCP/IP socket. The receiving Erlang node decodes the message and distributes it to the correct process.</source>
          <target state="translated">Когда сообщение отправляется в процесс на другом узле Erlang,оно сначала кодируется во внешний формат Erlang,а затем отправляется через TCP/IP сокет.Принимающий узел Erlang декодирует сообщение и передает его в правильный процесс.</target>
        </trans-unit>
        <trans-unit id="551c8d852b503a0a48471c3cded481149fff350c" translate="yes" xml:space="preserve">
          <source>When a module is Cover compiled, it is also loaded using the normal code loading mechanism of Erlang. This means that if a Cover compiled module is re-loaded during a Cover session, for example using &lt;code&gt;c(Module)&lt;/code&gt;, it will no longer be Cover compiled.</source>
          <target state="translated">Когда модуль скомпилирован Cover, он также загружается с использованием обычного механизма загрузки кода Erlang. Это означает, что если скомпилированный модуль Cover повторно загружается во время сеанса Cover, например, с использованием &lt;code&gt;c(Module)&lt;/code&gt; , он больше не будет скомпилирован Cover.</target>
        </trans-unit>
        <trans-unit id="072f598e1ef5d76264967426b11622ee9dff185e" translate="yes" xml:space="preserve">
          <source>When a module is to be updated, the release handler finds which processes that are &lt;strong&gt;using&lt;/strong&gt; the module by traversing the supervision tree of each running application and checking all the child specifications:</source>
          <target state="translated">Когда модуль должен быть обновлен, обработчик выпуска находит, какие процессы &lt;strong&gt;используют&lt;/strong&gt; модуль, просматривая дерево надзора каждого запущенного приложения и проверяя все дочерние спецификации:</target>
        </trans-unit>
        <trans-unit id="9033ba75ed69bf751fa6e5b051720381187f258c" translate="yes" xml:space="preserve">
          <source>When a new OTP release is released it will have an OTP version on the form &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; where the major OTP version number equals the release number. The major version number is increased one step since the last major version. All other OTP versions with the same major OTP version number are patches on that OTP release.</source>
          <target state="translated">Когда выпускается новый выпуск OTP, он будет иметь версию OTP в форме &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; , где номер основной версии OTP равен номеру выпуска. Номер основной версии увеличивается на один шаг по сравнению с последней основной версией. Все другие версии OTP с тем же основным номером версии OTP являются исправлениями для этого выпуска OTP.</target>
        </trans-unit>
        <trans-unit id="cbbb4bde17a561149622c0549faa70bd0cd996df" translate="yes" xml:space="preserve">
          <source>When a new fun is defined in the shell, the value of the fun is printed as &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Когда в оболочке определяется новое развлечение, его значение печатается как &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a3c0fc498149078e34911c14f7a085c035bd806" translate="yes" xml:space="preserve">
          <source>When a new version of a release is installed, the application specifications are automatically updated for all loaded applications.</source>
          <target state="translated">При установке новой версии релиза технические характеристики приложения автоматически обновляются для всех загруженных приложений.</target>
        </trans-unit>
        <trans-unit id="1659bff51ef846577db0a731a65e27f0a6975ea2" translate="yes" xml:space="preserve">
          <source>When a node gets overloaded, it is not possible to issue &lt;code&gt;ttb:p/2&lt;/code&gt; or any command from the &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; family, as it would lead to inconsistent tracing state (different trace specifications on different nodes).</source>
          <target state="translated">Когда узел перегружается, невозможно выполнить &lt;code&gt;ttb:p/2&lt;/code&gt; или любую команду из семейства &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; , так как это приведет к несогласованному состоянию трассировки (разные спецификации трассировки на разных узлах).</target>
        </trans-unit>
        <trans-unit id="9107c7e3a2ab54b42fe2aa4f90dbf2f0ef91d069" translate="yes" xml:space="preserve">
          <source>When a node tries to connect to another node, the magic cookies are compared. If they do not match, the connected node rejects the connection.</source>
          <target state="translated">Когда узел пытается соединиться с другим узлом,сравниваются волшебные куки.Если они не совпадают,подключенный узел отвергает соединение.</target>
        </trans-unit>
        <trans-unit id="91dc7db1911778980d1a145028f56ea061e34c24" translate="yes" xml:space="preserve">
          <source>When a parenthesized subpattern is quantified with a minimum repeat count that is &amp;gt; 1 or with a limited maximum, more memory is required for the compiled pattern, in proportion to the size of the minimum or maximum.</source>
          <target state="translated">При количественной оценке заключенного в скобки подшаблона с минимальным числом повторений&amp;gt; 1 или с ограниченным максимумом для скомпилированного шаблона требуется больше памяти пропорционально размеру минимума или максимума.</target>
        </trans-unit>
        <trans-unit id="17163b128ce2d3940abc9e287d9eb3065dfe4943" translate="yes" xml:space="preserve">
          <source>When a part in the version number increases, all less significant parts are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Когда часть номера версии увеличивается, все менее значимые части устанавливаются в &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="414ecb7481a0e4a00ed77662f92beb6946aca44b" translate="yes" xml:space="preserve">
          <source>When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a long time. The pattern</source>
          <target state="translated">Когда шаблон содержит неограниченное повторение внутри подмаски,которое само по себе может повторяться неограниченное количество раз,использование атомной группы является единственным способом избежать некоторых неудачных совпадений,которые занимают много времени.Шаблон</target>
        </trans-unit>
        <trans-unit id="ca6c00c70d6d587bfac21cf87c7afe2ad1eacd1f" translate="yes" xml:space="preserve">
          <source>When a pending message is received, and the &lt;code&gt;long_request_timer&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; &quot;on its final leg&quot;, the timer will be restarted, and, if &lt;code&gt;long_request_resend = true&lt;/code&gt;, the request will be re-sent.</source>
          <target state="translated">Когда получено ожидающее сообщение, и &lt;code&gt;long_request_timer&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; находится &amp;laquo;на последнем этапе&amp;raquo;, таймер будет перезапущен, и, если &lt;code&gt;long_request_resend = true&lt;/code&gt; , запрос будет повторно отправлен.</target>
        </trans-unit>
        <trans-unit id="f75f183f6a0a339836141c5520bd7b12114dfb3c" translate="yes" xml:space="preserve">
          <source>When a pending message is received, the timer is cancelled and the &lt;code&gt;long_request_timer&lt;/code&gt; is started instead (see below). No resends will be performed from this point (since we now know that the other side has received the request).</source>
          <target state="translated">Когда получено ожидающее сообщение, таймер отменяется и &lt;code&gt;long_request_timer&lt;/code&gt; него запускается long_request_timer (см. Ниже). С этого момента повторная отправка не будет выполняться (поскольку теперь мы знаем, что другая сторона получила запрос).</target>
        </trans-unit>
        <trans-unit id="caca1f590c83f0cbc730079b288c0a340c8795e2" translate="yes" xml:space="preserve">
          <source>When a pending transaction is sent.</source>
          <target state="translated">Когда отправляется нерассмотренная сделка.</target>
        </trans-unit>
        <trans-unit id="9309b1e58646bc0004532eb714a09afd5a498a84" translate="yes" xml:space="preserve">
          <source>When a port is closed, either by an Erlang process or by the driver calling one of the &lt;code&gt;driver_failure_XXX&lt;/code&gt; routines. This routine is to clean up everything connected to one particular port. When other callbacks call a &lt;code&gt;driver_failure_XXX&lt;/code&gt; routine, this routine is immediately called. The callback routine issuing the error can make no more use of the data structures for the port, as this routine surely has freed all associated data and closed all file descriptors. If the queue utility available to driver writer is used, this routine is however &lt;strong&gt;not&lt;/strong&gt; called until the queue is empty.</source>
          <target state="translated">Когда порт закрывается либо процессом Erlang, либо драйвером, вызывающим одну из подпрограмм &lt;code&gt;driver_failure_XXX&lt;/code&gt; . Эта процедура предназначена для очистки всего, что связано с одним конкретным портом. Когда другие обратные вызовы &lt;code&gt;driver_failure_XXX&lt;/code&gt; подпрограмму driver_failure_XXX , эта подпрограмма вызывается немедленно. Подпрограмма обратного вызова, выдающая ошибку, больше не может использовать структуры данных для порта, поскольку эта подпрограмма наверняка освободила все связанные данные и закрыла все файловые дескрипторы. Если утилита очереди доступна для писателя драйвера используется, эта процедура, однако , &lt;strong&gt;не&lt;/strong&gt; называется , пока очередь не опустеет.</target>
        </trans-unit>
        <trans-unit id="cab97407457bdcec73d321074e9305a6e73487c1" translate="yes" xml:space="preserve">
          <source>When a port to the driver is opened (by a &lt;code&gt;open_port&lt;/code&gt; call from Erlang). This routine is to set up internal data structures and return an opaque data entity of the type &lt;code&gt;ErlDrvData&lt;/code&gt;, which is a data type large enough to hold a pointer. The pointer returned by this function is the first argument to all other callbacks concerning this particular port. It is usually called the port handle. The emulator only stores the handle and does never try to interpret it, why it can be virtually anything (anything not larger than a pointer that is) and can point to anything if it is a pointer. Usually this pointer refers to a structure holding information about the particular port, as it does in the example.</source>
          <target state="translated">Когда порт для драйвера открыт ( &lt;code&gt;open_port&lt;/code&gt; из Erlang). Эта процедура предназначена для настройки внутренних структур данных и возврата непрозрачного объекта данных типа &lt;code&gt;ErlDrvData&lt;/code&gt; , который является типом данных, достаточно большим для хранения указателя. Указатель, возвращаемый этой функцией, является первым аргументом для всех других обратных вызовов, касающихся этого конкретного порта. Обычно его называют дескриптором порта. Эмулятор хранит только дескриптор и никогда не пытается его интерпретировать, поэтому он может быть практически любым (чем угодно, не превышающим указатель) и может указывать на что угодно, если это указатель. Обычно этот указатель относится к структуре, содержащей информацию о конкретном порте, как в примере.</target>
        </trans-unit>
        <trans-unit id="d6c6008e1040993823cc1153b9087a328f65c269" translate="yes" xml:space="preserve">
          <source>When a process is killed by &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt;, it is killed before the garbage collection is complete and thus no large heap message is sent.</source>
          <target state="translated">Когда процесс &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt; помощью max_heap_size , он завершается до завершения сборки мусора, и поэтому большое сообщение кучи не отправляется.</target>
        </trans-unit>
        <trans-unit id="54c7049ba92415c934270df93ecc40c6ff49a6de" translate="yes" xml:space="preserve">
          <source>When a process is trapping exits, it does not terminate when an exit signal is received. Instead, the signal is transformed into a message &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt;, which is put into the mailbox of the process, just like a regular message.</source>
          <target state="translated">Когда процесс захватывает выход, он не завершается при получении сигнала выхода. Вместо этого сигнал преобразуется в сообщение &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt; , которое помещается в почтовый ящик процесса, как обычное сообщение.</target>
        </trans-unit>
        <trans-unit id="f894aeebc67996f11b9c7ed1100aea86a6d270d1" translate="yes" xml:space="preserve">
          <source>When a process reaches a breakpoint, only that process is stopped. Other processes are not affected.</source>
          <target state="translated">Когда процесс достигает точки останова,останавливается только этот процесс.Другие процессы не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="f5fe92890350a386281d849d2308c2fdf32b6229" translate="yes" xml:space="preserve">
          <source>When a process terminates, it always terminates with an &lt;strong&gt;exit reason&lt;/strong&gt;. The reason can be any term.</source>
          <target state="translated">Когда процесс завершается, он всегда завершается по &lt;strong&gt;причине выхода&lt;/strong&gt; . Причиной может быть любой срок.</target>
        </trans-unit>
        <trans-unit id="a33255f3d61f1a754c180593962f65ef23e96913" translate="yes" xml:space="preserve">
          <source>When a process terminates, it terminates with an &lt;strong&gt;exit reason&lt;/strong&gt; as explained in &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt;. This exit reason is emitted in an &lt;strong&gt;exit signal&lt;/strong&gt; to all linked processes.</source>
          <target state="translated">Когда процесс завершается, он завершается по &lt;strong&gt;причине выхода,&lt;/strong&gt; как описано в &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt; . Эта причина выхода выдается в &lt;strong&gt;сигнале выхода&lt;/strong&gt; для всех связанных процессов.</target>
        </trans-unit>
        <trans-unit id="f438ecf00c74cada65672d3aca9158bdc88f9b65" translate="yes" xml:space="preserve">
          <source>When a process that is started using &lt;code&gt;proc_lib&lt;/code&gt; terminates abnormally (that is, with another exit reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;), a &lt;strong&gt;crash report&lt;/strong&gt; is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="translated">Когда процесс, запущенный с использованием &lt;code&gt;proc_lib&lt;/code&gt; , завершается ненормально (то есть с другой причиной выхода, чем &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; или &lt;code&gt;{shutdown,Term}&lt;/code&gt; ), создается &lt;strong&gt;отчет о&lt;/strong&gt; сбое, который записывается в терминал обработчиком журнала по умолчанию, установленным ядром , Для получения дополнительной информации о том, как регистрировались отчеты о сбоях до выхода Erlang / OTP 21.0, см. &amp;laquo; &lt;code&gt;SASL Error Logging&lt;/code&gt; SASL&amp;raquo; в Руководстве пользователя SASL.</target>
        </trans-unit>
        <trans-unit id="620e45b56f249c1dbe8f129dc957582dac227989" translate="yes" xml:space="preserve">
          <source>When a program runs in the service context, it must handle the control events that are sent to every program in the system when the interactive user logs off. This is done in different ways for programs running in the console subsystem and programs running as window applications. An application running in the console subsystem (normal for port programs) uses the win32 function &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; to register a control handler that returns &lt;code&gt;true&lt;/code&gt; in answer to the &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; and &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; events. Other applications only forward &lt;code&gt;WM_ENDSESSION&lt;/code&gt; and &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; to the default window procedure.</source>
          <target state="translated">Когда программа выполняется в контексте службы, она должна обрабатывать управляющие события, которые отправляются каждой программе в системе, когда интерактивный пользователь выходит из системы. Это делается по-разному для программ, работающих в подсистеме консоли, и программ, работающих как оконные приложения. Приложение, работающее в подсистеме консоли (обычно для портовых программ), использует функцию &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; для регистрации обработчика управления, который возвращает &lt;code&gt;true&lt;/code&gt; в ответ на события &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; и &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; . Другие приложения пересылают &lt;code&gt;WM_ENDSESSION&lt;/code&gt; и &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; только оконной процедуре по умолчанию.</target>
        </trans-unit>
        <trans-unit id="19ffb1b5dfb2cc8d3c94f0461fc310cb105f6b53" translate="yes" xml:space="preserve">
          <source>When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte.</source>
          <target state="translated">Когда подсчет выполняется,перезапускаются и таймер,и счетчик байтов.По умолчанию-один час и один ГБайт.</target>
        </trans-unit>
        <trans-unit id="160df15be10c112ef08e1b12460eb364b392a9a7" translate="yes" xml:space="preserve">
          <source>When a reply &lt;code&gt;Reply&lt;/code&gt; is received from the &lt;code&gt;gen_server&lt;/code&gt; process at a node &lt;code&gt;Node&lt;/code&gt;, &lt;code&gt;{Node,Reply}&lt;/code&gt; is added to &lt;code&gt;Replies&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">Когда ответный &lt;code&gt;Reply&lt;/code&gt; получен от процесса &lt;code&gt;gen_server&lt;/code&gt; на узле &lt;code&gt;Node&lt;/code&gt; , &lt;code&gt;{Node,Reply}&lt;/code&gt; добавляется в &lt;code&gt;Replies&lt;/code&gt; . &lt;code&gt;Reply&lt;/code&gt; определяется в возвращаемом значении &lt;code&gt;Module:handle_call/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3612568b6d1bd1adf395a8924394d4f1cda79d" translate="yes" xml:space="preserve">
          <source>When a reply transaction is sent.</source>
          <target state="translated">Когда отправляется ответная операция.</target>
        </trans-unit>
        <trans-unit id="6b9676d76432236d4be5a23bf4ca85a4c81230e6" translate="yes" xml:space="preserve">
          <source>When a request is received, some info related to the reply is store internally (e.g. the binary of the reply). This info will live until either an ack is received or this timer expires. For instance, if the same request is received again (e.g. a request with the same transaction id), the (stored) reply will be (re-) sent automatically by megaco.</source>
          <target state="translated">Когда запрос получен,некоторая информация,связанная с ответом,хранится внутри организации (например,двоичный файл ответа).Эта информация будет храниться до тех пор,пока не будет получен либо Ак,либо этот таймер не истечет.Например,если тот же самый запрос будет получен снова (например,запрос с тем же самым идентификатором транзакции),то (сохраненный)ответ будет (повторно)автоматически отправлен megaco.</target>
        </trans-unit>
        <trans-unit id="b6b06f9b88824f92a821ddd40390c63201a38782" translate="yes" xml:space="preserve">
          <source>When a request is sent using the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; function, a proxy process is started to handle all replies. When the reply has been received and delivered to the user, the proxy process continue to exist for as long as this option specifies. Any received messages, is passed on to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; callback function.</source>
          <target state="translated">Когда запрос отправляется с использованием функции &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; , запускается процесс прокси для обработки всех ответов. Когда ответ получен и доставлен пользователю, прокси-процесс продолжает существовать до тех пор, пока этот параметр указывает. Любые полученные сообщения передаются пользователю через &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; обратного вызова handle_unexpected_trans .</target>
        </trans-unit>
        <trans-unit id="c88f71ef842c681d045f4cae79da80397386486a" translate="yes" xml:space="preserve">
          <source>When a run-time error occurs, that is an exception of class &lt;code&gt;error&lt;/code&gt;. The exit reason is a tuple &lt;code&gt;{Reason,Stack}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is a term indicating the type of error:</source>
          <target state="translated">Когда возникает ошибка времени выполнения, это исключение &lt;code&gt;error&lt;/code&gt; класса . Причиной выхода является кортеж &lt;code&gt;{Reason,Stack}&lt;/code&gt; , где &lt;code&gt;Reason&lt;/code&gt; - это термин, указывающий тип ошибки:</target>
        </trans-unit>
        <trans-unit id="25b12f8bd1c57b6ce9840c0a7b9fe58cbedb898d" translate="yes" xml:space="preserve">
          <source>When a run-time error or generated error occurs in Erlang, execution for the process that evaluated the erroneous expression is stopped. This is referred to as a &lt;strong&gt;failure&lt;/strong&gt;, that execution or evaluation &lt;strong&gt;fails&lt;/strong&gt;, or that the process &lt;strong&gt;fails&lt;/strong&gt;, &lt;strong&gt;terminates&lt;/strong&gt;, or &lt;strong&gt;exits&lt;/strong&gt;. Notice that a process can terminate/exit for other reasons than a failure.</source>
          <target state="translated">Когда в Erlang возникает ошибка времени выполнения или сгенерированная ошибка, выполнение процесса, который оценил ошибочное выражение, останавливается. Это упоминается как &lt;strong&gt;провал&lt;/strong&gt; , что выполнение или оценки &lt;strong&gt;терпит неудачу&lt;/strong&gt; , или что процесс &lt;strong&gt;терпит неудачу&lt;/strong&gt; , &lt;strong&gt;Прерывает&lt;/strong&gt; или &lt;strong&gt;завершает работу&lt;/strong&gt; . Обратите внимание, что процесс может завершиться / выйти по другим причинам, кроме сбоя.</target>
        </trans-unit>
        <trans-unit id="6222adda532a7ba95811b3f47ed6b592bce7369e" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details), transitions to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode, the controlling process is notified by a message of the following form:</source>
          <target state="translated">Когда сокет в режиме &lt;code&gt;{active, N}&lt;/code&gt; (подробности см. В &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; ), переходит в пассивный ( &lt;code&gt;{active, false}&lt;/code&gt; ) режим, контролирующий процесс уведомляется сообщением следующей формы:</target>
        </trans-unit>
        <trans-unit id="2ad380e3a94ebd517a8a93bc527d1a2a8c42ac9d" translate="yes" xml:space="preserve">
          <source>When a sticky write lock is acquired, all nodes are informed which node is locked. Then, sticky lock requests from the same node are performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction ends. For details, see the User's Guide.</source>
          <target state="translated">При получении блокировки записи на липкой основе,все узлы получают информацию о том,какой узел заблокирован.Затем запросы на блокировку прилипанием от того же узла выполняются как локальная операция без связи с другими узлами.Липкая блокировка остается на узле даже после завершения транзакции.Подробнее см.руководство пользователя.</target>
        </trans-unit>
        <trans-unit id="f8a9afc8539f723b3d906fa063814442e45d9210" translate="yes" xml:space="preserve">
          <source>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). Also, more memory is used.</source>
          <target state="translated">Когда таблица заказана по SNMP,изменения стоят дороже,чем обычно,O(logN).Также используется больше памяти.</target>
        </trans-unit>
        <trans-unit id="09de174e5f27981b5d536ae7d587e5f775467043" translate="yes" xml:space="preserve">
          <source>When a table is fixed, a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls are guaranteed to succeed, and each object in the table is returned only once, even if objects are removed or inserted during the traversal. The keys for new objects inserted during the traversal &lt;strong&gt;can&lt;/strong&gt; be returned by &lt;code&gt;next/2&lt;/code&gt; (it depends on the internal ordering of the keys).</source>
          <target state="translated">Когда таблица зафиксирована, последовательность вызовов &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; гарантированно завершится успешно, и каждый объект в таблице возвращается только один раз, даже если объекты удаляются или вставляются во время обхода. Ключи для новых объектов, вставленных во время обхода, &lt;strong&gt;могут&lt;/strong&gt; быть возвращены функцией &lt;code&gt;next/2&lt;/code&gt; (это зависит от внутреннего порядка ключей).</target>
        </trans-unit>
        <trans-unit id="f25502d9a8f67791267ea14f5c70c734251d290a" translate="yes" xml:space="preserve">
          <source>When a target name is used for referencing the configuration data (that specifies the connection to be opened), the same name can be used as connection identity in all subsequent calls related to the connection (also for closing it). Only one open connection per target name is possible. If you attempt to open a new connection using a name already associated with an open connection, &lt;code&gt;Common Test&lt;/code&gt; returns the already existing handle so the previously opened connection is used. This feature makes it possible to call the function for opening a particular connection whenever useful. An action like this does not necessarily open any new connections unless it is required (which could be the case if, for example, the previous connection has been closed unexpectedly by the server). Using named connections also removes the need to pass handle references around in the suite for these connections.</source>
          <target state="translated">Когда целевое имя используется для ссылки на данные конфигурации (которые определяют соединение, которое нужно открыть), то же имя может использоваться в качестве идентификатора соединения во всех последующих вызовах, связанных с соединением (также для его закрытия). Возможно только одно открытое соединение для каждого имени цели. Если вы попытаетесь открыть новое соединение, используя имя, уже связанное с открытым соединением, &lt;code&gt;Common Test&lt;/code&gt; возвращает уже существующий дескриптор, поэтому используется ранее открытое соединение. Эта функция позволяет при необходимости вызывать функцию для открытия определенного соединения. Подобное действие не обязательно открывает какие-либо новые соединения, если это не требуется (что может иметь место, если, например, предыдущее соединение было неожиданно закрыто сервером). Использование именованных соединений также устраняет необходимость передавать ссылки на дескрипторы в наборе для этих соединений.</target>
        </trans-unit>
        <trans-unit id="8b832ad499cefe25ddc82f36d870e896057644d6" translate="yes" xml:space="preserve">
          <source>When a term is passed as the initial process arguments in the &lt;code&gt;spawn&lt;/code&gt; call</source>
          <target state="translated">Когда термин передается в качестве начальных аргументов процесса в вызове &lt;code&gt;spawn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e389307b8d59483ef3d7e87b6dfe90a060b042c" translate="yes" xml:space="preserve">
          <source>When a term is sent to another process</source>
          <target state="translated">Когда термин отправляется в другой процесс</target>
        </trans-unit>
        <trans-unit id="b733aebb93dce74a8914341750d479f7d8a549ed" translate="yes" xml:space="preserve">
          <source>When a term is stored in an Ets table</source>
          <target state="translated">Когда термин хранится в таблице Ets</target>
        </trans-unit>
        <trans-unit id="0c7ebdcd78a12cc7bd8bd97eb29bacb32f39549b" translate="yes" xml:space="preserve">
          <source>When a test case group is repeated, the configuration functions &lt;code&gt;init_per_group/2&lt;/code&gt; and &lt;code&gt;end_per_group/2&lt;/code&gt; are also always called with each repetition.</source>
          <target state="translated">Когда группа тестовых примеров повторяется, функции конфигурации &lt;code&gt;init_per_group/2&lt;/code&gt; и &lt;code&gt;end_per_group/2&lt;/code&gt; также всегда вызываются при каждом повторении.</target>
        </trans-unit>
        <trans-unit id="2be9bace113be2bd43525f396f001fb603a47ce4" translate="yes" xml:space="preserve">
          <source>When a test case group is specified, the resulting test executes function &lt;code&gt;init_per_group&lt;/code&gt;, followed by all test cases and subgroups (including their configuration functions), and finally function &lt;code&gt;end_per_group&lt;/code&gt;. Also, if particular test cases in a group are specified, &lt;code&gt;init_per_group&lt;/code&gt; and &lt;code&gt;end_per_group&lt;/code&gt;, for the group in question, are called. If a group defined (in &lt;code&gt;Suite:group/0&lt;/code&gt;) as a subgroup of another group, is specified (or if particular test cases of a subgroup are), &lt;code&gt;Common Test&lt;/code&gt; calls the configuration functions for the top-level groups and for the subgroup in question (making it possible to pass configuration data all the way from &lt;code&gt;init_per_suite&lt;/code&gt; down to the test cases in the subgroup).</source>
          <target state="translated">Когда указана группа тестовых примеров, результирующий тест выполняет функцию &lt;code&gt;init_per_group&lt;/code&gt; , за которой следуют все тестовые примеры и подгруппы (включая их функции конфигурации) и, наконец, функцию &lt;code&gt;end_per_group&lt;/code&gt; . Кроме того, если в группе указаны конкретные тестовые примеры, &lt;code&gt;init_per_group&lt;/code&gt; и &lt;code&gt;end_per_group&lt;/code&gt; для рассматриваемой группы. Если группа, определенная (в &lt;code&gt;Suite:group/0&lt;/code&gt; ) как подгруппа другой группы, указана (или если указаны конкретные тестовые примеры подгруппы), &lt;code&gt;Common Test&lt;/code&gt; вызывает функции конфигурации для групп верхнего уровня и для подгруппы в вопрос (что позволяет передавать данные конфигурации полностью из &lt;code&gt;init_per_suite&lt;/code&gt; вплоть до тестовых примеров в подгруппе).</target>
        </trans-unit>
        <trans-unit id="7eab1460f1347d0c73cb3c3a8b4439b39091de4a" translate="yes" xml:space="preserve">
          <source>When a test case is skipped, it is noted as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log.</source>
          <target state="translated">Когда тестовый пример пропускается, он отмечается как &lt;code&gt;SKIPPED&lt;/code&gt; в журнале HTML.</target>
        </trans-unit>
        <trans-unit id="d7277815e7b5fc7d7307a8ad2c9b5d0b7fee5390" translate="yes" xml:space="preserve">
          <source>When a timer expires. The driver can set timers with the function &lt;code&gt;driver_set_timer&lt;/code&gt;. When such timers expire, a specific callback function is called. No timers are used in the example.</source>
          <target state="translated">Когда истекает таймер. Драйвер может устанавливать таймеры с помощью функции &lt;code&gt;driver_set_timer&lt;/code&gt; . Когда такие таймеры истекают, вызывается определенная функция обратного вызова. В этом примере таймеры не используются.</target>
        </trans-unit>
        <trans-unit id="01248c84705afaa8d22118ccef5dc76865736320" translate="yes" xml:space="preserve">
          <source>When a transaction acknowledgement is received it is possible that user has decided not to bother about the acknowledgement. But in case the return value from UserMod:handle_trans_request/3 indicates that the acknowledgement is important the following callback function will be invoked:</source>
          <target state="translated">При получении подтверждения сделки возможно,что пользователь решил не беспокоиться о подтверждении.Но если возвращаемое из UserMod:handle_trans_request/3 значение указывает на важность подтверждения,то будет вызвана следующая функция обратного вызова:</target>
        </trans-unit>
        <trans-unit id="163b7a94b619edcfd4f6cd93b3333d250e24a1fb" translate="yes" xml:space="preserve">
          <source>When a user (MG/MGC) is distributed over several nodes, it is required that the node hosting the connection already has activated the connection and that it is in the &quot;normal&quot; state. The RemoteMid must be a real Megaco MID and not a preliminary_mid.</source>
          <target state="translated">Когда пользователь (MG/MGC)распределен по нескольким узлам,требуется,чтобы узел,на котором установлено соединение,уже активировал его и чтобы он находился в &quot;нормальном&quot; состоянии.RemoteMid должен быть настоящим Megaco MID,а не предварительным_mid.</target>
        </trans-unit>
        <trans-unit id="19eb5cc222fe8477b606be0ecb93b47faec2127d" translate="yes" xml:space="preserve">
          <source>When a valid request reaches &lt;code&gt;httpd&lt;/code&gt;, it calls &lt;code&gt;do/1&lt;/code&gt; in each module, defined by the configuration option of &lt;code&gt;Module&lt;/code&gt;. The function can generate data for other modules or a response that can be sent back to the client.</source>
          <target state="translated">Когда действительный запрос достигает &lt;code&gt;httpd&lt;/code&gt; , он вызывает &lt;code&gt;do/1&lt;/code&gt; в каждом модуле, определяемом параметром конфигурации &lt;code&gt;Module&lt;/code&gt; . Функция может генерировать данные для других модулей или ответ, который может быть отправлен обратно клиенту.</target>
        </trans-unit>
        <trans-unit id="988284baf01c48f0333363a5420ee041f8e80f73" translate="yes" xml:space="preserve">
          <source>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use construct &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; instead. It can be used for records of type &lt;code&gt;RecordName&lt;/code&gt;.</source>
          <target state="translated">При доступе к отдельным атрибутам в записи нет необходимости или даже рекомендуется жестко кодировать любые имена атрибутов как атомы. &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; этого используйте конструкцию record_info (fields, RecordName) . Его можно использовать для записей типа &lt;code&gt;RecordName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a069a06056d1779ba3b73665e6912fd948d0893" translate="yes" xml:space="preserve">
          <source>When adding or removing an application, no &lt;code&gt;.appup&lt;/code&gt; file is needed. When generating &lt;code&gt;relup&lt;/code&gt;, the &lt;code&gt;.rel&lt;/code&gt; files are compared and the &lt;code&gt;add_application&lt;/code&gt; and &lt;code&gt;remove_application&lt;/code&gt; instructions are added automatically.</source>
          <target state="translated">При добавлении или удалении приложения файл &lt;code&gt;.appup&lt;/code&gt; не требуется. При создании &lt;code&gt;relup&lt;/code&gt; , то &lt;code&gt;.rel&lt;/code&gt; файлы сравниваются и &lt;code&gt;add_application&lt;/code&gt; и &lt;code&gt;remove_application&lt;/code&gt; инструкции добавляются автоматически.</target>
        </trans-unit>
        <trans-unit id="d7dcf974a69ad2af0b183e9640143a16ca26c965" translate="yes" xml:space="preserve">
          <source>When adding processes or ports, a window with trace options is displayed. The chosen options are set for the selected processes/ports. To change the options, right-click the process or port and select &lt;strong&gt;Edit process options&lt;/strong&gt;. To remove a process or port from the list, right-click and select &lt;strong&gt;Remove process&lt;/strong&gt; or &lt;strong&gt;Remove port&lt;/strong&gt;, respectively.</source>
          <target state="translated">При добавлении процессов или портов отображается окно с параметрами трассировки. Выбранные параметры устанавливаются для выбранных процессов / портов. Чтобы изменить параметры, щелкните правой кнопкой мыши процесс или порт и выберите &lt;strong&gt;Изменить параметры процесса&lt;/strong&gt; . Чтобы удалить процесс или порт из списка, щелкните правой кнопкой мыши и выберите &lt;strong&gt;Удалить процесс&lt;/strong&gt; или &lt;strong&gt;Удалить порт&lt;/strong&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="8ed50d489e165b74cf018acee993218839df9d7b" translate="yes" xml:space="preserve">
          <source>When all involved (mandatory) nodes have been started, the distributed application can be started by calling &lt;code&gt;application:start(Application)&lt;/code&gt; at &lt;strong&gt;all of these nodes.&lt;/strong&gt;</source>
          <target state="translated">Когда все задействованные (обязательные) узлы запущены, распределенное приложение можно запустить, вызвав &lt;code&gt;application:start(Application)&lt;/code&gt; на &lt;strong&gt;всех этих узлах.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd73cca48ba2b286c66fc15f791c382c884ddbc5" translate="yes" xml:space="preserve">
          <source>When all nodes are operational, &lt;code&gt;myapp&lt;/code&gt; can be started. This is achieved by calling &lt;code&gt;application:start(myapp)&lt;/code&gt; at all three nodes. It is then started at &lt;code&gt;cp1&lt;/code&gt;, as shown in the following figure:</source>
          <target state="translated">Когда все узлы работают, &lt;code&gt;myapp&lt;/code&gt; можно запускать. Это достигается вызовом &lt;code&gt;application:start(myapp)&lt;/code&gt; на всех трех узлах. Затем он запускается на &lt;code&gt;cp1&lt;/code&gt; , как показано на следующем рисунке:</target>
        </trans-unit>
        <trans-unit id="efd0a7b9eacf13a1791c55c3dbd5596c2928ca10" translate="yes" xml:space="preserve">
          <source>When all objects of the table have been matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Когда все объекты таблицы сопоставлены, &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa1c6e68ed8acc251646eddfa314228262bb5f3b" translate="yes" xml:space="preserve">
          <source>When all table objects are matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Когда все объекты таблицы совпадают, &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c62a1cbadf2c2b8976473d30ec9850b0e30154" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;escript&lt;/code&gt; file contains an archive, there are no restrictions on the name of the &lt;code&gt;escript&lt;/code&gt; and no restrictions on how many applications that can be stored in the embedded archive. Single Beam files can also reside on the top level in the archive. At startup, the top directory in the embedded archive and all (second level) &lt;code&gt;ebin&lt;/code&gt; directories in the embedded archive are added to the code path. See &lt;code&gt;erts:escript(1)&lt;/code&gt;.</source>
          <target state="translated">Если файл &lt;code&gt;escript&lt;/code&gt; содержит архив, нет ограничений на имя &lt;code&gt;escript&lt;/code&gt; и нет ограничений на количество приложений, которые могут быть сохранены во встроенном архиве. Файлы Single Beam также могут находиться на верхнем уровне архива. При запуске верхний каталог встроенного архива и все (второй уровень) &lt;code&gt;ebin&lt;/code&gt; во встроенном архиве добавляются к пути кода. См. &lt;code&gt;erts:escript(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9936eae6e93ab6d5c78b6480d03e1af10ab7148" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;usm_entry()&lt;/code&gt; tuple (or a list of such tuples) is returned, this data is then added to the &lt;code&gt;usmUserTable&lt;/code&gt; by the (master-) agent.</source>
          <target state="translated">Когда &lt;code&gt;usm_entry()&lt;/code&gt; кортеж usm_entry () (или список таких кортежей), эти данные затем добавляются в &lt;code&gt;usmUserTable&lt;/code&gt; агентом (master-).</target>
        </trans-unit>
        <trans-unit id="0b976e99904fcceb1196e74093f891273ad96adf" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled with option &lt;code&gt;ber&lt;/code&gt;, the &lt;code&gt;asn1rt_nif&lt;/code&gt; module and the NIF library in &lt;code&gt;asn1/priv_dir&lt;/code&gt; are needed at runtime.</source>
          <target state="translated">Когда спецификация ASN.1 компилируется с опцией &lt;code&gt;ber&lt;/code&gt; , во время &lt;code&gt;asn1rt_nif&lt;/code&gt; модуль asn1rt_nif и библиотека NIF в &lt;code&gt;asn1/priv_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c483462464501bc7953de399a743714b5061e30" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled, all defined types of type &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SEQUENCE&lt;/code&gt; result in a corresponding record in the generated &lt;code&gt;.hrl&lt;/code&gt; file. This is because the values for &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;SEQUENCE&lt;/code&gt; are represented as records by default.</source>
          <target state="translated">Когда спецификация ASN.1 компилируется, все определенные типы типа &lt;code&gt;SET&lt;/code&gt; или &lt;code&gt;SEQUENCE&lt;/code&gt; приводят к соответствующей записи в сгенерированном файле &lt;code&gt;.hrl&lt;/code&gt; . Это связано с тем, что значения &lt;code&gt;SET&lt;/code&gt; и &lt;code&gt;SEQUENCE&lt;/code&gt; по умолчанию представлены как записи.</target>
        </trans-unit>
        <trans-unit id="0e9c8df5e2566ccd5d9fbe4734d8fd9d613779aa" translate="yes" xml:space="preserve">
          <source>When an Erlang process calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;, which is a synchronous interface to drivers. The control interface is used to set driver options, change states of ports, and so on. This interface is used a lot in the example.</source>
          <target state="translated">Когда процесс Erlang вызывает &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; , который является синхронным интерфейсом для драйверов. Интерфейс управления используется для установки параметров драйвера, изменения состояний портов и т. Д. Этот интерфейс часто используется в примере.</target>
        </trans-unit>
        <trans-unit id="2b618715bb8bb03bc07feda65b3a85bb43cb72de" translate="yes" xml:space="preserve">
          <source>When an Erlang process sends data to the port. The data arrives as a buffer of bytes, the interpretation is not defined, but is up to the implementor. This callback returns nothing to the caller, answers are sent to the caller as messages (using a routine called &lt;code&gt;driver_output&lt;/code&gt; available to all drivers). There is also a way to talk in a synchronous way to drivers, described below. There can be an additional callback function for handling data that is fragmented (sent in a deep io-list). That interface gets the data in a form suitable for Unix &lt;code&gt;writev&lt;/code&gt; rather than in a single buffer. There is no need for a distribution driver to implement such a callback, so we will not.</source>
          <target state="translated">Когда процесс Erlang отправляет данные в порт. Данные поступают в виде байтового буфера, интерпретация не определена, но остается на усмотрение разработчика. Этот обратный вызов ничего не возвращает вызывающему, ответы отправляются вызывающему в виде сообщений (с использованием подпрограммы под названием &lt;code&gt;driver_output&lt;/code&gt; , доступной для всех драйверов). Существует также способ синхронного общения с водителями, описанный ниже. Может быть дополнительная функция обратного вызова для обработки фрагментированных данных (отправленных в глубоком io-списке). Этот интерфейс получает данные в форме , пригодной для Unix &lt;code&gt;writev&lt;/code&gt; , а не в одном буфере. Для реализации такого обратного вызова в драйвере распространения нет необходимости, поэтому мы не будем.</target>
        </trans-unit>
        <trans-unit id="fcd682219ed27952353a789f2a95e93eae1b95ef" translate="yes" xml:space="preserve">
          <source>When an Erlang runtime system is started, a number of processes are started as part of the Kernel application. One of these processes is the &lt;strong&gt;application controller&lt;/strong&gt; process, registered as &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="translated">Когда запускается система времени выполнения Erlang, как часть приложения ядра запускается ряд процессов. Одним из этих процессов является процесс &lt;strong&gt;контроллера приложения&lt;/strong&gt; , зарегистрированный как &lt;code&gt;application_controller&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6e9cd273f9f4e055a8524b92a57509f35b9cee" translate="yes" xml:space="preserve">
          <source>When an I/O server receives an &lt;code&gt;io_request&lt;/code&gt; tuple, it acts upon the &lt;code&gt;Request&lt;/code&gt; part and eventually sends an &lt;code&gt;io_reply&lt;/code&gt; tuple with the corresponding &lt;code&gt;Reply&lt;/code&gt; part.</source>
          <target state="translated">Когда сервер ввода-вывода получает кортеж &lt;code&gt;io_request&lt;/code&gt; , он воздействует на часть &lt;code&gt;Request&lt;/code&gt; и в конечном итоге отправляет кортеж &lt;code&gt;io_reply&lt;/code&gt; с соответствующей частью &lt;code&gt;Reply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c97830caeadaae0c71c4a6641f2b72ee5a3a4441" translate="yes" xml:space="preserve">
          <source>When an MIB is compiled, the compiler detects if several managed objects use the same &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. If that is the case, it issues an error message. However, the compiler cannot detect Oid conflicts between different MIBs. These kinds of conflicts generate an error at load time. To avoid this, the following function can be used to do consistency checking between MIBs:</source>
          <target state="translated">Когда MIB компилируется, компилятор определяет, используют ли несколько управляемых объектов один и тот же &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; . В этом случае выдается сообщение об ошибке. Однако компилятор не может обнаружить конфликты Oid между разными MIB. Такие конфликты вызывают ошибку во время загрузки. Чтобы избежать этого, можно использовать следующую функцию для проверки согласованности между MIB:</target>
        </trans-unit>
        <trans-unit id="db011fd2eddc67aaa683180ce280cb84fa7377af" translate="yes" xml:space="preserve">
          <source>When an TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages:</source>
          <target state="translated">Когда TLS/DTLS-разъем находится в активном режиме (по умолчанию),данные из разъема доставляются владельцу разъема в виде сообщений:</target>
        </trans-unit>
        <trans-unit id="996325d55085b77e5910030169e95fa9280c37bb" translate="yes" xml:space="preserve">
          <source>When an accept sequence has been completed the acceptor process is expected to continue accepting further requests.</source>
          <target state="translated">После завершения процедуры приема ожидается,что процесс акцептования продолжит принимать дальнейшие запросы.</target>
        </trans-unit>
        <trans-unit id="709fa60f17ba558cd057f2a6b62757eac692ee54" translate="yes" xml:space="preserve">
          <source>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</source>
          <target state="translated">Когда приложение выполняется на нескольких узлах и хочет убедиться,что обновление выполняется на удаленных узлах,прежде чем будет запущен удаленный процесс или отправлено сообщение удаленному процессу.</target>
        </trans-unit>
        <trans-unit id="6c28abc5b0d379d3a8ba44dbcc2c9763e0be3b27" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on other nodes.</source>
          <target state="translated">Когда приложение выполняет частые или объемные обновления, которые могут перегрузить &lt;code&gt;Mnesia&lt;/code&gt; на других узлах.</target>
        </trans-unit>
        <trans-unit id="a47a8128b591f9e03e1d7bb3a8b71505f2177f47" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on the nodes.</source>
          <target state="translated">Когда приложение выполняет частые или объемные обновления, которые могут перегрузить &lt;code&gt;Mnesia&lt;/code&gt; на узлах.</target>
        </trans-unit>
        <trans-unit id="8091d18c34c7568e437ad61e1779d1db887806b5" translate="yes" xml:space="preserve">
          <source>When an event handler terminates abnormally, &lt;code&gt;gen_event&lt;/code&gt; logs &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">Когда обработчик событий завершает работу ненормально, &lt;code&gt;gen_event&lt;/code&gt; регистрирует &lt;code&gt;Status&lt;/code&gt; вместо термина состояния обработчика событий.</target>
        </trans-unit>
        <trans-unit id="3b856ad79c467961efb9c09f4c8c68ce2f0ae4ff" translate="yes" xml:space="preserve">
          <source>When an event manager is stopped, it gives each of the installed event handlers the chance to clean up by calling &lt;code&gt;terminate/2&lt;/code&gt;, the same way as when deleting a handler.</source>
          <target state="translated">Когда диспетчер событий остановлен, он дает каждому из установленных обработчиков событий возможность выполнить очистку путем вызова &lt;code&gt;terminate/2&lt;/code&gt; , так же, как при удалении обработчика.</target>
        </trans-unit>
        <trans-unit id="6ecb64233649623988df5a15e4320b8e35507f15" translate="yes" xml:space="preserve">
          <source>When an installed release is made permanent, the system process &lt;code&gt;init&lt;/code&gt; is set to point out the new &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">Когда установленный выпуск становится постоянным, в системном процессе &lt;code&gt;init&lt;/code&gt; указывается новый &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b00873013d7a25ee81fef530c37b0fd219bde2fd" translate="yes" xml:space="preserve">
          <source>When an integer-value is specified, &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; goes into hibernation after the specified number of milliseconds of inactivity, thus reducing its memory footprint. When &lt;code&gt;undefined&lt;/code&gt; is specified (this is the default), the process never goes into hibernation.</source>
          <target state="translated">Когда указано целочисленное значение, &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; переходит в спящий режим после указанного количества миллисекунд бездействия, тем самым уменьшая объем памяти. Если указано значение &lt;code&gt;undefined&lt;/code&gt; (это значение по умолчанию), процесс никогда не переходит в режим гибернации.</target>
        </trans-unit>
        <trans-unit id="bd630c54a2a673edbcdeb121843359b4c127f6e0" translate="yes" xml:space="preserve">
          <source>When analysing code coverage, the result for &lt;code&gt;m1&lt;/code&gt; can be seen in the cover log in the &lt;code&gt;s1&lt;/code&gt; test result.</source>
          <target state="translated">При анализе покрытия кода результат для &lt;code&gt;m1&lt;/code&gt; можно увидеть в журнале покрытия в результате теста &lt;code&gt;s1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89c824ef18f1155e6eb73bb5f1e6f145e288eb6a" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the &lt;code&gt;include_dir&lt;/code&gt; to Dialyzer. (**)</source>
          <target state="translated">При анализе из источника передайте &lt;code&gt;include_dir&lt;/code&gt; в Dialyzer. (**)</target>
        </trans-unit>
        <trans-unit id="6d86eb0ccd83bcc9cd8e9fc364281c878af586ee" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the define to Dialyzer. (**)</source>
          <target state="translated">При анализе от источника,передайте определение в Dialyzer.(**)</target>
        </trans-unit>
        <trans-unit id="ac42477caf4c3ea1c573d88619291bc09d0583f2" translate="yes" xml:space="preserve">
          <source>When analyzing from source, you might have to supply Dialyzer with a list of include directories and macro definitions (as you can do with the &lt;code&gt;erlc&lt;/code&gt; flags &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-D&lt;/code&gt;). This can be done either by starting Dialyzer with these flags from the command line as in:</source>
          <target state="translated">При анализе из исходного кода вам может потребоваться предоставить Dialyzer список включаемых каталогов и определений макросов (как вы можете сделать с флагами &lt;code&gt;erlc&lt;/code&gt; &lt;code&gt;-I&lt;/code&gt; и &lt;code&gt;-D&lt;/code&gt; ). Это можно сделать либо запустив Dialyzer с этими флагами из командной строки, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="658b2374a8aacc4b9e6927fe3e6096361c317c2b" translate="yes" xml:space="preserve">
          <source>When analyzing the result file from the profiling activity, look for functions that are called many times and have a long &quot;own&quot; execution time (time excluding calls to other functions). Functions that are called a lot of times can also be interesting, as even small things can add up to quite a bit if repeated often. Also ask yourself what you can do to reduce this time. The following are appropriate types of questions to ask yourself:</source>
          <target state="translated">При анализе результирующего файла из профилирующей активности ищите функции,которые вызываются многократно и имеют длительное &quot;собственное&quot; время выполнения (время,исключающее вызов других функций).Функции,которые вызываются много раз,также могут быть интересны,так как даже мелкие вещи могут складываться до довольно небольшого количества,если их часто повторять.Также спросите себя,что можно сделать,чтобы сократить это время.Ниже перечислены подходящие типы вопросов,которые вы можете задать себе:</target>
        </trans-unit>
        <trans-unit id="806459f8533827481672dc572cf1bf7921931e0f" translate="yes" xml:space="preserve">
          <source>When appending to a binary as follows, only the binary returned from the latest append operation will support further cheap append operations:</source>
          <target state="translated">При добавлении к двоичному файлу следующим образом,только двоичный файл,возвращенный из последнего приложения,будет поддерживать дальнейшие дешевые операции с приложением:</target>
        </trans-unit>
        <trans-unit id="228cd4e5a8bc6e5b7fee2e6123af719e572f533e" translate="yes" xml:space="preserve">
          <source>When building in a Git working directory you also have to have a GNU &lt;code&gt;autoconf&lt;/code&gt; of at least version 2.59 on your system, because you need to generate the &lt;code&gt;configure&lt;/code&gt; scripts before you can start building.</source>
          <target state="translated">При сборке в рабочем каталоге Git вам также необходимо иметь в вашей системе &lt;code&gt;autoconf&lt;/code&gt; GNU не ниже версии 2.59, потому что вам нужно сгенерировать скрипты &lt;code&gt;configure&lt;/code&gt; прежде чем вы сможете начать сборку.</target>
        </trans-unit>
        <trans-unit id="eaf8c1d8b7925ac8c617463eca8b72a76f666d34" translate="yes" xml:space="preserve">
          <source>When building the documentation you need a full Erlang/OTP-21.0 system in the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">При создании документации вам понадобится полная система Erlang / OTP-21.0 в &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90530c4b0ae5b8364ccb16ac3ef25111d36b377f" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">Предполагается, что при вызове с аргументом &lt;code&gt;read&lt;/code&gt; функция &lt;code&gt;InitFun&lt;/code&gt; возвращает &lt;code&gt;end_of_input&lt;/code&gt; , когда больше нет ввода, или &lt;code&gt;{Objects, Fun}&lt;/code&gt; , где &lt;code&gt;Objects&lt;/code&gt; - это список объектов, а &lt;code&gt;Fun&lt;/code&gt; - новая функция ввода. Любое другое значение &lt;code&gt;Value&lt;/code&gt; возвращается как ошибка &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; . Каждая функция ввода вызывается ровно один раз, и в случае ошибки вызывается последняя функция с аргументом &lt;code&gt;close&lt;/code&gt; , ответ которой игнорируется.</target>
        </trans-unit>
        <trans-unit id="07cb85581936567b82cbd8ae581b4c6171786cd2" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, the function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occur, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">Предполагается, что при вызове с аргументом &lt;code&gt;read&lt;/code&gt; функция &lt;code&gt;InitFun&lt;/code&gt; возвращает &lt;code&gt;end_of_input&lt;/code&gt; , когда больше нет ввода, или &lt;code&gt;{Objects, Fun}&lt;/code&gt; , где &lt;code&gt;Objects&lt;/code&gt; - это список объектов, а &lt;code&gt;Fun&lt;/code&gt; - новая функция ввода. Любое другое значение &lt;code&gt;Value&lt;/code&gt; возвращается как ошибка &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; . Каждая функция ввода вызывается ровно один раз, и при возникновении ошибки последняя функция вызывается с аргументом &lt;code&gt;close&lt;/code&gt; , ответ которой игнорируется.</target>
        </trans-unit>
        <trans-unit id="364ba2a27b870da0b99015d17a3a2b5626ba1eeb" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;undefined&lt;/code&gt;, all system performance monitoring settings are cleared.</source>
          <target state="translated">При вызове с аргументом &lt;code&gt;undefined&lt;/code&gt; все настройки мониторинга производительности системы очищаются.</target>
        </trans-unit>
        <trans-unit id="b44f8219d85b31453de272e6169e5dfa4f9585c9" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;qlc:q/1,2&lt;/code&gt; from the Erlang shell, the parse transform is automatically called. When this occurs, the fun substituted for the QLC is not compiled but is evaluated by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. This is also true when expressions are evaluated by &lt;code&gt;file:eval/1,2&lt;/code&gt; or in the debugger.</source>
          <target state="translated">При вызове &lt;code&gt;qlc:q/1,2&lt;/code&gt; из оболочки Erlang автоматически вызывается преобразование синтаксического анализа. Когда это происходит, функция, заменяющая QLC, не компилируется, а оценивается &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; . Это также верно, когда выражения оцениваются с помощью &lt;code&gt;file:eval/1,2&lt;/code&gt; или в отладчике.</target>
        </trans-unit>
        <trans-unit id="0142d7dfddbd655a17b503f022ba1db92cd0ecd9" translate="yes" xml:space="preserve">
          <source>When calling BIFs that accept deep lists, such as &lt;code&gt;list_to_binary/1&lt;/code&gt; or &lt;code&gt;iolist_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">При вызове BIF, принимающих глубокие списки, например &lt;code&gt;list_to_binary/1&lt;/code&gt; или &lt;code&gt;iolist_to_binary/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c494144b9a22a3f981a6afcba77050a11fcf18" translate="yes" xml:space="preserve">
          <source>When calling this function, &lt;code&gt;iovec&lt;/code&gt; should contain a pointer to &lt;code&gt;NULL&lt;/code&gt; or a ErlNifIOVec structure that should be used if possible. e.g.</source>
          <target state="translated">При вызове этой функции &lt;code&gt;iovec&lt;/code&gt; должен содержать указатель на &lt;code&gt;NULL&lt;/code&gt; или структуру ErlNifIOVec, которую следует использовать, если возможно. например</target>
        </trans-unit>
        <trans-unit id="865c3803d266e89c17825224f1f9b63a82983678" translate="yes" xml:space="preserve">
          <source>When caseless matching is set, any letters in a class represent both their uppercase and lowercase versions. For example, a caseless &lt;code&gt;[aeiou]&lt;/code&gt; matches &quot;A&quot; and &quot;a&quot;, and a caseless &lt;code&gt;[^aeiou]&lt;/code&gt; does not match &quot;A&quot;, but a caseful version would. In a UTF mode, PCRE always understands the concept of case for characters whose values are &amp;lt; 256, so caseless matching is always possible. For characters with higher values, the concept of case is supported only if PCRE is compiled with Unicode property support. If you want to use caseless matching in a UTF mode for characters &amp;gt;=, ensure that PCRE is compiled with Unicode property support and with UTF support.</source>
          <target state="translated">Если установлено сопоставление без регистра, любые буквы в классе представляют их версии как в верхнем, так и в нижнем регистре. Например, &lt;code&gt;[aeiou]&lt;/code&gt; без регистра соответствует &quot;A&quot; и &quot;a&quot;, а без регистра &lt;code&gt;[^aeiou]&lt;/code&gt; не соответствует &quot;A&quot;, но вариант с регистром соответствует. В режиме UTF PCRE всегда понимает концепцию регистра для символов, значения которых &amp;lt;256, поэтому всегда возможно сопоставление без регистра. Для символов с более высокими значениями концепция регистра поддерживается только в том случае, если PCRE скомпилирован с поддержкой свойств Unicode. Если вы хотите использовать сопоставление без регистра в режиме UTF для символов&amp;gt; =, убедитесь, что PCRE скомпилирован с поддержкой свойств Unicode и с поддержкой UTF.</target>
        </trans-unit>
        <trans-unit id="1fa07acc11a720ed656be365e748b1e786d781a3" translate="yes" xml:space="preserve">
          <source>When caseless matching is specified (option &lt;code&gt;caseless&lt;/code&gt;), letters are matched independently of case.</source>
          <target state="translated">Если указано сопоставление без регистра (опция &lt;code&gt;caseless&lt;/code&gt; ), буквы сопоставляются независимо от регистра.</target>
        </trans-unit>
        <trans-unit id="37ae8050f70165954f23ba0ebf3fbda68196592f" translate="yes" xml:space="preserve">
          <source>When changing this flag messages will be moved. This work has been initiated but not completed when this function call returns.</source>
          <target state="translated">При смене этого флага сообщения будут перемещаться.Эта работа была инициирована,но не завершена при возврате вызова данной функции.</target>
        </trans-unit>
        <trans-unit id="1c283832835fc69a63d88192d48cfa2b0fe0ad55" translate="yes" xml:space="preserve">
          <source>When changing to state &lt;code&gt;open&lt;/code&gt;, the collected buttons are reset, the lock unlocked, and a state timer for 10 s is started.</source>
          <target state="translated">При переходе в состояние &amp;laquo; &lt;code&gt;open&lt;/code&gt; собранные кнопки сбрасываются, замок разблокируется и запускается таймер состояния на 10 с.</target>
        </trans-unit>
        <trans-unit id="44d2f7b0ec39f0b334cd93ff69fd7523f8653774" translate="yes" xml:space="preserve">
          <source>When comparing an integer to a float, the term with the lesser precision is converted into the type of the other term, unless the operator is one of &lt;code&gt;=:=&lt;/code&gt; or &lt;code&gt;=/=&lt;/code&gt;. A float is more precise than an integer until all significant figures of the float are to the left of the decimal point. This happens when the float is larger/smaller than +/-9007199254740992.0. The conversion strategy is changed depending on the size of the float because otherwise comparison of large floats and integers would lose their transitivity.</source>
          <target state="translated">При сравнении целого числа с числом с плавающей запятой термин с меньшей точностью преобразуется в тип другого члена, если только оператор не является одним из &lt;code&gt;=:=&lt;/code&gt; или &lt;code&gt;=/=&lt;/code&gt; . Число с плавающей запятой является более точным, чем целое число, пока все значащие цифры числа с плавающей запятой не будут слева от десятичной точки. Это происходит, когда поплавок больше / меньше, чем +/- 9007199254740992.0. Стратегия преобразования изменяется в зависимости от размера числа с плавающей запятой, потому что в противном случае сравнение больших чисел с плавающей запятой и целых чисел потеряло бы свою транзитивность.</target>
        </trans-unit>
        <trans-unit id="057fdbcf9c89dcfcef51fc5e8e497f10a792cf05" translate="yes" xml:space="preserve">
          <source>When comparing external sets, operator &lt;code&gt;==/2&lt;/code&gt; is used.</source>
          <target state="translated">При сравнении внешних наборов используется оператор &lt;code&gt;==/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc0d77de42806fcc3f093559352b14f83658b4e" translate="yes" xml:space="preserve">
          <source>When comparing two version numbers that have an order, one compare each part as ordinary integers from the most significant part to less significant parts. The order is defined by the first parts of the same significance that differ. An OTP version with a larger version includes all changes that are part of a smaller OTP version. The same goes for application versions.</source>
          <target state="translated">При сравнении двух номеров версий,которые имеют порядок,каждая часть сравнивается как обычные целые числа от наиболее значимой части к менее значимым частям.Порядок определяется первыми частями одинаковой значимости,которые различаются.Версия OTP с большей версией включает в себя все изменения,которые являются частью меньшей версии OTP.То же самое относится и к версиям приложений.</target>
        </trans-unit>
        <trans-unit id="7045558361dff4148b294c98385164fc4d95e222" translate="yes" xml:space="preserve">
          <source>When compilation is involved, exception &lt;code&gt;badarg&lt;/code&gt; is thrown if a compilation error occurs. Call &lt;code&gt;compile/2&lt;/code&gt; to get information about the location of the error in the regular expression.</source>
          <target state="translated">При компиляции &lt;code&gt;badarg&lt;/code&gt; исключение badarg, если возникает ошибка компиляции. Вызовите &lt;code&gt;compile/2&lt;/code&gt; , чтобы получить информацию о местонахождении ошибки в регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="70f94aaa056c45f783cd020ccfb0c871d028ac6c" translate="yes" xml:space="preserve">
          <source>When connections gets broken (that is explicitly by megaco:disconnect/2 or when its controlling process dies) a user callback function is invoked in order to allow the user to re-establish the connection. The internal state of kept messages, re-send timers etc. is not affected by this. A few re-sends will of course fail while the connection is down, but the automatic re-send algorithm does not bother about this and eventually when the connection is up and running the messages will be delivered if the timeouts are set to be long enough. The user has the option of explicitly invoking megaco:cancel/2 to cancel all messages for a connection.</source>
          <target state="translated">При обрыве соединения (т.е.явно через megaco:disconnect/2 или при умирании управляющего процесса)вызывается функция обратного вызова пользователя,позволяющая пользователю восстановить соединение.Внутреннее состояние сохраненных сообщений,таймеров повторной отправки и т.д.на это не влияет.Некоторые повторные отправки,конечно же,не будут работать,когда соединение не работает,но алгоритм автоматической повторной отправки не беспокоит,и в конце концов,когда соединение установлено и работает,сообщения будут доставлены,если таймауты настроены на достаточно длительный период времени.Пользователь имеет возможность явно вызвать megaco:cancel/2,чтобы отменить все сообщения для соединения.</target>
        </trans-unit>
        <trans-unit id="eee80008193ca8beab002b82928ea575e05d44fd" translate="yes" xml:space="preserve">
          <source>When constructing a segment of a &lt;code&gt;utf&lt;/code&gt; type, &lt;code&gt;Value&lt;/code&gt; must be an integer in the range 0..16#D7FF or 16#E000....16#10FFFF. Construction fails with a &lt;code&gt;badarg&lt;/code&gt; exception if &lt;code&gt;Value&lt;/code&gt; is outside the allowed ranges. The size of the resulting binary segment depends on the type or &lt;code&gt;Value&lt;/code&gt;, or both:</source>
          <target state="translated">При построении сегмента &lt;code&gt;utf&lt;/code&gt; типа, &lt;code&gt;Value&lt;/code&gt; должно быть целым числом в диапазоне 0..16 # D7FF или 16 # E000 .... 16 # 10FFFF. Конструкция завершается ошибкой с исключением &lt;code&gt;badarg&lt;/code&gt; , если &lt;code&gt;Value&lt;/code&gt; выходит за допустимые пределы. Размер результирующего двоичного сегмента зависит от типа, &lt;code&gt;Value&lt;/code&gt; или обоих:</target>
        </trans-unit>
        <trans-unit id="2dfba87ba5340bf590a9719ae92123f1780ed535" translate="yes" xml:space="preserve">
          <source>When constructing binaries, &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; can be any Erlang expression. However, for syntactical reasons, both &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; must be enclosed in parenthesis if the expression consists of anything more than a single literal or a variable. The following gives a compiler syntax error:</source>
          <target state="translated">При создании двоичных файлов &lt;code&gt;Value&lt;/code&gt; и &lt;code&gt;Size&lt;/code&gt; могут быть любым выражением Erlang. Однако по синтаксическим причинам и &lt;code&gt;Value&lt;/code&gt; , и &lt;code&gt;Size&lt;/code&gt; должны быть заключены в круглые скобки, если выражение состоит из чего-либо, кроме одного литерала или переменной. Следующее дает синтаксическую ошибку компилятора:</target>
        </trans-unit>
        <trans-unit id="a4d4be88f085f6842045d6bb85ffd60f1c5e2495" translate="yes" xml:space="preserve">
          <source>When constructing binaries, if the size &lt;code&gt;N&lt;/code&gt; of an integer segment is too small to contain the given integer, the most significant bits of the integer are silently discarded and only the &lt;code&gt;N&lt;/code&gt; least significant bits are put into the binary.</source>
          <target state="translated">При построении двоичных файлов, если размер &lt;code&gt;N&lt;/code&gt; целочисленного сегмента слишком мал, чтобы содержать данное целое число, наиболее значимые биты целого числа автоматически отбрасываются, и только &lt;code&gt;N&lt;/code&gt; наименее значимых битов помещаются в двоичный файл.</target>
        </trans-unit>
        <trans-unit id="ed7c4511bca13fde6765438ddbde809cac5d3478" translate="yes" xml:space="preserve">
          <source>When constructing, a literal string can be given followed by one of the UTF types, for example: &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; which is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">При построении можно указать буквенную строку, за которой следует один из типов UTF, например: &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; который является синтаксическим сахаром для &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ed84f016fc083dab3c16b2cd6e8fe5dee14cdb" translate="yes" xml:space="preserve">
          <source>When creating a record to be used in a select/match operation, you want most of the fields to have the value &quot;_&quot;. The easiest and fastest way to do that is as follows:</source>
          <target state="translated">При создании записи для использования в операции выделения/сопоставления необходимо,чтобы большинство полей имели значение &quot;_&quot;.Самый простой и быстрый способ сделать это следующий:</target>
        </trans-unit>
        <trans-unit id="0be878ceb74375986a99208578a50205223bc154" translate="yes" xml:space="preserve">
          <source>When creating a system using Erlang/OTP, the simplest way is to install Erlang/OTP somewhere, install the application-specific code somewhere else, and then start the Erlang runtime system, making sure the code path includes the application-specific code.</source>
          <target state="translated">При создании системы,использующей Erlang/OTP,самым простым способом является установка Erlang/OTP где-нибудь,установка кода,специфичного для приложений,а затем запуск системы Erlang runtime,убедившись,что путь к коду включает код,специфичный для приложений.</target>
        </trans-unit>
        <trans-unit id="f9a48110445b8b431b0a819b4efed940d95979f9" translate="yes" xml:space="preserve">
          <source>When creating test suites, it is strongly recommended to not create dependencies between test cases, that is, letting test cases depend on the result of previous test cases. There are various reasons for this, such as, the following:</source>
          <target state="translated">При создании наборов тестов настоятельно не рекомендуется создавать зависимости между тестовыми случаями,то есть позволять тестовым случаям зависеть от результата предыдущих тестовых случаев.Этому есть различные причины,например,следующие:</target>
        </trans-unit>
        <trans-unit id="26cf28e2e1bf20fe1af4eb848b0d0a7d334f0f8b" translate="yes" xml:space="preserve">
          <source>When debugging a process with the functions of this module, the process generates &lt;strong&gt;system_events&lt;/strong&gt;, which are then treated in the debug function. For example, &lt;code&gt;trace&lt;/code&gt; formats the system events to the terminal.</source>
          <target state="translated">При отладке процесса с помощью функций этого модуля процесс генерирует &lt;strong&gt;system_events&lt;/strong&gt; , которые затем обрабатываются в функции отладки. Например, &lt;code&gt;trace&lt;/code&gt; форматирует системные события на терминал.</target>
        </trans-unit>
        <trans-unit id="f636b27b7770791a083db3563a557efb2923ba0e" translate="yes" xml:space="preserve">
          <source>When decoding &lt;code&gt;property_group()&lt;/code&gt; or &lt;code&gt;property_groups()&lt;/code&gt;, those property parameter constructs that cannot be decoded (either because of decode error or because they are unknown), will be returned as a two-tuple. The first element of which will be the (undecoded) property parameter and the other the actual reason. This means that the caller of this function has to expect not only sdp-records, but also this two-tuple construct.</source>
          <target state="translated">При декодировании &lt;code&gt;property_group()&lt;/code&gt; или &lt;code&gt;property_groups()&lt;/code&gt; те конструкции параметров свойств, которые не могут быть декодированы (либо из-за ошибки декодирования, либо потому, что они неизвестны), будут возвращены в виде двух кортежей. Первым элементом будет параметр свойства (недекодированный), а вторым - фактическая причина. Это означает, что вызывающий эту функцию должен ожидать не только sdp-записи, но и эту двухкортежную конструкцию.</target>
        </trans-unit>
        <trans-unit id="17f3e727c9b04040e7e330882d55b9758d892ab6" translate="yes" xml:space="preserve">
          <source>When decoding a type that uses an extensible set constraint, it is always possible that the value in field &lt;code&gt;UNIQUE&lt;/code&gt; is unknown (that is, the type has been encoded with a later version of the ASN.1 specification). The unencoded data is then returned wrapped in a tuple as follows:</source>
          <target state="translated">При декодировании типа, который использует расширяемое ограничение набора, всегда возможно, что значение в поле &lt;code&gt;UNIQUE&lt;/code&gt; неизвестно (то есть тип был закодирован с помощью более поздней версии спецификации ASN.1). Незакодированные данные затем возвращаются в виде кортежа следующим образом:</target>
        </trans-unit>
        <trans-unit id="15c1a9e3a07dbc42bbebe73b1a8cb57a2a65f591" translate="yes" xml:space="preserve">
          <source>When decoding binaries from untrusted sources, consider using &lt;code&gt;binary_to_term/2&lt;/code&gt; to prevent Denial of Service attacks.</source>
          <target state="translated">При декодировании двоичных файлов из ненадежных источников рассмотрите возможность использования &lt;code&gt;binary_to_term/2&lt;/code&gt; для предотвращения атак типа &amp;laquo;отказ в обслуживании&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d0e0e586b31755d07f5d7b42305304a2d4527232" translate="yes" xml:space="preserve">
          <source>When decoding, optional fields will be omitted from the map:</source>
          <target state="translated">При декодировании необязательные поля будут опущены с карты:</target>
        </trans-unit>
        <trans-unit id="e2aad35acaab6959e7cb6145c3615cfd817ae41a" translate="yes" xml:space="preserve">
          <source>When describing a set of functions (that is, a module, a part of a module, or an application), executing in a process and wanting to use a ddll-driver, we use the term &lt;strong&gt;user&lt;/strong&gt;. A process can have many users (different modules needing the same driver) and many processes running the same code, making up many &lt;strong&gt;users&lt;/strong&gt; of a driver.</source>
          <target state="translated">При описании набора функций (то есть модуля, части модуля или приложения), выполняемых в процессе и желающих использовать ddll-драйвер, мы используем термин &lt;strong&gt;пользователь&lt;/strong&gt; . У процесса может быть много пользователей (для разных модулей нужен один и тот же драйвер) и множество процессов, выполняющих один и тот же код, что составляет множество &lt;strong&gt;пользователей&lt;/strong&gt; драйвера.</target>
        </trans-unit>
        <trans-unit id="d599e465efb7551b80d5232a1bfe503d0d783500" translate="yes" xml:space="preserve">
          <source>When developing with Erlang/OTP you usually test your programs from the interactive shell (see &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;) where you can call individual functions. There is also a number of tools available, such as the graphical &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;Debugger&lt;/a&gt; and the &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;Observer tool&lt;/a&gt; for inspection of system information, ets and mnesia tables etc.</source>
          <target state="translated">При разработке с помощью Erlang / OTP вы обычно тестируете свои программы из интерактивной оболочки (см. &amp;laquo; &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;Начало работы с Erlang&amp;raquo;&lt;/a&gt; ), где вы можете вызывать отдельные функции. Также доступен ряд инструментов, таких как графический &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;отладчик&lt;/a&gt; и &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;инструмент Observer&lt;/a&gt; для проверки системной информации, таблиц ets и mnesia и т. Д.</target>
        </trans-unit>
        <trans-unit id="7bf2dfb99c11e0b6eebdf245aebada381fb9ab39" translate="yes" xml:space="preserve">
          <source>When disabling trace, the option must match the type of trace set on the function. That is, local tracing must be disabled with option &lt;code&gt;local&lt;/code&gt; and global tracing with option &lt;code&gt;global&lt;/code&gt; (or no option), and so on.</source>
          <target state="translated">При отключении трассировки параметр должен соответствовать типу трассировки, заданному для функции. То есть, локальную трассировку необходимо отключить с помощью параметра &lt;code&gt;local&lt;/code&gt; , а глобальную трассировку - с помощью параметра &lt;code&gt;global&lt;/code&gt; (или без параметра) и так далее.</target>
        </trans-unit>
        <trans-unit id="8e262a7b92cfd57af3c5fc673b211db44e0d61d2" translate="yes" xml:space="preserve">
          <source>When doing &lt;code&gt;make install&lt;/code&gt; and the default installation prefix is used, relative symbolic links will be created from &lt;code&gt;/usr/local/bin&lt;/code&gt; to all public Erlang/OTP executables in &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt;. The installation phase will try to create relative symbolic links as long as &lt;code&gt;--bindir&lt;/code&gt; and the Erlang bin directory, located under &lt;code&gt;--libdir&lt;/code&gt;, both have &lt;code&gt;--exec-prefix&lt;/code&gt; as prefix. Where &lt;code&gt;--exec-prefix&lt;/code&gt; defaults to &lt;code&gt;--prefix&lt;/code&gt;. &lt;code&gt;--prefix&lt;/code&gt;, &lt;code&gt;--exec-prefix&lt;/code&gt;, &lt;code&gt;--bindir&lt;/code&gt;, and &lt;code&gt;--libdir&lt;/code&gt; are all arguments that can be passed to &lt;code&gt;configure&lt;/code&gt;. One can force relative, or absolute links by passing &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; as arguments to &lt;code&gt;make&lt;/code&gt; during the install phase. Note that such a request might cause a failure if the request cannot be satisfied.</source>
          <target state="translated">При выполнении &lt;code&gt;make install&lt;/code&gt; и использовании префикса установки по умолчанию будут созданы относительные символические ссылки из &lt;code&gt;/usr/local/bin&lt;/code&gt; на все общедоступные исполняемые файлы Erlang / OTP в &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt; . На этапе установки будут пытаться создать относительные символические ссылки, если &lt;code&gt;--bindir&lt;/code&gt; и каталог bin Erlang, расположенный под &lt;code&gt;--libdir&lt;/code&gt; , имеют &lt;code&gt;--exec-prefix&lt;/code&gt; prefix. Где &lt;code&gt;--exec-prefix&lt;/code&gt; по умолчанию &lt;code&gt;--prefix&lt;/code&gt; . &lt;code&gt;--prefix&lt;/code&gt; , &lt;code&gt;--exec-prefix&lt;/code&gt; , &lt;code&gt;--bindir&lt;/code&gt; и &lt;code&gt;--libdir&lt;/code&gt; - все аргументы, которые можно передать для &lt;code&gt;configure&lt;/code&gt; , Можно заставить относительные или абсолютные ссылки, проходящее &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; в качестве аргументов , чтобы &lt;code&gt;make&lt;/code&gt; во время установки фазы. Обратите внимание, что такой запрос может вызвать сбой, если запрос не может быть удовлетворен.</target>
        </trans-unit>
        <trans-unit id="a2786f78387349e137e785c359068f69a038e2e9" translate="yes" xml:space="preserve">
          <source>When dumping the table, some information about the table is dumped to a header at the beginning of the dump. This information contains data about the table type, name, protection, size, version, and if it is a named table. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file.</source>
          <target state="translated">При сбросе таблицы некоторая информация о таблице сбрасывается в заголовок в начале сбрасывания.Эта информация содержит данные о типе таблицы,ее имени,защите,размере,версии,а также о том,является ли таблица именованной.Она также содержит примечания о том,какая расширенная информация добавляется в файл,это может быть счетчик объектов в файле или MD5-сумма заголовка и записей в файле.</target>
        </trans-unit>
        <trans-unit id="8bb8dc80e08844ad0426660bafbab7a03b0891ac" translate="yes" xml:space="preserve">
          <source>When editing normal text in text mode you can let Emacs reformat the text by the &lt;code&gt;fill-paragraph&lt;/code&gt; command. This command will not work for comments since it will treat the comment characters as words.</source>
          <target state="translated">При редактировании обычного текста в текстовом режиме вы можете позволить Emacs переформатировать текст с помощью команды &lt;code&gt;fill-paragraph&lt;/code&gt; . Эта команда не будет работать с комментариями, так как она будет рассматривать символы комментария как слова.</target>
        </trans-unit>
        <trans-unit id="385563ac3b6af3039b39f79f5505ddf536cbbbf9" translate="yes" xml:space="preserve">
          <source>When enabled, it prevents decoding data that can be used to attack the Erlang system. In the event of receiving unsafe data, decoding fails with a &lt;code&gt;badarg&lt;/code&gt; error.</source>
          <target state="translated">Когда он включен, он предотвращает декодирование данных, которые могут быть использованы для атаки на систему Erlang. В случае получения небезопасных данных декодирование завершается ошибкой &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e911575fa07d922476972d70c313e02f9b293dc" translate="yes" xml:space="preserve">
          <source>When enabling an &lt;code&gt;Item&lt;/code&gt; that represents a group of processes, the &lt;code&gt;Item&lt;/code&gt; is enabled on all nodes added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">При включении &lt;code&gt;Item&lt;/code&gt; , представляющего группу процессов, этот &lt;code&gt;Item&lt;/code&gt; включается на всех узлах, добавленных с помощью функции &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961f18823d723f8de73592aaed24463820242f21" translate="yes" xml:space="preserve">
          <source>When encoding action requests for one transaction, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When encoding action requests for several transactions, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">При кодировании запросов действий для одной транзакции, &lt;code&gt;Actions&lt;/code&gt; должны быть &lt;code&gt;action_reqs()&lt;/code&gt; . При кодировании запросов действий для нескольких транзакций, &lt;code&gt;Actions&lt;/code&gt; должны быть &lt;code&gt;[action_reqs()]&lt;/code&gt; . Каждый элемент списка является частью одной транзакции.</target>
        </trans-unit>
        <trans-unit id="c3e08a1905a5b3e0dc65abec6d55dd6312a7226f" translate="yes" xml:space="preserve">
          <source>When evaluating a digit map, a state machine waits for timeouts and letters reported by megaco:report_digit_event/2. The length of the various timeouts are defined in the digit_map_value() record.</source>
          <target state="translated">При оценке цифровой карты государственная машина ждет таймаута и писем,о которых сообщает megaco:report_digit_event/2.Длительность различных таймаутов определяется в записи digit_map_value().</target>
        </trans-unit>
        <trans-unit id="bd3c6596324fcf3c283be7c0b3555d1b46a28bd6" translate="yes" xml:space="preserve">
          <source>When evaluating an expression, the operator with the highest priority is evaluated first. Operators with the same priority are evaluated according to their associativity.</source>
          <target state="translated">При оценке выражения сначала вычисляется оператор с наивысшим приоритетом.Операторы с одинаковым приоритетом оцениваются по их ассоциативности.</target>
        </trans-unit>
        <trans-unit id="1250bb19a7c4cde6aa87a09dc8b61c235001dd61" translate="yes" xml:space="preserve">
          <source>When executing in an emulator thread, it is &lt;strong&gt;very important&lt;/strong&gt; that you unlock &lt;strong&gt;all&lt;/strong&gt; locks you have locked before letting the thread out of your control; otherwise you are &lt;strong&gt;very likely&lt;/strong&gt; to deadlock the whole emulator.</source>
          <target state="translated">При выполнении в потоке эмулятора &lt;strong&gt;очень важно&lt;/strong&gt; разблокировать &lt;strong&gt;все&lt;/strong&gt; блокировки, которые вы заблокировали, прежде чем позволить потоку выйти из-под вашего контроля; в противном случае вы, &lt;strong&gt;скорее всего,&lt;/strong&gt; заблокируете весь эмулятор.</target>
        </trans-unit>
        <trans-unit id="3d063e02c2be3b7faac0250e13934a29e88d4cb4" translate="yes" xml:space="preserve">
          <source>When executing the &lt;code&gt;etop&lt;/code&gt; script, configuration parameters can be specified as command-line options, for example, &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt;. The following configuration parameters exist for the tool:</source>
          <target state="translated">При выполнении сценария &lt;code&gt;etop&lt;/code&gt; параметры конфигурации могут быть указаны как параметры командной строки, например, &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt; . Для инструмента существуют следующие параметры конфигурации:</target>
        </trans-unit>
        <trans-unit id="9eb714d64a16860edb9466fdec5e16164e92007d" translate="yes" xml:space="preserve">
          <source>When executing within a CTH, all timetraps are shut off. So if your CTH never returns, the entire test run is stalled.</source>
          <target state="translated">При выполнении в пределах CTH все расписания отключаются.Так что,если CTH никогда не вернется,весь пробный запуск затормозится.</target>
        </trans-unit>
        <trans-unit id="407f5e1130fa4448aafc45d4cd243aed3adf7a96" translate="yes" xml:space="preserve">
          <source>When failing, all three functions set &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">В случае сбоя все три функции устанавливают &lt;code&gt;erl_errno&lt;/code&gt; в одно из:</target>
        </trans-unit>
        <trans-unit id="40b47ee65ea9b082b925d4c051f321ad5844fe95" translate="yes" xml:space="preserve">
          <source>When fragments are added or deleted, &lt;code&gt;Mnesia&lt;/code&gt; automatically propagates the operation to all fragmented tables that have a foreign key referring to this table. Instead of using the record key to determine which fragment to access, the value of field &lt;code&gt;Attr&lt;/code&gt; is used. This feature makes it possible to colocate records automatically in different tables to the same node. &lt;code&gt;foreign_key&lt;/code&gt; defaults to &lt;code&gt;undefined&lt;/code&gt;. However, if the foreign key is set to something else, it causes the default values of the other fragmentation properties to be the same values as the actual fragmentation properties of the foreign table.</source>
          <target state="translated">Когда фрагменты добавляются или удаляются, &lt;code&gt;Mnesia&lt;/code&gt; автоматически распространяет операцию на все фрагментированные таблицы, у которых есть внешний ключ, ссылающийся на эту таблицу. Вместо использования ключа записи для определения того, к какому фрагменту нужно получить доступ, используется значение поля &lt;code&gt;Attr&lt;/code&gt; . Эта функция позволяет автоматически размещать записи в разных таблицах на одном и том же узле. &lt;code&gt;foreign_key&lt;/code&gt; по умолчанию &lt;code&gt;undefined&lt;/code&gt; . Однако, если для внешнего ключа установлено другое значение, это приводит к тому, что значения по умолчанию для других свойств фрагментации будут такими же, как и фактические свойства фрагментации сторонней таблицы.</target>
        </trans-unit>
        <trans-unit id="333f980f252538f0da8f8c81fee6306212deb2e4" translate="yes" xml:space="preserve">
          <source>When generating the &lt;code&gt;relup&lt;/code&gt; file, &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures that there is only one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and that it is the last instruction in the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">При &lt;code&gt;relup&lt;/code&gt; файла &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; гарантирует, что существует только одна инструкция &lt;code&gt;restart_emulator&lt;/code&gt; и что это последняя инструкция в файле &lt;code&gt;relup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80c099bc81dcbffa43792d0bf735abab5b902a73" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;code&gt;ssh&lt;/code&gt; subsystem for daemons, use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (Replaces ssh_daemon_channel) instead.</source>
          <target state="translated">При реализации подсистемы &lt;code&gt;ssh&lt;/code&gt; для демонов используйте вместо этого &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (заменяет ssh_daemon_channel).</target>
        </trans-unit>
        <trans-unit id="f6478258292a96422b7f4fde5f2a8507d5b2f75a" translate="yes" xml:space="preserve">
          <source>When implementing a client subsystem handler, use &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">При реализации обработчика клиентской подсистемы вместо этого используйте &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0817fdff736a7fb006dde9156f2e254a826ee1a2" translate="yes" xml:space="preserve">
          <source>When importing MIBs, ensure that the imported MIBs as well as the importing MIB are compiled using the same version of the SNMP-compiler.</source>
          <target state="translated">При импорте MIB убедитесь,что импортируемые MIB,а также импортируемые MIB скомпилированы с использованием той же версии SNMP-компилятора.</target>
        </trans-unit>
        <trans-unit id="4d86af8d65c195f9b07f8aefb0aff8be5ef9554d" translate="yes" xml:space="preserve">
          <source>When inputting data using sql_query/[2,3] the values will always be in string format as they are part of an SQL-query. Example:</source>
          <target state="translated">При вводе данных с помощью sql_query/[2,3]значения всегда будут в строковом формате,так как они являются частью SQL-запроса.Пример:</target>
        </trans-unit>
        <trans-unit id="38a61084660618420bf57899c1e143bbdfd319d4" translate="yes" xml:space="preserve">
          <source>When installing a release, the application specifications are automatically updated before evaluating the &lt;code&gt;relup&lt;/code&gt; script. Thus, no instructions are needed in the &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">При установке выпуска спецификации приложения автоматически обновляются перед оценкой сценария &lt;code&gt;relup&lt;/code&gt; . Таким образом, никаких инструкций в файле &lt;code&gt;.appup&lt;/code&gt; не требуется :</target>
        </trans-unit>
        <trans-unit id="ab36faf918b13f9650566e7cda312d53b2b058cb" translate="yes" xml:space="preserve">
          <source>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</source>
          <target state="translated">При включенной аппаратуре эмулятор использует больше памяти и работает медленнее.</target>
        </trans-unit>
        <trans-unit id="613cb49badd27e8334ffae06e691a346b0c3156f" translate="yes" xml:space="preserve">
          <source>When interpreting the data for a process, it is helpful to know that anonymous function objects (funs) are given the following:</source>
          <target state="translated">При интерпретации данных для процесса полезно знать,что анонимные объекты функций (funs)даются следующим образом:</target>
        </trans-unit>
        <trans-unit id="a7a1e6f2364e14a4f8731ff03ef081c6c153b8e5" translate="yes" xml:space="preserve">
          <source>When it comes to pure encode/decode performance, it turns out that:</source>
          <target state="translated">Когда дело доходит до чистой производительности кодирования/декодирования,получается,что:</target>
        </trans-unit>
        <trans-unit id="fdb9a1b728613db78be0dae343529296127017c3" translate="yes" xml:space="preserve">
          <source>When it is guaranteed that all trace messages are delivered to the tracer up to the point that &lt;code&gt;Tracee&lt;/code&gt; reached at the time of the call to &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;, then a &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; message is sent to the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</source>
          <target state="translated">Когда гарантируется, что все сообщения трассировки доставляются трассировщику до точки, которую &lt;code&gt;Tracee&lt;/code&gt; достигла во время вызова &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; , то вызывающему абоненту отправляется сообщение &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6efe9163e0ae5672fec51b923b5f0a3fddf22450" translate="yes" xml:space="preserve">
          <source>When libraries and escripts are expanded, the names of their contained applications will be displayed. Double click on an application name to launch an application window.</source>
          <target state="translated">При расширении библиотек и эскриптов будут отображаться имена содержащихся в них приложений.Дважды щелкните по имени приложения,чтобы запустить окно приложения.</target>
        </trans-unit>
        <trans-unit id="8ec607efa45c31ad1357f20a7d66c6c141bb9cf2" translate="yes" xml:space="preserve">
          <source>When linking:</source>
          <target state="translated">При соединении:</target>
        </trans-unit>
        <trans-unit id="d08f2f18c94939c7eb816f59b144c9e39119701b" translate="yes" xml:space="preserve">
          <source>When loading, function &lt;code&gt;load/2&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; when any instance of the driver is present. Thus, if a driver is waiting to get unloaded (because of open ports), it simply changes state to no longer need unloading.</source>
          <target state="translated">При загрузке функция &lt;code&gt;load/2&lt;/code&gt; возвращает &lt;code&gt;ok&lt;/code&gt; , если присутствует любой экземпляр драйвера. Таким образом, если драйвер ожидает выгрузки (из-за открытых портов), он просто меняет состояние, чтобы больше не нуждаться в выгрузке.</target>
        </trans-unit>
        <trans-unit id="65fab8b9afb79981ea75c2c9f545c0487fc0a213" translate="yes" xml:space="preserve">
          <source>When looking at memory usage in a running system the most basic function to get information from is &lt;code&gt;erlang:memory()&lt;/code&gt;. It returns the current memory usage of the system. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of where memory is used.</source>
          <target state="translated">При рассмотрении использования памяти в работающей системе самая основная функция для получения информации - это &lt;code&gt;erlang:memory()&lt;/code&gt; . Он возвращает текущее использование памяти системой. &lt;code&gt;instrument(3)&lt;/code&gt; можно использовать для получения более подробной информации о том, где используется память.</target>
        </trans-unit>
        <trans-unit id="afc0303546ea4a5cee3b6a223eb3288b9d2ea037" translate="yes" xml:space="preserve">
          <source>When macros are expanded in expressions the macro calls are replaced by the macro value without any form of quoting or enclosing in parentheses.</source>
          <target state="translated">При расширении макросов в выражениях вызовы макросов заменяются значением макроса без каких-либо кавычек или заключений в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="6e14461d99df8d7f5bd6dbaee93c610c2ce18da3" translate="yes" xml:space="preserve">
          <source>When many types (or another ASN.1 entity) only differ in some minor cases, but the structure of the types is similar, only one general type can be defined and the differences can be supplied through parameters.</source>
          <target state="translated">Когда многие типы (или другой субъект ASN.1)различаются только в некоторых незначительных случаях,но структура типов похожа,можно определить только один общий тип,и различия могут быть обеспечены через параметры.</target>
        </trans-unit>
        <trans-unit id="e3e3f53fcfe03af37581eeb29d3a1f8a21d06868" translate="yes" xml:space="preserve">
          <source>When matched against a term, both &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are matched against the term. The idea behind this feature is to avoid reconstruction of terms.</source>
          <target state="translated">Когда сопоставляются сроком, как &lt;code&gt;Pattern1&lt;/code&gt; и &lt;code&gt;Pattern2&lt;/code&gt; сопоставляются с термином. Идея этой функции состоит в том, чтобы избежать реконструкции терминов.</target>
        </trans-unit>
        <trans-unit id="70ef1970aabf29043b85da367698cefcc4f383ae" translate="yes" xml:space="preserve">
          <source>When matching &lt;code&gt;Value&lt;/code&gt;, value must be either a variable or an integer, or a floating point literal. Expressions are not allowed.</source>
          <target state="translated">При сопоставлении &lt;code&gt;Value&lt;/code&gt; значение должно быть либо переменной, либо целым числом, либо литералом с плавающей запятой. Выражения не допускаются.</target>
        </trans-unit>
        <trans-unit id="919226a6786be88542935b4ae72b62f44ea75480" translate="yes" xml:space="preserve">
          <source>When matching strings, the following is a valid pattern:</source>
          <target state="translated">При совпадении строк действительным шаблоном является следующий:</target>
        </trans-unit>
        <trans-unit id="d1c82c501be92ba824ae89344ef75c4d9af9bf67" translate="yes" xml:space="preserve">
          <source>When megaco fails to send the reply (see &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;), for whatever reason.</source>
          <target state="translated">Когда megaco не может отправить ответ (см. &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; ) по какой-либо причине.</target>
        </trans-unit>
        <trans-unit id="acae380ca138d49866a8d2225bb9fdf2866a8ef8" translate="yes" xml:space="preserve">
          <source>When messages are &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This is because the version number is implied by the version number in the distribution header.</source>
          <target state="translated">Когда сообщения &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; и используется &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; , первый байт, содержащий номер версии (131), опускается из терминов, следующих за заголовком распределения. Это связано с тем, что номер версии подразумевается номером версии в заголовке дистрибутива.</target>
        </trans-unit>
        <trans-unit id="787e404397583f253bb775c283cf222bacb2db6c" translate="yes" xml:space="preserve">
          <source>When monitoring is requested, and a corresponding &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt; would be returned, the function instead returns a tuple &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; and the process then gets a monitor message later, when the driver gets loaded. The monitor message to expect is described in the function description of &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Когда запрашивается мониторинг и &lt;code&gt;{ok, pending_driver}&lt;/code&gt; соответствующий {ok, pending_driver} или &lt;code&gt;{ok, pending_process}&lt;/code&gt; , функция вместо этого возвращает кортеж &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; а затем процесс получает сообщение монитора позже, когда драйвер загружается. Ожидаемое сообщение монитора описано в описании функции &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efb7c3fa2502fdd9d0754635086f8f9899582889" translate="yes" xml:space="preserve">
          <source>When multiple test specification files are specified at startup (either with &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; or &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; either executes one test run per specification file, or joins the files and performs all tests within one single test run. The first behavior is the default one. The latter requires that start flag/option &lt;code&gt;join_specs&lt;/code&gt; is provided, for example, &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt;.</source>
          <target state="translated">Если при запуске указано несколько файлов спецификации теста (либо с помощью &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; или &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt; ), &lt;code&gt;Common Test&lt;/code&gt; либо выполняет один тестовый запуск на файл спецификации или объединяет файлы и выполняет все тесты в рамках одного запуска теста. Первое поведение - поведение по умолчанию. Последнее требует наличия начального флага / опции &lt;code&gt;join_specs&lt;/code&gt; , например &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d4d379ce1acc3e58649f3f6e5610dec08b734cc" translate="yes" xml:space="preserve">
          <source>When new nodes are added to the network, they are informed of the globally registered names that already exist. The network is also informed of any global names in newly connected nodes. If any name clashes are discovered, function &lt;code&gt;Resolve&lt;/code&gt; is called. Its purpose is to decide which pid is correct. If the function crashes, or returns anything other than one of the pids, the name is unregistered. This function is called once for each name clash.</source>
          <target state="translated">Когда новые узлы добавляются в сеть, они информируются об уже существующих глобально зарегистрированных именах. Сеть также информируется о любых глобальных именах во вновь подключенных узлах. Если обнаруживаются конфликты имен, вызывается функция &lt;code&gt;Resolve&lt;/code&gt; . Его цель - решить, какой pid правильный. Если функция дает сбой или возвращает что-либо, кроме одного из pid, имя не зарегистрировано. Эта функция вызывается один раз для каждого конфликта имен.</target>
        </trans-unit>
        <trans-unit id="78f8bd0d1896a4dff8f44b290b2a56e3f9fcb215" translate="yes" xml:space="preserve">
          <source>When one node wants to connect to another node it starts with a &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; request to the EPMD on the host where the node resides to get the distribution port that the node listens to.</source>
          <target state="translated">Когда один узел хочет подключиться к другому узлу, он начинает с запроса &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; к EPMD на узле, где находится узел, чтобы получить порт распределения, который этот узел прослушивает.</target>
        </trans-unit>
        <trans-unit id="733930eec7fc5b747c5c2817c8d2e79c6f4e243c" translate="yes" xml:space="preserve">
          <source>When one of these option changes occurs at top-level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows.</source>
          <target state="translated">Когда одно из этих изменений происходит на верхнем уровне (т.е.не внутри скобок подмаскивания),изменение применяется к оставшейся части детали,которая следует за ним.</target>
        </trans-unit>
        <trans-unit id="b86cd46910a6aa214f7f42e5ee8633b337f649a0" translate="yes" xml:space="preserve">
          <source>When opening an existing wrap log, it is not necessary to supply a value for option &lt;code&gt;Size&lt;/code&gt;, but any supplied value must equal the current log size, otherwise the tuple &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; is returned.</source>
          <target state="translated">При открытии существующего журнала &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; значение для параметра &lt;code&gt;Size&lt;/code&gt; , но любое предоставленное значение должно равняться текущему размеру журнала, в противном случае возвращается кортеж {error, {size_mismatch, CurrentSize, NewSize}} .</target>
        </trans-unit>
        <trans-unit id="2c7edf9e74339539f6cc3b3080ee90687bd35019" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;global&lt;/code&gt; is speciified, the &lt;code&gt;capture&lt;/code&gt; specification affects each match separately, so that:</source>
          <target state="translated">Если указан параметр &lt;code&gt;global&lt;/code&gt; , спецификация &lt;code&gt;capture&lt;/code&gt; влияет на каждое совпадение отдельно, так что:</target>
        </trans-unit>
        <trans-unit id="35779093faa3e10fba6141595e13648b564ea182" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;unicode&lt;/code&gt; is specified, the regular expression is to be specified as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise as any valid &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">Если указан параметр &lt;code&gt;unicode&lt;/code&gt; , регулярное выражение должно быть указано как действительный &lt;code&gt;charlist()&lt;/code&gt; символов Unicode () , иначе как любые допустимые данные &lt;code&gt;iodata()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55a165a455c0fbb6c5fe22fe047dc9f316e166c5" translate="yes" xml:space="preserve">
          <source>When ordered to shut down, the &lt;code&gt;gen_statem&lt;/code&gt; then calls callback function &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt;.</source>
          <target state="translated">При получении команды на выключение &lt;code&gt;gen_statem&lt;/code&gt; затем вызывает функцию обратного вызова &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c0af6f0c64d162765f0e344a6e84e0addaa2a2" translate="yes" xml:space="preserve">
          <source>When packaging code using &lt;code&gt;systools&lt;/code&gt;, the code for each application is placed in a separate directory, &lt;code&gt;lib/Application-Vsn&lt;/code&gt;, where &lt;code&gt;Vsn&lt;/code&gt; is the version number.</source>
          <target state="translated">При упаковке кода с помощью &lt;code&gt;systools&lt;/code&gt; код для каждого приложения помещается в отдельный каталог &lt;code&gt;lib/Application-Vsn&lt;/code&gt; , где &lt;code&gt;Vsn&lt;/code&gt; - номер версии.</target>
        </trans-unit>
        <trans-unit id="9753680bda30c348a14a4334e6baee4da1b60e94" translate="yes" xml:space="preserve">
          <source>When parsing a URI with an unknown scheme (that is, a scheme not found in the scheme defaults), a port number must be provided, otherwise the parsing fails.</source>
          <target state="translated">При разборе URI с неизвестной схемой (т.е.схемой,не найденной в схеме по умолчанию)должен быть указан номер порта,иначе при разборе произойдет сбой.</target>
        </trans-unit>
        <trans-unit id="710f52128840cdac154a523eb3c58c2968f8b895" translate="yes" xml:space="preserve">
          <source>When parts of the MIB are implemented, you recompile it and continue on by using default functions. With this approach, the SNMP agent can be developed incrementally.</source>
          <target state="translated">Когда части MIB реализованы,вы перекомпилируете его и продолжаете использовать функции по умолчанию.При таком подходе агент SNMP может разрабатываться постепенно.</target>
        </trans-unit>
        <trans-unit id="e91864f69e3643249c414a5ca6b0b38fdf0614ca" translate="yes" xml:space="preserve">
          <source>When performance is of highest priority and you are interested in a limited part of the ASN.1 encoded message before deciding what to do with the rest of it, an option is to decode only this small part. The situation can be a server that has to decide the addressee of a message. The addressee can be interested in the entire message, but the server can be a bottleneck that you want to spare any unnecessary load.</source>
          <target state="translated">Когда производительность имеет наивысший приоритет,и вас интересует ограниченная часть закодированного сообщения ASN.1,прежде чем решить,что делать с остальной частью,опция заключается в декодировании только этой маленькой части.Ситуация может представлять собой сервер,который должен решить адресата сообщения.Адресат может быть заинтересован во всем сообщении,но сервер может быть узким местом,которое вы хотите избавить от ненужной нагрузки.</target>
        </trans-unit>
        <trans-unit id="00f8fec10d66dd9849d5606b35c3bae4eb0e24b0" translate="yes" xml:space="preserve">
          <source>When performing a GC, this is the max number of cache entries that will be deleted from the cache.</source>
          <target state="translated">При выполнении GC,это максимальное количество записей в кэше,которые будут удалены из кэша.</target>
        </trans-unit>
        <trans-unit id="c12910634b83422602cdf82ac5e1d4a0b08ca569" translate="yes" xml:space="preserve">
          <source>When positioning in a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, caution must be taken to set the position on a correct character boundary. For details, see &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При позиционировании в файле с &lt;code&gt;encoding&lt;/code&gt; отличной от &lt;code&gt;latin1&lt;/code&gt; , необходимо соблюдать осторожность, чтобы установить позицию на правильной границе символа. Подробнее см. &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1edc83622335984eb1eafacb2b7c60d225676ad9" translate="yes" xml:space="preserve">
          <source>When reading and writing to Unicode-aware entities, like a file opened for Unicode translation, you probably want to format text strings using the functions in the &lt;code&gt;io&lt;/code&gt; module or the &lt;code&gt;io_lib&lt;/code&gt; module. For backward compatibility reasons, these functions do not accept any list as a string, but require a special &lt;strong&gt;translation modifier&lt;/strong&gt; when working with Unicode texts. The modifier is &lt;code&gt;t&lt;/code&gt;. When applied to control character &lt;code&gt;s&lt;/code&gt; in a formatting string, it accepts all Unicode code points and expects binaries to be in UTF-8:</source>
          <target state="translated">При чтении и записи в объекты, поддерживающие Unicode, такие как файл, открытый для перевода Unicode, вы, вероятно, захотите отформатировать текстовые строки с помощью функций в модуле &lt;code&gt;io&lt;/code&gt; или &lt;code&gt;io_lib&lt;/code&gt; . По причинам обратной совместимости эти функции не принимают список в виде строки, но требуют специального &lt;strong&gt;модификатора перевода&lt;/strong&gt; при работе с текстами Unicode. Модификатор &lt;code&gt;t&lt;/code&gt; . При применении к управляющему символу &lt;code&gt;s&lt;/code&gt; в строке форматирования он принимает все кодовые точки Unicode и ожидает, что двоичные файлы будут в UTF-8:</target>
        </trans-unit>
        <trans-unit id="d8c1dd8823b82718c750f6e4752dce919973fd1c" translate="yes" xml:space="preserve">
          <source>When receiving data from untrusted sources, use option &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt;.</source>
          <target state="translated">При получении данных из ненадежных источников используйте опцию &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caaa8dcd0a5b73778282496efd8b85cdbc96febe" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler clears the latest received alarm with id &lt;code&gt;AlarmId&lt;/code&gt;.</source>
          <target state="translated">При получении этого события простой обработчик по умолчанию очищает последний полученный сигнал тревоги с идентификатором &lt;code&gt;AlarmId&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e62ca61b001221600279b3875635215766f5030" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler stores the alarm. &lt;code&gt;AlarmId&lt;/code&gt; identifies the alarm and is used when the alarm is cleared.</source>
          <target state="translated">При получении этого события простой обработчик по умолчанию сохраняет сигнал тревоги. &lt;code&gt;AlarmId&lt;/code&gt; идентифицирует сигнал тревоги и используется, когда сигнал тревоги сброшен.</target>
        </trans-unit>
        <trans-unit id="cab9fe9e9b48ff6bfb268655c0f4e10837898a9b" translate="yes" xml:space="preserve">
          <source>When recompiling with &lt;code&gt;gcc&lt;/code&gt;, use flag &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; to get better warnings. Try to find a similar flag if you use another compiler.</source>
          <target state="translated">При перекомпиляции с помощью &lt;code&gt;gcc&lt;/code&gt; используйте флаг &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; , чтобы получать более точные предупреждения. Попробуйте найти похожий флаг, если вы используете другой компилятор.</target>
        </trans-unit>
        <trans-unit id="5fa55ded95f5c996f7f21886e99692b06c59dfaf" translate="yes" xml:space="preserve">
          <source>When recursing and building a list, it is important to ensure that you attach the new elements to the beginning of the list. In this way, you will build &lt;strong&gt;one&lt;/strong&gt; list, not hundreds or thousands of copies of the growing result list.</source>
          <target state="translated">При рекурсии и построении списка важно убедиться, что вы прикрепляете новые элементы к началу списка. Таким образом вы создадите &lt;strong&gt;один&lt;/strong&gt; список, а не сотни или тысячи копий растущего списка результатов.</target>
        </trans-unit>
        <trans-unit id="d8bab5f0a38ad7351ef92518566a8a66e14c70a0" translate="yes" xml:space="preserve">
          <source>When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively.</source>
          <target state="translated">При активации или деактивации режима ограниченной оболочки на узле запускаются новые задания в ограниченном или нормальном режиме соответственно.</target>
        </trans-unit>
        <trans-unit id="5c2049b6ccaf60623aba58c7816db28baba978c3" translate="yes" xml:space="preserve">
          <source>When run as above (this will take some time), the measurement process is done as follows:</source>
          <target state="translated">При выполнении,как описано выше (это займет некоторое время),процесс измерения выполняется следующим образом:</target>
        </trans-unit>
        <trans-unit id="bcae0656877ffa6ebb4290ed9f508d93d062de30" translate="yes" xml:space="preserve">
          <source>When run on Linux, &lt;code&gt;cpu_sup&lt;/code&gt; assumes that the &lt;code&gt;/proc&lt;/code&gt; file system is present and accessible by &lt;code&gt;cpu_sup&lt;/code&gt;. If it is not, &lt;code&gt;cpu_sup&lt;/code&gt; will terminate.</source>
          <target state="translated">При запуске в Linux &lt;code&gt;cpu_sup&lt;/code&gt; предполагает, что файловая система &lt;code&gt;/proc&lt;/code&gt; присутствует и доступна для &lt;code&gt;cpu_sup&lt;/code&gt; . Если это не так, &lt;code&gt;cpu_sup&lt;/code&gt; прекратит работу.</target>
        </trans-unit>
        <trans-unit id="4cf54f8998c8d68cc207a24a295ffc4553d6eff1" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;high&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; are selected for execution. Notice however that this does &lt;strong&gt;not&lt;/strong&gt; mean that no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; can run when processes are running on priority &lt;code&gt;high&lt;/code&gt;. When using multiple schedulers, more processes can be running in parallel than processes on priority &lt;code&gt;high&lt;/code&gt;. That is, a &lt;code&gt;low&lt;/code&gt; and a &lt;code&gt;high&lt;/code&gt; priority process can execute at the same time.</source>
          <target state="translated">Когда существуют выполняемые процессы с &lt;code&gt;high&lt;/code&gt; приоритетом , для выполнения не выбираются процессы с &lt;code&gt;low&lt;/code&gt; или &lt;code&gt;normal&lt;/code&gt; приоритетом . Обратите внимание, однако, что это &lt;strong&gt;не&lt;/strong&gt; означает, что никакие процессы с &lt;code&gt;low&lt;/code&gt; или &lt;code&gt;normal&lt;/code&gt; приоритетом не могут выполняться, когда процессы работают с &lt;code&gt;high&lt;/code&gt; приоритетом . При использовании нескольких планировщиков параллельно может выполняться больше процессов, чем процессов с &lt;code&gt;high&lt;/code&gt; приоритетом . То есть процесс с &lt;code&gt;low&lt;/code&gt; и &lt;code&gt;high&lt;/code&gt; приоритетом может выполняться одновременно.</target>
        </trans-unit>
        <trans-unit id="bac375c5ce5278df5f7742eba36c446680185abe" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;max&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;high&lt;/code&gt; are selected for execution. As with priority &lt;code&gt;high&lt;/code&gt;, processes on lower priorities can execute in parallel with processes on priority &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Когда существуют выполняемые процессы с &lt;code&gt;max&lt;/code&gt; приоритетом , для выполнения не выбираются процессы с &lt;code&gt;low&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; или &lt;code&gt;high&lt;/code&gt; приоритетом . Как и в случае с &lt;code&gt;high&lt;/code&gt; приоритетом , процессы с более низким приоритетом могут выполняться параллельно с процессами с &lt;code&gt;max&lt;/code&gt; приоритетом .</target>
        </trans-unit>
        <trans-unit id="680e4c2820f1533afc4212ad58a52897fa7b6ea9" translate="yes" xml:space="preserve">
          <source>When running SMP erlang on a multi-core machine the &quot;throughput&quot; is significantly higher. The mstone1 test is an extreme test, but it shows what is gained by using the reentrant flex-scanner.</source>
          <target state="translated">При запуске SMP erlang на многоядерном станке &quot;пропускная способность&quot; значительно выше.Тест mstone1 является экстремальным тестом,но он показывает,что получается при использовании реентерабельного флекс-сканера.</target>
        </trans-unit>
        <trans-unit id="bb8603cea37568d4ea95955c8c7cd5ad79e8fceb" translate="yes" xml:space="preserve">
          <source>When running a distributed system with two or more participating nodes, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; must be executed on each participating node. This would typically be part of the boot script in an embedded environment. In a test environment or an interactive environment, &lt;code&gt;mnesia:start()&lt;/code&gt; can also be used either from the Erlang shell or another program.</source>
          <target state="translated">При запуске распределенной системы с двумя или более участвующими узлами функция &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; должна выполняться на каждом участвующем узле. Обычно это часть сценария загрузки во встроенной среде. В тестовой или интерактивной среде &lt;code&gt;mnesia:start()&lt;/code&gt; также можно использовать либо из оболочки Erlang, либо из другой программы.</target>
        </trans-unit>
        <trans-unit id="65e9a6705c8969bac7cd69e2170ef9d9d0ac1c6a" translate="yes" xml:space="preserve">
          <source>When running in &lt;code&gt;utf8&lt;/code&gt; mode, functions &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; never return raw filenames. To return all filenames including raw filenames, use functions &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При работе в режиме &lt;code&gt;utf8&lt;/code&gt; функции &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; никогда не возвращают необработанные имена файлов. Чтобы вернуть все имена файлов, включая необработанные имена файлов, используйте функции &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdc638646c31aefd08c7b469c60f917c3f883df" translate="yes" xml:space="preserve">
          <source>When running on OSs lacking support for monotonic time, &lt;code&gt;heart&lt;/code&gt; is susceptible to system clock adjustments of more than &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds. When this happens, &lt;code&gt;heart&lt;/code&gt; times out and tries to reboot the system. This can occur, for example, if the system clock is adjusted automatically by use of the Network Time Protocol (NTP).</source>
          <target state="translated">При работе в операционных системах, не поддерживающих монотонное время, &lt;code&gt;heart&lt;/code&gt; восприимчиво к настройкам системных часов более чем на &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; секунд. Когда это происходит, &lt;code&gt;heart&lt;/code&gt; выходит из строя и пытается перезагрузить систему. Это может произойти, например, если системные часы настраиваются автоматически с использованием протокола сетевого времени (NTP).</target>
        </trans-unit>
        <trans-unit id="5ecb6729e649e0c2e3875d3412d7df6f9ff2fc1b" translate="yes" xml:space="preserve">
          <source>When running on Windows, suppresses creation of a new console window when spawning the port program. (This option has no effect on other platforms.)</source>
          <target state="translated">При запуске на Windows подавляет создание нового консольного окна при создании программы для порта.(Эта опция не действует на других платформах).</target>
        </trans-unit>
        <trans-unit id="63b602ea12cff6b347850ec520a992d2e4051e4a" translate="yes" xml:space="preserve">
          <source>When selecting data from a table, all data types are returned from the database to the ODBC driver as an ODBC data type. The tables below shows the mapping between those data types and what is returned by the Erlang API.</source>
          <target state="translated">При выборе данных из таблицы все типы данных возвращаются из базы данных в драйвер ODBC в качестве типа данных ODBC.В таблицах ниже показано соответствие между этими типами данных и тем,что возвращается API Erlang.</target>
        </trans-unit>
        <trans-unit id="5028404a77ebb05ae66aa4cdb0300c35b354c2d2" translate="yes" xml:space="preserve">
          <source>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</source>
          <target state="translated">При отправке данных в порт.Порты понимают глубокие списки,поэтому нет смысла выравнивать список перед отправкой в порт.</target>
        </trans-unit>
        <trans-unit id="f6655794aac8234bda9f3cc8627542cf28e39cd7" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;user_reply()&lt;/code&gt;). When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;[user_reply()]&lt;/code&gt;). Each element of the list is part of one transaction.</source>
          <target state="translated">При отправке одной транзакции в сообщении &lt;code&gt;Actions&lt;/code&gt; должны быть &lt;code&gt;action_reqs()&lt;/code&gt; ( &lt;code&gt;UserReply&lt;/code&gt; тогда будет &lt;code&gt;user_reply()&lt;/code&gt; ). При отправке нескольких транзакций в сообщении &lt;code&gt;Actions&lt;/code&gt; должны быть &lt;code&gt;[action_reqs()]&lt;/code&gt; ( &lt;code&gt;UserReply&lt;/code&gt; тогда будет &lt;code&gt;[user_reply()]&lt;/code&gt; ). Каждый элемент списка является частью одной транзакции.</target>
        </trans-unit>
        <trans-unit id="342bdd47df4ec30e4e5a4ebaa64afc70c7b8eea1" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">При отправке одной транзакции в сообщении &lt;code&gt;Actions&lt;/code&gt; должны быть &lt;code&gt;action_reqs()&lt;/code&gt; . При отправке нескольких транзакций в сообщении, &lt;code&gt;Actions&lt;/code&gt; должны быть &lt;code&gt;[action_reqs()]&lt;/code&gt; . Каждый элемент списка является частью одной транзакции.</target>
        </trans-unit>
        <trans-unit id="75b19f5e353d16bcbf308a2928e10b271ad77a7b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system logs an error event via &lt;code&gt;logger&lt;/code&gt;, containing details about the process when the maximum heap size is reached. One log event is sent each time the limit is reached.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , система времени выполнения регистрирует событие ошибки через средство ведения &lt;code&gt;logger&lt;/code&gt; , содержащее подробную информацию о процессе при достижении максимального размера кучи. Одно событие журнала отправляется каждый раз при достижении лимита.</target>
        </trans-unit>
        <trans-unit id="a7a9f29c7c04f56d28d9864f8634905c97f0d23f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system sends an untrappable exit signal with reason &lt;code&gt;kill&lt;/code&gt; to the process if the maximum heap size is reached. The garbage collection that triggered the &lt;code&gt;kill&lt;/code&gt; is not completed, instead the process exits as soon as possible. When set to &lt;code&gt;false&lt;/code&gt;, no exit signal is sent to the process, instead it continues executing.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , система времени выполнения отправляет процессу неотражаемый сигнал выхода с указанием причины &lt;code&gt;kill&lt;/code&gt; , если достигается максимальный размер кучи. Сборка мусора, вызвавшая &lt;code&gt;kill&lt;/code&gt; , не завершена, вместо этого процесс завершается как можно скорее. Если установлено значение &lt;code&gt;false&lt;/code&gt; , процессу не отправляется сигнал выхода, вместо этого он продолжает выполнение.</target>
        </trans-unit>
        <trans-unit id="1535dfcd1ada0e5df2bfdd93f8582a8fb9db2211" translate="yes" xml:space="preserve">
          <source>When set, informs the peer to use &lt;code&gt;{IP, Port}&lt;/code&gt; as the primary address of the local endpoint for the association specified by &lt;code&gt;assoc_id&lt;/code&gt;.</source>
          <target state="translated">Когда установлено, сообщает одноранговому &lt;code&gt;assoc_id&lt;/code&gt; использовать &lt;code&gt;{IP, Port}&lt;/code&gt; в качестве основного адреса локальной конечной точки для ассоциации, указанной в assoc_id .</target>
        </trans-unit>
        <trans-unit id="a09fa3690c8e86bcc1ad44fbac6fe4381cfc8c36" translate="yes" xml:space="preserve">
          <source>When set, requests that the local endpoint uses the value specified by &lt;code&gt;adaptation_ind&lt;/code&gt; as the Adaptation Indication parameter for establishing new associations. For details, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если он установлен, запрашивает, чтобы локальная конечная точка использовала значение, указанное в &lt;code&gt;adaptation_ind&lt;/code&gt; в качестве параметра индикации адаптации для установления новых ассоциаций. Дополнительные сведения см. В &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35268e3a52547204a88309f957a19dbdd29a75e6" translate="yes" xml:space="preserve">
          <source>When setting up a trace, the following features can also be activated:</source>
          <target state="translated">При настройке трассы также могут быть активированы следующие функции:</target>
        </trans-unit>
        <trans-unit id="bc86d8be157ab5b84c3a61f949941d9549419fe9" translate="yes" xml:space="preserve">
          <source>When something is to be sent, everything is packed into one message, unless the trigger was a reply transaction and the added size of the reply and all the requests is greater then &lt;code&gt;trans_req_maxsize&lt;/code&gt;, in which case the stored transactions are sent first in a separate message and the reply in another message.</source>
          <target state="translated">Когда что-то должно быть отправлено, все упаковывается в одно сообщение, если только триггер не был ответной транзакцией, а добавленный размер ответа и всех запросов больше, чем &lt;code&gt;trans_req_maxsize&lt;/code&gt; , и в этом случае сохраненные транзакции сначала отправляются в отдельном сообщении. и ответ в другом сообщении.</target>
        </trans-unit>
        <trans-unit id="5c6669a85ba52eabed1bcac71536c7df178c1e61" translate="yes" xml:space="preserve">
          <source>When sorting or merging files, only the first of a sequence of terms that compare equal (&lt;code&gt;==&lt;/code&gt;) is output if this option is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;, which implies that all terms that compare equal are output. When checking files for sortedness, a check that no pair of consecutive terms compares equal is done if this option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">При сортировке или объединении файлов выводится только первый из последовательности сравниваемых терминов ( &lt;code&gt;==&lt;/code&gt; ), если для этого параметра установлено значение &lt;code&gt;true&lt;/code&gt; . По умолчанию &lt;code&gt;false&lt;/code&gt; , что означает, что выводятся все сравниваемые термины. При проверке файлов на сортировку выполняется проверка того, что никакая пара последовательных терминов не сравнивается с равными, если для этой опции установлено значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c34b332981b8e474e02ef63bcc500fd0757ef2" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can be used.</source>
          <target state="translated">При запуске &lt;code&gt;stand_alone&lt;/code&gt; можно использовать только pid.</target>
        </trans-unit>
        <trans-unit id="b66f134384d3cc9012959c5c579272f12c941335" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can used.</source>
          <target state="translated">При запуске &lt;code&gt;stand_alone&lt;/code&gt; можно использовать только pid.</target>
        </trans-unit>
        <trans-unit id="a9910d3d66f8237ea301a1cc0a52c4d81c8b1682" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt;.</source>
          <target state="translated">Когда запустил &lt;code&gt;stand_alone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ce6035e3ae59d7f18987449985901fd92e494f" translate="yes" xml:space="preserve">
          <source>When started, the node waits for all nodes specified by &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; and &lt;code&gt;sync_nodes_optional&lt;/code&gt; to come up. When all nodes are up, or when all mandatory nodes are up and the time specified by &lt;code&gt;sync_nodes_timeout&lt;/code&gt; has elapsed, all applications start. If not all mandatory nodes are up, the node terminates.</source>
          <target state="translated">При запуске узел ожидает появления всех узлов, указанных в параметрах &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; и &lt;code&gt;sync_nodes_optional&lt;/code&gt; . Когда все узлы включены или когда все обязательные узлы работают и время, указанное в &lt;code&gt;sync_nodes_timeout&lt;/code&gt; , истекло, запускаются все приложения. Если не все обязательные узлы работают, узел завершает работу.</target>
        </trans-unit>
        <trans-unit id="4f35884d86e4f1c2ac96377ac4d8d3d8958cc289" translate="yes" xml:space="preserve">
          <source>When started, the supervisor does not start any child processes. Instead, all child processes are added dynamically by calling:</source>
          <target state="translated">При запуске супервайзер не запускает никаких дочерних процессов.Вместо этого,все дочерние процессы добавляются динамически путем вызова:</target>
        </trans-unit>
        <trans-unit id="af782a2bcb2a4b2a362bed6616a129bcc6a72b52" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;Mnesia&lt;/code&gt;, a &lt;code&gt;.LOG&lt;/code&gt; file called &lt;code&gt;LATEST.LOG&lt;/code&gt; is created and placed in the database directory. This file is used by &lt;code&gt;Mnesia&lt;/code&gt; to log disc-based transactions. This includes all transactions that write at least one record in a table that is of storage type &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;disc_only_copies&lt;/code&gt;. The file also includes all operations that manipulate the schema itself, such as creating new tables. The log format can vary with different implementations of &lt;code&gt;Mnesia&lt;/code&gt;. The &lt;code&gt;Mnesia&lt;/code&gt; log is currently implemented in the standard library module &lt;code&gt;disk_log&lt;/code&gt; in &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">При запуске &lt;code&gt;Mnesia&lt;/code&gt; , &lt;code&gt;.LOG&lt;/code&gt; файл с именем &lt;code&gt;LATEST.LOG&lt;/code&gt; создан и размещен в каталоге базы данных. Этот файл используется &lt;code&gt;Mnesia&lt;/code&gt; для регистрации транзакций на дисках. Сюда входят все транзакции, которые записывают хотя бы одну запись в таблицу с типом хранилища &lt;code&gt;disc_copies&lt;/code&gt; или &lt;code&gt;disc_only_copies&lt;/code&gt; . Файл также включает в себя все операции, которые управляют самой схемой, такие как создание новых таблиц. Формат журнала может варьироваться в зависимости от реализации &lt;code&gt;Mnesia&lt;/code&gt; . Журнал &lt;code&gt;Mnesia&lt;/code&gt; в настоящее время реализован в модуле стандартной библиотеки &lt;code&gt;disk_log&lt;/code&gt; в &lt;code&gt;Kernel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbcc2618bb75c573fc25f8a846a8fe36e4ed8763" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;prim_app&lt;/code&gt; as defined above, the application controller calls the following callback functions before &lt;code&gt;application:start(prim_app)&lt;/code&gt; returns a value:</source>
          <target state="translated">При запуске &lt;code&gt;prim_app&lt;/code&gt; , как определено выше, контроллер приложения вызывает следующие функции обратного вызова перед &lt;code&gt;application:start(prim_app)&lt;/code&gt; возвращает значение:</target>
        </trans-unit>
        <trans-unit id="4cd4f1a6e7e43123fc3118e6461ff8abe900204f" translate="yes" xml:space="preserve">
          <source>When starting Erlang in embedded mode, it is assumed that exactly one system configuration file is used, named &lt;code&gt;sys.config&lt;/code&gt;. This file is to be located in &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the Erlang/OTP root installation directory and &lt;code&gt;Vsn&lt;/code&gt; is the release version.</source>
          <target state="translated">При запуске Erlang во встроенном режиме предполагается, что используется ровно один файл конфигурации системы с именем &lt;code&gt;sys.config&lt;/code&gt; . Этот файл должен находиться в &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; , где &lt;code&gt;$ROOT&lt;/code&gt; - это корневой каталог установки Erlang / OTP, а &lt;code&gt;Vsn&lt;/code&gt; - это версия выпуска.</target>
        </trans-unit>
        <trans-unit id="b5ddbb5d78d831c78a317496e7e2a2d2c40076a3" translate="yes" xml:space="preserve">
          <source>When starting Erlang/OTP using the boot script, all applications from the &lt;code&gt;.rel&lt;/code&gt; file are automatically loaded and started:</source>
          <target state="translated">При запуске Erlang / OTP с помощью сценария загрузки все приложения из файла &lt;code&gt;.rel&lt;/code&gt; автоматически загружаются и запускаются:</target>
        </trans-unit>
        <trans-unit id="b604ec38ae2b79479f9ec0cb1378442b00d5b576" translate="yes" xml:space="preserve">
          <source>When starting a primary application with included applications, the primary application is started the normal way, that is:</source>
          <target state="translated">При запуске основного приложения с включенными приложениями,основное приложение запускается обычным способом,то есть:</target>
        </trans-unit>
        <trans-unit id="ed0f727403d7e975b13ca3d05489c37f1a495f5a" translate="yes" xml:space="preserve">
          <source>When starting an Erlang node, the default behaviour is that all log events on level &lt;code&gt;notice&lt;/code&gt; or more severe, are logged to the terminal via the default handler. To also log info events, you can either change the primary log level to &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">При запуске узла Erlang поведение по умолчанию таково, что все события журнала на уровне &amp;laquo; &lt;code&gt;notice&lt;/code&gt; или более серьезные, регистрируются в терминале через обработчик по умолчанию. Чтобы также регистрировать информационные события, вы можете либо изменить уровень основного журнала на &lt;code&gt;info&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d267d7fc52461e3316cc2f612f2db868d98e7a72" translate="yes" xml:space="preserve">
          <source>When starting external programs on Solaris, the system call &lt;code&gt;vfork&lt;/code&gt; is used in preference to &lt;code&gt;fork&lt;/code&gt; for performance reasons, although it has a history of being less robust. If there are problems using &lt;code&gt;vfork&lt;/code&gt;, setting environment variable &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; to any value causes &lt;code&gt;fork&lt;/code&gt; to be used instead.</source>
          <target state="translated">При запуске внешних программ в Solaris системный вызов &lt;code&gt;vfork&lt;/code&gt; используется вместо &lt;code&gt;fork&lt;/code&gt; по соображениям производительности, хотя в прошлом он был менее надежным. Если есть проблемы с использованием &lt;code&gt;vfork&lt;/code&gt; , установка переменной среды &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; на любое значение приведет к тому, что вместо нее будет использоваться &lt;code&gt;fork&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eba2c0286e1f80a8b6d2f783a23106deb0b2394" translate="yes" xml:space="preserve">
          <source>When starting snmpa_local_db it always tries to open an existing database. If &lt;code&gt;false&lt;/code&gt;, and some errors occur, a new database is created instead. If &lt;code&gt;true&lt;/code&gt;, an existing file will be repaired. If &lt;code&gt;force&lt;/code&gt;, the table will be repaired even if it was properly closed.</source>
          <target state="translated">При запуске snmpa_local_db всегда пытается открыть существующую базу данных. Если &lt;code&gt;false&lt;/code&gt; и возникают некоторые ошибки, вместо этого создается новая база данных. Если это &lt;code&gt;true&lt;/code&gt; , существующий файл будет исправлен. Если приложить &lt;code&gt;force&lt;/code&gt; , стол будет отремонтирован, даже если он был правильно закрыт.</target>
        </trans-unit>
        <trans-unit id="c1c86792af0c1fc90a287c8a9c5bae64d2165932" translate="yes" xml:space="preserve">
          <source>When starting the &lt;code&gt;Inets&lt;/code&gt; application, a manager process for the default profile is started. The functions in this API that do not explicitly use a profile accesses the default profile. A profile keeps track of proxy options, cookies, and other options that can be applied to more than one request.</source>
          <target state="translated">При запуске приложения &lt;code&gt;Inets&lt;/code&gt; запускается процесс менеджера для профиля по умолчанию. Функции в этом API, которые явно не используют профиль, получают доступ к профилю по умолчанию. Профиль отслеживает параметры прокси, файлы cookie и другие параметры, которые могут применяться к нескольким запросам.</target>
        </trans-unit>
        <trans-unit id="cd05c53bfd126defe810f3a187a5cf1551a34b96" translate="yes" xml:space="preserve">
          <source>When starting the flex scanner a port to the linked in driver is created. This port has to be owned by a process. This process must not die. If it does the port will also terminate. Therefor:</source>
          <target state="translated">При запуске гибкого сканера создается порт на связанный в драйвере.Этот порт должен принадлежать процессу.Этот процесс не должен умереть.Если он сделает это,порт также завершится.Для этого:</target>
        </trans-unit>
        <trans-unit id="6d9ab8ee43c8cd162c696fc7f8c9882054157b9c" translate="yes" xml:space="preserve">
          <source>When starting this release, three things must be specified:</source>
          <target state="translated">При запуске этого релиза необходимо указать три вещи:</target>
        </trans-unit>
        <trans-unit id="b5e8349f617cc19cb94845c2b5a433d10397c346" translate="yes" xml:space="preserve">
          <source>When starting with Unicode, one often stumbles over some common issues. This section describes some methods of dealing with Unicode data.</source>
          <target state="translated">Начиная с Юникода,человек часто натыкается на некоторые общие проблемы.В этом разделе описаны некоторые методы работы с данными Юникода.</target>
        </trans-unit>
        <trans-unit id="63dac761d2448700171ff70d4839175c0009a766" translate="yes" xml:space="preserve">
          <source>When stopped, the application is still loaded.</source>
          <target state="translated">Когда приложение останавливается,оно все еще загружается.</target>
        </trans-unit>
        <trans-unit id="6bcf5a7b78ff49a4689ff94e30fd3cc2e19a3b3d" translate="yes" xml:space="preserve">
          <source>When streaming to the calling processes using option &lt;code&gt;{self, once}&lt;/code&gt;, the first message has an extra element, that is, &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt;. This is the process id to be used as an argument to &lt;code&gt;httpc:stream_next/1&lt;/code&gt; to trigger the next message to be sent to the calling process.</source>
          <target state="translated">При потоковой передаче вызывающим процессам с использованием опции &lt;code&gt;{self, once}&lt;/code&gt; первое сообщение имеет дополнительный элемент, то есть &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt; . Это идентификатор процесса, который будет использоваться в качестве аргумента для &lt;code&gt;httpc:stream_next/1&lt;/code&gt; , чтобы инициировать отправку следующего сообщения вызывающему процессу.</target>
        </trans-unit>
        <trans-unit id="715fec6e13a0abfe20ee555a6324b0802bfff927" translate="yes" xml:space="preserve">
          <source>When string or binary objects are stored in the registry it is important that some simple guidelines are followed.</source>
          <target state="translated">Когда строковые или двоичные объекты хранятся в реестре,важно следовать некоторым простым рекомендациям.</target>
        </trans-unit>
        <trans-unit id="9879a39d7048a88467f14f974e9672e4f402cb5c" translate="yes" xml:space="preserve">
          <source>When tables are forcefully loaded from the local disc, all operations that were performed on the replicated table while the local node was down, and the remote replica was alive, are lost. This can cause the database to become inconsistent.</source>
          <target state="translated">Когда таблицы принудительно загружаются с локального диска,все операции,которые выполнялись с реплицируемой таблицей во время работы локального узла,а удаленная реплика была жива,теряются.Это может привести к тому,что база данных станет непоследовательной.</target>
        </trans-unit>
        <trans-unit id="bc9c626bcd30b7f8ecf9ddc823a493152c649dd7" translate="yes" xml:space="preserve">
          <source>When tests start, &lt;code&gt;Common Test&lt;/code&gt; Master displays information to console about the involved nodes. &lt;code&gt;Common Test&lt;/code&gt; Master also reports when tests finish, successfully or unsuccessfully. If connection is lost to a node, the test on that node is considered finished. &lt;code&gt;Common Test&lt;/code&gt; Master does not attempt to re-establish contact with the failing node.</source>
          <target state="translated">Когда запускаются тесты, &lt;code&gt;Common Test&lt;/code&gt; Master отображает на консоли информацию об задействованных узлах. &lt;code&gt;Common Test&lt;/code&gt; Master также сообщает, когда тесты завершены, успешно или безуспешно. Если соединение с узлом потеряно, тест на этом узле считается завершенным. &lt;code&gt;Common Test&lt;/code&gt; Master не пытается восстановить связь с отказавшим узлом.</target>
        </trans-unit>
        <trans-unit id="c0e15e615fec1bfe62b38c3373f94e44765c1055" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;'CHANGE'&lt;/code&gt; message has been received you are guaranteed not to retrieve the old time offset when calling &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;. Notice that you can observe the change of the time offset when calling &lt;code&gt;erlang:time_offset()&lt;/code&gt; before you get the &lt;code&gt;'CHANGE'&lt;/code&gt; message.</source>
          <target state="translated">После получения сообщения &lt;code&gt;'CHANGE'&lt;/code&gt; вы гарантированно не получите старое смещение времени при вызове &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что вы можете наблюдать изменение смещения времени при вызове &lt;code&gt;erlang:time_offset()&lt;/code&gt; до того, как получите сообщение &lt;code&gt;'CHANGE'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="389c67d197284147820c964a147bf25f89168f89" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term and the state callback name is &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;handle_event_function&lt;/code&gt; , состоянием может быть любой термин, а имя обратного вызова состояния - &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; . Это позволяет легко переходить в зависимости от состояния или события по вашему желанию. Будьте осторожны с тем, какие события вы обрабатываете в каких состояниях, чтобы случайно не отложить событие навсегда, создав бесконечный цикл занятости.</target>
        </trans-unit>
        <trans-unit id="7c771ceccfcda3b957b4a4bb8455365fc3a48832" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom and is used as the state callback name; see &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;. This co-locates all code for a specific state in one function as the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name. Note the fact that the callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; makes the state name &lt;code&gt;terminate&lt;/code&gt; unusable in this mode.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;state_functions&lt;/code&gt; , состояние должно быть атомом и использоваться как имя обратного вызова состояния; см. &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; . Это совмещает весь код для определенного состояния в одной функции, поскольку механизм &lt;code&gt;gen_statem&lt;/code&gt; разветвляется в зависимости от имени состояния. Обратите внимание на тот факт, что функция обратного вызова &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; делает невозможным использование имени состояния &lt;code&gt;terminate&lt;/code&gt; в этом режиме.</target>
        </trans-unit>
        <trans-unit id="7bd23a20d36b333c46d925b8fd401de86fe841dc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="translated">Если значение &lt;code&gt;Addr&lt;/code&gt; не содержит номера порта, используется значение &lt;code&gt;intAgentUDPPort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22814bccf02caaf2232de9c743157f0b7348ee14" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;erl_tar&lt;/code&gt; core wants to, for example, write a piece of &lt;code&gt;Data&lt;/code&gt;, it would call &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt;.</source>
          <target state="translated">Когда ядро &lt;code&gt;erl_tar&lt;/code&gt; хочет, например, записать часть &lt;code&gt;Data&lt;/code&gt; , оно вызовет &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b84a2f0be01530772a20ac645af7f54b604dbf79" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;fprof&lt;/code&gt; server is stopped the collected raw profile data is lost.</source>
          <target state="translated">Когда сервер &lt;code&gt;fprof&lt;/code&gt; останавливается, собранные необработанные данные профиля теряются.</target>
        </trans-unit>
        <trans-unit id="e37d26017c607226a4f422562f10e0bd5f4835e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, these functions are also called with arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; whenever the state changes. In this case there are some restrictions on the &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; that may be returned: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is not allowed since a &lt;strong&gt;state enter call&lt;/strong&gt; is not an event so there is no event to postpone, and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; is not allowed since using &lt;strong&gt;state enter calls&lt;/strong&gt; should not affect how events are consumed and produced. You may also not change states from this call. Should you return &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; with &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; crashes. Note that it is actually allowed to use &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; although it makes little sense since you immediately will be called again with a new &lt;strong&gt;state enter call&lt;/strong&gt; making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update &lt;code&gt;NewData&lt;/code&gt; and have some loop termination condition, or if you use &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; you have an infinite loop! You are advised to use &lt;code&gt;{keep_state,...}&lt;/code&gt;, &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; or &lt;code&gt;keep_state_and_data&lt;/code&gt; since changing states from a &lt;strong&gt;state enter call&lt;/strong&gt; is not possible anyway.</source>
          <target state="translated">Когда &lt;code&gt;gen_statem&lt;/code&gt; запускается с &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt; , эти функции также вызываются с аргументами &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; при изменении состояния. В этом случае есть некоторые ограничения на &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; которые могут быть возвращены: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; не разрешен, поскольку &lt;strong&gt;вызов входа&lt;/strong&gt; в &lt;strong&gt;состояние&lt;/strong&gt; не является событием, поэтому нет события, которое можно отложить, и &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; не допускается, поскольку использование &lt;strong&gt;вызовов входа в состояние&lt;/strong&gt; не должно влиять на то, как события потребляются и производятся. Вы также не можете изменять состояния этого вызова. Если вы возвращаете &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; с &lt;code&gt;NextState =/= State&lt;/code&gt; &lt;code&gt;gen_statem&lt;/code&gt; вылетает. Обратите внимание, что на самом деле разрешено использовать &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; хотя это не имеет особого смысла, поскольку вы немедленно будете вызваны снова с новым &lt;strong&gt;вызовом ввода состояния,&lt;/strong&gt; что делает это просто странным способом зацикливания, и есть лучшие способы цикл в Erlang. Если вы не обновляете &lt;code&gt;NewData&lt;/code&gt; и у вас есть условие завершения цикла, или если вы используете &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; или &lt;code&gt;repeat_state_and_data&lt;/code&gt; ,у вас бесконечный цикл! Рекомендуется использовать &lt;code&gt;{keep_state,...}&lt;/code&gt; , &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; или &lt;code&gt;keep_state_and_data&lt;/code&gt; , поскольку изменение состояний из &lt;strong&gt;вызова ввода состояния в&lt;/strong&gt; любом случае невозможно.</target>
        </trans-unit>
        <trans-unit id="88a1846d28e7d4cd1692423afe0396a4f961fecf" translate="yes" xml:space="preserve">
          <source>When the Cover analysis is ready, Cover is stopped and all Cover compiled modules are &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt;. The code for &lt;code&gt;channel&lt;/code&gt; is now loaded as usual from a &lt;code&gt;.beam&lt;/code&gt; file in the current path.</source>
          <target state="translated">Когда анализ Cover готов, Cover останавливается, и все скомпилированные модули Cover &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt; . Код для &lt;code&gt;channel&lt;/code&gt; теперь загружается как обычно из файла &lt;code&gt;.beam&lt;/code&gt; по текущему пути.</target>
        </trans-unit>
        <trans-unit id="5e678693029d9376dee27d1a3e9cecfc3eb0694b" translate="yes" xml:space="preserve">
          <source>When the Erlang function &lt;code&gt;t/1&lt;/code&gt; was applied to an Xref server loaded with the current version of OTP, the returned value was close to 84 (percent). This means that the number of indirectly used modules is approximately six times greater when using the module graph. So the answer to the above stated question is that it is definitely worth while using the function graph for this particular analysis. Finally, note that in the presence of unresolved calls, the graphs may be incomplete, which means that there may be indirectly used modules that do not show up.</source>
          <target state="translated">Когда функция Erlang &lt;code&gt;t/1&lt;/code&gt; была применена к серверу внешних ссылок, загруженному с текущей версией OTP, возвращенное значение было близко к 84 (процентам). Это означает, что количество косвенно используемых модулей примерно в шесть раз больше при использовании графа модулей. Итак, ответ на поставленный выше вопрос состоит в том, что определенно стоит использовать график функции для этого конкретного анализа. Наконец, обратите внимание, что при наличии неразрешенных вызовов графики могут быть неполными, что означает, что могут быть косвенно используемые модули, которые не отображаются.</target>
        </trans-unit>
        <trans-unit id="ef14100f6973eec9a2da0c5aac1b652a8be07c43" translate="yes" xml:space="preserve">
          <source>When the Erlang mode is correctly installed, it is automatically activated when a file ending in &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; is opened in Emacs.</source>
          <target state="translated">Если режим Erlang установлен правильно, он автоматически активируется, когда в Emacs открывается файл с &lt;code&gt;.erl&lt;/code&gt; или &lt;code&gt;.hrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="064005753816c68987f62de4089ac63432bbee7f" translate="yes" xml:space="preserve">
          <source>When the Erlang runtime system is automatically started from the &lt;code&gt;S75otp.system&lt;/code&gt; script, the &lt;code&gt;TERM&lt;/code&gt; environment variable must be set. The following is a minimal setting:</source>
          <target state="translated">Когда &lt;code&gt;S75otp.system&lt;/code&gt; система Erlang автоматически запускается из сценария S75otp.system , должна быть установлена ​​переменная среды &lt;code&gt;TERM&lt;/code&gt; . Ниже приведены минимальные настройки:</target>
        </trans-unit>
        <trans-unit id="e452b2fde57d622fa0997d4cb19e28e4a65d9107" translate="yes" xml:space="preserve">
          <source>When the MGC receives its first message, the Service Change Request, the Megaco application will automatically establish the connection by using the MG MID found in the message header as remote mid.</source>
          <target state="translated">Когда MGC получает первое сообщение,Запрос на изменение услуги,приложение Megaco автоматически устанавливает соединение,используя MG MID,найденный в заголовке сообщения в качестве удаленной середины.</target>
        </trans-unit>
        <trans-unit id="0bc1904c9d30ade44fccd694ce928f2cb4a5ad23" translate="yes" xml:space="preserve">
          <source>When the MIB definition work is finished, there are two major issues left.</source>
          <target state="translated">Когда работа над определением MIB будет завершена,останутся две основные проблемы.</target>
        </trans-unit>
        <trans-unit id="8e36ed72ceac42895c73ec727502a81f2596dcdf" translate="yes" xml:space="preserve">
          <source>When the SASL application is started, it adds a Logger handler that formats and writes these reports, as specified in the &lt;code&gt;configuration parameters for SASL&lt;/code&gt;.</source>
          <target state="translated">Когда приложение SASL запускается, оно добавляет обработчик Logger, который форматирует и записывает эти отчеты, как указано в &lt;code&gt;configuration parameters for SASL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b73a5fb29f56921e69c0ac4a2cd6ca545f386dd" translate="yes" xml:space="preserve">
          <source>When the SNMP manager has crashed, the dependent client application has to wait for the SNMP manager to be restarted before it can &lt;strong&gt;reconnect&lt;/strong&gt;.</source>
          <target state="translated">В случае сбоя диспетчера SNMP зависимое клиентское приложение должно дождаться перезапуска диспетчера SNMP, прежде чем оно сможет &lt;strong&gt;повторно подключиться&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a13e96b0328435d455e574296b3ea29ea96cf675" translate="yes" xml:space="preserve">
          <source>When the agent receives a request, it keeps the request ID for one second after the response is sent. If the agent receives another request with the same request ID during this time, from the same IP address and UDP port, that request will be discarded. This mechanism has nothing to do with the function &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt;.</source>
          <target state="translated">Когда агент получает запрос, он сохраняет идентификатор запроса в течение одной секунды после отправки ответа. Если в это время агент получит другой запрос с тем же идентификатором запроса, с того же IP-адреса и порта UDP, этот запрос будет отклонен. Этот механизм не имеет ничего общего с функцией &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c76ffb17b2706d88d3e12e2091f84905c555d5ff" translate="yes" xml:space="preserve">
          <source>When the agent receives the same get-request as above, a call will be made to &lt;code&gt;generic_access(get,&lt;/code&gt;'&lt;code&gt;IPADR')&lt;/code&gt;.</source>
          <target state="translated">Когда агент получает тот же запрос на получение, что и выше, будет выполнен &lt;code&gt;generic_access(get,&lt;/code&gt; ' &lt;code&gt;IPADR')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a93278d10a2e49a183a4771ee8ba18b8f11a4c78" translate="yes" xml:space="preserve">
          <source>When the async operation is done, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; driver entry function is called. If &lt;code&gt;ready_async&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; in the driver entry, the &lt;code&gt;async_free&lt;/code&gt; function is called instead.</source>
          <target state="translated">Когда асинхронная операция завершена, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; функция ввода драйвера ready_async . Если в записи драйвера для &lt;code&gt;ready_async&lt;/code&gt; установлено &lt;code&gt;NULL&lt;/code&gt; вместо этого &lt;code&gt;async_free&lt;/code&gt; функция async_free .</target>
        </trans-unit>
        <trans-unit id="45fda767b9fff4af850e8e6b34bac5b879c78132" translate="yes" xml:space="preserve">
          <source>When the choice of directories in the code path is &lt;code&gt;strict&lt;/code&gt;, the directory that ends up in the code path is exactly the stated one. This means that if, for example, the directory &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; is explicitly added to the code path, the code server does not load files from &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">Когда выбор каталогов в пути кода является &lt;code&gt;strict&lt;/code&gt; , каталог, который заканчивается в пути кода, является в точности указанным. Это означает, что если, например, каталог &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; явно добавлен в путь кода, сервер кода не загружает файлы из &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85eceed499c5d35cfe880d316d8beaf6cbb94efc" translate="yes" xml:space="preserve">
          <source>When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero &lt;code&gt;exit_status&lt;/code&gt; usually means that the command terminated successfully. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Когда команда, выполняемая на другом конце, завершается, может быть отправлено следующее сообщение для возврата статуса завершения команды. Нулевое значение &lt;code&gt;exit_status&lt;/code&gt; обычно означает, что команда завершилась успешно. Это событие отправляется в результате вызова &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3d64a299ff94a9ee47249f94cefcc624dd35a6f" translate="yes" xml:space="preserve">
          <source>When the compiler encounters the module attribute &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; in a module &lt;code&gt;Mod&lt;/code&gt;, it calls &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; and compares the result with the set of functions actually exported from &lt;code&gt;Mod&lt;/code&gt;, and issues a warning if any callback function is missing.</source>
          <target state="translated">Когда компилятор обнаруживает атрибут модуля &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; в модуле &lt;code&gt;Mod&lt;/code&gt; он вызывает &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; и сравнивает результат с набором функций, фактически экспортированных из &lt;code&gt;Mod&lt;/code&gt; , и выдает предупреждение, если какая-либо функция обратного вызова отсутствует.</target>
        </trans-unit>
        <trans-unit id="844a9525ff66b482554dce5aa81432bba7df925d" translate="yes" xml:space="preserve">
          <source>When the data has passed through an Ets table, &lt;code&gt;erts_debug:size/1&lt;/code&gt; and &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; return the same value. Sharing has been lost.</source>
          <target state="translated">Когда данные прошли через таблицу Ets, &lt;code&gt;erts_debug:size/1&lt;/code&gt; и &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; возвращают одно и то же значение. Совместное использование было потеряно.</target>
        </trans-unit>
        <trans-unit id="0180fd29af0af06f5eb68c4a08485d210bd536c3" translate="yes" xml:space="preserve">
          <source>When the data is returned, we deallocate our data.</source>
          <target state="translated">Когда данные возвращаются,мы перераспределяем их.</target>
        </trans-unit>
        <trans-unit id="b841886acb544968ed7c8d220277846a17d2018c" translate="yes" xml:space="preserve">
          <source>When the driver has passed the &lt;code&gt;driver_entry&lt;/code&gt; over to the emulator, the driver is &lt;strong&gt;not&lt;/strong&gt; allowed to modify the &lt;code&gt;driver_entry&lt;/code&gt;.</source>
          <target state="translated">Когда драйвер передал &lt;code&gt;driver_entry&lt;/code&gt; эмулятору, ему &lt;strong&gt;не&lt;/strong&gt; разрешено изменять &lt;code&gt;driver_entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff1b7d404a057ddcb6ce2d59d8b2bdb057597c3d" translate="yes" xml:space="preserve">
          <source>When the driver is implemented, one would preferably write an Erlang interface for the driver to be able to test the functionality of the driver separately. This interface can then be used by the distribution module, which will cover the details of the protocol from the &lt;code&gt;net_kernel&lt;/code&gt;.</source>
          <target state="translated">Когда драйвер реализован, желательно написать интерфейс Erlang для драйвера, чтобы иметь возможность тестировать функциональность драйвера отдельно. Затем этот интерфейс может использоваться модулем распределения, который будет охватывать детали протокола из &lt;code&gt;net_kernel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7f8ef65dc76d982cfe0dc69232e4e5827bba12" translate="yes" xml:space="preserve">
          <source>When the driver is loaded. This callback must have a special name and inform the emulator of what callbacks are to be used by returning a pointer to a &lt;code&gt;ErlDrvEntry&lt;/code&gt; struct, which is to be properly filled in (see below).</source>
          <target state="translated">Когда драйвер загружен. Этот обратный вызов должен иметь специальное имя и информировать эмулятор о том, какие обратные вызовы должны использоваться, возвращая указатель на структуру &lt;code&gt;ErlDrvEntry&lt;/code&gt; , которая должна быть правильно заполнена (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="68f883c088fbc777f98b15d9733f9e21c9a4e592" translate="yes" xml:space="preserve">
          <source>When the emulator is run with instrumentation, the &lt;code&gt;system&lt;/code&gt; value is more accurate, but memory directly allocated for &lt;code&gt;malloc&lt;/code&gt; (and friends) is still not part of the &lt;code&gt;system&lt;/code&gt; value. Direct calls to &lt;code&gt;malloc&lt;/code&gt; are only done from OS-specific runtime libraries and perhaps from user-implemented Erlang drivers that do not use the memory allocation functions in the driver interface.</source>
          <target state="translated">Когда эмулятор запускается с инструментарием, &lt;code&gt;system&lt;/code&gt; значение более точное, но память, непосредственно выделяемая для &lt;code&gt;malloc&lt;/code&gt; (и других), по-прежнему не является частью &lt;code&gt;system&lt;/code&gt; значения. Прямые вызовы &lt;code&gt;malloc&lt;/code&gt; выполняются только из специфичных для ОС библиотек времени выполнения и, возможно, из реализованных пользователем драйверов Erlang, которые не используют функции выделения памяти в интерфейсе драйвера.</target>
        </trans-unit>
        <trans-unit id="77fa82a9f2b1030c7423dea145244305c2d9ec50" translate="yes" xml:space="preserve">
          <source>When the end of the binary is reached and the second clause matches, the match context will simply be discarded (removed in the next garbage collection, as there is no longer any reference to it).</source>
          <target state="translated">Когда конец бинарного файла будет достигнут,а второе условие будет соответствовать,контекст соответствия будет просто удален (удален в следующем сборе мусора,так как ссылок на него больше нет).</target>
        </trans-unit>
        <trans-unit id="6749f7e62fded072722b2a6ba9f855671542a797" translate="yes" xml:space="preserve">
          <source>When the external process connected to the port exits, a message of the form &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; is sent to the connected process, where &lt;code&gt;Status&lt;/code&gt; is the exit status of the external process. If the program aborts on Unix, the same convention is used as the shells do (that is, 128+signal).</source>
          <target state="translated">Когда внешний процесс, подключенный к порту, завершается, сообщение формы &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; отправляется подключенному процессу, где &lt;code&gt;Status&lt;/code&gt; - это статус выхода внешнего процесса. Если программа прерывается в Unix, используется то же соглашение, что и в оболочках (то есть 128 + сигнал).</target>
        </trans-unit>
        <trans-unit id="6d4264b7112b0cfbe36495f0cf35a65dd07c402f" translate="yes" xml:space="preserve">
          <source>When the function &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; cannot be used, &lt;code&gt;Mnesia&lt;/code&gt; provides the programmer with several functions for matching records against a pattern. The most useful ones are the following:</source>
          <target state="translated">Когда функция &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; не может использоваться, &lt;code&gt;Mnesia&lt;/code&gt; предоставляет программисту несколько функций для сопоставления записей с шаблоном. Самые полезные из них:</target>
        </trans-unit>
        <trans-unit id="0a19808ffaca3fd048abe14ac1422112fae7f8be" translate="yes" xml:space="preserve">
          <source>When the function returns &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt;, one can get information about when the driver is &lt;strong&gt;actually&lt;/strong&gt; loaded by using option &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt;.</source>
          <target state="translated">Когда функция возвращает &lt;code&gt;{ok, pending_driver}&lt;/code&gt; или &lt;code&gt;{ok, pending_process}&lt;/code&gt; , можно получить информацию о том, когда драйвер &lt;strong&gt;фактически&lt;/strong&gt; загружен, используя параметр &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1ba8ad7fadddd0bcf392a93e44763cd846c6e5a" translate="yes" xml:space="preserve">
          <source>When the indexed set is a set of subsets of a set X, we call x a &lt;strong id=&quot;family&quot;&gt;family of subsets&lt;/strong&gt; of X.</source>
          <target state="translated">Когда индексированное множество является набором подмножеств множества X, мы называем x &lt;strong id=&quot;family&quot;&gt;семейством подмножеств&lt;/strong&gt; X.</target>
        </trans-unit>
        <trans-unit id="b2e8e9476aa05c51f4eed310e674f5ac07849f6f" translate="yes" xml:space="preserve">
          <source>When the initial message arrives the transport service forwards it to the protocol engine which automatically sets up the connection and invokes UserMod:handle_connect/2 before it invokes UserMod:handle_trans_request/3 with the Service Change Request like this:</source>
          <target state="translated">Когда приходит начальное сообщение,транспортная служба пересылает его в протокольный движок,который автоматически устанавливает соединение и вызывает UserMod:handle_connect/2 перед тем,как вызывает UserMod:handle_trans_request/3 с таким запросом на изменение услуги,как этот:</target>
        </trans-unit>
        <trans-unit id="0b479e3b528c8dff428a540e36a91f070ee36f40" translate="yes" xml:space="preserve">
          <source>When the instrumentation function for the distributed table is called, the request should be forwarded to the table coordinator. The coordinator finds the requested information among the table holders and then returns the answer to the instrumentation function. The SNMP toolkit contains no support for coordination of tables since this must be independent of the implementation.</source>
          <target state="translated">При вызове функции прибора для распределенного стола запрос должен быть передан координатору стола.Координатор находит запрошенную информацию среди владельцев стола и затем возвращает ответ на функцию приборостроения.Инструментарий SNMP не содержит поддержки для координации таблиц,так как он должен быть независим от реализации.</target>
        </trans-unit>
        <trans-unit id="3d4612fb76d339a555d7ce395426dfd7559ca7e3" translate="yes" xml:space="preserve">
          <source>When the logs are full, &lt;code&gt;run_erl&lt;/code&gt; deletes and reuses the oldest log file.</source>
          <target state="translated">Когда журналы заполнены, &lt;code&gt;run_erl&lt;/code&gt; удаляет и повторно использует самый старый файл журнала.</target>
        </trans-unit>
        <trans-unit id="981906d024a846c5ad60dd39439e2525942f2a29" translate="yes" xml:space="preserve">
          <source>When the message queue grows larger than this threshold, the handler switches to a mode in which it drops all new events that senders want to log. Dropping an event in this mode means that the call to the log function never results in a message being sent to the handler, but the function returns without taking any action. The handler keeps logging the events that are already in its message queue, and when the length of the message queue is reduced to a level below the threshold, synchronous or asynchronous mode is resumed. Notice that when the handler activates or deactivates drop mode, information about it is printed in the log.</source>
          <target state="translated">Когда очередь сообщений становится больше этого порога,обработчик переключается в режим,в котором он сбрасывает все новые события,которые отправители хотят записать в журнал.Удаление события в этом режиме означает,что вызов функции протоколирования никогда не приводит к отправке сообщения обработчику,но функция возвращается,не предпринимая никаких действий.Обработчик продолжает протоколировать события,которые уже находятся в его очереди сообщений,и когда длина очереди сообщений уменьшается до уровня ниже порога,синхронный или асинхронный режим возобновляется.Обратите внимание,что когда обработчик активирует или отключает режим сброса,информация о нем выводится в лог.</target>
        </trans-unit>
        <trans-unit id="377865ca162dc01a005c1cf33711bbbcf3cf6d3a" translate="yes" xml:space="preserve">
          <source>When the modifier &lt;code&gt;l&lt;/code&gt; is specified, no detection of printable character lists takes place, for example:</source>
          <target state="translated">Когда указан модификатор &lt;code&gt;l&lt;/code&gt; , не происходит обнаружение списков печатаемых символов, например:</target>
        </trans-unit>
        <trans-unit id="28bc31ee472c6a6f71d309884c8eb89c306960b4" translate="yes" xml:space="preserve">
          <source>When the monitor is triggered a &lt;code&gt;'CHANGE'&lt;/code&gt; message is sent to the monitoring process. A &lt;code&gt;'CHANGE'&lt;/code&gt; message has the following pattern:</source>
          <target state="translated">Когда монитор запускается, процессу мониторинга отправляется сообщение &lt;code&gt;'CHANGE'&lt;/code&gt; . A &lt;code&gt;'CHANGE'&lt;/code&gt; сообщение имеет следующую закономерность:</target>
        </trans-unit>
        <trans-unit id="a6576c399613f943fdf757c4457a0db8dddece67" translate="yes" xml:space="preserve">
          <source>When the number of schedulers is less than or equal to the reader groups limit, each scheduler has its own reader group. When the number of schedulers is larger than the reader groups limit, schedulers share reader groups. Shared reader groups degrade read lock and read unlock performance while many reader groups degrade write lock performance. So, the limit is a tradeoff between performance for read operations and performance for write operations. Each reader group consumes 64 byte in each read/write lock.</source>
          <target state="translated">Когда количество планировщиков меньше или равно ограничению групп читателей,каждый планировщик имеет свою собственную группу читателей.Когда количество планировщиков больше предела групп читателей,планировщики разделяют группы читателей.Общие группы считывателей снижают производительность блокировки чтения и разблокировки чтения,в то время как многие группы считывателей снижают производительность блокировки записи.Таким образом,ограничение является компромиссом между производительностью для операций чтения и производительностью для операций записи.Каждая группа считывателей потребляет 64 байта в каждой блокировке чтения/записи.</target>
        </trans-unit>
        <trans-unit id="36226219dde60c8da7ee7e2f3ead5fe94e62e1f9" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;maps&lt;/code&gt; is given, no &lt;code&gt;.hrl&lt;/code&gt; files will be generated. The rest of this section describes the behavior of the compiler when &lt;code&gt;maps&lt;/code&gt; is not used.</source>
          <target state="translated">Если заданы параметры &lt;code&gt;maps&lt;/code&gt; , файлы &lt;code&gt;.hrl&lt;/code&gt; создаваться не будут. Остальная часть этого раздела описывает поведение компилятора, когда &lt;code&gt;maps&lt;/code&gt; не используются.</target>
        </trans-unit>
        <trans-unit id="54a21311cf0fcf49981af7057a09551734c3f7b1" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;, where it is possible to do customized checks by using the full possibilities of the &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API. When the option &lt;code&gt;server_name_indication&lt;/code&gt; is provided, its value (the DNS name) will be used as &lt;code&gt;ReferenceID&lt;/code&gt; to &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;. When no &lt;code&gt;server_name_indication&lt;/code&gt; option is given, the &lt;code&gt;Host&lt;/code&gt; argument will be used as Server Name Indication extension. The &lt;code&gt;Host&lt;/code&gt; argument will also be used for the &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; check and if the &lt;code&gt;Host&lt;/code&gt; argument is an &lt;code&gt;inet:ip_address()&lt;/code&gt; the &lt;code&gt;ReferenceID&lt;/code&gt; used for the check will be &lt;code&gt;{ip, Host}&lt;/code&gt; otherwise &lt;code&gt;dns_id&lt;/code&gt; will be assumed with a fallback to &lt;code&gt;ip&lt;/code&gt; if that fails.</source>
          <target state="translated">Когда опция &lt;code&gt;verify&lt;/code&gt; установлена в &lt;code&gt;verify_peer&lt;/code&gt; проверки &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; будет осуществляться в дополнении к обычной проверке проверки x509-пути. Если проверка не удалась, ошибка {bad_cert, hostname_check_failed} будет распространена на &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt; проверки пути verify_fun , где можно выполнять индивидуальные проверки, используя все возможности API &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; . Когда опция &lt;code&gt;server_name_indication&lt;/code&gt; предусмотрена, его значение (имя DNS) , будет использоваться в качестве &lt;code&gt;ReferenceID&lt;/code&gt; к &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; . Если опция &lt;code&gt;server_name_indication&lt;/code&gt; не указана, &lt;code&gt;Host&lt;/code&gt; Аргумент хоста будет использоваться как расширение индикации имени сервера. &lt;code&gt;Host&lt;/code&gt; аргумент будет также использоваться для &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; чек и , если &lt;code&gt;Host&lt;/code&gt; аргумент является &lt;code&gt;inet:ip_address()&lt;/code&gt; в &lt;code&gt;ReferenceID&lt;/code&gt; , используемый для проверки будет &lt;code&gt;{ip, Host}&lt;/code&gt; в противном случае &lt;code&gt;dns_id&lt;/code&gt; будет предполагаться с Откат к &lt;code&gt;ip&lt;/code&gt; если это не удается.</target>
        </trans-unit>
        <trans-unit id="a93a77e10e8decc9a9a5af353d5ffa646066813a" translate="yes" xml:space="preserve">
          <source>When the port has been opened, the driver can be called. In the &lt;code&gt;pg_sync&lt;/code&gt; example, we do not have any data from the port, only the return value from the &lt;code&gt;port_control&lt;/code&gt;.</source>
          <target state="translated">Когда порт открыт, можно вызвать драйвер. В примере &lt;code&gt;pg_sync&lt;/code&gt; у нас нет данных из порта, только возвращаемое значение из &lt;code&gt;port_control&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2960ec142372aacf524e3c02cb29b3deda53c6" translate="yes" xml:space="preserve">
          <source>When the port is in &lt;code&gt;data&lt;/code&gt; mode, all data is sent to Erlang in a format that suits the distribution. In fact, the raw data will never reach any Erlang process, but will be translated/interpreted by the emulator itself and then delivered in the correct format to the correct processes. In the current emulator version, received data is to be tagged with a single byte of 100. That is what the macro &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; is defined to. The tagging of data in the distribution can be changed in the future.</source>
          <target state="translated">Когда порт находится в режиме &lt;code&gt;data&lt;/code&gt; , все данные отправляются в Erlang в формате, подходящем для распределения. Фактически, необработанные данные никогда не попадут в какой-либо процесс Erlang, но будут переведены / интерпретированы самим эмулятором, а затем доставлены в правильном формате правильным процессам. В текущей версии эмулятора полученные данные должны быть помечены одним байтом 100. Для этого определен макрос &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; . Пометка данных в раздаче может быть изменена в будущем.</target>
        </trans-unit>
        <trans-unit id="98a5fc45c74e8bc2edca91ff415618981adda324" translate="yes" xml:space="preserve">
          <source>When the protocol is available to Erlang through a driver and an Erlang interface module, a distribution module can be written. The distribution module is a module with well-defined callbacks, much like a &lt;code&gt;gen_server&lt;/code&gt; (there is no compiler support for checking the callbacks, though). This module implements:</source>
          <target state="translated">Когда протокол доступен для Erlang через драйвер и интерфейсный модуль Erlang, можно написать модуль распространения. Модуль распределения - это модуль с четко определенными обратными вызовами, очень похожий на &lt;code&gt;gen_server&lt;/code&gt; (однако компилятор не поддерживает проверку обратных вызовов). В этом модуле реализованы:</target>
        </trans-unit>
        <trans-unit id="be29dce95eec97a67e2087b38e94bd51a5e3dde0" translate="yes" xml:space="preserve">
          <source>When the queue contains data, the driver does not close until the queue is empty.</source>
          <target state="translated">Когда очередь содержит данные,драйвер не закрывается до тех пор,пока очередь не станет пустой.</target>
        </trans-unit>
        <trans-unit id="21ba1599707f578e6da25bafa5c66c03f204937f" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it first generates a temporary boot file, which starts the new versions of the emulator and the core applications, and the old version of all other applications. Then it shuts down the current emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system is rebooted by the &lt;code&gt;heart&lt;/code&gt; program, using the temporary boot file. After the reboot, the rest of the relup instructions are executed. This is done as a part of the temporary boot script.</source>
          <target state="translated">Когда обработчик выпуска встречает инструкцию, он сначала создает временный загрузочный файл, который запускает новые версии эмулятора и основных приложений, а также старую версию всех других приложений. Затем он выключает текущий эмулятор, вызывая &lt;code&gt;init:reboot()&lt;/code&gt; , см. &lt;code&gt;init(3)&lt;/code&gt; страницу init (3) в ядре. Все процессы завершают работу , и система перезагружается в &lt;code&gt;heart&lt;/code&gt; программы, используя временный файл загрузки. После перезагрузки выполняются остальные инструкции по повторному включению. Это делается как часть временного загрузочного скрипта.</target>
        </trans-unit>
        <trans-unit id="cee98f8753d15dee1e12f17349a48be34b074873" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it shuts down the emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system can then be rebooted by the &lt;code&gt;heart&lt;/code&gt; program using the new release version. No more upgrade instruction is executed after the restart.</source>
          <target state="translated">Когда обработчик выпуска встречает инструкцию, он завершает работу эмулятора, вызывая &lt;code&gt;init:reboot()&lt;/code&gt; , см. Страницу руководства &lt;code&gt;init(3)&lt;/code&gt; в ядре. Все процессы завершают работу , и система может быть перегружена в &lt;code&gt;heart&lt;/code&gt; программы с помощью новой версии. После перезапуска инструкции по обновлению больше не выполняются.</target>
        </trans-unit>
        <trans-unit id="a250d269026a9e3f5fca66518f55dd84f05c8c5d" translate="yes" xml:space="preserve">
          <source>When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_cast(Request, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{noreply,State1}&lt;/code&gt;. &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">Когда запрос получен, &lt;code&gt;gen_server&lt;/code&gt; вызывает &lt;code&gt;handle_cast(Request, State)&lt;/code&gt; , который, как ожидается, вернет кортеж &lt;code&gt;{noreply,State1}&lt;/code&gt; . &lt;code&gt;State1&lt;/code&gt; - это новое значение состояния &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d57c2ee62a9879fde2097882cf19d4663d2b600" translate="yes" xml:space="preserve">
          <source>When the restricted shell evaluates an expression and encounters a function call or an operator application, it calls a callback function (with information about the function call in question). This callback function returns &lt;code&gt;true&lt;/code&gt; to let the shell go ahead with the evaluation, or &lt;code&gt;false&lt;/code&gt; to abort it. There are two possible callback functions for the user to implement:</source>
          <target state="translated">Когда ограниченная оболочка оценивает выражение и встречает вызов функции или приложение оператора, она вызывает функцию обратного вызова (с информацией о соответствующем вызове функции). Эта функция обратного вызова возвращает &lt;code&gt;true&lt;/code&gt; чтобы позволить оболочке продолжить оценку, или &lt;code&gt;false&lt;/code&gt; чтобы прервать ее. Пользователь может реализовать две возможные функции обратного вызова:</target>
        </trans-unit>
        <trans-unit id="c54c402919b78665c1c8f198f292bab9fc59cd16" translate="yes" xml:space="preserve">
          <source>When the server is asked to provide a document type that cannot be determined by the MIME Type Settings, the server uses this default type.</source>
          <target state="translated">Когда серверу предлагается предоставить тип документа,который не может быть определен в настройках MIME Type Settings,сервер использует этот тип по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bb82b8ca8c5a5957509c8e72df7e62feb33df317" translate="yes" xml:space="preserve">
          <source>When the shell starts, it starts a single evaluator process. This process, together with any local processes that it spawns, is referred to as a &lt;code&gt;job&lt;/code&gt;. Only the current job, which is said to be &lt;code&gt;connected&lt;/code&gt;, can perform operations with standard I/O. All other jobs, which are said to be &lt;code&gt;detached&lt;/code&gt;, are &lt;code&gt;blocked&lt;/code&gt; if they attempt to use standard I/O.</source>
          <target state="translated">Когда оболочка запускается, она запускает единственный процесс оценки. Этот процесс вместе с любыми локальными процессами, которые он порождает, называется &lt;code&gt;job&lt;/code&gt; . Только текущее задание, которое считается &lt;code&gt;connected&lt;/code&gt; , может выполнять операции со стандартным вводом-выводом. Все остальные задания, которые называются &lt;code&gt;detached&lt;/code&gt; , &lt;code&gt;blocked&lt;/code&gt; если они пытаются использовать стандартный ввод-вывод.</target>
        </trans-unit>
        <trans-unit id="3c74035ba1de254b56bab74be22512784e14aa0a" translate="yes" xml:space="preserve">
          <source>When the size of all received requests exceeds &lt;code&gt;trans_req_maxsize&lt;/code&gt;.</source>
          <target state="translated">Когда размер всех полученных запросов превышает &lt;code&gt;trans_req_maxsize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf7ff81cd7bcbcf93265972ba220ec58a44a2621" translate="yes" xml:space="preserve">
          <source>When the specified event occurs, the function &lt;code&gt;Function&lt;/code&gt; is called as:</source>
          <target state="translated">Когда происходит указанное событие, функция &lt;code&gt;Function&lt;/code&gt; вызывается как:</target>
        </trans-unit>
        <trans-unit id="a9b740db20f360e56cbaf192b02a625103f61f81" translate="yes" xml:space="preserve">
          <source>When the supervisor terminates, then the next higher-level supervisor takes some action. It either restarts the terminated supervisor or terminates itself.</source>
          <target state="translated">Когда супервайзер прекращает работу,то следующий супервайзер высшего уровня предпринимает какое-то действие.Он либо перезапускает завершенного супервайзера,либо прекращает работу.</target>
        </trans-unit>
        <trans-unit id="f021b23bfe2cd55d1b599da584871e714016f843" translate="yes" xml:space="preserve">
          <source>When the timer finally expires, a &quot;megaco segments not received&quot; (459) error message is sent to the other side and the user is notified with a &lt;code&gt;segment timeout&lt;/code&gt;&lt;code&gt;UserReply&lt;/code&gt; in either the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function or the return value of the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Когда таймер, наконец, истекает, на другую сторону отправляется сообщение об ошибке &amp;laquo;мегасегменты не получены&amp;raquo; (459), и пользователь уведомляется с &lt;code&gt;segment timeout&lt;/code&gt; &lt;code&gt;UserReply&lt;/code&gt; либо в &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; обратного вызова handle_trans_reply, либо в возвращаемом значении функции &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bf973279da0cedc632ba88c183b69c62e648346" translate="yes" xml:space="preserve">
          <source>When the timer reaches &lt;code&gt;0&lt;/code&gt; and expires, the driver entry function &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Когда таймер достигает &lt;code&gt;0&lt;/code&gt; и истекает, вызывается &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; функции входа в драйвер .</target>
        </trans-unit>
        <trans-unit id="9a9f3b6a59efe7a46474fcba7bb50d20a40f5897" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the request is resent and the timer is restarted.</source>
          <target state="translated">Когда таймер достигает промежуточного конца,запрос повторно отправляется,и таймер перезапускается.</target>
        </trans-unit>
        <trans-unit id="fd4e877095aa4be1ada9827ad7529e4bc18e2c51" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer is restarted.</source>
          <target state="translated">Когда таймер достигает промежуточного конца,таймер перезапускается.</target>
        </trans-unit>
        <trans-unit id="157d3bfb09cfc45ece6b6d5a8c11a2c6035409d0" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer restarted.</source>
          <target state="translated">Когда таймер достигает промежуточного конца,таймер перезапускается.</target>
        </trans-unit>
        <trans-unit id="e2702c4a29cb7ffd2d62635fddc60ffda837b937" translate="yes" xml:space="preserve">
          <source>When the timer reaches the final expire, either the function &lt;code&gt;megaco:call&lt;/code&gt; will return with &lt;code&gt;{error, timeout}&lt;/code&gt; or the callback function &lt;code&gt;handle_trans_reply&lt;/code&gt; will be called with &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; (if &lt;code&gt;megaco:cast&lt;/code&gt; was used).</source>
          <target state="translated">Когда таймер достигает окончательного истечения срока действия, либо функция &lt;code&gt;megaco:call&lt;/code&gt; вернется с &lt;code&gt;{error, timeout}&lt;/code&gt; либо функция обратного вызова &lt;code&gt;handle_trans_reply&lt;/code&gt; будет вызываться с &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; (если использовалось &lt;code&gt;megaco:cast&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d489b1aa41c1da0731c58c4d8333c65b8fb249f" translate="yes" xml:space="preserve">
          <source>When the tracing is completed, stop the tracer with &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; and format the trace log with &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; (if there is anything to format).</source>
          <target state="translated">Когда трассировка завершена, остановите трассировщик с помощью &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; и отформатируйте журнал трассировки с помощью &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; (если есть что отформатировать).</target>
        </trans-unit>
        <trans-unit id="c36338011eef64525211dd65889fb16a9937ec35" translate="yes" xml:space="preserve">
          <source>When the transaction sender receives a request which is already &quot;in storage&quot; (indicated by the transaction id) it is assumed to be a resend and everything stored is sent. This could happen if the values of the &lt;code&gt;trans_timer&lt;/code&gt; and the &lt;code&gt;request_timer&lt;/code&gt; is not properly chosen.</source>
          <target state="translated">Когда отправитель транзакции получает запрос, который уже находится &amp;laquo;в хранилище&amp;raquo; (обозначенный идентификатором транзакции), предполагается, что это повторная отправка, и все сохраненное отправляется. Это могло произойти, если значения &lt;code&gt;trans_timer&lt;/code&gt; и &lt;code&gt;request_timer&lt;/code&gt; выбраны неправильно.</target>
        </trans-unit>
        <trans-unit id="7862d7ec18f93027c83a7039d6cf2d951465703f" translate="yes" xml:space="preserve">
          <source>When the user has processed a transaction request in its callback function, the Megaco application assembles a transaction reply, encodes it using the selected encoding module and sends the message back by invoking the callback function:</source>
          <target state="translated">Когда пользователь обработал запрос на транзакцию в своей функции обратного вызова,приложение Megaco собирает ответ на транзакцию,кодирует его с помощью выбранного модуля кодировки и отправляет сообщение обратно,вызывая функцию обратного вызова:</target>
        </trans-unit>
        <trans-unit id="17fcbf724175dd6197cb33c7a80fb993e93fef84" translate="yes" xml:space="preserve">
          <source>When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, &lt;code&gt;[{Option, Value}]&lt;/code&gt;, where &lt;code&gt;Option = property()&lt;/code&gt; and &lt;code&gt;Value = term()&lt;/code&gt;, followed by a full stop, or for backwards compatibility, an Apache-like configuration file. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list.</source>
          <target state="translated">Когда веб-сервер запускается во время запуска приложения, свойства должны быть получены из файла конфигурации, который может состоять из обычного списка свойств Erlang, то есть &lt;code&gt;[{Option, Value}]&lt;/code&gt; , где &lt;code&gt;Option = property()&lt;/code&gt; и &lt;code&gt;Value = term()&lt;/code&gt; , за которым следует точка, или для обратной совместимости файл конфигурации, подобный Apache. Если веб-сервер запускается динамически во время выполнения, можно указать не только файл, но и полный список свойств.</target>
        </trans-unit>
        <trans-unit id="b8385f08e883f730c6d6877fd915bdc9c53f2091" translate="yes" xml:space="preserve">
          <source>When the whole driver is unloaded. Every resource allocated by the driver is to be freed.</source>
          <target state="translated">Когда весь водитель выгружается.Каждый ресурс,выделенный драйвером,должен быть освобожден.</target>
        </trans-unit>
        <trans-unit id="1864bbfe1bb4da0ed39ef620a0d58a044889dcf3" translate="yes" xml:space="preserve">
          <source>When the window (terminal) size changes on the client side, it &lt;strong&gt;can&lt;/strong&gt; send a message to the server side to inform it of the new dimensions. No API function generates this event.</source>
          <target state="translated">Когда размер окна (терминала) изменяется на стороне клиента, он &lt;strong&gt;может&lt;/strong&gt; отправить сообщение на сторону сервера, чтобы сообщить ему о новых размерах. Это событие не генерируется ни одной функцией API.</target>
        </trans-unit>
        <trans-unit id="6ae6cb0d1aeff4baecd961c38c7a0d0343bce682" translate="yes" xml:space="preserve">
          <source>When there are no generators or bit string generators, a list comprehension returns either a list with one element (the result of evaluating &lt;code&gt;Expr&lt;/code&gt;) if all filters are true or an empty list otherwise.</source>
          <target state="translated">Когда нет генераторов или генераторов битовых строк, &lt;code&gt;Expr&lt;/code&gt; списка возвращает либо список с одним элементом (результат вычисления Expr ), если все фильтры истинны, либо пустой список в противном случае.</target>
        </trans-unit>
        <trans-unit id="68c8a10137c4675b33b04fc152e8dd169fb08630" translate="yes" xml:space="preserve">
          <source>When there are no more objects in the table, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Когда в таблице больше нет объектов, &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="745f9cd3851e711d348b63ccc23a8f52273edfe7" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, &lt;code&gt;qlc&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">Когда есть только простые ограничения на положение ключа, &lt;code&gt;qlc&lt;/code&gt; виды использования &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; для просмотра ключей. Когда это невозможно, просматривается вся таблица. Опция &lt;code&gt;traverse&lt;/code&gt; определяет, как это делается:</target>
        </trans-unit>
        <trans-unit id="a97d09e0174e7ebcd752be249e317734288c7fe5" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, QLC uses &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">Когда есть только простые ограничения на позицию ключа, QLC использует &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; для поиска ключей. Когда это невозможно, просматривается вся таблица. Опция &lt;code&gt;traverse&lt;/code&gt; определяет, как это делается:</target>
        </trans-unit>
        <trans-unit id="1432344868741e2698e6a9b96d60c2837b98772c" translate="yes" xml:space="preserve">
          <source>When there is no risk of confusion, elements of Sets are identified with the sets they represent. For example, if U is the result of calling &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2).</source>
          <target state="translated">Когда нет риска путаницы, элементы Наборов идентифицируются с наборами, которые они представляют. Например, если U является результатом вызова &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; с S1 и S2 в качестве аргументов, то U называется объединением S1 и S2. Более точная формулировка состоит в том, что Set (U) является объединением Set (S1) и Set (S2).</target>
        </trans-unit>
        <trans-unit id="3340db1e6247a69837f2ad75c699140be306fabf" translate="yes" xml:space="preserve">
          <source>When this argument is removed, a final CPU topology to use is determined at emulator boot time.</source>
          <target state="translated">Когда этот аргумент удаляется,при загрузке эмулятора определяется окончательная топология процессора,которую необходимо использовать.</target>
        </trans-unit>
        <trans-unit id="4b43ec86ba8c916251f60d0bb263cce04f4688f6" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the linked-in driver must manually acknowledge that the port has been successfully started using &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt;. This allows the implementor to make the &lt;code&gt;erlang:open_port&lt;/code&gt; exit with &lt;code&gt;badarg&lt;/code&gt; after some initial asynchronous initialization has been done.</source>
          <target state="translated">Когда установлен этот флаг, связанный драйвер должен вручную подтвердить, что порт был успешно запущен, с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt; . Это позволяет разработчику выполнить выход из &lt;code&gt;badarg&lt;/code&gt; &lt;code&gt;erlang:open_port&lt;/code&gt; с помощью badarg после выполнения некоторой начальной асинхронной инициализации.</target>
        </trans-unit>
        <trans-unit id="a6c9e4e469cc7c78f5cf4d1f7fdc335fb16bb6a9" translate="yes" xml:space="preserve">
          <source>When this function executes within a transaction, several processes running on different nodes can concurrently execute the function &lt;code&gt;raise/2&lt;/code&gt; without interfering with each other.</source>
          <target state="translated">Когда эта функция выполняется внутри транзакции, несколько процессов, запущенных на разных узлах, могут одновременно выполнять функцию &lt;code&gt;raise/2&lt;/code&gt; , не мешая друг другу.</target>
        </trans-unit>
        <trans-unit id="4f5be18c956ae3c742f6fbc74a81c84e27f37de5" translate="yes" xml:space="preserve">
          <source>When this function is called the initiating &lt;code&gt;erlang:open_port&lt;/code&gt; call is returned as if the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; function had just been called. It can only be used when flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; has been set on the linked-in driver.</source>
          <target state="translated">Когда эта функция вызывается, &lt;code&gt;erlang:open_port&lt;/code&gt; вызов erlang: open_port возвращается, как если бы функция &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; была только что вызвана. Его можно использовать, только если для &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; установлен флаг ERL_DRV_FLAG_USE_INIT_ACK .</target>
        </trans-unit>
        <trans-unit id="9f1d28b41ff3a8afa6eef2cd6d49d478529957d0" translate="yes" xml:space="preserve">
          <source>When this function is called with a list of certificate options; it generates a configuration with just one node certificate where &lt;code&gt;cacerts&lt;/code&gt; contains the root cert and the intermediate certs that should be presented to a peer. In this case the same root cert must be used for all peers. This is useful in for example an Erlang distributed cluster where any node, towards another node, acts either as a server or as a client depending on who connects to whom. The generated certificate contains a subject altname, which is not needed in a client certificate, but makes the certificate useful for both roles.</source>
          <target state="translated">Когда эта функция вызывается со списком параметров сертификата; он генерирует конфигурацию только с одним сертификатом узла, где &lt;code&gt;cacerts&lt;/code&gt; содержит корневой сертификат и промежуточные сертификаты, которые должны быть представлены одноранговому узлу. В этом случае для всех узлов должен использоваться один и тот же корневой сертификат. Это полезно, например, в распределенном кластере Erlang, где любой узел по отношению к другому узлу действует либо как сервер, либо как клиент, в зависимости от того, кто к кому подключается. Сгенерированный сертификат содержит альтернативное имя субъекта, которое не требуется в сертификате клиента, но делает сертификат полезным для обеих ролей.</target>
        </trans-unit>
        <trans-unit id="fe0dc82b5ddcdc81bd48ff82e4659150dc801ef9" translate="yes" xml:space="preserve">
          <source>When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the &lt;code&gt;cacerts&lt;/code&gt; returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the &lt;code&gt;cacerts&lt;/code&gt; returned for the client. The root cert(s) can either be pre-generated with &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or if options are specified; it is (they are) generated.</source>
          <target state="translated">Когда эта функция вызывается с картой, содержащей спецификации цепочки клиентов и серверов; он генерирует цепочку сертификатов клиента и сервера, где &lt;code&gt;cacerts&lt;/code&gt; , возвращаемые для сервера, содержат корневой сертификат, которому сервер должен доверять, и промежуточные сертификаты, которые сервер должен предоставлять подключающимся клиентам. Корневой сертификат, которому сервер должен доверять, - это тот, который используется в качестве корневого сертификата цепочки сертификатов клиента. И наоборот, относится к &lt;code&gt;cacerts&lt;/code&gt; , возвращенным клиенту. Корневые сертификаты могут быть либо предварительно сгенерированы с помощью &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; , либо, если указаны параметры; он (они) генерируются.</target>
        </trans-unit>
        <trans-unit id="ef9a4bfdea86e7e0384f0eb8ca04b745e4df80d6" translate="yes" xml:space="preserve">
          <source>When this function is called, &lt;code&gt;*value_size&lt;/code&gt; is to contain the size of the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">Когда эта функция вызывается, &lt;code&gt;*value_size&lt;/code&gt; должен содержать размер буфера &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0658a8caa71ae8ec3af2aaa874893698a63c04" translate="yes" xml:space="preserve">
          <source>When this function is executed inside a transaction-context, it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Когда эта функция выполняется внутри контекста транзакции, она возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcdfcd8239bab330841cc445bcf6b51860555e6e" translate="yes" xml:space="preserve">
          <source>When this is triggered, the previous path through the pattern is searched for the most recent (*MARK) that has the same name. If one is found, the &quot;bumpalong&quot; advance is to the subject position that corresponds to that (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a matching name is found, (*SKIP) is ignored.</source>
          <target state="translated">При срабатывании этой функции,предыдущий путь по шаблону будет искать последний (*MARK)с тем же именем.Если он найден,то &quot;ухабистое&quot; продвижение-в позицию субъекта,которая соответствует этому (*MARK),а не в позицию,где (*SKIP)был обнаружен.Если нет (*MARK)с совпадающим именем,(*SKIP)игнорируется.</target>
        </trans-unit>
        <trans-unit id="d7db68b788b90d41b1ce4140671c7e956cf1dfc1" translate="yes" xml:space="preserve">
          <source>When this mapping is used, insertion and deletion in the original Mnesia table is slower, with a factor O(log n). The read access is not affected.</source>
          <target state="translated">При использовании этого отображения вставка и удаление в исходной таблице Мнезии происходит медленнее,с коэффициентом O(log n).Это не влияет на доступ к чтению.</target>
        </trans-unit>
        <trans-unit id="eb494176e860d606fcf89bbbcaf477ac48b4e483" translate="yes" xml:space="preserve">
          <source>When this option is set to &lt;code&gt;false&lt;/code&gt;, which is default, an RST received from the TCP peer is treated as a normal close (as though an FIN was sent). A caller to &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; gets &lt;code&gt;{error, closed}&lt;/code&gt;. In active mode, the controlling process receives a &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; message, indicating that the peer has closed the connection.</source>
          <target state="translated">Если для этого параметра установлено значение &lt;code&gt;false&lt;/code&gt; (по умолчанию), RST, полученный от однорангового TCP-узла, рассматривается как нормальное закрытие (как если бы был отправлен FIN). Вызывающий &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; получает &lt;code&gt;{error, closed}&lt;/code&gt; . В активном режиме управляющий процесс получает сообщение &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; , указывающее, что одноранговый узел закрыл соединение.</target>
        </trans-unit>
        <trans-unit id="cc7f5c99c2ce601b738e1cbcc7fe8e59a1211a42" translate="yes" xml:space="preserve">
          <source>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option &lt;code&gt;/m&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?m)&lt;/code&gt; option setting. If there are no newlines in a subject string, or no occurrences of &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; in a pattern, setting &lt;code&gt;multiline&lt;/code&gt; has no effect.</source>
          <target state="translated">Когда указана эта опция, конструкции &amp;laquo;начало строки&amp;raquo; и &amp;laquo;конец строки&amp;raquo; соответствуют непосредственно после или непосредственно перед внутренними символами новой строки в строке темы, соответственно, а также в самом начале и в конце. Это эквивалентно параметру &lt;code&gt;/m&lt;/code&gt; в Perl и может быть изменено в шаблоне с помощью параметра &lt;code&gt;(?m)&lt;/code&gt; . Если в строке темы нет символов новой строки или нет вхождений &lt;code&gt;^&lt;/code&gt; или &lt;code&gt;$&lt;/code&gt; в шаблоне, установка &lt;code&gt;multiline&lt;/code&gt; имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="675f8d886654247d43dbcd4fe8a49b4d5b32073b" translate="yes" xml:space="preserve">
          <source>When this option is used, the result of &lt;code&gt;write/2&lt;/code&gt; calls can prematurely be reported as successful, and if a write error occurs, the error is reported as the result of the next file operation, which is not executed.</source>
          <target state="translated">Когда используется эта опция, результат вызовов &lt;code&gt;write/2&lt;/code&gt; может быть преждевременно сообщен как успешный, а если возникает ошибка записи, ошибка сообщается как результат следующей файловой операции, которая не выполняется.</target>
        </trans-unit>
        <trans-unit id="efc30def2e6a5147d2d890feeb73645cc382d513" translate="yes" xml:space="preserve">
          <source>When time-out occurs, &lt;code&gt;Common Test&lt;/code&gt; never aborts the ongoing test case, as this can leave the SUT in an undefined, and possibly bad, state. Instead &lt;code&gt;Common Test&lt;/code&gt;, by default, finishes the current test run before stopping. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified, &lt;code&gt;Common Test&lt;/code&gt; stops when the current test job is finished. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified with &lt;code&gt;skip_rest&lt;/code&gt;, &lt;code&gt;Common Test&lt;/code&gt; only completes the current test case and skips the remaining tests in the test job.</source>
          <target state="translated">Когда происходит тайм-аут, &lt;code&gt;Common Test&lt;/code&gt; никогда не прерывает текущий тестовый пример, так как это может оставить SUT в неопределенном и, возможно, плохом состоянии. Вместо этого &lt;code&gt;Common Test&lt;/code&gt; по умолчанию завершает текущий тестовый запуск перед остановкой. Если &lt;code&gt;force_stop&lt;/code&gt; флаг force_stop , &lt;code&gt;Common Test&lt;/code&gt; останавливается по завершении текущего тестового задания. Если флаг &lt;code&gt;force_stop&lt;/code&gt; указан с &lt;code&gt;skip_rest&lt;/code&gt; , &lt;code&gt;Common Test&lt;/code&gt; завершает только текущий тестовый пример и пропускает остальные тесты в тестовом задании.</target>
        </trans-unit>
        <trans-unit id="7496cb290358c83d75813f93e436cc9aa7801dbd" translate="yes" xml:space="preserve">
          <source>When to use a Sub-agent</source>
          <target state="translated">Когда использовать субагента</target>
        </trans-unit>
        <trans-unit id="25981ff4244a1ee87a90be438c90aa93aa36e1ed" translate="yes" xml:space="preserve">
          <source>When trace flag &lt;code&gt;call&lt;/code&gt; is set on a process, function calls are traced on that process if a trace pattern is set for the called function.</source>
          <target state="translated">Когда для процесса установлен &lt;code&gt;call&lt;/code&gt; флага трассировки , вызовы функций отслеживаются в этом процессе, если для вызываемой функции установлен шаблон трассировки.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
