<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="535867dd76e5b138e05f832dc9af825cc91d8cc3" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;flatmap&lt;/code&gt; behaves as if it had been defined as follows:</source>
          <target state="translated">То есть &lt;code&gt;flatmap&lt;/code&gt; ведет себя так, как если бы она была определена следующим образом:</target>
        </trans-unit>
        <trans-unit id="aad791da5a9f2ebf28101f220528f9b8d026646d" translate="yes" xml:space="preserve">
          <source>That is, a leap year. The next two &lt;code&gt;trunc&lt;/code&gt;-tests evaluate if the year is divisible by 100 or 4 in the same way. The first &lt;code&gt;if&lt;/code&gt; returns &lt;code&gt;leap&lt;/code&gt; or &lt;code&gt;not_leap&lt;/code&gt;, which lands up in the variable &lt;code&gt;Leap&lt;/code&gt;. This variable is used in the guard for &lt;code&gt;feb&lt;/code&gt; in the following &lt;code&gt;case&lt;/code&gt; that tells us how long the month is.</source>
          <target state="translated">То есть високосный год. Следующие два &lt;code&gt;trunc&lt;/code&gt; - теста оценивают, делится ли год на 100 или на 4 одинаковым образом. Первый &lt;code&gt;if&lt;/code&gt; возвращает &lt;code&gt;leap&lt;/code&gt; или &lt;code&gt;not_leap&lt;/code&gt; , который попадает в переменную &lt;code&gt;Leap&lt;/code&gt; . Эта переменная используется в защите для &lt;code&gt;feb&lt;/code&gt; в следующем &lt;code&gt;case&lt;/code&gt; который сообщает нам, сколько длится месяц.</target>
        </trans-unit>
        <trans-unit id="b854b71df5b84451e38dd1e69632ca6e45d5445e" translate="yes" xml:space="preserve">
          <source>That is, a list of four-tuples &lt;code&gt;{Module, Function, Arity | Args, Location}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; are atoms, and the third element is an integer arity or an argument list. The stacktrace can also contain &lt;code&gt;{Fun, Args, Location}&lt;/code&gt; tuples, where &lt;code&gt;Fun&lt;/code&gt; is a local fun and &lt;code&gt;Args&lt;/code&gt; is an argument list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bd067e8a1df03751d1301ebc5a385097e1ecce" translate="yes" xml:space="preserve">
          <source>That is, a trace output, with both the function called and the resulting value.</source>
          <target state="translated">То есть,выход трассы,с одновременным вызовом функции и результирующим значением.</target>
        </trans-unit>
        <trans-unit id="b1bb322ca91a6283f723e39d12e1d20ae13c765c" translate="yes" xml:space="preserve">
          <source>That is, all the bound variables in the match head as a list. If tuples are to be constructed, one has to write a tuple of arity 1 where the single element in the tuple is the tuple one wants to construct (as an ordinary tuple can be mistaken for a &lt;code&gt;Guard&lt;/code&gt;).</source>
          <target state="translated">То есть все связанные переменные в заголовке сопоставления в виде списка. Если необходимо построить кортежи, нужно написать кортеж с арностью 1, где единственный элемент в кортеже - это кортеж, который нужно построить (поскольку обычный кортеж можно ошибочно принять за &lt;code&gt;Guard&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">То есть:</target>
        </trans-unit>
        <trans-unit id="5b7862e3dd48cc38e9add817496ab2e5b649c353" translate="yes" xml:space="preserve">
          <source>That reduces the code size, but is slower because &lt;code&gt;S&lt;/code&gt; means that there will be extra code to test whether the operand refers to an X register or a Y register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7179c2c2c75b5324944355b82ad607b610b23c74" translate="yes" xml:space="preserve">
          <source>That should make it possible to rebuild any library without hassle...</source>
          <target state="translated">Это должно позволить перестроить любую библиотеку без лишних хлопот...</target>
        </trans-unit>
        <trans-unit id="7fa2409e343b10dfba92d13f38dd386e2e863cc5" translate="yes" xml:space="preserve">
          <source>That simple example shows that it is impossible to deliver the SSH application with default values on hardening options as well on other options that suites every need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af23b62330311be1d934875119477b949789e10" translate="yes" xml:space="preserve">
          <source>That the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff03a468de0d9ed380aa26940cb3d4ce174a3748" translate="yes" xml:space="preserve">
          <source>That the correct cookie was used</source>
          <target state="translated">Что правильное печенье было использовано</target>
        </trans-unit>
        <trans-unit id="fbb73f156f2e40ae17a54d203d8b3537e9a4d680" translate="yes" xml:space="preserve">
          <source>That the remote Erlang node on the other side is running the same version of Erlang as the &lt;code&gt;ei&lt;/code&gt; library</source>
          <target state="translated">Что удаленный узел Erlang на другой стороне использует ту же версию Erlang, что и библиотека &lt;code&gt;ei&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43093885e0893ad901ee4b46bda00f5dc1d9a9d7" translate="yes" xml:space="preserve">
          <source>That the remote Erlang node on the other side is running the same version of Erlang as the &lt;code&gt;erl_interface&lt;/code&gt; library</source>
          <target state="translated">Что удаленный узел Erlang на другой стороне использует ту же версию Erlang, что и библиотека &lt;code&gt;erl_interface&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3420600d759a760d25722c58727ef289f531b08" translate="yes" xml:space="preserve">
          <source>That was once true, but from R6B the BEAM compiler can see that a variable is not used.</source>
          <target state="translated">Когда-то это было правдой,но из R6B компилятор BEAM видит,что переменная не используется.</target>
        </trans-unit>
        <trans-unit id="aefbfb778a6045a9feec711cee7f0b6bfe06745c" translate="yes" xml:space="preserve">
          <source>That was true to some extent before R12B. It was even more true before R7B. Today, not so much. A body-recursive function generally uses the same amount of memory as a tail-recursive function. It is generally not possible to predict whether the tail-recursive or the body-recursive version will be faster. Therefore, use the version that makes your code cleaner (hint: it is usually the body-recursive version).</source>
          <target state="translated">В какой-то степени это было правдой до R12B.Это было еще более верно до R7B.Сегодня,не так уж и много.Тело-рекурсивная функция обычно использует тот же объем памяти,что и хвост-рекурсивная функция.Обычно невозможно предсказать,будет ли хвост-рекурсивная или боди-рекурсивная версия работать быстрее.Поэтому используйте версию,которая делает ваш код более чистым (подсказка:обычно это версия с рекурсивным движением).</target>
        </trans-unit>
        <trans-unit id="8ef05f15aa52cadeef34686e592834e1d7565d8c" translate="yes" xml:space="preserve">
          <source>That will copy the emulator executables.</source>
          <target state="translated">Это скопирует исполняемые файлы эмулятора.</target>
        </trans-unit>
        <trans-unit id="c1b9697cd4f3baa91fdf236c77e1a263c60d4132" translate="yes" xml:space="preserve">
          <source>That's basically all you need to get going.</source>
          <target state="translated">Это практически все,что тебе нужно,чтобы уйти.</target>
        </trans-unit>
        <trans-unit id="82c971d45846792b2b886cdbb85418dc5903f332" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator has a complexity proportional to the product of the length of its operands. This means that the operator is very slow if both of its operands are long lists:</source>
          <target state="translated">Оператор &amp;laquo; &lt;code&gt;--&lt;/code&gt; &amp;raquo; имеет сложность, пропорциональную произведению длины его операндов. Это означает, что оператор работает очень медленно, если оба его операнда являются длинными списками:</target>
        </trans-unit>
        <trans-unit id="ff5589371f0dbe70e4139850cd24f1db48567113" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;strong&gt;state callback&lt;/strong&gt;&quot; for a specific &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;gen_statem&lt;/code&gt; is the callback function that is called for all events in this state. It is selected depending on which &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; that the callback module defines with the callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo; &lt;strong&gt;Обратный вызов состояния&lt;/strong&gt; &amp;raquo; для определенного &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;gen_statem&lt;/code&gt; - это функция обратного вызова, которая вызывается для всех событий в этом состоянии. Он выбирается в зависимости от того, какой &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; обратного вызова определяет модуль обратного вызова с помощью функции обратного вызова &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd11f0de519165a84c1b8fcc83fbb4913df33819" translate="yes" xml:space="preserve">
          <source>The &quot;Definitions.&quot;, &quot;Rules.&quot; and &quot;Erlang code.&quot; headings are mandatory and must occur at the beginning of a source line. The &amp;lt;Header&amp;gt;, &amp;lt;Macro Definitions&amp;gt; and &amp;lt;Erlang code&amp;gt; sections may be empty but there must be at least one rule.</source>
          <target state="translated">&amp;laquo;Определения&amp;raquo;, &amp;laquo;Правила&amp;raquo;. и &amp;laquo;Код Эрланга&amp;raquo;. заголовки являются обязательными и должны располагаться в начале строки исходного текста. Разделы &amp;lt;Header&amp;gt;, &amp;lt;Macro Definitions&amp;gt; и &amp;lt;Erlang code&amp;gt; могут быть пустыми, но должно быть хотя бы одно правило.</target>
        </trans-unit>
        <trans-unit id="0a6c1c05be408f7e65aa7a987ce718ffc02949c2" translate="yes" xml:space="preserve">
          <source>The &quot;Okasaki API&quot; is inspired by &quot;Purely Functional Data Structures&quot; by Chris Okasaki. It regards queues as lists. This API is by many regarded as strange and avoidable. For example, many reverse operations have lexically reversed names, some with more readable but perhaps less understandable aliases.</source>
          <target state="translated">Вдохновением для &quot;Okasaki API&quot; послужил &quot;Purely Functional Data Structures&quot; Криса Окасаки.Он рассматривает очереди как списки.Многие считают этот API странным и его можно избежать.Например,многие обратные операции имеют лексически перевернутые имена,некоторые с более читабельными,но,возможно,менее понятными псевдонимами.</target>
        </trans-unit>
        <trans-unit id="4fe7eac7bdedf25d0494e04217d2e3132e60e367" translate="yes" xml:space="preserve">
          <source>The &quot;Original API&quot; and the &quot;Extended API&quot; both use the mental picture of a waiting line of items. Both have reverse operations suffixed &quot;_r&quot;.</source>
          <target state="translated">Оригинальный API&quot; и &quot;Расширенный API&quot; используют мысленную картину очереди элементов.В обоих случаях обратные операции имеют суффикс &quot;_r&quot;.</target>
        </trans-unit>
        <trans-unit id="3887fa2b48cbded502d3da264fbe59b3f1883ab5" translate="yes" xml:space="preserve">
          <source>The &quot;Original API&quot; item removal functions return compound terms with both the removed item and the resulting queue. The &quot;Extended API&quot; contains alternative functions that build less garbage and functions for just inspecting the queue ends. Also the &quot;Okasaki API&quot; functions build less garbage.</source>
          <target state="translated">Функции удаления элемента &quot;Original API&quot; возвращают составные термины как с удаленным элементом,так и с результирующей очередью.Расширенный API&quot; содержит альтернативные функции,которые строят меньше мусора и функции для простого просмотра концов очереди.Также функции &quot;Okasaki API&quot; строят меньше мусора.</target>
        </trans-unit>
        <trans-unit id="7a1a738b6242350a278b4cc4eaff19808c280faf" translate="yes" xml:space="preserve">
          <source>The &quot;Oxford Advanced Learners Dictionary of Current English&quot; says the following about the word &quot;indent&quot;:</source>
          <target state="translated">В &quot;Оксфордском словаре для продвинутых учащихся текущего английского языка&quot; о слове &quot;отступ&quot; говорится следующее:</target>
        </trans-unit>
        <trans-unit id="b71ca1b4095bae581a22c9bd4dc765543e310daa" translate="yes" xml:space="preserve">
          <source>The &quot;keep alive&quot; activity (that is, that &lt;code&gt;Common Test&lt;/code&gt; sends NOP to the server every 10 seconds if the connection is idle) can be enabled or disabled for one particular connection as described here. It can be disabled for all connections using &lt;code&gt;telnet_settings&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Действие &amp;laquo;сохранить активность&amp;raquo; (то есть, что &lt;code&gt;Common Test&lt;/code&gt; отправляет NOP на сервер каждые 10 секунд, если соединение находится в режиме ожидания) можно включить или отключить для одного конкретного соединения, как описано здесь. Его можно отключить для всех подключений с помощью &lt;code&gt;telnet_settings&lt;/code&gt; (см. &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="82d4b81efe7dcd8e24eb60d67714cfdca853f28b" translate="yes" xml:space="preserve">
          <source>The &quot;message box&quot; is implemented using a lock free single linked list through the memory blocks to deallocate. The order of the elements in this list is not important. Insertion of new free blocks will be made somewhere near the end of this list. Requiring that the new blocks need to be inserted at the end would cause unnecessary contention when large amount of memory blocks are inserted simultaneous by multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe589f8c1fff89269afb0db8e6111d61dec7b78" translate="yes" xml:space="preserve">
          <source>The &quot;private&quot; message &lt;code&gt;{From, rewind}&lt;/code&gt; results in the current position in the pseudo-file to be reset to &lt;code&gt;0&lt;/code&gt; (the beginning of the &quot;file&quot;). This is a typical example of I/O device-specific messages not being part of the I/O protocol. It is usually a bad idea to embed such private messages in &lt;code&gt;io_request&lt;/code&gt; tuples, as that can confuse the reader.</source>
          <target state="translated">&amp;laquo;Приватное&amp;raquo; сообщение &lt;code&gt;{From, rewind}&lt;/code&gt; приводит к тому, что текущая позиция в псевдофайле сбрасывается на &lt;code&gt;0&lt;/code&gt; (начало &amp;laquo;файла&amp;raquo;). Это типичный пример сообщений, специфичных для устройства ввода-вывода, не являющихся частью протокола ввода-вывода. Обычно встраивать такие личные сообщения в кортежи &lt;code&gt;io_request&lt;/code&gt; - плохая идея , так как это может запутать читателя.</target>
        </trans-unit>
        <trans-unit id="df7c24b268c29aef7fecbe44c0aab51a5f20a7f3" translate="yes" xml:space="preserve">
          <source>The &quot;server_name&quot; and &quot;certificate_authorities&quot; extensions are used to guide certificate selection. As servers MAY require the presence of the &quot;server_name&quot; extension, clients SHOULD send this extension, when applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a690e384b2d5a804cad58bd96420656c204892" translate="yes" xml:space="preserve">
          <source>The &quot;test run index&quot; page includes a link to the &lt;code&gt;Common Test&lt;/code&gt; Framework Log file in which information about imported configuration data and general test progress is written. This log file is useful to get snapshot information about the test run during execution. It can also be helpful when analyzing test results or debugging test suites.</source>
          <target state="translated">На странице &amp;laquo;Индекс тестового запуска&amp;raquo; есть ссылка на файл журнала &lt;code&gt;Common Test&lt;/code&gt; Framework, в котором записывается информация об импортированных данных конфигурации и общем ходе тестирования. Этот файл журнала полезен для получения информации о моментальном снимке теста во время выполнения. Это также может быть полезно при анализе результатов тестирования или отладке наборов тестов.</target>
        </trans-unit>
        <trans-unit id="8c3be9bfee853a4424aae3e9b08197fdb2f6acc7" translate="yes" xml:space="preserve">
          <source>The &quot;test run index&quot; page indicates if a test has missing suites (that is, suites that &lt;code&gt;Common Test&lt;/code&gt; failed to compile). Names of the missing suites can be found in the &lt;code&gt;Common Test&lt;/code&gt; Framework Log file.</source>
          <target state="translated">На странице &amp;laquo;Индекс тестового запуска&amp;raquo; указывается, отсутствуют ли в тесте комплекты (то есть комплекты, которые &lt;code&gt;Common Test&lt;/code&gt; не удалось скомпилировать). Названия отсутствующих наборов можно найти в файле журнала &lt;code&gt;Common Test&lt;/code&gt; Framework.</target>
        </trans-unit>
        <trans-unit id="19d572f8fd1e712c92a2de5cde66fc7d07a76688" translate="yes" xml:space="preserve">
          <source>The &quot;thread progress&quot; functionality in the Erlang VM is used to address these problems. The name &quot;thread progress&quot; was chosen since we want to use it to determine when all threads in a set of threads have made such progress so that two specific events have taken place for all them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60728f91de50a0cab75ed1bd09ee0c55638db56" translate="yes" xml:space="preserve">
          <source>The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty ones&quot;, which sometimes can be useful. You can also specify how many parts you want, by specifying &lt;code&gt;{parts,&lt;/code&gt;N&lt;code&gt;}&lt;/code&gt;:</source>
          <target state="translated">Вариант &amp;laquo;обрезки&amp;raquo; говорит; &amp;laquo;дайте мне как можно больше деталей, кроме пустых&amp;raquo;, что иногда может быть полезно. Вы также можете указать, сколько частей вы хотите, указав &lt;code&gt;{parts,&lt;/code&gt; N &lt;code&gt;}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f31ddf356bb1296b6c57934df526e33fec2480e7" translate="yes" xml:space="preserve">
          <source>The $REFRESH_GEN_DEST() macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8edde0db65ff7f9e25c8ce9f9ce0286b2ab0b7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;Regexp&amp;gt; must occur at the start of a line and not include any blanks; use &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; to include TAB and SPACE characters in the regular expression. If &amp;lt;Regexp&amp;gt; matches then the corresponding &amp;lt;Erlang code&amp;gt; is evaluated to generate a token. With the Erlang code the following predefined variables are available:</source>
          <target state="translated">&amp;lt;Regexp&amp;gt; должен находиться в начале строки и не содержать пробелов; используйте &lt;code&gt;\t&lt;/code&gt; и &lt;code&gt;\s&lt;/code&gt; чтобы включить символы TAB и SPACE в регулярное выражение. Если &amp;lt;Regexp&amp;gt; совпадает, то соответствующий &amp;lt;код Erlang&amp;gt; оценивается для генерации токена. В коде Erlang доступны следующие предопределенные переменные:</target>
        </trans-unit>
        <trans-unit id="7faf73f339f8137ba8202610ef5e79dc01a5875e" translate="yes" xml:space="preserve">
          <source>The '?' type modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ad87b21116c045fdb7bb1d623835d9ff636685" translate="yes" xml:space="preserve">
          <source>The 'process oid' &quot;tag&quot; that can be provided with the variable name / oids is indended to be used for oid post processing. The value '&lt;code&gt;keep&lt;/code&gt;', which is the default, leaves the oid as is. The value '&lt;code&gt;truncate&lt;/code&gt;', will cause the oid to be &quot;truncated&quot;. That is, any trailing &quot;.0&quot; will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd6006060b360d3964e6301c70d62dfa6542605" translate="yes" xml:space="preserve">
          <source>The (*MARK) name is tagged with &quot;MK:&quot; in this output, and in this example it indicates which of the two alternatives matched. This is a more efficient way of obtaining this information than putting each alternative in its own capturing parentheses.</source>
          <target state="translated">Имя (*MARK)в этом выводе помечено &quot;MK:&quot;,и в этом примере оно указывает,какая из двух альтернатив совпала.Это более эффективный способ получения этой информации,чем помещение каждой альтернативы в собственные захватывающие скобки.</target>
        </trans-unit>
        <trans-unit id="7626cd8d4a95d16adbb501a045b70ff730bc3449" translate="yes" xml:space="preserve">
          <source>The (*UTF8) and (*UCP) leading sequences can be used to set UTF and Unicode property modes. They are equivalent to setting options &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;ucp&lt;/code&gt;, respectively. The (*UTF) sequence is a generic version that can be used with any of the libraries. However, the application can set option &lt;code&gt;never_utf&lt;/code&gt;, which locks out the use of the (*UTF) sequences.</source>
          <target state="translated">Ведущие последовательности (* UTF8) и (* UCP) можно использовать для установки режимов свойств UTF и Unicode. Они эквивалентны настройке параметров &lt;code&gt;unicode&lt;/code&gt; и &lt;code&gt;ucp&lt;/code&gt; соответственно. Последовательность (* UTF) - это общая версия, которую можно использовать с любой из библиотек. Однако приложение может установить параметр &lt;code&gt;never_utf&lt;/code&gt; , который блокирует использование последовательностей (* UTF).</target>
        </trans-unit>
        <trans-unit id="0af8bbc7ab3d2447bd6a5d8520e9f3d0f277f0b4" translate="yes" xml:space="preserve">
          <source>The (built-in) &lt;code&gt;escript&lt;/code&gt; program first determines which Erlang runtime system to use and then starts it to execute your script. Usually the runtime system is located in the same Erlang installation as the &lt;code&gt;escript&lt;/code&gt; program itself. But for standalone systems with one or more escripts it may be the case that the &lt;code&gt;escript&lt;/code&gt; program in your path actually starts the runtime system bundled with the escript. This is intentional, and typically happens when the standalone system &lt;code&gt;bin&lt;/code&gt; directory is not in the execution path (as it may cause its &lt;code&gt;erl&lt;/code&gt; program to override the desired one) and the &lt;code&gt;escript&lt;/code&gt;(s) are referred to via symbolic links from a &lt;code&gt;bin&lt;/code&gt; directory in the path.</source>
          <target state="translated">(Встроенная) программа &lt;code&gt;escript&lt;/code&gt; сначала определяет, какую систему времени выполнения Erlang использовать, а затем запускает ее для выполнения вашего сценария. Обычно исполняющая система находится в той же установке Erlang, что и &lt;code&gt;escript&lt;/code&gt; программа escript . Но для автономных систем с одним или несколькими секретными кодами может случиться так, что программа &lt;code&gt;escript&lt;/code&gt; на вашем пути фактически запускает систему времени выполнения, связанную с escript. Это сделано намеренно и обычно происходит, когда автономный системный каталог &lt;code&gt;bin&lt;/code&gt; не находится в пути выполнения (так как это может привести к тому, что его программа &lt;code&gt;erl&lt;/code&gt; переопределит желаемый), и к &lt;code&gt;escript&lt;/code&gt; (-ам) обращаются через символические ссылки из каталога &lt;code&gt;bin&lt;/code&gt; в тропинка.</target>
        </trans-unit>
        <trans-unit id="dfd9ff6975abbc395a9f98a9f0cbda02a2c72d28" translate="yes" xml:space="preserve">
          <source>The (compressed) tape archive file is to be extracted in the installation directory defined above.</source>
          <target state="translated">Архивный файл (сжатый)ленты должен быть распакован в директорию установки,указанную выше.</target>
        </trans-unit>
        <trans-unit id="ff202b736bdf02f02856c9e0b5a48d4c81a349b4" translate="yes" xml:space="preserve">
          <source>The (encoding) config option for the full version, &lt;code&gt;{version3, 3}&lt;/code&gt;, will still be supported, even though its no longer necessary to specify it this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdcfaa6a575093f30922fde0b326af66b1dc8369" translate="yes" xml:space="preserve">
          <source>The (hidden) node implements atom cache (obsolete).</source>
          <target state="translated">В (скрытом)узле реализована атомная кэш-память (устаревшая).</target>
        </trans-unit>
        <trans-unit id="148d899ab108f6515349d4b01878d74abd02d0c9" translate="yes" xml:space="preserve">
          <source>The (host operating system) environment variable &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; can be used to give default compiler options. Its value must be a valid Erlang term. If the value is a list, it is used as is. If it is not a list, it is put into a list.</source>
          <target state="translated">Переменная среды &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; (операционной системы хоста) может использоваться для задания параметров компилятора по умолчанию. Его значение должно быть допустимым термином Эрланга. Если значение является списком, оно используется как есть. Если это не список, он помещается в список.</target>
        </trans-unit>
        <trans-unit id="f06fadd0b84d13f99d85c50cfc349e4a25addef3" translate="yes" xml:space="preserve">
          <source>The (possibly flattened) &lt;code&gt;Path&lt;/code&gt; parameter must be consistent throughout the system. A driver is to, by all &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;, be loaded using the same &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt;. The exception is when &lt;strong&gt;reloading&lt;/strong&gt; is requested, in which case &lt;code&gt;Path&lt;/code&gt; can be specified differently. Notice that all &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; trying to load the driver later need to use the &lt;strong&gt;new&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; if &lt;code&gt;Path&lt;/code&gt; is changed using a &lt;code&gt;reload&lt;/code&gt; option. This is yet another reason to have &lt;strong&gt;only one loader&lt;/strong&gt; of a driver one wants to upgrade in a running system.</source>
          <target state="translated">Параметр &lt;code&gt;Path&lt;/code&gt; (возможно, сглаженный) должен быть согласован во всей системе. Драйвер должен быть загружен всеми &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; с использованием одного и того же &lt;strong&gt;буквального &lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; . Исключение составляют случаи, когда запрашивается &lt;strong&gt;перезагрузка&lt;/strong&gt; , и в этом случае &lt;code&gt;Path&lt;/code&gt; можно указать по-другому. Обратите внимание, что все &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; пытающиеся загрузить драйвер позже, должны использовать &lt;strong&gt;новый &lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; если &lt;code&gt;Path&lt;/code&gt; изменен с помощью параметра &lt;code&gt;reload&lt;/code&gt; . Это еще одна причина иметь &lt;strong&gt;только один загрузчик&lt;/strong&gt; драйвера, который нужно обновить в работающей системе.</target>
        </trans-unit>
        <trans-unit id="83b2a48f7b5f8f51af459ed68059f2418cf4dc0c" translate="yes" xml:space="preserve">
          <source>The -no_next directive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e9e710cb5f6c3ca182c389c02b5335142f703b" translate="yes" xml:space="preserve">
          <source>The -no_prefetch directive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c443fb128bea98f3149bd2df5d12047cad839bc" translate="yes" xml:space="preserve">
          <source>The 16 bytes MD5 of the significant parts of the Beam file.</source>
          <target state="translated">16 байт MD5 значительной части лучевого файла.</target>
        </trans-unit>
        <trans-unit id="7d39efdef71579d11fb25cc52651c18fba9a7537" translate="yes" xml:space="preserve">
          <source>The 3-tuple form additionally specifies an interval, in milliseconds, after which a started transport process should be terminated if it has not yet established a connection. For example, the following options on a connecting transport request a connection with one peer over SCTP or another (typically the same) over TCP.</source>
          <target state="translated">В 3-ступенчатой форме дополнительно указывается интервал в миллисекундах,по истечении которого начатый транспортный процесс должен быть прекращен,если соединение еще не установлено.Например,следующие опции при запросе на соединение транспорта устанавливают соединение с одним равноправным узлом по протоколу SCTP или другому (как правило,такому же)по TCP.</target>
        </trans-unit>
        <trans-unit id="acebf1a57043cf38ebb17933963dec066b1efb07" translate="yes" xml:space="preserve">
          <source>The 4-byte header is limited to 2Gb.</source>
          <target state="translated">Четырехбайтовый заголовок ограничен 2 Гб.</target>
        </trans-unit>
        <trans-unit id="c54cda7cb6bfe2ffa1c818c4fe4b01c2c1e1b503" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;cert_opt&quot;&gt;cert_opt()&lt;/code&gt; type consists of the following options:</source>
          <target state="translated">Тип &lt;code id=&quot;cert_opt&quot;&gt;cert_opt()&lt;/code&gt; состоит из следующих опций:</target>
        </trans-unit>
        <trans-unit id="050b18a3c2818149908322c73d61c6c85b47e765" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;ei_socket_callbacks_fields&quot;&gt;&lt;a href=&quot;#ei_socket_callbacks&quot;&gt;ei_socket_callbacks&lt;/a&gt;&lt;/code&gt; structure may be enlarged in the future. All fields not set, &lt;strong&gt;needs&lt;/strong&gt; to be zeroed out. Currently the following fields exist:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865c911e774746bccfef22abcc84f0e0893f4e7b" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;emulator&quot;&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; driver API functions need a port handle that identifies the driver instance (and the port in the emulator). This is only passed to the &lt;code&gt;start&lt;/code&gt; function, but not to the other functions. The &lt;code&gt;start&lt;/code&gt; function returns a driver-defined handle that is passed to the other functions. A common practice is to have the &lt;code&gt;start&lt;/code&gt; function allocate some application-defined structure and stash the &lt;code&gt;port&lt;/code&gt; handle in it, to use it later with the driver API functions.</source>
          <target state="translated">Для &lt;code id=&quot;emulator&quot;&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; API драйвера erl_driver необходим дескриптор порта, который идентифицирует экземпляр драйвера (и порт в эмуляторе). Это передается только функции &lt;code&gt;start&lt;/code&gt; , но не другим функциям. Функция &lt;code&gt;start&lt;/code&gt; возвращает определяемый драйвером дескриптор, который передается другим функциям. Обычная практика - заставить функцию &lt;code&gt;start&lt;/code&gt; выделить некоторую определяемую приложением структуру и спрятать в ней дескриптор &lt;code&gt;port&lt;/code&gt; , чтобы использовать его позже с функциями API драйвера.</target>
        </trans-unit>
        <trans-unit id="fac23f5db2a77ff3396a2eb9379305c9a2e69b07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; Module:callback_mode() &lt;/code&gt; function may also return a list containing the &lt;strong&gt;callback mode&lt;/strong&gt; and the atom &lt;code&gt;state_enter&lt;/code&gt; in which case &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are activated for the &lt;strong&gt;callback mode&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d6b2ddf1f8b4bed5ebc7bdf4fb25c7cfe43dee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; erts_alloc_config(3)&lt;/code&gt; tool can be used to aid creation of an &lt;code&gt;erts_alloc&lt;/code&gt; configuration that is suitable for a limited number of runtime scenarios.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418f98e4e66687632d887b26d161001270432df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; file contains all available cross configuration variables and can be used as a template when creating a cross compilation configuration. All &lt;code&gt;&lt;a href=&quot;#Currently-Used-Configuration-Variables&quot;&gt;cross configuration variables&lt;/a&gt;&lt;/code&gt; are also listed at the end of this document. For examples of working cross configurations see the &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf&lt;/code&gt; file and the &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf&lt;/code&gt; file. If the default behavior of a variable is satisfactory, the variable does not need to be set. However, the &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">&lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; файл содержит все доступные переменные кросс конфигурации и может быть использован в качестве шаблона при создании кросс конфигурации компиляции. Все &lt;code&gt;&lt;a href=&quot;#Currently-Used-Configuration-Variables&quot;&gt;cross configuration variables&lt;/a&gt;&lt;/code&gt; также перечислены в конце этого документа. Примеры рабочих кросс-конфигураций см. В &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf&lt;/code&gt; и в файле &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf&lt;/code&gt; . Если поведение переменной по умолчанию является удовлетворительным, устанавливать переменную не нужно. Однако сценарий &lt;code&gt;configure&lt;/code&gt; выдаст предупреждение при использовании значения по умолчанию. Когда переменная установлена, предупреждение не выводится.</target>
        </trans-unit>
        <trans-unit id="eb9365413abd348bc2e1ccbcdc327aa503fb22ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%if&lt;/code&gt; directive includes a range of lines if a condition is true. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8c049d3991b699c878b126ce3c6bdb33cc7a3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; directory is where new release packets are installed, and where the release handler keeps information about releases. For more information, see the &lt;code&gt;release_handler(3)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">&lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; каталог , где новые пакеты выпуска установлены, и где обработчик релиз хранит информацию о выпусках. Для получения дополнительной информации см. &lt;code&gt;release_handler(3)&lt;/code&gt; в SASL.</target>
        </trans-unit>
        <trans-unit id="927497bac1e3aacb4e090f1231bc5491dae42268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;++&lt;/code&gt; operator has, somewhat undeservedly, got a bad reputation. It probably has something to do with code like the following, which is the most inefficient way there is to reverse a list:</source>
          <target state="translated">Оператор &lt;code&gt;++&lt;/code&gt; получил незаслуженно дурную репутацию. Вероятно, это как-то связано с таким кодом, как следующий, который является наиболее неэффективным способом перевернуть список:</target>
        </trans-unit>
        <trans-unit id="42130a038f0aadad4f70fd60034fb79e9e360ef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;#&lt;/code&gt; operators are defined for line number expressions, provided the operands are compatible. The LineOp operators are also defined for modules, applications, and releases; the operand is implicitly converted to functions. Similarly, the cast operator is defined for the interpretation of the LineOp operators.</source>
          <target state="translated">Операторы &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;#&lt;/code&gt; определены для выражений номеров строк при условии, что операнды совместимы. Операторы LineOp также определены для модулей, приложений и выпусков; операнд неявно преобразуется в функции. Точно так же оператор приведения определяется для интерпретации операторов LineOp.</target>
        </trans-unit>
        <trans-unit id="7d867665c4e36dd9997bf46a9f78b7c231955da1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+fna&lt;/code&gt; switch can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt;. This has effect if the locale settings cause the behavior of &lt;code&gt;+fnu&lt;/code&gt; to be selected; see the description of &lt;code&gt;+fnu&lt;/code&gt; above. If the locale settings cause the behavior of &lt;code&gt;+fnl&lt;/code&gt; to be selected, then &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; have no effect.</source>
          <target state="translated">За переключателем &lt;code&gt;+fna&lt;/code&gt; может следовать &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; или &lt;code&gt;e&lt;/code&gt; . Это имеет эффект, если настройки локали вызывают &lt;code&gt;+fnu&lt;/code&gt; поведения + fnu ; см. описание &lt;code&gt;+fnu&lt;/code&gt; выше. Если настройки локали вызывают выбор поведения &lt;code&gt;+fnl&lt;/code&gt; , то &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; или &lt;code&gt;e&lt;/code&gt; не действуют.</target>
        </trans-unit>
        <trans-unit id="9e6133996f9262b8d90826837351bd3d8efee96b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+fnu&lt;/code&gt; switch can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported:</source>
          <target state="translated">За переключателем &lt;code&gt;+fnu&lt;/code&gt; может следовать &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; или &lt;code&gt;e&lt;/code&gt; , чтобы указать, как следует сообщать о неправильно закодированных именах файлов:</target>
        </trans-unit>
        <trans-unit id="831e6d2347d95f44b19c16835a12096caa3382d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--enable-bootstrap-only&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt; isn't strictly necessary, but will speed things up. It will only run &lt;code&gt;configure&lt;/code&gt; in applications necessary for the bootstrap, and will disable a lot of things not needed by the bootstrap system. If you run &lt;code&gt;configure&lt;/code&gt; without &lt;code&gt;--enable-boostrap-only&lt;/code&gt; you also have to run make as &lt;code&gt;make bootstrap&lt;/code&gt;; otherwise, the whole system will be built.</source>
          <target state="translated">&lt;code&gt;--enable-bootstrap-only&lt;/code&gt; аргумент &lt;code&gt;configure&lt;/code&gt; не является строго необходимым, но ускорить процесс . Он будет запускать &lt;code&gt;configure&lt;/code&gt; только в приложениях, необходимых для начальной загрузки, и отключит многие вещи, которые не нужны системе начальной загрузки. Если вы запускаете &lt;code&gt;configure&lt;/code&gt; без &lt;code&gt;--enable-boostrap-only&lt;/code&gt; , вам также необходимо запустить make как &lt;code&gt;make bootstrap&lt;/code&gt; ; в противном случае будет построена вся система.</target>
        </trans-unit>
        <trans-unit id="f9606e2fd218b40d91d81e57470942cf1aec71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-error()&lt;/code&gt; and &lt;code&gt;-warning()&lt;/code&gt; directives were added in OTP 19.</source>
          <target state="translated">&lt;code&gt;-error()&lt;/code&gt; и &lt;code&gt;-warning()&lt;/code&gt; директивы были добавлены в OTP 19.</target>
        </trans-unit>
        <trans-unit id="c265860ecc1894d7ef2df5fb5a19bf0d362bff43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-on_load()&lt;/code&gt; directive names a function that is to be run automatically when a module is loaded.</source>
          <target state="translated">В &lt;code&gt;-on_load()&lt;/code&gt; имена директивных функций, которая будет запускаться автоматически при загрузке модуля.</target>
        </trans-unit>
        <trans-unit id="aa13e09e4d341c2108d3357512871ca10a0cc6bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.app&lt;/code&gt; file for release may reside in the &lt;code&gt;ebin&lt;/code&gt;-directory in a development environment but it is encouraged that this is an artifact of the build step. By convention a &lt;code&gt;.app.src&lt;/code&gt; file is used, which resides in the &lt;code&gt;src&lt;/code&gt; directory. This file is nearly identical as the &lt;code&gt;.app&lt;/code&gt; file but certain fields may be replaced during the build step, such as the application version.</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; файл для выпуска может находиться в &lt;code&gt;ebin&lt;/code&gt; -Каталога в среде разработки , но рекомендуется , что это артефакт на стадии сборки. По соглашению используется файл &lt;code&gt;.app.src&lt;/code&gt; , который находится в каталоге &lt;code&gt;src&lt;/code&gt; . Этот файл почти идентичен файлу &lt;code&gt;.app&lt;/code&gt; , но некоторые поля могут быть заменены на этапе сборки, например, версия приложения.</target>
        </trans-unit>
        <trans-unit id="817bfba9b560dd19b99757cc44790bf08dd077b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.app&lt;/code&gt; files</source>
          <target state="translated">В &lt;code&gt;.app&lt;/code&gt; файлы</target>
        </trans-unit>
        <trans-unit id="e7a9a94b1b27ccedaac07d12dcc8d76dbbdc8458" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; файл может выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="0f9944b699387d7c11ea7cd1be3bab23ba4afdef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade or downgrade the application. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; файл содержит один единственный член Erlang, который определяет инструкцию , используемую для обновления или понизить приложение. Файл имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="0a4e2f387f9c84aa65d3380a5a44029b602ea3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.erlang.cookie&lt;/code&gt; file is to contain a line with the same atom. For example, on Linux or UNIX, in the OS shell:</source>
          <target state="translated">&lt;code&gt;.erlang.cookie&lt;/code&gt; файл должен содержать строку с тем же атомом. Например, в Linux или UNIX в оболочке ОС:</target>
        </trans-unit>
        <trans-unit id="0032fcf48e0da685e59294f0a4f697a2db8dcacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.funcs&lt;/code&gt; file would look like:</source>
          <target state="translated">&lt;code&gt;.funcs&lt;/code&gt; файл будет выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="14e7547174b37977afa693aeffb001d289cd5a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hrl&lt;/code&gt; files are generated with &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt;. Include these files in your code as in the following example:</source>
          <target state="translated">В &lt;code&gt;.hrl&lt;/code&gt; файлы генерируются с &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt; . Включите эти файлы в свой код, как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="3f3c52adfe9451ed557d5cb72636a16ce9b8cff5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; файл</target>
        </trans-unit>
        <trans-unit id="f61412bcc5809a8e7db35485d4bc2ee4c582bd3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains information about the release: its name, version, and which ERTS and application versions it uses.</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; файл содержит информацию о релизе: название, версия, и которая ГЭР и версии приложений он использует.</target>
        </trans-unit>
        <trans-unit id="fba0dc5cd4e50a75950facea5ebefcde4b2c40d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains one single Erlang term, which is called a &lt;strong&gt;release specification&lt;/strong&gt;. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; файл содержит один единственный член Erlang, который называется &lt;strong&gt;спецификацией релиза&lt;/strong&gt; . Файл имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="9be75095f9fcc28e6742d9c5c6b665ebdc21fd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file must also contain &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt;, as these applications are required by &lt;code&gt;ch_app&lt;/code&gt;. The file is called &lt;code&gt;ch_rel-1.rel&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; файл также должен содержать &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; и &lt;code&gt;sasl&lt;/code&gt; , так как эти приложения требуются &lt;code&gt;ch_app&lt;/code&gt; . Файл называется &lt;code&gt;ch_rel-1.rel&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="13be72d295c9d3a74b0ba266a8b6d753044e4f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.script&lt;/code&gt; file is generated by &lt;code&gt;systools&lt;/code&gt; from a &lt;code&gt;.rel&lt;/code&gt; file and from &lt;code&gt;.app&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.script&lt;/code&gt; файл генерируется &lt;code&gt;systools&lt;/code&gt; из более &lt;code&gt;.rel&lt;/code&gt; файла и из &lt;code&gt;.app&lt;/code&gt; файлов.</target>
        </trans-unit>
        <trans-unit id="8952d3b159688281512664b4559315ca46a6b2ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; in which the resolved process id is stored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; , в котором разрешен Идентификатор процесса сохраняется.</target>
        </trans-unit>
        <trans-unit id="7f0ba8ce42f3241f6f1e8ce8e3ec88bd285be952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; in which the resolved port id is stored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; , в котором разрешенный порт идентификатор хранится.</target>
        </trans-unit>
        <trans-unit id="9be61e44d94622615ce4101938ee713afd7cdab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; has the same behavior as before, and the old API still works. Thus, you are not required to change anything unless you want to. However, &lt;strong&gt;you are strongly encouraged to use the new API&lt;/strong&gt; instead of the old API based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; is deprecated, as it is and will be a scalability bottleneck.</source>
          <target state="translated">Режим &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; имеет то же поведение, что и раньше, и старый API все еще работает. Таким образом, вам не нужно ничего менять, если вы этого не хотите. Однако &lt;strong&gt;настоятельно рекомендуется использовать новый API&lt;/strong&gt; вместо старого API, основанного на &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;erlang:now/0&lt;/code&gt; устарел, поскольку он есть и будет узким местом масштабируемости.</target>
        </trans-unit>
        <trans-unit id="18bf0f08971899dc4f16a1b00f5aad47c098d502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt; state transition action explicitly postpones one received event.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; предназначено для модели селективных получает. Выборочный прием неявно откладывает все непринятые события, но действие &lt;code&gt;postpone&lt;/code&gt; переход состояния явно откладывает одно полученное событие.</target>
        </trans-unit>
        <trans-unit id="2e521122544eb6fa9ab0cd68ed9751d9d365e33f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of Erlang monotonic time heavily depends on the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; в Erlang монотонного времени в значительной степени зависят от следующих условий :</target>
        </trans-unit>
        <trans-unit id="da959f4f913bd754095c0cffc4af1e4cec02fe00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt;&lt;strong&gt;transition action&lt;/strong&gt; explicitly postpones one received event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee853e7e00e08008dc7e059fac73729f774dbe00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt; enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f631a391a9754e49e6ee1bde4ff6f90ac52a87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; функция может быть использована , чтобы информировать систему о времени выполнения длины вызова NIF. Обычно его следует использовать всегда, если только NIF не выполняется очень быстро.</target>
        </trans-unit>
        <trans-unit id="42203200dce5d30a841bfbad273ab03cca628668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; records below are defined in diameter.hrl, which can be included as follows.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; записи ниже, определенные в diameter.hrl, которые могут быть включены следующие.</target>
        </trans-unit>
        <trans-unit id="5443a5673cfdeb62b70cfaa66a1a4d05ea2c10ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; is displayed.</source>
          <target state="translated">Откроется &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64917e182873d825bb4118b082544cb5020d55ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; test is not completely foolproof. For a few special node types (e.g. &lt;code&gt;arity_qualifier&lt;/code&gt;), if such a node occurs in a context where it is not expected, it will be left unchanged as a non-reverted subtree of the result. This can only happen if &lt;code&gt;Tree&lt;/code&gt; does not actually represent legal Erlang code.</source>
          <target state="translated">Тест &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; не является полностью надежным. Для нескольких специальных типов узлов (например, &lt;code&gt;arity_qualifier&lt;/code&gt; ), если такой узел встречается в контексте, где он не ожидается, он останется неизменным как необратимое поддерево результата. Это может произойти только в том случае, если &lt;code&gt;Tree&lt;/code&gt; на самом деле не представляет законный код Erlang.</target>
        </trans-unit>
        <trans-unit id="8bdddf2d9e89b5afec27570549313f0a00dfb66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; is displayed with information about all debugged processes, interpreted modules, and selected options. Initially there are normally no debugged processes. First, it must be specified which modules that are to be &lt;strong&gt;debugged&lt;/strong&gt; (also called &lt;strong&gt;interpreted&lt;/strong&gt;). Proceed as follows:</source>
          <target state="translated">Окно &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; отображается с информацией обо всех отлаженных процессах, интерпретируемых модулях и выбранных параметрах. Изначально отлаженных процессов обычно нет. Во-первых, необходимо указать, какие модули должны быть &lt;strong&gt;отлажены&lt;/strong&gt; (также называемые &lt;strong&gt;интерпретируемыми&lt;/strong&gt; ). Действуйте следующим образом:</target>
        </trans-unit>
        <trans-unit id="d1371003c4109f45bb7c590d9e6bfcf741d3783e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; at the time when current Erlang runtime system instance started.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; в момент , когда ток Erlang выполнение экземпляра запуск системы.</target>
        </trans-unit>
        <trans-unit id="c54a199fd4640b0c1f2d1a7d7f234a5d11ebf160" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; syntax and semantics resemble that of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; синтаксиса и семантики напоминают , что Perl.</target>
        </trans-unit>
        <trans-unit id="86910d8a99b113804f6c41ebe30ba830eeca44e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted in the event queue as the next to call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; with. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddaf5a8cfd6684f5a32a7cfde1c55113cf46f155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; may return &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;gen_statem&lt;/code&gt; to execute during the &lt;strong&gt;state transition&lt;/strong&gt;, for example to reply to a &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;gen_statem:call/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7246167f3c09c6525874f60b11ba89db7e2744c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted as the next to present to the state callback. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; может вставить события , используя &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; и такое событие вставляется в качестве следующего , чтобы представить в состояние обратного вызова. То есть как будто это самое старое входящее событие. Для таких событий может использоваться специальный &lt;code&gt;internal&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; что делает невозможным их принятие за внешние события.</target>
        </trans-unit>
        <trans-unit id="8dc397f4aad495e70f783e4e9f18314a11b4699a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79b4de0faec73ea8a56c3d33b4728d0d0f13117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; выполняются при вводе первого &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; так же , как для &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; , за исключением того, что действие &lt;code&gt;postpone&lt;/code&gt; вынужден &lt;code&gt;false&lt;/code&gt; , так как нет ни одного события , чтобы отложить.</target>
        </trans-unit>
        <trans-unit id="4b95289b0c26b39ec2e6bba34c2ea61ee391b999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec-option&lt;/a&gt;&lt;/code&gt; has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-6 above if conflicting. The old and undocumented style should not be used in new programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99afc1abdda369a0914949188ce7fb06901f6f8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec_spec&lt;/a&gt;&lt;/code&gt;&lt;code&gt;fun()&lt;/code&gt; is called with the same number of parameters as the arity of the fun, and the result is returned to the client. Shell-requests are not affected, they follow the &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt;'s value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04249803fd25f8d18a129af7ec7559589758bac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; are associated with this list of keys.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; связаны с этим списком ключей.</target>
        </trans-unit>
        <trans-unit id="c47299082b86fea81f7b73b85c3b481aabd9d033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; can then be passed to the aforementioned functions to use the referenced configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e395a27eee95c6082f8cf61222aaf962540cea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; must then be used in calls to &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Затем &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; или связанный &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; должен использоваться в вызовах для &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3dc033ce6bd037856bac83ebd4f39855340ec51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; type also consist of the following &lt;strong&gt;deprecated&lt;/strong&gt; symbolic time units:</source>
          <target state="translated">Тип &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; также состоит из следующих &lt;strong&gt;устаревших&lt;/strong&gt; символических единиц времени:</target>
        </trans-unit>
        <trans-unit id="88d76a69dffe86852b03f6f2771d64a235602ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is expected to know if reloading is demanded before creating a monitor for loading.</source>
          <target state="translated">Ожидается, что &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; узнает, требуется ли перезагрузка, прежде чем создавать монитор для загрузки.</target>
        </trans-unit>
        <trans-unit id="6529c6f67bbc8e3a2934d327ad30e40ae74a06cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;crypto#next_iv-2&quot;&gt;next_iv/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;crypto#next_iv-3&quot;&gt;next_iv/3&lt;/a&gt;&lt;/code&gt; is not needed since the &lt;code&gt;crypto_init&lt;/code&gt; and &lt;code&gt;crypto_update&lt;/code&gt; includes this functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef4e16c6d6043c0d934f6a3edee0c7cc5aa2fe6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; module provides the main interface for writing test cases. This includes for example, the following:</source>
          <target state="translated">Модуль &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; предоставляет основной интерфейс для написания тестовых случаев. Это включает, например, следующее:</target>
        </trans-unit>
        <trans-unit id="24d2428c5253a289420ac3c56a797aad5738f051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; function prints a string to the test case log file. The &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the string to screen. The &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the same string both to file and screen. The functions are described in module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; выводит строку в файл журнала тестового случая. Функция &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; выводит строку на экран. Функция &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; выводит одну и ту же строку как в файл, так и на экран. Функции описаны в модуле &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f487c24dcce56661b796ae49d9fa184c1120f87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_property_test&quot;&gt;ct_property_test&lt;/a&gt;&lt;/code&gt; module does the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7520b5a1282410b50e8ce82d773253694bcb5f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_property_test#present_result-4&quot;&gt;ct_property_test:present_result/4&lt;/a&gt;&lt;/code&gt; is a help function for printing some statistics in the CommonTest log file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2225a95d59e4a2a00a916261ffc2ac6e972545a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program can be used for running tests from the OS command line, for example, as follows:</source>
          <target state="translated">Программа &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; может использоваться для запуска тестов из командной строки ОС, например, следующим образом:</target>
        </trans-unit>
        <trans-unit id="45351661ad4006c4669c2ebdd26490749b02b241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; function performs pattern matching. It takes a pattern and a term and tries to match them. As a side effect any unbound variables in the pattern will be bound. In the following example, a pattern is created with a variable &lt;code&gt;Age&lt;/code&gt;, which is included at two positions in the tuple. The pattern match is performed as follows:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; выполняет сопоставление с образцом. Он берет образец и термин и пытается сопоставить их. В качестве побочного эффекта будут связаны любые несвязанные переменные в шаблоне. В следующем примере шаблон создается с переменной &lt;code&gt;Age&lt;/code&gt; , которая включена в две позиции в кортеже. Сопоставление с образцом выполняется следующим образом:</target>
        </trans-unit>
        <trans-unit id="f58e8b7ebcca47b5fa5b9e432d29b5c35a2acf4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d913aee0ec20f5c99548c0d67120c8b7390405c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; обратного вызова, которая используется много в этой реализации.</target>
        </trans-unit>
        <trans-unit id="5df35aa6c58680e6606845e3cb0a4b184a4d606d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel handling the remote channel. The Erlang format of thoose messages is (see also &lt;code&gt;&lt;a href=&quot;#type-event&quot;&gt;below&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04d20c0a21a342accdbeea00bdc89554c9bbc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel. If the receiving channel is an Erlang process, the messages have the format &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; используется клиентами и серверами, то есть, SSH каналов, для связи через соединение SSH. Функции API в этом модуле отправляют события протокола соединения SSH, которые принимаются удаленным каналом в виде сообщений. Если принимающим каналом является процесс Erlang, сообщения имеют формат &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt; . Если для реализации процесса канала используется поведение &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; , эти сообщения обрабатываются &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb9446bc2906454d7543c5cf2f665a89704ad38a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1021&quot;&gt;high-watermark&lt;/a&gt;&lt;/code&gt; is placed where the previous garbage collection (described in &lt;code&gt;&lt;a href=&quot;#Overview&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;) ended and we have introduced a new area called the old heap. When doing the normal garbage collection pass, any term that is located below the high-watermark is copied to the old &lt;strong&gt;to space&lt;/strong&gt; instead of the young.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd1b00c890947931beb8fe9dcb1f1a330520a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/global.h#L1452-L1465&quot;&gt;`erts_is_literal`&lt;/a&gt;&lt;/code&gt; check works differently on different architectures and operating systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f892246d7df69546254cbfcc798654f3646997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; defines</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; определяет</target>
        </trans-unit>
        <trans-unit id="db576f227eaa817db713aea46842d38ec3c43cfa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel handling the remote channel. The Erlang format of thoose messages is (see also &lt;code&gt;&lt;a href=&quot;#type-event&quot;&gt;below&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcb6a1e5d8b3f03deff03d3241d42eac28f4c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module makes it possible to map different parts of the host file system into the document tree, that is, creates aliases and redirections.</source>
          <target state="translated">Модуль &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; позволяет отображать различные части файловой системы хоста в дерево документа, то есть создает псевдонимы и перенаправления.</target>
        </trans-unit>
        <trans-unit id="fcc4b78316a4143698c35ef4043e086c3252f889" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; module provides for basic user authentication using textual files, Dets databases as well as Mnesia databases.</source>
          <target state="translated">Модуль &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; обеспечивает базовую аутентификацию пользователя с использованием текстовых файлов, баз данных Dets, а также баз данных Mnesia.</target>
        </trans-unit>
        <trans-unit id="461a1eaddbc542451f83c2ca184fe0b61bd2923e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; module implements the Erlang Server Interface (ESI) providing a tight and efficient interface to the execution of Erlang functions.</source>
          <target state="translated">Модуль &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; реализует интерфейс сервера Erlang (ESI), обеспечивая тесный и эффективный интерфейс для выполнения функций Erlang.</target>
        </trans-unit>
        <trans-unit id="451822a0390939c5b7aa871766fbf59707a840eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; module serves as a filter for authenticated requests handled in &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt;. It provides a possibility to restrict users from access for a specified amount of time if they fail to authenticate several times. It logs failed authentication as well as blocking of users, and it calls a configurable callback module when the events occur.</source>
          <target state="translated">Модуль &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; служит фильтром для аутентифицированных запросов, обрабатываемых в &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; . Это дает возможность ограничить доступ пользователей на определенный период времени, если они не прошли аутентификацию несколько раз. Он регистрирует неудачную аутентификацию, а также блокировку пользователей и вызывает настраиваемый модуль обратного вызова при возникновении событий.</target>
        </trans-unit>
        <trans-unit id="cca463bd9735d9ae37813de52272ea12a3c25d3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run program&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41608b3a764923c262561e0c2d97e667f71e82d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="translated">Программа &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; для обзора доступных стартовых флагов (поскольку у большинства флагов есть соответствующий термин конфигурации)</target>
        </trans-unit>
        <trans-unit id="3f97cdf73ff78f958f92c1082d9981899a202f74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2bdaafc19f8eda6fa7e095397c6b638b7731c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; module can be used for debugging a supervisor bridge.</source>
          <target state="translated">Модуль &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; можно использовать для отладки моста супервизора.</target>
        </trans-unit>
        <trans-unit id="1915b4761876d96adb7cfdaf20279417ba58c6b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; function starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the transfer.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; запускает процесс-демон, который прослушивает UDP-пакеты на порту. Когда он получает запрос на чтение или запись, он порождает временный серверный процесс, обрабатывающий передачу.</target>
        </trans-unit>
        <trans-unit id="34bf65dbe208c89793330cc690692124bc99f1eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt; multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e817126baaf83dd2177ff4d3961b1bf92117ec3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Используется &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d9a2bc15a65c27354714aedd36bc465c988bc11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt; no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac6d07dd79fabf515998a51c2c8ccd52cb9e6e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Используется &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a0707134722e646e7cc1eaf4404ec443d34378" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b934f9948e4845a2b33851b5932f94d59f1d45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Используется &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40c216921e0f08c2b36308cbbb132054a41492aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;CRYPTO User's Guide&lt;/a&gt;&lt;/code&gt; has more information on FIPS, Engines and Algorithm Details like key lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842d1fd61ccfd8c7f0a3b2ea51238f75d1a39f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; has examples and a &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; есть примеры и раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7213ba1d558f14b69b4e8a3edef214d04ef9e98a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?Q&lt;/code&gt; macros turn the quoted code fragments into ASTs, and lifts metavariables such as &lt;code&gt;_@Tuple&lt;/code&gt; and &lt;code&gt;_@Number&lt;/code&gt; to the level of your Erlang code, so you can use the corresponding Erlang variables &lt;code&gt;Tuple&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; directly. This is the most straightforward way to use Merl, and in many cases it's all you need.</source>
          <target state="translated">В &lt;code&gt;?Q&lt;/code&gt; макросы включить процитированные фрагменты кода в НРХ и подъемники метапеременными , такие как &lt;code&gt;_@Tuple&lt;/code&gt; и &lt;code&gt;_@Number&lt;/code&gt; на уровне кода Erlang, так что вы можете использовать соответствующие Erlang переменные &lt;code&gt;Tuple&lt;/code&gt; и &lt;code&gt;Number&lt;/code&gt; непосредственно. Это наиболее простой способ использования Merl, и во многих случаях это все, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="15c579f9adfb6704c3bcff309334cae348b5e5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?assert(Expression)&lt;/code&gt; macro will evaluate &lt;code&gt;Expression&lt;/code&gt;, and if that does not evaluate to &lt;code&gt;true&lt;/code&gt;, it will throw an exception; otherwise it just returns &lt;code&gt;ok&lt;/code&gt;. In the above example, the test will thus fail if the call to &lt;code&gt;length&lt;/code&gt; does not return 3.</source>
          <target state="translated">&lt;code&gt;?assert(Expression)&lt;/code&gt; макрос будет оценивать &lt;code&gt;Expression&lt;/code&gt; , и если это не вычисляется &lt;code&gt;true&lt;/code&gt; , то будет сгенерировано исключение; в противном случае он просто вернется &lt;code&gt;ok&lt;/code&gt; . Таким образом, в приведенном выше примере тест завершится неудачно, если вызов &lt;code&gt;length&lt;/code&gt; не вернет 3.</target>
        </trans-unit>
        <trans-unit id="824fe9ddd06f6c4a1a05c0b0fcb9265f7a7b2017" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ASN.1&lt;/code&gt; application provides the following two separate user interfaces:</source>
          <target state="translated">Приложение &lt;code&gt;ASN.1&lt;/code&gt; предоставляет следующие два отдельных пользовательских интерфейса:</target>
        </trans-unit>
        <trans-unit id="ad1896e2fd3770f39ede02112fb63bbac81b7df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Address&lt;/code&gt; field is the second element.</source>
          <target state="translated">Поле &lt;code&gt;Address&lt;/code&gt; - второй элемент.</target>
        </trans-unit>
        <trans-unit id="90bfd70e3f20f8f506d98edda14b178d797720e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AlgorithmId&lt;/code&gt; is the signature OID from a certificate or a certificate revocation list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e284c989131372b49e03051b62849870dd521425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to &quot;compact notation&quot;. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;BIT STRING&lt;/code&gt; декодируется в &quot;компактную запись&quot;. &lt;strong&gt;Этот вариант не рекомендуется для нового кода. &lt;/strong&gt;Этот параметр нельзя комбинировать с &lt;code&gt;maps&lt;/code&gt; параметров .</target>
        </trans-unit>
        <trans-unit id="d727373c971108a708085cfa309ebdb4fa5bc28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to the legacy format, that is, a list of zeroes and ones. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;BIT STRING&lt;/code&gt; декодируется в устаревший формат, то есть в список нулей и единиц. &lt;strong&gt;Этот вариант не рекомендуется для нового кода. &lt;/strong&gt;Этот параметр нельзя комбинировать с &lt;code&gt;maps&lt;/code&gt; параметров .</target>
        </trans-unit>
        <trans-unit id="3c84e077a6dbf3c771cfd255a8a9895e6702d3a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bitstring&lt;/code&gt; variable can consist of any number of bits, for example, 0, 1, 8, 11, 17, 42, and so on. This is because the default &lt;code&gt;unit&lt;/code&gt; for bitstrings is 1.</source>
          <target state="translated">&lt;code&gt;Bitstring&lt;/code&gt; переменная может состоять из любого числа битов, например, 0, 1, 8, 11, 17, 42, и так далее. Это связано с тем, что &lt;code&gt;unit&lt;/code&gt; по умолчанию для битовых строк является 1.</target>
        </trans-unit>
        <trans-unit id="94a1488efe62c17d8ba98c01afd1b232f7321a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; argument indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Block&lt;/code&gt; аргумент указывает , если журнал должен быть заблокирован во время преобразования. Это может быть полезно при преобразовании больших журналов (в противном случае журнал может быть перенесен во время преобразования). По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ab5f211e8f18fd1c4ca859d11a5d3fcd218d631" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; option indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Параметр &amp;laquo; &lt;code&gt;Block&lt;/code&gt; указывает, следует ли блокировать журнал во время преобразования. Это может быть полезно при преобразовании больших журналов (в противном случае журнал может быть перенесен во время преобразования). По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2a775047eba8dcca0470291f62d589146470f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufSz&lt;/code&gt; argument basically defines the size of the receive buffer. By setting the value to zero (0), the configured size (setopt with &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt; and &lt;code&gt;Key&lt;/code&gt; = &lt;code&gt;rcvbuf&lt;/code&gt;) is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acfbefe2ee37310ba387213e5e15aa6901a988c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Callback&lt;/code&gt; module should contain hook functions for all tags present in the data structure. A hook function must have the following format:</source>
          <target state="translated">Модуль &lt;code&gt;Callback&lt;/code&gt; должен содержать функции перехвата для всех тегов, присутствующих в структуре данных. Функция-перехватчик должна иметь следующий формат:</target>
        </trans-unit>
        <trans-unit id="883390db9451e13b3d5a5f85d744ec9ca06a2b24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallbackMode&lt;/code&gt; is either just &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; or a list containing &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; and possibly the atom &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CallbackMode&lt;/code&gt; либо просто &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; или список , содержащий &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; и , возможно, атом &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a580d51d45e0183e4b31ffec1224002d11cfbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CharSpec&lt;/code&gt;&lt;code&gt;eof&lt;/code&gt; signals end of file. &lt;code&gt;LeftOverChars&lt;/code&gt; then takes the value &lt;code&gt;eof&lt;/code&gt; as well.</source>
          <target state="translated">В &lt;code&gt;CharSpec&lt;/code&gt; &lt;code&gt;eof&lt;/code&gt; сигналы конца файла. &lt;code&gt;LeftOverChars&lt;/code&gt; также принимает значение &lt;code&gt;eof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64d980b4c7c9584d2e8b4e055ab6694f99c89599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChildSpecs&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; is a list of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChildSpecs&lt;/code&gt; переменного возвращаемого значения &lt;code&gt;init/1&lt;/code&gt; приведен список &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5232c85e790e4f73652dc642ce50e6888594555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChunkSize&lt;/code&gt; defines the size of the &lt;code&gt;PlainBin&lt;/code&gt;s that &lt;code&gt;EncodeFun&lt;/code&gt; is applied to. If the &lt;code&gt;ChunkSize&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;ChunkSize&lt;/code&gt; is intended for block crypto. &lt;code&gt;ChunkSize&lt;/code&gt;s can be changed in the return from the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChunkSize&lt;/code&gt; определяет размер &lt;code&gt;PlainBin&lt;/code&gt; с , что &lt;code&gt;EncodeFun&lt;/code&gt; применяется к. Если &lt;code&gt;ChunkSize&lt;/code&gt; не &lt;code&gt;undefined&lt;/code&gt; , размер &lt;code&gt;PlainBin&lt;/code&gt; s изменяется, потому что он предназначен для потокового шифрования, тогда как фиксированный &lt;code&gt;ChunkSize&lt;/code&gt; предназначен для блочного шифрования. &lt;code&gt;ChunkSize&lt;/code&gt; s может быть изменен в возврате от &lt;code&gt;EncryptFun&lt;/code&gt; или &lt;code&gt;DecryptFun&lt;/code&gt; . Значение может быть изменено между &lt;code&gt;pos_integer()&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8a7a9966f0b85d64cc4feece108959a21b830fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; API does also allow you to save the collected &lt;code&gt;Events&lt;/code&gt; to file and later load them in a later session.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; API делает также позволяет сохранять собранные &lt;code&gt;Events&lt;/code&gt; в файл , а затем загрузить их в более поздней сессии.</target>
        </trans-unit>
        <trans-unit id="fceb8c2c1f65a97284385a3f23405d68267725fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; automatically registers itself to listen for trace &lt;code&gt;Events&lt;/code&gt;, so all you have to do is enable them.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; автоматически регистрирует себя для прослушивания трассировки &lt;code&gt;Events&lt;/code&gt; , поэтому все , что вам нужно сделать , это включить их.</target>
        </trans-unit>
        <trans-unit id="ec20677889045987c82a0d9f6c4d053fcf85822c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; manages a key/value based dictionary, where the filters are stored. Updates of the dictionary is propagated to all subscribing processes. When a &lt;code&gt;Viewer&lt;/code&gt; is started it is registered as a subscriber of dictionary updates.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; управляет словарь , основанный ключ / значение, где фильтры сохраняются. Обновления словаря распространяются на все подписавшиеся процессы. Когда &lt;code&gt;Viewer&lt;/code&gt; запускается, он регистрируется как подписчик обновлений словаря.</target>
        </trans-unit>
        <trans-unit id="e368c10bff22300d3fab811f6f50a4674a69667b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Framework Log page includes links to the Pre- and Post Test I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; and &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt;, as well as captured system error- and progress reports, which take place before, and after, the test run. Examples of this are printouts from a CT hook init- or terminate function, or progress reports generated when an OTP application is started from a CT hook init function. Another example is an error report generated because of a failure when an external application is stopped from a CT hook terminate function. All information in these examples ends up in the Pre- and Post Test I/O Log. For more information on how to synchronize test runs with external user applications, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; in section Common Test Hooks.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; страница Framework Log содержит ссылки на древнейшей и после теста ввода / вывода журнала. В этом журнале &lt;code&gt;Common Test&lt;/code&gt; сохраняет распечатки, сделанные с помощью &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; и &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; ., а также фиксированные системные отчеты об ошибках и ходе выполнения, которые создаются до и после запуска теста. Примерами этого являются распечатки из функции инициализации или завершения ловушки CT, или отчеты о ходе выполнения, созданные при запуске приложения OTP из функции инициализации ловушки CT. Другой пример - отчет об ошибке, созданный из-за сбоя, когда внешнее приложение останавливается из-за функции завершения ловушки CT. Вся информация в этих примерах попадает в журнал ввода-вывода до и после тестирования. Для получения дополнительной информации о том, как синхронизировать выполнение тестов с внешними пользовательскими приложениями, см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; в разделе &amp;laquo;Общие тестовые хуки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2b15f94344ef9977a91750baa9dddf1dbad0746d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master API is exported by module &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master API экспортируется модулем &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1eb6fe3660c4d65491500f6426215f629639619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server runs on one dedicated Erlang node and uses distributed Erlang to communicate with any number of &lt;code&gt;Common Test&lt;/code&gt; test nodes, each hosting a regular &lt;code&gt;Common Test&lt;/code&gt; server. Test specifications are used as input to specify what to test on which test nodes, using what configuration.</source>
          <target state="translated">Главный сервер &lt;code&gt;Common Test&lt;/code&gt; работает на одном выделенном узле Erlang и использует распределенный Erlang для связи с любым количеством узлов тестирования &lt;code&gt;Common Test&lt;/code&gt; , на каждом из которых размещается обычный сервер &lt;code&gt;Common Test&lt;/code&gt; . Спецификации тестирования используются в качестве входных данных, чтобы указать, что тестировать на каких тестовых узлах и в какой конфигурации.</target>
        </trans-unit>
        <trans-unit id="d910e14beb83938480f0c5db0900211c5bc5ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server writes progress information to HTML log files similarly to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The logs contain test statistics and links to the log files written by each independent &lt;code&gt;Common Test&lt;/code&gt; server.</source>
          <target state="translated">Главный сервер &lt;code&gt;Common Test&lt;/code&gt; записывает информацию о ходе выполнения в файлы журнала HTML аналогично обычному серверу &lt;code&gt;Common Test&lt;/code&gt; . Журналы содержат статистику тестов и ссылки на файлы журналов, записанные каждым независимым сервером &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e124139583e4b5d8918f07bb2c0c03bd8d6c703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application also includes other modules named &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt;, which provide various support, mainly simplified use of communication protocols such as RPC, SNMP, FTP, Telnet, and others.</source>
          <target state="translated">Приложение &lt;code&gt;Common Test&lt;/code&gt; также включает другие модули с именем &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt; , которые обеспечивают различную поддержку, в основном упрощенное использование протоколов связи, таких как RPC, SNMP, FTP, Telnet и другие.</target>
        </trans-unit>
        <trans-unit id="03a84fce685f88578ce41de6a729049cb8fac0fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application is installed with the Erlang/OTP system. No extra installation step is required to start using &lt;code&gt;Common Test&lt;/code&gt; through the &lt;code&gt;ct_run&lt;/code&gt; executable program, and/or the interface functions in the &lt;code&gt;ct&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; приложение устанавливается с системой Erlang / OTP. Никаких дополнительных шагов установки не требуется, чтобы начать использовать &lt;code&gt;Common Test&lt;/code&gt; через исполняемую программу &lt;code&gt;ct_run&lt;/code&gt; и / или функции интерфейса в модуле &lt;code&gt;ct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78a22725d0c7f0f676d4ba2a90661e795ebb56c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is a tool that supports implementation and automated execution of test cases to any types of target systems. &lt;code&gt;Common Test&lt;/code&gt; is the main tool being used in all testing- and verification activities that are part of Erlang/OTP system development and maintenance.</source>
          <target state="translated">Платформа &lt;code&gt;Common Test&lt;/code&gt; Framework - это инструмент, который поддерживает реализацию и автоматическое выполнение тестовых примеров для любых типов целевых систем. &lt;code&gt;Common Test&lt;/code&gt; - это основной инструмент, который используется во всех действиях по тестированию и проверке, которые являются частью разработки и сопровождения системы Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="18e9917f7eb0c975fe2d0bf461322b555cc56962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is an environment for implementing and performing automatic and semi-automatic execution of test cases.</source>
          <target state="translated">Платформа &lt;code&gt;Common Test&lt;/code&gt; - это среда для реализации и автоматического и полуавтоматического выполнения тестовых примеров.</target>
        </trans-unit>
        <trans-unit id="c32a30ee7b6005326d0a472ffa1a54f5ce95df96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework provides a high-level operator interface for testing, providing the following features:</source>
          <target state="translated">Платформа &lt;code&gt;Common Test&lt;/code&gt; предоставляет высокоуровневый интерфейс оператора для тестирования, предоставляя следующие функции:</target>
        </trans-unit>
        <trans-unit id="ad9b65cad13beffef2e82d575de6699dcf88a08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; test server requires that the test suite defines and exports the following mandatory or optional callback functions:</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; тестовый сервер требует, чтобы результаты тестов определяют и экспортирует следующие обязательные или необязательные функции обратного вызова:</target>
        </trans-unit>
        <trans-unit id="b3f5974325a1f6adb2e7a53fd6b80b396429c849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database is now initialized and contains data.</source>
          <target state="translated">База данных &lt;code&gt;Company&lt;/code&gt; теперь инициализирована и содержит данные.</target>
        </trans-unit>
        <trans-unit id="84399fbfc3c32ddc0958865c1bc7e66e07f291b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database, introduced in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, has three tables that store records (&lt;code&gt;employee&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, &lt;code&gt;project&lt;/code&gt;), and three tables that store relationships (&lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, &lt;code&gt;in_proj&lt;/code&gt;). This is a normalized data model, which has some advantages over a non-normalized data model.</source>
          <target state="translated">База данных &lt;code&gt;Company&lt;/code&gt; , представленная в &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; , имеет три таблицы, в которых хранятся записи ( &lt;code&gt;employee&lt;/code&gt; , &lt;code&gt;dept&lt;/code&gt; , &lt;code&gt;project&lt;/code&gt; ), и три таблицы, в которых хранятся отношения ( &lt;code&gt;manager&lt;/code&gt; , &lt;code&gt;at_dep&lt;/code&gt; , &lt;code&gt;in_proj&lt;/code&gt; ). Это нормализованная модель данных, которая имеет некоторые преимущества перед ненормализованной моделью данных.</target>
        </trans-unit>
        <trans-unit id="5b4167561d4c9786e75acf722fa5255d76e1f375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ControlMessage&lt;/code&gt; is a tuple, where the first element indicates which distributed operation it encodes:</source>
          <target state="translated">&lt;code&gt;ControlMessage&lt;/code&gt; является кортеж, в котором первый элемент , который указывает на то распределенной операции он кодирует:</target>
        </trans-unit>
        <trans-unit id="a9bce474e15518f3622f365b9755866898515b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CtrlSz&lt;/code&gt; argument basically defines the size of the receive buffer for the control messages. By setting the value to zero (0), the configured size (setopt with &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt;) is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53e02a747463b517e8ec15e14ceddfb049c6d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DAT&lt;/code&gt; files must always be opened with option &lt;code&gt;{repair, false}&lt;/code&gt;. This ensures that these files are not automatically repaired. Without this option, the database can become inconsistent, because &lt;code&gt;Mnesia&lt;/code&gt; can believe that the files were properly closed. For information about configuration parameter &lt;code&gt;auto_repair&lt;/code&gt;, see the Reference Manual.</source>
          <target state="translated">В &lt;code&gt;DAT&lt;/code&gt; - файлы всегда должны быть открыты с опцией &lt;code&gt;{repair, false}&lt;/code&gt; . Это гарантирует, что эти файлы не будут исправлены автоматически. Без этой опции база данных может стать несогласованной, потому что &lt;code&gt;Mnesia&lt;/code&gt; может полагать, что файлы были правильно закрыты. Для получения информации о параметре конфигурации &lt;code&gt;auto_repair&lt;/code&gt; см. Справочное руководство.</target>
        </trans-unit>
        <trans-unit id="5873af1928aed9c59ec2db4bf69bcbdd1c33d63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Data&lt;/code&gt; received can be a &lt;code&gt;binary()&lt;/code&gt; or a &lt;code&gt;list()&lt;/code&gt; of bytes (integers in the range 0 through 255) depending on the socket mode, or an SCTP event.</source>
          <target state="translated">Полученные &lt;code&gt;Data&lt;/code&gt; могут быть &lt;code&gt;binary()&lt;/code&gt; или &lt;code&gt;list()&lt;/code&gt; байтов (целые числа в диапазоне от 0 до 255) в зависимости от режима сокета или события SCTP.</target>
        </trans-unit>
        <trans-unit id="69f5b6911daa714868434e1a90189319187674c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DbgExtra&lt;/code&gt; options are described in section &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;DbgExtra&lt;/code&gt; описаны в разделе &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16f5677b6ef24617d1e07a7aa94edc055731eaee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DiscoHandler&lt;/code&gt; module is used during the discovery process. See &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">Модуль &lt;code&gt;DiscoHandler&lt;/code&gt; используется в процессе обнаружения. См. Подробности в &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="510046e751218ed5f95a1059673c4d8fbf2a7fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dst&lt;/code&gt; map is updated with new channel values. The syntax for updating an existing key with a new value is with the &lt;code&gt;:=&lt;/code&gt; operator.</source>
          <target state="translated">Карта &lt;code&gt;Dst&lt;/code&gt; обновляется новыми значениями каналов. Синтаксис обновления существующего ключа новым значением - оператор &lt;code&gt;:=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f4f4e3c2c9185266f65e6f7d9040faa980d49a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt; erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e5af70acd62ed71f0140803a094eed25236db0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="translated">&lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; Термин тип используется для передачи термин , закодированного с &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; , то есть срок , который был закодирован с помощью &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; , и так далее. Например, если &lt;code&gt;binp&lt;/code&gt; является указателем на &lt;code&gt;ErlDrvBinary&lt;/code&gt; , который содержит термин &lt;code&gt;{17, 4711}&lt;/code&gt; закодированный с помощью &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; , и вы хотите &lt;code&gt;my_tag&lt;/code&gt; кортеж с тегом my_tag , то есть &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt; , вы можете сделать следующее:</target>
        </trans-unit>
        <trans-unit id="8c0ac01302ce56a5538e783afbe86c0e3ca92aac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; term is a way to construct strings. It works differently from how &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; works. &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; builds a string list in reverse order (as opposed to how &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; works), concatenating the strings added to a list. The tail must be specified before &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; термин является способом построения строк. Он работает иначе, чем &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; . &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; строит список строк в обратном порядке (в отличие от того, как работает &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; ), объединяя строки, добавленные в список. Хвост должен быть указан перед &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe5603a0b688982ee095c5b6eb8b3abf301f57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_UINT&lt;/code&gt;, &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt;, and &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term types were introduced in ERTS 5.6.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_UINT&lt;/code&gt; , &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; и &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; термин тип были введены в ЭРЦЕ 5.6.</target>
        </trans-unit>
        <trans-unit id="78c7a39595ca5fe9252d32999a603c6e910dd570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable can be used to store the complicated parameters in:</source>
          <target state="translated">&lt;code&gt;ERL_FLAGS&lt;/code&gt; переменная среды может быть использована для хранения сложных параметров в:</target>
        </trans-unit>
        <trans-unit id="0a3584a359b0427b176ceaff9674304e574ffce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Emakefile&lt;/code&gt; (if it exists) in the current directory is searched for compiler options for each module. If a given module does not exist in &lt;code&gt;Emakefile&lt;/code&gt; or if &lt;code&gt;Emakefile&lt;/code&gt; does not exist, the module is still compiled.</source>
          <target state="translated">&lt;code&gt;Emakefile&lt;/code&gt; (если он существует) в текущем каталоге ищется параметры компилятора для каждого модуля. Если данный модуль не существует в &lt;code&gt;Emakefile&lt;/code&gt; или если &lt;code&gt;Emakefile&lt;/code&gt; не существует, модуль все равно компилируется.</target>
        </trans-unit>
        <trans-unit id="da28c7ffe618c58fd36df47a840c22abe8ebdbed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encoding&lt;/code&gt; says how the characters in the request are represented. We want to store the characters as lists in the ETS table, so we convert them to lists using function &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt;. The conversion function conveniently accepts the encoding types &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;latin1&lt;/code&gt;, so we can use &lt;code&gt;Encoding&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;Encoding&lt;/code&gt; говорит как символы в запросе представлены. Мы хотим сохранить символы в виде списков в таблице ETS, поэтому мы преобразуем их в списки с помощью функции &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt; . Функция преобразования удобно принимает типы кодировки &lt;code&gt;unicode&lt;/code&gt; и &lt;code&gt;latin1&lt;/code&gt; , поэтому мы можем использовать &lt;code&gt;Encoding&lt;/code&gt; напрямую.</target>
        </trans-unit>
        <trans-unit id="e3c694d3baa325d31ca5ef434295459f7fd84d35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvBinary&lt;/code&gt; structure is a binary, as sent between the emulator and the driver. All binaries are reference counted; when &lt;code&gt;driver_binary_free&lt;/code&gt; is called, the reference count is decremented, when it reaches zero, the binary is deallocated. &lt;code&gt;orig_size&lt;/code&gt; is the binary size and &lt;code&gt;orig_bytes&lt;/code&gt; is the buffer. &lt;code&gt;ErlDrvBinary&lt;/code&gt; has not a fixed size, its size is &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt;.</source>
          <target state="translated">Структура &lt;code&gt;ErlDrvBinary&lt;/code&gt; - это двоичная структура, передаваемая между эмулятором и драйвером. Все двоичные файлы подсчитываются по ссылкам; когда &lt;code&gt;driver_binary_free&lt;/code&gt; , счетчик ссылок уменьшается, когда он достигает нуля, двоичный файл освобождается. &lt;code&gt;orig_size&lt;/code&gt; - это двоичный размер, а &lt;code&gt;orig_bytes&lt;/code&gt; - это буфер. &lt;code&gt;ErlDrvBinary&lt;/code&gt; не имеет фиксированного размера, его размер: &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c86b87f3b0b95eba095182c55f0fcc45cc6647fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvNowData&lt;/code&gt; structure holds a time stamp consisting of three values measured from some arbitrary point in the past. The three structure members are:</source>
          <target state="translated">Структура &lt;code&gt;ErlDrvNowData&lt;/code&gt; содержит отметку времени, состоящую из трех значений, измеренных с некоторой произвольной точки в прошлом. Три члена структуры:</target>
        </trans-unit>
        <trans-unit id="4c525691955a7766948a2ab00688137550480556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f846aa2a9d3bbb835eaa5c58e3ac257c0f2247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="translated">Структура &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; используется для хранения информации о системе времени выполнения Erlang. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; записывает системную информацию при передаче ссылки на структуру &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; . Поля в структуре следующие:</target>
        </trans-unit>
        <trans-unit id="a097b8521d625c64b18dfa0ef6d0bb28ad84fb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library contains functions that help you integrate programs written in C and Erlang. The functions in &lt;code&gt;Erl_Interface&lt;/code&gt; support the following:</source>
          <target state="translated">Библиотека &lt;code&gt;Erl_Interface&lt;/code&gt; содержит функции, которые помогают интегрировать программы, написанные на C и Erlang. Функции в &lt;code&gt;Erl_Interface&lt;/code&gt; поддерживают следующее:</target>
        </trans-unit>
        <trans-unit id="6e029ea371407136acd36ef3f94ae9b566be79a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0bb8f936d4589865a80fe604ad9b594bedb70df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The library also contains an encode and a decode function. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="translated">Библиотека &lt;code&gt;Erl_Interface&lt;/code&gt; поддерживает это действие. В нем есть несколько функций C, которые создают структуры данных Erlang и управляют ими. Библиотека также содержит функции кодирования и декодирования. В следующем примере показано, как создать и закодировать кортеж Erlang &lt;code&gt;{tobbe,3928}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="57a4e297c09c6f1e5049ba6a6a04c4f9715c1746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorDesc&lt;/code&gt; returned is an opaque value to be passed further on to function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;. For more control over the operation, use the &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;ErrorDesc&lt;/code&gt; возвращаемой непрозрачное значения , которое передается далее на функцию &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; . Для большего контроля над операцией используйте интерфейс &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a7a560a95e6aefba3bb607f84b70fa45da9fcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned earlier is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure, which is returned from all I/O modules. It has the following format:</source>
          <target state="translated">&lt;code&gt;ErrorInfo&lt;/code&gt; упоминалось ранее является стандартом &lt;code&gt;ErrorInfo&lt;/code&gt; структура, которая возвращается из всех модулей ввода / вывода. Он имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="46cd6a74f6ad42247387aa8b77c1e43606850bb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned in this module is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure that is returned from all I/O modules. It has the following format:</source>
          <target state="translated">&lt;code&gt;ErrorInfo&lt;/code&gt; упоминалось в этом модуле является стандартной &lt;code&gt;ErrorInfo&lt;/code&gt; структура , которая возвращается из всех модулей ввода / вывода. Он имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="93b9c6c6a8848b5cb82997ba3624a2f0fabf1b76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Records&lt;/code&gt; in the Ets table are ordered by their timestamp. Which timestamp that should be used is controlled via the &lt;code&gt;event_order&lt;/code&gt; parameter. Default is &lt;code&gt;trace_ts&lt;/code&gt; which means the time when the trace data was generated. &lt;code&gt;event_ts&lt;/code&gt; means the time when the trace data was parsed (transformed into an &lt;code&gt;Event Record&lt;/code&gt;).</source>
          <target state="translated">В &lt;code&gt;Event Records&lt;/code&gt; в таблице Ets упорядочена по их временной метке. Какая временная метка должна использоваться, контролируется параметром &lt;code&gt;event_order&lt;/code&gt; . По умолчанию это &lt;code&gt;trace_ts&lt;/code&gt; , что означает время, когда были созданы данные трассировки. &lt;code&gt;event_ts&lt;/code&gt; означает время, когда данные трассировки были проанализированы (преобразованы в &lt;code&gt;Event Record&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="78b79ae16c44e1321dea0365d3ec779b8f949891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses named filters in various contexts. An Event Trace filter is an &lt;code&gt;Erlang fun&lt;/code&gt; that takes some trace data as input and returns a possibly modified version of it:</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; использует именованные фильтры в различных контекстах. Фильтр трассировки событий - это &lt;code&gt;Erlang fun&lt;/code&gt; на Erlang, которое принимает на вход некоторые данные трассировки и возвращает их, возможно, измененную версию:</target>
        </trans-unit>
        <trans-unit id="272a43aecd37d28c1a13622b7271bed26dc65387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses the built-in trace mechanism in Erlang and provides tools for collection and graphical viewing of trace data.</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; использует встроенный механизм трассировки в Erlang и предоставляет инструменты для сбора и просмотра графических данных трассировки.</target>
        </trans-unit>
        <trans-unit id="7b3f5424185756e71f4988bcc6cd871d1c3dd01e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expire&lt;/code&gt; time indicates for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">&lt;code&gt;Expire&lt;/code&gt; время показывает, как долго запрос действителен (после чего менеджер может свободно удалить его).</target>
        </trans-unit>
        <trans-unit id="39bea9e5ae5bbc7a2dffd8b8ca100b554fe6e7ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6c34cadce8690c6e2555787337ac8b727e225e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;Extra&lt;/code&gt; указывается при добавлении фильтра через &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="727df65f2f4d2a5696a95b4aebc0f85f3f6e4431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229acf43839cafb043149ab1533fb570fa7aafb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;Extra&lt;/code&gt; к функции &lt;code&gt;domain/2&lt;/code&gt; указывается при добавлении фильтра через &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52e94c11f02389a5bccbbedf86c2e899b3c665d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraArgument&lt;/code&gt; parameter is the empty list. For example, when the agent receives a get-request for the &lt;code&gt;ipAdr&lt;/code&gt; variable, a call will be made to &lt;code&gt;ip_access(get)&lt;/code&gt;. The value returned by this function is the answer to the get-request.</source>
          <target state="translated">Параметр &lt;code&gt;ExtraArgument&lt;/code&gt; - это пустой список. Например, когда агент получает запрос на &lt;code&gt;ipAdr&lt;/code&gt; переменной ipAdr , будет выполнен &lt;code&gt;ip_access(get)&lt;/code&gt; . Значение, возвращаемое этой функцией, является ответом на запрос получения.</target>
        </trans-unit>
        <trans-unit id="fb7a37656b5be6c6e17b2389894ea550dae8ed86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on from the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;ExtraInfo&lt;/code&gt; аргумент передается от &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="f30e53e02c0d2cd4e451fab992fbc868cf17c42e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on to the callback functions of the &lt;code&gt;DiscoHandler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ExtraInfo&lt;/code&gt; аргумент передается в функцию обратного вызова в &lt;code&gt;DiscoHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="289abc6fff4535554475e47566270dcbf6237037" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Freeze&lt;/code&gt; button starts/stops the redrawing of the graph. &lt;code&gt;Reset&lt;/code&gt; moves the graph to the middle of the window and resets all graph settings to default, with the exception of deleted nodes.</source>
          <target state="translated">Кнопка &lt;code&gt;Freeze&lt;/code&gt; запускает / останавливает перерисовку графика. &lt;code&gt;Reset&lt;/code&gt; перемещает график в середину окна и сбрасывает все настройки графика по умолчанию, за исключением удаленных узлов.</target>
        </trans-unit>
        <trans-unit id="0da0ebb6c63a989a7a4138310af5788ea3268e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserData,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserData&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb27036c1560c4a25ff7bd106092a75ea724c349" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserPrivate&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; вызывается , когда функция дегтя хочет сделать операцию низкого уровня, как запись блока в файл. &lt;code&gt;Fun&lt;/code&gt; называется &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; это имя операции, &lt;code&gt;UserPrivate&lt;/code&gt; это термин , передается в качестве первого аргумента &lt;code&gt;init/1&lt;/code&gt; и &lt;code&gt;Parameters...&lt;/code&gt; являются данные добавленные tar, которая будет передана функции обработки хранилища.</target>
        </trans-unit>
        <trans-unit id="5d186993003ed1ccd81976e2681cc3264ce79a2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is the definition of what to do when the different storage operations functions are to be called from the higher tar handling functions (such as &lt;code&gt;add/3&lt;/code&gt;, &lt;code&gt;add/4&lt;/code&gt;, and &lt;code&gt;close/1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; является определение того , что делать , когда функции различных операций хранения должны быть вызваны из высших функций обработки смол (например, &lt;code&gt;add/3&lt;/code&gt; , &lt;code&gt;add/4&lt;/code&gt; , и &lt;code&gt;close/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca0ec970a34ee33c7f128926a1e15f48a39b7957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;foldl/3&lt;/code&gt; returns the final accumulator value. &lt;code&gt;Acc0&lt;/code&gt; is returned if the archive is empty. It is not necessary to iterate over all files in the archive. The iteration can be ended prematurely in a controlled manner by throwing an exception.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; должен возвращать новый аккумулятор, который передается к следующему вызову. &lt;code&gt;foldl/3&lt;/code&gt; возвращает окончательное значение аккумулятора. &lt;code&gt;Acc0&lt;/code&gt; возвращается, если архив пуст. Нет необходимости перебирать все файлы в архиве. Итерацию можно закончить преждевременно контролируемым образом, вызвав исключение.</target>
        </trans-unit>
        <trans-unit id="387a945d1ef3c3c3d8058c83966af63af2d4d8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt; section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that the following guard test written in Erlang:</source>
          <target state="translated">Раздел &lt;code&gt;Guard&lt;/code&gt; также может содержать логические и арифметические операции, которые написаны с тем же синтаксисом, что и тесты защиты (префиксная нотация), поэтому следующий тест защиты написан на Erlang:</target>
        </trans-unit>
        <trans-unit id="0ed2562e6fd2d312da06422aef22e77ebef5ba9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt;s are constructed as tuples, where the first element is the test name and the remaining elements are the test parameters. To check for a specific type (say a list) of the element bound to the match variable &lt;code&gt;'$1'&lt;/code&gt;, one would write the test as &lt;code&gt;{is_list, '$1'}&lt;/code&gt;. If the test fails, the object in the table does not match and the next &lt;code&gt;MatchFunction&lt;/code&gt; (if any) is tried. Most guard tests present in Erlang can be used, but only the new versions prefixed &lt;code&gt;is_&lt;/code&gt; are allowed (&lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_atom&lt;/code&gt;, and so on).</source>
          <target state="translated">В &lt;code&gt;Guard&lt;/code&gt; ы выполнен в виде кортежей, где первый элемент является именем теста , а остальные элементы являются параметрами испытаний. Чтобы проверить конкретный тип (скажем, список) элемента, привязанного к переменной соответствия &lt;code&gt;'$1'&lt;/code&gt; , &lt;code&gt;{is_list, '$1'}&lt;/code&gt; написать тест как {is_list, '$ 1'} . Если тест не проходит, объект в таблице не совпадает, и выполняется &lt;code&gt;MatchFunction&lt;/code&gt; следующей MatchFunction (если есть). Можно использовать большинство защитных тестов, представленных в Erlang, но разрешены только новые версии с префиксом &lt;code&gt;is_&lt;/code&gt; ( &lt;code&gt;is_float&lt;/code&gt; , &lt;code&gt;is_atom&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="3de2a50d3651924af28c65d29b6c75e407eb8165" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HTTP&lt;/code&gt; version of the request, that is, &quot;HTTP/0.9&quot;, &quot;HTTP/1.0&quot;, or &quot;HTTP/1.1&quot;.</source>
          <target state="translated">&lt;code&gt;HTTP&lt;/code&gt; - версия запроса, то есть, &quot;HTTP / 0.9&quot;, &quot;HTTP / 1.0&quot;, или &quot;HTTP / 1.1&quot;.</target>
        </trans-unit>
        <trans-unit id="462a5eb6a4e1b7237b73c6e94eed8c647d921612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HostName&lt;/code&gt; will also be used in the hostname verification of the peer certificate using &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HostName&lt;/code&gt; также будет использоваться в имени хоста проверки сертификата с помощью экспертной &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fe5414d8d8a859939f8d4935fe18c2a11ba8b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Id&lt;/code&gt; identifies a CTH instance uniquely. If two CTHs return the same &lt;code&gt;Id&lt;/code&gt;, the second CTH is ignored and subsequent calls to the CTH are only made to the first instance. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Id&lt;/code&gt; идентифицирует экземпляр CTH однозначно. Если два CTH возвращают один и тот же &lt;code&gt;Id&lt;/code&gt; , второй CTH игнорируется, и последующие вызовы CTH выполняются только первому экземпляру. Подробности см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="c260809e9afd9c349ba39adc0e706099bd4227f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InclNodes&lt;/code&gt; argument to &lt;code&gt;run/3&lt;/code&gt; is a list of node names. Function &lt;code&gt;run/3&lt;/code&gt; runs the tests in &lt;code&gt;TestSpecs&lt;/code&gt; just like &lt;code&gt;run/1&lt;/code&gt;, but also takes any test in &lt;code&gt;TestSpecs&lt;/code&gt;, which is not explicitly tagged with a particular node name, and execute it on the nodes listed in &lt;code&gt;InclNodes&lt;/code&gt;. By using &lt;code&gt;run/3&lt;/code&gt; this way, any test specification can be used, with or without node information, in a large-scale test environment.</source>
          <target state="translated">&lt;code&gt;InclNodes&lt;/code&gt; аргумент &lt;code&gt;run/3&lt;/code&gt; представляет собой список имен узлов. Функция &lt;code&gt;run/3&lt;/code&gt; запускает тесты в &lt;code&gt;TestSpecs&lt;/code&gt; точно так же, как &lt;code&gt;run/1&lt;/code&gt; , но также принимает любой тест в &lt;code&gt;TestSpecs&lt;/code&gt; , который явно не помечен конкретным именем узла, и выполняет его на узлах, перечисленных в &lt;code&gt;InclNodes&lt;/code&gt; . Используя &lt;code&gt;run/3&lt;/code&gt; таким образом, можно использовать любую тестовую спецификацию, с информацией об узле или без нее, в крупномасштабной тестовой среде.</target>
        </trans-unit>
        <trans-unit id="728f2fde5e1be51dec6dbadf7fd8bb23ae8a8436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InfoTuple&lt;/code&gt;s with the following items are part of the result:</source>
          <target state="translated">&lt;code&gt;InfoTuple&lt;/code&gt; ы со следующими пунктами являются частью результата:</target>
        </trans-unit>
        <trans-unit id="18a616360c14e89869b3ee8a191e8982efcb7c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InitFun&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The returned &lt;code&gt;CryptoState&lt;/code&gt; is then folded into repeated applications of the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The binary returned from those funs are sent further to the remote SFTP server. Finally, if doing encryption, the &lt;code&gt;CloseFun&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;CloseFun&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="translated">&lt;code&gt;InitFun&lt;/code&gt; применяется один раз перед любой другой &lt;code&gt;crypto&lt;/code&gt; операции. Возвращается &lt;code&gt;CryptoState&lt;/code&gt; затем складывают в повторных применений &lt;code&gt;EncryptFun&lt;/code&gt; или &lt;code&gt;DecryptFun&lt;/code&gt; . Бинарный файл, возвращаемый этими развлечениями, отправляется дальше на удаленный сервер SFTP. Наконец, при шифровании &lt;code&gt;CloseFun&lt;/code&gt; применяется к последней части данных. &lt;code&gt;CloseFun&lt;/code&gt; отвечает за заполнение ( в случае необходимости) и шифрование этой последней части.</target>
        </trans-unit>
        <trans-unit id="f831068a66059cf58bd10807a62c5026adc8c387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">Сценарий &lt;code&gt;Install&lt;/code&gt; настоящее время должен запускаться в каталоге, в котором он находится (верхний каталог), следующим образом:</target>
        </trans-unit>
        <trans-unit id="151c25d0c87229840b1a357c4265bc6b194406ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script used when installing Erlang/OTP requires common Unix tools such as &lt;code&gt;sed&lt;/code&gt; to be present in your &lt;code&gt;$PATH&lt;/code&gt;. If your target system does not have such tools, you need to run the &lt;code&gt;Install&lt;/code&gt; script on your build machine before packaging Erlang/OTP. The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">&lt;code&gt;Install&lt;/code&gt; скрипт , используемый при установке Erlang / OTP требует общих инструментов Unix , таких как &lt;code&gt;sed&lt;/code&gt; , чтобы присутствовать в вашем &lt;code&gt;$PATH&lt;/code&gt; . Если в вашей целевой системе нет таких инструментов, вам необходимо запустить сценарий &lt;code&gt;Install&lt;/code&gt; на вашем компьютере сборки перед упаковкой Erlang / OTP. Сценарий &lt;code&gt;Install&lt;/code&gt; настоящее время должен запускаться в каталоге, в котором он находится (верхний каталог), следующим образом:</target>
        </trans-unit>
        <trans-unit id="63ceadf10aefd8db61da0846c16f50dd4c57bf68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Issuer&lt;/code&gt; argument contains the issuer name of the certificate to be checked. Normally the returned CRL should be issued by this issuer, except if the &lt;code&gt;cRLIssuer&lt;/code&gt; field of &lt;code&gt;DistributionPoint&lt;/code&gt; has a value, in which case that value should be used instead.</source>
          <target state="translated">&lt;code&gt;Issuer&lt;/code&gt; аргумент содержит имя эмитента сертификата для проверки. Обычно возвращенный CRL должен быть выпущен этим &lt;code&gt;cRLIssuer&lt;/code&gt; , за исключением случаев, когда поле cRLIssuer в &lt;code&gt;DistributionPoint&lt;/code&gt; имеет значение, и в этом случае это значение должно использоваться вместо этого.</target>
        </trans-unit>
        <trans-unit id="1df86fa6a13d4782f56f4b70368193619f74ccce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JCL&lt;/code&gt; commands have the following meaning:</source>
          <target state="translated">В &lt;code&gt;JCL&lt;/code&gt; команда имеет следующий смысл:</target>
        </trans-unit>
        <trans-unit id="eb0d6b265bbd8a2ede63c784c4e76e0b9b25a09c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; setting are to be consistent with what the terminal is capable of. There is no portable way for Erlang to ask the terminal about its UTF-8 capacity, we have to rely on the language and character type settings.</source>
          <target state="translated">Настройка &lt;code&gt;LANG&lt;/code&gt; или &lt;code&gt;LC_CTYPE&lt;/code&gt; должна соответствовать возможностям терминала. У Erlang нет переносимого способа запросить терминал о его возможностях UTF-8, мы должны полагаться на настройки языка и типа символов.</target>
        </trans-unit>
        <trans-unit id="6dcd5eb8b8d30040b44118c19bb40f40ac2fd675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lin&lt;/code&gt; (&lt;code&gt;LLin&lt;/code&gt;, &lt;code&gt;XLin&lt;/code&gt;) operator assigns the lines where calls (local calls, external calls) are made. The &lt;code&gt;ELin&lt;/code&gt; operator assigns to each call (From, To), for which it is defined, every line L such that there is a chain of calls from From to To beginning with a call on line L.</source>
          <target state="translated">Оператор &lt;code&gt;Lin&lt;/code&gt; ( &lt;code&gt;LLin&lt;/code&gt; , &lt;code&gt;XLin&lt;/code&gt; ) назначает линии , по которым выполняются вызовы (местные вызовы, внешние вызовы). Оператор &lt;code&gt;ELin&lt;/code&gt; назначает каждому вызову (From, To), для которого он определен, каждую строку L, такую ​​что существует цепочка вызовов от From до To, начинающаяся с вызова в строке L.</target>
        </trans-unit>
        <trans-unit id="ddd6ecd801eba0297210dd779a386d2f9b34f307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ListOfExtraArguments&lt;/code&gt; can be used to write generic functions. This list is appended to the standard arguments for each function. Consider two read-only variables for a device, &lt;code&gt;ipAdr&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; with object identifiers 1.1.23.4 and 1.1.7 respectively. To access these variables, one could implement the two Erlang functions &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt;, which will be in the MIB. The functions could be specified in a text file as follows:</source>
          <target state="translated">В &lt;code&gt;ListOfExtraArguments&lt;/code&gt; может быть использован для написания обобщенных функций. Этот список добавляется к стандартным аргументам каждой функции. Рассмотрим две переменные только для чтения для устройства, &lt;code&gt;ipAdr&lt;/code&gt; и &lt;code&gt;name&lt;/code&gt; с идентификаторами объектов 1.1.23.4 и 1.1.7 соответственно. Для доступа к этим переменным можно реализовать две функции Erlang &lt;code&gt;ip_access&lt;/code&gt; и &lt;code&gt;name_access&lt;/code&gt; , которые будут в MIB. Функции могут быть указаны в текстовом файле следующим образом:</target>
        </trans-unit>
        <trans-unit id="e1503197789ab51916ae2782b9a6115c1230e790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; argument will be the same as the &lt;code&gt;Listen&lt;/code&gt; handle part of the return value of the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback above. &lt;code&gt;accept/1&lt;/code&gt; is called only once when the distribution protocol is started.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; аргумент будет такой же , как &lt;code&gt;Listen&lt;/code&gt; ручки часть возвращаемого значения &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; обратного вызова выше. &lt;code&gt;accept/1&lt;/code&gt; вызывается только один раз при запуске протокола распространения.</target>
        </trans-unit>
        <trans-unit id="431a15a498450f82a9cfae588ffa70427314b380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoadOrder&lt;/code&gt; priority is by default &lt;code&gt;0&lt;/code&gt; (zero) but can be set to any integer. The tables with the highest &lt;code&gt;LoadOrder&lt;/code&gt; priority are loaded first at startup.</source>
          <target state="translated">&lt;code&gt;LoadOrder&lt;/code&gt; приоритет по умолчанию &lt;code&gt;0&lt;/code&gt; (ноль) , но может быть установлен на любое целое число. Таблицы с наивысшим приоритетом &lt;code&gt;LoadOrder&lt;/code&gt; загружаются первыми при запуске.</target>
        </trans-unit>
        <trans-unit id="c0d1ccb772696ffcb0ff02e3e38d3edd067a8070" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Low&lt;/code&gt; limit is automatically adjusted to the same as &lt;code&gt;High&lt;/code&gt; if it is set larger then &lt;code&gt;High&lt;/code&gt;. Valid range of values for &lt;code&gt;Low&lt;/code&gt; and &lt;code&gt;High&lt;/code&gt; is &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt;. If the atom &lt;code&gt;disabled&lt;/code&gt; is passed, the port message queue will never enter the busy state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca11762016f06296699f63500e41a8f8017d459" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Low&lt;/code&gt; limit is automatically adjusted to the same as &lt;code&gt;High&lt;/code&gt; if it is set larger then &lt;code&gt;High&lt;/code&gt;. Valid range of values for &lt;code&gt;Low&lt;/code&gt; and &lt;code&gt;High&lt;/code&gt; is &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt;. If the atom &lt;code&gt;disabled&lt;/code&gt; is passed, the port will never enter the busy state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca1036527f7b7c9ab7ab8a36cae20db5fe67ec0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; configuration was as follows:</source>
          <target state="translated">&lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; , конфигурация была следующим образом :</target>
        </trans-unit>
        <trans-unit id="d517f2a191b0a2929a426e74c5d9977a2a92791e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MIB.Object&lt;/code&gt; syntax is not implemented (since all objects must be unique anyway).</source>
          <target state="translated">&lt;code&gt;MIB.Object&lt;/code&gt; синтаксис не реализован (так как все объекты должны быть уникальными в любом случае).</target>
        </trans-unit>
        <trans-unit id="431d9a802a4fe9bcef002e403293ba1753c616e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mac&lt;/code&gt; result will have a default length depending on the &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SubType&lt;/code&gt;. To set a shorter length, use &lt;code&gt;&lt;a href=&quot;#macN-4&quot;&gt;macN/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#macN-5&quot;&gt;macN/5&lt;/a&gt;&lt;/code&gt; instead. The default length is documented in &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5dc880ea5414559476926c86f0abfef7e6942b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; for building the emulator currently defines the following symbols by using the &lt;code&gt;-D&lt;/code&gt; option on the command line for &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636dca28dbd87863b36f206b257464a2e654c483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Max Carrier size&lt;/code&gt; column shows the maximum value seen by observer since the last node change or since the start of the application, i.e. switching nodes will reset the max column. Values are sampled so higher values may have existed than what is shown.</source>
          <target state="translated">В &lt;code&gt;Max Carrier size&lt;/code&gt; показывает столбец значение максимального видно наблюдателем , так как изменения последнего узла или с момента запуска приложения, то есть узлы коммутации будут сброшены максимальный столбец. Значения отбираются, поэтому могли существовать более высокие значения, чем показано.</target>
        </trans-unit>
        <trans-unit id="cc6e05d560929a4a9cfa001cecdf62f1726f815c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; programmer cannot prioritize one particular transaction to execute before other transactions that are waiting to execute. As a result, the &lt;code&gt;Mnesia&lt;/code&gt; DBMS transaction system is not suitable for hard real-time applications. However, &lt;code&gt;Mnesia&lt;/code&gt; contains other features that have real-time properties.</source>
          <target state="translated">Программист &lt;code&gt;Mnesia&lt;/code&gt; не может назначить приоритет одной конкретной транзакции для выполнения перед другими транзакциями, ожидающими выполнения. В результате система транзакций СУБД &lt;code&gt;Mnesia&lt;/code&gt; не подходит для приложений жесткого реального времени. Однако &lt;code&gt;Mnesia&lt;/code&gt; содержит другие функции, которые имеют свойства в реальном времени.</target>
        </trans-unit>
        <trans-unit id="2398df613eed0972c6702e33c30169f57db4a6c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; record identifiers (&lt;code&gt;{Tab, Key}&lt;/code&gt;) can also be used as references. In this case, attribute &lt;code&gt;dept&lt;/code&gt; would be set to value &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; instead of &lt;code&gt;'B/SFR'&lt;/code&gt;.</source>
          <target state="translated">Идентификаторы записей &lt;code&gt;Mnesia&lt;/code&gt; ( &lt;code&gt;{Tab, Key}&lt;/code&gt; ) также могут использоваться в качестве ссылок. В этом случае для атрибута &lt;code&gt;dept&lt;/code&gt; будет установлено значение &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; вместо &lt;code&gt;'B/SFR'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90246ca10a3686ec4547ee9155bf07c76827f547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transaction system facilitates the construction of reliable, distributed systems by providing the following important properties:</source>
          <target state="translated">Система транзакций &lt;code&gt;Mnesia&lt;/code&gt; облегчает построение надежных распределенных систем, обеспечивая следующие важные свойства:</target>
        </trans-unit>
        <trans-unit id="05c05e9d6716d8728951521a8360d9cad3bf485c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transactions have four important properties, called &lt;strong&gt;A&lt;/strong&gt;tomicity, &lt;strong&gt;C&lt;/strong&gt;onsistency, &lt;strong&gt;I&lt;/strong&gt;solation, and &lt;strong&gt;D&lt;/strong&gt;urability (ACID). These properties are described in the following sections.</source>
          <target state="translated">В &lt;code&gt;Mnesia&lt;/code&gt; сделки имеют четыре важных свойства, называется tomicity, &lt;strong&gt;С&lt;/strong&gt; onsistency, &lt;strong&gt;я&lt;/strong&gt; solation и &lt;strong&gt;D&lt;/strong&gt; urability (КИСЛОТА). Эти свойства описаны в следующих разделах.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34969f65d94bd140bef4861a2be0633f1edd4059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Module:callback_mode()&lt;/code&gt; function may also return a list containing the callback mode and the atom &lt;code&gt;state_enter&lt;/code&gt; in which case &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; are activated for the callback mode.</source>
          <target state="translated">Функция &lt;code&gt;Module:callback_mode()&lt;/code&gt; также может возвращать список, содержащий режим обратного вызова и атом &lt;code&gt;state_enter&lt;/code&gt; , в этом случае &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; активируются для режима обратного вызова.</target>
        </trans-unit>
        <trans-unit id="40a0e269f3ccc50144dceff290b7ec1e5d3d30c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">&lt;code&gt;Msg&lt;/code&gt; либо двоичные данные &amp;laquo;обычный текст&amp;raquo; или это Хешированное значение &amp;laquo;обычного текста&amp;raquo;, то есть, переваривать.</target>
        </trans-unit>
        <trans-unit id="aa7575828f011f723e11b39b2169db4b9db4b1aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data to be signed or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">&lt;code&gt;Msg&lt;/code&gt; либо двоичные &amp;laquo;обычный текст&amp;raquo; данные должны быть подписаны или это Хешированное значение &amp;laquo;обычного текста&amp;raquo;, то есть, переваривать.</target>
        </trans-unit>
        <trans-unit id="caed8c29d6ad9904a92815ee1e45441de9aec981" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; parameters have exactly the same meaning as when calling the plain function &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;Name&lt;/code&gt; и &lt;code&gt;Path&lt;/code&gt; имеют то же значение, что и при вызове простой функции &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27916491cb8658a94525ccdce76cf8ccb4103b9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; field is the first element of the tuple.</source>
          <target state="translated">Поле &lt;code&gt;Name&lt;/code&gt; - это первый элемент кортежа.</target>
        </trans-unit>
        <trans-unit id="771b9f2fcc80d7e7468afb27c626f330320484ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; is &lt;code&gt;&quot;sftp&quot;&lt;/code&gt; and &lt;code&gt;CbMod&lt;/code&gt; is the name of the Erlang module implementing the subsystem using the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca819160319b409a2f4c421438e5784e6c81c13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; specified is to correspond to the filename of the dynamically loadable object file residing in the directory specified as &lt;code&gt;Path&lt;/code&gt;, but &lt;strong&gt;without&lt;/strong&gt; the extension (that is, &lt;code&gt;.so&lt;/code&gt;). The driver name provided in the driver initialization routine must correspond with the filename, in much the same way as Erlang module names correspond to the names of the &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">Указанное &lt;code&gt;Name&lt;/code&gt; должно соответствовать имени файла динамически загружаемого объектного файла, находящегося в каталоге, указанном как &lt;code&gt;Path&lt;/code&gt; , но &lt;strong&gt;без&lt;/strong&gt; расширения (то есть &lt;code&gt;.so&lt;/code&gt; ). Имя драйвера, указанное в процедуре инициализации драйвера, должно соответствовать имени файла, во многом так же, как имена модулей Erlang соответствуют именам файлов &lt;code&gt;.beam&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8577668ea7b4d3a7d25c6ddf13c9da38e01e030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NegotiationTimeout&lt;/code&gt; is in milli-seconds. The default value is &lt;code&gt;infinity&lt;/code&gt;. For connection timeout, use the option &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NegotiationTimeout&lt;/code&gt; в милли-секунд. Значение по умолчанию - &lt;code&gt;infinity&lt;/code&gt; . Для тайм-аута подключения используйте опцию &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25cf803e685b877b848b6e92d88b9c3e6c3210a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is an important type and it is widely used within different standards to identify various objects uniquely. Dubuisson: ASN.1 - Communication Between Heterogeneous Systems includes an easy-to-understand description of the use of &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; является важным типом и он широко используется в различных стандартах для идентификации различных объектов однозначно. Dubuisson: ASN.1 - Связь между гетерогенными системами включает простое для понимания описание использования &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d89a49f90db529d1a87ec8ebe643fd609dd3d3b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; value is simply a tuple with the consecutive values, which must be integers.</source>
          <target state="translated">Значение &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; - это просто кортеж с последовательными значениями, которые должны быть целыми числами.</target>
        </trans-unit>
        <trans-unit id="a30b8da746d4069e2cdb144e9b76560cd1897c56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Old API&lt;/code&gt; is now deprecated and has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07c15aa636f0544d2756cdbf51bdac039857354" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Old API&lt;/code&gt; will be removed as of OTP 24. The support was formally deprecated as of OTP 23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291813bf4581fd45b017cff8a605850835e5740d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; может быть &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; или &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0de93bd973f344208a44803393d2336ed72a592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; может быть &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;undo&lt;/code&gt; или &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dd3e602f768fecc29440b2334d159be22f01871" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; argument is intended for &quot;other&quot; options. The supported option(s) are described below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98288c1e55f84bdd812985a5fd086264e78ad4f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; argument is intended for providing extra information for the open call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c435f50eeeff168b9ba4f24d7c44a547a62546d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; when only the &lt;code&gt;Module&lt;/code&gt; is specified.</source>
          <target state="translated">По умолчанию &lt;code&gt;Opts&lt;/code&gt; имеет значение &lt;code&gt;[]&lt;/code&gt; , если указан только &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb29cec4d8746b25b30ed76f21784b67fd7d4bbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Phone&lt;/code&gt; field is the third element.</source>
          <target state="translated">Поле &quot; &lt;code&gt;Phone&lt;/code&gt; - третий элемент.</target>
        </trans-unit>
        <trans-unit id="9a36c74c23cadea74c3943787187639b86600b99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pid&lt;/code&gt; is the process handling the supervision of the SNMP manager start. When the manager has started a completion message will be sent to the client from this process: &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt;. If the SNMP manager was not started in time, a timeout message will be sent to the client: &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; процесс обработки контроля старта менеджера SNMP. Когда менеджер запустит, клиенту будет отправлено сообщение о завершении этого процесса: &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt; . Если диспетчер SNMP не был запущен вовремя, клиенту будет отправлено сообщение о тайм-ауте: &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b30293a63b2a3b26c593085f1e5a77514ed0092c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PingTO&lt;/code&gt; time specifies the between a successful ping (or start) and the time when a &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; message is to be sent to the net-if process (basically the time between ping:s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523184d1586b2a64475008cf790d421779a2a4e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PongTO&lt;/code&gt; time specifies how long time the net-if process has to respond to a ping message, with a &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message. It starts counting when the ping message has been sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad1ec7b826ce17efed8a480d14fb2c2d7c83c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ProtocolVersion&lt;/code&gt; version is the version actually encoded in the reply message.</source>
          <target state="translated">Версия &lt;code&gt;ProtocolVersion&lt;/code&gt; - это версия, фактически закодированная в ответном сообщении.</target>
        </trans-unit>
        <trans-unit id="cc15bf57b674de665a3aa4e09be58f12e93f6528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RELATIVE-OID&lt;/code&gt; type for relative object identifiers is fully supported.</source>
          <target state="translated">Тип &lt;code&gt;RELATIVE-OID&lt;/code&gt; для относительных идентификаторов объектов полностью поддерживается.</target>
        </trans-unit>
        <trans-unit id="500392beab058916677f3be61233265c489d27bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; parameter in the &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; user callback function.</source>
          <target state="translated">Параметр &lt;code&gt;Reason&lt;/code&gt; в функции обратного вызова пользователя &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b9fce90dd7e0310098f64ad13d29f2262c2551d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; returned value if any of the sync/async get/get-next/set/get-bulk functions returns &lt;code&gt;{error, Reason}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; возвращаемого значения , если какая - либо из синхронных / асинхронной Get / Get-Next / комплект / Get-сыпучая функция возвращает &lt;code&gt;{error, Reason}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1adaa6337c0136bccefb9d645f47ac7a3dea29f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReplyData&lt;/code&gt; defaults to &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt;, but may be explicitly overridden by a &lt;code&gt;megaco:cast/3&lt;/code&gt; option in order to forward info about the calling context of the originating process.</source>
          <target state="translated">В &lt;code&gt;ReplyData&lt;/code&gt; по умолчанию &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt; , но может быть явно переопределен &lt;code&gt;megaco:cast/3&lt;/code&gt; вариант для того , чтобы вперед информации о контексте вызывающего процесса инициирующей.</target>
        </trans-unit>
        <trans-unit id="5dcd8c369c6500e932ff1e1629f6fafbdc39108e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-Line&lt;/code&gt; as defined in&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Request-Line&lt;/code&gt; , как определено в &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; , например, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb08315668e2b40765d2d6e12af7abf8e890149a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-Line&lt;/code&gt; as defined in&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560f996f8e0b32b35d673e574bfba7c7f5732599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-URI&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Request-URI&lt;/code&gt; , как определено в &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; , например, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b8d48f9166b31382467a83cabd23a76e7475016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-URI&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09cc862e08384f6496c068b1ef00d8543bcd2fea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request&lt;/code&gt; element can in itself contain many &lt;code&gt;Request&lt;/code&gt;s by using the following format:</source>
          <target state="translated">Элемент &lt;code&gt;Request&lt;/code&gt; может сам по себе содержать множество &lt;code&gt;Request&lt;/code&gt; , используя следующий формат:</target>
        </trans-unit>
        <trans-unit id="df3736ae6d527f6dc758c7bc44a6f372a5715a61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Root directory&lt;/code&gt; can be edited by selecting the line where the path of the root directory is displayed and clicking the right mouse button. Choose edit in the menu that pops up.</source>
          <target state="translated">&lt;code&gt;Root directory&lt;/code&gt; можно изменить, выбрав строку , в которой отображается путь корневого каталога и нажав правую кнопку мыши. Выберите редактировать во всплывающем меню.</target>
        </trans-unit>
        <trans-unit id="84770d839ef4e410e85af06b8af1e00bd08e41e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RowIndex&lt;/code&gt; argument may refer to an existing row or a non-existing row, or it may be unspecified. The &lt;code&gt;Cols&lt;/code&gt; list may refer to inaccessible columns or non-existing columns. For each column in the &lt;code&gt;Cols&lt;/code&gt; list, the corresponding next instance is determined, and the last part of its OBJECT IDENTIFIER and its value is returned.</source>
          <target state="translated">&lt;code&gt;RowIndex&lt;/code&gt; аргумент может относиться к существующей строке или пассивной существующей строке, или это может быть не определенно. Список &lt;code&gt;Cols&lt;/code&gt; может относиться к недоступным или несуществующим столбцам. Для каждого столбца в списке &lt;code&gt;Cols&lt;/code&gt; определяется соответствующий следующий экземпляр, и возвращается последняя часть его OBJECT IDENTIFIER и его значение.</target>
        </trans-unit>
        <trans-unit id="b8d86bbb9ebe74c2dccf692588c950366f9986be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SecurityCallbackModule&lt;/code&gt; is a user-written module that can receive events from the &lt;code&gt;mod_security&lt;/code&gt; Erlang web server API module. This module only exports the functions event/[4,5] which are described here.</source>
          <target state="translated">&lt;code&gt;SecurityCallbackModule&lt;/code&gt; является написанный пользователем модуль , который может получать события от &lt;code&gt;mod_security&lt;/code&gt; модуля API веб - сервера Erlang. Этот модуль экспортирует только функции event / [4,5], которые описаны здесь.</target>
        </trans-unit>
        <trans-unit id="6af65a9600faa054b3af4ac9bf04b32c2eda0702" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SeqCnt&lt;/code&gt; values in the filenames are all in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;WrapCnt&lt;/code&gt; with a gap in the circular sequence. The gap is needed to find the end of the trace.</source>
          <target state="translated">Все значения &lt;code&gt;SeqCnt&lt;/code&gt; в именах файлов находятся в диапазоне от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;WrapCnt&lt;/code&gt; с пробелом в круговой последовательности. Пробел нужен, чтобы найти конец следа.</target>
        </trans-unit>
        <trans-unit id="c2214d4ed634c1087714e34b7518b2efdc6127b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; or the &lt;code&gt;TypeSpecifier&lt;/code&gt;, or both, can be omitted. Thus, the following variants are allowed:</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; или &lt;code&gt;TypeSpecifier&lt;/code&gt; , или оба, может быть опущен. Таким образом, допустимы следующие варианты:</target>
        </trans-unit>
        <trans-unit id="4401af203194a6b8a2b7ece91e21c535b2bfb4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; part of the segment multiplied by the unit in &lt;code&gt;TypeSpecifierList&lt;/code&gt; (described later) gives the number of bits for the segment. In construction, &lt;code&gt;Size&lt;/code&gt; is any expression that evaluates to an integer. In matching, &lt;code&gt;Size&lt;/code&gt; must be a constant expression or a variable.</source>
          <target state="translated">Часть &lt;code&gt;Size&lt;/code&gt; сегмента, умноженная на единицу в &lt;code&gt;TypeSpecifierList&lt;/code&gt; (описанном ниже), дает количество битов для сегмента. При построении &lt;code&gt;Size&lt;/code&gt; - это любое выражение, которое принимает целое число. При сопоставлении &lt;code&gt;Size&lt;/code&gt; должен быть постоянным выражением или переменной.</target>
        </trans-unit>
        <trans-unit id="fa124ccd13ea8b5e4811fb40dda4e89bf8e0ab6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Socket&lt;/code&gt; shall be in passive mode ({active, false}) before calling this function or else the behavior of this function is undefined.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; должно быть в пассивном режиме ({активен, ложной}) перед вызовом этой функции , или иначе поведение этой функции не определено.</target>
        </trans-unit>
        <trans-unit id="71d2c0146fa0a8ad0d23a9f16dafb29d093033b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State0&lt;/code&gt; is the State value originally from a MAC init function, that is &lt;code&gt;&lt;a href=&quot;#mac_init-2&quot;&gt;mac_init/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#mac_init-3&quot;&gt;mac_init/3&lt;/a&gt;&lt;/code&gt; or a previous call of &lt;code&gt;mac_update/2&lt;/code&gt;. The value &lt;code&gt;State0&lt;/code&gt; is returned unchanged by the function as &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a112d3244fe07cff9e8f015a14975b38bd7df44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StatisticsSpec&lt;/code&gt; is a list of the tuples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eae7e5127eb1df08b89e0018b0917cb18f30c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SupFlags&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; represents the &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SupFlags&lt;/code&gt; переменного возвращаемого значения &lt;code&gt;init/1&lt;/code&gt; представляет &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b2315a984f49c0998e8d5af6001ef3acd45c41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TEST&lt;/code&gt; macro can also be used to override the &lt;code&gt;NOTEST&lt;/code&gt; macro. If &lt;code&gt;TEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included (even if &lt;code&gt;NOTEST&lt;/code&gt; is also defined), then the code will be compiled with EUnit enabled.</source>
          <target state="translated">&lt;code&gt;TEST&lt;/code&gt; макросъемка также может быть использована , чтобы переопределить &lt;code&gt;NOTEST&lt;/code&gt; макрокоманды. Если &lt;code&gt;TEST&lt;/code&gt; определен &lt;strong&gt;до&lt;/strong&gt; включения файла заголовка EUnit (даже если &lt;code&gt;NOTEST&lt;/code&gt; также определен), то код будет скомпилирован с включенным EUnit.</target>
        </trans-unit>
        <trans-unit id="838665ed4c5367a2b5c2a4be4ad60949587a0665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module.</source>
          <target state="translated">&lt;code&gt;TarDescriptor&lt;/code&gt; термин не является дескриптор файла. Рекомендуется не полагаться на конкретное содержание этого термина, поскольку оно может измениться в будущих выпусках Erlang / OTP, когда в этот модуль будут добавлены дополнительные функции.</target>
        </trans-unit>
        <trans-unit id="465bc37c25caf4b34efb2c4086ab264294ebb922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module..</source>
          <target state="translated">&lt;code&gt;TarDescriptor&lt;/code&gt; термин не является дескриптор файла. Рекомендуется не полагаться на конкретное содержание этого термина, поскольку оно может измениться в будущих выпусках Erlang / OTP, когда в этот модуль будут добавлены дополнительные функции.</target>
        </trans-unit>
        <trans-unit id="0454f0125983aa193be8922f905a4526ad0af9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; is the time the request is valid. The value has to be greater then zero.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; время запроса является действительным. Значение должно быть больше нуля.</target>
        </trans-unit>
        <trans-unit id="7d17ac7ee8e9756a5bbf3de834214c031df9a61a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; parameter is for the actual tls upgrade (phase 2) while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for the initial negotiation about upgrade (phase 1).</source>
          <target state="translated">Параметр &lt;code&gt;Timeout&lt;/code&gt; предназначен для фактического обновления tls (фаза 2), в то время как время ожидания в &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; используется для первоначального согласования обновления (фаза 1).</target>
        </trans-unit>
        <trans-unit id="2880ac4f009b868dac04469b39959fc855b2bc2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; value in milliseconds sets an upper time limit for all &lt;code&gt;call&lt;/code&gt; operations to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e76487200ab118ffd183bce3e76d073d0b42eca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Trace Pattern&lt;/code&gt; is basically a tuple of a &lt;code&gt;module&lt;/code&gt; and a &lt;code&gt;detail level&lt;/code&gt; (either an integer or the atom max for full detail). In most cases the &lt;code&gt;Trace Pattern&lt;/code&gt;&lt;code&gt;{et,max}&lt;/code&gt; does suffice. But if you do not want any runtime dependency of &lt;code&gt;et&lt;/code&gt; you can implement your own &lt;code&gt;trace_me/5&lt;/code&gt; function in some module and refer to that module in the &lt;code&gt;Trace Pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Trace Pattern&lt;/code&gt; в основном кортеж из &lt;code&gt;module&lt;/code&gt; и &lt;code&gt;detail level&lt;/code&gt; (целое число или атом макс для полной детализации). В большинстве случаев достаточно &lt;code&gt;Trace Pattern&lt;/code&gt; &lt;code&gt;{et,max}&lt;/code&gt; . Но если вам не нужна какая-либо зависимость от &lt;code&gt;et&lt;/code&gt; во время выполнения, вы можете реализовать свою собственную &lt;code&gt;trace_me/5&lt;/code&gt; в каком-либо модуле и ссылаться на этот модуль в шаблоне &lt;code&gt;Trace Pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7f49e5bd7c0b07a911f5147dffd68a5a99e4dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceStartOption&lt;/code&gt; is any option allowed for &lt;code&gt;trace/1&lt;/code&gt;. The options &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; are given to &lt;code&gt;trace/1&lt;/code&gt;, where &lt;code&gt;OptList&lt;/code&gt; is &lt;code&gt;OptionList&lt;/code&gt; with &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;{procs, _}&lt;/code&gt; options removed.</source>
          <target state="translated">&lt;code&gt;TraceStartOption&lt;/code&gt; является любой вариант допускается для &lt;code&gt;trace/1&lt;/code&gt; . Опции &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; передаются для &lt;code&gt;trace/1&lt;/code&gt; , где &lt;code&gt;OptList&lt;/code&gt; - это &lt;code&gt;OptionList&lt;/code&gt; с удаленными параметрами &lt;code&gt;continue&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;{procs, _}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2aed641ea18d80129eeabfddfeb6dc4dea97713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceTag&lt;/code&gt;&lt;code&gt;seq_trace&lt;/code&gt; is handled slightly differently. There is no &lt;code&gt;Tracee&lt;/code&gt; for &lt;code&gt;seq_trace&lt;/code&gt;, instead the &lt;code&gt;Label&lt;/code&gt; associated with the &lt;code&gt;seq_trace&lt;/code&gt; event is specified.</source>
          <target state="translated">&lt;code&gt;TraceTag&lt;/code&gt; &lt;code&gt;seq_trace&lt;/code&gt; обрабатывается немного по- другому. Там нет &lt;code&gt;Tracee&lt;/code&gt; для &lt;code&gt;seq_trace&lt;/code&gt; , вместо этого &lt;code&gt;Label&lt;/code&gt; связана с &lt;code&gt;seq_trace&lt;/code&gt; события указывается.</target>
        </trans-unit>
        <trans-unit id="0e7aee8b9587689f8640e087123cb9269b76c67d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TypeSpecifierList&lt;/code&gt; is a list of type specifiers separated by hyphens.</source>
          <target state="translated">&lt;code&gt;TypeSpecifierList&lt;/code&gt; список спецификаторов типа , разделенных дефисом.</target>
        </trans-unit>
        <trans-unit id="cf30b67e2b9d6eefe96e2a44b56b701c3a71843b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Value&lt;/code&gt; part is any expression, when used in binary construction. Used in binary matching, the &lt;code&gt;Value&lt;/code&gt; part must be a literal or a variable. For more information about the &lt;code&gt;Value&lt;/code&gt; part, see &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Часть &lt;code&gt;Value&lt;/code&gt; - это любое выражение при использовании в двоичной конструкции. Используемая при двоичном сопоставлении часть &lt;code&gt;Value&lt;/code&gt; должна быть литералом или переменной. Дополнительные сведения о части &lt;code&gt;Value&lt;/code&gt; см. &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; и битовых строк и &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt; двоичных файлов&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="db41e1083994609150ba03a58467ce1564f93559" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will automatically pull events from the &lt;code&gt;Collector&lt;/code&gt; and display them on the screen.</source>
          <target state="translated">Средство &lt;code&gt;Viewer&lt;/code&gt; автоматически извлекает события из &lt;code&gt;Collector&lt;/code&gt; и отображает их на экране.</target>
        </trans-unit>
        <trans-unit id="8afb3e18be8e7e2fb56c7adc4a8999ad88a05635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will by default create a &lt;code&gt;Collector&lt;/code&gt; for you. With a few options and some configuration settings you can start collecting &lt;code&gt;Events&lt;/code&gt;.</source>
          <target state="translated">Средство &lt;code&gt;Viewer&lt;/code&gt; по умолчанию создаст для вас &lt;code&gt;Collector&lt;/code&gt; . С помощью нескольких опций и некоторых настроек конфигурации вы можете начать сбор &lt;code&gt;Events&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12a1a53435b86d328cae136152477d1bdb078001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XXL&lt;/code&gt; operator is defined for the interpretation of any of the LineOp operators applied to a set of function calls. The result is that of replacing the function call with a line numbered function call, that is, each of the two functions of the call is replaced by a pair of the function and the line where the function is defined. The effect of the &lt;code&gt;XXL&lt;/code&gt; operator can be undone by the LineOp operators. For instance, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; is equivalent to &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;XXL&lt;/code&gt; определен для интерпретации любого из операторов LineOp, применяемых к набору вызовов функций. Результатом является замена вызова функции вызовом функции с пронумерованной строкой, то есть каждая из двух функций вызова заменяется парой функции и строкой, в которой функция определена. Действие оператора &lt;code&gt;XXL&lt;/code&gt; может быть отменено операторами LineOp. Так , например, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; эквивалентно &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773f8eacbf90d517d7610d94842c0bab01a3934c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ZipHandle&lt;/code&gt; is closed if the process that originally opened the archive dies.</source>
          <target state="translated">&lt;code&gt;ZipHandle&lt;/code&gt; закрыт , если процесс , который первоначально открыл архив плашки.</target>
        </trans-unit>
        <trans-unit id="557e22236c78cd7d079417146126bba5baaa6036" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[&amp;lt;&amp;lt;&quot;First bytes&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;Second bytes&quot;&amp;gt;&amp;gt;]&lt;/code&gt; could of course have been one single binary: &lt;code&gt;&amp;lt;&amp;lt;&quot;First bytesSecond bytes&quot;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a10f4396b335e787b9182ce75a8ccae749ae857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_test&lt;/code&gt; macro takes any expression (the &quot;body&quot;) as argument, and places it within a fun-expression (along with some extra information). The body can be any kind of test expression, just like the body of a simple test function.</source>
          <target state="translated">&lt;code&gt;_test&lt;/code&gt; макрос принимает любое выражение ( &amp;laquo;тело&amp;raquo;) в качестве аргумента, и помещает его в забавном-выражении (наряду с некоторой дополнительной информацией). Тело может быть любым видом тестового выражения, как и тело простой тестовой функции.</target>
        </trans-unit>
        <trans-unit id="21e2f2fedc48b32638d6fb2b72fe74559f091a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call does &lt;strong&gt;not&lt;/strong&gt; have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; вызов вовсе &lt;strong&gt;не&lt;/strong&gt; должен быть выдан из процесса владельца сокета. Используя эмулятор версии 5.5.3 и выше, несколько одновременных вызовов приема могут быть отправлены из разных процессов, что позволяет пулу процессов-приемников обрабатывать входящие соединения.</target>
        </trans-unit>
        <trans-unit id="118d34eb87604b965b95931c52d7927f1d1dca61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; arguments are both input and output arguments. When called &lt;code&gt;addr&lt;/code&gt; points to an address structure of lenght &lt;code&gt;*len&lt;/code&gt; containing information on how to bind the socket. Uppon return this callback should have updated the structure referred by &lt;code&gt;addr&lt;/code&gt; with information on how the socket actually was bound. &lt;code&gt;*len&lt;/code&gt; should be updated to reflect the size of &lt;code&gt;*addr&lt;/code&gt; updated. &lt;code&gt;backlog&lt;/code&gt; identifies the size of the backlog for the listen socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a0f81704a04cf2f958a3cb5b26d7a07f57fb43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; argument of the &lt;code&gt;listen&lt;/code&gt;, &lt;code&gt;accept&lt;/code&gt;, and &lt;code&gt;connect&lt;/code&gt; callbacks refer to appropriate address structure for currently used protocol. Currently &lt;code&gt;ei&lt;/code&gt; only supports IPv4. That is, at this time &lt;code&gt;addr&lt;/code&gt; always points to a &lt;code&gt;struct sockaddr_in&lt;/code&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97c48085c09e86337df00a4b0a18e9e9f983484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apread/4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">Функция &lt;code&gt;apread/4&lt;/code&gt; читает из указанной позиции, комбинируя функции &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e1ba830557bf0975fcfe18ee483f0f3bec5d278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apwrite/4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">Функция &lt;code&gt;apwrite/4&lt;/code&gt; записывает в указанную позицию, комбинируя функции &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00d3c3634428cbc77b5aceea9f983ec649758967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert&lt;/code&gt; macro can be used anywhere in a program, not just in unit tests, to check pre/postconditions and invariants. For example:</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; макрос может быть использован в любом месте программы, а не только в виде единичных тестов, чтобы проверить заранее / постусловия и инварианты. Например:</target>
        </trans-unit>
        <trans-unit id="108ceadd98496de12d8902f0058bac96f4aa9204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is passed to the &lt;code&gt;do_perm&lt;/code&gt; function. We do not use a &lt;code&gt;async_free&lt;/code&gt; function (the last argument to &lt;code&gt;driver_async&lt;/code&gt;), it is only used if the task is cancelled programmatically.</source>
          <target state="translated">&lt;code&gt;async_data&lt;/code&gt; передается &lt;code&gt;do_perm&lt;/code&gt; функции. Мы не используем функцию &lt;code&gt;async_free&lt;/code&gt; (последний аргумент для &lt;code&gt;driver_async&lt;/code&gt; ), она используется только в том случае, если задача отменяется программно.</target>
        </trans-unit>
        <trans-unit id="4cd04a38dd6fcdc2cd251ae665b899f10977e42f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is the argument to the functions &lt;code&gt;async_invoke&lt;/code&gt; and &lt;code&gt;async_free&lt;/code&gt;. It is typically a pointer to a structure containing a pipe or event that can be used to signal that the async operation completed. The data is to be freed in &lt;code&gt;async_free&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async_data&lt;/code&gt; является аргументом функций &lt;code&gt;async_invoke&lt;/code&gt; и &lt;code&gt;async_free&lt;/code&gt; . Обычно это указатель на структуру, содержащую канал или событие, которое можно использовать для сигнализации о завершении асинхронной операции. Данные должны быть освобождены в &lt;code&gt;async_free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10c62ebaa7dc721acc77acfe725a467db8e1f296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atom()&lt;/code&gt; value is formed from the sftp error codes in the protocol-level responses as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#page-49&quot;&gt;draft-ietf-secsh-filexfer-13&lt;/a&gt;&lt;/code&gt; section 9.1. The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c5f2724e8a89f933cb80bf3b2eb6cc8b3b6977" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;avg1/0&lt;/code&gt;, &lt;code&gt;avg5/0&lt;/code&gt;, and &lt;code&gt;avg15/0&lt;/code&gt; functions can be used for retrieving system load values, and the &lt;code&gt;util/0&lt;/code&gt; and &lt;code&gt;util/1&lt;/code&gt; functions can be used for retrieving CPU utilization values.</source>
          <target state="translated">Функции &lt;code&gt;avg1/0&lt;/code&gt; , &lt;code&gt;avg5/0&lt;/code&gt; и &lt;code&gt;avg15/0&lt;/code&gt; могут использоваться для получения значений загрузки системы, а функции &lt;code&gt;util/0&lt;/code&gt; и &lt;code&gt;util/1&lt;/code&gt; могут использоваться для получения значений использования ЦП.</target>
        </trans-unit>
        <trans-unit id="a43d2dcf5e0e967eda5efa53bd70665dc5d59efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blog()&lt;/code&gt; functions can also be used for internally formatted logs, but in this case they must be called with binaries constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;. There is no check to ensure this, it is entirely the responsibility of the caller. If these functions are called with binaries that do not correspond to Erlang terms, the &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; and automatic repair functions fail. The corresponding terms (not the binaries) are returned when &lt;code&gt;chunk/2,3&lt;/code&gt; is called.</source>
          <target state="translated">Функции &lt;code&gt;blog()&lt;/code&gt; также могут использоваться для журналов с внутренним форматированием, но в этом случае они должны вызываться с двоичными &lt;code&gt;term_to_binary/1&lt;/code&gt; с помощью вызовов term_to_binary / 1 . Нет никакой проверки, чтобы гарантировать это, это полностью ответственность вызывающего абонента. Если эти функции вызываются с двоичными файлами, которые не соответствуют условиям Erlang, функции &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; и автоматического восстановления не работают. Соответствующие термины (не двоичные файлы) возвращаются при вызове &lt;code&gt;chunk/2,3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6a9390501bbca6818af22e2d682ca803f60bdab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; operand can encode any literal value, including NIL. The &lt;code&gt;n&lt;/code&gt; operand only works for NIL. If we have the generic instruction &lt;code&gt;{move,nil,{x,1}}&lt;/code&gt;, the loader will translate it to &lt;code&gt;move_nx 1&lt;/code&gt; because &lt;code&gt;move n x&lt;/code&gt; is more specific. &lt;code&gt;move_nx&lt;/code&gt; could be slightly faster or smaller (depending on the architecture), because the &lt;code&gt;[]&lt;/code&gt; is not stored explicitly as an operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9287c794d6838f0d9c560c6cf16a390d870948c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call()&lt;/code&gt; function only returns if the applied function successfully returned without raising any uncaught exceptions, the operation did not time out, and no failures occurred. In all other cases an exception is raised. The following exceptions, listed by exception class, can currently be raised by &lt;code&gt;erpc:call()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725661331a506e2dce5360076476c39f4c67eeff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; operation for this specific node raised an exception of class &lt;code&gt;Class&lt;/code&gt; with exception reason &lt;code&gt;ExceptionReason&lt;/code&gt;. These corresponds the the exceptions that &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:call/5&lt;/a&gt;&lt;/code&gt; can raise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3190218027bddfcb10c66d83569c4e030fe8e281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; operation for this specific node returned &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c4b6b511dd79e662208e902c57d062a8c73aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call_ext&lt;/code&gt; instruction can be used to call functions written in Erlang as well as BIFs (or more properly called SNIFs). The &lt;code&gt;u$is_bif&lt;/code&gt; constraint will match if the operand refers to a BIF (that is, if it is listed in the file &lt;code&gt;bif.tab&lt;/code&gt;). Note that &lt;code&gt;u$is_bif&lt;/code&gt; should only be applied to operands that are known to contain an index to the import table chunk in the BEAM file (such operands have the type &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;e&lt;/code&gt; in the corresponding specific instruction). If applied to other &lt;code&gt;u&lt;/code&gt; operands, it will at best return a nonsense result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d74f76daa8e51f123951ddaf373680517fc012" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel_callback&lt;/code&gt; is the module that implements the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour in the daemon. See the section &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information and an example.</source>
          <target state="translated">&lt;code&gt;channel_callback&lt;/code&gt; является модулем , который реализует &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; поведения (заменяет ssh_daemon_channel) в демоне. См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; в Руководстве пользователя для получения дополнительной информации и примеров.</target>
        </trans-unit>
        <trans-unit id="b8493f2b264f76e709a289fe048f59895e05cdc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chmod&lt;/code&gt; above makes the &lt;code&gt;.erlang.cookie&lt;/code&gt; file accessible only by the owner of the file. This is a requirement.</source>
          <target state="translated">Приведенный выше &lt;code&gt;chmod&lt;/code&gt; делает файл &lt;code&gt;.erlang.cookie&lt;/code&gt; доступным только для владельца файла. Это требование.</target>
        </trans-unit>
        <trans-unit id="067ed8257f3ed48d1dd77d1c82e5f73c03791be2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;client_directory&lt;/code&gt; in the directory structure of the master nodes must be specified.</source>
          <target state="translated">Необходимо &lt;code&gt;client_directory&lt;/code&gt; в структуре каталогов главных узлов.</target>
        </trans-unit>
        <trans-unit id="97ad2677bec8a2ec1b2eaf275491aa26823e6cdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clients&lt;/code&gt; directory is to have one subdirectory per supported client node. The name of each client directory is to be the name of the corresponding client node. As a minimum, each client directory is to contain the &lt;code&gt;bin&lt;/code&gt; and &lt;code&gt;releases&lt;/code&gt; subdirectories. These directories are used to store information about installed releases and to appoint the current release to the client. The &lt;code&gt;$ROOT&lt;/code&gt; directory thus contains the following:</source>
          <target state="translated">В каталоге &lt;code&gt;clients&lt;/code&gt; должен быть один подкаталог на каждый поддерживаемый клиентский узел. Имя каждого клиентского каталога должно быть именем соответствующего клиентского узла. Как минимум, каждый каталог клиента должен содержать &lt;code&gt;bin&lt;/code&gt; и &lt;code&gt;releases&lt;/code&gt; подкаталоги. Эти каталоги используются для хранения информации об установленных выпусках и для назначения текущего выпуска клиенту. Таким образом, каталог &lt;code&gt;$ROOT&lt;/code&gt; содержит следующее:</target>
        </trans-unit>
        <trans-unit id="fef0ac1b98cce64ffd1d82b4509565a3e18b84ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code_change&lt;/code&gt; method must also be implemented.</source>
          <target state="translated">Также должен быть реализован метод &lt;code&gt;code_change&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfba9577e3cba70bb212c1548338d8d33c8f09a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combined&lt;/code&gt; format is one line looking like this: &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;combined&lt;/code&gt; формат одна строка вида: &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="630925a2786b7b59d8f4c833942afd22d020f670" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compatibility_only_hash()&lt;/code&gt; algorithms are recommended only for compatibility with existing applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b60f349fe6a82d8f3ab2d525a727ef964290939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process does the following:</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; процесс выполняет следующие действия :</target>
        </trans-unit>
        <trans-unit id="ceca332ed5fece3a22bbc2b65250bbdfb9575097" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process performs the following:</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; процесс выполняет следующее:</target>
        </trans-unit>
        <trans-unit id="0e88a24bce8d7b2a409cde6bc42dab540256c0b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compressed&lt;/code&gt; and &lt;code&gt;cooked&lt;/code&gt; flags are invalid when passing a file descriptor with &lt;code&gt;{file,Fd}&lt;/code&gt;. The file is assumed to have been opened with the appropriate flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45da19705e860c5554e30ca96214a35258f720dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compressed&lt;/code&gt; and &lt;code&gt;cooked&lt;/code&gt; flags are invalid when passing a file descriptor with &lt;code&gt;{file,Fd}&lt;/code&gt;. The file must already be opened with the appropriate flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3748b6dda37726d1886cb8a28dacde2fa7798fe9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; macro is defined in &lt;code&gt;ct.hrl&lt;/code&gt;. This macro is to be used to retrieve information from the &lt;code&gt;Config&lt;/code&gt; variable sent to all test cases. It is used with two arguments; the first is the name of the configuration variable to retrieve, the second is the &lt;code&gt;Config&lt;/code&gt; variable supplied to the test case.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; макрокоманда определена в &lt;code&gt;ct.hrl&lt;/code&gt; . Этот макрос должен использоваться для получения информации из переменной &lt;code&gt;Config&lt;/code&gt; , отправляемой всем тестовым примерам. Он используется с двумя аргументами; первая - это имя переменной конфигурации, которую нужно получить, вторая - это переменная &lt;code&gt;Config&lt;/code&gt; предоставленная для тестового примера.</target>
        </trans-unit>
        <trans-unit id="3402fd646c2b066512d58aeec8dd8cb2dfa256aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">Сценарий &lt;code&gt;configure&lt;/code&gt; выдаст предупреждение при использовании значения по умолчанию. Когда переменная установлена, предупреждение не выводится.</target>
        </trans-unit>
        <trans-unit id="6288c90b6c5e2f3d2b468cb02b51d6affc24bf92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; scripts are generated by invoking &lt;code&gt;./otp_build autoconf&lt;/code&gt; in the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. The &lt;code&gt;configure&lt;/code&gt; scripts also have to be regenerated when a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file has been modified. Note that when checking out a branch a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file may change content, and you may therefore have to regenerate the &lt;code&gt;configure&lt;/code&gt; scripts when checking out a branch. Regenerated &lt;code&gt;configure&lt;/code&gt; scripts imply that you have to run &lt;code&gt;configure&lt;/code&gt; and build again.</source>
          <target state="translated">В &lt;code&gt;configure&lt;/code&gt; скрипты генерируются вызовом &lt;code&gt;./otp_build autoconf&lt;/code&gt; в &lt;code&gt;$ERL_TOP&lt;/code&gt; каталоге. В &lt;code&gt;configure&lt;/code&gt; сценарии также должны быть восстановлены , когда &lt;code&gt;configure.in&lt;/code&gt; или &lt;code&gt;aclocal.m4&lt;/code&gt; файл был изменен. Обратите внимание, что при извлечении ветки файл &lt;code&gt;configure.in&lt;/code&gt; или &lt;code&gt;aclocal.m4&lt;/code&gt; может изменить содержимое, и поэтому вам может потребоваться повторно создать скрипты &lt;code&gt;configure&lt;/code&gt; при извлечении ветки. Повторно &lt;code&gt;configure&lt;/code&gt; сценарии настройки подразумевают, что вам нужно снова запустить &lt;code&gt;configure&lt;/code&gt; и сборку.</target>
        </trans-unit>
        <trans-unit id="208c163b5d9b18adfd658c53d3afa3ceb105c168" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; function looks a bit different too. We connect using the asynchronous &lt;code&gt;PQconnectStart&lt;/code&gt; function. After the connection is started, we retrieve the socket for the connection with &lt;code&gt;PQsocket&lt;/code&gt;. This socket is used with the &lt;code&gt;driver_select&lt;/code&gt; function to wait for connection. When the socket is ready for input or for output, the &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">Функция &lt;code&gt;connect&lt;/code&gt; тоже выглядит немного иначе. Подключаемся с помощью асинхронной функции &lt;code&gt;PQconnectStart&lt;/code&gt; . После того, как соединение запущено, мы получаем сокет для соединения с &lt;code&gt;PQsocket&lt;/code&gt; . Этот сокет используется с функцией &lt;code&gt;driver_select&lt;/code&gt; для ожидания соединения. Когда сокет готов к вводу или выводу, &lt;code&gt;ready_io&lt;/code&gt; функция ready_io .</target>
        </trans-unit>
        <trans-unit id="72241940e6969f3882cb2063d805e933d9f13162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;console&lt;/code&gt; option is &lt;strong&gt;not&lt;/strong&gt; intended for production. It is &lt;strong&gt;only&lt;/strong&gt; a convenient way to debug Erlang services during development.</source>
          <target state="translated">&lt;code&gt;console&lt;/code&gt; опция &lt;strong&gt;не&lt;/strong&gt; предназначена для производства. Это &lt;strong&gt;всего лишь&lt;/strong&gt; удобный способ отладки сервисов Erlang во время разработки.</target>
        </trans-unit>
        <trans-unit id="09d03cd7b2afda946d29b4dfa4871ca45c957a3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content&lt;/code&gt; field of the top element is a list of records that shows the structure and data of the document. If it is a simple document like:</source>
          <target state="translated">Поле &lt;code&gt;content&lt;/code&gt; верхнего элемента - это список записей, который показывает структуру и данные документа. Если это простой документ, например:</target>
        </trans-unit>
        <trans-unit id="838c0fd05d2d1deb4094b06de0e616a5af7c6e8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; option inhibits the call to &lt;code&gt;trace(stop)&lt;/code&gt; and leaves it up to the caller to stop tracing at a suitable time.</source>
          <target state="translated">Опция &lt;code&gt;continue&lt;/code&gt; запрещает вызов для &lt;code&gt;trace(stop)&lt;/code&gt; и оставляет на усмотрение вызывающего абонента возможность прекратить отслеживание в подходящее время.</target>
        </trans-unit>
        <trans-unit id="5e5e4cf83680d9fc0726d1fa4e444a1ac9be072e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;control&lt;/code&gt; entry is called from the emulator when the Erlang code calls &lt;code&gt;port_control/3&lt;/code&gt;, to do the actual work. We have defined a simple set of commands: &lt;code&gt;connect&lt;/code&gt; to log in to the database, &lt;code&gt;disconnect&lt;/code&gt; to log out, and &lt;code&gt;select&lt;/code&gt; to send a SQL-query and get the result. All results are returned through &lt;code&gt;rbuf&lt;/code&gt;. The library &lt;code&gt;ei&lt;/code&gt; in &lt;code&gt;erl_interface&lt;/code&gt; is used to encode data in binary term format. The result is returned to the emulator as binary terms, so &lt;code&gt;binary_to_term&lt;/code&gt; is called in Erlang to convert the result to term form.</source>
          <target state="translated">Элемент &lt;code&gt;control&lt;/code&gt; вызывается из эмулятора, когда код Erlang вызывает &lt;code&gt;port_control/3&lt;/code&gt; , чтобы выполнить фактическую работу. Мы определили простой набор команд: &lt;code&gt;connect&lt;/code&gt; для входа в базу данных, &lt;code&gt;disconnect&lt;/code&gt; для выхода из системы и &lt;code&gt;select&lt;/code&gt; отправки SQL-запроса и получения результата. Все результаты возвращаются через &lt;code&gt;rbuf&lt;/code&gt; . Библиотека &lt;code&gt;ei&lt;/code&gt; в &lt;code&gt;erl_interface&lt;/code&gt; используется для кодирования данных в двоичном формате терминов. Результат возвращается в эмулятор в виде двоичных терминов, поэтому в Erlang &lt;code&gt;binary_to_term&lt;/code&gt; для преобразования результата в форму термина.</target>
        </trans-unit>
        <trans-unit id="26bab11093554a028ef86c3afb6f974cfc496b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert_to_c&lt;/code&gt; function is the same as before, but here it is used as a fun:</source>
          <target state="translated">Функция &lt;code&gt;convert_to_c&lt;/code&gt; такая же, как и раньше, но здесь она используется для развлечения:</target>
        </trans-unit>
        <trans-unit id="77c0725ecb5968616addeb9bf220dfefe059032f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cprof&lt;/code&gt; module is used to profile a program to find out how many times different functions are called. Breakpoints similar to local call trace, but containing a counter, are used to minimise runtime performance impact.</source>
          <target state="translated">Модуль &lt;code&gt;cprof&lt;/code&gt; используется для профилирования программы, чтобы узнать, сколько раз вызываются разные функции. Точки останова, подобные локальной трассировке вызовов, но содержащие счетчик, используются для минимизации влияния на производительность во время выполнения.</target>
        </trans-unit>
        <trans-unit id="9716455d32bb78ba694b642a2f677996c5c94a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is applied to the generated stream of bytes prior to sending them to the SFTP server. This is intended for encryption but can be used for other purposes.</source>
          <target state="translated">Параметр &lt;code&gt;crypto&lt;/code&gt; режима применяется к сгенерированному потоку байтов до их отправки на сервер SFTP. Это предназначено для шифрования, но может использоваться для других целей.</target>
        </trans-unit>
        <trans-unit id="fae5817bafe1b274a413d2d8be87f3d34ec23f9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is explained in the data types section above, see &lt;code&gt;&lt;a href=&quot;#Crypto%20operations%20for%20open_tar&quot;&gt;Crypto operations for open_tar&lt;/a&gt;&lt;/code&gt;. Encryption is assumed if the &lt;code&gt;Mode&lt;/code&gt; contains &lt;code&gt;write&lt;/code&gt;, and decryption if the &lt;code&gt;Mode&lt;/code&gt; contains &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cee4c61a0a375534a2fba35a2573413a78af60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto_init&lt;/code&gt; initialies an internal cipher state, and one or more calls of &lt;code&gt;crypto_update&lt;/code&gt; does the acual encryption or decryption. Note that AEAD ciphers can't be handled this way due to their nature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b046fe6dab519074b82c93250ff16e0a704aba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto_one_time_aead&lt;/code&gt; functions are for the ciphers of mode &lt;code&gt;ccm&lt;/code&gt; or &lt;code&gt;gcm&lt;/code&gt;, and for the cipher &lt;code&gt;chacha20-poly1305&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ea90a542fdde5c9bfa793410f97e64b38fc90e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cryptolib_padding&lt;/code&gt; are paddings that may be present in the underlying cryptolib linked to the Erlang/OTP crypto app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05085fc1befe3aa6ba53fe6204755e8c7f0ad8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_hooks&lt;/code&gt; statement must look as follows:</source>
          <target state="translated">Оператор &lt;code&gt;ct_hooks&lt;/code&gt; должен выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="195e3e1b4f16da2ed99752167d29e762d1e2035f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program is automatically installed with Erlang/OTP and the &lt;code&gt;Common Test&lt;/code&gt; application (for more information, see section &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; in the User's Guide). The program accepts different start flags. Some flags trigger &lt;code&gt;ct_run&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt; and pass on data to it. Some flags start an Erlang node prepared for running &lt;code&gt;Common Test&lt;/code&gt; in a particular mode.</source>
          <target state="translated">Программа &lt;code&gt;ct_run&lt;/code&gt; автоматически устанавливается вместе с Erlang / OTP и приложением &lt;code&gt;Common Test&lt;/code&gt; (дополнительную информацию см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; Руководства пользователя). Программа принимает разные стартовые флаги. Некоторые флаги запускают &lt;code&gt;ct_run&lt;/code&gt; для запуска &lt;code&gt;Common Test&lt;/code&gt; и передачи ему данных. Некоторые флаги запускают узел Erlang, подготовленный для запуска &lt;code&gt;Common Test&lt;/code&gt; в определенном режиме.</target>
        </trans-unit>
        <trans-unit id="0bead0eeaff46c7e466e0712fc0054654e293c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program sets the exit status before shutting down. The following values are defined:</source>
          <target state="translated">Программа &lt;code&gt;ct_run&lt;/code&gt; устанавливает статус выхода перед завершением работы. Определены следующие значения:</target>
        </trans-unit>
        <trans-unit id="5e688bf44ef358ec92d20ce42ff6bf380d1fb9a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cth_conn_log&lt;/code&gt; hook performs unformatted logging of Telnet data to a separate text file. All Telnet communication is captured and printed, including any data sent from the server. The link to this text file is located at the top of the test case HTML log.</source>
          <target state="translated">В &lt;code&gt;cth_conn_log&lt;/code&gt; крюк выполняет неотформатированная протоколирование данных Telnet в отдельный текстовый файл. Все коммуникации Telnet фиксируются и распечатываются, включая любые данные, отправленные с сервера. Ссылка на этот текстовый файл находится в верхней части HTML-журнала тестового примера.</target>
        </trans-unit>
        <trans-unit id="a68179b6708f261780e3204a93ccf67ebff3b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; module is primarily targeted towards tracing through the &lt;code&gt;erlang:trace/3&lt;/code&gt; function. It is sometimes desired to trace messages in a more delicate way, which can be done with the help of the &lt;code&gt;seq_trace&lt;/code&gt; module.</source>
          <target state="translated">Модуль &lt;code&gt;dbg&lt;/code&gt; в первую очередь предназначен для отслеживания с помощью функции &lt;code&gt;erlang:trace/3&lt;/code&gt; . Иногда желательно отслеживать сообщения более тонким способом, что можно сделать с помощью модуля &lt;code&gt;seq_trace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ec06ab24b2bef8a81af6b12d4353768a1844399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; server keeps a list of nodes where tracing should be performed. Whenever a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; call or a &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; call is made, it is executed for all nodes in this list including the local node (except for &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; with a specific &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; as first argument, in which case the command is executed only on the node where the designated process or port resides).</source>
          <target state="translated">Сервер &lt;code&gt;dbg&lt;/code&gt; хранит список узлов, на которых должна выполняться трассировка. Всякий раз, когда выполняется вызов &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; или вызов &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; , он выполняется для всех узлов в этом списке, включая локальный узел (кроме &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; с конкретным &lt;code&gt;pid()&lt;/code&gt; или &lt;code&gt;port()&lt;/code&gt; качестве первого аргумента, в котором в случае, если команда выполняется только на узле, где находится назначенный процесс или порт).</target>
        </trans-unit>
        <trans-unit id="c217008a9ef77e9f7c9c82997e3edae1e2b0a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; variants of match specifications have an imperative approach to the match specification body, the ETS dialect has not. The fun body for &lt;code&gt;ets:fun2ms/1&lt;/code&gt; returns the result without side effects. As matching (&lt;code&gt;=&lt;/code&gt;) in the body of the match specifications is not allowed (for performance reasons) the only thing left, more or less, is term construction.</source>
          <target state="translated">В &lt;code&gt;dbg&lt;/code&gt; варианта спецификаций соответствия имеет императивный подход к спецификации телам совпадают, ETS диалект не имеет. &lt;code&gt;ets:fun2ms/1&lt;/code&gt; тело для ets: fun2ms / 1 возвращает результат без побочных эффектов. Поскольку соответствие ( &lt;code&gt;=&lt;/code&gt; ) в теле спецификаций совпадений не допускается (по соображениям производительности), единственное, что осталось более или менее, - это построение термина.</target>
        </trans-unit>
        <trans-unit id="8b1d45e514e2b4bb0f72c0e576b456b901110516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; option ensures that the BEAM file contains debug information, which makes it possible to find unused local functions.</source>
          <target state="translated">Параметр &lt;code&gt;debug_info&lt;/code&gt; гарантирует, что файл BEAM содержит отладочную информацию, что позволяет находить неиспользуемые локальные функции.</target>
        </trans-unit>
        <trans-unit id="f272f87848e9520c4164ada69cea273706e63692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; parameter controls whether the debug information in the beam file should be kept (&lt;code&gt;keep&lt;/code&gt;) or stripped &lt;code&gt;strip&lt;/code&gt; when the file is copied to the target system.</source>
          <target state="translated">Параметр &lt;code&gt;debug_info&lt;/code&gt; управляет тем, следует ли сохранять ( &lt;code&gt;keep&lt;/code&gt; ) отладочную информацию в файле луча или удалять &lt;code&gt;strip&lt;/code&gt; при копировании файла в целевую систему.</target>
        </trans-unit>
        <trans-unit id="6fb823bf619fb63ef67310a79ad7a561ee4d0a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the table from the database since unloading an MIB does not necessarily mean that the table should be destroyed.</source>
          <target state="translated">Функция &lt;code&gt;delete&lt;/code&gt; не удаляет таблицу из базы данных, поскольку выгрузка MIB не обязательно означает, что таблица должна быть уничтожена.</target>
        </trans-unit>
        <trans-unit id="9bb6d436299249f5caa30b07b29030812a609536" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the variable from the database.</source>
          <target state="translated">Функция &lt;code&gt;delete&lt;/code&gt; не удаляет переменную из базы данных.</target>
        </trans-unit>
        <trans-unit id="7056e5309dbe8cb35a67254e724ea1561fd3590e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; operation is considered successful if the element was not present in the table. Hence all attempts to check that the element is present in the Ets/Mnesia table before deletion are unnecessary. Here follows an example for Ets tables:</source>
          <target state="translated">Операция &lt;code&gt;delete&lt;/code&gt; считается успешной, если элемент отсутствовал в таблице. Следовательно, все попытки перед удалением проверить, присутствует ли элемент в таблице Ets / Mnesia, не нужны. Вот пример для таблиц Ets:</target>
        </trans-unit>
        <trans-unit id="9843826cc8a81d332dd5ca58dc2e4d273cfa0a51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dh_der&lt;/code&gt; option is not supported by TLS 1.3. Use the &lt;code&gt;supported_groups&lt;/code&gt; option instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d506578ec68dd2a9fa7f8cceed364aba6b39394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dh_file&lt;/code&gt; option is not supported by TLS 1.3. Use the &lt;code&gt;supported_groups&lt;/code&gt; option instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec29833516e95ca8c52bcd06ca0329b6a9912b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disc_copies&lt;/code&gt; tables are stored on disk with &lt;code&gt;.DCL&lt;/code&gt; and &lt;code&gt;.DCD&lt;/code&gt; files, which are standard &lt;code&gt;disk_log&lt;/code&gt; files.</source>
          <target state="translated">В &lt;code&gt;disc_copies&lt;/code&gt; таблицы хранятся на диске с &lt;code&gt;.DCL&lt;/code&gt; и &lt;code&gt;.DCD&lt;/code&gt; файлы, которые являются стандартными &lt;code&gt;disk_log&lt;/code&gt; файлы.</target>
        </trans-unit>
        <trans-unit id="0566aa9127b7a16298ed02e87fbca3df443437c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disk_log&lt;/code&gt; module does not report errors to the &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; module. It is up to the caller to decide whether to employ the error logger. Function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; can be used to produce readable messages from error replies. However, information events are sent to the error logger in two situations, namely when a log is repaired, or when a file is missing while reading chunks.</source>
          <target state="translated">Модуль &lt;code&gt;disk_log&lt;/code&gt; не сообщает об ошибках модулю &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; . Вызывающий должен решить, использовать ли регистратор ошибок. Функцию &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; можно использовать для создания удобочитаемых сообщений из ответов об ошибках. Однако информационные события отправляются в регистратор ошибок в двух ситуациях, а именно, когда журнал восстанавливается или когда файл отсутствует во время чтения фрагментов.</target>
        </trans-unit>
        <trans-unit id="cfcfef3897d14b434ad165428853c39b5f2890f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; and &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; functions takes a &lt;code&gt;#hs_data{}&lt;/code&gt; record as argument. There are quite a lot of fields in this record that you need to set. The record is defined in &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt;. Not documented fields should not be set, i.e., should be left as &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Функции &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; и &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; принимают в качестве аргумента запись &lt;code&gt;#hs_data{}&lt;/code&gt; . В этой записи довольно много полей, которые вам нужно задать. Запись определена в &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt; . Недокументированные поля не должны устанавливаться, т.е. должны оставаться &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83c7e0ed34c372831d8c8f2866d0a4d8b8af47d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do_select&lt;/code&gt; function initiates a select, and returns if there is no immediate error. The result is returned when &lt;code&gt;ready_io&lt;/code&gt; is called.</source>
          <target state="translated">Функция &lt;code&gt;do_select&lt;/code&gt; инициирует выбор и возвращается, если немедленной ошибки нет. Результат возвращается при &lt;code&gt;ready_io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e898d68f399dcaad71bedb473b4e1db27a86822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver_entry&lt;/code&gt; structure is a C struct that all Erlang drivers define. It contains entry points for the Erlang driver, which are called by the Erlang emulator when Erlang code accesses the driver.</source>
          <target state="translated">Структура &lt;code&gt;driver_entry&lt;/code&gt; - это структура C, которую определяют все драйверы Erlang. Он содержит точки входа для драйвера Erlang, которые вызываются эмулятором Erlang, когда код Erlang обращается к драйверу.</target>
        </trans-unit>
        <trans-unit id="e2f343471e0cd9e732eb94fa594ad01445d525d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entity-Body&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;, for example, data sent from a CGI script using the POST method.</source>
          <target state="translated">&lt;code&gt;entity-Body&lt;/code&gt; , как определено в &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; , например, данные , передаваемые из сценария CGI с помощью метода POST.</target>
        </trans-unit>
        <trans-unit id="76a9c6534aadded1a2e3a2195c085de8d3e1307d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entity-Body&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;, for example, data sent from a CGI script using the POST method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8485e195c6ca973415a83d30d66c767c905bacbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;epmd&lt;/code&gt; daemon accepts messages from both the local host and remote hosts. However, only the query commands are answered (and acted upon) if the query comes from a remote host. It is always an error to try to register a node name if the client is not a process on the same host as the &lt;code&gt;epmd&lt;/code&gt; instance is running on. Such requests are considered hostile and the connection is closed immediately.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; демон принимает сообщения от как на локальном хосте и удаленных хостов. Однако только команды запроса получают ответ (и действуют), если запрос поступает с удаленного хоста. &lt;code&gt;epmd&lt;/code&gt; зарегистрировать имя узла всегда является ошибкой, если клиент не является процессом на том же хосте, на котором запущен экземпляр epmd . Такие запросы считаются враждебными, и соединение немедленно закрывается.</target>
        </trans-unit>
        <trans-unit id="1a8cdcc41303bad80d1836231fd657575e8b7da9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl&lt;/code&gt; program starts an Erlang runtime system. The exact details (for example, whether &lt;code&gt;erl&lt;/code&gt; is a script or a program and which other programs it calls) are system-dependent.</source>
          <target state="translated">Программа &lt;code&gt;erl&lt;/code&gt; запускает систему времени выполнения Erlang. Точные детали (например, является ли &lt;code&gt;erl&lt;/code&gt; сценарием или программой и какие другие программы он вызывает) зависят от системы.</target>
        </trans-unit>
        <trans-unit id="23033c746a70348dcd7ee413398f764a041fafc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_boot_server&lt;/code&gt; can read regular files and files in archives. See &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; in ERTS.</source>
          <target state="translated">&lt;code&gt;erl_boot_server&lt;/code&gt; может читать обычные файлы и файлы в архивах. См. &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; в ERTS.</target>
        </trans-unit>
        <trans-unit id="cc1db4ac366acb55e5dbd23b870fee87dcf6984d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_prim_loader&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">Модуль &lt;code&gt;erl_prim_loader&lt;/code&gt; интерпретирует следующие флаги командной строки:</target>
        </trans-unit>
        <trans-unit id="a9f75e2ebb8bacf1be148858ac754ee91aff0b2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:processes/1&lt;/code&gt; and &lt;code&gt;erlang:port/1&lt;/code&gt; BIFs iterate over the tables and return corresponding identifiers. These BIF should return a consistent snapshot of the table content during some time when the BIF is executing. In order to implement this we use locking in a strange way. We use an &quot;inverted rwlock&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8443a325361f346c54c5b5b79ecfd176dc3cc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF is equivalent to:</source>
          <target state="translated">&lt;code&gt;erlang:timestamp()&lt;/code&gt; БИФ эквивалентно:</target>
        </trans-unit>
        <trans-unit id="674c071fef1bb6c50be069bf2fac5cfa5b02ddff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; commands can be used to compile SNMP MIBs. Example:</source>
          <target state="translated">В &lt;code&gt;erlc&lt;/code&gt; команды могут быть использованы для компиляции SNMP MIBs. Пример:</target>
        </trans-unit>
        <trans-unit id="62bad1fda35fe8631456e7f852e564c8e9c8e268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides a common way to run all compilers in the Erlang system. Depending on the extension of each input file, &lt;code&gt;erlc&lt;/code&gt; invokes the appropriate compiler. Regardless of which compiler is used, the same flags are used to provide parameters, such as include paths and output directory.</source>
          <target state="translated">Программа &lt;code&gt;erlc&lt;/code&gt; предоставляет общий способ запуска всех компиляторов в системе Erlang. В зависимости от расширения каждого входного файла &lt;code&gt;erlc&lt;/code&gt; вызывает соответствующий компилятор. Независимо от того, какой компилятор используется, одни и те же флаги используются для предоставления параметров, таких как пути включения и выходной каталог.</target>
        </trans-unit>
        <trans-unit id="04a181b53380c41c65d2013dd7fbc831073b3697" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides an even better way to compile modules from the shell, see the &lt;code&gt;erlc(1)&lt;/code&gt; manual page in ERTS. It understands a number of flags that can be used to define macros, add search paths for include files, and more.</source>
          <target state="translated">Программа &lt;code&gt;erlc&lt;/code&gt; предоставляет еще лучший способ компилировать модули из оболочки, см. &lt;code&gt;erlc(1)&lt;/code&gt; в ERTS. Он понимает ряд флагов, которые можно использовать для определения макросов, добавления путей поиска для включаемых файлов и т. Д.</target>
        </trans-unit>
        <trans-unit id="8ef81ea9999fef9d6386667fd464ac528873e195" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation failed due to some system limit being reached. This typically due to failure to create a process on the remote node &lt;code&gt;Node&lt;/code&gt;, but can be other things as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef05a4f26d361fa5f7db9630f59b90887dc5e15f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation failed. The following &lt;code&gt;ERpcErrorReason&lt;/code&gt;s are the most common ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecee252d04d93f7d74c1c1a56f12a612505d489e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation timed out. The function may or may not be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3c7d4f5dac617c7aad52a992257a0165d9e724" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger&lt;/code&gt; API still exists, but should only be used by legacy code. It will be removed in a later release.</source>
          <target state="translated">&lt;code&gt;error_logger&lt;/code&gt; API все еще существует, но должны использоваться только унаследованным кодом. Он будет удален в более позднем выпуске.</target>
        </trans-unit>
        <trans-unit id="cecfe06c35cc22d6fbeab34699c031b77ba0b013" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt; deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68556b2eb1fae2f09bd4af885781dca52da64d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt;deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="translated">&lt;code&gt;error_logger_format_depth&lt;/code&gt; переменная не &lt;code&gt;deprecated&lt;/code&gt; , так как &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; был введен в Erlang / OTP 21,0. Переменная и эта функция сохранены для обратной совместимости, поскольку они все еще могут использоваться устаревшими обработчиками отчетов.</target>
        </trans-unit>
        <trans-unit id="7c78dbc6e06eb7032ca1037abf4bb7cf984ec4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; tool can be used to aid creation of an &lt;code&gt;erts_alloc&lt;/code&gt; configuration that is suitable for a limited number of runtime scenarios.</source>
          <target state="translated">Инструмент &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; может использоваться для помощи в создании конфигурации &lt;code&gt;erts_alloc&lt;/code&gt; , подходящей для ограниченного числа сценариев выполнения.</target>
        </trans-unit>
        <trans-unit id="6d445f376d6f420d187f6eefce3f926292a91d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;et&lt;/code&gt; module is not like other modules. It contains a function called &lt;code&gt;et:trace_me/5&lt;/code&gt;. Which is a function that does not do any useful stuff at all. Its sole purpose is to be a function that is easy to trace. A call to it may be something like:</source>
          <target state="translated">Модуль &lt;code&gt;et&lt;/code&gt; не похож на другие модули. Он содержит функцию &lt;code&gt;et:trace_me/5&lt;/code&gt; . Это функция, которая вообще не делает никаких полезных вещей. Его единственная цель - быть функцией, которую легко отследить. Обращение к нему может быть примерно таким:</target>
        </trans-unit>
        <trans-unit id="bed59c1de102975ce15ed3e675ac3119209f047d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; program of fairly modern versions of Emacs and XEmacs has native support for Erlang. To check if your version does include this support, issue the command &lt;code&gt;etags --help&lt;/code&gt; at a the command line prompt. At the end of the help text there is a list of supported languages. Unless Erlang is a member of this list I suggest that you should upgrade to a newer version of Emacs.</source>
          <target state="translated">Программа &lt;code&gt;etags&lt;/code&gt; довольно современных версий Emacs и XEmacs имеет встроенную поддержку Erlang. Чтобы проверить, включает ли ваша версия эту поддержку, &lt;code&gt;etags --help&lt;/code&gt; команду etags --help в командной строке. В конце текста справки приводится список поддерживаемых языков. Если Erlang не входит в этот список, я предлагаю вам перейти на более новую версию Emacs.</target>
        </trans-unit>
        <trans-unit id="47e6f553b59c8cd440ae6bcf427e51798ed42721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; utility can also read a list of files from its standard input by supplying a single dash in place of the file names. This feature is useful when a project consists of a large number of files. The standard UNIX command &lt;code&gt;find&lt;/code&gt; can be used to generate the list of files, e.g:</source>
          <target state="translated">&lt;code&gt;etags&lt;/code&gt; утилита также может прочитать список файлов из стандартного ввода путем подачи одного тира вместо имен файлов. Эта функция полезна, когда проект состоит из большого количества файлов. Стандартная команда UNIX &lt;code&gt;find&lt;/code&gt; может использоваться для создания списка файлов, например:</target>
        </trans-unit>
        <trans-unit id="e41a30417c9eb9b7fd9125a0948a761a185309da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ets:select/2&lt;/code&gt; call conceptually looks like this in the resulting code:</source>
          <target state="translated">&lt;code&gt;ets:select/2&lt;/code&gt; вызова концептуально выглядит в полученном коде:</target>
        </trans-unit>
        <trans-unit id="c0a28f71fbf02463cf528426b0591cc67a7a02b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;example_drv_start&lt;/code&gt;, is the only function that is called with a handle to the port instance, so this must be saved. It is customary to use an allocated driver-defined structure for this one, and to pass a pointer back as a reference.</source>
          <target state="translated">&lt;code&gt;example_drv_start&lt;/code&gt; , единственная функция, которая вызывается с ручкой к экземпляру порта, так что это должно быть сохранено. Обычно для этого используется выделенная структура, определяемая драйвером, и передается указатель обратно в качестве ссылки.</target>
        </trans-unit>
        <trans-unit id="d0356d1c5d4e8ef894f1ca0204010b1f0f916038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extended_errors&lt;/code&gt; option enables extended ODBC error information when an operation fails. Rather than returning &lt;code&gt;{error, Reason}&lt;/code&gt;, the failing function will reutrn &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt;. Note that this information is probably of little use when writing database-independent code, but can be of assistance in providing more sophisticated error handling when dealing with a known underlying database.</source>
          <target state="translated">Параметр &lt;code&gt;extended_errors&lt;/code&gt; включает расширенную информацию об ошибках ODBC в случае сбоя операции. Вместо того чтобы возвращать &lt;code&gt;{error, Reason}&lt;/code&gt; , сбойная функция вернет &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt; . Обратите внимание, что эта информация, вероятно, мало пригодна при написании кода, независимого от базы данных, но может помочь в обеспечении более сложной обработки ошибок при работе с известной базовой базой данных.</target>
        </trans-unit>
        <trans-unit id="c59051a0d238b0abf7c9e7050c91b5361d579937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra&lt;/code&gt; info is not normally interpreted by the agent, instead it is passed through to the &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; process. It is up to the implementor of that process to make use of this data.</source>
          <target state="translated">&lt;code&gt;extra&lt;/code&gt; информация не обычно интерпретируется агентом, вместо этого он проходит через к &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; процесс. Реализатор этого процесса должен использовать эти данные.</target>
        </trans-unit>
        <trans-unit id="57ed5e1b23df723cf600bd41057a5b61adc0bf3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; field can only have the (above) specified values (and not all the values of socket:domain()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9363097de66681822e14d18a16cae53b07a71b33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module accepts raw filenames as input. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; also accepts them. As mentioned earlier, the arguments specified in the option list to &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; undergo the same conversion as the filenames, meaning that the executable is provided with arguments in UTF-8 as well. This translation is avoided consistently with how the filenames are treated, by giving the argument as a binary.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; модуль принимает исходные имена файлов в качестве входных данных. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; также принимает их. Как упоминалось ранее, аргументы, указанные в списке опций для &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; подвергаются тому же преобразованию, что и имена файлов, что означает, что исполняемый файл также предоставляется с аргументами в UTF-8. Этого преобразования избегают в соответствии с тем, как обрабатываются имена файлов, путем передачи аргумента в виде двоичного файла.</target>
        </trans-unit>
        <trans-unit id="56811d8968fc7cff92a38ee6c1b86759f5455dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module already spread's tags, so there is noo need to manually call these function to get user tags spread to the efile driver through that module.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; модуль уже теги Spread, поэтому есть Ий нужно вручную вызвать эти функции , чтобы получить тег пользователей распространения драйвера efile через этот модуль.</target>
        </trans-unit>
        <trans-unit id="d1888f67852ce013eb515b48a1f7e3f5fb2b5677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foo&lt;/code&gt; table is replicated on the two nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">Таблица &lt;code&gt;foo&lt;/code&gt; дублируется на двух узлах &lt;code&gt;N1&lt;/code&gt; и &lt;code&gt;N2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58cb0b27674de03ef7e6aa8a782a3f05022f6202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fprof&lt;/code&gt; module uses tracing to collect profiling data, hence there is no need for special compilation of any module to be profiled. When it starts tracing, &lt;code&gt;fprof&lt;/code&gt; will erase all previous tracing in the node and set the necessary trace flags on the profiling target processes as well as local call trace on all functions in all loaded modules and all modules to be loaded. &lt;code&gt;fprof&lt;/code&gt; erases all tracing in the node when it stops tracing.</source>
          <target state="translated">Модуль &lt;code&gt;fprof&lt;/code&gt; использует трассировку для сбора данных профилирования, поэтому нет необходимости в специальной компиляции какого-либо модуля для профилирования. Когда он начинает трассировку, &lt;code&gt;fprof&lt;/code&gt; удалит всю предыдущую трассировку в узле и установит необходимые флаги трассировки для целевых процессов профилирования, а также трассировку локального вызова для всех функций во всех загруженных модулях и всех модулях, которые должны быть загружены. &lt;code&gt;fprof&lt;/code&gt; стирает всю трассировку в узле, когда прекращает трассировку.</target>
        </trans-unit>
        <trans-unit id="2499ac11d982c28fc125b257bd3bdd2fea444c7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fqdn_fun&lt;/code&gt; extracts hostnames (Fully Qualified Domain Names) from uri_id or other ReferenceIDs that are not pre-defined in the public_key function. Suppose you have some URI with a very special protocol-part: &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt;. Since this a non-standard URI there will be no hostname extracted for matching CN-names in the &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;fqdn_fun&lt;/code&gt; извлекает имена хостов ( полные доменные имена) из uri_id или других ReferenceID, которые не определены заранее в функции public_key. Предположим, у вас есть некий URI с очень специальной частью протокола: &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt; . Поскольку это нестандартный URI, имя хоста не извлекается для сопоставления CN-имен в &lt;code&gt;Subject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="122806faca6d67fa7fa167376a0e47c2c49bcb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;message&lt;/code&gt; parameters are exactly what they sound like. &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are visualized in the &lt;code&gt;Viewer&lt;/code&gt; as &quot;lifelines&quot;, with the message passing from one to the other. If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same value, then it is displayed next to the lifeline as an &quot;action&quot;. The &lt;code&gt;extra_stuff&lt;/code&gt;value is simply data that you can attach that will be displayed when someone actually clicks on the action or message in the &lt;code&gt;Viewer&lt;/code&gt; window.</source>
          <target state="translated">Параметры &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; и &lt;code&gt;message&lt;/code&gt; - это именно то, на что они похожи. &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;to&lt;/code&gt; визуализируются в &lt;code&gt;Viewer&lt;/code&gt; как &amp;laquo; линии жизни&amp;raquo;, при этом сообщение передается от одного к другому. Если &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;to&lt;/code&gt; являются одним и тем же значением, то оно отображается рядом с линией жизни как &amp;laquo;действие&amp;raquo;. Значение &lt;code&gt;extra_stuff&lt;/code&gt; - это просто данные, которые вы можете прикрепить и которые будут отображаться, когда кто-то на самом деле щелкает действие или сообщение в окне средства &lt;code&gt;Viewer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87548be67a9ff93c1ef1ff4d3cbb19180b6403f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ftp&lt;/code&gt; module normally accesses the tar file on disk using the &lt;code&gt;file&lt;/code&gt; module. When other needs arise, you can define your own low-level Erlang functions to perform the writing and reading on the storage media; use function &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Модуль &lt;code&gt;ftp&lt;/code&gt; обычно обращается к tar-файлу на диске с помощью &lt;code&gt;file&lt;/code&gt; модуля. Когда возникают другие потребности, вы можете определить свои собственные низкоуровневые функции Erlang для выполнения записи и чтения на носителе; используйте функцию &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a262c9e6ae8c813f3758420838640077d62040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; in the exec option could take up to three arguments (&lt;code&gt;Cmd&lt;/code&gt;, &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;ClientAddress&lt;/code&gt;). See the &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt; for the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601051b0fdf8cf4c5f5015c05c1f7676f5366f6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; is very restricted, it can take only a single parameter (the parameter list to match), a sole variable or a list. It needs to use the &lt;code&gt;is_&lt;/code&gt;XXX guard tests and one cannot use language constructs that have no representation in a match_spec (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; etc). The return value from the fun will be the return value of the resulting match_spec.</source>
          <target state="translated">Функция &lt;code&gt;fun()&lt;/code&gt; очень ограничена, она может принимать только один параметр (список параметров для сопоставления), единственную переменную или список. Необходимо использовать &lt;code&gt;is_&lt;/code&gt; тесты is_ XXX, и нельзя использовать языковые конструкции, не представленные в match_spec (например, &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; и т. Д.). Возвращаемое значение из развлечения будет возвращаемым значением результирующего match_spec.</target>
        </trans-unit>
        <trans-unit id="000806ecedbeddab2e6bf12ee5fe07ca1e33c2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun/2&lt;/code&gt; in this option replaces the default host name matching rules. The fun should return a boolean to tell if the Reference ID and Presented ID matches or not. The fun can also return a third value, the atom &lt;code&gt;default&lt;/code&gt;, if the default matching rules shall apply. This makes it possible to augment the tests with a special case:</source>
          <target state="translated">Параметр &lt;code&gt;fun/2&lt;/code&gt; в этом параметре заменяет правила сопоставления имен хостов по умолчанию. Веселье должно возвращать логическое значение, чтобы определить, совпадают ли ссылочный идентификатор и представленный идентификатор или нет. Fun может также вернуть третье значение, атом по &lt;code&gt;default&lt;/code&gt; , если должны применяться правила сопоставления по умолчанию. Это позволяет дополнить тесты специальным случаем:</target>
        </trans-unit>
        <trans-unit id="f52884fca2fcf6439eaac6506d404d211516c579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functions&lt;/code&gt; filter shows each function as a vertical line in the sequence diagram. A function calling itself is shown as an activity within a function, and all other function calls are shown as interactions between functions.</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; фильтра показывает каждую функцию в виде вертикальной линии на диаграмме последовательности. Сам вызывающая функция отображается как действие внутри функции, а все остальные вызовы функций отображаются как взаимодействие между функциями.</target>
        </trans-unit>
        <trans-unit id="3f981dcbf4ac48552e64e421603989d6797ca936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;garbage_collect&lt;/code&gt; pseudo function has not got an OWN time of zero like &lt;code&gt;suspend&lt;/code&gt;, instead it is equal to the ACC time.</source>
          <target state="translated">&lt;code&gt;garbage_collect&lt;/code&gt; функция псевдо не получил собственное время , равное нулю , как &lt;code&gt;suspend&lt;/code&gt; , а оно равно времени ACC.</target>
        </trans-unit>
        <trans-unit id="65be8dbec39cb8799bd4b2ae3b3d10e864f2a323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt; erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044322659b6e8af2be19d4c036e45080be4df433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="translated">Процесс &lt;code&gt;gen_event&lt;/code&gt; может перейти в спящий режим (см. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; ), если функция обратного вызова в модуле обработчика указывает &lt;code&gt;hibernate&lt;/code&gt; в своем возвращаемом значении. Это может быть полезно, если ожидается, что сервер будет простаивать долгое время. Однако используйте эту функцию с осторожностью, так как гибернация подразумевает как минимум две сборки мусора (при переходе в спящий режим и вскоре после пробуждения) и не является чем-то, что вы хотите делать между каждым событием, обрабатываемым диспетчером событий.</target>
        </trans-unit>
        <trans-unit id="f841b959e8263c246a84615eb245e9aa9e79a66a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a989bcc28ed3e808b806405714b19049fd235b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned.</source>
          <target state="translated">Процесс &lt;code&gt;gen_server&lt;/code&gt; вызывает &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; для инициализации. Чтобы гарантировать синхронизированную процедуру запуска, &lt;code&gt;start_link/3,4&lt;/code&gt; не возвращается, пока не вернется &lt;code&gt;Module:init/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7490f34408e79e925356758b66c95f52679a6c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt; erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0125aacc8a9ef2d0db488477563acd091e114f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="translated">Процесс &lt;code&gt;gen_server&lt;/code&gt; может перейти в режим гибернации (см. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; ), если функция обратного вызова указывает &lt;code&gt;'hibernate'&lt;/code&gt; вместо значения тайм-аута. Это может быть полезно, если ожидается, что сервер будет простаивать долгое время. Однако используйте эту функцию с осторожностью, поскольку гибернация подразумевает как минимум две сборки мусора (при переходе в спящий режим и вскоре после пробуждения) и не является чем-то, что вы хотите делать между каждым вызовом занятого сервера.</target>
        </trans-unit>
        <trans-unit id="93b11bb8bc3cc58fae8df0b4cde4e2b1b7508719" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process has been set to trap exit signals.</source>
          <target state="translated">Процесс &lt;code&gt;gen_server&lt;/code&gt; настроен на перехват сигналов выхода.</target>
        </trans-unit>
        <trans-unit id="1a0a8f650014835d8fac6303db526f6a6997059c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">Процесс &lt;code&gt;gen_server&lt;/code&gt; аварийно завершает работу и регистрирует ошибку. &lt;code&gt;Opt&lt;/code&gt; устанавливается на атом &lt;code&gt;terminate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a177f7b03da7ce677026ac74a7f1eaf2f38ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior can if this is enabled, regardless of callback mode, automatically &lt;code&gt;call the state callback&lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the state transition rules. It typically looks like this:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; поведение , если это разрешено, независимо от режима обратного вызова, автоматически &lt;code&gt;call the state callback&lt;/code&gt; с помощью специальных аргументов всякий раз , когда изменяется состояние , так что вы можете написать состояния входят действия вблизи остальных правил перехода состояний. Обычно это выглядит так:</target>
        </trans-unit>
        <trans-unit id="bed0fd34af6e417a5ed2971b378b4cefa2ed46b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior supports two callback modes:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; поведение поддерживает два режима обратного вызова:</target>
        </trans-unit>
        <trans-unit id="0853cf94b65372cd43a3f0b5a15fa90c0eef1c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behaviour can if this is enabled, regardless of &lt;strong&gt;callback mode&lt;/strong&gt;, automatically &lt;code&gt; call the state callback &lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the &lt;strong&gt;state transition&lt;/strong&gt; rules. It typically looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bfee8de64aaf220d4aeed1c41aab972dbfcbf33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behaviour supports two &lt;strong&gt;callback modes&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202063559580002e499e6f482887a341d2fb543d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; calls the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{call,From}&lt;/code&gt; and event content &lt;code&gt;Request&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6f22901bf82daa00ca3a8e82f1d85e746f57f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a &lt;strong&gt;state transition&lt;/strong&gt; to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If &lt;code&gt;NextState =/= CurrentState&lt;/code&gt; the &lt;strong&gt;state transition&lt;/strong&gt; is a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17680806ff10db88faa8089ccb57cda1bbf46d1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; делает переход состояния &lt;code&gt;NextState&lt;/code&gt; (который может быть таким же , как текущее состояние), устанавливает &lt;code&gt;NewData&lt;/code&gt; , и выполняет все &lt;code&gt;Actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b1ba800b2bd8eddab3c29205a82310973e51fec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;State&lt;/code&gt;, which has to be the current state, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; делает переход состояния &lt;code&gt;State&lt;/code&gt; , которое должно быть текущим состоянием, устанавливает &lt;code&gt;NewData&lt;/code&gt; и выполняет все &lt;code&gt;Actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3869ef62f08e2a10aa5bf3ec284cea8fd875bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to explicitly insert an event at the &lt;strong&gt;state transition&lt;/strong&gt;, and/or to use a dedicated &lt;strong&gt;state transition&lt;/strong&gt; function, but that is something you will have to remember at every &lt;strong&gt;state transition&lt;/strong&gt; to the state(s) that need it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff91dbdb67dc0752a1cb136935a70afdac9c712" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to insert an event at the state transition, and/or to use a dedicated state transition function, but that is something you will have to remember at every state transition to the state(s) that need it.</source>
          <target state="translated">Механизм &lt;code&gt;gen_statem&lt;/code&gt; может автоматически выполнять специализированный вызов функции &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; всякий раз, когда вводится новое состояние; см. &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt; . Это для написания кода, общего для всех записей состояния. Другой способ сделать это - вставить событие при переходе состояния и / или использовать специальную функцию перехода между состояниями, но это то, что вам нужно будет помнить при каждом переходе состояния в состояние (я), которое в нем нуждается.</target>
        </trans-unit>
        <trans-unit id="298787bc0880c606f6d382d6ec4eea28eb66cd16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine will find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; of &lt;code&gt;NewModule&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; NewModule:callback_mode/0 &lt;/a&gt;&lt;/code&gt; before the next &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609a55f5722ed6b61803cc1734f944814dbce653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; enqueues incoming events in order of arrival and presents these to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in that order. The state callback can postpone an event so it is not retried in the current state. After a state change the queue restarts with the postponed events.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; ставит в очередь входящие события в порядке поступления и подарков в этих &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; в таком порядке. Обратный вызов состояния может отложить событие, чтобы оно не повторялось в текущем состоянии. После изменения состояния очередь перезапускается с отложенными событиями.</target>
        </trans-unit>
        <trans-unit id="63345530db17175adac9ec3a019543d210266d03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement.</source>
          <target state="translated">Модель &lt;code&gt;gen_statem&lt;/code&gt; событий gen_statem достаточна для имитации нормальной очереди сообщений процесса с выборочным приемом. Отсрочка события соответствует несоответствию его в операторе приема, а изменение состояний соответствует вводу нового оператора приема.</target>
        </trans-unit>
        <trans-unit id="641237d979ff0a2d03c26c3ad66f07cb507fd0a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; has been set to trap exit signals.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; был установлен в ловушку сигналов выхода.</target>
        </trans-unit>
        <trans-unit id="154bbf6641ffd5663c5aefea121dd325520717a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is globally registered in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; глобально зарегистрирован в &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67b6a4a7c1fd3b7590f8afba5f3bf9c9be4abb6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered on another node.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; локально зарегистрирована на другой узел.</target>
        </trans-unit>
        <trans-unit id="85f1bfb26c1bebdbfe3ea8eee17c7ba7fcaa85f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; локально зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="dff17e2a1fe994c2de42244386fbbe29172ce5a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is registered in an alternative process registry. The registry callback module &lt;code&gt;RegMod&lt;/code&gt; is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is the same as &lt;code&gt;{global,GlobalName}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; зарегистрирован в альтернативном реестре процесса. Модуль обратного вызова реестра &lt;code&gt;RegMod&lt;/code&gt; предназначен для экспорта функций &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; &lt;code&gt;unregister_name/1&lt;/code&gt; , whereis_name / 1 и &lt;code&gt;send/2&lt;/code&gt; , которые должны вести себя как соответствующие функции в &lt;code&gt;global&lt;/code&gt; . Таким образом, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; совпадает с &lt;code&gt;{global,GlobalName}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f744ffe4f5b7b57ef92ebf70203f5d38f475257a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state and data, or does a state transition to the current state if you like, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state_and_data&lt;/code&gt; is the same as &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; сохраняет текущее состояние и данные, или же переход состояния к текущему состоянию , если вы хотите, и выполняет все &lt;code&gt;Actions&lt;/code&gt; . Это то же самое, что и &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt; . Если &lt;code&gt;gen_statem&lt;/code&gt; работает с &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; в состояние, вызов входа в состояние повторяется, см. Тип &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; , иначе &lt;code&gt;repeat_state_and_data&lt;/code&gt; совпадает с &lt;code&gt;keep_state_and_data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d475ad84f6e39a68e71be16a98a5f4760d76809d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state or does a state transition to the current state if you like, keeps the current server data, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; сохраняет текущее состояние или делает переход состояния к текущему состоянию , если вы хотите, сохраняет текущие данные сервера, и выполняет все &lt;code&gt;Actions&lt;/code&gt; . Это то же самое, что и &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6668d570fa47d65dc6496ac8a7e26666fa0a0e00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; сохраняет текущее состояние, или же переход состояния к текущему состоянию , если вы хотите, устанавливает &lt;code&gt;NewData&lt;/code&gt; и выполняет все &lt;code&gt;Actions&lt;/code&gt; . Если &lt;code&gt;gen_statem&lt;/code&gt; работает с &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; состояния, вызов ввода состояния повторяется, см. Тип &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; , в противном случае &lt;code&gt;repeat_state&lt;/code&gt; совпадает с &lt;code&gt;keep_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d700edd0442a4b2cb750903fd91d19af04ce58f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; сохраняет текущее состояние, или же переход состояния к текущему состоянию , если вы хотите, устанавливает &lt;code&gt;NewData&lt;/code&gt; и выполняет все &lt;code&gt;Actions&lt;/code&gt; . Это то же самое, что и &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8501d306024ff238059935aefd0de35838afe886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize the server. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; has returned.</source>
          <target state="translated">Процесс &lt;code&gt;gen_statem&lt;/code&gt; вызывает &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; для инициализации сервера. Чтобы гарантировать синхронизированную процедуру запуска, &lt;code&gt;start_link/3,4&lt;/code&gt; не возвращается, пока не вернется &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="238d457fbc3808fc222aef2d6327199e92b50362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3de78075e1ead85abb08c9961b0132a2121787" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">Процесс &lt;code&gt;gen_statem&lt;/code&gt; может перейти в режим гибернации; см. &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; . Это выполняется, когда &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; указывает &lt;code&gt;hibernate&lt;/code&gt; в возвращаемом списке &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; . Эта функция может быть полезна для освобождения памяти кучи процесса, когда ожидается, что сервер будет простаивать в течение длительного времени. Однако используйте эту функцию с осторожностью, так как использование гибернации после каждого события может оказаться слишком дорогостоящим; см. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="881ead844dbebfad51980a814a9a4905aa6bf4c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; завершается аварийно и регистрирует ошибку. &lt;code&gt;Opt&lt;/code&gt; устанавливается на атом &lt;code&gt;terminate&lt;/code&gt; для этого случая.</target>
        </trans-unit>
        <trans-unit id="98d014159aa311c58e42eb49a30b95ce56872c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get-bulk&lt;/code&gt; operation for transferring large amounts of data.</source>
          <target state="translated">Операция &lt;code&gt;get-bulk&lt;/code&gt; для передачи больших объемов данных.</target>
        </trans-unit>
        <trans-unit id="ca7aa99a53f77bb03e023a14cb8a5dfa322719fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;realm&lt;/code&gt; filters cause the Destination-Host and Destination-Realm AVPs to be extracted from the outgoing request, assuming it to be a record- or list-valued &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, and assuming at most one of each AVP. If this is not the case then the &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; filters must be used to achieve the desired result. An empty &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (which should not be typical) matches all hosts/realms for the purposes of filtering.</source>
          <target state="translated">В &lt;code&gt;host&lt;/code&gt; и &lt;code&gt;realm&lt;/code&gt; фильтры вызывают целевого-Host и назначения-Realm AVP , чтобы извлечь из исходящего запроса, при условии , что это будет Запись- или список-значной &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; , и предполагая , самое большее один из каждого AVP. Если это не так, то для достижения желаемого результата необходимо использовать фильтры &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; . Пустой &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (что не должно быть типичным) соответствует всем хостам / областям для целей фильтрации.</target>
        </trans-unit>
        <trans-unit id="1384604d97fc2fad058cb0b49328402f702a9c11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; was successfully decoded but the path contains at least one character with non-UTF-8 encoding. In order to be able to decode this, you have to make assumptions about the encoding used in these triplets. The most obvious choice is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d366d9713f6b9c72596126187499371839fd52b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; module provides short forms for some of the functions used by the graphical Debugger and some of the functions in module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, the Erlang interpreter.</source>
          <target state="translated">Модуль &lt;code&gt;i&lt;/code&gt; предоставляет краткие формы для некоторых функций, используемых графическим отладчиком, и некоторых функций в модуле &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; , интерпретаторе Erlang.</target>
        </trans-unit>
        <trans-unit id="d1d8b2c5a7a92df360a05d4f0b328a8a9dec2469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i_fast_element/2&lt;/code&gt; instruction is faster because the tuple is already an untagged integer. It also knows that the index is at least 1, so it does not have to test for that. The &lt;code&gt;i_element/4&lt;/code&gt; instruction will have to fetch the index from a register, test that it is an integer, and untag the integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe8d3c73461c97195740001f84500385e3636a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i_increment&lt;/code&gt; instruction is implemented like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56dd7d3b9f60436a9a9021776dba220b9a35a843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; header represents the number of unique identifiers under a class when the option &lt;code&gt;{combine, true}&lt;/code&gt; is used (which is on by default). It will otherwise show the specific identifier. The &lt;code&gt;db_tab&lt;/code&gt; listing shows 722287 unique locks, it is one for each ets-table created and Mnesia creates one for each transaction.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; заголовок представляет собой число уникальных идентификаторов под классом , если параметр &lt;code&gt;{combine, true}&lt;/code&gt; используются (который по умолчанию). В противном случае будет отображаться конкретный идентификатор. В листинге &lt;code&gt;db_tab&lt;/code&gt; показано 722287 уникальных блокировок, по одной для каждой созданной таблицы ets, а Mnesia создает по одной для каждой транзакции.</target>
        </trans-unit>
        <trans-unit id="0fc657f0d7c1adea0e37abaf50e5955d09748ddb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; key is mandatory.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; ключ обязателен.</target>
        </trans-unit>
        <trans-unit id="543a86a9dbb014f2154dac485e637aa4987d5f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index()&lt;/code&gt; type denotes an snmp index structure.</source>
          <target state="translated">Тип &lt;code&gt;index()&lt;/code&gt; обозначает структуру индекса snmp.</target>
        </trans-unit>
        <trans-unit id="9e43b2120ef1641713607a20d5663b50e4bfd154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; field of a &lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; record. Can have one of the following types.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; о поле &lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; записи. Может иметь один из следующих типов.</target>
        </trans-unit>
        <trans-unit id="1a3e0c6a3b85d7da20be620618cd94e4069d8c32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; functions return information as a list of pairs {Tag, term()} in some order about the state and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;info&lt;/code&gt; функции возвращают информацию в виде списка пар {Tag, член ()} в некотором порядке о состоянии и &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; в качестве &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1b7238dd78cc738fd7a6138cfed66a0946104d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init:get_arguments()&lt;/code&gt; call verifies that the correct arguments are supplied to the emulator.</source>
          <target state="translated">В &lt;code&gt;init:get_arguments()&lt;/code&gt; проверяет вызов , что правильные аргументы поставляются в эмуляторе.</target>
        </trans-unit>
        <trans-unit id="de26f216cc9cb8c745717da43fc15ae4239618cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">Модуль &lt;code&gt;init&lt;/code&gt; интерпретирует следующие флаги командной строки:</target>
        </trans-unit>
        <trans-unit id="9159e5b3d2da59b16c5905eba93189ce3aa15286" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; process itself interprets some of these flags, the &lt;strong&gt;init flags&lt;/strong&gt;. It also stores any remaining flags, the &lt;strong&gt;user flags&lt;/strong&gt;. The latter can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;.</source>
          <target state="translated">Сам процесс &lt;code&gt;init&lt;/code&gt; интерпретирует некоторые из этих флагов, &lt;strong&gt;флаги инициализации&lt;/strong&gt; . Он также хранит все оставшиеся флаги, &lt;strong&gt;пользовательские флаги&lt;/strong&gt; . Последний можно получить, вызвав &lt;code&gt;init:get_argument/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="808f537737de60102eb2d48a20a77f05a231d51c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init_fun()&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The intention is that this function initiates the encryption or decryption for example by calling &lt;code&gt;crypto:crypto_init/4&lt;/code&gt; or similar. The &lt;code&gt;crypto_state()&lt;/code&gt; is the state such a function may return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00463fc2a7f182be0da0183c5213eee9fd19f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;insert_emp/3&lt;/code&gt; arguments are as follows:</source>
          <target state="translated">В &lt;code&gt;insert_emp/3&lt;/code&gt; аргументы заключаются в следующем:</target>
        </trans-unit>
        <trans-unit id="35e63d83642fa80f496dd6056b90a430ea6b3ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; module has been extended along with the actual I/O protocol to handle Unicode data. This means that many functions require binaries to be in UTF-8, and there are modifiers to format control sequences to allow for output of Unicode strings.</source>
          <target state="translated">Модуль &lt;code&gt;io&lt;/code&gt; был расширен вместе с фактическим протоколом ввода-вывода для обработки данных Unicode. Это означает, что многие функции требуют, чтобы двоичные файлы были в UTF-8, и есть модификаторы для форматирования управляющих последовательностей, позволяющие выводить строки Unicode.</target>
        </trans-unit>
        <trans-unit id="abc6624cbf5af8be037d2670ec76b72f4b7f1113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip&lt;/code&gt; Reference ID takes an &lt;code&gt;inet:ip_address()&lt;/code&gt; or an ip address in string format (E.g &quot;10.0.1.1&quot; or &quot;1234::5678:9012&quot;) as second element.</source>
          <target state="translated">&lt;code&gt;ip&lt;/code&gt; Reference ID принимает &lt;code&gt;inet:ip_address()&lt;/code&gt; или адрес IP в формате строки (например , &quot;10.0.1.1&quot; или &quot;1234 :: 5678: 9012&quot;) в качестве второго элемента.</target>
        </trans-unit>
        <trans-unit id="a7ee8c582d46917ec81790ab0ac53e2589a28393" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is_set_ok&lt;/code&gt; function checks that a row which is to be modified or deleted exists, and that a row which is to be created does not exist.</source>
          <target state="translated">Функция &lt;code&gt;is_set_ok&lt;/code&gt; проверяет, существует ли строка, которая должна быть изменена или удалена, и что строка, которая должна быть создана, не существует.</target>
        </trans-unit>
        <trans-unit id="3f824fe79494e6524fbde8189315044778985916" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jer&lt;/code&gt; encoding rules (ITU-T X.697) are experimental in OTP 22. There is support for a subset of the X.697 standard, for example there is no support for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7f1bbdc59c16a06c62efdccc8b7854b7407424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key()&lt;/code&gt; type correlates to the &lt;code&gt;key_types()&lt;/code&gt; type. If the &lt;code&gt;key_types()&lt;/code&gt; is a single atom, the corresponding &lt;code&gt;key()&lt;/code&gt; is a single type as well, but if the &lt;code&gt;key_types()&lt;/code&gt; is a tuple, &lt;code&gt;key&lt;/code&gt; must be a tuple of the same size.</source>
          <target state="translated">Тип &lt;code&gt;key()&lt;/code&gt; типу &lt;code&gt;key_types()&lt;/code&gt; . Если &lt;code&gt;key_types()&lt;/code&gt; является одним атомом, соответствующий &lt;code&gt;key()&lt;/code&gt; является одним типом, но если &lt;code&gt;key_types()&lt;/code&gt; является кортежем, &lt;code&gt;key&lt;/code&gt; должен быть кортежем того же размера.</target>
        </trans-unit>
        <trans-unit id="5cac72dd809c7185a7dcb83183f4f89c08277c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type defines the types of the SNMP INDEX columns for the table. If the table has one single INDEX column, this type should be a single atom, but if the table has multiple INDEX columns, it should be a tuple with atoms.</source>
          <target state="translated">Тип &lt;code&gt;key_types()&lt;/code&gt; определяет типы столбцов SNMP INDEX для таблицы. Если в таблице есть один столбец INDEX, этот тип должен быть одним атомом, но если таблица имеет несколько столбцов INDEX, это должен быть кортеж с атомами.</target>
        </trans-unit>
        <trans-unit id="a81df154de4b4c4f859872829034600f9ab7e463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type is used when creating the index structure, and the &lt;code&gt;key()&lt;/code&gt; type is used when inserting and deleting items from the structure.</source>
          <target state="translated">Тип &lt;code&gt;key_types()&lt;/code&gt; используется при создании структуры индекса, а тип &lt;code&gt;key()&lt;/code&gt; используется при вставке и удалении элементов из структуры.</target>
        </trans-unit>
        <trans-unit id="555d2dccfadbf0b7e5219e84813fd3bd45eaaf5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keypos&lt;/code&gt; of the table dumped to file, which is used when loading the table again.</source>
          <target state="translated">В &lt;code&gt;keypos&lt;/code&gt; таблицы выгружается в файл, который используется при повторном загрузке таблицы.</target>
        </trans-unit>
        <trans-unit id="f7afe180cd162bc0e597b4a20726157b5ac4e0bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;killproc&lt;/code&gt; procedure is not to be removed. The purpose is here to move from run level 3 (multi-user mode with networking resources) to run level 2 (multi-user mode without such resources), in which Erlang is not to run.</source>
          <target state="translated">Процедуру &lt;code&gt;killproc&lt;/code&gt; удалять нельзя. Цель здесь - перейти от уровня выполнения 3 (многопользовательский режим с сетевыми ресурсами) к уровню выполнения 2 (многопользовательский режим без таких ресурсов), в котором Erlang не должен запускаться.</target>
        </trans-unit>
        <trans-unit id="03c484e3840400c5a5e9dd6a195fc19b5d1faa2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; component is a term which identifies all events belonging to the same sequential trace. If several sequential traces can be active simultaneously, &lt;code&gt;label&lt;/code&gt; is used to identify the separate traces. Default is 0.</source>
          <target state="translated">Компонент &lt;code&gt;label&lt;/code&gt; - это термин, который определяет все события, принадлежащие одной и той же последовательной трассе. Если несколько последовательных трасс могут быть активны одновременно, &lt;code&gt;label&lt;/code&gt; используется для идентификации отдельных трасс. По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="8ada4b47638c77da9291a9bd47140e9b15fe504a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_free&lt;/code&gt; and &lt;code&gt;number_of_free&lt;/code&gt; tags are currently only returned on a VxWorks system.</source>
          <target state="translated">В настоящее время теги &lt;code&gt;largest_free&lt;/code&gt; и &lt;code&gt;number_of_free&lt;/code&gt; возвращаются только в системе VxWorks.</target>
        </trans-unit>
        <trans-unit id="47c985889700e94be33eba8b924bf9a3dfed0540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lcnt&lt;/code&gt; module is used to profile the internal ethread locks in the Erlang Runtime System. With &lt;code&gt;lcnt&lt;/code&gt; enabled, internal counters in the runtime system are updated each time a lock is taken. The counters stores information about the number of acquisition tries and the number of collisions that has occurred during the acquisition tries. The counters also record the waiting time a lock has caused for a blocked thread when a collision has occurred.</source>
          <target state="translated">Модуль &lt;code&gt;lcnt&lt;/code&gt; используется для профилирования внутренних блокировок ethread в системе времени выполнения Erlang. При включенном &lt;code&gt;lcnt&lt;/code&gt; внутренние счетчики в системе времени выполнения обновляются каждый раз, когда выполняется блокировка. Счетчики хранят информацию о количестве попыток захвата и количестве конфликтов, которые произошли во время попыток захвата. Счетчики также регистрируют время ожидания, вызванное блокировкой для заблокированного потока при возникновении конфликта.</target>
        </trans-unit>
        <trans-unit id="b187fc5e5c5e9c948af3fd95dc59f5d10e6fe566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list_in&lt;/code&gt; термин должен принадлежать к среде &lt;code&gt;env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2831975c1bbe04314d3d0e20134569769f4c8e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log_mf_h&lt;/code&gt; handler writes all reports to a report logging directory, which is specified when configuring the SASL application.</source>
          <target state="translated">&lt;code&gt;log_mf_h&lt;/code&gt; обработчик записывает все отчеты в каталог регистрации отчета, который задается при конфигурировании приложения SASL.</target>
        </trans-unit>
        <trans-unit id="c42c9a83ba0cfd927135745afcf8a51d16e0e657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_in&lt;/code&gt; термин должен принадлежать к среде &lt;code&gt;env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4596e3e12adaafb27a37675223c89e5e8290b48e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match_fun&lt;/code&gt; takes two arguments and returns either &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;. The value &lt;code&gt;default&lt;/code&gt; will invoke the default match function.</source>
          <target state="translated">&lt;code&gt;match_fun&lt;/code&gt; принимает два аргумента и возвращает либо &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; или значение по &lt;code&gt;default&lt;/code&gt; . Значение по &lt;code&gt;default&lt;/code&gt; вызовет функцию сопоставления по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8b940d5eaace9d3d7a8384b7f450246290a324ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max_path_length&lt;/code&gt; is the maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if &lt;code&gt;max_path_length&lt;/code&gt; is 0, the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA, ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on.</source>
          <target state="translated">&lt;code&gt;max_path_length&lt;/code&gt; максимального количество неавтомодельных выдано промежуточных сертификатов , которые могут следовать сертификату партнера в правильном пути сертификации. Итак, если &lt;code&gt;max_path_length&lt;/code&gt; равно 0, PEER должен быть подписан доверенным ROOT-CA напрямую, если он равен 1, путь может быть PEER, CA, ROOT-CA, если он равен 2, путь может быть PEER, CA, CA, ROOT-CA и так далее.</target>
        </trans-unit>
        <trans-unit id="38b7f85ec648548ce222a27921a129e6b78760bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mib_to_hrl&lt;/code&gt; generator can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.bin&lt;/code&gt;, and invokes this function for files with that extension.</source>
          <target state="translated">&lt;code&gt;mib_to_hrl&lt;/code&gt; генератор может быть вызван из командной строки операционной системы с помощью команды &lt;code&gt;erlc&lt;/code&gt; . &lt;code&gt;erlc&lt;/code&gt; распознает расширение &lt;code&gt;.bin&lt;/code&gt; и вызывает эту функцию для файлов с этим расширением.</target>
        </trans-unit>
        <trans-unit id="8c1d578ccfe04ced0a4858e6e98da0fd19d29b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mods_and_procs&lt;/code&gt; and &lt;code&gt;funcs_and_procs&lt;/code&gt; filters are equivalent to the &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;functions&lt;/code&gt; filters respectively, except that each module or function can have many vertical lines, one for each process it resides on.</source>
          <target state="translated">В &lt;code&gt;mods_and_procs&lt;/code&gt; и &lt;code&gt;funcs_and_procs&lt;/code&gt; фильтры эквивалентны &lt;code&gt;modules&lt;/code&gt; и &lt;code&gt;functions&lt;/code&gt; фильтров соответственно, за исключением того, что каждый модуль или функция может иметь множество вертикальных линий, по одному для каждого процесса он находится дальше.</target>
        </trans-unit>
        <trans-unit id="629670db402f7cde732ec01282578c7159f3daad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; functions of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">Опция &lt;code&gt;module&lt;/code&gt; позволяет пользователю предоставить свой собственный модуль обратного вызова. Функции &lt;code&gt;receive_message/4&lt;/code&gt; или &lt;code&gt;process_received_message/4&lt;/code&gt; этого модуля вызываются при получении нового сообщения (которое зависит от размера сообщения; small - receive_message, large - process_received_message). Значение по умолчанию - &lt;strong&gt;мегако&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4039dc8c38a872b706a72298a0693bdeed53b2b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The functions &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">Опция &lt;code&gt;module&lt;/code&gt; позволяет пользователю предоставить свой собственный модуль обратного вызова. Функции &lt;code&gt;receive_message/4&lt;/code&gt; или &lt;code&gt;process_received_message/4&lt;/code&gt; этого модуля вызываются при получении нового сообщения (которое зависит от размера сообщения; small - receive_message, large - process_received_message). Значение по умолчанию - &lt;strong&gt;мегако&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1fa747bd68db4bc817397fca349049b0c0c2bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module_info/0&lt;/code&gt; function in each module, returns a list of &lt;code&gt;{Key,Value}&lt;/code&gt; tuples with information about the module. Currently, the list contain tuples with the following &lt;code&gt;Key&lt;/code&gt;s: &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt;, &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;native&lt;/code&gt;. The order and number of tuples may change without prior notice.</source>
          <target state="translated">Функция &lt;code&gt;module_info/0&lt;/code&gt; в каждом модуле возвращает список кортежей &lt;code&gt;{Key,Value}&lt;/code&gt; с информацией о модуле. В настоящее время список содержит кортежи со следующими &lt;code&gt;Key&lt;/code&gt; : &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;attributes&lt;/code&gt; , &lt;code&gt;compile&lt;/code&gt; , &lt;code&gt;exports&lt;/code&gt; , &lt;code&gt;md5&lt;/code&gt; и &lt;code&gt;native&lt;/code&gt; . Порядок и количество кортежей могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="13c3af4d94c692779fc270d51ec8836243a76c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; filter shows each module as a vertical line in the sequence diagram. External function calls/returns are shown as interactions between modules, and internal function calls/returns are shown as activities within a module.</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; фильтр показывает каждый модуль в виде вертикальной линии на диаграмме последовательности. Вызовы / возвраты внешних функций показаны как взаимодействия между модулями, а вызовы / возвраты внутренних функций показаны как действия внутри модуля.</target>
        </trans-unit>
        <trans-unit id="220a661131b4c202e09615fa7794089d54019aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not given, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; ключ не является обязательным. Если он не указан, по умолчанию используется &lt;code&gt;[M]&lt;/code&gt; , где &lt;code&gt;M&lt;/code&gt; происходит от начала дочернего элемента &lt;code&gt;{M,F,A}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3890e0d50c45d6e12a18dbc1aec19b335349f526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; ключ не является обязательным. Если он не указан, по умолчанию используется &lt;code&gt;[M]&lt;/code&gt; , где &lt;code&gt;M&lt;/code&gt; происходит от начала дочернего элемента &lt;code&gt;{M,F,A}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b73b08f6879f5bf7ade5d9880f8cf1f512709fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;native&lt;/code&gt; time unit is determined at runtime system start, and remains the same until the runtime system terminates. If a runtime system is stopped and then started again (even on the same machine), the &lt;code&gt;native&lt;/code&gt; time unit of the new runtime system instance can differ from the &lt;code&gt;native&lt;/code&gt; time unit of the old runtime system instance.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; единицу времени определяется во время выполнения запуска системы, и остается неизменным , пока система выполнения завершает свою работу . Если система времени выполнения остановлена, а затем запущена снова (даже на том же компьютере), &lt;code&gt;native&lt;/code&gt; единица времени нового экземпляра системы времени выполнения может отличаться от &lt;code&gt;native&lt;/code&gt; единицы времени старого экземпляра системы времени выполнения.</target>
        </trans-unit>
        <trans-unit id="e77d232e74f552cf373975f9713b96716de00e8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_kernel&lt;/code&gt; process terminated.</source>
          <target state="translated">Процесс &lt;code&gt;net_kernel&lt;/code&gt; завершен.</target>
        </trans-unit>
        <trans-unit id="33c94a1185ccb7943d79b55ac568ef3bf3963cc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_ticktime&lt;/code&gt; changes must be initiated on all nodes in the network (with the same &lt;code&gt;NetTicktime&lt;/code&gt;) before the end of any transition period on any node; otherwise connections can erroneously be disconnected.</source>
          <target state="translated">Изменения &lt;code&gt;net_ticktime&lt;/code&gt; должны быть инициированы на всех узлах в сети (с одинаковым &lt;code&gt;NetTicktime&lt;/code&gt; ) до окончания любого переходного периода на любом узле; в противном случае соединения могут быть отключены по ошибке.</target>
        </trans-unit>
        <trans-unit id="88d35276b805d419b7b2b451eec9f43dfbe3fb9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;reuse&lt;/code&gt; options might seem convenient in a production system, but consider that the logs grow indefinitely during the system lifetime and cannot be truncated, except if the service is restarted.</source>
          <target state="translated">В &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;reuse&lt;/code&gt; опция может показаться удобной в производственной системе, но считает , что журналы неограниченно расти в течение всего срока службы системы и не могут быть усечены, за исключением , если услуга будет перезапущена.</target>
        </trans-unit>
        <trans-unit id="ffcaa93ee15ba09c39cb246f4b83efb0388fde54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates a new variable in the database with a default value as defined in the MIB, or a zero value (depending on the type).</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; функция создает новую переменную в базе данных со значением по умолчанию , как определено в MIB, или нулевое значение ( в зависимости от типа).</target>
        </trans-unit>
        <trans-unit id="2000d16d511f7d3865cad4dec402c68d50d75e6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates the table if it does not exist, but only if the database is the SNMP internal db.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; функция создает таблицу , если она не существует, но только если база данных является внутренней БД SNMP.</target>
        </trans-unit>
        <trans-unit id="2d170f32fbd322133bb3d50a0e41f54d86fe7d23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, as in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe241cbaac0cb96b60c93ae96dc9889cf2b5f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="translated">Модуль &lt;code&gt;nteventlog&lt;/code&gt; используется для реализации &lt;code&gt;os_sup&lt;/code&gt; . См. &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что функции запуска &lt;code&gt;nteventlog&lt;/code&gt; использовать не нужно, в этом случае процесс запускается автоматически как часть дерева наблюдения OS_Mon.</target>
        </trans-unit>
        <trans-unit id="e2bfdbeebfa5a9fe7cf75fe729c76e05070db8fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is a pointer to the resource. The only allowed use for the resource in the destructor is to access its user data one final time. The destructor is guaranteed to be the last callback before the resource is deallocated.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; аргумент является указателем на ресурс. Единственное разрешенное использование ресурса в деструкторе - это последний раз получить доступ к его пользовательским данным. Деструктор гарантированно будет последним обратным вызовом перед освобождением ресурса.</target>
        </trans-unit>
        <trans-unit id="7ceb6922f1bc2b55a11a196aefd83fd27d2d6cd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator returns &lt;code&gt;false&lt;/code&gt; if no chain of calls between the given constants can be found.</source>
          <target state="translated">Оператор &lt;code&gt;of&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; , если цепочка вызовов между заданными константами не может быть найдена.</target>
        </trans-unit>
        <trans-unit id="edc8f1a9759344cda2be6a01281eb7cf8541e7d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;after&lt;/code&gt; sections are all optional, as long as there is at least a &lt;code&gt;catch&lt;/code&gt; or an &lt;code&gt;after&lt;/code&gt; section. So the following are valid &lt;code&gt;try&lt;/code&gt; expressions:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , и &lt;code&gt;after&lt;/code&gt; того, как секции являются необязательными, до тех пор , пока существует , по меньшей мере &lt;code&gt;catch&lt;/code&gt; или &lt;code&gt;after&lt;/code&gt; раздела. Итак, следующие допустимые выражения &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ebc057ad457a36d0493c7c4827deec0d89f9db4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid()&lt;/code&gt; type is used to represent an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">Тип &lt;code&gt;oid()&lt;/code&gt; используется для представления ИДЕНТИФИКАТОРА ОБЪЕКТА ASN.1.</target>
        </trans-unit>
        <trans-unit id="c317ddfbc946c81f789ac77305cd9d495bd67257" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ordered_set&lt;/code&gt; works on the &lt;strong&gt;Erlang term order&lt;/strong&gt; and no defined order exists between an &lt;code&gt;integer()&lt;/code&gt; and a &lt;code&gt;float()&lt;/code&gt; that extends to the same value. Hence the key &lt;code&gt;1&lt;/code&gt; and the key &lt;code&gt;1.0&lt;/code&gt; are regarded as equal in an &lt;code&gt;ordered_set&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;ordered_set&lt;/code&gt; работает на &lt;strong&gt;срок порядка Эрланга&lt;/strong&gt; и не определен порядок не существует между &lt;code&gt;integer()&lt;/code&gt; и &lt;code&gt;float()&lt;/code&gt; , которая простирается на ту же величину. Следовательно, ключ &lt;code&gt;1&lt;/code&gt; и ключ &lt;code&gt;1.0&lt;/code&gt; считаются равными в таблице &lt;code&gt;ordered_set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f84a949184c1de5bc030233161e9c4c0b92121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;originating&lt;/code&gt; options effects discovery initiated by this agent.</source>
          <target state="translated">&lt;code&gt;originating&lt;/code&gt; открытие варианты эффектов инициировано этот агент.</target>
        </trans-unit>
        <trans-unit id="ccd973135b90cc097810c0c2b724141ea8487e4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; syntax:</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; синтаксис:</target>
        </trans-unit>
        <trans-unit id="8bdd7004ea407fa82763663af39ba15a0e1f25f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; tool utilizes the &lt;code&gt;runtime_dependencies&lt;/code&gt; tag in the &lt;code&gt;application resource file&lt;/code&gt;. This information is used to determine if the patch can be installed in the given Erlang/OTP installation directory.</source>
          <target state="translated">Инструмент &lt;code&gt;otp_patch_apply&lt;/code&gt; использует тег &lt;code&gt;runtime_dependencies&lt;/code&gt; в &lt;code&gt;application resource file&lt;/code&gt; . Эта информация используется, чтобы определить, можно ли установить исправление в указанном каталоге установки Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="8315d03358900e027c0447a981ac995840fffee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;output&lt;/code&gt; function allocates the work area of the asynchronous function. As we use C++, we use a struct, and stuff the data in it. We must copy the original data, it is not valid after we have returned from the &lt;code&gt;output&lt;/code&gt; function, and the &lt;code&gt;do_perm&lt;/code&gt; function is called later, and from another thread. We return no data here, instead it is sent later from the &lt;code&gt;ready_async&lt;/code&gt; callback.</source>
          <target state="translated">Функция &lt;code&gt;output&lt;/code&gt; выделяет рабочую область асинхронной функции. Поскольку мы используем C ++, мы используем структуру и помещаем в нее данные. Мы должны скопировать исходные данные, они недействительны после того, как мы вернулись из функции &lt;code&gt;output&lt;/code&gt; , а функция &lt;code&gt;do_perm&lt;/code&gt; вызывается позже и из другого потока. Здесь мы не возвращаем никаких данных, вместо этого они отправляются позже из обратного вызова &lt;code&gt;ready_async&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71aa4ffe227f9aa33da51854c389c54a822efeef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse&lt;/code&gt; format is an internal representation that can be passed to &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt;, while the &lt;code&gt;forms&lt;/code&gt; format can be passed to &lt;code&gt;compile:forms/2&lt;/code&gt;. The &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;hrl&lt;/code&gt; formats are returned as iolists.</source>
          <target state="translated">Формат &lt;code&gt;parse&lt;/code&gt; - это внутреннее представление, которое можно передать в &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt; , а формат &lt;code&gt;forms&lt;/code&gt; можно передать в &lt;code&gt;compile:forms/2&lt;/code&gt; . В &lt;code&gt;erl&lt;/code&gt; и &lt;code&gt;hrl&lt;/code&gt; форматы возвращаются как iolists.</target>
        </trans-unit>
        <trans-unit id="9ac6e1b83188e6ba00253b80c4e4e283b31e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; option is used for pointing out the old version of all applications. (The new versions are already in the code path - assuming of course that the Erlang node on which this is executed is running the correct version of Erlang/OTP.)</source>
          <target state="translated">Параметр &lt;code&gt;path&lt;/code&gt; используется для указания старой версии всех приложений. (Новые версии уже находятся в пути кода - конечно, при условии, что узел Erlang, на котором это выполняется, выполняет правильную версию Erlang / OTP.)</target>
        </trans-unit>
        <trans-unit id="24e00a9507fa707a286aad7abe3e3cd07325080a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pending_driver&lt;/code&gt;&lt;code&gt;MonitorOption&lt;/code&gt; is by far the most useful. It must be used to ensure that the driver really is unloaded and the ports closed whenever option &lt;code&gt;kill_ports&lt;/code&gt; is used, or the driver can have been loaded with driver option &lt;code&gt;kill_ports&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pending_driver&lt;/code&gt; &lt;code&gt;MonitorOption&lt;/code&gt; на сегодняшний день является наиболее полезным. Его необходимо использовать, чтобы гарантировать, что драйвер действительно выгружен, а порты закрыты всякий раз, когда используется опция &lt;code&gt;kill_ports&lt;/code&gt; , или драйвер мог быть загружен с опцией драйвера &lt;code&gt;kill_ports&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7752015e6089336570fa00078221b8ccabc19aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt; os:perf_counter/0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36e06928220660615452de6fef2258f5362fc89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt;os:perf_counter/0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perf_counter&lt;/code&gt; единица времени ведет себя точно так же , как и &lt;code&gt;native&lt;/code&gt; единицу времени. То есть он может отличаться между перезапусками среды выполнения. Чтобы получить значения этого типа, вызовите &lt;code&gt;os:perf_counter/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b9f8d1ef7145eb704be87bd7e74e2fde38ff315" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg2&lt;/code&gt; module is deprecated as of OTP 23 and scheduled for removal in OTP 24. You are advised to replace the usage of &lt;code&gt;pg2&lt;/code&gt; with &lt;code&gt;pg&lt;/code&gt;. &lt;code&gt;pg&lt;/code&gt; has a similar API, but with an implementation that is more scalable. See the documentation of &lt;code&gt;pg&lt;/code&gt; for more information about differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ddb3f0153c3890640ae834ac81e6898f916068" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; parameter is a pointer to a &lt;code&gt;erlang_pid&lt;/code&gt; that the function will update with the pid associated with the global name, if successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff6f3b7d18bc68a03a8f098e3306bea8afa3388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pread/3,4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">Функция &lt;code&gt;pread/3,4&lt;/code&gt; читает из указанной позиции, комбинируя функции &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5e46480f01a8aa86737f226ba56bdcb171312f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; fields in the elements of the list contain the value of the pointer, a modification marker, and a deleted marker. Memory operations on these fields are done using atomic memory operations. When a thread has set the modification marker in a field, no-one except the thread that set the marker is allowed to modify the field. If multiple modification markers need to be set, we always begin with &lt;code&gt;next&lt;/code&gt; fields followed by &lt;code&gt;prev&lt;/code&gt; fields in the order following the actual pointers. This guarantees that no deadlocks will occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ade504b785b0942df35eaf3b82afa6476a54cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended it does so in a structured manner.</source>
          <target state="translated">В &lt;code&gt;priv&lt;/code&gt; хранятся ресурсы, необходимые приложению во время выполнения. Исполняемые файлы должны находиться в &lt;code&gt;priv/bin&lt;/code&gt; , а динамически подключаемые библиотеки - в &lt;code&gt;priv/lib&lt;/code&gt; . Другие ресурсы могут свободно размещаться в каталоге &lt;code&gt;priv&lt;/code&gt; , но рекомендуется делать это структурированным образом.</target>
        </trans-unit>
        <trans-unit id="6b2507225c4f70efae176a5a0a6b4b0633e1f261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended they do so in a structured manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a744587962b51e3c606263db57ff07f274e44a97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;processes&lt;/code&gt; filter is the only filter showing all trace messages from a trace log. Each vertical line in the sequence diagram represents a process. Erlang messages, spawn, and link/unlink are typical interactions between processes. Function calls, scheduling, and garbage collection, are typical activities within a process. &lt;code&gt;processes&lt;/code&gt; is the default filter.</source>
          <target state="translated">&lt;code&gt;processes&lt;/code&gt; фильтра является только фильтр , показывающий все сообщения трассировки из журнала трассировки. Каждая вертикальная линия на диаграмме последовательности представляет процесс. Сообщения Erlang, порождение и связывание / отключение - типичные взаимодействия между процессами. Вызов функций, планирование и сборка мусора - типичные действия в рамках процесса. &lt;code&gt;processes&lt;/code&gt; - фильтр по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3861f99e16c84fe5707ca3129e815480d2eca579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pwrite/3,4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">Функция &lt;code&gt;pwrite/3,4&lt;/code&gt; записывает в указанную позицию, комбинируя функции &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4939b64de1d53ed04f7d5997288438bc45d2be8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module evaluates this differently depending on the query handles &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;. If, for example, &lt;code&gt;X2&lt;/code&gt; is matched against the key of a QLC table, the lookup join method traverses the objects of &lt;code&gt;QH2&lt;/code&gt; while looking up key values in the table. However, if not &lt;code&gt;X2&lt;/code&gt; or &lt;code&gt;Y2&lt;/code&gt; is matched against the key or an indexed position of a QLC table, the merge join method ensures that &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; are both sorted on position 2 and next do the join by traversing the objects one by one.</source>
          <target state="translated">Модуль &lt;code&gt;qlc&lt;/code&gt; оценивает это по-разному в зависимости от &lt;code&gt;QH1&lt;/code&gt; запросов QH1 и &lt;code&gt;QH2&lt;/code&gt; . Если, например, &lt;code&gt;X2&lt;/code&gt; сопоставляется с ключом таблицы QLC, метод соединения с поиском проходит по объектам &lt;code&gt;QH2&lt;/code&gt; при поиске значений ключа в таблице. Однако, если не &lt;code&gt;X2&lt;/code&gt; или &lt;code&gt;Y2&lt;/code&gt; сопоставляются с ключом или индексированной позицией таблицы QLC, метод объединения слиянием гарантирует, что &lt;code&gt;QH1&lt;/code&gt; и &lt;code&gt;QH2&lt;/code&gt; оба сортируются в позиции 2, а затем выполняется соединение, просматривая объекты один за другим.</target>
        </trans-unit>
        <trans-unit id="7bdc283a4e0d387d9b4fe3c9cce9b3813bddfd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module supports fast join of two query handles. Fast join is possible if some position &lt;code&gt;P1&lt;/code&gt; of one query handler and some position &lt;code&gt;P2&lt;/code&gt; of another query handler are tested for equality. Two fast join methods are provided:</source>
          <target state="translated">Модуль &lt;code&gt;qlc&lt;/code&gt; поддерживает быстрое соединение двух обработчиков запросов. Быстрое соединение возможно, если некоторая позиция &lt;code&gt;P1&lt;/code&gt; одного обработчика запроса и некоторая позиция &lt;code&gt;P2&lt;/code&gt; другого обработчика запроса проверяются на равенство. Предусмотрены два метода быстрого соединения:</target>
        </trans-unit>
        <trans-unit id="4dc69ce9649099f1a16568929e4dca5a9ec4a8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module warns at compile time if a QLC combines query handles in such a way that more than one join is possible. That is, no query planner is provided that can select a good order between possible join operations. It is up to the user to order the joins by introducing query handles.</source>
          <target state="translated">Модуль &lt;code&gt;qlc&lt;/code&gt; предупреждает во время компиляции, если QLC объединяет дескрипторы запросов таким образом, что возможно более одного соединения. То есть не предусмотрен планировщик запросов, который мог бы выбрать правильный порядок между возможными операциями соединения. Пользователь может упорядочить объединения, введя дескрипторы запросов.</target>
        </trans-unit>
        <trans-unit id="1ac4329d09995d8cc50dafbae48fcd60ee3ef172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re&lt;/code&gt; module allows for matching Unicode strings as a special option. As the library is centered on matching in binaries, the Unicode support is UTF-8-centered.</source>
          <target state="translated">Модуль &lt;code&gt;re&lt;/code&gt; позволяет в качестве специальной опции сопоставлять строки Unicode. Поскольку библиотека ориентирована на сопоставление в двоичных файлах, поддержка Unicode ориентирована на UTF-8.</target>
        </trans-unit>
        <trans-unit id="412cfcfb79171f8451db72dbfc6769aeeae48e5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_ahead&lt;/code&gt; buffer is also highly used by function &lt;code&gt;read_line/1&lt;/code&gt; in &lt;code&gt;raw&lt;/code&gt; mode, therefore this option is recommended (for performance reasons) when accessing raw files using that function.</source>
          <target state="translated">&lt;code&gt;read_ahead&lt;/code&gt; буфер также высоко используется функция &lt;code&gt;read_line/1&lt;/code&gt; в &lt;code&gt;raw&lt;/code&gt; режиме, поэтому этот вариант рекомендуется (из соображений производительности) при доступе необработанных файлов с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="1d7e68fecfc79e8020cc09ac14cad9865216cb67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready_io&lt;/code&gt; function is called when the socket we got from postgres is ready for input or output. Here we first check if we are connecting to the database. In that case, we check connection status and return OK if the connection is successful, or error if it is not. If the connection is not yet established, we simply return; &lt;code&gt;ready_io&lt;/code&gt; is called again.</source>
          <target state="translated">Функция &lt;code&gt;ready_io&lt;/code&gt; вызывается, когда сокет, который мы получили от postgres, готов к вводу или выводу. Здесь мы сначала проверяем, подключаемся ли мы к базе данных. В этом случае мы проверяем статус подключения и возвращаем ОК, если подключение успешно, или ошибку, если нет. Если соединение еще не установлено, просто возвращаемся; &lt;code&gt;ready_io&lt;/code&gt; вызывается снова.</target>
        </trans-unit>
        <trans-unit id="c5f336c46236fef6d33a9737fecfbc45848cc85a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; construct is used to allow processes to wait for messages from other processes. It has the following format:</source>
          <target state="translated">Конструкция &lt;code&gt;receive&lt;/code&gt; используется, чтобы позволить процессам ждать сообщений от других процессов. Он имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="37481113af1fc6bf67ec51a1b4573b5766d4940d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; expression can be augmented with a timeout:</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; выражение может быть увеличена с помощью тайм - аута:</target>
        </trans-unit>
        <trans-unit id="42725fa1b02c7390bf310c7b5f650def33047bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receiver&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; будет первым выслан &lt;code&gt;snmp_targets&lt;/code&gt; сообщения, а затем для каждого адреса в &lt;code&gt;Addresses&lt;/code&gt; список, один из двух &lt;code&gt;snmp_notification&lt;/code&gt; сообщений.</target>
        </trans-unit>
        <trans-unit id="d783190c30a4c184095fc9fe7326cabca7bed37e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt; driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt; driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt; driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e35f7f5fad0e5d56316957219823696de6e6786c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поле &lt;code&gt;refc&lt;/code&gt; было удалено. Счетчик ссылок &lt;code&gt;ErlDrvBinary&lt;/code&gt; теперь хранится в другом месте. Доступ к &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt; ссылок &lt;code&gt;ErlDrvBinary&lt;/code&gt; можно получить через driver_binary_get_refc , &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82f0b91245f77a3b886c273dd05b9767b42d775d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registry&lt;/code&gt; functionality part of &lt;code&gt;erl_interface&lt;/code&gt; is as of &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; and will be removed in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660ed54d5ac1fcd2169600b38b40bd925d66cf86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_handler&lt;/code&gt; copies these files to the &lt;code&gt;bin&lt;/code&gt; directory in the client directory at the master nodes whenever a new release is made permanent.</source>
          <target state="translated">В &lt;code&gt;release_handler&lt;/code&gt; копирует эти файлы в &lt;code&gt;bin&lt;/code&gt; каталог в каталоге клиента на основных узлах , когда новый релиз становится постоянным.</target>
        </trans-unit>
        <trans-unit id="56830d582041a2d058cd8b9ca80ec725e5c3e287" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reload&lt;/code&gt; option can be either of the following:</source>
          <target state="translated">Вариант &lt;code&gt;reload&lt;/code&gt; может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="207c0a4a6dd7d54555e6c470a0c170ec46378f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains instructions for how to upgrade to, or downgrade from, this version of the release.</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; файл содержит инструкции о том , как обновить или понижена с, этой версии выпуска.</target>
        </trans-unit>
        <trans-unit id="eb051013f36a233ac41b404b8075c071558087a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade the release. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; файл содержит один единственный член Erlang, который определяет инструкцию , используемую для обновления выпуска. Файл имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="d56076bd8991e00d489d3da464bc1ef66915e244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply_timer&lt;/code&gt; eventually times out.</source>
          <target state="translated">Время &lt;code&gt;reply_timer&lt;/code&gt; истекает.</target>
        </trans-unit>
        <trans-unit id="3918ee266b06587588695e693fc72ac650418ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;permanent&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;restart&lt;/code&gt; ключ не является обязательным. Если он не указан, будет использоваться &lt;code&gt;permanent&lt;/code&gt; значение по умолчанию .</target>
        </trans-unit>
        <trans-unit id="aa12db49496616557ec440b620daa191bf27cdc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;restart&lt;/code&gt; ключ не является обязательным. Если он не указан, по умолчанию используется &lt;code&gt;permanent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a92effc8d3efc4277861eec34f0f1caed07816" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction must always be the first instruction in a relup. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">&lt;code&gt;restart_new_emulator&lt;/code&gt; инструкция всегда должна быть первой инструкцией в relup. Если повторная установка создается с помощью &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; , это обеспечивается автоматически.</target>
        </trans-unit>
        <trans-unit id="11d3f640ffec2cfdf0c8a6e928ab7cecff319eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_erl&lt;/code&gt; program is specific to Unix systems. This program redirects the standard input and standard output streams so that all output can be logged. It also lets the program &lt;code&gt;to_erl&lt;/code&gt; connect to the Erlang console, making it possible to monitor and debug an embedded system remotely.</source>
          <target state="translated">Программа &lt;code&gt;run_erl&lt;/code&gt; специфична для систем Unix. Эта программа перенаправляет потоки стандартного ввода и вывода, чтобы можно было регистрировать весь вывод. Он также позволяет программе &lt;code&gt;to_erl&lt;/code&gt; подключаться к консоли Erlang, что позволяет удаленно отслеживать и отлаживать встроенную систему.</target>
        </trans-unit>
        <trans-unit id="750c30ae5ba824b2f2aab4a171c99b419364a053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime_dependencies&lt;/code&gt; key was introduced in OTP 17.0. The type of its value might be subject to changes during the OTP 17 release.</source>
          <target state="translated">&lt;code&gt;runtime_dependencies&lt;/code&gt; ключ был введен в OTP 17,0. Тип его значения может быть изменен во время выпуска OTP 17.</target>
        </trans-unit>
        <trans-unit id="c0fc6c1e3ca6659e674892c5855367c57b82e3b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt; Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d8491d2a1375817a9cf2b814c2646acf960284" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Приложение &lt;code&gt;sasl&lt;/code&gt; включает в себя пример модуля Erlang &lt;code&gt;target_system.erl&lt;/code&gt; , который содержит функции для создания и установки целевой системы. Этот модуль используется в следующих примерах. Исходный код модуля указан в &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3906ed9fb14f8072e02da2d35e2b47f21b0a6292" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; expression matches all entries in table employee with the field &lt;code&gt;sex&lt;/code&gt; set to &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; выражение соответствует записи в таблице работника с поля &lt;code&gt;sex&lt;/code&gt; набор в &lt;code&gt;female&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d221358022dcaa2231dd0fa112459ee9f7e4a5b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select_ref()&lt;/code&gt; is the same as was received in the &lt;code&gt;&lt;a href=&quot;socket#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5c2c9e1f5cbdb80c6a7e6b52821b6b12fa676f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; flags enable tracing of all messages sent and received by the process/port. Trace patterns set with &lt;code&gt;tpe&lt;/code&gt; may limit traced messages based on the message content, the sender, and/or the receiver.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; и &lt;code&gt;'receive'&lt;/code&gt; флаги трассировку всех сообщений , отправленных и полученных процессом / порт. Шаблоны трассировки, установленные с помощью &lt;code&gt;tpe&lt;/code&gt; , могут ограничивать отслеживаемые сообщения в зависимости от содержимого сообщения, отправителя и / или получателя.</target>
        </trans-unit>
        <trans-unit id="0233a943ab6f52106ec90bb0ab714ed2cd9deb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; call does not accept a time-out option because time-outs on send is handled through socket option &lt;code&gt;send_timeout&lt;/code&gt;. The behavior of a send operation with no receiver is mainly defined by the underlying TCP stack and the network infrastructure. To write code that handles a hanging receiver that can eventually cause the sender to hang on a &lt;code&gt;send&lt;/code&gt; do like the following.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; вызова не принимает параметр тайм-аут из - за тайм-аута на посыла осуществляется через опции сокета &lt;code&gt;send_timeout&lt;/code&gt; . Поведение операции отправки без получателя в основном определяется лежащим в основе стеком TCP и сетевой инфраструктурой. Чтобы написать код, обрабатывающий зависший получатель, который в конечном итоге может привести к зависанию &lt;code&gt;send&lt;/code&gt; при отправке, выполните следующие действия.</target>
        </trans-unit>
        <trans-unit id="bdcf831f5f9a895f78c5ead8d39eb67c53d11a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_notification/6&lt;/code&gt; function is the most general version of the function. A &lt;code&gt;ContextName&lt;/code&gt; must be specified, from which the notification will be sent. If this parameter is not specified, the default context (&lt;code&gt;&quot;&quot;&lt;/code&gt;) is used.</source>
          <target state="translated">Функция &lt;code&gt;send_notification/6&lt;/code&gt; - это наиболее общая версия функции. Необходимо &lt;code&gt;ContextName&lt;/code&gt; , из которого будет отправляться уведомление. Если этот параметр не указан, используется контекст по умолчанию ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e10004941e2f7c2be1fb735798912ba806d773f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_out_queue&lt;/code&gt; routine is as follows:</source>
          <target state="translated">Процедура &lt;code&gt;send_out_queue&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="843b939f65952e899d6ea657ca1ebe102c72dbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;server&lt;/code&gt; module corresponds, greatly simplified, to the Erlang/OTP behaviour &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">На &lt;code&gt;server&lt;/code&gt; модуль соответствует, значительно упрощена, к поведению Эрланга / OTP &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eede287bf30328bbe010a8372b63b7607963a54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; commands modifies or adds an Erlang service, respectively. The simplest form of an &lt;code&gt;add&lt;/code&gt; command is without any options in which case all default values (described above) apply. The service name is mandatory.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; и &lt;code&gt;add&lt;/code&gt; команды модифицирует или добавляет службу Эрланга, соответственно. Самая простая форма команды &lt;code&gt;add&lt;/code&gt; - без каких-либо параметров, и в этом случае применяются все значения по умолчанию (описанные выше). Имя службы обязательно.</target>
        </trans-unit>
        <trans-unit id="7d5aec8c53556f4c4632141415f220fd68b8daa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function checks if it has enough information to make the row change its status from &lt;code&gt;notReady&lt;/code&gt; to &lt;code&gt;notInService&lt;/code&gt; (when a row has been been set to &lt;code&gt;createAndWait&lt;/code&gt;). If a row is set to &lt;code&gt;createAndWait&lt;/code&gt;, columns without a value are set to &lt;code&gt;noinit&lt;/code&gt;. If Mnesia is used, the set functionality is handled within a transaction.</source>
          <target state="translated">Функция &lt;code&gt;set&lt;/code&gt; проверяет, достаточно ли информации, чтобы строка изменила свой статус с &lt;code&gt;notReady&lt;/code&gt; на &lt;code&gt;notInService&lt;/code&gt; (когда для строки задано значение &lt;code&gt;createAndWait&lt;/code&gt; ). Если для строки задано значение &lt;code&gt;createAndWait&lt;/code&gt; , столбцы без значения устанавливаются на &lt;code&gt;noinit&lt;/code&gt; . Если используется Mnesia, установленные функции обрабатываются в рамках транзакции.</target>
        </trans-unit>
        <trans-unit id="dffce6a86883fb98a441ee618f3e33a10bd8dd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_on_spawn&lt;/code&gt; option will active call time tracing for all processes spawned by processes in the rootset. This is the default behaviour.</source>
          <target state="translated">Параметр &lt;code&gt;set_on_spawn&lt;/code&gt; будет активировать отслеживание времени вызова для всех процессов, порожденных процессами в корневом наборе. Это поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d7ea8237fdbb6c1e6e9cad779100829368078340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not given, and the child is of type &lt;code&gt;worker&lt;/code&gt;, the default value &lt;code&gt;5000&lt;/code&gt; will be used; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;, the default value &lt;code&gt;infinity&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; ключ не является обязательным. Если он не указан, и дочерний элемент имеет тип &lt;code&gt;worker&lt;/code&gt; , будет использоваться значение по умолчанию &lt;code&gt;5000&lt;/code&gt; ; если дочерний элемент относится к типу &lt;code&gt;supervisor&lt;/code&gt; , будет использоваться значение по умолчанию &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cb49de51c4b23fb4081f3a3f48b32fd97395704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;5000&lt;/code&gt; if the child is of type &lt;code&gt;worker&lt;/code&gt; and it defaults to &lt;code&gt;infinity&lt;/code&gt; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; ключ не является обязательным. Если он не указан, по умолчанию используется значение &lt;code&gt;5000&lt;/code&gt; , если дочерний элемент имеет тип &lt;code&gt;worker&lt;/code&gt; , и значение по умолчанию &lt;code&gt;infinity&lt;/code&gt; если дочерний элемент относится к типу &lt;code&gt;supervisor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38a6562eb72c50374e4148dda56f4f2798a51836" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silent&lt;/code&gt; trace flag facilitates setting up a trace on many or even all processes in the system. The trace can then be activated and deactivated using the match specification function &lt;code&gt;{silent,Bool}&lt;/code&gt;, giving a high degree of control of which functions with which arguments that trigger the trace.</source>
          <target state="translated">&lt;code&gt;silent&lt;/code&gt; флаг трассировки облегчает создание след на многих или даже всех процессов в системе. Затем трассировку можно активировать и деактивировать с помощью функции спецификации соответствия &lt;code&gt;{silent,Bool}&lt;/code&gt; , что дает высокую степень контроля над тем, какие функции с какими аргументами запускают трассировку.</target>
        </trans-unit>
        <trans-unit id="57bdb45fe915c31143be502180221ee741783591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field changed from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">Поле &lt;code&gt;size&lt;/code&gt; изменено с подписанного на беззнаковое. Это может вызвать проблемы, например, для условий завершения цикла или условий ошибки, если вы меняете только типы повсюду.</target>
        </trans-unit>
        <trans-unit id="240a989a5bf707c990bcb78e115aed91f3f04714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field in &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; has been changed to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from &lt;code&gt;int&lt;/code&gt;. Check all code that use that field.</source>
          <target state="translated">Поле &lt;code&gt;size&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; было изменено на &lt;code&gt;ErlDrvSizeT&lt;/code&gt; с &lt;code&gt;int&lt;/code&gt; . Проверьте весь код, который использует это поле.</target>
        </trans-unit>
        <trans-unit id="a337f162f4c8e035168099f55089fef2894d81f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; directory could be useful to release for debugging purposes but is not required. The &lt;code&gt;include&lt;/code&gt; directory should only be released if the applications has public include files.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; каталог может быть полезным , чтобы освободить для отладки , но не требуется. &lt;code&gt;include&lt;/code&gt; каталог должен быть выпущен только в том случае , если приложения имеют общественные включаемые файлы.</target>
        </trans-unit>
        <trans-unit id="fc13993adad718eae8701221afde4693b532449e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssh&lt;/code&gt; application is an implementation of the SSH Transport, Connection and Authentication Layer Protocols in Erlang. It provides the following:</source>
          <target state="translated">Приложение &lt;code&gt;ssh&lt;/code&gt; - это реализация протоколов SSH транспортного уровня, уровня подключения и аутентификации в Erlang. Он обеспечивает следующее:</target>
        </trans-unit>
        <trans-unit id="1b351d65a63d0aa90f08b7937079a25c6920290a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssl_passive&lt;/code&gt; message is sent only when the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode and the counter dropped to 0. It indicates that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f65d2a2ea4f4fd44a5c098586ac285ac95cdefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; commands communicates with the service manager for starting and stopping a service. The commands wait until the service is started or stopped. When disabling a service, it is not stopped, the disabled state does not take effect until the service is stopped. Enabling a service sets it in automatic mode, which is started at boot. This command cannot set the service to manual.</source>
          <target state="translated">На &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; - команд связывается с менеджером службы для запуска и остановки службы. Команды ждут, пока служба не будет запущена или остановлена. При отключении службы она не останавливается, отключенное состояние не вступает в силу, пока служба не будет остановлена. Включение службы переводит ее в автоматический режим, который запускается при загрузке. Эта команда не может установить сервис в ручной режим.</target>
        </trans-unit>
        <trans-unit id="d1f3d732c30aec74a57c16dda04003bb1543c716" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; entry is called when the driver is opened as a port with &lt;code&gt;open_port/2&lt;/code&gt;. Here we allocate memory for a user data structure. This user data is passed every time the emulator calls us. First we store the driver handle, as it is needed in later calls. We allocate memory for the connection handle that is used by LibPQ. We also set the port to return allocated driver binaries, by setting flag &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, calling &lt;code&gt;set_port_control_flags&lt;/code&gt;. (This is because we do not know if our data will fit in the result buffer of &lt;code&gt;control&lt;/code&gt;, which has a default size, 64 bytes, set up by the emulator.)</source>
          <target state="translated">Запись &lt;code&gt;start&lt;/code&gt; вызывается, когда драйвер открывается как порт с &lt;code&gt;open_port/2&lt;/code&gt; . Здесь мы выделяем память для пользовательской структуры данных. Эти пользовательские данные передаются каждый раз, когда эмулятор вызывает нас. Сначала мы сохраняем дескриптор драйвера, так как он понадобится в последующих вызовах. Мы выделяем память для дескриптора соединения, который используется LibPQ. Мы также устанавливаем порт для возврата выделенных двоичных файлов драйверов, установив флаг &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; , вызывая &lt;code&gt;set_port_control_flags&lt;/code&gt; . (Это потому, что мы не знаем, поместятся ли наши данные в буфер результатов элемента &lt;code&gt;control&lt;/code&gt; , размер которого по умолчанию составляет 64 байта, установленный эмулятором.)</target>
        </trans-unit>
        <trans-unit id="f756fe51eb87c21305c2536fa74b5434575da4c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; key is mandatory.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; ключ обязателен.</target>
        </trans-unit>
        <trans-unit id="7a89df12694a55231dbe9df289731067f34bf0ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; program is called when the machine is started.</source>
          <target state="translated">Программа &lt;code&gt;start&lt;/code&gt; вызывается при запуске машины.</target>
        </trans-unit>
        <trans-unit id="34d8bb2f8c095328e05b319382abf621840539e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is an example script on how to start up the Erlang system in embedded mode on Unix.</source>
          <target state="translated">Сценарий &lt;code&gt;start&lt;/code&gt; - это пример сценария того, как запустить систему Erlang во встроенном режиме в Unix.</target>
        </trans-unit>
        <trans-unit id="c9b5982012fe67cdfffd9b71b0eeb41c6d062f31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is to be edited accordingly.</source>
          <target state="translated">Соответственно отредактировать &lt;code&gt;start&lt;/code&gt; сценарий.</target>
        </trans-unit>
        <trans-unit id="31e73008fe878f9797af9d091c4fba4b24889e97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_disabled&lt;/code&gt; command operates on a service regardless of if it is enabled/disabled or started/stopped. It does this by first enabling it (regardless of if it is enabled or not), then starting it (if not already started), and then disabling it. The result is a disabled but started service, regardless of its earlier state. This is useful for starting services temporarily during a release upgrade. The difference between using &lt;code&gt;start_disabled&lt;/code&gt; and the sequence &lt;code&gt;enable&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;disable&lt;/code&gt; is that all other &lt;code&gt;erlsrv&lt;/code&gt; commands are locked out during the sequence of operations in &lt;code&gt;start_disable&lt;/code&gt;, making the operation atomic from an &lt;code&gt;erlsrv&lt;/code&gt; user's point of view.</source>
          <target state="translated">Команда &lt;code&gt;start_disabled&lt;/code&gt; работает со службой независимо от того, включена она / отключена или запущена / остановлена. Он делает это, сначала включив его (независимо от того, включен он или нет), затем запустив его (если он еще не запущен), а затем отключил его. Результат - отключенная, но запущенная служба, независимо от ее более раннего состояния. Это полезно для временного запуска служб во время обновления выпуска. Разница между использованием &lt;code&gt;start_disabled&lt;/code&gt; и последовательностью &lt;code&gt;enable&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;disable&lt;/code&gt; заключается в том, что все другие команды &lt;code&gt;erlsrv&lt;/code&gt; заблокированы во время последовательности операций в &lt;code&gt;start_disable&lt;/code&gt; , что делает операцию атомарной из &lt;code&gt;erlsrv&lt;/code&gt; точка зрения пользователя.</target>
        </trans-unit>
        <trans-unit id="fc0272cbbd8f9392623927de4cb2fc5730b48880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program in its original form recognizes the following options:</source>
          <target state="translated">Программа &lt;code&gt;start_erl&lt;/code&gt; в исходном виде распознает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="a046e5227b7bb73b869f5bee562322400ca78ede" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program is specific to Windows NT/2000/XP (and later versions of Windows). Although there are programs with the same name on other platforms, their functionality is different.</source>
          <target state="translated">Программа &lt;code&gt;start_erl&lt;/code&gt; специфична для Windows NT / 2000 / XP (и более поздних версий Windows). Хотя есть программы с таким же названием на других платформах, их функциональность отличается.</target>
        </trans-unit>
        <trans-unit id="dbb5a322b443d443c9f79ed8f50a8ce9c3dd4066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; shell script is normally not to be altered by the user.</source>
          <target state="translated">&lt;code&gt;start_erl&lt;/code&gt; сценарий оболочки , как правило , не может быть изменен пользователем.</target>
        </trans-unit>
        <trans-unit id="f114d80543f043efa956ef10b8b8d871f223052b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stop&lt;/code&gt; entry is called when the port is closed.</source>
          <target state="translated">Запись &lt;code&gt;stop&lt;/code&gt; вызывается, когда порт закрыт.</target>
        </trans-unit>
        <trans-unit id="d04747a932902a65b42336d22f13d3d5bc78329f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strategy&lt;/code&gt; key is optional in this map. If it is not given, it defaults to &lt;code&gt;one_for_one&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strategy&lt;/code&gt; ключ не является обязательным в этой карте. Если не указан, по умолчанию используется &lt;code&gt;one_for_one&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="677a0d7125364697331cecce3cb1b444380c3397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string()&lt;/code&gt; reason is the error information from the server in case of an exit-signal. If that information is empty, the reason is the exit signal name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46c7648d961485339da72bde9519efe243649a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string&lt;/code&gt; module works perfectly for Unicode strings and ISO Latin-1 strings, except the language-dependent functions &lt;code&gt;string:uppercase/1&lt;/code&gt; and &lt;code&gt;string:lowercase/1&lt;/code&gt;. These two functions can never function correctly for Unicode characters in their current form, as there are language and locale issues to consider when converting text between cases. Converting case in an international environment is a large subject not yet addressed in OTP.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; Модуль отлично работает для строк Unicode и ISO Latin-1 строк, за исключением языка-зависимых функций &lt;code&gt;string:uppercase/1&lt;/code&gt; и &lt;code&gt;string:lowercase/1&lt;/code&gt; . Эти две функции никогда не могут правильно работать для символов Unicode в их текущей форме, так как при преобразовании текста между регистрами необходимо учитывать языковые и языковые особенности. Преобразование case в международной среде - большая тема, которая еще не рассматривается в OTP.</target>
        </trans-unit>
        <trans-unit id="bbf0fa4cdfc9cb3b3a98e97fea86cc7766872258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subsystem_name&lt;/code&gt; is the name that a client requests to start with for example &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;subsystem_name&lt;/code&gt; этого имя , которое клиент запрашивает , чтобы начать с, например , &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09767c0926afa55480ccd26075dea864841952af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suspend&lt;/code&gt; pseudo function has got an OWN time of zero. This is to prevent the process total OWN time from including time in suspension. Whether suspend time is really ACC or OWN time is more of a philosophical question.</source>
          <target state="translated">&lt;code&gt;suspend&lt;/code&gt; функцию псевдо завела собственное время , равное нулю. Это сделано для того, чтобы общее СОБСТВЕННОЕ время процесса не включало время приостановки. Является ли время приостановки действительно ACC или СОБСТВЕННЫМ временем - это скорее философский вопрос.</target>
        </trans-unit>
        <trans-unit id="56fd6933946b063ca50f26b9fde4abf8abbc8167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. It also has functions that, together with functions in the &lt;code&gt;proc_lib&lt;/code&gt; module, can be used to implement a &lt;strong&gt;special process&lt;/strong&gt; that complies to the OTP design principles without using a standard behaviour. These functions can also be used to implement user-defined (non-standard) behaviours.</source>
          <target state="translated">В модуле &lt;code&gt;sys&lt;/code&gt; есть функции для простой отладки процессов, реализованных с использованием поведения. В нем также есть функции, которые вместе с функциями в модуле &lt;code&gt;proc_lib&lt;/code&gt; могут использоваться для реализации &lt;strong&gt;специального процесса,&lt;/strong&gt; который соответствует принципам проектирования OTP без использования стандартного поведения. Эти функции также могут использоваться для реализации пользовательского (нестандартного) поведения.</target>
        </trans-unit>
        <trans-unit id="a5f881a797bfc4fbe38f558b9ae2256b6de4f52c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. The &lt;code&gt;code_lock&lt;/code&gt; example from &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; is used to illustrate this:</source>
          <target state="translated">В модуле &lt;code&gt;sys&lt;/code&gt; есть функции для простой отладки процессов, реализованных с использованием поведения. &lt;code&gt;code_lock&lt;/code&gt; пример из &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; используется для иллюстрации этого:</target>
        </trans-unit>
        <trans-unit id="d8d80e46d29a3b09620c79d01dfafc6546d08b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; value is not complete. Some allocated memory that is to be part of this value is not.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; значение не является полным. Некоторая выделенная память, которая должна быть частью этого значения, не является.</target>
        </trans-unit>
        <trans-unit id="26e392c3cf2f0ef617cba237c6220075b3ea4b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system_dir&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;system_dir&lt;/code&gt; должен быть каталогом, содержащим файл ключей хоста, и по умолчанию это &lt;code&gt;/etc/ssh&lt;/code&gt; . Подробности см. В разделе &amp;laquo;Файлы конфигурации&amp;raquo; в &lt;code&gt;ssh(6)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dc4b52b4a1a8766ffe6fbf819d4319fd568e3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; function takes a &lt;code&gt;.rel&lt;/code&gt; file as input and creates a zipped tar file with the code for the specified applications, a &lt;strong&gt;release package&lt;/strong&gt;:</source>
          <target state="translated">Функция &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; принимает файл &lt;code&gt;.rel&lt;/code&gt; в качестве входных данных и создает заархивированный файл tar с кодом для указанных приложений, &lt;strong&gt;пакет выпуска&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="301c4b01094f4be3c122bd03d67de7a461179ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_info/2&lt;/code&gt; function takes two arguments. The first is the name of a Mnesia table. The second is one of the following keys:</source>
          <target state="translated">Функция &lt;code&gt;table_info/2&lt;/code&gt; принимает два аргумента. Первое - это название таблицы Mnesia. Второй - это один из следующих ключей:</target>
        </trans-unit>
        <trans-unit id="cc6490531af30f5ced0c442f4ca5f18223c8f2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag_receiver()&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;tag_receiver()&lt;/code&gt; сначала будет отправлено на &lt;code&gt;snmp_targets&lt;/code&gt; сообщение, а затем для каждого адреса в &lt;code&gt;Addresses&lt;/code&gt; списке, один из двух &lt;code&gt;snmp_notification&lt;/code&gt; сообщений.</target>
        </trans-unit>
        <trans-unit id="05b2bd26a182333de1bd8075c792a7cf0885382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;term&lt;/code&gt; structure contains the arity for a tuple or list, size for a binary, string, or atom. It contains a term if it is any of the following: integer, float, atom, pid, port, or ref.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; структура содержит арность для кортежа или списка, размера для двоичного, строки или атома. Он содержит термин, если он является одним из следующих: целое число, число с плавающей запятой, атом, pid, порт или ссылка.</target>
        </trans-unit>
        <trans-unit id="414ded4046829ee348e2029f26b1f968edf7170d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminating&lt;/code&gt; options effects discovery initiated by a manager.</source>
          <target state="translated">Параметры &lt;code&gt;terminating&lt;/code&gt; влияют на обнаружение, инициированное менеджером.</target>
        </trans-unit>
        <trans-unit id="7e88c128d4034b8d31e143d58083f1b627d669f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; functions use the &lt;code&gt;*.asn1db&lt;/code&gt; files for all included modules. If they are located in a different directory than the current working directory, use the &lt;code&gt;include&lt;/code&gt; option to add paths. This is only needed when automatically generating values. For static values using &lt;code&gt;Value&lt;/code&gt; no options are needed.</source>
          <target state="translated">В &lt;code&gt;test&lt;/code&gt; - функции используют &lt;code&gt;*.asn1db&lt;/code&gt; файлы для всех включенных модулей. Если они расположены в другом каталоге, чем текущий рабочий каталог, используйте параметр &lt;code&gt;include&lt;/code&gt; , чтобы добавить пути. Это необходимо только при автоматическом создании значений. Для статических значений, использующих &lt;code&gt;Value&lt;/code&gt; , параметры не требуются.</target>
        </trans-unit>
        <trans-unit id="83b7e0837f597d64ddcc824925c5e1f6e2d7ce99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tftp&lt;/code&gt; application implements the following IETF standards:</source>
          <target state="translated">Приложение &lt;code&gt;tftp&lt;/code&gt; реализует следующие стандарты IETF:</target>
        </trans-unit>
        <trans-unit id="6783b7d09b3f65f7bff4fe67aceb9dac10494244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd16215e29bac88188ec05db9e000d6b25c2a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;time_unit/0&lt;/code&gt; может быть расширен. Чтобы преобразовать значения времени между единицами времени, используйте &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d6b5da79accb971f070469104b62f5de13468c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; option in the &lt;code&gt;SearchOptions&lt;/code&gt; is for the ldap server, while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for each individual request in the search operation.</source>
          <target state="translated">Параметр &lt;code&gt;timeout&lt;/code&gt; в &lt;code&gt;SearchOptions&lt;/code&gt; предназначен для сервера ldap, а таймаут в &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; используется для каждого отдельного запроса в операции поиска.</target>
        </trans-unit>
        <trans-unit id="3469f460bad51d15abfb716bef8439dd19f5713d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;total&lt;/code&gt; value is supposed to be the total amount of memory dynamically allocated by the emulator. Shared libraries, the code of the emulator itself, and the emulator stacks are not supposed to be included. That is, the &lt;code&gt;total&lt;/code&gt; value is &lt;strong&gt;not&lt;/strong&gt; supposed to be equal to the total size of all pages mapped to the emulator.</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; стоимость должна быть общим объемом памяти динамически распределяемый эмулятором. Общие библиотеки, код самого эмулятора и стеки эмулятора не должны быть включены. То есть &lt;code&gt;total&lt;/code&gt; значение &lt;strong&gt;не&lt;/strong&gt; должно равняться общему размеру всех страниц, сопоставленных с эмулятором.</target>
        </trans-unit>
        <trans-unit id="855a90cd384864cf599ca9011960a53bac88f853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trim&lt;/code&gt; behavior corresponds exactly to the Perl default. &lt;code&gt;{parts,N}&lt;/code&gt;, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of &lt;code&gt;split/3&lt;/code&gt; corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine.</source>
          <target state="translated">&lt;code&gt;trim&lt;/code&gt; поведение в точности соответствует по умолчанию Perl. &lt;code&gt;{parts,N}&lt;/code&gt; , где N - положительное целое число, в точности соответствует поведению Perl с положительным числовым третьим параметром. Поведение по умолчанию &lt;code&gt;split/3&lt;/code&gt; соответствует поведению Perl, когда отрицательное целое число указано в качестве третьего параметра для процедуры Perl.</target>
        </trans-unit>
        <trans-unit id="503ae720e5d8f3760c374c5a7724a46be581ffb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can also be augmented with an &lt;code&gt;after&lt;/code&gt; section, intended to be used for cleanup with side effects:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; выражение также может быть увеличено с &lt;code&gt;after&lt;/code&gt; того, как раздела, предназначенных для использования для очистки с побочными эффектами:</target>
        </trans-unit>
        <trans-unit id="9aa8fddb846b9b7abd8af53c04dc022f8bbdb56d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can have an &lt;code&gt;of&lt;/code&gt; section:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; выражение может иметь &lt;code&gt;of&lt;/code&gt; раздела:</target>
        </trans-unit>
        <trans-unit id="1247ef97bc2a099c330eff988713e9a5888387df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tuple()&lt;/code&gt; reason are other errors like for example &lt;code&gt;{exit_status,1}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874e9960e26401a3b617a3b1e2c19da394373ec5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;worker&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; ключ не является обязательным. Если он не указан, будет использоваться &lt;code&gt;worker&lt;/code&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="6ce30d2f89579b051b36741023e812a759179d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;worker&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; ключ не является обязательным. Если он не указан, по умолчанию используется &lt;code&gt;worker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ab52ef65eee07504a8c99112afca9e52efb72ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$bif:Module:Name/Arity&lt;/code&gt; constraint tests whether the given operand refers to a specific BIF. Note that &lt;code&gt;Module:Name/Arity&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be an existing BIF defined in &lt;code&gt;bif.tab&lt;/code&gt;, or there will be a compilation error. It is useful when a call to a specific BIF should be replaced with an instruction as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f2c733d5f2c3ff7dc2fecb9f7616099b07cea0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$func:Module:Name/Arity&lt;/code&gt; will test whether the given operand is a a specific function. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e0ceadd09742f3e89a0e0c489abdb4b9f52d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$is_not_bif&lt;/code&gt; constraint matches if the operand does not refer to a BIF (not listed in &lt;code&gt;bif.tab&lt;/code&gt;). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f1c69ed96b83a679b6a1461cadd4cb592d2117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_command&lt;/code&gt; routine is the routine called when an Erlang process sends data to the port. This routine handles all asynchronous commands when the port is in &lt;code&gt;command&lt;/code&gt; mode and the sending of all data when the port is in &lt;code&gt;data&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;uds_command&lt;/code&gt; подпрограмма подпрограмма вызывается , когда процесс Эрланга отправляет данные в порт. Эта процедура обрабатывает все асинхронные команды, когда порт находится в &lt;code&gt;command&lt;/code&gt; режиме, и отправку всех данных, когда порт находится в режиме &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="12d38078aadeb17f73f6143b46507ced220c8b0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine handles other input events (like non-blocking &lt;code&gt;accept&lt;/code&gt;), but most importantly handle data arriving at the socket by calling &lt;code&gt;do_recv&lt;/code&gt;:</source>
          <target state="translated">В &lt;code&gt;uds_input&lt;/code&gt; обычные ручки и другие события ввода (например , неблокирующая &lt;code&gt;accept&lt;/code&gt; ), но самое главное , обрабатывать данные , поступающие в гнездо по телефону &lt;code&gt;do_recv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="202a772c2bbbb0c73373b15e1d87ffd28aa29133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine is called when data is available on a file descriptor previously passed to the &lt;code&gt;driver_select&lt;/code&gt; routine. This occurs typically when a read command is issued and no data is available. The &lt;code&gt;do_recv&lt;/code&gt; routine is as follows:</source>
          <target state="translated">&lt;code&gt;uds_input&lt;/code&gt; процедура вызывается , когда данные доступны на файловом дескрипторе ранее переданного &lt;code&gt;driver_select&lt;/code&gt; рутина. Обычно это происходит, когда выдается команда чтения и данные недоступны. &lt;code&gt;do_recv&lt;/code&gt; процедура выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="afe5ea4f80f83ad57ad0aad31e10486a4f2bf930" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_start&lt;/code&gt; routine is called when a port is opened from Erlang. In this case, we only allocate a structure and initialize it. Creating the actual socket is left to the &lt;code&gt;uds_command&lt;/code&gt; routine.</source>
          <target state="translated">&lt;code&gt;uds_start&lt;/code&gt; процедура вызывается , когда порт открыт с Erlang. В этом случае мы только выделяем структуру и инициализируем ее. Создание фактического сокета оставлено на &lt;code&gt;uds_command&lt;/code&gt; процедуры uds_command .</target>
        </trans-unit>
        <trans-unit id="8bfbb24810f0c5b15e0b6448d90f972fe31a6386" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undo&lt;/code&gt; function does nothing.</source>
          <target state="translated">Функция &lt;code&gt;undo&lt;/code&gt; ничего не делает.</target>
        </trans-unit>
        <trans-unit id="7969bdd4f7e8e8283016abfb83b747e28e6525e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unicode&lt;/code&gt; module is clearly Unicode-aware. It contains functions for conversion between different Unicode formats and some utilities for identifying byte order marks. Few programs handling Unicode data survive without this module.</source>
          <target state="translated">Модуль &lt;code&gt;unicode&lt;/code&gt; явно поддерживает Unicode. Он содержит функции для преобразования между различными форматами Unicode и некоторые утилиты для определения меток порядка байтов. Немногие программы, работающие с данными Unicode, выживают без этого модуля.</target>
        </trans-unit>
        <trans-unit id="45fc4ab31edeed78de6dcc133ce43fa458252958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; function is an alternative for updating module data of recompiled modules.</source>
          <target state="translated">Функция &lt;code&gt;update&lt;/code&gt; является альтернативой для обновления данных модулей перекомпилированных модулей.</target>
        </trans-unit>
        <trans-unit id="e7a993cc2041a3a5e4126cbf7ea824172decdb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; instruction must contain the tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;. The instruction makes the special process call the callback function &lt;code&gt;system_code_change/4&lt;/code&gt;, a function the user must implement. The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to &lt;code&gt;system_code_change/4&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; инструкция должна содержать кортеж &lt;code&gt;{advanced,Extra}&lt;/code&gt; . Инструкция заставляет специальный процесс вызывать функцию обратного вызова &lt;code&gt;system_code_change/4&lt;/code&gt; , функцию, которую должен реализовать пользователь. Термин &lt;code&gt;Extra&lt;/code&gt; , в данном случае &lt;code&gt;[]&lt;/code&gt; , передается как есть в &lt;code&gt;system_code_change/4&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55a52d1bdeacd91af756556ef9395d795b7ce705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user_args&lt;/code&gt; configuration parameter which may be used to extend the argument list of the callback functions. For example, the handle_connect function takes by default two arguments:</source>
          <target state="translated">&lt;code&gt;user_args&lt;/code&gt; параметр конфигурации , который может быть использован для расширения списка аргументов функций обратного вызова. Например, функция handle_connect по умолчанию принимает два аргумента:</target>
        </trans-unit>
        <trans-unit id="c15ed8631e7be541ad2f112cab6d63b078785dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmAccessTable&lt;/code&gt; maps the &lt;code&gt;groupName&lt;/code&gt; (found in &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;), &lt;code&gt;contextName&lt;/code&gt;, &lt;code&gt;securityModel&lt;/code&gt;, and &lt;code&gt;securityLevel&lt;/code&gt; to an MIB view for each type of operation (read, write, or notify). The MIB view is represented as a &lt;code&gt;viewName&lt;/code&gt;. The definition of the MIB view represented by the &lt;code&gt;viewName&lt;/code&gt; is found in the &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vacmAccessTable&lt;/code&gt; отображает &lt;code&gt;groupName&lt;/code&gt; (найденный в &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; ), &lt;code&gt;contextName&lt;/code&gt; , &lt;code&gt;securityModel&lt;/code&gt; и &lt;code&gt;securityLevel&lt;/code&gt; с представлением MIB для каждого типа операции (чтение, запись, или уведомлять). Представление MIB представлено как &lt;code&gt;viewName&lt;/code&gt; . Определение представления MIB, представленного &lt;code&gt;viewName&lt;/code&gt; , находится в &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a70d16c49aee0ecab7697bd61b2b47a75fed9fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmContextTable&lt;/code&gt; is a read-only table that lists all available contexts.</source>
          <target state="translated">&lt;code&gt;vacmContextTable&lt;/code&gt; является только для чтения таблицы , в которой перечислены все доступные контексты.</target>
        </trans-unit>
        <trans-unit id="ef9aac3e2a8987ec6dd80992e0534a1b71403af1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; maps a &lt;code&gt;securityModel&lt;/code&gt; and a &lt;code&gt;securityName&lt;/code&gt; to a &lt;code&gt;groupName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; отображает &lt;code&gt;securityModel&lt;/code&gt; и &lt;code&gt;securityName&lt;/code&gt; к &lt;code&gt;groupName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28801f1623b234b9de96cc740a98bd5f85c06c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; is indexed by the &lt;code&gt;viewName&lt;/code&gt;, and defines which objects are included in the MIB view.</source>
          <target state="translated">&lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; индексируется &lt;code&gt;viewName&lt;/code&gt; , а также определяет , какие объекты включены в представлении MIB.</target>
        </trans-unit>
        <trans-unit id="1870424a39adeddc9df6d1301607365bb578c850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vfs&lt;/code&gt; layer of MacOS X enforces UTF-8 filenames in an aggressive way. Older versions did this by refusing to create non-UTF-8 conforming filenames, while newer versions replace offending bytes with the sequence &quot;%HH&quot;, where HH is the original character in hexadecimal notation. As Unicode translation is enabled by default on MacOS X, the only way to come up against this is to either start the VM with flag &lt;code&gt;+fnl&lt;/code&gt; or to use a raw filename in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. If using a raw filename, with a bytewise encoding containing characters from 127 through 255, to create a file, the file cannot be opened using the same name as the one used to create it. There is no remedy for this behavior, except keeping the filenames in the correct encoding.</source>
          <target state="translated">Уровень &lt;code&gt;vfs&lt;/code&gt; в MacOS X агрессивно применяет имена файлов UTF-8. В более старых версиях это было сделано путем отказа от создания имен файлов, не соответствующих UTF-8, в то время как в новых версиях ошибочные байты заменяются последовательностью &amp;laquo;% HH&amp;raquo;, где HH - исходный символ в шестнадцатеричной системе счисления. Поскольку перевод Unicode включен по умолчанию в MacOS X, единственный способ столкнуться с этим - либо запустить виртуальную машину с помощью flag &lt;code&gt;+fnl&lt;/code&gt; , либо использовать необработанное имя файла в побайтной ( &lt;code&gt;latin1&lt;/code&gt; ) кодировке. Если для создания файла используется необработанное имя файла с побайтной кодировкой, содержащей символы от 127 до 255, файл не может быть открыт с тем же именем, что и имя, использованное для его создания. Исправить такое поведение нельзя, кроме как сохранить имена файлов в правильной кодировке.</target>
        </trans-unit>
        <trans-unit id="831df5545d1b1c7760cea7009d162230198cc0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;werl&lt;/code&gt; window is in many ways modeled after the &lt;code&gt;xterm&lt;/code&gt; window present on other platforms, as the &lt;code&gt;xterm&lt;/code&gt; model fits well with line-oriented command-based interaction. This means that selecting text is line-oriented rather than rectangle-oriented.</source>
          <target state="translated">Окно &lt;code&gt;werl&lt;/code&gt; во многом смоделировано по образцу окна &lt;code&gt;xterm&lt;/code&gt; , присутствующего на других платформах, поскольку модель &lt;code&gt;xterm&lt;/code&gt; хорошо сочетается со строчно-ориентированным взаимодействием на основе команд. Это означает, что выделение текста ориентировано на строку, а не на прямоугольник.</target>
        </trans-unit>
        <trans-unit id="cb0a24e0ba3c71a8aad37252c9a038696dacac35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;whereis&lt;/code&gt; function-call verifies that the SSL application is started.</source>
          <target state="translated">В &lt;code&gt;whereis&lt;/code&gt; провер вызова функции , что приложение запускается SSL.</target>
        </trans-unit>
        <trans-unit id="e2ea2763aab3c4567e48b6fa3d1366d90dff0b7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write_concurrency&lt;/code&gt; option can be combined with the options &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt;. You typically want to combine &lt;code&gt;write_concurrency&lt;/code&gt; with &lt;code&gt;read_concurrency&lt;/code&gt; when large concurrent read bursts and large concurrent write bursts are common; for more information, see option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned on by default for tables of type &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;write_concurrency&lt;/code&gt; option enabled, and the &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned off by default for all other table types. For more information, see the documentation for the &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d05af96ec0e7231d4e09ddd7a1fc622f5621cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{OtherRefId,term()}&lt;/code&gt; is defined by the user and is passed to the &lt;code&gt;match_fun&lt;/code&gt;, if defined. If the term in &lt;code&gt;OtherRefId&lt;/code&gt; is a binary, it will be converted to a string.</source>
          <target state="translated">&lt;code&gt;{OtherRefId,term()}&lt;/code&gt; определяется пользователем , и передается в &lt;code&gt;match_fun&lt;/code&gt; , если они определены. Если термин в &lt;code&gt;OtherRefId&lt;/code&gt; является двоичным, он будет преобразован в строку.</target>
        </trans-unit>
        <trans-unit id="19e1b6293cd5c62e374c8457e4fbd9d95a253158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; option must be included. This option is used to find the callback module &lt;code&gt;Module&lt;/code&gt; of the application. &lt;code&gt;StartArgs&lt;/code&gt; is ignored, as &lt;code&gt;Module:start/2&lt;/code&gt; is called only for the primary application.</source>
          <target state="translated">Параметр &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; должен быть включен. Эта опция используется для поиска модуля обратного вызова &lt;code&gt;Module&lt;/code&gt; приложения. &lt;code&gt;StartArgs&lt;/code&gt; игнорируется, поскольку &lt;code&gt;Module:start/2&lt;/code&gt; вызывается только для основного приложения.</target>
        </trans-unit>
        <trans-unit id="4668f1fd645c2ffa2dba60de3db8016985e65bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{ok,tut}&lt;/code&gt; means that the compilation is OK. If it says &quot;error&quot; it means that there is some mistake in the text that you entered. Additional error messages gives an idea to what is wrong so you can modify the text and then try to compile the program again.</source>
          <target state="translated">В &lt;code&gt;{ok,tut}&lt;/code&gt; означает , что компиляция ОК. Если написано &amp;laquo;ошибка&amp;raquo;, значит, в введенном вами тексте есть ошибка. Дополнительные сообщения об ошибках дают представление о том, что не так, поэтому вы можете изменить текст, а затем снова попытаться скомпилировать программу.</target>
        </trans-unit>
        <trans-unit id="37c82dec6529acb72fb125b0bac4fda347c61081" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{packet, N}&lt;/code&gt; and &lt;code&gt;{line, L}&lt;/code&gt; settings are mutually exclusive.</source>
          <target state="translated">Настройки &lt;code&gt;{packet, N}&lt;/code&gt; и &lt;code&gt;{line, L}&lt;/code&gt; исключают друг друга.</target>
        </trans-unit>
        <trans-unit id="971d55e17028d3606b6c283922622f2c0932a483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{port,PortNum}&lt;/code&gt; tuple is optional and if omitted, default Telnet port 23 is used. Also the &lt;code&gt;keep_alive&lt;/code&gt; tuple is optional, and the value defauls to &lt;code&gt;true&lt;/code&gt; (enabled).</source>
          <target state="translated">&lt;code&gt;{port,PortNum}&lt;/code&gt; кортеж является необязательным и , если опущен, то по умолчанию Telnet , порт 23 используется. Также кортеж &lt;code&gt;keep_alive&lt;/code&gt; является необязательным, а значение по умолчанию равно &lt;code&gt;true&lt;/code&gt; (включено).</target>
        </trans-unit>
        <trans-unit id="fa6ece2cc8b2e8dafa07d4e08292eb70bec23c2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; option must be included, and the set of specified phases must be a subset of the set of phases specified for the primary application.</source>
          <target state="translated">Параметр &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; должен быть включен, а набор указанных фаз должен быть подмножеством набора фаз, указанного для основного приложения.</target>
        </trans-unit>
        <trans-unit id="ff25bb9b46c77ee1bd1587510f1046fea71955a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; &quot;such that&quot; and the arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; is read as &quot;taken from&quot;.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; &amp;laquo;такой, что&amp;raquo; и стрелка &lt;code&gt;&amp;lt;-&lt;/code&gt; читается как &amp;laquo;взято из&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8950a73316b6b3766c9706406f02f3f2dda35162" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;Cartesian_product&quot;&gt;Cartesian product&lt;/strong&gt; of two sets X and Y, denoted X &amp;times; Y, is the set {a : a = (x, y) for some x in X and for some y in Y}.</source>
          <target state="translated">&lt;strong id=&quot;Cartesian_product&quot;&gt;Декартово произведение&lt;/strong&gt; двух множеств X и Y, обозначенный X &amp;times; Y, есть множество {а: а = (х, у) для некоторых х в X и для некоторых у в Y}.</target>
        </trans-unit>
        <trans-unit id="97f5043ae782de1e349c1f4e82a07bd359c0964c" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;converse&quot;&gt;converse&lt;/strong&gt; of R is the set {a : a = (y, x) for some (x, y) in R}.</source>
          <target state="translated">&lt;strong id=&quot;converse&quot;&gt;Обратный&lt;/strong&gt; из R есть множество {а: а = (у, х) для некоторых (х, у) в R}.</target>
        </trans-unit>
        <trans-unit id="c74f91b2df651d6f1d918e8b3fa79c423cad5e1b" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;difference&quot;&gt;difference&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that do not belong to B.</source>
          <target state="translated">&lt;strong id=&quot;difference&quot;&gt;Разность&lt;/strong&gt; двух множеств А и В представляет собой набор , который содержит все элементы A , которые не принадлежат к B.</target>
        </trans-unit>
        <trans-unit id="efd11e10dc9bffd3ce00966684d96fd8a122cb0d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;domain&quot;&gt;domain&lt;/strong&gt; of R is the set {x : x R y for some y in Y}.</source>
          <target state="translated">Область &lt;strong id=&quot;domain&quot;&gt;определения&lt;/strong&gt; R - это множество {x: x R y для некоторого y в Y}.</target>
        </trans-unit>
        <trans-unit id="377184fb47eff2618a884d3371438181861419a0" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;field&quot;&gt;field&lt;/strong&gt; of a relation R in X is the union of the domain of R and the range of R.</source>
          <target state="translated">&lt;strong id=&quot;field&quot;&gt;Поле&lt;/strong&gt; из соотношения R в X является объединением области R и диапазон R.</target>
        </trans-unit>
        <trans-unit id="1a9617de87db1af0121da59eba19d31a6b757eff" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;in_degree&quot;&gt;in-degree&lt;/strong&gt; of a vertex is the number of edges incident on that vertex.</source>
          <target state="translated">Внутренняя &lt;strong id=&quot;in_degree&quot;&gt;степень&lt;/strong&gt; вершины - это количество ребер, инцидентных этой вершине.</target>
        </trans-unit>
        <trans-unit id="4c0e00f79ce45926299ee2f3508020fdf2f45df9" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection&quot;&gt;intersection&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that belong to B.</source>
          <target state="translated">&lt;strong id=&quot;intersection&quot;&gt;Пересечение&lt;/strong&gt; двух множеств А и В представляет собой набор , который содержит все элементы , которые принадлежат A к B.</target>
        </trans-unit>
        <trans-unit id="3f1d912f47b338c33084d89f0c15a5a316197ecb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection_n&quot;&gt;intersection&lt;/strong&gt; of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection.</source>
          <target state="translated">&lt;strong id=&quot;intersection_n&quot;&gt;Пересечение&lt;/strong&gt; из непустого множества множеств называется множество, содержащее все элементы , которые принадлежат каждому набору коллекции.</target>
        </trans-unit>
        <trans-unit id="429f2c89c9e807577354da0b8e15a8e248018d77" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;length&quot;&gt;length&lt;/strong&gt; of path P is k-1.</source>
          <target state="translated">&lt;strong id=&quot;length&quot;&gt;Длина&lt;/strong&gt; по пути Р к-1.</target>
        </trans-unit>
        <trans-unit id="abc21b67f672b304bee1db7701b820f9b24de3c6" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;natural_join&quot;&gt;natural join&lt;/strong&gt; of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z : z = (x[1], ..., x[n], y[1], ..., y[j-1], y[j+1], ..., y[m]) for some (x[1], ..., x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}.</source>
          <target state="translated">&lt;strong id=&quot;natural_join&quot;&gt;Естественное соединение&lt;/strong&gt; из п-арной соотношением R и т-местное отношение S от координаты I и J определяется как множество {г: г = (х [1], ..., х [п], у [ 1], ..., y [j-1], y [j + 1], ..., y [m]) для некоторых (x [1], ..., x [n]) в R и для некоторых (y [1], ..., y [m]) в S таких, что x [i] = y [j]}.</target>
        </trans-unit>
        <trans-unit id="adf6489e3c93a13ca7fd19239f3939863c02f11d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;out_degree&quot;&gt;out-degree&lt;/strong&gt; of a vertex is the number of edges emanating from that vertex.</source>
          <target state="translated">&lt;strong id=&quot;out_degree&quot;&gt;Из степени&lt;/strong&gt; вершины есть число ребер , исходящих из этой вершины.</target>
        </trans-unit>
        <trans-unit id="7c6a3c4f02bedbb63c4000218f9eaa4b3029b656" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;projection&quot;&gt;projection&lt;/strong&gt; of an n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ..., x[n]) in R for some x[j] in X[j], 1 &amp;lt;= j &amp;lt;= n and not i = j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R, respectively.</source>
          <target state="translated">&lt;strong id=&quot;projection&quot;&gt;Проекция&lt;/strong&gt; из п-арной отношения R на координатных я есть множество {х [г]: (х [1], ..., х [I], ..., х [п]) в R для некоторого х [j] в X [j], 1 &amp;lt;= j &amp;lt;= n, а не i = j}. Проекции бинарного отношения R на первую и вторую координаты являются областью и диапазоном R соответственно.</target>
        </trans-unit>
        <trans-unit id="928618861a3a7864fa16dc6571d48344039643c2" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;range&quot;&gt;range&lt;/strong&gt; of R is the set {y : x R y for some x in X}.</source>
          <target state="translated">&lt;strong id=&quot;range&quot;&gt;Диапазон&lt;/strong&gt; от R есть множество {у: х R Y для некоторых х в X}.</target>
        </trans-unit>
        <trans-unit id="a0513ff69692a7179c5c24f4ad25a5aa23d84d71" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;restriction&quot;&gt;restriction&lt;/strong&gt; of R to A is the set S defined so that x S y if and only if there exists an element x in A such that x R y.</source>
          <target state="translated">&lt;strong id=&quot;restriction&quot;&gt;Ограничение&lt;/strong&gt; на R к А является множество S определен так , что х S у тогда и только тогда , когда существует элемент х в А, что х R у.</target>
        </trans-unit>
        <trans-unit id="53dd8e97ddf5e81c0a22de5f228a88721f6ccc8d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;symmetric_difference&quot;&gt;symmetric difference&lt;/strong&gt; of two sets is the set that contains those element that belong to either of the two sets, but not both.</source>
          <target state="translated">&lt;strong id=&quot;symmetric_difference&quot;&gt;Симметрическая разность&lt;/strong&gt; двух множеств называется множество, содержащее те элементы , которые принадлежат ни к одному из двух наборов, но не оба.</target>
        </trans-unit>
        <trans-unit id="baf0cfcddb027f4d4f3dff2390047419348137ab" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union&quot;&gt;union&lt;/strong&gt; of two sets A and B is the smallest set that contains all elements of A and all elements of B.</source>
          <target state="translated">&lt;strong id=&quot;union&quot;&gt;Объединение&lt;/strong&gt; двух множеств А и В является наименьшим набор , который содержит все элементы А и все элементы B.</target>
        </trans-unit>
        <trans-unit id="81d4f87a2b598bff542bef7879776b07f0f811bb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union_n&quot;&gt;union&lt;/strong&gt; of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection.</source>
          <target state="translated">&lt;strong id=&quot;union_n&quot;&gt;Объединение&lt;/strong&gt; из совокупности множеств является наименьшим набор , который содержит все элементы, принадлежащие , по меньшей мере , одного набора сбора.</target>
        </trans-unit>
        <trans-unit id="5d51e506fb7ebd09e0439b577c3665c859bbc0bf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Auto Attach&lt;/strong&gt; boxes, &lt;strong&gt;Stack Trace&lt;/strong&gt; label, &lt;strong&gt;Back Trace Size&lt;/strong&gt; label, and &lt;strong&gt;Strings&lt;/strong&gt; box display some options set. For details about these options, see section &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В полях &amp;laquo; &lt;strong&gt;Автоматическое присоединение&amp;raquo;&lt;/strong&gt; , &amp;laquo; Метка &lt;strong&gt;трассировки стека&amp;raquo;&lt;/strong&gt; , &amp;laquo; &lt;strong&gt;Размер обратной трассы&amp;raquo;&lt;/strong&gt; и &amp;laquo; &lt;strong&gt;Строки&amp;raquo;&lt;/strong&gt; отображаются некоторые установленные параметры. Подробнее об этих параметрах см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abcaf1a971590700133b8016539b636c71ba876f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Break&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">В &lt;strong&gt;перерыве&lt;/strong&gt; , &lt;strong&gt;Windows&lt;/strong&gt; , и &lt;strong&gt;Помощь&lt;/strong&gt; меню такие же , как и в &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; , за исключением того, что &lt;strong&gt;пауза&lt;/strong&gt; меню применяется только к местной точке останова.</target>
        </trans-unit>
        <trans-unit id="a10eb03f19350fbdf85025a9eab01c5153042f77" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Breaks&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">В &lt;strong&gt;перерыве&lt;/strong&gt; , &lt;strong&gt;Windows&lt;/strong&gt; , и &lt;strong&gt;Помощь&lt;/strong&gt; меню такие же , как и в &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; , за исключением того, что &lt;strong&gt;Перерывы&lt;/strong&gt; меню применяется только к местной точке останова.</target>
        </trans-unit>
        <trans-unit id="81208a589d29fcc1ae9246757bcbbd412aee1292" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; by callbacks before and after all test suite calls. It is intended for advanced users of &lt;code&gt;Common Test&lt;/code&gt; who want to abstract out behavior that is common to multiple test suites.</source>
          <target state="translated">&lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; структура позволяет расширение поведения по умолчанию &lt;code&gt;Common Test&lt;/code&gt; с помощью обратных вызовов до и после все набора тестов вызовов. Он предназначен для опытных пользователей &lt;code&gt;Common Test&lt;/code&gt; , которые хотят абстрагироваться от поведения, характерного для нескольких наборов тестов.</target>
        </trans-unit>
        <trans-unit id="e6fc5c94241e7e52f12a5fd7bd3416eff9018efa" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; using hooks before and after all test suite calls. CTHs allow advanced &lt;code&gt;Common Test&lt;/code&gt; users to abstract out behavior that is common to multiple test suites without littering all test suites with library calls. This can be used for logging, starting, and monitoring external systems, building C files needed by the tests, and so on.</source>
          <target state="translated">&lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; структура позволяет расширение поведения по умолчанию &lt;code&gt;Common Test&lt;/code&gt; с использованием крючков до и после все набора тестов вызовов. CTH позволяют продвинутым пользователям &lt;code&gt;Common Test&lt;/code&gt; абстрагироваться от поведения, присущего множеству наборов тестов, не засоряя все наборы тестов вызовами библиотек. Это можно использовать для регистрации, запуска и мониторинга внешних систем, создания файлов C, необходимых для тестов, и т. Д.</target>
        </trans-unit>
        <trans-unit id="03e6f71f473d365a318259d6ca0121e4f4c728af" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Property Testing Support (ct_property_test)&lt;/strong&gt; is an aid to run property based testing tools in Common Test test suites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cdc049609d4e15a26ab891a990c31ae80de460" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; and &lt;strong&gt;Edit&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В &lt;strong&gt;File&lt;/strong&gt; и &lt;strong&gt;Edit&lt;/strong&gt; меню такие же , как и в &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff4e15bb4c0b2061b264590ff96d04af89b93805" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; menu includes options to save the contents of the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window. Simply choose the options and enter the file to save the contents in.</source>
          <target state="translated">В меню &amp;laquo; &lt;strong&gt;Файл&amp;raquo;&lt;/strong&gt; есть параметры для сохранения содержимого окна &lt;strong&gt;журнала и&lt;/strong&gt; окна &lt;strong&gt;предупреждений&lt;/strong&gt; . Просто выберите параметры и введите файл, в котором нужно сохранить содержимое.</target>
        </trans-unit>
        <trans-unit id="370a6214852f8fdbb6373c8997912c0758173f20" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; window displays a listing of the current directory. Click your way to the directories/modules you want to add or type the correct path in the entry.</source>
          <target state="translated">В окне &amp;laquo; &lt;strong&gt;Файл&amp;raquo;&lt;/strong&gt; отображается список текущего каталога. Щелкните свой путь к каталогам / модулям, которые вы хотите добавить, или введите правильный путь в записи.</target>
        </trans-unit>
        <trans-unit id="8e3940de2fcf0c6b61297d85ec453fc7187e592a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;OTP design principles&lt;/strong&gt; define how to structure Erlang code in terms of processes, modules, and directories.</source>
          <target state="translated">В &lt;strong&gt;принципы OTP проектирования&lt;/strong&gt; определяют , как структурировать Erlang код с точки зрения процессов, модулей и каталогов.</target>
        </trans-unit>
        <trans-unit id="ce6dbe8f8ec89aa3b4f8a5fbd8bce3df7dce0384" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;anonymous variable&lt;/strong&gt; is denoted by underscore (_) and can be used when a variable is required but its value can be ignored.</source>
          <target state="translated">&lt;strong&gt;Анонимные переменный&lt;/strong&gt; обозначаются символом подчеркивания (_) и может быть использована , когда переменным требуется , но его значение может быть проигнорировано.</target>
        </trans-unit>
        <trans-unit id="a6798179458a851b9ebec479cdde3c475bff4cbb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application resource file&lt;/strong&gt; specifies the resources an application uses, and how the application is started. There must always be one application resource file called &lt;code&gt;Application.app&lt;/code&gt; for each application &lt;code&gt;Application&lt;/code&gt; in the system.</source>
          <target state="translated">&lt;strong&gt;Файл ресурсов приложения&lt;/strong&gt; определяет ресурсы Н. использует приложение, и как приложение запускается. Для каждого приложения &lt;code&gt;Application&lt;/code&gt; в системе всегда должен быть один файл ресурсов приложения с именем &lt;code&gt;Application.app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6e14a23d7c2ef8d516ebeb71a889d63ab7e5e5f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application upgrade file&lt;/strong&gt; defines how an application is upgraded or downgraded in a running system.</source>
          <target state="translated">В &lt;strong&gt;файл обновление приложения&lt;/strong&gt; определяет , как приложение модернизировано или понижено в работающей системе.</target>
        </trans-unit>
        <trans-unit id="6724ecd893c2f90d64929956a749eae932ffa031" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;beam_makeops&lt;/strong&gt; Perl script is used at build-time by both the compiler and runtime system. Given a number of input files (all with the extension &lt;code&gt;.tab&lt;/code&gt;), it will generate source files used by the Erlang compiler and by the runtime system to load and execute BEAM instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db57b7456855f2efbc5591cfd1f43a7d95e2566" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;boot script&lt;/strong&gt; describes how the Erlang runtime system is started. It contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">Сценарий &lt;strong&gt;загрузки&lt;/strong&gt; описывает, как запускается система времени выполнения Erlang. Он содержит инструкции о том, какой код загружать и какие процессы и приложения запускать.</target>
        </trans-unit>
        <trans-unit id="c43e23aec0edb2b1553fbf3a42ab629ff93e0727" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is a property of the &lt;strong&gt;callback module&lt;/strong&gt; and is set at server start. It may be changed due to a code upgrade/downgrade, or when changing the &lt;strong&gt;callback module&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0117a440e83974bf851c56ecb41421105f272e12" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected by implementing a mandatory callback function &lt;code&gt; Module:callback_mode() &lt;/code&gt; that returns one of the &lt;strong&gt;callback modes&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5741097334e8b8597284eb3550244c5de695e977" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected when starting the &lt;code&gt;gen_statem&lt;/code&gt; and after code change using the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Режим &lt;strong&gt;обратного вызова&lt;/strong&gt; выбирается при запуске &lt;code&gt;gen_statem&lt;/code&gt; и после изменения кода с использованием возвращаемого значения из &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b41a677df62f29884be14a8c6c25a7497c11480" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected with the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bffb738c6ff50eb3adeb56460c8af109c3f28df" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt;&lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3427359c72c6325ce793c2593793b153f136ba5e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback module&lt;/strong&gt; can be changed for a running server using any of the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt;transition actions&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt;, &lt;code&gt;{push_callback_module, NewModule}&lt;/code&gt; or &lt;code&gt;pop_callback_module&lt;/code&gt;. Note that this is a pretty esoteric thing to do... The origin for this feature is a protocol that after version negotiation branches off into quite different state machines depending on the protocol version. There</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61740187206076da0d0e88e42b8dcd3ef778c9b8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback module&lt;/strong&gt; contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the &lt;strong&gt;callback module&lt;/strong&gt; with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010c2dfc5017e7774d251ec3e8505c4cdafc0e30" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;detailed table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">В &lt;strong&gt;подробной таблице события&lt;/strong&gt; являются кортежи как &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="790690408a0b723c21e944914ee3b6f33b9bfb5b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dynamic node name&lt;/strong&gt; feature is supported from OTP 23. Both the temporary client node and the first connected peer node (supplying the dynamic node name) must be at least OTP 23 for it to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cb531fb67c541100e62d6289d443a02cba5fa3" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;empty set&lt;/strong&gt; contains no elements.</source>
          <target state="translated">&lt;strong&gt;Пустое множество&lt;/strong&gt; не содержит элементов.</target>
        </trans-unit>
        <trans-unit id="529d8e8336cfdf10118ffc9b093a47018a9c6171" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;mstone2&lt;/strong&gt; is similar to the &lt;strong&gt;mstone1&lt;/strong&gt; tool, but in this case, each created process makes only &lt;strong&gt;one&lt;/strong&gt; run through the messages and then exits. A soon as a process exits, a new process (with the same config and messages) is created to takes its place. The number of messages processed in total is the mstone2(1) value.</source>
          <target state="translated">&lt;strong&gt;Mstone2&lt;/strong&gt; похож на &lt;strong&gt;mstone1&lt;/strong&gt; инструмент, но в этом случае, каждый создаваемый процесс делает только &lt;strong&gt;один&lt;/strong&gt; проход через сообщения , а затем завершает работу. Как только процесс завершается, его место занимает новый процесс (с той же конфигурацией и сообщениями). Общее количество обработанных сообщений равно значению mstone2 (1).</target>
        </trans-unit>
        <trans-unit id="b927187f56617f5aef02c9b312ff36f409a08649" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ordered pair&lt;/strong&gt; of a and b, with first &lt;strong&gt;coordinate&lt;/strong&gt; a and second coordinate b, is denoted (a, b). An ordered pair is an &lt;strong&gt;ordered set&lt;/strong&gt; of two elements. In this module, ordered sets can contain one, two, or more elements, and parentheses are used to enclose the elements.</source>
          <target state="translated">&lt;strong&gt;Заказал пару&lt;/strong&gt; А и В, с первой &lt;strong&gt;координат&lt;/strong&gt; а и вторая координата Ь, обозначается (а, б). Упорядоченная пара - это &lt;strong&gt;упорядоченный набор&lt;/strong&gt; из двух элементов. В этом модуле упорядоченные наборы могут содержать один, два или более элементов, и они используются в круглых скобках.</target>
        </trans-unit>
        <trans-unit id="c83c801cd635dbe318e9132115de7b55b1599720" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;receiver&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which expects a response (for example Get, GetNext, Get-Bulk, Set or Inform PDU).</source>
          <target state="translated">&lt;strong&gt;Приемник&lt;/strong&gt; является &lt;strong&gt;авторитетным&lt;/strong&gt; для сообщений , содержащих полезную нагрузку , которая ожидает ответа (например Get, GetNext, Get-Bulk, Set или Inform PDU).</target>
        </trans-unit>
        <trans-unit id="ac92db4f0e00aaa89bb19e432441af806acad352" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release handler&lt;/strong&gt; process belongs to the SASL application, which is responsible for &lt;strong&gt;release handling&lt;/strong&gt;, that is, unpacking, installation, and removal of release packages.</source>
          <target state="translated">Процесс обработки &lt;strong&gt;выпуска&lt;/strong&gt; принадлежит приложению SASL, которое отвечает за &lt;strong&gt;обработку выпуска&lt;/strong&gt; , то есть распаковку, установку и удаление пакетов выпуска.</target>
        </trans-unit>
        <trans-unit id="91dc52a591c8ca51fdb38124dea4daf9b7e6ea32" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release resource file&lt;/strong&gt; specifies which applications are included in a release (system) based on Erlang/OTP.</source>
          <target state="translated">В &lt;strong&gt;файл релиз ресурсов&lt;/strong&gt; определяет , какие приложения включены в релиз (системы) на основе Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="ad1a94e9c3dc7a7604b7beecc0ad4192b022ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release upgrade file&lt;/strong&gt; describes how a release is upgraded in a running system.</source>
          <target state="translated">&lt;strong&gt;Файл обновление релиза&lt;/strong&gt; описывает , как выпуск повышен в работающей системе.</target>
        </trans-unit>
        <trans-unit id="df96a6a378319ab14151f9909dca99424881e367" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;sender&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which does &lt;strong&gt;not&lt;/strong&gt; expect a response (for example SNMPv2-Trap, Response or Report PDU).</source>
          <target state="translated">&lt;strong&gt;Отправитель&lt;/strong&gt; является &lt;strong&gt;авторитетным&lt;/strong&gt; для сообщений , содержащих полезную нагрузку , которая никак &lt;strong&gt;не&lt;/strong&gt; ожидать ответа (например SNMPv2-Trap, Response или Report PDU).</target>
        </trans-unit>
        <trans-unit id="4ac925cddc8d38d70b14e09284795baa1f665f91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;simple table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">В &lt;strong&gt;события просто таблица&lt;/strong&gt; кортежи как &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="c7623d1fa21054abc3e3ac53a4bbc8066dac8120" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;socket registry&lt;/strong&gt; is how we keep track of sockets. There are two functions that can be used for interaction: &lt;code&gt;&lt;a href=&quot;socket#number_of-0&quot;&gt;socket:number_of/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;socket#which_sockets-1&quot;&gt;socket:which_sockets/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42f516326a33814c075d0ef2dd476acfd28000d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; for a specific &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;gen_statem&lt;/code&gt; is the callback function that is called for all events in this state. It is selected depending on which &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; that the callback module defines with the callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39642072ab882c38d48ac8e225ecf14ced26e9ee" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; is the callback function that handles an event in the current state, and which function that is depends on the &lt;strong&gt;callback mode&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b1ae1634c63df766310472c5f61e301e8fde51" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; return values are defined in the description of &lt;code&gt; Module:StateName/3 &lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcc34c431d064d6d4c4085640be13ac8df36a55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;system tracer&lt;/strong&gt; for sequential tracing is automatically initiated by &lt;code&gt;ttb&lt;/code&gt; when a trace port is started with &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Система трассировщик&lt;/strong&gt; для последовательного отслеживания автоматически инициируется &lt;code&gt;ttb&lt;/code&gt; , когда порт трассировки запускается с &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33df7c3d6f3cf265ee046f5bbcec06d7fee2046" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;unordered set&lt;/strong&gt; containing the elements a, b, and c is denoted {a, b, c}. This notation is not to be confused with tuples.</source>
          <target state="translated">&lt;strong&gt;Неупорядоченный набор&lt;/strong&gt; , содержащий элементы , а, б, будем обозначать {A, B, C}. Это обозначение не следует путать с кортежами.</target>
        </trans-unit>
        <trans-unit id="338f2ff3d932d37a0203031cf3c8ecd12e555100" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;xmerl&lt;/strong&gt; XML parser is able to parse XML documents according to the XML 1.0 standard. As default it performs well-formed parsing, (syntax checks and checks of well-formed constraints). Optionally one can also use xmerl as a validating parser, (validate according to referenced DTD and validating constraints). By means of for example the xmerl_xs module it is possible to transform the parsed result to other formats, e.g. text, HTML, XML etc.</source>
          <target state="translated">&lt;strong&gt;Xmerl&lt;/strong&gt; XML парсер способен синтаксический анализ документов XML в соответствии со стандартом XML 1.0. По умолчанию он выполняет правильно сформированный синтаксический анализ (проверки синтаксиса и проверки правильно сформированных ограничений). При желании можно также использовать xmerl в качестве проверяющего синтаксического анализатора (проверять в соответствии с указанным DTD и проверять ограничения). С помощью, например, модуля xmerl_xs можно преобразовать проанализированный результат в другие форматы, например текст, HTML, XML и т. Д.</target>
        </trans-unit>
        <trans-unit id="639ddc138940995a6e19ca0db97584c255b5e3c9" translate="yes" xml:space="preserve">
          <source>The ACC time calculation is sometimes difficult to make correct, since it is difficult to define. This happens especially when a function occurs in several instances in the call stack, for example by calling itself perhaps through other functions and perhaps even non-tail recursively.</source>
          <target state="translated">Расчет времени ACC иногда трудно сделать правильным,так как его трудно определить.Особенно это бывает,когда функция происходит в нескольких случаях в стеке вызовов,например,при вызове себя,возможно,через другие функции и,возможно,даже не хвостовой рекурсивно.</target>
        </trans-unit>
        <trans-unit id="57e2a8ffba28b7446bf70cbc1663f4839a28353c" translate="yes" xml:space="preserve">
          <source>The AND intersection of the list &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt; is also easily defined:</source>
          <target state="translated">Пересечение AND списков &lt;code&gt;L1&lt;/code&gt; и &lt;code&gt;L2&lt;/code&gt; также легко определяется:</target>
        </trans-unit>
        <trans-unit id="03c2705073fe9051dbc22438c110997b433d5384" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt; logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ddb999f667f09a910e3689c6469b160527272a" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">API для ведения журнала состоит из набора &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; и набора функций в &lt;code&gt;logger:Level/1,2,3&lt;/code&gt; формы : Level / 1,2,3 , которые являются ярлыками для средства &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="38e9019f75b372bc1c195496de6c985d2c8006d1" translate="yes" xml:space="preserve">
          <source>The API functions in &lt;code&gt;uri_string&lt;/code&gt; work on two basic data types &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; represents a standard URI, while &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; is a wider datatype, that can represent URI components using &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; characters. &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; is a convenient choice for enabling operations such as producing standard compliant URIs out of components that have special or &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; characters. It is easier to explain this by an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d41ee39dfc3d3300eef2e7cc4120a5fd8d4f83d" translate="yes" xml:space="preserve">
          <source>The API is simple:</source>
          <target state="translated">API прост:</target>
        </trans-unit>
        <trans-unit id="d4aca81b201537abe8dedf009dd68114d62d46d3" translate="yes" xml:space="preserve">
          <source>The API provided by Windows.</source>
          <target state="translated">API,предоставляемый Windows.</target>
        </trans-unit>
        <trans-unit id="ea6764678e9074dc87171f45bcd4511b8aa2d4d8" translate="yes" xml:space="preserve">
          <source>The ASN.1 application provides the following:</source>
          <target state="translated">Приложение ASN.1 предусматривает следующее:</target>
        </trans-unit>
        <trans-unit id="9c1b6316b531e843db6912095bad2d7449901534" translate="yes" xml:space="preserve">
          <source>The ASN.1 code, the Erlang source code, and the generated &lt;code&gt;.hrl&lt;/code&gt; files for them are provided in the distribution and are placed in the directories &lt;code&gt;mibs&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt;, and &lt;code&gt;include&lt;/code&gt;, respectively, in the &lt;code&gt;snmp&lt;/code&gt; application.</source>
          <target state="translated">Код ASN.1, исходный код Erlang и сгенерированные для них файлы &lt;code&gt;.hrl&lt;/code&gt; предоставляются в дистрибутиве и помещаются в каталоги &lt;code&gt;mibs&lt;/code&gt; , &lt;code&gt;src&lt;/code&gt; и &lt;code&gt;include&lt;/code&gt; , соответственно, в приложении &lt;code&gt;snmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c076a03aaf6d1e948523fb216ccde0cc05b7f7" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler can be started directly from the command line by the &lt;code&gt;erlc&lt;/code&gt; program. This is convenient when compiling many ASN.1 files from the command line or when using Makefiles. Some examples of how the &lt;code&gt;erlc&lt;/code&gt; command can be used to start the ASN.1 compiler:</source>
          <target state="translated">Компилятор ASN.1 может быть запущен непосредственно из командной строки программой &lt;code&gt;erlc&lt;/code&gt; . Это удобно при компиляции большого количества файлов ASN.1 из командной строки или при использовании файлов Makefile. Некоторые примеры того, как можно использовать команду &lt;code&gt;erlc&lt;/code&gt; для запуска компилятора ASN.1:</target>
        </trans-unit>
        <trans-unit id="fb22058cd698b91ccb24c3e367daf392b4a590e1" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler takes an ASN.1 module as input and generates a corresponding Erlang module, which can encode and decode the specified data types. Alternatively, the compiler takes a specification module specifying all input modules, and generates a module with encode/decode functions. In addition, some generic functions can be used during development of applications that handles ASN.1 data (encoded as &lt;code&gt;BER&lt;/code&gt; or &lt;code&gt;PER&lt;/code&gt;).</source>
          <target state="translated">Компилятор ASN.1 принимает модуль ASN.1 в качестве входных данных и генерирует соответствующий модуль Erlang, который может кодировать и декодировать указанные типы данных. В качестве альтернативы компилятор берет модуль спецификации, определяющий все модули ввода, и генерирует модуль с функциями кодирования / декодирования. Кроме того, некоторые общие функции могут использоваться во время разработки приложений, которые обрабатывают данные ASN.1 (закодированные как &lt;code&gt;BER&lt;/code&gt; или &lt;code&gt;PER&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c60d4a11ddc52b500d299eda7e6852a95f2bae35" translate="yes" xml:space="preserve">
          <source>The ASN.1 specifications in the test were compiled with options &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; and &lt;code&gt;asn1config&lt;/code&gt;. Omitting option &lt;code&gt;driver&lt;/code&gt; gives higher values for &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;decode_part&lt;/code&gt;. These tests have not been rerun using NIFs, but are expected to perform about 5% better than the linked-in driver.</source>
          <target state="translated">Спецификации ASN.1 в тесте были скомпилированы с параметрами &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; и &lt;code&gt;asn1config&lt;/code&gt; . Опуская вариант &lt;code&gt;driver&lt;/code&gt; дает более высокие значения для &lt;code&gt;decode&lt;/code&gt; и &lt;code&gt;decode_part&lt;/code&gt; . Эти тесты не выполнялись повторно с использованием NIF, но ожидается, что они будут работать примерно на 5% лучше, чем связанный драйвер.</target>
        </trans-unit>
        <trans-unit id="2f22980605315f568d967ab23f6f0f04c10f0db4" translate="yes" xml:space="preserve">
          <source>The ASN.1 to Erlang compiler does not determine the correct interpretation of each BER string octet value with different character strings. The application is responsible for interpretation of octets. Therefore, from the BER string point of view, octets are very similar to character strings and are compiled in the same way.</source>
          <target state="translated">Компилятор ASN.1 к Erlang не определяет правильную интерпретацию каждого значения октета BER-строки с различными символьными строками.Приложение отвечает за интерпретацию октетов.Поэтому с точки зрения BER-строки октеты очень похожи на символьные строки и скомпилированы таким же образом.</target>
        </trans-unit>
        <trans-unit id="e882c6bd57a43305a3640939f477df3d4ead459d" translate="yes" xml:space="preserve">
          <source>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</source>
          <target state="translated">Тип ASN.1 может быть 'Сертификат','OTPCertificate' или подтипом любого из них.</target>
        </trans-unit>
        <trans-unit id="a7a7f7547a93bea8b589e07f519f153c18f157b7" translate="yes" xml:space="preserve">
          <source>The AVPs of the message. Ignored for an outgoing message if the &lt;code&gt;msg&lt;/code&gt; field is set to a value other than &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">AVP сообщения. Игнорируется для исходящего сообщения, если в поле &lt;code&gt;msg&lt;/code&gt; установлено значение, отличное от &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbe283419a75e9a012fbd1970d31d2b4f451187c" translate="yes" xml:space="preserve">
          <source>The Adler checksum of the dictionary is returned.</source>
          <target state="translated">Возвращается контрольная сумма Адлера в словаре.</target>
        </trans-unit>
        <trans-unit id="396f5f5683edcca9c1f25e63c5cdd3210d9fa913" translate="yes" xml:space="preserve">
          <source>The Anti-Replay protection feature in stateless servers executes in the following steps when a new ClientHello is received:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87eb8ebe47038b4ccdd22aaa97c4f88f2c5c087" translate="yes" xml:space="preserve">
          <source>The Application Id is set in the Diameter Header of outgoing messages of the application, and the value in the header of an incoming message is used to identify the relevant dictionary module.</source>
          <target state="translated">Идентификатор приложения устанавливается в заголовке Diameter (Диаметр)исходящих сообщений приложения,а значение в заголовке входящего сообщения используется для идентификации соответствующего модуля словаря.</target>
        </trans-unit>
        <trans-unit id="f5de0091f6607fa5ed052b8880c8cef363f44808" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to do the actual changing of the type.</source>
          <target state="translated">Журнал Audit Trail Log управляется процессом сетевого интерфейса.Таким образом,именно этот процесс должен делать фактическое изменение типа.</target>
        </trans-unit>
        <trans-unit id="4ffaae1f3e0b8fd90d36e73237642154e3434485" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to retrieve the actual log-type.</source>
          <target state="translated">Журнал Audit Trail Log управляется процессом сетевого интерфейса.Таким образом,именно этот процесс должен получить действительный тип лога.</target>
        </trans-unit>
        <trans-unit id="56bc2b11b64e2a80365e104579b5470c818d8f1f" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to return the actual log-type.</source>
          <target state="translated">Журнал Audit Trail Log управляется процессом сетевого интерфейса.Поэтому именно этот процесс должен возвращать действительный тип лога.</target>
        </trans-unit>
        <trans-unit id="5f534cf4748ee979b48f1dda16d8700a38a8db83" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:is_process_alive/1&lt;/code&gt; is the closest you can get to a process table lookup only. The BIF looks up the process corresponding to the process identifier passed as argument, and then checks if it is alive. By running multiple processes looping over this BIF checking the same process, we get a speedup between 20000-23000%. Conceptually this operation only involve read operations. In the implementation used in R16B also only read operation are performed, while the previous implementation need to lock structures in order to read the data, suffering from both lock contention and contention due to modifications of cache lines used by lock internal data structures and the reference counter on the process being looked up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9967052a764c3afae20ad96d6a28a3fa28a91f" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; can also add match specifications to a function. A match specification comprises a pattern that the function arguments must match, a guard expression that must evaluate to &lt;code&gt;true&lt;/code&gt;, and an action to be performed. The default action is to send a trace message. If the pattern does not match or the guard fails, the action is not executed.</source>
          <target state="translated">BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; также может добавлять спецификации соответствия к функции. Спецификация соответствия содержит шаблон, которому должны соответствовать аргументы функции, защитное выражение, которое должно быть &lt;code&gt;true&lt;/code&gt; , и действие, которое необходимо выполнить. Действие по умолчанию - отправить сообщение трассировки. Если шаблон не совпадает или защита не работает, действие не выполняется.</target>
        </trans-unit>
        <trans-unit id="0e87dd32697c643963810be073120b237d9b1c65" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;open_port/2&lt;/code&gt; is documented in the &lt;code&gt;erlang&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">БИФ &lt;code&gt;open_port/2&lt;/code&gt; описан в &lt;code&gt;erlang&lt;/code&gt; странице руководства в ЭРЦЕ.</target>
        </trans-unit>
        <trans-unit id="102d447ee7d66bcdc64a15b95caa727b7d5ec384" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; is used for estimating future loads. It returns the length of the queue of ready to run processes in the Erlang runtime system.</source>
          <target state="translated">&lt;code&gt;statistics(run_queue)&lt;/code&gt; BIF (run_queue) используется для оценки будущих нагрузок. Он возвращает длину очереди готовых к запуску процессов в системе времени выполнения Erlang.</target>
        </trans-unit>
        <trans-unit id="a6a407c55efe87e4b70f70a1f8c95515dc9b4791" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;throw(Any)&lt;/code&gt; can be used for non-local return from a function. It must be evaluated within a &lt;code&gt;catch&lt;/code&gt;, which returns the value &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;throw(Any)&lt;/code&gt; может использоваться для нелокального возврата из функции. Он должен быть вычислен в пределах &lt;code&gt;catch&lt;/code&gt; , который возвращает значение &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30ca995f69db34040dadf8f4fb8f2daa8f294d98" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; checks if a registered process of name &lt;code&gt;RegisteredName&lt;/code&gt; exists. If it exists, the pid of that process is returned. If it does not exist, the atom &lt;code&gt;undefined&lt;/code&gt; is returned.</source>
          <target state="translated">BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; проверяет, существует ли зарегистрированный процесс с именем &lt;code&gt;RegisteredName&lt;/code&gt; . Если он существует, возвращается pid этого процесса. Если он не существует, возвращается &lt;code&gt;undefined&lt;/code&gt; атом .</target>
        </trans-unit>
        <trans-unit id="6cbf1adc0d75868cfd46589662e75f0f79ed5cbb" translate="yes" xml:space="preserve">
          <source>The Bindings area, displaying all variables bindings. If you click a variable name, the value is displayed in the Evaluator area. Double-click a variable name to open a window where the variable value can be edited. Notice however that pid, port, reference, or fun values cannot be edited unless they can be represented in the running system.</source>
          <target state="translated">Область &quot;Связки&quot;,в которой отображаются все переменные связки.При щелчке по имени переменной значение отображается в области &quot;Evaluator&quot;.Дважды щелкните по имени переменной,чтобы открыть окно,в котором можно редактировать значение переменной.Однако обратите внимание,что значения pid,port,reference или fun нельзя редактировать,если они не могут быть представлены в работающей системе.</target>
        </trans-unit>
        <trans-unit id="4b6c3c38656309049129434a8a3888567bd5d33d" translate="yes" xml:space="preserve">
          <source>The Button area, with buttons for quick access to frequently used functions in the &lt;strong&gt;Process&lt;/strong&gt; menu.</source>
          <target state="translated">Область кнопок с кнопками для быстрого доступа к часто используемым функциям в меню &lt;strong&gt;процесса&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ada22f32dd020105bdc39ab625188b5d539d360a" translate="yes" xml:space="preserve">
          <source>The C driver is a module that is compiled and linked into a shared library. It uses a driver structure and includes the header file &lt;code&gt;erl_driver.h&lt;/code&gt;.</source>
          <target state="translated">Драйвер C - это модуль, который скомпилирован и связан с общей библиотекой. Он использует структуру драйвера и включает файл заголовка &lt;code&gt;erl_driver.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a7c12f419c3e677f26c1d74131f78103f5ccbf9" translate="yes" xml:space="preserve">
          <source>The C node can act as a server or a client when setting up the Erlang-C communication. If it acts as a client, it connects to an Erlang node by calling &lt;code&gt;erl_connect()&lt;/code&gt;, which returns an open file descriptor at success:</source>
          <target state="translated">Узел C может выступать в качестве сервера или клиента при настройке связи Erlang-C. Если он действует как клиент, он подключается к узлу Erlang, вызывая &lt;code&gt;erl_connect()&lt;/code&gt; , который в случае успеха возвращает дескриптор открытого файла:</target>
        </trans-unit>
        <trans-unit id="f778bcd020988cc52d7d8911bac363507b5bc1fe" translate="yes" xml:space="preserve">
          <source>The C node can receive a message from Erlang by calling &lt;code&gt;erl_receive msg()&lt;/code&gt;. This function reads data from the open file descriptor &lt;code&gt;fd&lt;/code&gt; into a buffer and puts the result in an &lt;code&gt;ErlMessage&lt;/code&gt; struct &lt;code&gt;emsg&lt;/code&gt;. &lt;code&gt;ErlMessage&lt;/code&gt; has a field &lt;code&gt;type&lt;/code&gt; defining what kind of data is received. In this case, the type of interest is &lt;code&gt;ERL_REG_SEND&lt;/code&gt; which indicates that Erlang sent a message to a registered process at the C node. The actual message, an &lt;code&gt;ETERM&lt;/code&gt;, is in the &lt;code&gt;msg&lt;/code&gt; field.</source>
          <target state="translated">Узел C может получить сообщение от Erlang, вызвав &lt;code&gt;erl_receive msg()&lt;/code&gt; . Эта функция считывает данные из дескриптора открытого файла &lt;code&gt;fd&lt;/code&gt; в буфер и помещает результат в качестве &lt;code&gt;ErlMessage&lt;/code&gt; STRUCT &lt;code&gt;emsg&lt;/code&gt; . &lt;code&gt;ErlMessage&lt;/code&gt; имеет &lt;code&gt;type&lt;/code&gt; поля, определяющий, какие данные принимаются. В этом случае интересующий тип - &lt;code&gt;ERL_REG_SEND&lt;/code&gt; , который указывает, что Erlang отправил сообщение зарегистрированному процессу на узле C. Фактическое сообщение, &lt;code&gt;ETERM&lt;/code&gt; , находится в поле &lt;code&gt;msg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec592580544dfa8a13cf79ebfaf21d822174fe76" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_make_pid()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13c2586709436dfbebc6149ffb9c1b130da4a2e" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_make_ref()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39af024e46f5af7c40347c42343f756bdbbc0a29" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_self()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cfee0b8169b38821cf004612b6024fa4504a22" translate="yes" xml:space="preserve">
          <source>The CA certificates specified for the connection will be used to construct the certificate chain validating the CRLs.</source>
          <target state="translated">Сертификаты CA,указанные для соединения,будут использоваться для построения цепочки сертификатов,подтверждающих CRL.</target>
        </trans-unit>
        <trans-unit id="9b711437028a29fd162a39304f7e85e3b67e2c19" translate="yes" xml:space="preserve">
          <source>The CGI script response comprises a message header and a message body, separated by a blank line. The message header contains one or more header fields. The body can be empty.</source>
          <target state="translated">Ответ CGI-скрипта состоит из заголовка сообщения и тела сообщения,разделенного пустой строкой.Заголовок сообщения содержит одно или несколько полей заголовка.Тело может быть пустым.</target>
        </trans-unit>
        <trans-unit id="4c3c9d660d39101e158d800c72dc5b3c5f71e86f" translate="yes" xml:space="preserve">
          <source>The CNT column shows the total number of function calls that was found in the trace. In the ACC column is the total time of the trace from first timestamp to last. And in the OWN column is the sum of the execution time in functions found in the trace, not including called functions. In this case it is very close to the ACC time since the emulator had practically nothing else to do than to execute our test program.</source>
          <target state="translated">В столбце CNT показано общее количество вызовов функций,найденных в трассе.В столбце ACC указано общее время трассировки с первой временной метки до последней.А в столбце OWN-сумма времени выполнения функций,найденных в трассе,без учета вызванных функций.В данном случае оно очень близко ко времени ACC,так как эмулятору практически не оставалось ничего,кроме как выполнить нашу тестовую программу.</target>
        </trans-unit>
        <trans-unit id="0bca2724268527bcfe47363d53f453d381e52758" translate="yes" xml:space="preserve">
          <source>The CPU topology is used when binding schedulers to logical processors. If schedulers are already bound when the CPU topology is changed, the schedulers are sent a request to rebind according to the new CPU topology.</source>
          <target state="translated">Топология процессора используется при привязке планировщиков к логическим процессорам.Если планировщики уже привязаны при изменении топологии процессора,то планировщики посылают запрос на перепривязку в соответствии с новой топологией процессора.</target>
        </trans-unit>
        <trans-unit id="3e338f2c345acced3a85f3002b3cdda7b33768c1" translate="yes" xml:space="preserve">
          <source>The CPU utilization is defined as the sum of the percentage shares of the CPU cycles spent in all busy processor states (see &lt;code&gt;util/1&lt;/code&gt; below) in average on all CPUs.</source>
          <target state="translated">Загрузка ЦП определяется как сумма процентных долей циклов ЦП, потраченных во всех состояниях занятости процессора (см. &lt;code&gt;util/1&lt;/code&gt; ниже) в среднем на всех ЦП.</target>
        </trans-unit>
        <trans-unit id="aa86529ffc420dbda732a44a0aa8bd483c1ae653" translate="yes" xml:space="preserve">
          <source>The CRL entry extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">Расширения записи CRL атомы имени OID и соответствующие им типы значений представлены ниже:</target>
        </trans-unit>
        <trans-unit id="270f1611da531780d2eaa5897949ee887332e027" translate="yes" xml:space="preserve">
          <source>The CRL extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">Расширения CRL-это атомы имени OID и соответствующие им типы значений:</target>
        </trans-unit>
        <trans-unit id="d9b7329cef621756a648262a641008c28933737d" translate="yes" xml:space="preserve">
          <source>The CRLs will be fetched from a local or external cache. See &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt;.</source>
          <target state="translated">CRL будут извлечены из локального или внешнего кеша. См. &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc03e6a9344836dc83866fc80ae58c6381b38386" translate="yes" xml:space="preserve">
          <source>The CRYPTO app has evolved during its lifetime. Since also the OpenSSL cryptolib has changed the API several times, there are parts of the CRYPTO app that uses a very old one internally and other parts that uses the latest one. The internal definitions of e.g cipher names was a bit hard to maintain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d829d39e1e62045ec8647a09fccc7a51c77978" translate="yes" xml:space="preserve">
          <source>The CT hook functions can call any logging function in the &lt;code&gt;ct&lt;/code&gt; interface to print information to the log files, or to add comments in the suite overview page.</source>
          <target state="translated">Функции ловушки CT могут вызывать любую функцию регистрации в интерфейсе &lt;code&gt;ct&lt;/code&gt; для печати информации в файлах журнала или для добавления комментариев на странице обзора пакета.</target>
        </trans-unit>
        <trans-unit id="3ec67be87ba83be4a6a36f46cae0a249d6c031c6" translate="yes" xml:space="preserve">
          <source>The Call Graph is  represented by Erlang terms (the sets are lists), which is suitable for many analyses. But for analyses that look at chains of calls, a list representation is much too slow. Instead the representation offered by the &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; module is used. The translation of the list representation of the Call Graph - or a subgraph thereof - to the &lt;code&gt;digraph&lt;/code&gt; representation does not come for free, so the language used for expressing queries to be described below has a special operator for this task and a possibility to save the &lt;code&gt;digraph&lt;/code&gt; representation for subsequent analyses.</source>
          <target state="translated">Граф вызовов представлен терминами Erlang (наборы представляют собой списки), что подходит для многих анализов. Но для анализа цепочек вызовов представление списка слишком медленно. Вместо этого используется представление, предлагаемое модулем &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; . Перевод представления списка графа вызовов - или его подграфа - в представление &lt;code&gt;digraph&lt;/code&gt; не является бесплатным, поэтому язык, используемый для выражения запросов, которые будут описаны ниже, имеет специальный оператор для этой задачи и возможность сохранять представление &lt;code&gt;digraph&lt;/code&gt; для последующего анализа.</target>
        </trans-unit>
        <trans-unit id="bce56cac593ab0a42cef53b33869a05dc52b528e" translate="yes" xml:space="preserve">
          <source>The Code area, displaying the code being executed. The code is indented and each line is prefixed with its line number. If the process execution is stopped, the current line is marked with &lt;code&gt;--&amp;gt;&lt;/code&gt;. An existing break point at a line is marked with a stop symbol. In the example shown in the illustration, the execution stopped at line 6, before the execution of &lt;code&gt;fac/1&lt;/code&gt;.</source>
          <target state="translated">Область кода, отображающая выполняемый код. Код имеет отступ, и каждая строка имеет префикс со своим номером. Если выполнение процесса остановлено, текущая строка помечается знаком &lt;code&gt;--&amp;gt;&lt;/code&gt; . Существующая точка останова на линии помечается символом остановки. В примере, показанном на иллюстрации, выполнение остановилось на строке 6 перед выполнением &lt;code&gt;fac/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4163ad4ae86ebef487e34acf3cb3b300872a11" translate="yes" xml:space="preserve">
          <source>The Common Message and Relay applications are the only applications that diameter itself has any specific knowledge of. The Common Message application is used for messages that diameter itself handles: CER/CEA, DWR/DWA and DPR/DPA. The Relay application is given special treatment with regard to encode/decode since the messages and AVPs it handles are not specifically defined.</source>
          <target state="translated">Общее сообщение и применение реле-это единственные приложения,которые сами по себе диаметром имеют специальные знания.Приложение Common Message (Общее сообщение)используется для сообщений,с которыми сам диаметр справляется:CER/CEA,DWR/DWA и DPR/DPA.Приложение &quot;Реле&quot; имеет специальную обработку в отношении кодирования/декодирования,так как сообщения и AVP,с которыми оно работает,специально не определены.</target>
        </trans-unit>
        <trans-unit id="314dbe1e2d1cb12d891485b91d81bb94162ddaf9" translate="yes" xml:space="preserve">
          <source>The Compliance column notes &lt;strong&gt;C&lt;/strong&gt; (Compliant) if the required functionality is implemented, &lt;strong&gt;PC&lt;/strong&gt; (Partially Compliant) if there are limitations, &lt;strong&gt;NC&lt;/strong&gt; (Not Compliant) if functionality is not implemented, or a dash if text is informational or only places requirements that must be met by the user's implementation.</source>
          <target state="translated">В столбце &amp;laquo; Соответствие&amp;raquo; указано &lt;strong&gt;C&lt;/strong&gt; (соответствует), если необходимая функциональность реализована, &lt;strong&gt;PC&lt;/strong&gt; (частично соответствует), если есть ограничения, &lt;strong&gt;NC&lt;/strong&gt; (не соответствует), если функциональность не реализована, или тире, если текст является информационным или содержит только требования, которые должны быть выполнены. встречены реализацией пользователя.</target>
        </trans-unit>
        <trans-unit id="cb5797134c742f2284426627bbcaee9db9ff4f9b" translate="yes" xml:space="preserve">
          <source>The ControlPid may be the identity of a process residing on another Erlang node. This is useful when you want to distribute a user over several Erlang nodes. In such a case one of the nodes has the physical connection. When a user residing on one of the other nodes needs to send a request (with megaco:call/3 or megaco:cast/3), the message will encoded on the originating Erlang node, and then be forwarded to the node with the physical connection. When the reply arrives, it will be forwarded back to the originator. The distributed connection may explicitly be deactivated by a local call to megaco:disconnect/2 or implicitly when the physical connection is deactivated (with megaco:disconnect/2, killing the controlling process, halting the other node, ...).</source>
          <target state="translated">ControlPid может быть идентификатором процесса,находящегося на другом узле Erlang.Это полезно,когда вы хотите распределить пользователя по нескольким узлам Erlang.В этом случае один из узлов имеет физическое соединение.Когда пользователю,проживающему на одном из других узлов,необходимо отправить запрос (с megaco:call/3 или megaco:cast/3),сообщение будет закодировано на исходящем узле Erlang,а затем перенаправлено на узел с физической связью.Когда ответ придет,он будет переадресован обратно отправителю.Распределенное соединение может быть явно деактивировано местным звонком на megaco:disconnect/2 или неявно,когда физическое соединение деактивировано (с megaco:disconnect/2,убивающим управляющий процесс,останавливающим другой узел,....).</target>
        </trans-unit>
        <trans-unit id="78df27997f59e3cf7a226f97555796fd4db3b167" translate="yes" xml:space="preserve">
          <source>The Crashdump Viewer is a WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">Crashdump Viewer-это инструмент на основе WxWidgets для просмотра Erlang crashdumps.</target>
        </trans-unit>
        <trans-unit id="e25b4f2128c61d45f1244bb1e42a65e6c254444f" translate="yes" xml:space="preserve">
          <source>The Cs (Surrogate) property applies only to characters in the range U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested by PCRE. Perl does not support the Cs property.</source>
          <target state="translated">Свойство Cs (Surrogate)применяется только к символам в диапазоне от U+D800 до U+DFFF.Такие символы недействительны в строках Юникода и поэтому не могут быть проверены PCRE.Perl не поддерживает свойство Cs.</target>
        </trans-unit>
        <trans-unit id="8d8b1e5940b411ae8301615a457804bfb0094984" translate="yes" xml:space="preserve">
          <source>The DER encoder omits the encoding for the same &lt;code&gt;BIT STRING&lt;/code&gt;:</source>
          <target state="translated">Кодировщик DER опускает кодировку для той же &lt;code&gt;BIT STRING&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9e781b3302f49ad7b6f93f77b8bb63523e6ee75c" translate="yes" xml:space="preserve">
          <source>The DER-encoded Diffie-Hellman parameters. If specified, it overrides option &lt;code&gt;dhfile&lt;/code&gt;.</source>
          <target state="translated">Параметры Диффи-Хеллмана, закодированные в формате DER. Если указано, он переопределяет параметр &lt;code&gt;dhfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e05b3ca4b742f1e879494bc5c683f33ec025ce" translate="yes" xml:space="preserve">
          <source>The DER-encoded trusted certificates. If this option is supplied it overrides option &lt;code&gt;cacertfile&lt;/code&gt;.</source>
          <target state="translated">Доверенные сертификаты в кодировке DER. Если этот параметр указан, он имеет приоритет над параметром &lt;code&gt;cacertfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ba530c04cbce9e372b32aee5f085b4acb4f0137" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt; crypto:engine_load/4 &lt;/code&gt; and &lt;code&gt; Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503452c36c49cb1fd0ea949662ea239d8f9105d2" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt;crypto:engine_load/4&lt;/code&gt; and &lt;code&gt;Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="translated">Закрытый ключ пользователя, закодированный в DER, или карта, относящаяся к криптографическому движку, и его ссылка на ключ, который при желании может быть защищен паролем, см. Также &lt;code&gt;crypto:engine_load/4&lt;/code&gt; и &lt;code&gt;Crypto's Users Guide&lt;/code&gt; . Если этот параметр указан, он переопределяет параметр &lt;code&gt;keyfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1412b8d79c31037e94ec8ee160cfa882f7bfb3fb" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">Сертификат пользователя в кодировке DER. Если указана эта опция, она переопределяет параметр &lt;code&gt;certfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d494bd359efefc011e29e6ca8af7b8607707f9" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. Note that the cert option may also be a list of DER-encoded certificates where the first one is the users certificate and the rest of the certificates constitutes the certificate chain. For maximum interoperability the certificates in the chain should be in the correct order, the chain will be sent as is to the peer. If chain certificates are not provided, certificates from &lt;code&gt;&lt;a href=&quot;#type-client_cacerts&quot;&gt;client_cacerts()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-server_cacerts&quot;&gt;server_cacerts()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#type-client_cafile&quot;&gt;client_cafile()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-server_cafile&quot;&gt;server_cafile()&lt;/a&gt;&lt;/code&gt; are used to construct the chain. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00e40d2bc93d885d8856a1b65b6e1164cd7cb96" translate="yes" xml:space="preserve">
          <source>The Data Structures of the Distribution Driver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f2f74a7edc47541dafb29c006cde23cd47d9fe" translate="yes" xml:space="preserve">
          <source>The Diameter header of the message. Can be (and typically should be) &lt;code&gt;undefined&lt;/code&gt; for an outgoing message in a non-relay application, in which case diameter provides appropriate values.</source>
          <target state="translated">Заголовок сообщения Diameter. Может быть (и обычно должно быть) &lt;code&gt;undefined&lt;/code&gt; для исходящего сообщения в приложении без ретрансляции, и в этом случае диаметр обеспечивает соответствующие значения.</target>
        </trans-unit>
        <trans-unit id="5efc1791e653c1599eb1a85a25bc63fbc5f68900" translate="yes" xml:space="preserve">
          <source>The EPMD closes the socket when it has sent the information.</source>
          <target state="translated">EPMD закрывает гнездо после отправки информации.</target>
        </trans-unit>
        <trans-unit id="e75f4961aac2a4105e4523a54d7cf3b30606ca91" translate="yes" xml:space="preserve">
          <source>The ERTS memory allocators manage memory blocks in two types of raw memory chunks. We call these chunks of raw memory &lt;strong&gt;carriers&lt;/strong&gt;. Single-block carriers which only contain one large block, and multi-block carriers which contain multiple blocks. A carrier is typically created using &lt;code&gt;mmap()&lt;/code&gt; on unix systems. However, how a carrier is created is of minor importance. An allocator instance typically manages a mixture of single- and multi-block carriers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657accf9a74a7eb0b025905c51aa524bbb4f52c3" translate="yes" xml:space="preserve">
          <source>The ETS type of the dumped table (that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;duplicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;). This type is used when loading the table again.</source>
          <target state="translated">Тип ETS &lt;code&gt;ordered_set&lt;/code&gt; таблицы (то есть &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; , &lt;code&gt;duplicate_bag&lt;/code&gt; или orders_set ). Этот тип используется при повторной загрузке таблицы.</target>
        </trans-unit>
        <trans-unit id="37bd9159078f20014405583883e1e7838b1f320f" translate="yes" xml:space="preserve">
          <source>The EUnit framework makes it extremely easy to write unit tests in Erlang. There are a few different ways of writing them, though, so we start with the simplest:</source>
          <target state="translated">EUnit-фреймворк позволяет чрезвычайно легко писать юнит-тесты в Эрланге.Однако есть несколько различных способов их написания,поэтому мы начинаем с самого простого:</target>
        </trans-unit>
        <trans-unit id="fa53810c7a30463d78bce3f01ea7ecca8bb2337e" translate="yes" xml:space="preserve">
          <source>The Edward curves &lt;code&gt;x25519&lt;/code&gt; and &lt;code&gt;x448&lt;/code&gt; are supported with OpenSSL 1.1.1 or later if not disabled by configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e6615a6259b426a5c1aa433aefd48dfe9f0730" translate="yes" xml:space="preserve">
          <source>The Election Process</source>
          <target state="translated">Избирательный процесс</target>
        </trans-unit>
        <trans-unit id="d7e47fd1c3278cd7de4abd1246ff9d0b6caf0c35" translate="yes" xml:space="preserve">
          <source>The Encoding can be changed for a file &quot;on the fly&quot; by using function &lt;code&gt;io:setopts/2&lt;/code&gt;. So a file can be analyzed in latin1 encoding for, for example, a BOM, positioned beyond the BOM and then be set for the right encoding before further reading. For functions identifying BOMs, see module &lt;code&gt;unicode(3)&lt;/code&gt;.</source>
          <target state="translated">Кодировку можно изменить для файла &amp;laquo;на лету&amp;raquo; с помощью функции &lt;code&gt;io:setopts/2&lt;/code&gt; . Таким образом, файл может быть проанализирован в кодировке latin1, например, для спецификации, расположенной за пределами спецификации, а затем быть установлен для правильной кодировки перед дальнейшим чтением. Для функций, определяющих спецификации, см. Модуль &lt;code&gt;unicode(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ce07ca3d080f90844cafbb92cdb028293480a0" translate="yes" xml:space="preserve">
          <source>The Erlang &lt;strong&gt;error logger&lt;/strong&gt; is an event manager (see &lt;code&gt;OTP Design Principles&lt;/code&gt; and &lt;code&gt;gen_event(3)&lt;/code&gt;), registered as &lt;code&gt;error_logger&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Регистратор ошибок&lt;/strong&gt; Erlang - это менеджер событий (см. &lt;code&gt;OTP Design Principles&lt;/code&gt; и &lt;code&gt;gen_event(3)&lt;/code&gt; ), зарегистрированный как &lt;code&gt;error_logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6cec8bd2bf7434e290f227203641824a28b2253" translate="yes" xml:space="preserve">
          <source>The Erlang API allows using arbitrary curve parameters, but in FIPS mode only those allowed by the Security Policy shall be used.</source>
          <target state="translated">API Erlang позволяет использовать произвольные параметры кривых,но в режиме FIPS должны использоваться только те параметры,которые разрешены Политикой безопасности.</target>
        </trans-unit>
        <trans-unit id="1e13d1897ff2db6a5ca229af1382794e443a1fe1" translate="yes" xml:space="preserve">
          <source>The Erlang API of the crypto application is identical regardless of building with or without FIPS support. However the nif code internally uses a different OpenSSL API.</source>
          <target state="translated">API Erlang крипто-приложения идентичны независимо от сборки с поддержкой FIPS или без нее.Тем не менее,код nif внутренне использует другой API OpenSSL.</target>
        </trans-unit>
        <trans-unit id="48490447d94b14d0abe2e04b21fbd8bf2b9b8cdb" translate="yes" xml:space="preserve">
          <source>The Erlang BIF &lt;code&gt;spawn&lt;/code&gt; is used to create a new process: &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt;. Consider the following module:</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; Erlang BIF используется для создания нового процесса: &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt; . Рассмотрим следующий модуль:</target>
        </trans-unit>
        <trans-unit id="bc260aee970be8377de4dc3244ea906f03e3f766" translate="yes" xml:space="preserve">
          <source>The Erlang BIFs.</source>
          <target state="translated">БИФы Эрланга.</target>
        </trans-unit>
        <trans-unit id="8938c14ae46ae4bc9fd254a9382eb3df9c381a7c" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt; Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fe49d5ed45f059cc301355028f8dfef080429d" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">Протокол распространения Erlang сам по себе небезопасен и не предназначен для этого. Чтобы обеспечить безопасное распространение, распределенные узлы должны быть настроены для использования распределения по tls. См. Руководство пользователя &amp;laquo; &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; &amp;raquo; для получения подробной информации о том, как настроить безопасный распределенный узел.</target>
        </trans-unit>
        <trans-unit id="a40f7e40db92a7107a9e3a5cac4b4ab65b30339c" translate="yes" xml:space="preserve">
          <source>The Erlang Emulator</source>
          <target state="translated">Эмулятор Эрланга</target>
        </trans-unit>
        <trans-unit id="99377f0e14b45ce54e27b19f84ce7e618a01753c" translate="yes" xml:space="preserve">
          <source>The Erlang I/O-system has been designed (or at least used) in a way where you expect any I/O server to handle any string data. That is, however, no longer the case when working with Unicode characters. The Erlang programmer must now know the capabilities of the device where the data ends up. Also, ports in Erlang are byte-oriented, so an arbitrary string of (Unicode) characters cannot be sent to a port without first converting it to an encoding of choice.</source>
          <target state="translated">Система ввода/вывода Erlang была разработана (или,по крайней мере,использована)таким образом,что вы ожидаете,что любой сервер ввода/вывода будет обрабатывать любые строковые данные.Однако,это больше не так при работе с символами Юникода.Теперь программист Erlang должен знать возможности устройства,в котором заканчиваются данные.Кроме того,порты на Эрланге ориентированы на байты,поэтому произвольная строка символов (Unicode)не может быть отправлена на порт без предварительной конвертации в кодировку по выбору.</target>
        </trans-unit>
        <trans-unit id="81cc438ebd93249f6378dd48a6614f5a8c1d4ea2" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application consists of both &lt;code&gt;Erlang&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; code. The &lt;code&gt;C&lt;/code&gt; code is delivered as a precompiled executable for windows, solaris and linux (SLES10) in the commercial build. In the open source distribution it is built the same way as all other application using configure and make. You may want to provide the the path to your ODBC libraries using --with-odbc=PATH.</source>
          <target state="translated">Приложение Erlang ODBC состоит из кода &lt;code&gt;Erlang&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; .Код &lt;code&gt;C&lt;/code&gt; поставляется в виде предварительно скомпилированного исполняемого файла для Windows, Solaris и Linux (SLES10) в коммерческой сборке. В дистрибутиве с открытым исходным кодом он построен так же, как и все другие приложения, с использованием configure и make. Вы можете указать путь к вашим библиотекам ODBC, используя --with-odbc = PATH.</target>
        </trans-unit>
        <trans-unit id="8a4351bfa2f995c6bd330803859435f644586add" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should run on all Unix dialects including Linux, Windows 2000, Windows XP and NT. But currently it is only tested for Solaris, Windows 2000, Windows XP and NT.</source>
          <target state="translated">Приложение Erlang ODBC должно работать на всех диалектах Unix,включая Linux,Windows 2000,Windows XP и NT.Но в настоящее время оно протестировано только для Solaris,Windows 2000,Windows XP и NT.</target>
        </trans-unit>
        <trans-unit id="c54f824f83f969a528f4d85db8ff3bf2b47f63fe" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should work for any relational database that has an ODBC driver. But currently it is only regularly tested for &lt;code&gt;sqlserver&lt;/code&gt; and &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">Приложение Erlang ODBC должно работать с любой реляционной базой данных, имеющей драйвер ODBC. Но в настоящее время он регулярно тестируется только для &lt;code&gt;sqlserver&lt;/code&gt; и &lt;code&gt;postgres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d474f74418b8768698a57fb6613d328b379dec3" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC interface is in principal database independent, e.i. an erlang program using the interface could be run without changes towards different databases. But as SQL is used it is alas possible to write database dependent programs. Even though SQL is an ANSI-standard meant to be database independent, different databases have proprietary extensions to SQL defining their own data types. If you keep to the ANSI data types you will minimize the problem. But unfortunately there is no guarantee that all databases actually treats the ANSI data types equivalently. For instance an installation of &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; will accept that you create a table column with the ANSI data type &lt;code&gt;integer&lt;/code&gt;, but when retrieving values from this column the driver reports that it is of type &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; and not &lt;code&gt;SQL_INTEGER&lt;/code&gt; as you may have expected.</source>
          <target state="translated">Интерфейс Erlang ODBC в основном не зависит от базы данных, например, программа на Erlang, использующая этот интерфейс, может быть запущена без изменений в других базах данных. Но поскольку используется SQL, можно писать программы, зависящие от базы данных. Несмотря на то, что SQL является стандартом ANSI, который должен быть независимым от базы данных, разные базы данных имеют собственные расширения SQL, определяющие их собственные типы данных. Если вы будете придерживаться типов данных ANSI, вы минимизируете проблему. Но, к сожалению, нет гарантии, что все базы данных фактически одинаково обрабатывают типы данных ANSI. Например, установка &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; примет, что вы создаете столбец таблицы с &lt;code&gt;integer&lt;/code&gt; типа данных ANSI., но при получении значений из этого столбца драйвер сообщает, что это тип &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; а не &lt;code&gt;SQL_INTEGER&lt;/code&gt; , как вы могли ожидать.</target>
        </trans-unit>
        <trans-unit id="56a64c0ae629896e0d315a11fe6e47437de08daf" translate="yes" xml:space="preserve">
          <source>The Erlang Port Mapper Daemon &lt;strong&gt;epmd&lt;/strong&gt; is automatically started at every host where an Erlang node is started. It is responsible for mapping the symbolic node names to machine addresses. See the &lt;code&gt;epmd(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">&lt;strong&gt;Epmd&lt;/strong&gt; демона &lt;strong&gt;сопоставления&lt;/strong&gt; портов Erlang автоматически запускается на каждом хосте, на котором запущен узел Erlang. Он отвечает за отображение символьных имен узлов на машинные адреса. См. &lt;code&gt;epmd(1)&lt;/code&gt; руководства epmd (1) в ERTS.</target>
        </trans-unit>
        <trans-unit id="d980add9dd240554f189b1c3b37b65443fa21bb5" translate="yes" xml:space="preserve">
          <source>The Erlang Runtime System Application, ERTS, contains functionality necessary to run the Erlang system.</source>
          <target state="translated">Приложение Erlang Runtime System Application,ERTS,содержит функциональность,необходимую для работы системы Erlang.</target>
        </trans-unit>
        <trans-unit id="ec553e20bbac1faf44d07e9ebb7fae6ca5046122" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the SSL/TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Приложение Erlang SSL реализует протокол SSL / TLS / DTLS для поддерживаемых в настоящее время версий, см. Страницу руководства &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ca09abc1780869abd79ed38a1d8065b44531491" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c184aeafc9a6a8c3c28dfd4fc9896eddb1e7172" translate="yes" xml:space="preserve">
          <source>The Erlang Token Scanner returns tokens with a subset of the following annotations, depending on the options:</source>
          <target state="translated">Сканер Erlang Token возвращает маркеры с подмножеством следующих примечаний,в зависимости от опций:</target>
        </trans-unit>
        <trans-unit id="f44e036ac3f33332c9617d1ca93feead49accb2d" translate="yes" xml:space="preserve">
          <source>The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.</source>
          <target state="translated">В ВМ Эрланга используется библиотека PCRE,где используется куча памяти,когда происходит рекурсия совпадения регулярных выражений.Это ограничивает использование машинной кучи,а не стека C.</target>
        </trans-unit>
        <trans-unit id="8d4936bbce5dce7c69c00ed9e6d923ffdcef1207" translate="yes" xml:space="preserve">
          <source>The Erlang archives are &lt;code&gt;ZIP&lt;/code&gt; files with extension &lt;code&gt;.ez&lt;/code&gt;. Erlang archives can also be enclosed in &lt;code&gt;escript&lt;/code&gt; files whose file extension is arbitrary.</source>
          <target state="translated">Архивы Erlang представляют собой &lt;code&gt;ZIP&lt;/code&gt; - файлы с расширением &lt;code&gt;.ez&lt;/code&gt; . Архивы Erlang также могут быть заключены в файлы &lt;code&gt;escript&lt;/code&gt; с произвольным расширением.</target>
        </trans-unit>
        <trans-unit id="75458bb55fedfe4d27d190b85b2453fc10e6e94f" translate="yes" xml:space="preserve">
          <source>The Erlang code in the &quot;Erlang code.&quot; section is written into the output file directly after the module declaration and predefined exports declaration so it is possible to add extra exports, define imports and other attributes which are then visible in the whole file.</source>
          <target state="translated">Код Erlang в разделе &quot;Код Erlang.&quot; записывается в выходной файл непосредственно после декларации модуля и предопределенной декларации экспорта,так что можно добавлять дополнительные экспорты,определять импорты и другие атрибуты,которые затем видны во всем файле.</target>
        </trans-unit>
        <trans-unit id="9bada6b35e4702ac9e1f602bd85f459a9e5c8d11" translate="yes" xml:space="preserve">
          <source>The Erlang code is slightly different, as we do not return the result synchronously from &lt;code&gt;port_control&lt;/code&gt;, instead we get it from &lt;code&gt;driver_output&lt;/code&gt; as data in the message queue. The function &lt;code&gt;return_port_data&lt;/code&gt; above receives data from the port. As the data is in binary format, we use &lt;code&gt;binary_to_term/1&lt;/code&gt; to convert it to an Erlang term. Notice that the driver is opened in binary mode (&lt;code&gt;open_port/2&lt;/code&gt; is called with option &lt;code&gt;[binary]&lt;/code&gt;). This means that data sent from the driver to the emulator is sent as binaries. Without option &lt;code&gt;binary&lt;/code&gt;, they would have been lists of integers.</source>
          <target state="translated">Код Erlang немного отличается, поскольку мы не возвращаем результат синхронно из &lt;code&gt;port_control&lt;/code&gt; , вместо этого мы получаем его из &lt;code&gt;driver_output&lt;/code&gt; как данные в очереди сообщений. Функция &lt;code&gt;return_port_data&lt;/code&gt; выше получает данные из порта. Поскольку данные находятся в двоичном формате, мы используем &lt;code&gt;binary_to_term/1&lt;/code&gt; , чтобы преобразовать их в термин Erlang. Обратите внимание, что драйвер открывается в двоичном режиме ( &lt;code&gt;open_port/2&lt;/code&gt; вызывается с опцией &lt;code&gt;[binary]&lt;/code&gt; ). Это означает, что данные, отправляемые драйвером в эмулятор, отправляются в виде двоичных файлов. Без &lt;code&gt;binary&lt;/code&gt; опций они были бы списками целых чисел.</target>
        </trans-unit>
        <trans-unit id="57d172985612cd6cd41a2f597d2b75bb27821e07" translate="yes" xml:space="preserve">
          <source>The Erlang code linter.</source>
          <target state="translated">Подложка с кодом Эрланга.</target>
        </trans-unit>
        <trans-unit id="a5138a7c32b5f91b090191893db4bd11097e1026" translate="yes" xml:space="preserve">
          <source>The Erlang code preprocessor includes functions that are used by the &lt;code&gt;compile&lt;/code&gt; module to preprocess macros and include files before the parsing takes place.</source>
          <target state="translated">Препроцессор кода Erlang включает функции, которые используются модулем &lt;code&gt;compile&lt;/code&gt; для предварительной обработки макросов и включения файлов до того, как будет произведен синтаксический анализ.</target>
        </trans-unit>
        <trans-unit id="392fc9728278e4892ea581cefb80f74c12d7912e" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt; crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d403e45ee407cb0dd03528fe23bfb406bd2d6ae" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="translated">Аварийный дамп Erlang претерпел серьезные изменения в Erlang / OTP R9C. Поэтому информация в этом разделе не применима напрямую для старых дампов. Однако, если вы используете &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; для старых дампов, аварийные дампы переводятся в формат, подобный этому.</target>
        </trans-unit>
        <trans-unit id="737305746ee3808d6e58fd2718a7d171052eb3a2" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump is a readable text file, but it can be difficult to read. Using the Crashdump Viewer tool in the &lt;code&gt;Observer&lt;/code&gt; application simplifies the task. This is a wx-widget-based tool for browsing Erlang crash dumps.</source>
          <target state="translated">Аварийный дамп Erlang - это читаемый текстовый файл, но он может быть трудным для чтения. Использование инструмента Crashdump Viewer в приложении &lt;code&gt;Observer&lt;/code&gt; упрощает задачу. Это инструмент на основе wx-виджетов для просмотра аварийных дампов Erlang.</target>
        </trans-unit>
        <trans-unit id="3019fbc7ca6a8b1745aa1cb4e5822a66509aa10a" translate="yes" xml:space="preserve">
          <source>The Erlang crashdump contains a listing of each living Erlang process in the system. The following fields can exist for a process:</source>
          <target state="translated">Erlang crashdump содержит список каждого живого процесса Erlang в системе.Для процесса могут существовать следующие поля:</target>
        </trans-unit>
        <trans-unit id="db00cf758cc1a463b96d0532ae1f4b69cef5510a" translate="yes" xml:space="preserve">
          <source>The Erlang distribution can in theory use almost any connection-based protocol as bearer. However, a module that implements the protocol-specific parts of the connection setup is needed. The default distribution module is &lt;code&gt;inet_tcp_dist&lt;/code&gt; in the Kernel application. When starting an Erlang node distributed, &lt;code&gt;net_kernel&lt;/code&gt; uses this module to set up listen ports and connections.</source>
          <target state="translated">Теоретически дистрибутив Erlang может использовать в качестве носителя практически любой протокол на основе соединения. Однако необходим модуль, реализующий специфические для протокола части настройки соединения. Модуль распространения по умолчанию - &lt;code&gt;inet_tcp_dist&lt;/code&gt; в приложении ядра. При запуске распределенного узла Erlang &lt;code&gt;net_kernel&lt;/code&gt; использует этот модуль для настройки портов прослушивания и соединений.</target>
        </trans-unit>
        <trans-unit id="5c65eb0e7a3b5fcbd2b82941f0e7502510e7adf8" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API can be used in conjunction with the POSIX thread API on UN-ices and with the Windows native thread API on Windows. The Erlang driver thread API has the advantage of being portable, but there can exist situations where you want to use functionality from the POSIX thread API or the Windows native thread API.</source>
          <target state="translated">Потоковый API драйвера Erlang может использоваться совместно с POSIX thread API на UN-ices и с Windows native thread API на Windows.Потоковое API драйверов Erlang имеет преимущество переносимости,но могут возникнуть ситуации,когда вы захотите использовать функциональность POSIX thread API или Windows native thread API.</target>
        </trans-unit>
        <trans-unit id="cd35f4981de74aaf8658339a6b773ed029b97baf" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API only returns error codes when it is reasonable to recover from an error condition. If it is not reasonable to recover from an error condition, the whole runtime system is terminated. For example, if a create mutex operation fails, an error code is returned, but if a lock operation on a mutex fails, the whole runtime system is terminated.</source>
          <target state="translated">Потоковый API драйвера Erlang возвращает коды ошибок только в том случае,если есть смысл восстанавливаться из состояния ошибки.Если восстановление из состояния ошибки нецелесообразно,то вся работающая система завершается.Например,если операция создания мьютекса не удается,возвращается код ошибки,но если операция блокировки мьютекса не удается,то завершается работа всей исполняющей системы.</target>
        </trans-unit>
        <trans-unit id="f886f4ca7d89492a5c1356ea054f392597b34344" translate="yes" xml:space="preserve">
          <source>The Erlang editing mode provides a command that knows about the Erlang comment structure and can be used to fill text paragraphs in comments. Ex:</source>
          <target state="translated">Режим редактирования Erlang предоставляет команду,которая знает о структуре комментариев Erlang и может быть использована для заполнения текстовых параграфов в комментариях.Бывший</target>
        </trans-unit>
        <trans-unit id="6381e25503c0fb716dfd00aadaa0608beadd9a69" translate="yes" xml:space="preserve">
          <source>The Erlang emulator is found by examining the registry keys for the emulator version specified in the release data file. The new emulator must be properly installed before the upgrade for this to work.</source>
          <target state="translated">Эмулятор Erlang можно найти,изучив ключи реестра для версии эмулятора,указанной в файле данных версии.Новый эмулятор должен быть правильно установлен перед обновлением,чтобы это работало.</target>
        </trans-unit>
        <trans-unit id="6339e932f018732bcd165eb1f04f836a77855588" translate="yes" xml:space="preserve">
          <source>The Erlang emulator keeps track of a &lt;strong&gt;stack trace&lt;/strong&gt;, information about recent function calls. This information is used if an error occurs, for example:</source>
          <target state="translated">Эмулятор Erlang отслеживает &lt;strong&gt;трассировку стека&lt;/strong&gt; , информацию о последних вызовах функций. Эта информация используется при возникновении ошибки, например:</target>
        </trans-unit>
        <trans-unit id="17cd3f882b4ce1af8737a7262e13ec5ab23b1f5e" translate="yes" xml:space="preserve">
          <source>The Erlang emulator.</source>
          <target state="translated">Эмулятор Эрланга.</target>
        </trans-unit>
        <trans-unit id="5714cdd55594ddeb51b48625444a53558a829eec" translate="yes" xml:space="preserve">
          <source>The Erlang external term format is a representation of an Erlang term as a sequence of bytes, that is, a binary. Conversion between the two representations is done using the following BIFs:</source>
          <target state="translated">Формат внешнего термина Erlang представляет собой представление термина Erlang в виде последовательности байтов,то есть двоичной последовательности.Преобразование между двумя представлениями осуществляется с помощью следующих BIF-файлов:</target>
        </trans-unit>
        <trans-unit id="152d4b6905d9f607d0072156b089899f65fd52eb" translate="yes" xml:space="preserve">
          <source>The Erlang implementation is &quot;clever&quot; and minimizes the number of times each message is tested against the patterns in each &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">Реализация Erlang &amp;laquo;умна&amp;raquo; и сводит к минимуму количество проверок каждого сообщения на соответствие шаблонам в каждом &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79a0b3cf2e8db83679b557ee8aff89fcae6b1c98" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter can also be accessed through the interface module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Интерпретатор Erlang также доступен через интерфейсный модуль &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ca39c39b895d99de154868388ab2c941551645" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter provides mechanisms for breakpoints and stepwise execution of code. It is primarily intended to be used by Debugger, see the User's Guide and &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Интерпретатор Erlang предоставляет механизмы для точек останова и пошагового выполнения кода. Он в первую очередь предназначен для использования отладчиком, см. Руководство пользователя и &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe42365ca090c07c2f31a18aa82078cc7413a46" translate="yes" xml:space="preserve">
          <source>The Erlang language is described in the &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang Reference Manual&lt;/a&gt;. An Erlang tutorial can be found in &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;.</source>
          <target state="translated">Язык Erlang описан в &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Справочном руководстве&lt;/a&gt; по Erlang . Учебник по Erlang можно найти в &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;Приступая к работе с Erlang&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c86834683bf25d823843edf61397923bc0c7af5" translate="yes" xml:space="preserve">
          <source>The Erlang language specification puts no limits on the number of processes, length of atoms, and so on. However, for performance and memory saving reasons, there will always be limits in a practical implementation of the Erlang language and execution environment.</source>
          <target state="translated">Спецификация языка Эрланг не устанавливает ограничений на количество процессов,длину атомов и так далее.Однако из соображений производительности и экономии памяти,в практической реализации языка Erlang и среды исполнения всегда будут существовать ограничения.</target>
        </trans-unit>
        <trans-unit id="5868365d112b2d753afe38d0282d35341218fb05" translate="yes" xml:space="preserve">
          <source>The Erlang literal syntax for strings uses the &quot;\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\&quot;.</source>
          <target state="translated">Синтаксис литерала Эрланг для строк использует символ &quot;\&quot; (обратная косая черта)в качестве экранирующего кода.Вам нужно экранировать обратные слеши в литеральных строках,как в вашем коде,так и в оболочке,с дополнительным обратным слешем,то есть &quot;\\&quot;.</target>
        </trans-unit>
        <trans-unit id="7436c6776e46ff0b0c98637a1562d8d93f74d6d7" translate="yes" xml:space="preserve">
          <source>The Erlang meta interpreter.</source>
          <target state="translated">Мета-переводчик Эрланга.</target>
        </trans-unit>
        <trans-unit id="6dd0afebea808766c4e5ba67702ba9bcda564088" translate="yes" xml:space="preserve">
          <source>The Erlang mode does, of course, provide this feature. The layout used is based on the common use of the language.</source>
          <target state="translated">Режим Эрланг,конечно же,предоставляет эту функцию.Используемая раскладка основана на общем использовании языка.</target>
        </trans-unit>
        <trans-unit id="e03b514fa1c315e1fd202d5ceb91d82531266ba5" translate="yes" xml:space="preserve">
          <source>The Erlang mode for the Emacs editor includes two &lt;code&gt;Common Test&lt;/code&gt; test suite templates, one with extensive information in the function headers, and one with minimal information. A test suite template provides a quick start for implementing a suite from scratch and gives a good overview of the available callback functions. The two templates follows:</source>
          <target state="translated">Режим Erlang для редактора Emacs включает два шаблона набора тестов &lt;code&gt;Common Test&lt;/code&gt; , один с обширной информацией в заголовках функций, а другой с минимальной информацией. Шаблон набора тестов обеспечивает быстрое начало реализации набора с нуля и дает хороший обзор доступных функций обратного вызова. Следующие два шаблона:</target>
        </trans-unit>
        <trans-unit id="bd1e16dd7e3186a437be6f5c58e6b98f95a1b6f2" translate="yes" xml:space="preserve">
          <source>The Erlang module can look as follows:</source>
          <target state="translated">Модуль Эрланг может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="4e4823fe40646d231f25e1af4061079540646bbb" translate="yes" xml:space="preserve">
          <source>The Erlang nif library contains function for easily working with I/O vectors as used by the unix system call &lt;code&gt;writev&lt;/code&gt;. The I/O Queue is not thread safe, so some other synchronization mechanism has to be used.</source>
          <target state="translated">Библиотека Erlang nif содержит функцию для простой работы с векторами ввода-вывода, используемую системным вызовом &lt;code&gt;writev&lt;/code&gt; в unix . Очередь ввода-вывода не является потокобезопасной, поэтому необходимо использовать какой-то другой механизм синхронизации.</target>
        </trans-unit>
        <trans-unit id="4fe4b7ddd1b6e3fddbfb0dc8eba68674fa92a0bc" translate="yes" xml:space="preserve">
          <source>The Erlang node is to be given the short name &lt;code&gt;e1&lt;/code&gt; and must be set to use the same magic cookie as the C node, &lt;code&gt;secretcookie&lt;/code&gt;:</source>
          <target state="translated">Узлу Erlang нужно дать короткое имя &lt;code&gt;e1&lt;/code&gt; и настроить на использование того же волшебного файла cookie, что и для узла C, &lt;code&gt;secretcookie&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b252e3e3ea1acfeb31712ba10c8bb1164cc7e6f7" translate="yes" xml:space="preserve">
          <source>The Erlang nodes have different cookies.</source>
          <target state="translated">У узлов Эрланга разные куки.</target>
        </trans-unit>
        <trans-unit id="2dac1fcc04ff2d796878d2e221f0d3d0504eeff3" translate="yes" xml:space="preserve">
          <source>The Erlang parser.</source>
          <target state="translated">Эрлангский парсер.</target>
        </trans-unit>
        <trans-unit id="e3e1a66870ceefa4057accb399287057807ab241" translate="yes" xml:space="preserve">
          <source>The Erlang part of the asynchronous driver consists of the sample file &lt;code&gt;pg_async.erl&lt;/code&gt;.</source>
          <target state="translated">Часть асинхронного драйвера на Erlang состоит из файла &lt;code&gt;pg_async.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a9c70ac47d5fb1df5bdc0c1579a6d354d215f36" translate="yes" xml:space="preserve">
          <source>The Erlang pretty printer.</source>
          <target state="translated">Симпатичный принтер Эрланга.</target>
        </trans-unit>
        <trans-unit id="8092d1a007430220494c776fea5b8d0105151629" translate="yes" xml:space="preserve">
          <source>The Erlang process creating a port is said to be the &lt;strong&gt;port owner&lt;/strong&gt;, or the &lt;strong&gt;connected process&lt;/strong&gt; of the port. All communication to and from the port must go through the port owner. If the port owner terminates, so does the port (and the external program, if it is written correctly).</source>
          <target state="translated">Процесс Erlang, создающий порт, называется &lt;strong&gt;владельцем порта&lt;/strong&gt; или &lt;strong&gt;связанным процессом&lt;/strong&gt; порта. Все коммуникации в порт и из порта должны проходить через владельца порта. Если владелец порта завершает свою работу, порт (и внешняя программа, если она написана правильно) прекращает работу.</target>
        </trans-unit>
        <trans-unit id="27d54a521c2a5287aa3d01d2b57bd9e14da9ddb9" translate="yes" xml:space="preserve">
          <source>The Erlang representation for &quot;BMPString&quot; and &quot;UniversalString&quot; is either a list of ASCII values or a list of quadruples. The quadruple representation associates to the Unicode standard representation of characters. The ASCII characters are all represented by quadruples beginning with three zeros like {0,0,0,65} for character 'A'. When decoding a value for these strings, the result is a list of quadruples, or integers when the value is an ASCII character.</source>
          <target state="translated">Представление Erlang для &quot;BMPString&quot; и &quot;UniversalString&quot; является либо списком ASCII-значений,либо списком четырёхкратных.Четырехкратное представление ассоциируется со стандартным представлением символов в Unicode.Все ASCII-символы представлены четырёхугольниками,начинающимися с трёх нулей типа {0,0,0,65}для символа 'A'.При декодировании значения для этих строк в результате получается список четырёхугольников,или целых чисел,когда значение является ASCII символом.</target>
        </trans-unit>
        <trans-unit id="fd34b0812f3e91023a25d2d60c73c4062e69913a" translate="yes" xml:space="preserve">
          <source>The Erlang representation of an ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; is an integer or an atom if a &lt;code&gt;Named Number List&lt;/code&gt; (see &lt;code&gt;T6&lt;/code&gt; in the previous list) is specified.</source>
          <target state="translated">Представление в Эрланге ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; является целым числом или атомом, если указан список &lt;code&gt;Named Number List&lt;/code&gt; (см. &lt;code&gt;T6&lt;/code&gt; в предыдущем списке).</target>
        </trans-unit>
        <trans-unit id="6762086b168330d83da3710e72be56df1e3f3f82" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system can use the complete 32-bit (or 64-bit) address space, but the operating system often limits a single process to use less than that.</source>
          <target state="translated">Система исполнения Erlang может использовать полное 32-битное (или 64-битное)адресное пространство,но операционная система часто ограничивает использование одного процесса меньшим количеством.</target>
        </trans-unit>
        <trans-unit id="b825bf5f9dd97f4fdde610e1f993f6d1d34418b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system requires that the contents of the script used to boot the system is a binary Erlang term. This function transforms the &lt;code&gt;File.script&lt;/code&gt; boot script to a binary term, which is stored in the &lt;code&gt;File.boot&lt;/code&gt; file.</source>
          <target state="translated">Система времени выполнения Erlang требует, чтобы содержимое скрипта, используемого для загрузки системы, было двоичным термином Erlang. Эта функция преобразует &lt;code&gt;File.script&lt;/code&gt; загрузки File.script в двоичный термин, который хранится в файле &lt;code&gt;File.boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1ce0572c42ceec3f568ad1851dad4770b2b84b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system uses a generational garbage collection scheme, using an &quot;old heap&quot; for data that has survived at least one garbage collection. When there is no more room on the old heap, a fullsweep garbage collection is done.</source>
          <target state="translated">Система исполнения Erlang использует схему сбора мусора поколениями,используя &quot;старую кучу&quot; для данных,которые пережили по крайней мере один сбор мусора.Когда на старой куче больше нет места,производится полномасштабный сбор мусора.</target>
        </trans-unit>
        <trans-unit id="1b5c1cc2b8bfec92e6852fd54565f25ead94806c" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt; erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d9f6b0df9097bbff53b037dc4f96145ca6dbd2" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Взгляд системы времени выполнения Erlang на время &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; . Чтобы получить его, вызовите &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175c0bd0d93fcd68af4b41f5bd3ed0c1384dfa2e" translate="yes" xml:space="preserve">
          <source>The Erlang scanner in the &lt;code&gt;io&lt;/code&gt; module can be used as a starting point when writing a new scanner. Study &lt;code&gt;yeccscan.erl&lt;/code&gt; in order to see how a filter can be added on top of &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; to provide a scanner for Yecc that tokenizes grammar files before parsing them with the Yecc parser. A more general approach to scanner implementation is to use a scanner generator. A scanner generator in Erlang called &lt;code&gt;leex&lt;/code&gt; is under development.</source>
          <target state="translated">Сканер Erlang в модуле &lt;code&gt;io&lt;/code&gt; можно использовать в качестве отправной точки при написании нового сканера. Изучите &lt;code&gt;yeccscan.erl&lt;/code&gt; , чтобы увидеть, как можно добавить фильтр поверх &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; , чтобы предоставить сканер для Yecc, который токенизирует файлы грамматики перед их синтаксическим анализом с помощью парсера Yecc. Более общий подход к реализации сканера - использование генератора сканера. Генератор сканеров на Erlang под названием &lt;code&gt;leex&lt;/code&gt; находится в стадии разработки.</target>
        </trans-unit>
        <trans-unit id="37265f6197faced222d42e8a4148f58e5b966cea" translate="yes" xml:space="preserve">
          <source>The Erlang server interface is implemented by module &lt;code&gt;mod_esi&lt;/code&gt;.</source>
          <target state="translated">Интерфейс сервера Erlang реализован модулем &lt;code&gt;mod_esi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa8c45ba50425e13e797fcc4854bc1fcf3424403" translate="yes" xml:space="preserve">
          <source>The Erlang shell available over SSH</source>
          <target state="translated">Оболочка Эрланга доступна по SSH.</target>
        </trans-unit>
        <trans-unit id="fa1d76065068bd2589fcd099c8a0c8156db2a1c8" translate="yes" xml:space="preserve">
          <source>The Erlang shell understands the command &lt;code&gt;c(Module)&lt;/code&gt; which both compiles and loads &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">Оболочка Erlang понимает команду &lt;code&gt;c(Module)&lt;/code&gt; которая компилирует и загружает &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5dceee96a25b9a8c7bf615c2130bf76584510ce" translate="yes" xml:space="preserve">
          <source>The Erlang shell.</source>
          <target state="translated">Панцирь Эрланга.</target>
        </trans-unit>
        <trans-unit id="a51205151ea58d8438ebe29c7d0e6218f72ff948" translate="yes" xml:space="preserve">
          <source>The Erlang source code has support for the UTF-8 encoding and bytewise encoding. The default in Erlang/OTP R16B was bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. It was changed to UTF-8 in Erlang/OTP 17.0. You can control the encoding by a comment like the following in the beginning of the file:</source>
          <target state="translated">Исходный код Erlang поддерживает кодировку UTF-8 и побайтовую кодировку. По умолчанию в Erlang / OTP R16B используется побайтная &lt;code&gt;latin1&lt;/code&gt; ( latin1 ). Он был изменен на UTF-8 в Erlang / OTP 17.0. Вы можете контролировать кодировку с помощью комментария, подобного следующему, в начале файла:</target>
        </trans-unit>
        <trans-unit id="469909cd3bb80b2a08960dcf0954a2e053c206c4" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;code&gt;encoding&lt;/code&gt; is selected by a comment in one of the first two lines of the source file. The first string that matches the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is an invalid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; исходного файла Erlang выбирается с помощью комментария в одной из первых двух строк исходного файла. Первая строка, которая соответствует &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; регулярного выражения \ s * [: =] \ s * ([- a-zA-Z0-9]) +, выбирает кодировку. Если совпадающая строка является недопустимой кодировкой, она игнорируется. Допустимые кодировки: &lt;code&gt;Latin-1&lt;/code&gt; и &lt;code&gt;UTF-8&lt;/code&gt; , где регистр символов можно выбирать произвольно.</target>
        </trans-unit>
        <trans-unit id="e7ddb53385af1f6753c8713a645cc1fc36907bac" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;strong id=&quot;encoding&quot;&gt;encoding&lt;/strong&gt; is selected by a comment in one of the first two lines of the source file. The first string matching the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">&lt;strong id=&quot;encoding&quot;&gt;Кодировка&lt;/strong&gt; исходного файла Erlang выбирается с помощью комментария в одной из первых двух строк исходного файла. Первая строка, соответствующая &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; регулярного выражения \ s * [: =] \ s * ([- a-zA-Z0-9]) +, выбирает кодировку. Если совпадающая строка не является допустимой кодировкой, она игнорируется. Допустимые кодировки: &lt;code&gt;Latin-1&lt;/code&gt; и &lt;code&gt;UTF-8&lt;/code&gt; , где регистр символов можно выбирать произвольно.</target>
        </trans-unit>
        <trans-unit id="978c7190f27ebbf14f966c1feadf6f5410de9629" translate="yes" xml:space="preserve">
          <source>The Erlang system must be started.</source>
          <target state="translated">Система Эрланг должна быть запущена.</target>
        </trans-unit>
        <trans-unit id="c9941ae0e376a140dd219d96c5fea5aedb3770d4" translate="yes" xml:space="preserve">
          <source>The Erlang token scanner.</source>
          <target state="translated">Сканер жетонов Эрланга.</target>
        </trans-unit>
        <trans-unit id="a16c12a6b02ac800a11334f62d3a994378ac0165" translate="yes" xml:space="preserve">
          <source>The Erlang web server API data types are as follows:</source>
          <target state="translated">Типы данных API веб-сервера Erlang следующие:</target>
        </trans-unit>
        <trans-unit id="682db584bdb9aa3dd1062d8f6e41de11a4e999fd" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH application is intended to be used in other applications as a library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834fb47d95be27590d99f014c1a5220c8d723132" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH server after a succesful authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce8792731cffaac51f7760932b74501269d8966" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH server checks the user name and password in the following order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d28c591e7208c326a531484ecbb2f3de4814d0" translate="yes" xml:space="preserve">
          <source>The Evaluator area, where you can evaluate functions within the context of the debugged process, if that process execution is stopped.</source>
          <target state="translated">Область &quot;Evaluator&quot;,где можно оценить функции в контексте отлаживаемого процесса,если исполнение этого процесса остановлено.</target>
        </trans-unit>
        <trans-unit id="b8f527b2c601f16975ba4c3206247d354cc52722" translate="yes" xml:space="preserve">
          <source>The FTP client always tries to use passive FTP mode and only resort to active FTP mode if this fails. This default behavior can be changed by start option &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Клиент FTP всегда пытается использовать пассивный режим FTP и прибегает к активному режиму FTP только в случае сбоя. Это поведение по умолчанию можно изменить с помощью &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; параметров запуска .</target>
        </trans-unit>
        <trans-unit id="46eb4343e573b38e361697e41777d053a18c2fba" translate="yes" xml:space="preserve">
          <source>The FTP client can be started and stopped dynamically in runtime by calling the &lt;code&gt;ftp&lt;/code&gt; application API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; and &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt;.</source>
          <target state="translated">FTP - клиент может быть запущен и динамически остановлен во время выполнения путем вызова &lt;code&gt;ftp&lt;/code&gt; приложений API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; и &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ff37cf016753285c00cfe38b14f6b9064cd0bb5" translate="yes" xml:space="preserve">
          <source>The Flex scanner is a Megaco scanner written as a linked in driver (in C). There are two ways to get this working:</source>
          <target state="translated">Сканер Flex-это сканер Megaco,записанный в виде ссылки на драйвер (в букве C).Есть два способа заставить это работать:</target>
        </trans-unit>
        <trans-unit id="8bd0f2f59d01566729720bb338392aa95bc03bec" translate="yes" xml:space="preserve">
          <source>The Fragment ID is used to number the fragments in a sequence. The id starts at the total number of fragments and then decrements to 1 (which is the final fragment). So if a sequence consists of 3 fragments the fragment id in the starting header will be 3, and then fragments 2 and 1 are sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6270c4ff6807ee1959a0d7d8287c7ee55db3319" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-2&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0817c2658a9f234929df429f0abce5aa05ce329d" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="translated">Fun также можно передать в качестве аргумента функции &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt; , которая позволяет использовать настраиваемые модули обратного вызова для доступа к активности. Его можно получить либо напрямую, указав имя модуля в качестве аргумента, либо неявно, используя параметр конфигурации &lt;code&gt;access_module&lt;/code&gt; . Настроенный модуль обратного вызова может использоваться для нескольких целей, таких как предоставление триггеров, ограничений целостности, статистики времени выполнения или виртуальных таблиц.</target>
        </trans-unit>
        <trans-unit id="279188337fe7d9611837624292436a6f0c6df988" translate="yes" xml:space="preserve">
          <source>The GC_REGEXP definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491576369b07d94c026adb9d94add3cd468dc1c6" translate="yes" xml:space="preserve">
          <source>The GUI main window is opened when Crashdump Viewer has loaded a crashdump. It contains a title bar, a menu bar, information tabs, and a status bar.</source>
          <target state="translated">Главное окно GUI открывается,когда Crashdump Viewer загрузил crashdump.Оно содержит строку заголовка,строку меню,информационные вкладки и строку состояния.</target>
        </trans-unit>
        <trans-unit id="468c9cc0468cc5c92ee919e07070c915b671da34" translate="yes" xml:space="preserve">
          <source>The GetNext Operation operation should only be defined for tables since the agent can find the next instance of plain variables in the MIB and call the instrumentation with the &lt;code&gt;get&lt;/code&gt; operation.</source>
          <target state="translated">Операцию GetNext Operation следует определять только для таблиц, поскольку агент может найти следующий экземпляр простых переменных в MIB и вызвать инструментарий с помощью операции &lt;code&gt;get&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca4179f6bcde085d4b0d34f9240821a74141f758" translate="yes" xml:space="preserve">
          <source>The Gregorian calendar in this module is extended back to year 0. For a given date, the &lt;strong&gt;gregorian days&lt;/strong&gt; is the number of days up to and including the date specified. Similarly, the &lt;strong&gt;gregorian seconds&lt;/strong&gt; for a specified date and time is the number of seconds up to and including the specified date and time.</source>
          <target state="translated">Григорианский календарь в этом модуле расширен до года 0. Для данной даты григорианские &lt;strong&gt;дни&lt;/strong&gt; - это количество дней до указанной даты включительно. Точно так же &lt;strong&gt;григорианские секунды&lt;/strong&gt; для указанной даты и времени - это количество секунд до указанной даты и времени включительно.</target>
        </trans-unit>
        <trans-unit id="6a32364a7c7faf5d1cbacad811c6e3a642e6422e" translate="yes" xml:space="preserve">
          <source>The HTML overview log file is updated with test results.</source>
          <target state="translated">Лог-файл обзора HTML обновляется результатами тестирования.</target>
        </trans-unit>
        <trans-unit id="7141eac40a2b0f12431f108b64d289e030f4933d" translate="yes" xml:space="preserve">
          <source>The HTML tags allowed in &lt;code&gt;application/erlang+html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab4263cb8d1f32842025f35d2e34059d6bef33e" translate="yes" xml:space="preserve">
          <source>The HTML version of the test suite source code is not generated during the test run (and is consequently not available in the log file system).</source>
          <target state="translated">HTML-версия исходного кода тестового набора не генерируется во время выполнения теста (и,следовательно,не доступна в файловой системе логов).</target>
        </trans-unit>
        <trans-unit id="e41fc71ae08f56427cd0499723a4d95a81e54bc2" translate="yes" xml:space="preserve">
          <source>The HTTP client and server are HTTP 1.1 compliant as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Клиент и сервер HTTP соответствуют стандарту HTTP 1.1, как определено в &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfa130fdcfe18e8ac6a3dda8703a94eb6f80401b" translate="yes" xml:space="preserve">
          <source>The HTTP client and server are HTTP 1.1 compliant as defined in &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3e013cebd4679eacc44ce278db16ae997e7553" translate="yes" xml:space="preserve">
          <source>The HTTP client default profile is started when the &lt;code&gt;Inets&lt;/code&gt; application is started and is then available to all processes on that Erlang node. Other profiles can also be started at application startup, or profiles can be started and stopped dynamically in runtime. Each client profile spawns a new process to handle each request, unless a persistent connection can be used with or without pipelining. The client adds a &lt;code&gt;host&lt;/code&gt; header and an empty &lt;code&gt;te&lt;/code&gt; header if there are no such headers present in the request.</source>
          <target state="translated">Профиль клиента HTTP по умолчанию запускается при &lt;code&gt;Inets&lt;/code&gt; приложения Inets и затем становится доступным для всех процессов на этом узле Erlang. Другие профили также можно запускать при запуске приложения, или профили можно запускать и останавливать динамически во время выполнения. Каждый профиль клиента порождает новый процесс для обработки каждого запроса, если постоянное соединение не может использоваться с конвейерной обработкой или без нее. Клиент добавляет заголовок &lt;code&gt;host&lt;/code&gt; и пустой заголовок &lt;code&gt;te&lt;/code&gt; , если в запросе нет таких заголовков.</target>
        </trans-unit>
        <trans-unit id="7c7ba7538b9c9c0121b49c6ec91168734deba0dc" translate="yes" xml:space="preserve">
          <source>The HTTP server, also referred to as httpd, handles HTTP requests as described in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; with a few exceptions, such as gateway and proxy functionality. The server supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">HTTP-сервер, также называемый httpd, обрабатывает HTTP-запросы, как описано в &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; , с некоторыми исключениями, такими как функции шлюза и прокси. Сервер поддерживает IPv6, если это поддерживают и базовые механизмы.</target>
        </trans-unit>
        <trans-unit id="5ba20a4773acfe0c238a663c431dfe6ce0c1a228" translate="yes" xml:space="preserve">
          <source>The HTTP server, also referred to as httpd, handles HTTP requests as described in &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; with a few exceptions, such as gateway and proxy functionality. The server supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5f93e75e8af313b179c6713c54eb1bf37d9eef" translate="yes" xml:space="preserve">
          <source>The HTTP standard requires them to be case insensitive. Use this feature only if there is no other way to communicate with the server or for testing purpose. When this option is used, no headers are automatically added. All necessary headers must be provided by the user.</source>
          <target state="translated">Стандарт HTTP требует,чтобы они не чувствительны к регистру.Используйте эту функцию только в том случае,если нет другого способа связи с сервером или в тестовых целях.При использовании данной опции заголовки автоматически не добавляются.Все необходимые заголовки должны быть предоставлены пользователем.</target>
        </trans-unit>
        <trans-unit id="f2d85de81f5fcc8588a618440bb02e8ae50bca16" translate="yes" xml:space="preserve">
          <source>The HTTP status code returned to the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Код состояния HTTP, возвращенный клиенту ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="227a5bc37ce15e886828e8d7a86d97d575be63c9" translate="yes" xml:space="preserve">
          <source>The HTTP status code returned to the client (&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0035abf3b99831613dc762c61fbb26c4588f4e" translate="yes" xml:space="preserve">
          <source>The Handshake in Detail</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b82e39a63325ee5467a0018be1f905eeb2f7c52" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described earlier. A packet is either a request, a response, a header, or an end of header mark. Invalid lines are returned as &lt;code&gt;HttpError&lt;/code&gt;.</source>
          <target state="translated">Протокол передачи гипертекста. Пакеты возвращаются в формате согласно описанному ранее &lt;code&gt;HttpPacket&lt;/code&gt; . Пакет представляет собой запрос, ответ, заголовок или конец заголовка. Недействительные строки возвращаются как &lt;code&gt;HttpError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3946370c047884fbf4c2f18670e43abd4a1961c1" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt; erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169734960811a4c34c5ce86c1d456ff7cf230d3e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="translated">Протокол передачи гипертекста. Пакеты возвращаются в формате согласно &lt;code&gt;HttpPacket&lt;/code&gt; , описанному в &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; в ERTS. Сокет в пассивном режиме возвращает &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; из &lt;code&gt;gen_tcp:recv&lt;/code&gt; ,в то время как активный сокет отправляет сообщения типа &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fdd97c77238f0d4bc1a4b8495b731166db58155" translate="yes" xml:space="preserve">
          <source>The I/O device used when Erlang is started with the &quot;-oldshell&quot; or &quot;-noshell&quot; flags is by default set to &lt;code&gt;latin1&lt;/code&gt; encoding, meaning that any characters &amp;gt; codepoint 255 are escaped and that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors are in UTF-8 (regardless of operating system).</source>
          <target state="translated">Устройство ввода-вывода, используемое при запуске Erlang с флагами &amp;laquo;-oldshell&amp;raquo; или &amp;laquo;-noshell&amp;raquo;, по умолчанию установлено на кодировку &lt;code&gt;latin1&lt;/code&gt; , что означает, что любые символы&amp;gt; кодовой точки 255 экранируются, и ожидается, что ввод будет простым 8-битным ISO Latin-1. Если кодировка изменена на Unicode, входные и выходные данные из стандартных файловых дескрипторов находятся в UTF-8 (независимо от операционной системы).</target>
        </trans-unit>
        <trans-unit id="3a9ee44bfdadb9768492101f1c57f8171e2439fd" translate="yes" xml:space="preserve">
          <source>The I/O protocol in Erlang enables bi-directional communication between clients and servers.</source>
          <target state="translated">Протокол ввода/вывода в Эрланге обеспечивает двунаправленную связь между клиентами и серверами.</target>
        </trans-unit>
        <trans-unit id="da4b71eee53848cfe7e0ded6f806a23b361aa596" translate="yes" xml:space="preserve">
          <source>The I/O server can, for a list of requests, send any of the following valid results in the reply, depending on the requests in the list:</source>
          <target state="translated">Для списка запросов сервер ввода/вывода может отправить любой из следующих действительных результатов в ответ,в зависимости от запросов в списке:</target>
        </trans-unit>
        <trans-unit id="7bf03aa38e2e7b2e9d865676ed62c6ed1b166de9" translate="yes" xml:space="preserve">
          <source>The I/O server is a process that handles the requests and performs the requested task on, for example, an I/O device.</source>
          <target state="translated">Сервер ввода/вывода-это процесс,который обрабатывает запросы и выполняет запрошенную задачу,например,на устройстве ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="29324f42eeb70cb428190b9afb707250b51d08e0" translate="yes" xml:space="preserve">
          <source>The I/O server is to send one of the following as &lt;code&gt;Reply&lt;/code&gt;:</source>
          <target state="translated">Сервер ввода-вывода должен отправить одно из следующего в качестве &lt;code&gt;Reply&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cffff6188b7c071be58063158f15f52414545611" translate="yes" xml:space="preserve">
          <source>The I/O server is to send the &lt;code&gt;Reply&lt;/code&gt; as:</source>
          <target state="translated">Сервер ввода-вывода должен отправить &lt;code&gt;Reply&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="a68a34b093217c6e79f51f56360324a76a6607db" translate="yes" xml:space="preserve">
          <source>The I/O server replies to the client with an &lt;code&gt;io_reply&lt;/code&gt; tuple, where element &lt;code&gt;Reply&lt;/code&gt; is one of:</source>
          <target state="translated">Сервер ввода-вывода отвечает клиенту кортежем &lt;code&gt;io_reply&lt;/code&gt; , где элемент &lt;code&gt;Reply&lt;/code&gt; является одним из:</target>
        </trans-unit>
        <trans-unit id="d6984e80e5ec40501eed04b79f0e90cd3e1a039b" translate="yes" xml:space="preserve">
          <source>The I/O server replies:</source>
          <target state="translated">Сервер ввода/вывода отвечает:</target>
        </trans-unit>
        <trans-unit id="615c499b56501d6b2d674044444c5cd252a3aa4d" translate="yes" xml:space="preserve">
          <source>The I/O vector used by the emulator and drivers is a list of binaries, with a &lt;code&gt;SysIOVec&lt;/code&gt; pointing to the buffers of the binaries. It is used in &lt;code&gt;driver_outputv&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; driver callback. Also, the driver queue is an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">Вектор ввода-вывода, используемый эмулятором и драйверами, представляет собой список двоичных файлов, при этом &lt;code&gt;SysIOVec&lt;/code&gt; указывает на буферы двоичных файлов. Он используется в &lt;code&gt;driver_outputv&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; драйвера outputv . Кроме того, очередь драйверов - это &lt;code&gt;ErlIOVec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11486f73702f77793d0c501dded54bd9d9a0b366" translate="yes" xml:space="preserve">
          <source>The ID of the handler (which is &lt;code&gt;false&lt;/code&gt; if it was registered without an ID).</source>
          <target state="translated">ID обработчика ( &lt;code&gt;false&lt;/code&gt; если он был зарегистрирован без ID).</target>
        </trans-unit>
        <trans-unit id="5910e0f627e6ac1682f658faee394e4ef0132c80" translate="yes" xml:space="preserve">
          <source>The IDs contains normal fully qualified domain names like e.g &lt;code&gt;foo.example.com&lt;/code&gt;, but IP addresses are not recommended. The rfc describes why this is not recommended as well as security considerations about how to aquire the Reference IDs.</source>
          <target state="translated">Идентификаторы содержат обычные полностью определенные доменные имена, например, &lt;code&gt;foo.example.com&lt;/code&gt; , но использовать IP-адреса не рекомендуется. RFC описывает, почему это не рекомендуется, а также соображения безопасности о том, как получить ссылочные идентификаторы.</target>
        </trans-unit>
        <trans-unit id="ba43ecb0debcc2f97c4e2d5e92d1fb358277b19c" translate="yes" xml:space="preserve">
          <source>The IF() macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28f4dac9c4ee5d63c861a672e8fdeba64970c63" translate="yes" xml:space="preserve">
          <source>The IP addresses must be specified in the standard form (four decimal numbers separated by periods, for example, &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt;. Hosts names are not acceptable, but a broadcast address (preferably limited to the local network) is.</source>
          <target state="translated">IP-адреса должны быть указаны в стандартной форме (четыре десятичных числа, разделенных &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt; , например, &amp;laquo;150.236.20.74&amp;raquo; . Имена хостов недопустимы, но допустим широковещательный адрес (желательно ограниченный локальной сетью).</target>
        </trans-unit>
        <trans-unit id="8e52fe37494dbcf6555873254ea719776b067efd" translate="yes" xml:space="preserve">
          <source>The IP_ADJUSTMENT pre-bound variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74be3487335549a3ba00af3a4220139041a986e4" translate="yes" xml:space="preserve">
          <source>The Inets services API.</source>
          <target state="translated">API сервиса Inets.</target>
        </trans-unit>
        <trans-unit id="2bd655ea5793b54cfcef1365f007ad296dab65da" translate="yes" xml:space="preserve">
          <source>The Interpret Modules window is used for selecting which modules to interpret. Initially, the window displays the modules (&lt;code&gt;erl&lt;/code&gt; files) and subdirectories of the current working directory.</source>
          <target state="translated">Окно Интерпретировать модули используется для выбора модулей для интерпретации. Первоначально в окне отображаются модули ( файлы &lt;code&gt;erl&lt;/code&gt; ) и подкаталоги текущего рабочего каталога.</target>
        </trans-unit>
        <trans-unit id="46568e5f2d41b68efc3d2efed445ca9d877dd874" translate="yes" xml:space="preserve">
          <source>The Kernel application has all the code necessary to run the Erlang runtime system: file servers, code servers, and so on.</source>
          <target state="translated">Приложение Kernel имеет весь код,необходимый для запуска системы Erlang:файловые серверы,кодовые серверы и так далее.</target>
        </trans-unit>
        <trans-unit id="1d2901750e4e178866aa29af00b9514d934b8cb3" translate="yes" xml:space="preserve">
          <source>The Kernel application is the first application started. It is mandatory in the sense that the minimal system based on Erlang/OTP consists of Kernel and STDLIB. Kernel contains the following functional areas:</source>
          <target state="translated">Приложение Kernel является первым запущенным приложением.Это обязательно в том смысле,что минимальная система,основанная на Erlang/OTP,состоит из ядра и STDLIB.Ядро содержит следующие функциональные области:</target>
        </trans-unit>
        <trans-unit id="393233a88750cf4fe6f8a18919929901cb57f040" translate="yes" xml:space="preserve">
          <source>The Kernel configuration parameter &lt;code&gt;global_groups&lt;/code&gt; defines the global groups (see also &lt;code&gt;kernel(6)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Параметр конфигурации ядра &lt;code&gt;global_groups&lt;/code&gt; определяет глобальные группы (см. Также &lt;code&gt;kernel(6)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="329d0e8d9e7fbac7a43bba657580181c6f878afc" translate="yes" xml:space="preserve">
          <source>The Kernel/STDLIB applications are damaged or the start script is damaged.</source>
          <target state="translated">Повреждены приложения Kernel/STDLIB или стартовый скрипт.</target>
        </trans-unit>
        <trans-unit id="ce538f925bf84002c38fbd4dc502029a22341ac9" translate="yes" xml:space="preserve">
          <source>The Leex module should be considered experimental as it will be subject to changes in future releases.</source>
          <target state="translated">Модуль Leex следует считать экспериментальным,так как он будет подвержен изменениям в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="c848076de058785ede6b2e785124e2cf00899a54" translate="yes" xml:space="preserve">
          <source>The Linux Trace Toolkit: next generation is an open source system software package for correlated tracing of the Linux kernel, user applications and libraries.</source>
          <target state="translated">Linux Trace Toolkit:следующее поколение системного программного обеспечения с открытым исходным кодом для коррелированной трассировки ядра Linux,пользовательских приложений и библиотек.</target>
        </trans-unit>
        <trans-unit id="9b5f802a372a8d9f81e47da8ffe942e03e117399" translate="yes" xml:space="preserve">
          <source>The Logger backend forwards log events from the API, first through a set of &lt;strong&gt;primary filters&lt;/strong&gt;, then through a set of secondary filters attached to each log handler. The secondary filters are in the following named &lt;strong&gt;handler filters&lt;/strong&gt;.</source>
          <target state="translated">Бэкэнд Logger пересылает события журнала из API, сначала через набор &lt;strong&gt;основных фильтров&lt;/strong&gt; , а затем через набор вторичных фильтров, прикрепленных к каждому обработчику журнала. Вторичные фильтры находятся в следующих именованных &lt;strong&gt;фильтрах обработчика&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="30f7d257c062cf1d99aadf05acae5dcdc7db0748" translate="yes" xml:space="preserve">
          <source>The Logger proxy is an Erlang process which is part of the Kernel application's supervision tree. During startup, the proxy process registers itself as the &lt;code&gt;system_logger&lt;/code&gt;, meaning that log events produced by the emulator are sent to this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709c2b894a55cf0a9eb1d8fa9b54a57e464ba3b7" translate="yes" xml:space="preserve">
          <source>The M-bit on a component AVP of a Grouped AVP that does not set M is ignored: such AVPs are not regarded as erroneous at decode.</source>
          <target state="translated">M-бит на компоненте AVP сгруппированного AVP,который не устанавливает M,игнорируется:такие AVP не считаются ошибочными при декодировании.</target>
        </trans-unit>
        <trans-unit id="b932f03ca4571cac226370cd6a0c3fc9c9dd133c" translate="yes" xml:space="preserve">
          <source>The MBC area is called &lt;strong&gt;sa&lt;/strong&gt; as in super aligned and the SBC area is called &lt;strong&gt;sua&lt;/strong&gt; as in super un-aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e65c3cb49c60d682bd3249d0c0dd54ec5a5739f" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm is &lt;strong&gt;not&lt;/strong&gt; considered safe for code-signing or software-integrity purposes.</source>
          <target state="translated">Алгоритм дайджеста сообщений MD5 &lt;strong&gt;не&lt;/strong&gt; считается безопасным для подписи кода или целостности программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="f776c349863aa954c934ed6333465e82a978b325" translate="yes" xml:space="preserve">
          <source>The MFA alternative makes it possible for Megaco to start and supervise a scanner written by the user (see &lt;code&gt;supervisor:start_child&lt;/code&gt; for an explanation of the parameters).</source>
          <target state="translated">Альтернатива MFA позволяет Megaco запускать и контролировать сканер, написанный пользователем (см &lt;code&gt;supervisor:start_child&lt;/code&gt; для объяснения параметров).</target>
        </trans-unit>
        <trans-unit id="1def19a97ae2b0656b00af132fb7f372cb973f9f" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 and use a provisioned MID of the MGC as the RemoteMid.</source>
          <target state="translated">MG может явно вызывать megaco:connect/4 и использовать MID MGC как RemoteMid.</target>
        </trans-unit>
        <trans-unit id="d9b9106067cc9059d7c61d3ebb7b2686b953f307" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 with the atom 'preliminary_mid' as a temporary MID of the MGC, send an intial message, the Service Change Request, to the MGC and then wait for an initial message, the Service Change Reply. When the reply arrives, the Megaco application will pick the MID of the MGC from the message header and automatically upgrade the connection to be a &quot;normal&quot; connection. By using this method of establishing the connection, the callback function UserMod:handle_connect/2 to be invoked twice. First with a ConnHandle with the remote_mid-field set to preliminary_mid, and then when the connection upgrade is done with the remote_mid-field set to the actual MID of the MGC.</source>
          <target state="translated">MG может явно вызывать megaco:connect/4 с атомом 'preliminary_mid' в качестве временного MID MGC,посылать MGC сообщение,Запрос на изменение услуги,а затем ждать первоначального сообщения,Ответа на изменение услуги.Когда ответ придет,приложение Megaco выберет MID MGC из заголовка сообщения и автоматически обновит соединение,чтобы оно стало &quot;обычным&quot;.Используя этот метод установления соединения,дважды вызывается функция обратного вызова UserMod:handle_connect/2.Сначала с помощью ConnHandle с полем remote_mid,установленным в качестве предварительного_mid,а затем,когда обновление соединения будет выполнено с помощью поля remote_mid,установленного в качестве фактического MID MGC.</target>
        </trans-unit>
        <trans-unit id="aea17cec43c433cc7d5df78c11e5155adf50c978" translate="yes" xml:space="preserve">
          <source>The MIB compiler can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.mib&lt;/code&gt;, and invokes the SNMP MIB compiler for files with that extension. The options &lt;code&gt;db&lt;/code&gt;, &lt;code&gt;group_check&lt;/code&gt;, &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;verbosity&lt;/code&gt;, &lt;code&gt;imports&lt;/code&gt; and &lt;code&gt;module_identity&lt;/code&gt; have to be specified to &lt;code&gt;erlc&lt;/code&gt; using the syntax &lt;code&gt;+term&lt;/code&gt;. See &lt;code&gt;erlc(1)&lt;/code&gt; for details.</source>
          <target state="translated">Компилятор MIB можно вызвать из командной строки ОС с помощью команды &lt;code&gt;erlc&lt;/code&gt; . &lt;code&gt;erlc&lt;/code&gt; распознает расширение &lt;code&gt;.mib&lt;/code&gt; и вызывает компилятор SNMP MIB для файлов с этим расширением. Параметры &lt;code&gt;db&lt;/code&gt; , &lt;code&gt;group_check&lt;/code&gt; , &lt;code&gt;deprecated&lt;/code&gt; , &lt;code&gt;description&lt;/code&gt; , &lt;code&gt;verbosity&lt;/code&gt; , &lt;code&gt;imports&lt;/code&gt; и &lt;code&gt;module_identity&lt;/code&gt; должны быть определены для &lt;code&gt;erlc&lt;/code&gt; с использованием синтаксиса &lt;code&gt;+term&lt;/code&gt; . За подробностями &lt;code&gt;erlc(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4f52d6224012981f65b2f6681c14c8ab8b0bbf8" translate="yes" xml:space="preserve">
          <source>The MIB compiler is started with a call to &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; For example:</source>
          <target state="translated">Компилятор MIB запускается с вызова &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; Например:</target>
        </trans-unit>
        <trans-unit id="edd06159b7a6aba946136da4c7e4c2496fb5f976" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; statement to determine if the MIB is version 1 or 2.</source>
          <target state="translated">Компилятор MIB понимает MIB SMIv1 и SMIv2. Он использует оператор &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; , чтобы определить, является ли MIB версией 1 или 2.</target>
        </trans-unit>
        <trans-unit id="f45016e5e003d17ae323b899458860dc734f4ec3" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the MODULE-IDENTITY statement to determinate if the MIB is written in SMI version 1 or 2.</source>
          <target state="translated">Компилятор MIB понимает и SMIv1,и SMIv2 MIB.Он использует утверждение MODULE-IDENTITY (Идентификация модуля),чтобы определить,записан ли MIB в SMI версии 1 или 2.</target>
        </trans-unit>
        <trans-unit id="cd9d36a4d02e1cba5060187b622d24d58daaa77e" translate="yes" xml:space="preserve">
          <source>The MIB definition for the table looks as follows:</source>
          <target state="translated">Определение MIB для таблицы выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="3670a31f68beb5c49cf1fc0895f0360e583892d6" translate="yes" xml:space="preserve">
          <source>The MIB is specified in an adapted subset of the Abstract Syntax Notation One (ASN.1) language. This adapted subset is called the Structure of Management Information (SMI).</source>
          <target state="translated">МИБ указана в адаптированном подмножестве языка абстрактной синтаксической нотации № 1 (ASN.1).Это адаптированное подмножество называется Структура управленческой информации (SMI).</target>
        </trans-unit>
        <trans-unit id="ddf38993bb21f6943082354919313abcba92be9e" translate="yes" xml:space="preserve">
          <source>The MIB must be written as a text file in SMIv1 or SMIv2 using an ASN.1 notation before it will be compiled. This text file must have the same name as the MIB, but with the suffix &lt;code&gt;.mib&lt;/code&gt;. This is necessary for handling the &lt;code&gt;IMPORT&lt;/code&gt; statement.</source>
          <target state="translated">MIB должен быть записан как текстовый файл в SMIv1 или SMIv2 с использованием нотации ASN.1, прежде чем он будет скомпилирован. Этот текстовый файл должен иметь то же имя, что и MIB, но с &lt;code&gt;.mib&lt;/code&gt; . Это необходимо для обработки оператора &lt;code&gt;IMPORT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28b5820bae2b823215328a884121f24cdebd6ac9" translate="yes" xml:space="preserve">
          <source>The MIB table shown in the previous section can be compiled as follows:</source>
          <target state="translated">Таблицу MIB,показанную в предыдущем разделе,можно составить следующим образом:</target>
        </trans-unit>
        <trans-unit id="8ec9b6855efdcd50624fb2152240f9d6cfd37b82" translate="yes" xml:space="preserve">
          <source>The MIB used in this example is called EX1-MIB. It contains two objects, a variable with a name and a table with friends.</source>
          <target state="translated">MIB,используемый в этом примере,называется EX1-MIB.Он содержит два объекта,переменную с именем и таблицу с друзьями.</target>
        </trans-unit>
        <trans-unit id="e2036f385fe7aec6b74107075c06d9fb946e725a" translate="yes" xml:space="preserve">
          <source>The Makefile rule generated by this option looks as follows:</source>
          <target state="translated">Правило Makefile,генерируемое этой опцией,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b70e5f8f89b4686cb29a4a908b91ac8e282aa8a9" translate="yes" xml:space="preserve">
          <source>The Manager sends a request to the Agent.</source>
          <target state="translated">Менеджер посылает запрос агенту.</target>
        </trans-unit>
        <trans-unit id="46da3a78459a2791fe81dd4c8585eaa2e4cc0ded" translate="yes" xml:space="preserve">
          <source>The Master Agent decodes the incoming UDP packet.</source>
          <target state="translated">Мастер-агент декодирует входящий UDP-пакет.</target>
        </trans-unit>
        <trans-unit id="373ff796c178ffe0a9fc192a5614c9c2aa28127a" translate="yes" xml:space="preserve">
          <source>The Master Agent determines which items in the request that should be processed here and which items should be forwarded to its subagent.</source>
          <target state="translated">Главный Агент определяет,какие элементы в запросе должны быть обработаны здесь,а какие отправлены его субагенту.</target>
        </trans-unit>
        <trans-unit id="efae611f18882de954fb6f64727d8f6c45904beb" translate="yes" xml:space="preserve">
          <source>The Megaco client (user) starts the flex scanner (load the driver).</source>
          <target state="translated">Клиент (пользователь)Megaco запускает гибкий сканер (загружает драйвер).</target>
        </trans-unit>
        <trans-unit id="74b78735e0be983743300743d7f123f781d14b1d" translate="yes" xml:space="preserve">
          <source>The Megaco mib is as of yet not standardized and our implementation is based on &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt;. Almost all of the mib cannot easily be implemented by the megaco application. Instead these things should be implemented by a user (of the megaco application).</source>
          <target state="translated">Mib для Megaco еще не стандартизирован, и наша реализация основана на &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt; . Почти все mib не могут быть легко реализованы приложением megaco. Вместо этого эти вещи должны быть реализованы пользователем (приложения мегако).</target>
        </trans-unit>
        <trans-unit id="69ce7f3a78e528729b8eeea0590643ad39f48cc1" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 application contains implementations for the two protocols specified by the Megaco/H.248 standard; UDP, see &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;, and TCP/TPKT, see &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Приложение Megaco / H.248 содержит реализации для двух протоколов, определенных стандартом Megaco / H.248; UDP, см. &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; и TCP / TPKT, см. &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aad987e822802dc01bf9dc22e5bb8ea6068aa667" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do in fact supply five different encoding/decoding modules.</source>
          <target state="translated">Стандарт Megaco/H.248 определяет как обычную текстовую,так и двоичную кодировку (ASN.1 BER),и мы реализовали кодировщики и декодеры для обоих.Фактически мы поставляем пять различных модулей кодирования/декодирования.</target>
        </trans-unit>
        <trans-unit id="aa06303bf449e60941f0fbd6f5db8a0257dfe140" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do supply a bunch of different encoding/decoding modules and the user may in fact implement their own (like our erl_dist module). Using a non-standard encoding format has its obvious drawbacks, but may be useful in some configurations.</source>
          <target state="translated">Стандарт Megaco/H.248 определяет как обычную текстовую,так и двоичную кодировку (ASN.1 BER),и мы реализовали кодировщики и декодеры для обоих.Мы поставляем кучу различных модулей кодирования/декодирования,и пользователь может фактически реализовать свои собственные (как наш модуль erl_dist).Использование нестандартного формата кодирования имеет свои очевидные недостатки,но может быть полезно в некоторых конфигурациях.</target>
        </trans-unit>
        <trans-unit id="4e6da9c94911e5ddf6ca86f3b535349fffeec5ca" translate="yes" xml:space="preserve">
          <source>The Metadata field exists to allow languages, tools and libraries to add custom information to each entry. This EEP documents the following metadata keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1180df526f481dbe5f0436fa1406c56c4711af67" translate="yes" xml:space="preserve">
          <source>The Mnesia DBMS can be used for storing data of SNMP tables. This means that an SNMP table can be implemented as a Mnesia table, and that a Mnesia table can be made visible via SNMP. This mapping is largely automated.</source>
          <target state="translated">СУБД Mnesia может использоваться для хранения данных SNMP-таблиц.Это означает,что SNMP-таблицу можно реализовать в качестве таблицы Мнезии,а также сделать таблицу Мнезии видимой через SNMP.Такое отображение в значительной степени автоматизировано.</target>
        </trans-unit>
        <trans-unit id="a591b496e3da82473b635cc4b898494993b158a0" translate="yes" xml:space="preserve">
          <source>The Mnesia algorithm for table load can lead to a situation where a table cannot be loaded. This situation occurs when a node is started and Mnesia concludes, or suspects, that another copy of the table was active after this local copy became inactive because of a system crash.</source>
          <target state="translated">Алгоритм Мнезии для загрузки таблицы может привести к ситуации,когда таблица не может быть загружена.Эта ситуация возникает,когда узел запускается и Mnesia заключает,или подозревает,что другая копия таблицы была активна после того,как эта локальная копия стала неактивной из-за сбоя системы.</target>
        </trans-unit>
        <trans-unit id="5e84c0c6719410c924b39a7531b144a0635ce33f" translate="yes" xml:space="preserve">
          <source>The Mnesia application provides a heavy duty real-time distributed database.</source>
          <target state="translated">Приложение Mnesia обеспечивает мощную распределенную базу данных в режиме реального времени.</target>
        </trans-unit>
        <trans-unit id="4e31cb2dccdf565dc1ca8c735031043aeea8bc8e" translate="yes" xml:space="preserve">
          <source>The Mnesia directory is to be set to &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Каталог Mnesia должен быть установлен в положение &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87981337ff090edb8a09d20ade88cd56c81fc2fc" translate="yes" xml:space="preserve">
          <source>The Mnesia tables can be manipulated without using transactions. This has some serious disadvantages, but is considerably faster, as the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency, and the dirty operations cannot return garbled records. All dirty operations provide location transparency to the programmer, and a program does not have to be aware of the whereabouts of a certain table to function.</source>
          <target state="translated">Таблицами Мнезии можно манипулировать без использования транзакций.Это имеет некоторые серьезные недостатки,но значительно быстрее,так как не задействован менеджер транзакций и не установлены блокировки.Грязные операции,однако,гарантируют определенный уровень согласованности,а грязные операции не могут вернуть искаженные записи.Все грязные операции обеспечивают прозрачность местоположения для программиста,и программе не обязательно знать,где находится определенная таблица,чтобы функционировать.</target>
        </trans-unit>
        <trans-unit id="12555ca4fb4e5c73fcfb7a6b579630e086477989" translate="yes" xml:space="preserve">
          <source>The Module, Function and/or Arity parts of the tuple may be specified as the atom &lt;code&gt;'_'&lt;/code&gt; which is a &quot;wild-card&quot; matching all modules/functions/arities. Note, if the Module is specified as &lt;code&gt;'_'&lt;/code&gt;, the Function and Arity parts have to be specified as '_' too. The same holds for the Functions relation to the Arity.</source>
          <target state="translated">Части модуля, функции и / или арности кортежа могут быть указаны как атом &lt;code&gt;'_'&lt;/code&gt; , который является &amp;laquo; шаблоном &amp;raquo;, соответствующим всем модулям / функциям / арностям. Обратите внимание: если Module указан как &lt;code&gt;'_'&lt;/code&gt; , части Function и Arity также должны быть указаны как &amp;laquo;_&amp;raquo;. То же самое верно и для отношения функций к Arity.</target>
        </trans-unit>
        <trans-unit id="f0af3d5917bbe134a6abcdbbf9104dc4ecd4c736" translate="yes" xml:space="preserve">
          <source>The Monitor window is the main window of Debugger and displays the following:</source>
          <target state="translated">Окно Монитор является главным окном отладчика и отображает следующее:</target>
        </trans-unit>
        <trans-unit id="70b4cea5e362ae717c1192bf6736623910297884" translate="yes" xml:space="preserve">
          <source>The NETCONF client is also compliant with RFC 5277 NETCONF Event Notifications, which defines a mechanism for an asynchronous message notification delivery service for the NETCONF protocol.</source>
          <target state="translated">Клиент NETCONF также соответствует стандарту RFC 5277 NETCONF Event Notifications,который определяет механизм асинхронной доставки сообщений для протокола NETCONF.</target>
        </trans-unit>
        <trans-unit id="99b3461576af86b2830e124486fcb6fbe5704dd5" translate="yes" xml:space="preserve">
          <source>The NETCONF client is compliant with RFC 4741 NETCONF Configuration Protocol and RFC 4742 Using the NETCONF Configuration Protocol over Secure SHell (SSH).</source>
          <target state="translated">Клиент NETCONF соответствует стандарту RFC 4741 NETCONF Configuration Protocol и RFC 4742 Using the NETCONF Configuration Protocol over Secure SHell (SSH).</target>
        </trans-unit>
        <trans-unit id="ddf8604513f6b03eececb0b12edf6062d8892eb4" translate="yes" xml:space="preserve">
          <source>The NETCONF server uses &lt;code&gt;error_logger&lt;/code&gt; for logging of NETCONF traffic. A special purpose error handler is implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;. To use this error handler, add the &lt;code&gt;cth_conn_log&lt;/code&gt; hook in the test suite, for example:</source>
          <target state="translated">Сервер NETCONF использует &lt;code&gt;error_logger&lt;/code&gt; для регистрации трафика NETCONF. В &lt;code&gt;ct_conn_log_h&lt;/code&gt; реализован специальный обработчик ошибок . Чтобы использовать этот обработчик ошибок, добавьте в &lt;code&gt;cth_conn_log&lt;/code&gt; ловушку cth_conn_log , например:</target>
        </trans-unit>
        <trans-unit id="c4e761f6142db929d9abebfe00caf12e6df69e08" translate="yes" xml:space="preserve">
          <source>The NEXT_INSTRUCTION is a pre-bound variable that is available in all instructions. It expands to the address of the next instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee36acc539fb496464c93f96bb31d20de406968" translate="yes" xml:space="preserve">
          <source>The NEXT_INSTRUCTION pre-bound variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d107278e1a70d51b4fdd7f40141f0fe34ee6756" translate="yes" xml:space="preserve">
          <source>The NIF library must be explicitly loaded by Erlang code in the same module.</source>
          <target state="translated">Библиотека NIF должна быть явно загружена кодом Erlang в том же модуле.</target>
        </trans-unit>
        <trans-unit id="41a4ad2b0dc5ffd6f13eaa47aa861d15ed3c8d0c" translate="yes" xml:space="preserve">
          <source>The NIFs of the module are compiled and linked into a shared library. Each NIF is implemented as a normal C function. The macro &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; together with an array of structures defines the names, arity, and function pointers of all the NIFs in the module. The header file &lt;code&gt;erl_nif.h&lt;/code&gt; must be included. As the library is a shared module, not a program, no main function is to be present.</source>
          <target state="translated">NIF модуля скомпилированы и связаны в общую библиотеку. Каждый NIF реализован как обычная функция C. Макрос &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; вместе с массивом структур определяет имена, арность и указатели функций всех NIF в модуле. Заголовочный файл &lt;code&gt;erl_nif.h&lt;/code&gt; должен быть включен. Поскольку библиотека является разделяемым модулем, а не программой, не должно присутствовать никаких основных функций.</target>
        </trans-unit>
        <trans-unit id="999daf79065332e5e6572460b7e99eb5b72cdc5f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net If) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f70502604dd2333d650c0bc04a8729a4f497af" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net If) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd402b6f90d216badbbd85762e2a8ddff6c71c0f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="translated">Процесс Network Interface (Net if)доставляет SNMP PDU к ведущему агенту и получает SNMP PDU от ведущего агента.Наиболее распространенное поведение сети,если процесс получает байты из сети,декодирует их в SNMP PDU,который он отправляет мастер-агенту.Когда ведущий агент обработал PDU,он отправляет PDU ответа в сеть,если процесс кодирует PDU в байты и передает эти байты в сеть.</target>
        </trans-unit>
        <trans-unit id="976e6c5625eb166a7240dd083a2239c03ac8b8ec" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="translated">Процесс Network Interface (Net if)доставляет SNMP PDU на сервер менеджера и получает SNMP PDU от сервера менеджера.Наиболее распространенное поведение Net,если процесс получает PDU запроса от сервера управления,кодирует PDU в байты и передает байты в сеть агенту.Когда ответ от агента получает Сеть,если процесс,который она декодирует в SNMP PDU,отправляется на сервер менеджера.</target>
        </trans-unit>
        <trans-unit id="e3ad1933c4b353741e7d3dd411a4625d945e51b1" translate="yes" xml:space="preserve">
          <source>The OAM components, and some other OTP applications, define SNMP MIBs. These MIBs are written in SNMPv2 SMI syntax, as defined in RFC 1902. For convenience we also deliver the SNMPv1 SMI equivalent. All MIBs are designed to be v1/v2 compatible, that is, the v2 MIBs do not use any construct not available in v1.</source>
          <target state="translated">Компоненты OAM и некоторые другие приложения OTP определяют SNMP MIB.Эти MIBs написаны в синтаксисе SNMPv2 SMI,как определено в RFC 1902.Для удобства мы также поставляем эквивалент SNMPv1 SMI.Все MIBs разработаны для совместимости с v1/v2,т.е.v2 MIB не используют конструкций,недоступных в v1.</target>
        </trans-unit>
        <trans-unit id="6a0dd4d53e9a9b356b53c2117149daa068221b0f" translate="yes" xml:space="preserve">
          <source>The OPERAND_POSITION() macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa71a1f0f4b6ee0f7da7bee6b28148c4530dbc7" translate="yes" xml:space="preserve">
          <source>The OS failed to load the NIF library.</source>
          <target state="translated">Операционная система не смогла загрузить библиотеку NIF.</target>
        </trans-unit>
        <trans-unit id="0c8abadcc360635740ed383e0bd4f397be705277" translate="yes" xml:space="preserve">
          <source>The OTP SSH app can be configurated by a large amount of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c43c2d0328ac7bd67f0bc31e296a2b1639ba6e7" translate="yes" xml:space="preserve">
          <source>The OTP mibs are stored in the &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; directory. They are defined in SNMPv2 SMI syntax. An SNMPv1 version of the mib is delivered in the &lt;code&gt;mibs/v1&lt;/code&gt; directory. The compiled MIB is located under &lt;code&gt;priv/mibs&lt;/code&gt;, and the generated &lt;code&gt;.hrl&lt;/code&gt; file under the &lt;code&gt;include&lt;/code&gt; directory. To compile a MIB that IMPORTS a MIB in the OTP_Mibs application, give the option &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; to the MIB compiler.</source>
          <target state="translated">Mib-файлы OTP хранятся в &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; . Они определены в синтаксисе SNMPv2 SMI. Версия mib для SNMPv1 находится в &lt;code&gt;mibs/v1&lt;/code&gt; . Скомпилированный MIB находится в &lt;code&gt;priv/mibs&lt;/code&gt; , а сгенерированный файл &lt;code&gt;.hrl&lt;/code&gt; - в каталоге &lt;code&gt;include&lt;/code&gt; . Чтобы скомпилировать MIB, который ИМПОРТИРУЕТ MIB в приложении OTP_Mibs, дайте компилятору MIB параметр &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef0289a2a348b65c119233c8ade03f223f5c8802" translate="yes" xml:space="preserve">
          <source>The OTP release that the currently executing ERTS application is part of, as an integer. For details, see &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;. This macro was introduced in OTP release 21.</source>
          <target state="translated">Версия OTP, частью которой является выполняющееся в данный момент приложение ERTS, в виде целого числа. Подробнее см. &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; . Этот макрос был представлен в выпуске 21 OTP.</target>
        </trans-unit>
        <trans-unit id="16e1639b18798e91125ecf1f057060589779b23c" translate="yes" xml:space="preserve">
          <source>The OTP-MIB mib represents information about Erlang nodes such as node name, number of running processes, virtual machine version etc. If the MIB should be used in a system, it should be loaded into an SNMP agent by using the API function &lt;code&gt;otp_mib:load/1&lt;/code&gt;.</source>
          <target state="translated">MIB OTP-MIB представляет информацию об узлах Erlang, такую ​​как имя узла, количество запущенных процессов, версия виртуальной машины и т. Д. Если MIB следует использовать в системе, ее следует загрузить в агент SNMP с помощью функции API &lt;code&gt;otp_mib:load/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d079c6127c093fd0bf885dc8ec3e524eee2389b" translate="yes" xml:space="preserve">
          <source>The OTP-REG mib defines the unique OTP subtree of object identifiers under the Ericsson subtree. Under the OTP subtree several object identifiers are defined. This module is typically included by OTP applications defining their own mibs, or ASN.1 modules in general, that require unique object identifiers under the OTP subtree.</source>
          <target state="translated">OTP-REG mib определяет уникальное OTP-поддерево идентификаторов объектов поддерево Ericsson.В поддереве OTP определено несколько идентификаторов объектов.Этот модуль,как правило,входит в состав приложений OTP,определяющих свои собственные mib или ASN.1,которые требуют уникальных идентификаторов объектов в поддереве OTP.</target>
        </trans-unit>
        <trans-unit id="7e4e2e6abc0df4b67e259520ad92410685d1db8d" translate="yes" xml:space="preserve">
          <source>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before standard MIBs existed for access control, MIB views, and trap target specification. All objects in this MIB are now obsolete.</source>
          <target state="translated">OTP-SNMPEA-MIB использовался в более ранних версиях агента,прежде чем существовали стандартные MIB для контроля доступа,просмотра MIB и спецификации цели ловушки.Все объекты в этой MIB теперь устарели.</target>
        </trans-unit>
        <trans-unit id="dfdf456ec73d4195574c470386dbc5ef95b5e4be" translate="yes" xml:space="preserve">
          <source>The OTP-TC mib provides the textual convention datatype &lt;code&gt;OwnerString&lt;/code&gt;.</source>
          <target state="translated">Mib OTP-TC предоставляет текстовое соглашение типа данных &lt;code&gt;OwnerString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdfd28142322083a6af658ff0e91ac0a22fe94e4" translate="yes" xml:space="preserve">
          <source>The OTP/SSH application first calls this function in the callback module, and then the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; for compatibilty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c83f8d2349d1be9c18b485bc1cd6600dd20f64" translate="yes" xml:space="preserve">
          <source>The OTP/SSH application first calls this function in the callback module, and then the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; for compatibilty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370c0fa4230350b45a2bed8b159298418299327c" translate="yes" xml:space="preserve">
          <source>The Observer application is a container including the following tools for tracing and investigation of distributed systems:</source>
          <target state="translated">Приложение &quot;Наблюдатель&quot; представляет собой контейнер,включающий в себя следующие инструменты для отслеживания и исследования распределенных систем:</target>
        </trans-unit>
        <trans-unit id="e53532ab978b0a1e5f72db0836d60dcb2627de7d" translate="yes" xml:space="preserve">
          <source>The Observer application is available on the trace control node.</source>
          <target state="translated">Приложение Observer доступно на узле управления трассировкой.</target>
        </trans-unit>
        <trans-unit id="acca74abfba6c1293f4de6924079a0d77446f3db" translate="yes" xml:space="preserve">
          <source>The Observer application might not always be available on the node to be traced (in the following called the &quot;traced node&quot;). However, Trace Tool Builder can still be run from another node (in the following called the &quot;trace control node&quot;) as long as the following is fulfilled:</source>
          <target state="translated">Приложение Observer не всегда может быть доступно на отслеживаемом узле (в дальнейшем называется &quot;отслеживаемый узел&quot;).Однако,Trace Tool Builder может быть запущен из другого узла (в дальнейшем называемого &quot;узел управления трассировкой&quot;)до тех пор,пока выполняется следующее:</target>
        </trans-unit>
        <trans-unit id="40509725b1b94ac04bace7fdcf93e38e06d1990b" translate="yes" xml:space="preserve">
          <source>The Operation and Maintenance (OAM) support in OTP consists of a generic model for management subsystems in OTP, and some components to be used in these subsystems. This section describes the model.</source>
          <target state="translated">Поддержка эксплуатации и обслуживания (OAM)в ОБ состоит из общей модели подсистем управления в ОБ,а также некоторых компонентов,которые будут использоваться в этих подсистемах.В данном разделе описывается модель.</target>
        </trans-unit>
        <trans-unit id="808ca5db0eed6b5828cf7aea959f1c6d4f421b35" translate="yes" xml:space="preserve">
          <source>The P flag has been deprecated by RFC 6733.</source>
          <target state="translated">Флаг Р был уничтожен RFC 6733.</target>
        </trans-unit>
        <trans-unit id="521a731b4b96b784ec12d6942621ae176f880a6a" translate="yes" xml:space="preserve">
          <source>The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If &lt;code&gt;{error, match_limit}&lt;/code&gt; is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a &lt;code&gt;nomatch&lt;/code&gt;, which is the default return value when this occurs, but by specifying &lt;code&gt;report_errors&lt;/code&gt;, you are informed when the match fails because of too many internal calls.</source>
          <target state="translated">Библиотека PCRE устанавливает ограничение на количество вызовов функции внутреннего сопоставления. По умолчанию в библиотеке, скомпилированной для Erlang, установлено значение 10 000 000. Если возвращается &lt;code&gt;{error, match_limit}&lt;/code&gt; , выполнение регулярного выражения достигло этого предела. Обычно это рассматривается как &lt;code&gt;nomatch&lt;/code&gt; , которое является возвращаемым значением по умолчанию, когда это происходит, но, указав &lt;code&gt;report_errors&lt;/code&gt; , вы будете проинформированы, когда сопоставление не удается из-за слишком большого количества внутренних вызовов.</target>
        </trans-unit>
        <trans-unit id="315aa4b073a3e51b4182d67ae5a99c3e8dd60122" translate="yes" xml:space="preserve">
          <source>The PCRE-specific options &lt;code&gt;dupnames&lt;/code&gt;, &lt;code&gt;ungreedy&lt;/code&gt;, and &lt;code&gt;extra&lt;/code&gt; can be changed in the same way as the Perl-compatible options by using the characters J, U, and X respectively.</source>
          <target state="translated">Специфичные для PCRE параметры &lt;code&gt;dupnames&lt;/code&gt; , &lt;code&gt;ungreedy&lt;/code&gt; и &lt;code&gt;extra&lt;/code&gt; можно изменить так же, как и параметры, совместимые с Perl, с помощью символов J, U и X соответственно.</target>
        </trans-unit>
        <trans-unit id="3b60700ebcda31fdb446fa71f372ef2af6d7bcce" translate="yes" xml:space="preserve">
          <source>The PLT is built using option &lt;code&gt;--build_plt&lt;/code&gt; to Dialyzer. The following command builds the recommended minimal PLT for Erlang/OTP:</source>
          <target state="translated">PLT &lt;code&gt;--build_plt&lt;/code&gt; с использованием опции --build_plt для Dialyzer. Следующая команда создает рекомендуемый минимальный PLT для Erlang / OTP:</target>
        </trans-unit>
        <trans-unit id="068bb5f6b3073467febaec97d8dca8e259a70b70" translate="yes" xml:space="preserve">
          <source>The PLT is extended to also include the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. Use &lt;code&gt;--plt&lt;/code&gt; to specify which PLT to start from, and &lt;code&gt;--output_plt&lt;/code&gt; to specify where to put the PLT. Notice that the analysis possibly can include files from the PLT if they depend on the new files. This option only works for BEAM files.</source>
          <target state="translated">PLT расширен и теперь включает файлы, указанные с помощью &lt;code&gt;-c&lt;/code&gt; и &lt;code&gt;-r&lt;/code&gt; . Используйте &lt;code&gt;--plt&lt;/code&gt; , чтобы указать, с какого PLT начинать, и &lt;code&gt;--output_plt&lt;/code&gt; , чтобы указать, где разместить PLT. Обратите внимание, что анализ может включать файлы из PLT, если они зависят от новых файлов. Эта опция работает только для файлов BEAM.</target>
        </trans-unit>
        <trans-unit id="060b8280a8288371c7c464debf7423fb50d4cb7c" translate="yes" xml:space="preserve">
          <source>The POSIX error codes are mostly come from the OS level socket interface, but this module may generate some appropriate POSIX codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ac14853a9b086e8f452912a23bfe90221af508" translate="yes" xml:space="preserve">
          <source>The Perl documentation states that it is probably useful only when combined with (?{}) or (??{}). Those are Perl features that are not present in PCRE.</source>
          <target state="translated">В документации Perl говорится,что она,вероятно,полезна только в сочетании с (?{})или (?{}).Это возможности Perl,которых нет в PCRE.</target>
        </trans-unit>
        <trans-unit id="7305fc245a21d67edcfb1e7040ab9604b3ab8839" translate="yes" xml:space="preserve">
          <source>The Port number of the Host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7076aca020633109c1bf0af701628b144f387d" translate="yes" xml:space="preserve">
          <source>The Port number of the host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f38ed5f44cf6a58fcb55ac9b9ba9cb03970efa" translate="yes" xml:space="preserve">
          <source>The ProtocolVersion version is the version actually encoded in the reply message.</source>
          <target state="translated">Версия ProtocolVersion-это версия,фактически закодированная в ответном сообщении.</target>
        </trans-unit>
        <trans-unit id="544a356532db2cd2759e24c6723c4194d33f11f5" translate="yes" xml:space="preserve">
          <source>The Public Key application deals with public-key related file formats, digital signatures, and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt;. It is a library application that provides encode/decode, sign/verify, encrypt/decrypt, and similar functionality. It does not read or write files, it expects or returns file contents or partial file contents as binaries.</source>
          <target state="translated">Приложение &amp;laquo;Открытый ключ&amp;raquo; работает с форматами файлов, связанных с открытым ключом, цифровыми подписями и &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt; . Это библиотечное приложение, которое обеспечивает кодирование / декодирование, подпись / проверку, шифрование / дешифрование и аналогичные функции. Он не читает и не записывает файлы, он ожидает или возвращает содержимое файла или частичное содержимое файла в виде двоичных файлов.</target>
        </trans-unit>
        <trans-unit id="092e77be169b39b5b16fe830e8adc69715511cbd" translate="yes" xml:space="preserve">
          <source>The Public Key application deals with public-key related file formats, digital signatures, and &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt;. It is a library application that provides encode/decode, sign/verify, encrypt/decrypt, and similar functionality. It does not read or write files, it expects or returns file contents or partial file contents as binaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ebdf434e84c8ed49f35713ff4853c27de0d8e82" translate="yes" xml:space="preserve">
          <source>The Public Key decode- and encode-functions try to use the NIFs in the ASN.1 compilers runtime modules, if they can be found. Thus, to have the ASN1 application in the path of your system gives the best performance.</source>
          <target state="translated">Функции декодирования и кодирования открытого ключа пытаются использовать NIF в исполнительных модулях компиляторов ASN.1,если их можно найти.Таким образом,наличие приложения ASN1 на пути к вашей системе дает наилучшую производительность.</target>
        </trans-unit>
        <trans-unit id="efe14f45b872852caa29e8e8cc7c7d6e2482faaf" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog state machine has transitioned into (&lt;code&gt;up&lt;/code&gt;) or out of (&lt;code&gt;down&lt;/code&gt;) the OKAY state. If a &lt;code&gt;#diameter_packet{}&lt;/code&gt; is present in an &lt;code&gt;up&lt;/code&gt; event then there has been a capabilities exchange on a newly established transport connection and the record contains the received CER or CEA.</source>
          <target state="translated">Конечный автомат сторожевого таймера RFC 3539 перешел в ( &lt;code&gt;up&lt;/code&gt; ) или из ( &lt;code&gt;down&lt;/code&gt; ) состояние OKAY. Если &lt;code&gt;#diameter_packet{}&lt;/code&gt; присутствует в &lt;code&gt;up&lt;/code&gt; события , то есть был возможности обмена на вновь созданной транспортной связи и запись содержит принятый CER или СЕА.</target>
        </trans-unit>
        <trans-unit id="dc64b0c1b30970fb85a8fe63a3336e6b7a09937b" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a jitter of &amp;plusmn; 2 seconds being added at each rearming of the timer to compute the RFC's Tw. An MFA is expected to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation to be performed by the callback.</source>
          <target state="translated">Сторожевой таймер RFC 3539. Целочисленное значение интерпретируется как TwInit RFC в миллисекундах, при каждом повторном включении таймера добавляется дрожание &amp;plusmn; 2 секунды для вычисления Tw RFC. Ожидается, что MFA вернет Tw RFC напрямую с примененным джиттером, позволяя вычислять джиттер с помощью обратного вызова.</target>
        </trans-unit>
        <trans-unit id="fcc9e80a4124e3a42a057c7e5dbba54abf671c72" translate="yes" xml:space="preserve">
          <source>The RFC states that if a certificate defines Reference IDs in a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field MUST NOT be used for host name checking, even if it contains valid CN names. Therefore only &lt;code&gt;kb.example.org&lt;/code&gt; and &lt;code&gt;https://www.example.org&lt;/code&gt; matches. The match fails both for &lt;code&gt;example.com&lt;/code&gt; and &lt;code&gt;foo.example.com&lt;/code&gt; becuase they are in the &lt;code&gt;Subject&lt;/code&gt; field which is not checked because the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field is present.</source>
          <target state="translated">RFC гласит, что если сертификат определяет идентификаторы ссылок в поле &lt;code&gt;Subject Alternate Name&lt;/code&gt; &lt;code&gt;Subject&lt;/code&gt; поле субъекта НЕ ДОЛЖНО использоваться для проверки имени хоста, даже если оно содержит допустимые имена CN. Следовательно, &lt;code&gt;kb.example.org&lt;/code&gt; только kb.example.org и &lt;code&gt;https://www.example.org&lt;/code&gt; . &lt;code&gt;foo.example.com&lt;/code&gt; не удается как для &lt;code&gt;example.com&lt;/code&gt; ,так и для foo.example.com, поскольку они находятся в поле &amp;laquo; &lt;code&gt;Subject&lt;/code&gt; которое не проверяется, поскольку присутствует поле &amp;laquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e204403937648bc97742bc221c74abef96cbe2ca" translate="yes" xml:space="preserve">
          <source>The RSA options are experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8707a6b8a6bbf5e67f47a831acd5b638d6ca82c3" translate="yes" xml:space="preserve">
          <source>The Report Browser (RB) tool is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; in STDLIB.</source>
          <target state="translated">Инструмент Report Browser (RB) используется для просмотра и форматирования отчетов об ошибках, написанных обработчиком журнала ошибок &lt;code&gt;log_mf_h&lt;/code&gt; в STDLIB.</target>
        </trans-unit>
        <trans-unit id="e200f59605a43a83406a6a1c3aae57938231fe10" translate="yes" xml:space="preserve">
          <source>The Report Browser Tool</source>
          <target state="translated">Инструмент &quot;Браузер отчетов</target>
        </trans-unit>
        <trans-unit id="4692a2cbc9da1318b1c32468112fcf231936c7b1" translate="yes" xml:space="preserve">
          <source>The Runtime_Tools application is available on both the trace control node and the traced node.</source>
          <target state="translated">Приложение Runtime_Tools доступно как на узле управления трассировкой,так и на трассируемом узле.</target>
        </trans-unit>
        <trans-unit id="3e6f6adc881738e4e882b8995898a6ee34ae6866" translate="yes" xml:space="preserve">
          <source>The SASL application introduces three types of reports:</source>
          <target state="translated">Приложение SASL вводит три типа отчетов:</target>
        </trans-unit>
        <trans-unit id="a66565cf9194d0ac12d200f8341003bfd8ef9840" translate="yes" xml:space="preserve">
          <source>The SASL application provides support for:</source>
          <target state="translated">Приложение SASL обеспечивает поддержку:</target>
        </trans-unit>
        <trans-unit id="d6eac0a2617b8363f4e9ff21a3e5cf89ae6de35c" translate="yes" xml:space="preserve">
          <source>The SASL error logging concept described in this section is deprecated since Erlang/OTP 21.0, when the new &lt;code&gt;logging API&lt;/code&gt; was introduced.</source>
          <target state="translated">Концепция регистрации ошибок SASL, описанная в этом разделе, устарела с Erlang / OTP 21.0, когда был представлен новый &lt;code&gt;logging API&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06f440d4cdd560b9a71ad7c9c8906b6fd30020a0" translate="yes" xml:space="preserve">
          <source>The SAX events that are sent to the user via the callback.</source>
          <target state="translated">События SAX,которые отправляются пользователю через обратный вызов.</target>
        </trans-unit>
        <trans-unit id="6c62591fcbde98f13b883726ae2b16d26e6fd6e4" translate="yes" xml:space="preserve">
          <source>The SMP emulator (introduced in R11B) takes advantage of a multi-core or multi-CPU computer by running several Erlang scheduler threads (typically, the same as the number of cores). Each scheduler thread schedules Erlang processes in the same way as the Erlang scheduler in the non-SMP emulator.</source>
          <target state="translated">Эмулятор SMP (представленный в R11B)использует преимущества многоядерного или многопроцессорного компьютера,запуская несколько потоков планировщика Erlang (как правило,такое же количество ядер).Каждый поток планировщика расписания Erlang обрабатывает процессы так же,как и планировщик Erlang в эмуляторе без SMP.</target>
        </trans-unit>
        <trans-unit id="886a9eb3b2cede92a51b83a792de6e157b89118c" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional Sub-agents.</source>
          <target state="translated">Система SNMP-агентов состоит из одного Ведущего агента и дополнительных Субагентов.</target>
        </trans-unit>
        <trans-unit id="7abe087b7edee22ce1a0361250a19799bdfe6153" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional sub-agents. The Master Agent can be seen as a special kind of sub-agent. It implements the core agent functionality, UDP packet processing, type checking, access control, trap distribution, and so on. From a user perspective, it is used as an ordinary sub-agent.</source>
          <target state="translated">Система SNMP-агентов состоит из одного Ведущего агента и дополнительных субагентов.Главный Агент может рассматриваться как особый вид субагента.Он реализует функционал основного агента,обработку UDP-пакетов,проверку типов,контроль доступа,распространение ловушек и т.д..С точки зрения пользователя,он используется как обычный субагент.</target>
        </trans-unit>
        <trans-unit id="3265cc19f00c49d8349eff44b143ef435848cde4" translate="yes" xml:space="preserve">
          <source>The SNMP agent toolkit gets input from three different sources:</source>
          <target state="translated">Инструментарий SNMP-агента получает входные данные из трех различных источников:</target>
        </trans-unit>
        <trans-unit id="516cef785b21f525314dd4769fb5d4a3d8e52b36" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the agent is one. This function starts the agent entity of the application.</source>
          <target state="translated">Приложение SNMP состоит из нескольких объектов,одним из которых является агент.Данная функция запускает сущность агента приложения.</target>
        </trans-unit>
        <trans-unit id="5a5e7e85ae81bf01406a4eba00ac814b17f5f063" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the manager is one. This function starts the manager entity of the application.</source>
          <target state="translated">SNMP-приложение состоит из нескольких объектов,одним из которых является менеджер.Данная функция запускает сущность менеджера приложения.</target>
        </trans-unit>
        <trans-unit id="1c525a15cd833eca106834a5297df8dd9f3d8e99" translate="yes" xml:space="preserve">
          <source>The SNMP application should be used to start an SNMP agent. Then the API functions below can be used to load/unload the OTP-MIB into/from the agent. The instrumentation of the OTP-MIB uses Mnesia, hence Mnesia must be started prior to loading the OTP-MIB.</source>
          <target state="translated">Для запуска агента SNMP следует использовать приложение SNMP.Затем приведенные ниже функции API могут быть использованы для загрузки/выгрузки OTP-MIB в/из агента.Приборы OTP-MIB используют Mnesia,следовательно,Mnesia должна быть запущена до загрузки OTP-MIB.</target>
        </trans-unit>
        <trans-unit id="efcaf71f311ac8ed0a4c853a395724aa7b68ecca" translate="yes" xml:space="preserve">
          <source>The SNMP built-in database</source>
          <target state="translated">Встроенная база данных SNMP</target>
        </trans-unit>
        <trans-unit id="1f9b4daeb0c18439d5ab9d3febb86ba8cf3f41bc" translate="yes" xml:space="preserve">
          <source>The SNMP development tool provides an environment for rapid agent/manager prototyping and construction. With the following information provided, this tool is used to set up a running multi-lingual SNMP agent/manager:</source>
          <target state="translated">Инструмент для разработки SNMP обеспечивает среду для быстрого создания прототипов агентов/менеджеров и строительства.Приведенная ниже информация используется для настройки работающего многоязычного агента/менеджера SNMP:</target>
        </trans-unit>
        <trans-unit id="4042139e11f084c5315473eee5bae69ee58a652c" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit contains the following parts:</source>
          <target state="translated">Инструментарий разработки SNMP состоит из следующих частей:</target>
        </trans-unit>
        <trans-unit id="c676c0d7043a8420fb555224be79bdf5a57f0b38" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit works with all three versions of Standard Internet Management Framework; SNMPv1, SNMPv2 and SNMPv3. They all share the same basic structure and components. And they follow the same architecture.</source>
          <target state="translated">Инструментарий разработки SNMP работает со всеми тремя версиями Standard Internet Management Framework:SNMPv1,SNMPv2 и SNMPv3.Все они имеют одинаковую базовую структуру и компоненты.И они следуют одной и той же архитектуре.</target>
        </trans-unit>
        <trans-unit id="4c98874c0a92d51a9659461230a55d2c1a730338" translate="yes" xml:space="preserve">
          <source>The SNMP-COMMUNITY-MIB defines managed objects that is used for coexistence between SNMPv1 and SNMPv2c with SNMPv3. Specifically, it contains objects for mapping between community strings and version-independent SNMP message parameters. In addition, this MIB provides a mechanism for performing source address validation on incoming requests, and for selecting community strings based on target addresses for outgoing notifications.</source>
          <target state="translated">SNMP-COMMUNITY-MIB определяет управляемые объекты,которые используются для сосуществования SNMPv1 и SNMPv2c с SNMPv3.В частности,он содержит объекты для сопоставления между строками сообщества и версионно-независимыми параметрами сообщений SNMP.Кроме того,MIB предоставляет механизм проверки исходных адресов на входящие запросы,а также выбора строк сообщества на основе целевых адресов для исходящих уведомлений.</target>
        </trans-unit>
        <trans-unit id="8668c117c3657ad50b4bac1040aadc9d90558e41" translate="yes" xml:space="preserve">
          <source>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional read-only managed objects, which is used in the generic SNMP framework defined in RFC2271 and the generic message processing and dispatching module defined in RFC2272. They are generic in the sense that they are not tied to any specific SNMP version.</source>
          <target state="translated">SNMP-FRAMEWORK-MIB и SNMP-MPD-MIB определяют дополнительные объекты,управляемые только для чтения,которые используются в общей структуре SNMP,определенной в RFC2271,и модуль обработки и отправки общих сообщений,определенный в RFC2272.Они являются общими в том смысле,что они не привязаны ни к одной конкретной версии SNMP.</target>
        </trans-unit>
        <trans-unit id="45b5b2d3e04821e69bc6b70c4958af997f02dac7" translate="yes" xml:space="preserve">
          <source>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed objects for configuration of notification receivers. They are described in detail in RFC2273. Only a brief description is given here.</source>
          <target state="translated">SNMP-TARGET-MIB и SNMP-NOTIFICATION-MIB определяют управляемые объекты для конфигурации приемников уведомлений.Они подробно описаны в RFC2273.Здесь приводится только краткое описание.</target>
        </trans-unit>
        <trans-unit id="9d8ba60d5c67646e6a39ec77ff47623898401ff5" translate="yes" xml:space="preserve">
          <source>The SNMP-USER-BASED-SM-MIB defines managed objects that is used for the User-Based Security Model.</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB определяет управляемые объекты,которые используются для пользовательской модели безопасности.</target>
        </trans-unit>
        <trans-unit id="06a4a7a167128e9dfbd7bbf5787fec903cb71f3c" translate="yes" xml:space="preserve">
          <source>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to control access to the the managed objects for the managers. The View Based Access Control Module (VACM) can be used with any SNMP version. However, if it is used with SNMPv1 or SNMPv2c, the SNMP-COMMUNITY-MIB defines additional objects to map community strings to VACM parameters.</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB определяет управляемые объекты для контроля доступа к управляемым объектам для менеджеров.Модуль управления доступом на основе представлений (VACM)может использоваться с любой версией SNMP.Однако,если он используется с SNMPv1 или SNMPv2c,SNMP-COMMUNITY-MIB определяет дополнительные объекты для сопоставления строк сообщества с параметрами VACM.</target>
        </trans-unit>
        <trans-unit id="cf1237e4f8f3b9ace0c3f4bf9ded6dcb4f4634bb" translate="yes" xml:space="preserve">
          <source>The SNMPv3 specifications take a modular approach to SNMP. All modules are separated from each other, and can be extended or replaced individually. Examples of modules are Message definition, Security and Access Control. The main features of SNMPv3 are:</source>
          <target state="translated">В спецификациях SNMPv3 используется модульный подход к SNMP.Все модули отделены друг от друга и могут быть расширены или заменены по отдельности.Примерами модулей являются:Определение сообщений,Безопасность и Контроль доступа.Основные особенности SNMPv3:</target>
        </trans-unit>
        <trans-unit id="49091ee8eff63f8735f82d85f410f0e974abd772" translate="yes" xml:space="preserve">
          <source>The SSH Authentication Protocol is a general-purpose user authentication protocol run over the SSH Transport Layer Protocol. The &lt;code&gt;ssh&lt;/code&gt; application supports user authentication as follows:</source>
          <target state="translated">Протокол аутентификации SSH - это протокол аутентификации пользователя общего назначения, работающий на основе протокола транспортного уровня SSH. Приложение &lt;code&gt;ssh&lt;/code&gt; поддерживает аутентификацию пользователя следующим образом:</target>
        </trans-unit>
        <trans-unit id="7b0b1cec477594d6b882874c149d3fa88e25a3ad" translate="yes" xml:space="preserve">
          <source>The SSH Connection Protocol provides application-support services over the transport pipe, for example, channel multiplexing, flow control, remote program execution, signal propagation, and connection forwarding. Functions for handling the SSH Connection Protocol can be found in the module &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">Протокол соединения SSH предоставляет услуги поддержки приложений по транспортному каналу, например, мультиплексирование каналов, управление потоком, удаленное выполнение программы, распространение сигнала и переадресацию соединения. Функции для обработки протокола подключения SSH можно найти в модуле &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;ssh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="509aa3afb50ca256dde1f08abd1d170febe86fc9" translate="yes" xml:space="preserve">
          <source>The SSH Transport Protocol is a secure, low-level transport. It provides strong encryption, cryptographic host authentication, and integrity protection. A minimum of Message Authentication Code (MAC) and encryption algorithms are supported. For details, see the &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; manual page in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">Транспортный протокол SSH - это безопасный транспорт низкого уровня. Он обеспечивает надежное шифрование, криптографическую аутентификацию хоста и защиту целостности. Поддерживается минимум код аутентификации сообщения (MAC) и алгоритмы шифрования. Подробности смотрите на странице руководства &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;ssh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744c82a62e8aa358bae0f2bd9bcd0a7ad67c79e1" translate="yes" xml:space="preserve">
          <source>The SSH app's mechanism</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cafe9a62d6f03f5d4b28fc5be0a442441723104" translate="yes" xml:space="preserve">
          <source>The SSH protocol therefore has a special operation defined -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf96a70f08f9bc454fcd92af00d3c4835a1fd09" translate="yes" xml:space="preserve">
          <source>The SSH server on UNIX/Linux/etc after a succesful authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d33b22db4cc904f86f4d5db9025bf058eaf503" translate="yes" xml:space="preserve">
          <source>The SSL/TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="translated">Параметры распространения SSL / TLS могут быть записаны в файл, к которому обращаются при запуске узла. Затем это имя файла указывается с помощью аргумента командной строки &lt;code&gt;-ssl_dist_optfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ffdfd10003f355a79033be2fe1f79f1e9e6854" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555d2ccf08ac60c2e06799bc61b70df2c88b6a2f" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog-daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">Сообщения Solaris (SunOS 5.x) извлекаются из syslog-daemon, &lt;code&gt;syslogd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23097a6cf28465a184806bf15474a12dff162d12" translate="yes" xml:space="preserve">
          <source>The Standard Erlang Libraries application, &lt;strong&gt;STDLIB&lt;/strong&gt;, is mandatory in the sense that the minimal system based on Erlang/OTP consists of &lt;strong&gt;STDLIB&lt;/strong&gt; and &lt;strong&gt;Kernel&lt;/strong&gt;.</source>
          <target state="translated">Приложение стандартных библиотек Erlang, &lt;strong&gt;STDLIB&lt;/strong&gt; , является обязательным в том смысле, что минимальная система, основанная на Erlang / OTP, состоит из &lt;strong&gt;STDLIB&lt;/strong&gt; и &lt;strong&gt;ядра&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5c2a74e481bb59b29d7198edb8d96d6f22f60622" translate="yes" xml:space="preserve">
          <source>The System Under Test (SUT) can consist of one or more target nodes. &lt;code&gt;Common Test&lt;/code&gt; contains a generic test server that, together with other test utilities, is used to perform test case execution. The tests can be started from a GUI, from the OS shell, or from an Erlang shell. &lt;strong&gt;Test suites&lt;/strong&gt; are files (Erlang modules) that contain the &lt;strong&gt;test cases&lt;/strong&gt; (Erlang functions) to be executed. &lt;strong&gt;Support modules&lt;/strong&gt; provide functions that the test cases use to do the tests.</source>
          <target state="translated">Тестируемая система (SUT) может состоять из одного или нескольких целевых узлов. &lt;code&gt;Common Test&lt;/code&gt; содержит общий тестовый сервер, который вместе с другими тестовыми утилитами используется для выполнения тестового примера. Тесты можно запускать из графического интерфейса, из оболочки ОС или из оболочки Erlang. &lt;strong&gt;Наборы тестов&lt;/strong&gt; - это файлы (модули Erlang), которые содержат &lt;strong&gt;тестовые примеры&lt;/strong&gt; (функции Erlang), которые необходимо выполнить. &lt;strong&gt;Модули поддержки&lt;/strong&gt; предоставляют функции, которые тестовые примеры используют для выполнения тестов.</target>
        </trans-unit>
        <trans-unit id="eb87875630edf563277392030eee430765ee9a3b" translate="yes" xml:space="preserve">
          <source>The TCP/IP &lt;code&gt;epmd&lt;/code&gt; daemon only keeps track of the &lt;code&gt;Name&lt;/code&gt; (first) part of an Erlang node name. The &lt;code&gt;Host&lt;/code&gt; part (whatever is after the &lt;code&gt;@&lt;/code&gt;) is implicit in the node name where the &lt;code&gt;epmd&lt;/code&gt; daemon was contacted, as is the IP address where the Erlang node can be reached. Consistent and correct TCP naming services are therefore required for an Erlang network to function correctly.</source>
          <target state="translated">Демон TCP / IP &lt;code&gt;epmd&lt;/code&gt; отслеживает только часть &lt;code&gt;Name&lt;/code&gt; (первую) имени узла Erlang. Часть &lt;code&gt;Host&lt;/code&gt; (все, что стоит после &lt;code&gt;@&lt;/code&gt; ) неявно &lt;code&gt;epmd&lt;/code&gt; в имени узла, к которому был подключен демон epmd , как и IP-адрес, по которому может быть достигнут узел Erlang. Следовательно, для правильной работы сети Erlang требуются согласованные и правильные службы именования TCP.</target>
        </trans-unit>
        <trans-unit id="058df102c079061352735c937be80bdb1a45818f" translate="yes" xml:space="preserve">
          <source>The TCP/IP distribution uses a handshake that expects a connection-based protocol, that is, the protocol does not include any authentication after the handshake procedure.</source>
          <target state="translated">Распределение TCP/IP использует ручное квитирование,которое ожидает протокол,основанный на соединении,т.е.протокол не включает никакой аутентификации после процедуры ручного квитирования.</target>
        </trans-unit>
        <trans-unit id="6657b1618f0a92c332d5f9a74326d92f2550bf02" translate="yes" xml:space="preserve">
          <source>The TCP_NODELAY option for the telnet socket is disabled (set to &lt;code&gt;false&lt;/code&gt;) per default</source>
          <target state="translated">Параметр TCP_NODELAY для сокета telnet отключен (установлен в &lt;code&gt;false&lt;/code&gt; ) по умолчанию</target>
        </trans-unit>
        <trans-unit id="27af0d178d9d81560da76e1bb5028c47f5e6d47a" translate="yes" xml:space="preserve">
          <source>The TFTP port where the daemon listens. Defaults is the standardized number 69. On the server side, it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one is returned by function &lt;code&gt;info/1&lt;/code&gt;).</source>
          <target state="translated">Порт TFTP, на котором слушает демон. По умолчанию это стандартизованное число 69. На стороне сервера иногда имеет смысл установить его в 0, что означает, что демон просто выбирает свободный порт (который возвращается функцией &lt;code&gt;info/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d58f1eb861475088c58d8cf25b2227f3e09eb03" translate="yes" xml:space="preserve">
          <source>The TLS 1.3 protocol does not provide inherent protection for replay of 0-RTT data but describes mechanisms that SHOULD be implemented by compliant server implementations. The implementation of TLS 1.3 in the SSL application employs all standard methods to prevent potential threats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efab23f28e335395659c14ebcb8051f53a7632c5" translate="yes" xml:space="preserve">
          <source>The TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ccd2ece5259566f90ebb1a8f2c68746b4c7b93" translate="yes" xml:space="preserve">
          <source>The TLS/DTLS handshake protocol and data transfer is run on top of the TLS/DTLS Record Protocol, which uses a keyed-hash Message Authenticity Code (MAC), or a Hash-based MAC (HMAC), to protect the message data integrity. From the TLS RFC: &quot;A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.&quot;</source>
          <target state="translated">Протокол TLS/DTLS рукопожатия и передачи данных выполняется поверх протокола TLS/DTLS Record Protocol,который использует код аутентичности сообщения с ключом хэша (MAC)или MAC на основе хэша (Hash-based MAC)для защиты целостности данных сообщения.Из TLS RFC:&quot;Код аутентификации сообщения-это односторонний хэш,вычисленный из сообщения и некоторых секретных данных&quot;.Трудно подделать,не зная секретных данных&quot;.Его цель-определить,было ли сообщение изменено&quot;.</target>
        </trans-unit>
        <trans-unit id="ecf685e6c13939907b870d82ee6d0c05ec6e094e" translate="yes" xml:space="preserve">
          <source>The Text Based Trace Facility</source>
          <target state="translated">Текстовый механизм отслеживания</target>
        </trans-unit>
        <trans-unit id="e8fd67f45550805b41375cc84bc114e897e3206a" translate="yes" xml:space="preserve">
          <source>The Trace Tool Builder, &lt;code&gt;ttb&lt;/code&gt;, is a base for building trace tools for distributed systems.</source>
          <target state="translated">Конструктор инструментов трассировки, &lt;code&gt;ttb&lt;/code&gt; , является основой для создания инструментов трассировки для распределенных систем.</target>
        </trans-unit>
        <trans-unit id="64d22e790fe528bf704a212bc1e1c0da643a949f" translate="yes" xml:space="preserve">
          <source>The Trace area also displays Back Trace, a summary of the current function calls on the stack.</source>
          <target state="translated">В области прослеживания также отображается Back Trace (Трассировка назад)-сводка вызовов текущей функции на стеке.</target>
        </trans-unit>
        <trans-unit id="b692df8320088d88e275d851ad60786d4e949a1f" translate="yes" xml:space="preserve">
          <source>The Trace area, which displays a trace output for the process.</source>
          <target state="translated">Область трассировки,в которой отображается вывод трассировки для процесса.</target>
        </trans-unit>
        <trans-unit id="1b50d3d2fc04c4411539dfbb6e62512f2efa0130" translate="yes" xml:space="preserve">
          <source>The Trivial File Transfer Protocol or TFTP is a very simple protocol used to transfer files.</source>
          <target state="translated">Trivial File Transfer Protocol или TFTP-очень простой протокол,используемый для передачи файлов.</target>
        </trans-unit>
        <trans-unit id="bf89156ef59750c4bb77ca15635b355ebce24e10" translate="yes" xml:space="preserve">
          <source>The Types are:</source>
          <target state="translated">Типы:</target>
        </trans-unit>
        <trans-unit id="a2becef736618dd80aea9ed87dc6889b0431226f" translate="yes" xml:space="preserve">
          <source>The URI parser tries all possible combinations to interpret the input and fails at the last attempt when it encounters the colon character &lt;code&gt;&quot;:&quot;&lt;/code&gt;. Note, that the inital fault occurs when the parser attempts to interpret the character &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; and after a failure back-tracks to the point where it has another possible parsing alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea556d1f13405f24d60defd343780b8d63e1882" translate="yes" xml:space="preserve">
          <source>The URL the client was on before requesting the URL (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">URL,на котором клиент был перед запросом URL (если его невозможно определить,в этом поле ставится знак минус).</target>
        </trans-unit>
        <trans-unit id="2cd23bacb56d43630d70d816af467c37a05ab674" translate="yes" xml:space="preserve">
          <source>The UTF-8 variants were introduced in Erlang/OTP R16 and the string returned by &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; was not &lt;code&gt;NULL&lt;/code&gt;-terminated on older releases.</source>
          <target state="translated">Варианты UTF-8 были введены в Erlang / OTP R16, и строка, возвращаемая &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; не завершалась &lt;code&gt;NULL&lt;/code&gt; в более старых версиях.</target>
        </trans-unit>
        <trans-unit id="c76d8253124bd005c5e7c3968606bd5eebfe787e" translate="yes" xml:space="preserve">
          <source>The Unexpected I/O Log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615107616ab4a2ac637d22a3e97ccf0d1ff89d56" translate="yes" xml:space="preserve">
          <source>The Unicode characters need to be processed by the Erlang program, which is why library functions must be able to handle them. In some cases functionality has been added to already existing interfaces (as the &lt;code&gt;string&lt;/code&gt; module now can handle strings with any code points). In some cases new functionality or options have been added (as in the &lt;code&gt;io&lt;/code&gt; module, the file handling, the &lt;code&gt;unicode&lt;/code&gt; module, and the bit syntax). Today most modules in Kernel and STDLIB, as well as the VM are Unicode-aware.</source>
          <target state="translated">Символы Unicode должны обрабатываться программой Erlang, поэтому библиотечные функции должны уметь их обрабатывать. В некоторых случаях функциональность была добавлена ​​к уже существующим интерфейсам (поскольку теперь &lt;code&gt;string&lt;/code&gt; модуль может обрабатывать строки с любыми кодовыми точками). В некоторых случаях были добавлены новые функции или параметры (например, модуль &lt;code&gt;io&lt;/code&gt; , обработка файлов, модуль &lt;code&gt;unicode&lt;/code&gt; и битовый синтаксис). Сегодня большинство модулей ядра и STDLIB, а также виртуальная машина поддерживают Unicode.</target>
        </trans-unit>
        <trans-unit id="d8a64b00a37fa70a62423e7afa68917e078e3bbf" translate="yes" xml:space="preserve">
          <source>The Unicode file naming support was introduced in Erlang/OTP R14B01. A VM operating in Unicode filename translation mode can work with files having names in any language or character set (as long as it is supported by the underlying operating system and file system). The Unicode character list is used to denote filenames or directory names. If the file system content is listed, you also get Unicode lists as return value. The support lies in the Kernel and STDLIB modules, which is why most applications (that do not explicitly require the filenames to be in the ISO Latin-1 range) benefit from the Unicode support without change.</source>
          <target state="translated">В Erlang/OTP R14B01 была внедрена поддержка именования файлов в формате Unicode.ВМ,работающие в режиме Unicode,могут работать с файлами,имеющими имена на любом языке или с любым набором символов (при условии,что это поддерживается базовой операционной системой и файловой системой).Список символов Юникода используется для обозначения имен файлов или директорий.Если в списке присутствует содержимое файловой системы,то в качестве возвращаемого значения вы также получаете списки в формате Юникод.Поддержка лежит в модулях Kernel и STDLIB,поэтому большинство приложений (которые явно не требуют,чтобы имена файлов были в диапазоне ISO Latin-1)пользуются поддержкой Юникода без изменений.</target>
        </trans-unit>
        <trans-unit id="2e08532eda1cbb1ea06bfac649530b3d005afb89" translate="yes" xml:space="preserve">
          <source>The Unicode string is returned as a Unicode list, which is recognized as such, as the Erlang shell uses the Unicode encoding (and is started with all Unicode characters considered printable). The Unicode list is valid input to function &lt;code&gt;io:put_chars/2&lt;/code&gt;, so data can be output on any Unicode-capable device. If the device is a terminal, characters are output in format &lt;code&gt;\x{&lt;/code&gt;H...&lt;code&gt;}&lt;/code&gt; if encoding is &lt;code&gt;latin1&lt;/code&gt;. Otherwise in UTF-8 (for the non-interactive terminal: &quot;oldshell&quot; or &quot;noshell&quot;) or whatever is suitable to show the character properly (for an interactive terminal: the regular shell).</source>
          <target state="translated">Строка Unicode возвращается в виде списка Unicode, который распознается как таковой, поскольку оболочка Erlang использует кодировку Unicode (и запускается со всеми символами Unicode, которые считаются печатаемыми). Список Unicode является допустимым входом для функции &lt;code&gt;io:put_chars/2&lt;/code&gt; , поэтому данные могут выводиться на любое устройство с поддержкой Unicode. Если устройство является терминалом, символы выводятся в формате &lt;code&gt;\x{&lt;/code&gt; H ... &lt;code&gt;}&lt;/code&gt; , если кодировка &lt;code&gt;latin1&lt;/code&gt; . В противном случае в UTF-8 (для неинтерактивного терминала: &amp;laquo;oldshell&amp;raquo; или &amp;laquo;noshell&amp;raquo;) или в другом подходящем для правильного отображения символа (для интерактивного терминала: обычная оболочка).</target>
        </trans-unit>
        <trans-unit id="917f1b5ccc007e44df82f5ad9e8e418e0762f6b0" translate="yes" xml:space="preserve">
          <source>The Unicode support is controlled by both command-line switches, some standard environment variables, and the OTP version you are using. Most options affect mainly how Unicode data is displayed, not the functionality of the APIs in the standard libraries. This means that Erlang programs usually do not need to concern themselves with these options, they are more for the development environment. An Erlang program can be written so that it works well regardless of the type of system or the Unicode options that are in effect.</source>
          <target state="translated">Поддержка Unicode контролируется обоими переключателями командной строки,некоторыми стандартными переменными окружения,а также используемой вами версией OTP.Большинство опций в основном влияют на то,как отображаются данные Unicode,а не на функциональность API в стандартных библиотеках.Это означает,что Erlang-программам обычно не нужно беспокоиться об этих опциях,они больше подходят для среды разработки.Программу на Erlang можно написать так,чтобы она хорошо работала независимо от типа системы или действующих опций Юникода.</target>
        </trans-unit>
        <trans-unit id="9e4f13026f64ec5f7cdd6285c03d5258bacc1cd2" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier &lt;code&gt;t&lt;/code&gt; specifies how to treat characters outside the Latin-1 range of codepoints, in atoms, strings, and binaries. For example, printing an atom containing a character &amp;gt; 255:</source>
          <target state="translated">Модификатор перевода Unicode &lt;code&gt;t&lt;/code&gt; определяет, как обрабатывать символы вне диапазона кодовых точек Latin-1 в атомах, строках и двоичных файлах. Например, печать атома, содержащего символ&amp;gt; 255:</target>
        </trans-unit>
        <trans-unit id="e24a7d795c65b90caaa133aaf71048aad49fb98e" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier works as with &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">Модификатор перевода Unicode работает как с &lt;code&gt;s&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b61b21ce88bdc4622a6b58534472bd97a7d6b6d9" translate="yes" xml:space="preserve">
          <source>The Unix &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is to be set to the display of the master node.</source>
          <target state="translated">Переменная среды UNIX &lt;code&gt;DISPLAY&lt;/code&gt; должна быть установлена ​​на отображение главного узла.</target>
        </trans-unit>
        <trans-unit id="7580a1c9657bbaca0bea72d41a48c1a2c9f178ef" translate="yes" xml:space="preserve">
          <source>The VM performs tail call optimization, which does not add new entries to the stacktrace, and also limits stacktraces to a certain depth. Furthermore, compiler options, optimizations and future changes may add or remove stacktrace entries, causing any code that expects the stacktrace to be in a certain order or contain specific items to fail.</source>
          <target state="translated">ВМ выполняет оптимизацию хвостового вызова,которая не добавляет новых записей в стековую трассу,а также ограничивает стековую трассу до определенной глубины.Более того,опции компилятора,оптимизации и будущие изменения могут добавлять или удалять записи стековой дорожки,в результате чего любой код,ожидающий,что стековая дорожка находится в определенном порядке или содержит определенные элементы,может выйти из строя.</target>
        </trans-unit>
        <trans-unit id="36921b8c054120393af51df837412dde5ebe77c2" translate="yes" xml:space="preserve">
          <source>The VM with SMP support makes quite a heavy use of atomic memory operations. An implementation providing native atomic memory operations is therefore very important when building Erlang/OTP. By default the VM will refuse to build if native atomic memory operations are not available.</source>
          <target state="translated">ВМ с поддержкой SMP достаточно интенсивно использует атомарные операции с памятью.Поэтому при сборке Erlang/OTP очень важна реализация,обеспечивающая нативные операции с памятью.По умолчанию ВМ откажется от сборки,если родные атомарные операции памяти недоступны.</target>
        </trans-unit>
        <trans-unit id="883c00fb93b6833f40d7fa937a519315da18d85d" translate="yes" xml:space="preserve">
          <source>The View Module window displays the contents of an interpreted module and makes it possible to set breakpoints.</source>
          <target state="translated">Окно View Module отображает содержимое интерпретируемого модуля и позволяет устанавливать точки останова.</target>
        </trans-unit>
        <trans-unit id="818a2a38b6d37966404b0037603dc28865b80d3d" translate="yes" xml:space="preserve">
          <source>The Windows messages are retrieved from the eventlog file.</source>
          <target state="translated">Сообщения Windows извлекаются из файла журнала событий.</target>
        </trans-unit>
        <trans-unit id="1ef81693a27626a4d31fec58f2301060476cd06b" translate="yes" xml:space="preserve">
          <source>The Windows system is rebooted whenever the emulator stops (a more simple form of watchdog). This can be useful for less critical systems, otherwise use the heart functionality to accomplish this.</source>
          <target state="translated">Система Windows перезагружается всякий раз,когда эмулятор останавливается (более простая форма сторожевого пса).Это может быть полезно для менее критичных систем,в противном случае используйте для этого функциональность сердца.</target>
        </trans-unit>
        <trans-unit id="66afd9d96a38a37c4f7f94ff1bd05dfee703afea" translate="yes" xml:space="preserve">
          <source>The XML version shown earlier can also be used, but it is to be explicitly specified that the &lt;code&gt;ct_config_xml&lt;/code&gt; callback module is to be used by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">Показанная ранее версия XML также может быть использована, но необходимо явно указать, что &lt;code&gt;ct_config_xml&lt;/code&gt; обратного вызова ct_config_xml должен использоваться &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="252a4b864e9fb6b863b0c8c232185b5a96bbfa1c" translate="yes" xml:space="preserve">
          <source>The \A, \Z, and \z assertions differ from the traditional circumflex and dollar (described in the next section) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode. These three assertions are not affected by options &lt;code&gt;notbol&lt;/code&gt; or &lt;code&gt;noteol&lt;/code&gt;, which affect only the behavior of the circumflex and dollar metacharacters. However, if argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, indicating that matching is to start at a point other than the beginning of the subject, \A can never match. The difference between \Z and \z is that \Z matches before a newline at the end of the string and at the very end, while \z matches only at the end.</source>
          <target state="translated">Утверждения \ A, \ Z и \ z отличаются от традиционных циркумфлексов и долларов (описанных в следующем разделе) тем, что они всегда совпадают только в самом начале и в конце строки темы, какие бы параметры не были установлены. Таким образом, они не зависят от многострочного режима. На эти три утверждения не влияют параметры &lt;code&gt;notbol&lt;/code&gt; или &lt;code&gt;noteol&lt;/code&gt; , которые влияют только на поведение метасимволов с циркумфлексом и доллара. Однако, если аргумент &lt;code&gt;startoffset&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; не равен нулю, что указывает на то, что сопоставление должно начинаться с точки, отличной от начала объекта, \ A никогда не может соответствовать. Разница между \ Z и \ z заключается в том, что \ Z соответствует перед новой строкой в ​​конце строки и в самом конце, а \ z соответствует только в конце.</target>
        </trans-unit>
        <trans-unit id="943d4453f30bb5749d0c52004563365b21bda38a" translate="yes" xml:space="preserve">
          <source>The \C escape sequence</source>
          <target state="translated">Последовательность эвакуации \C</target>
        </trans-unit>
        <trans-unit id="4f34ba1108b5cb6716129944fbf4f4329a0a6235" translate="yes" xml:space="preserve">
          <source>The \C escape sequence is best avoided. However, one way of using it that avoids the problem of malformed UTF characters is to use a lookahead to check the length of the next character, as in the following pattern, which can be used with a UTF-8 string (ignore whitespace and line breaks):</source>
          <target state="translated">Лучше всего избегать последовательности эвакуации по адресу \C.Однако,один из способов ее использования,который позволяет избежать проблемы некорректного отображения символов UTF-это использование lookahead для проверки длины следующего символа,как в следующем шаблоне,который может быть использован со строкой UTF-8 (игнорируйте пробелы и разрывы строк):</target>
        </trans-unit>
        <trans-unit id="c3ea67e0b67cb019dc5aaa8e95c03b5cb7572754" translate="yes" xml:space="preserve">
          <source>The \G assertion is true only when the current matching position is at the start point of the match, as specified by argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;run/3&lt;/code&gt;. It differs from \A when the value of &lt;code&gt;startoffset&lt;/code&gt; is non-zero. By calling &lt;code&gt;run/3&lt;/code&gt; multiple times with appropriate arguments, you can mimic the Perl option &lt;code&gt;/g&lt;/code&gt;, and it is in this kind of implementation where \G can be useful.</source>
          <target state="translated">Утверждение \ G истинно, только если текущая позиция совпадения находится в начальной точке совпадения, как указано аргументом &lt;code&gt;startoffset&lt;/code&gt; для &lt;code&gt;run/3&lt;/code&gt; . Он отличается от \ A, когда значение &lt;code&gt;startoffset&lt;/code&gt; не равно нулю. Вызывая &lt;code&gt;run/3&lt;/code&gt; несколько раз с соответствующими аргументами, вы можете имитировать параметр Perl &lt;code&gt;/g&lt;/code&gt; , и именно в такой реализации \ G может быть полезен.</target>
        </trans-unit>
        <trans-unit id="2f7f1b350c6833ef257bc14bd5940d6dff8095f3" translate="yes" xml:space="preserve">
          <source>The \Q...\E sequence is recognized both inside and outside character classes. An isolated \E that is not preceded by \Q is ignored. If \Q is not followed by \E later in the pattern, the literal interpretation continues to the end of the pattern (that is, \E is assumed at the end). If the isolated \Q is inside a character class, this causes an error, as the character class is not terminated.</source>
          <target state="translated">Последовательность \Q...\E распознается как внутри,так и снаружи классов символов.Изолированный \E,которому не предшествует \Q,игнорируется.Если за \Q не следует \E позднее в шаблоне,буквальная интерпретация продолжается до конца шаблона (т.е.в конце предполагается \E).Если изолированный \Q находится внутри символьного класса,то это приводит к ошибке,так как символьный класс не завершается.</target>
        </trans-unit>
        <trans-unit id="14658b1c2056da1457d1137feae50fbf03cef97b" translate="yes" xml:space="preserve">
          <source>The \R escape sequence</source>
          <target state="translated">Последовательность эвакуации \R</target>
        </trans-unit>
        <trans-unit id="4253fcd6879a11eec01b435167179d5e15f76711" translate="yes" xml:space="preserve">
          <source>The \X escape matches any number of Unicode characters that form an &quot;extended grapheme cluster&quot;, and treats the sequence as an atomic group (see below). Up to and including release 8.31, PCRE matched an earlier, simpler definition that was equivalent to &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt;. That is, it matched a character without the &quot;mark&quot; property, followed by zero or more characters with the &quot;mark&quot; property. Characters with the &quot;mark&quot; property are typically non-spacing accents that affect the preceding character.</source>
          <target state="translated">\ X escape соответствует любому количеству символов Unicode, которые образуют &amp;laquo;расширенный кластер графемы&amp;raquo;, и рассматривает последовательность как атомарную группу (см. Ниже). До выпуска 8.31 включительно PCRE соответствовало более раннему, более простому определению, которое было эквивалентно &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt; . То есть он соответствует символу без свойства &amp;laquo;mark&amp;raquo;, за которым следует ноль или более символов со свойством &amp;laquo;mark&amp;raquo;. Символы со свойством &amp;laquo;mark&amp;raquo; обычно являются акцентами без пробелов, которые влияют на предыдущий символ.</target>
        </trans-unit>
        <trans-unit id="fe0ff3b7597c9ca177e61f2b7394c84224900254" translate="yes" xml:space="preserve">
          <source>The \X escape sequence</source>
          <target state="translated">Последовательность эвакуации \X</target>
        </trans-unit>
        <trans-unit id="1a667df5d1564a7cf0ddb2cbecc475bdb5eb483f" translate="yes" xml:space="preserve">
          <source>The \c facility was designed for use with ASCII characters, but with the extension to Unicode it is even less useful than it once was.</source>
          <target state="translated">Подсистема \c была разработана для использования с ASCII-символами,но с расширением до Юникода она еще менее полезна,чем когда-то.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
