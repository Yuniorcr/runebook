<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="19737da2fe03d867999d377974efb452c080feda" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fbdc51ae228be4fbd8c6e7c0ddb45260e0acb0" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Если P - образец nil &lt;code&gt;[]&lt;/code&gt; , то Rep (P) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72a84ce197dfd951db7868fea8973a6459407137" translate="yes" xml:space="preserve">
          <source>If P is a parenthesized pattern &lt;code&gt;( P_0 )&lt;/code&gt;, then Rep(P) = &lt;code&gt;Rep(P_0)&lt;/code&gt;, that is, parenthesized patterns cannot be distinguished from their bodies.</source>
          <target state="translated">Если P - это узор в скобках &lt;code&gt;( P_0 )&lt;/code&gt; , то Rep (P) = &lt;code&gt;Rep(P_0)&lt;/code&gt; , то есть узоры в скобках нельзя отличить от их тела.</target>
        </trans-unit>
        <trans-unit id="dfc926eeb885550b2057f5eaa3e598f075f5fb9c" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dae07160d27f4934f31cae5e6b4f2d04d1afc9" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Если P - шаблон индекса поля записи &lt;code&gt;#Name.Field&lt;/code&gt; , где &lt;code&gt;Field&lt;/code&gt; - атом, тогда Rep (P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6a33479e55d6adf6c5f304da26c896bfab008d" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(P_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c817b814455c0bbd5e19cc0a1e27a932ad7ae3e" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Если P - шаблон записи &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; , где каждое &lt;code&gt;Field_i&lt;/code&gt; является атомом или &lt;code&gt;_&lt;/code&gt; , тогда Rep (P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75542af568a4e6fd74ec30069d26212ef35f7d03" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,ANNO,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f2ebd069093962c3169272794269248d2ef02b" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если P является шаблоном кортежа &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; , то Rep (P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f93073cfd79739d9e631820436bac79686fc83" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,ANNO,'_'}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1673a195237ed41e2323e9fba0581f25f4bc7a6c" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt;.</source>
          <target state="translated">Если P - универсальный образец &lt;code&gt;_&lt;/code&gt; , то Rep (P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3149c3832edd80b313902a9d154c6d727e573468" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374e95854b4ce10a9075d7ca4749ba4604e1f66b" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Если P является переменной модели &lt;code&gt;V&lt;/code&gt; , то Реп (Р) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , где А представляет собой атом с printname , состоящей из одних и тех же символов , как &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="037087e53a14f2b5880a3446fa475c0011fde7f9" translate="yes" xml:space="preserve">
          <source>If P is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(P) = Rep(L).</source>
          <target state="translated">Если P - атомарный литерал &lt;code&gt;L&lt;/code&gt; , то Rep (P) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="faca9ab114984c50875ddef7ab3151e741e59fdd" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,ANNO,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3611eec9cbc1948d638f692cb3c204535c40a243" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">Если P - шаблон оператора &lt;code&gt;Op P_0&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; - унарный оператор (это вхождение выражения, которое может быть вычислено до числа во время компиляции), то Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e5c0b3f1ae8df31dec63b9c72633bdc64593894" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,ANNO,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20d57a29a11d3b725da4217b551d072cb2d9645" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">Если P - шаблон оператора &lt;code&gt;P_1 Op P_2&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; - бинарный оператор (это либо вхождение &lt;code&gt;++&lt;/code&gt; , примененное к литеральной строке или списку символов, либо вхождение выражения, которое может быть оценено как число во время компиляции ), то Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a50d35a985d1c4853945f370a6dcaf95a405ff8" translate="yes" xml:space="preserve">
          <source>If PER encoding is wanted:</source>
          <target state="translated">Если нужна PER-кодировка:</target>
        </trans-unit>
        <trans-unit id="8e69f891849831d14d1ae17a1a43b56f2f0e1d17" translate="yes" xml:space="preserve">
          <source>If Ps is a sequence of patterns &lt;code&gt;P_1, ..., P_k&lt;/code&gt;, then Rep(Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt;. Such sequences occur as the list of arguments to a function or fun.</source>
          <target state="translated">Если Ps представляет собой последовательность шаблонов &lt;code&gt;P_1, ..., P_k&lt;/code&gt; , то Rep (Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt; . Такие последовательности встречаются как список аргументов функции или развлечения.</target>
        </trans-unit>
        <trans-unit id="ad13e93659ed632a16cc4f4903f37ddc1132e280" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3d9c3be41ff91340aed17068892205b8e19bdf" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Если Q - генератор битовой строки &lt;code&gt;P &amp;lt;= E&lt;/code&gt; , где &lt;code&gt;P&lt;/code&gt; - шаблон, а &lt;code&gt;E&lt;/code&gt; - выражение, то Rep (Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50623f16fe5c165b35f76e12f8a3d6ba87d05b14" translate="yes" xml:space="preserve">
          <source>If Q is a filter &lt;code&gt;E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;Rep(E)&lt;/code&gt;.</source>
          <target state="translated">Если Q - фильтр &lt;code&gt;E&lt;/code&gt; , где &lt;code&gt;E&lt;/code&gt; - выражение, то Rep (Q) = &lt;code&gt;Rep(E)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="809f12ef8c3064b918954c279d0a931407f3434e" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed7ef1b4d4a36ddad7dd7fceafbd179ffb47f54" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Если Q - генератор &lt;code&gt;P &amp;lt;- E&lt;/code&gt; , где &lt;code&gt;P&lt;/code&gt; - образец, а &lt;code&gt;E&lt;/code&gt; - выражение, тогда Rep (Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee5bb555da8992e2b4f0f92c76f0e2b4698cbd0" translate="yes" xml:space="preserve">
          <source>If R is a relation from X to Y, and S is a relation from Y to Z, the &lt;strong id=&quot;relative_product&quot;&gt;relative product&lt;/strong&gt; of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z.</source>
          <target state="translated">Если R - отношение от X к Y, а S - отношение от Y к Z, &lt;strong id=&quot;relative_product&quot;&gt;относительное произведение&lt;/strong&gt; R и S - это отношение T от X к Z, определенное таким образом, что x T z тогда и только тогда, когда существует элемент y в Y такое, что x R y и y S z.</target>
        </trans-unit>
        <trans-unit id="618098342145de14043b9d049d0e27a0dbe8a5ba" translate="yes" xml:space="preserve">
          <source>If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the &lt;strong id=&quot;strict_relation&quot;&gt;strict&lt;/strong&gt; relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the &lt;strong id=&quot;weak_relation&quot;&gt;weak&lt;/strong&gt; relation corresponding to S.</source>
          <target state="translated">Если R - отношение в X, и если S определено так, что x S y, если x R y, а не x = y, то S - &lt;strong id=&quot;strict_relation&quot;&gt;строгое&lt;/strong&gt; отношение, соответствующее R. Наоборот, если S - отношение в X, и если R определяется так, что x R y, если x S y или x = y, то R - &lt;strong id=&quot;weak_relation&quot;&gt;слабое&lt;/strong&gt; отношение, соответствующее S.</target>
        </trans-unit>
        <trans-unit id="6577b63edebfaf6cb114810862f5d1c1f7536b21" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, and x is an element of X, the &lt;strong id=&quot;equivalence_class&quot;&gt;equivalence class&lt;/strong&gt; of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C.</source>
          <target state="translated">Если R является отношением эквивалентности в X, а x является элементом X, &lt;strong id=&quot;equivalence_class&quot;&gt;класс эквивалентности&lt;/strong&gt; x относительно R - это множество всех тех элементов y из X, для которых выполняется x R y. Классы эквивалентности составляют разбиение X. И наоборот, если C является разбиением X, отношение, которое выполняется для любых двух элементов X, если они принадлежат одному классу эквивалентности, является отношением эквивалентности, индуцированным разбиением C.</target>
        </trans-unit>
        <trans-unit id="83162ddd20e00fa4a162cbcf127d9c0721481053" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, the &lt;strong id=&quot;canonical_map&quot;&gt;canonical map&lt;/strong&gt; is the function that maps every element of X onto its equivalence class.</source>
          <target state="translated">Если R - отношение эквивалентности в X, &lt;strong id=&quot;canonical_map&quot;&gt;каноническое отображение&lt;/strong&gt; - это функция, которая отображает каждый элемент X в его класс эквивалентности.</target>
        </trans-unit>
        <trans-unit id="2e3f4abb96f981c697c50aab79cfafffa5fa7e98" translate="yes" xml:space="preserve">
          <source>If S is a restriction of R to A, then R is an &lt;strong id=&quot;extension&quot;&gt;extension&lt;/strong&gt; of S to X.</source>
          <target state="translated">Если S является ограничением R на A, то R является &lt;strong id=&quot;extension&quot;&gt;расширением&lt;/strong&gt; S на X.</target>
        </trans-unit>
        <trans-unit id="59bb1dc7653278e89c3f5020133ebdcc7761c491" translate="yes" xml:space="preserve">
          <source>If S is an element (T, X) of Sets, then T is a &lt;strong id=&quot;valid_type&quot;&gt;valid type&lt;/strong&gt; of X, T is the type of S, and X is the external set of S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; creates a set from a type and an Erlang term turned into an external set.</source>
          <target state="translated">Если S является элементом (T, X) наборов, то T - &lt;strong id=&quot;valid_type&quot;&gt;допустимый тип&lt;/strong&gt; X, T - тип S, а X - внешний набор S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; создает набор из типа и Erlang. термин превратился во внешний набор.</target>
        </trans-unit>
        <trans-unit id="d08abf342530f661d47c0b2d46fbf1f0e30add56" translate="yes" xml:space="preserve">
          <source>If SASL is not included as an application in the &lt;code&gt;.rel&lt;/code&gt; file, a warning is issued because such a release cannot be used in an upgrade. To turn off this warning, add option &lt;code&gt;no_warn_sasl&lt;/code&gt;.</source>
          <target state="translated">Если SASL не включен как приложение в файл &lt;code&gt;.rel&lt;/code&gt; , выдается предупреждение, так как такой выпуск нельзя использовать при обновлении. Чтобы отключить это предупреждение, добавьте параметр &lt;code&gt;no_warn_sasl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d446165493e24efa50be7a65b22a36a79836aa6" translate="yes" xml:space="preserve">
          <source>If SNMPv3 is used, these MIBs are loaded by default.</source>
          <target state="translated">При использовании SNMPv3 данные MIB загружаются по умолчанию.</target>
        </trans-unit>
        <trans-unit id="99d068911d44f519900efdb97e0ebd14d390453e" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set.</source>
          <target state="translated">Если SetFun указан как fun,то fun применяется к каждому элементу данного набора,а возвращаемое значение принимается за набор.</target>
        </trans-unit>
        <trans-unit id="e3976f1f032e302393b8bb08320950e629b9d555" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a tuple &lt;code&gt;{external, Fun}&lt;/code&gt;, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements.</source>
          <target state="translated">Если SetFun задан как кортеж &lt;code&gt;{external, Fun}&lt;/code&gt; , Fun применяется к внешнему набору каждого элемента данного набора, и предполагается, что возвращаемое значение является внешним набором. Выбор элементов неупорядоченного набора в качестве внешних наборов и сборка нового неупорядоченного набора из списка внешних наборов в настоящей реализации более эффективны, чем изменение каждого элемента как набора. Однако эту оптимизацию можно использовать только в том случае, если элементы неупорядоченного набора являются атомарными или упорядоченными наборами. Также должно быть, что тип элементов соответствует некоторому предложению Fun (тип созданного набора является результатом применения Fun к типу данного набора), и что Fun ничего не делает, кроме выбора, дублирования или перестановка частей элементов.</target>
        </trans-unit>
        <trans-unit id="43c0a8b3ea81788001f690f7e87c84083499ae45" translate="yes" xml:space="preserve">
          <source>If T is &lt;code&gt;( T_0 )&lt;/code&gt;, then Rep(T) = &lt;code&gt;Rep(T_0)&lt;/code&gt;, that is, parenthesized types cannot be distinguished from their bodies.</source>
          <target state="translated">Если T равно &lt;code&gt;( T_0 )&lt;/code&gt; , то Rep (T) = &lt;code&gt;Rep(T_0)&lt;/code&gt; , то есть типы в скобках нельзя отличить от их тел.</target>
        </trans-unit>
        <trans-unit id="3fe813c684b65a78f678a4bec68aa5f263202a79" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,ANNO,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d59bcb751b787399eaa6216688da1c771a3508" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">Если T является типом битовой строки &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; , где &lt;code&gt;M&lt;/code&gt; и &lt;code&gt;N&lt;/code&gt; являются одноэлементными целочисленными типами, тогда Rep (T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f85dadf01e8f30907411f8ced0faf82947f6804" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb0862754ffb06068ede8dc817a72eb1519add3" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Если T - развлечение типа &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; , то Rep (T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a390f10fcd8d8a36def467725d4dda00982dd986" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,'fun',[]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9d5b99a9c22d7dc1e1078c45173c119d328720" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">Если T - забавный тип &lt;code&gt;fun()&lt;/code&gt; , то Rep (T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7630c752d5e9079868a01fb10ba5440be40003" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun(Ft)&lt;/code&gt;, where &lt;code&gt;Ft&lt;/code&gt; is a function type, then Rep(T) = &lt;code&gt;Rep(Ft)&lt;/code&gt;. For Rep(Ft), see below.</source>
          <target state="translated">Если T - тип &lt;code&gt;fun(Ft)&lt;/code&gt; , где &lt;code&gt;Ft&lt;/code&gt; - тип функции, то Rep (T) = &lt;code&gt;Rep(Ft)&lt;/code&gt; . Относительно Rep (Ft) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="1adf89e8e92228a60dd07895fb1499d746d2f997" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,ANNO,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a030c9807953845560f8db0809d5cae00b3b69" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Если T является типом карты &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , где каждый &lt;code&gt;A_i&lt;/code&gt; является типом ассоциации, то Rep (T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Относительно Rep (A) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="a3d2ad35675d5afe54ca0bd9c3179fed7255c00e" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,map,any}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b831583f902b7b1e825485ae91283de7c5ae12d8" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt;.</source>
          <target state="translated">Если T является типом &lt;code&gt;map()&lt;/code&gt; , то Rep (T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="393b51301cf31a12b2c86b8f1d9bbdef7251ed54" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65f43c9b04c981a0f08dbd4e0efeaf97f33b27e" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если T является предопределенным (или встроенным) типом &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; , то Rep (T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca56d7b0dd371abffc166a298e3aa5c771e44b2d" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,ANNO,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81796f903baaa46af3b80b5d8688ebe92b7c0403" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="translated">Если T является типом записи &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt; , где каждый &lt;code&gt;F_i&lt;/code&gt; является типом поля записи, тогда Rep (T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt; . Относительно Rep (F) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="3222c4ffd098914385913646a36a5eb933808ff6" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,ANNO,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8d572503b5c61f934efe1a703bfabdb6fef560" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="translated">Если T - удаленный тип &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt; , то Rep (T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8647f8866bf0895e0a5b40a325be9d138c2a1081" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,tuple,any}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b1161c8a498bf9c973de5bfb81d671743d9c3d" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt;.</source>
          <target state="translated">Если T является кортежным типом &lt;code&gt;tuple()&lt;/code&gt; , то Rep (T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="207c50704c87beebe7a6e20ca5b5d3c04f6d1d99" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e4f6cf136dfa1b7d4b66063686fadb91908818" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если T является кортежным типом &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt; , то Rep (T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a938cb6958277c0935e0d57bb6651a672684a8d4" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f7c924bddde4fb82ebc04d0dc2ef68e7d3ec80" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если T является объединением типов &lt;code&gt;T_1 | ... | T_k&lt;/code&gt; , затем Rep (T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da23467e91ab40f667601ddef52da4d45d5feefe" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b9ae17be7ca13037caad5b425aea5153523426" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">Если T является типом переменной &lt;code&gt;V&lt;/code&gt; , то Группа (Т) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , где представляет собой атом с printname , состоящей из одних и тех же символов , как &lt;code&gt;V&lt;/code&gt; . Переменная типа - это любая переменная, кроме символа подчеркивания ( &lt;code&gt;_&lt;/code&gt; ). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9009a6974b8dc4d03f245e007c8f49b5b6d34b52" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ece75db2c93e58198cc536b47ac3b68361a0ca" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если T является определяемым пользователем типом &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; , то Rep (T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f07bf781162482afd2013d4024c6c725654680a1" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,ANNO,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308a5eeab7204b0380423b04a4f96b78a2bb9a71" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Если T - аннотированный тип &lt;code&gt;A :: T_0&lt;/code&gt; , где &lt;code&gt;A&lt;/code&gt; - переменная, то Rep (T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a9ca5d4370f68ffd4aacee2420b758f185ae7c5" translate="yes" xml:space="preserve">
          <source>If T is an atom or integer literal L, then Rep(T) = Rep(L).</source>
          <target state="translated">Если T-атомный или целочисленный буквенный L,то Rep(T)=Rep(L).</target>
        </trans-unit>
        <trans-unit id="88da671c68682a76fd63acbbd82cd33cfc329377" translate="yes" xml:space="preserve">
          <source>If T is an atom, a character, or an integer literal L, then Rep(T) = Rep(L).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0240293ad37bae225227647e0e3b7e2bac07ec" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,ANNO,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad797cc1858fce32e5e441213921861198714eb2" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="translated">Если T - это целочисленный тип диапазона &lt;code&gt;L .. H&lt;/code&gt; , где &lt;code&gt;L&lt;/code&gt; и &lt;code&gt;H&lt;/code&gt; - одноэлементные целочисленные типы, тогда Rep (T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc03bf3c127d2db614b6ef5e1997a93c0412bfa2" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,ANNO,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb40c0e15c57779039c33cac1f747c5810dbf6ac" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="translated">Если T - тип оператора &lt;code&gt;Op T_0&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; - унарный оператор (это вхождение выражения, которое может быть оценено в целое число во время компиляции), то Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ccf953cec087c4f37edbb5474ed7922f3550a3" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,ANNO,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8ff3216bb70a3e5574e4f729d37b4404373ced" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="translated">Если T - тип оператора &lt;code&gt;T_1 Op T_2&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; - бинарный оператор (это вхождение выражения, которое может быть оценено в целое число во время компиляции), то Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0cf8513a746893009eda27d45a4780f2cc888dc" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,nil,[]}&lt;/code&gt;, that is, the empty list type &lt;code&gt;[]&lt;/code&gt; cannot be distinguished from the predefined type &lt;code&gt;nil()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ad15b3d0471bd3faa5be48d2ae0de7d86566a4" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt;.</source>
          <target state="translated">Если T - это пустой список типа &lt;code&gt;[]&lt;/code&gt; , то Rep (T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fd606c5ec8d6d6bb3851df48abcb81b06d7a38" translate="yes" xml:space="preserve">
          <source>If TLS is requested (&lt;code&gt;Bool=true&lt;/code&gt;) then a connecting process should initiate a TLS handshake with the peer and an accepting process should prepare to accept a handshake. A successful handshake should be followed by a &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; message to the parent process. A failed handshake should cause the process to exit.</source>
          <target state="translated">Если запрашивается TLS ( &lt;code&gt;Bool=true&lt;/code&gt; ), то процесс подключения должен инициировать рукопожатие TLS с одноранговым узлом, а принимающий процесс должен подготовиться к принятию рукопожатия. За успешным рукопожатием должно следовать сообщение &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; родительскому процессу. Неудачное рукопожатие должно привести к завершению процесса.</target>
        </trans-unit>
        <trans-unit id="fdc7d15812f21bafb9f2d4f973c0a1f450ecf989" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A:Value&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom and &lt;code&gt;Value&lt;/code&gt; is an integer, then Rep(TS) = &lt;code&gt;{A,Value}&lt;/code&gt;.</source>
          <target state="translated">Если TS - спецификатор типа &lt;code&gt;A:Value&lt;/code&gt; , где &lt;code&gt;A&lt;/code&gt; - атом, а &lt;code&gt;Value&lt;/code&gt; - целое число, тогда Rep (TS) = &lt;code&gt;{A,Value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e7b2ba399cca51e247046ccdbff7d00ba5b8ab" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(TS) = &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Если TS является спецификатор типа , где представляет собой атом, то Группа (TS) = . &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cffa66b34c2d2e22ea4103aaa24ab719e89c2fec" translate="yes" xml:space="preserve">
          <source>If Trace Tool Builder is to be used against a remote node, it is highly recommended to start the trace control node as &lt;strong&gt;hidden&lt;/strong&gt;. This way it can connect to the traced node without being &quot;seen&quot; by it, that is, if the &lt;code&gt;nodes()&lt;/code&gt; BIF is called on the traced node, the trace control node does not show. To start a hidden node, add option &lt;code&gt;-hidden&lt;/code&gt; to the &lt;code&gt;erl&lt;/code&gt; command, for example:</source>
          <target state="translated">Если Trace Tool Builder будет использоваться против удаленного узла, настоятельно рекомендуется запускать узел управления трассировкой как &lt;strong&gt;скрытый&lt;/strong&gt; . Таким образом, он может подключиться к отслеживаемому узлу, не будучи &amp;laquo;видимым&amp;raquo; для него, то есть, если на отслеживаемом узле вызывается BIF &lt;code&gt;nodes()&lt;/code&gt; узел управления трассировкой не отображается. Чтобы запустить скрытый узел, добавьте в команду &lt;code&gt;erl&lt;/code&gt; опцию &lt;code&gt;-hidden&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="f981e82f10b1b120a81d1801123ff119c9dd5647" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57716f17031652959455a3f19555742110bf4198" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc97ec63a0f0a73856ddcd04133122fc9570583f" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab68d3d8a84e8ac67ee4631fedf30ccfba50dcc" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">Если действует кодировка имени файла Unicode (см. &lt;code&gt;erlmanual page&lt;/code&gt; ), строка &lt;code&gt;VarName&lt;/code&gt; может содержать символы с кодовыми точками &amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="349a1b5c23c6400e11f34baaeede22206381d4e8" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">Если действует кодировка имени файла Unicode (см. &lt;code&gt;erlmanual page&lt;/code&gt; ), строки &lt;code&gt;VarName&lt;/code&gt; и &lt;code&gt;Value&lt;/code&gt; могут содержать символы с кодовыми точками &amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="8063f0dff7c5946dc972277dda605fd528422b32" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">Если действует кодировка имени файла Unicode (см. &lt;code&gt;erlmanual page&lt;/code&gt; ), строки могут содержать символы с кодовыми точками &amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="50def98f37f2942e5e50a32fd6672fe00221e237" translate="yes" xml:space="preserve">
          <source>If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the &lt;code&gt;fun()&lt;/code&gt; must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &amp;gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8).</source>
          <target state="translated">Если действует перевод имен файлов Unicode и файловая система прозрачна, могут встречаться имена файлов, которые нельзя интерпретировать как Unicode, и в этом случае &lt;code&gt;fun()&lt;/code&gt; должен быть подготовлен для обработки необработанных имен файлов (то есть двоичных файлов). Если регулярное выражение содержит кодовых точек&amp;gt; 255, оно не соответствует именам файлов, которые не соответствуют ожидаемой кодировке символов (то есть не закодированы в допустимом UTF-8).</target>
        </trans-unit>
        <trans-unit id="27d8be04dca27e76e1518b6381c78e6ba0f1228a" translate="yes" xml:space="preserve">
          <source>If Unicode filenames are enabled, the calls to &lt;code&gt;os:getenv/0,1&lt;/code&gt;, &lt;code&gt;os:putenv/2&lt;/code&gt;, and &lt;code&gt;os:unsetenv/1&lt;/code&gt; handle Unicode strings. On Unix-like platforms, the built-in functions translate environment variables in UTF-8 to/from Unicode strings, possibly with code points &amp;gt; 255. On Windows, the Unicode versions of the environment system API are used, and code points &amp;gt; 255 are allowed.</source>
          <target state="translated">Если имена файлов Unicode включены, вызовы &lt;code&gt;os:getenv/0,1&lt;/code&gt; , &lt;code&gt;os:putenv/2&lt;/code&gt; и &lt;code&gt;os:unsetenv/1&lt;/code&gt; обрабатывают строки Unicode. На Unix-подобных платформах встроенные функции переводят переменные среды в UTF-8 в / из строк Unicode, возможно, с кодовыми точками&amp;gt; 255. В Windows используются версии Unicode системного API среды и кодовые точки&amp;gt; 255 разрешается.</target>
        </trans-unit>
        <trans-unit id="7fd5167b3902c5e1022270db7b7037a7e5ba7572" translate="yes" xml:space="preserve">
          <source>If Unicode translation is in effect (&lt;code&gt;~ts&lt;/code&gt;), characters &amp;gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &amp;gt; 255:</source>
          <target state="translated">Если действует перевод Unicode ( &lt;code&gt;~ts&lt;/code&gt; ), символы&amp;gt; 255 принимаются, в противном случае - нет. С модификатором перевода возвращаемый список может, как следствие, также содержать целые числа&amp;gt; 255:</target>
        </trans-unit>
        <trans-unit id="3e9eb4fb01bd12ad300a0a96c219b150663189ba" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8109397071948c43826e0713ed25b859b8a44c79" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">Если V - это &lt;code&gt;A :: T&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тип, то Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb6fe32cd5968d212727cb82bd15e47cc5d23b10" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f32a52c794ffe7684b6b2810c41e4682238d59" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">Если V равно &lt;code&gt;A = E :: T&lt;/code&gt; , где &lt;code&gt;E&lt;/code&gt; - выражение, а &lt;code&gt;T&lt;/code&gt; - тип, тогда Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc17addad3b18cec2f98a0aa96fe46ca497758bf" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,ANNO,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f396f938bddcba478f3de3dee1d32cdd215e7c9" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Если V равно &lt;code&gt;A = E&lt;/code&gt; , где &lt;code&gt;E&lt;/code&gt; - выражение, тогда Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="530b26a08f1369a0dde3ebbcc4e657abbc43c708" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,ANNO,Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46feb36a0599dccd153195f0bebe327e41e1d422" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Если V равно &lt;code&gt;A&lt;/code&gt; , то Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be88adeac37e6ad073f87c039fc9ee408a3d9604" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, &lt;code&gt;string()&lt;/code&gt; and &lt;code&gt;char()&lt;/code&gt; are allowed to be &amp;gt; 255. See also the documentation of the &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Если виртуальная машина находится в режиме имени файла Unicode, &lt;code&gt;string()&lt;/code&gt; и &lt;code&gt;char()&lt;/code&gt; могут иметь значение&amp;gt; 255. См. Также документацию по &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf04572355facf77510f6eb707d8bddd39905f32" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, characters are allowed to be &amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; is a filename not subject to Unicode translation, meaning that it can contain characters not conforming to the Unicode encoding expected from the file system (that is, non-UTF-8 characters although the VM is started in Unicode filename mode). Null characters (integer value zero) are &lt;strong&gt;not&lt;/strong&gt; allowed in filenames (not even at the end).</source>
          <target state="translated">Если виртуальная машина находится в режиме имени файла Unicode, символы могут быть&amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; - это имя файла, которое не подлежит преобразованию Unicode, что означает, что оно может содержать символы, не соответствующие кодировке Unicode, ожидаемой от файловой системы (то есть не-UTF -8 символов, хотя виртуальная машина запускается в режиме имени файла Unicode). Нулевые символы (целочисленное значение ноль) &lt;strong&gt;не&lt;/strong&gt; допускаются в именах файлов (даже в конце).</target>
        </trans-unit>
        <trans-unit id="c6fa19e3c49a3ba084dbfa57062e1a1ae9c3810d" translate="yes" xml:space="preserve">
          <source>If X = Y, then R is called a relation &lt;strong&gt;in&lt;/strong&gt; X.</source>
          <target state="translated">Если X = Y, то R называется отношением &lt;strong&gt;в&lt;/strong&gt; X.</target>
        </trans-unit>
        <trans-unit id="00c65a44486df5482c6dc2dd5875d8d6aaf46534" translate="yes" xml:space="preserve">
          <source>If a &quot;traditional&quot; transport is specified (without explicit &lt;code&gt;Kind&lt;/code&gt;, handling both requests and traps) for a transport domain, its &lt;strong&gt;not&lt;/strong&gt; possible to also specify a transport (for that domain) with a specific &lt;code&gt;Kind&lt;/code&gt;. This is for example &lt;strong&gt;not&lt;/strong&gt; allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5da42cb98de8f66497fcf02d854f52ee32aab90" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; of length two or more exists through vertex &lt;code&gt;V&lt;/code&gt;, the cycle is returned as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices. If a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; exists, the loop is returned as a list &lt;code&gt;[V]&lt;/code&gt;. If no cycles through &lt;code&gt;V&lt;/code&gt; exist, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; длины два или более существует через вершину &lt;code&gt;V&lt;/code&gt; , цикл возвращается как список &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; вершин. Если &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; через &lt;code&gt;V&lt;/code&gt; существует, цикл возвращается в виде списка &lt;code&gt;[V]&lt;/code&gt; . Если циклов через &lt;code&gt;V&lt;/code&gt; не существует, возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4c540f1bcb01b8107384c4ecb40a93c9ff68733" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Dir&lt;/code&gt; already exists in the code path, it is removed from the old position.</source>
          <target state="translated">Если &lt;code&gt;Dir&lt;/code&gt; уже существует в пути кода, он удаляется из старой позиции.</target>
        </trans-unit>
        <trans-unit id="74a148d16947689b4aa97fa5371e271e751763f1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function crashes or throws an exception, the original state of the process is unchanged for &lt;code&gt;gen_server&lt;/code&gt;, and &lt;code&gt;gen_statem&lt;/code&gt; processes. For &lt;code&gt;gen_event&lt;/code&gt; processes, a crashing or failing &lt;code&gt;StateFun&lt;/code&gt; function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same &lt;code&gt;gen_event&lt;/code&gt; process.</source>
          <target state="translated">Если &lt;code&gt;StateFun&lt;/code&gt; функция сбой или генерирует исключение, первоначальное состояние процесса является неизменным в течение &lt;code&gt;gen_server&lt;/code&gt; и &lt;code&gt;gen_statem&lt;/code&gt; процессов. Для процессов &lt;code&gt;gen_event&lt;/code&gt; сбой или сбой функции &lt;code&gt;StateFun&lt;/code&gt; означает, что неизменным остается только состояние конкретного обработчика событий, с которым он работал в момент сбоя или сбоя ; он все еще может успешно изменять состояния других обработчиков событий, зарегистрированных в том же процессе &lt;code&gt;gen_event&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f16194ae42169305df9c2ac40e5f3bc5d8ab5294" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function decides not to effect any change in process state, then regardless of process type, it can return its &lt;code&gt;State&lt;/code&gt; argument.</source>
          <target state="translated">Если функция &lt;code&gt;StateFun&lt;/code&gt; решает не производить никаких изменений в состоянии процесса, то независимо от типа процесса она может вернуть свой аргумент &lt;code&gt;State&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3a01e0c748edc694108fe2d71299f36d697f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is specified, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a0319e49e50710f02ee82c0914b94ac22dbba1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is speciifed, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;Tag&lt;/code&gt; является speciifed, возвращаемый &lt;code&gt;Match&lt;/code&gt; также включает совпадающую &lt;code&gt;Tag&lt;/code&gt; . В противном случае возвращается только &lt;code&gt;RxMatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a7555617310e8eeba0e7553e2392a16068784c6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Threshold&lt;/code&gt; is specified, the counter is reset to value &lt;code&gt;SetValue&lt;/code&gt; if the following conditions occur:</source>
          <target state="translated">Если задан &lt;code&gt;Threshold&lt;/code&gt; , счетчик сбрасывается до значения &lt;code&gt;SetValue&lt;/code&gt; , если возникают следующие условия:</target>
        </trans-unit>
        <trans-unit id="a5a595a63e0041392424b473cbdb427fc8601eee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pid()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt;, &lt;code&gt;{in, Location}&lt;/code&gt;, and &lt;code&gt;{out, Location}&lt;/code&gt; are present, where &lt;code&gt;Location&lt;/code&gt; is either an MFA (&lt;code&gt;{Module, Function, Arity}&lt;/code&gt;) describing the function where the process was scheduled in/out, or the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;pid()&lt;/code&gt; , присутствуют кортежи &lt;code&gt;{timeout, Millis}&lt;/code&gt; , &lt;code&gt;{in, Location}&lt;/code&gt; и &lt;code&gt;{out, Location}&lt;/code&gt; , где &lt;code&gt;Location&lt;/code&gt; - это либо MFA ( &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; ), описывающий функцию, в которой процесс был запланирован вход / выход, или атом &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68177e2c897ada3a2210fd2fd1b8bee05a073d3a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;port()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt; and &lt;code&gt;{port_op,Op}&lt;/code&gt; are present. &lt;code&gt;Op&lt;/code&gt; is one of &lt;code&gt;proc_sig&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;event&lt;/code&gt;, or &lt;code&gt;dist_cmd&lt;/code&gt;, depending on which driver callback was executing.</source>
          <target state="translated">Если &lt;code&gt;port()&lt;/code&gt; , присутствуют кортежи &lt;code&gt;{timeout, Millis}&lt;/code&gt; и &lt;code&gt;{port_op,Op}&lt;/code&gt; . &lt;code&gt;Op&lt;/code&gt; может быть одним из &lt;code&gt;proc_sig&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;output&lt;/code&gt; , &lt;code&gt;event&lt;/code&gt; или &lt;code&gt;dist_cmd&lt;/code&gt; , в зависимости от того, какой драйвер выполнял обратный вызов.</target>
        </trans-unit>
        <trans-unit id="793f68726c5cebcf04eed2e69bb996595dba56b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;property_parm()&lt;/code&gt; is found as part of the input (&lt;code&gt;SDP&lt;/code&gt;) then it is left unchanged.</source>
          <target state="translated">Если &lt;code&gt;property_parm()&lt;/code&gt; обнаруживается как часть ввода ( &lt;code&gt;SDP&lt;/code&gt; ), то он остается неизменным.</target>
        </trans-unit>
        <trans-unit id="85b487c95345f7250096baeb7f6ceb5385465d9a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pwdfun&lt;/code&gt; is defined, that one is called and the returned boolean is the authentication result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a1cdf79545c23e02941821b867906efcc046dd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;relup&lt;/code&gt; file and/or a system configuration file called &lt;code&gt;sys.config&lt;/code&gt;, or a &lt;code&gt;sys.config.src&lt;/code&gt;, is found, these files are also included in the release package. See &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;relup&lt;/code&gt; файл повторной установки и / или файл конфигурации системы с именем &lt;code&gt;sys.config&lt;/code&gt; или &lt;code&gt;sys.config.src&lt;/code&gt; , эти файлы также включаются в пакет выпуска. См. &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90bab5222409642ed3e9b025afcf25e28ff5080e" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; and no message is placed in the buffer. Also, &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EAGAIN&lt;/code&gt;.</source>
          <target state="translated">Если появляется &lt;strong&gt;галочка&lt;/strong&gt; , то есть узел Erlang на другом конце соединения опрашивает этот узел, чтобы узнать, жив ли он, функция возвращает &lt;code&gt;ERL_TICK&lt;/code&gt; , и в буфер не помещается сообщение. Кроме того, для &lt;code&gt;erl_errno&lt;/code&gt; установлено значение &lt;code&gt;EAGAIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a48a4a5f7af813214b4a1f7a53e0d6d083deb2" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; indicating that the tick has been received and responded to, but no message is placed in the buffer. In this case you are to call &lt;code&gt;erl_receive_msg()&lt;/code&gt; again.</source>
          <target state="translated">Если происходит &lt;strong&gt;галочка&lt;/strong&gt; , то есть узел Erlang на другом конце соединения опрашивает этот узел, чтобы убедиться, что он еще жив, функция возвращает &lt;code&gt;ERL_TICK&lt;/code&gt; , указывающее, что галочка была получена и на нее был дан ответ, но сообщение не помещается в буфере. В этом случае вы должны снова вызвать &lt;code&gt;erl_receive_msg()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="688f42cde6aa17e471ac615786a4c6b4015e0179" translate="yes" xml:space="preserve">
          <source>If a URI component has a character that is not allowed, it will be percent-encoded when the URI is produced:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4364cbd8c0d3d620c728241f3c91ca9a0df5663" translate="yes" xml:space="preserve">
          <source>If a binary is sent as a message to a process or port, the binary will be shrunk and any further append operation will copy the binary data into a new binary. For example, in the following code fragment &lt;code&gt;Bin1&lt;/code&gt; will be copied in the third line:</source>
          <target state="translated">Если двоичный файл отправляется как сообщение процессу или порту, двоичный файл будет сжат, и любая дальнейшая операция добавления скопирует двоичные данные в новый двоичный файл. Например, в следующем фрагменте кода &lt;code&gt;Bin1&lt;/code&gt; будет скопирован в третью строку:</target>
        </trans-unit>
        <trans-unit id="5090ad34e0febaa291c69020c02b54e9b3cafd88" translate="yes" xml:space="preserve">
          <source>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt;. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</source>
          <target state="translated">Если двоичный файл ссылается на более крупный двоичный файл (часто описываемый как вспомогательный), может быть полезно получить размер указанного двоичного файла. Эту функцию можно использовать в программе для запуска использования &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; . Копируя двоичный файл, можно разыменовать исходный, возможно, большой двоичный файл, на который ссылается меньший двоичный файл.</target>
        </trans-unit>
        <trans-unit id="bcde4e46ca8a493fcb199170b76f962a5fc5534f" translate="yes" xml:space="preserve">
          <source>If a call is added to this function, say in module &lt;code&gt;m1&lt;/code&gt;, a runtime error could can occur during release upgrade if the new version of &lt;code&gt;m1&lt;/code&gt; is loaded first and calls &lt;code&gt;ch3:available/0&lt;/code&gt; before the new version of &lt;code&gt;ch3&lt;/code&gt; is loaded.</source>
          <target state="translated">Если к этой функции добавлен вызов, например, в модуле &lt;code&gt;m1&lt;/code&gt; , во время обновления выпуска может произойти ошибка выполнения, если сначала загружается новая версия &lt;code&gt;m1&lt;/code&gt; и вызывается &lt;code&gt;ch3:available/0&lt;/code&gt; до загрузки новой версии &lt;code&gt;ch3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d672e9be794bb20d13fca259b638d9872ca48c52" translate="yes" xml:space="preserve">
          <source>If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</source>
          <target state="translated">Если обратный вызов (выполнение доступа к файлам на TFTP-сервере)занимает слишком много времени (более чем двойной тайм-аут TFTP),сервер прерывает соединение и посылает клиенту ответ об ошибке.Это означает,что сервер освобождает ресурсы,подключенные к соединению,быстрее,чем раньше.Сервер просто предполагает,что клиент сдался.</target>
        </trans-unit>
        <trans-unit id="b5299cdbeb0a91fc95e90dba08d8ca1a2663ba62" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_server&lt;/code&gt; process terminates.</source>
          <target state="translated">Если функция обратного вызова не работает или возвращает неверное значение, процесс &lt;code&gt;gen_server&lt;/code&gt; завершается.</target>
        </trans-unit>
        <trans-unit id="e4e015fa7495e24f93ba1b6d6271a425520bd035" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_statem&lt;/code&gt; terminates, unless otherwise stated. However, an exception of class &lt;code&gt;throw&lt;/code&gt; is not regarded as an error but as a valid return from all callback functions.</source>
          <target state="translated">Если функция обратного вызова не работает или возвращает &lt;code&gt;gen_statem&lt;/code&gt; значение, gen_statem завершается, если не указано иное. Однако исключение &lt;code&gt;throw&lt;/code&gt; класса не рассматривается как ошибка, а как допустимый возврат из всех функций обратного вызова.</target>
        </trans-unit>
        <trans-unit id="cb6c6d4e44bcb4f44a78613ffcfcc49d8fc1ed0e" translate="yes" xml:space="preserve">
          <source>If a carrier employed by a foreign allocator becomes empty, it will be passed back to the owner for deallocation using the delayed dealloc functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4900c7b9d94d3b64a0cfc23cc79861beaa9067fc" translate="yes" xml:space="preserve">
          <source>If a carrier in the pool becomes empty, it will be withdrawn from the pool and be deallocated by the owner which already employs it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2220ee07a02652209f14bbc36c9099d4b6fe0ac" translate="yes" xml:space="preserve">
          <source>If a child process terminates, all other child processes are terminated, and then all child processes, including the terminated one, are restarted.</source>
          <target state="translated">Если дочерний процесс завершается,то все остальные дочерние процессы завершаются,а затем все дочерние процессы,включая завершенный,перезапускаются.</target>
        </trans-unit>
        <trans-unit id="c9c437f353a175442240ea2029595a8633f65dff" translate="yes" xml:space="preserve">
          <source>If a child process terminates, only that process is restarted.</source>
          <target state="translated">Если дочерний процесс завершается,перезапускается только этот процесс.</target>
        </trans-unit>
        <trans-unit id="7507b23dc1b78f0736fa82a074e0d7da39372d83" translate="yes" xml:space="preserve">
          <source>If a child process terminates, the rest of the child processes (that is, the child processes after the terminated process in start order) are terminated. Then the terminated child process and the rest of the child processes are restarted.</source>
          <target state="translated">Если дочерний процесс завершается,то остальные дочерние процессы (т.е.дочерние процессы после завершения процесса в порядке старта)завершаются.Затем завершенные дочерние процессы и остальные дочерние процессы перезапускаются.</target>
        </trans-unit>
        <trans-unit id="d930d204b5a28f5ad0b963925f58f75368275cfb" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to a TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0124339350cc4e352e860e84fd95007fc0287" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="translated">Если клиент и сервер хотят использовать механизм обновления,такой как определено в RFC 2817,для обновления обычного TCP/IP соединения до TLS соединения,это поддерживается API приложения Erlang SSL.Это может быть полезно,например,для поддержки HTTP и HTTPS на одном порту и реализации виртуального хостинга.Обратите внимание,что это только функция TLS.</target>
        </trans-unit>
        <trans-unit id="6fb7903555258379fa86ef3cac0cdacd6a86b7aa" translate="yes" xml:space="preserve">
          <source>If a client is started (ssh:connect et al), the environment variable &lt;code&gt;client_options&lt;/code&gt; is used. Similarly for a daemon the &lt;code&gt;server_options&lt;/code&gt; variable is handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf674d6f811a6898fedc16a08be96658f66f44f" translate="yes" xml:space="preserve">
          <source>If a client sends more than one of the header fields that restricts the servers right to respond, the standard does not specify how this is to be handled. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; controls each field in the following order and if one of the fields does not match the current state, the request is rejected with a proper response:</source>
          <target state="translated">Если клиент отправляет более одного поля заголовка, которое ограничивает право серверов на ответ, стандарт не определяет, как это следует обрабатывать. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; управляет каждым полем в следующем порядке, и если одно из полей не соответствует текущему состоянию, запрос отклоняется с правильным ответом:</target>
        </trans-unit>
        <trans-unit id="e27ccd3f361e3a3fbab2cff1701eede9199b66b3" translate="yes" xml:space="preserve">
          <source>If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module &lt;code&gt;user_default&lt;/code&gt;, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module &lt;code&gt;shell_default&lt;/code&gt;. Module &lt;code&gt;user_default&lt;/code&gt; must be explicitly loaded.</source>
          <target state="translated">Если команда (вызов локальной функции) не распознается оболочкой, сначала делается попытка найти функцию в модуле &lt;code&gt;user_default&lt;/code&gt; , где можно разместить настроенные локальные команды. Если найдена, функция оценивается, в противном случае делается попытка оценить функцию в модуле &lt;code&gt;shell_default&lt;/code&gt; . Модуль &lt;code&gt;user_default&lt;/code&gt; должен быть загружен явно.</target>
        </trans-unit>
        <trans-unit id="c36c504c5a55c7d3e1004baa209d8df31f96a326" translate="yes" xml:space="preserve">
          <source>If a comment selecting the &lt;code&gt;encoding&lt;/code&gt; exists, it can be located on the second line.</source>
          <target state="translated">Если комментарий с выбором &lt;code&gt;encoding&lt;/code&gt; существует, он может быть расположен во второй строке.</target>
        </trans-unit>
        <trans-unit id="81cca8ba4d8e6db9b3078f3494bdf4b64a21625a" translate="yes" xml:space="preserve">
          <source>If a complete system consists of disk-less and/or read-only client nodes, a &lt;code&gt;clients&lt;/code&gt; directory is to be added to the &lt;code&gt;$ROOT&lt;/code&gt; directory. A read-only node is a node with a read-only file system.</source>
          <target state="translated">Если вся система состоит из клиентских узлов без диска и / или только для чтения, каталог &lt;code&gt;clients&lt;/code&gt; должен быть добавлен в каталог &lt;code&gt;$ROOT&lt;/code&gt; . Узел только для чтения - это узел с файловой системой, доступной только для чтения.</target>
        </trans-unit>
        <trans-unit id="114507e06ec8251c1f8b58a05d6e95c9f0294db1" translate="yes" xml:space="preserve">
          <source>If a compressed stream with a larger window size is specified as input, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; throws the &lt;code&gt;data_error&lt;/code&gt; exception.</source>
          <target state="translated">Если сжатый поток с большим размером окна указан в качестве входных данных, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; вызывает исключение &lt;code&gt;data_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d1665dab7973da2ee300d7146a8bea80f54e0b" translate="yes" xml:space="preserve">
          <source>If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched.</source>
          <target state="translated">Если условный тест для подмаски,совпавшей с подмаскировкой,относится к неуникальному числу,то тест верен,если какая-либо из подмаскировок этого числа совпала.</target>
        </trans-unit>
        <trans-unit id="54dcbb12cbe33c06847716fee8fa5d710e5db085" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files and you want to access all possible values, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; and specify &lt;code&gt;all&lt;/code&gt; in the options list. The values are then returned in a list and the order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">Если переменная конфигурации определена в нескольких файлах и вы хотите получить доступ ко всем возможным значениям, используйте функцию &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; и укажите &lt;code&gt;all&lt;/code&gt; в списке параметров. Затем значения возвращаются в списке, а порядок элементов соответствует порядку, в котором файлы конфигурации были указаны при запуске.</target>
        </trans-unit>
        <trans-unit id="0feca975d542bb0cc969b217767e215cd1ff5ce8" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files, use option &lt;code&gt;all&lt;/code&gt; to access all possible values. The values are returned in a list. The order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">Если переменная конфигурации определена в нескольких файлах, используйте опцию &lt;code&gt;all&lt;/code&gt; для доступа ко всем возможным значениям. Значения возвращаются в виде списка. Порядок элементов соответствует порядку, в котором файлы конфигурации были указаны при запуске.</target>
        </trans-unit>
        <trans-unit id="1b9661fe7033eba3fb41e53ee1dcb7e1bb7fe5b9" translate="yes" xml:space="preserve">
          <source>If a configuration variable key has been associated with a name (by &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement), the name can be used instead of the key to read the value:</source>
          <target state="translated">Если ключ переменной конфигурации был связан с именем ( &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; или оператором &lt;code&gt;require&lt;/code&gt; ), имя можно использовать вместо ключа для чтения значения:</target>
        </trans-unit>
        <trans-unit id="9a3f8db667e8bd436b47dbf9ca11fe7bcf52f5e1" translate="yes" xml:space="preserve">
          <source>If a connection attempt fails, the following can be checked:</source>
          <target state="translated">При неудачной попытке подключения можно проверить следующее:</target>
        </trans-unit>
        <trans-unit id="64f616a997808c9474daa0409579dbb91fef959e" translate="yes" xml:space="preserve">
          <source>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all &lt;code&gt;load_object_code&lt;/code&gt; instructions.</source>
          <target state="translated">Если после этой инструкции произойдет сбой, система не сможет восстановиться и будет перезапущена из старой версии выпуска. Инструкция должна встречаться в скрипте только один раз. Он должен быть помещен после всех инструкций &lt;code&gt;load_object_code&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2df1e7bdcf4b38219e76db42a7407ed6f3a44c6" translate="yes" xml:space="preserve">
          <source>If a crash occurs, an &lt;code&gt;erl_crash.dump&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; written unless environment variable &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is set:</source>
          <target state="translated">Если происходит сбой, &lt;code&gt;erl_crash.dump&lt;/code&gt; это &lt;strong&gt;не&lt;/strong&gt; написано , если переменная окружения &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; не установлено:</target>
        </trans-unit>
        <trans-unit id="990352c71d728a05d2ecb284bad93c6958f6c7e3" translate="yes" xml:space="preserve">
          <source>If a custom CLI is installed (see the option &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt;) the rules above are replaced by thoose implied by the custom CLI.</source>
          <target state="translated">Если установлен пользовательский интерфейс командной строки (см. &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt; ), приведенные выше правила заменяются на правила, подразумеваемые пользовательским интерфейсом командной строки.</target>
        </trans-unit>
        <trans-unit id="a77a173e95ad2269f4f246fd4ce1b5864fc76ada" translate="yes" xml:space="preserve">
          <source>If a default object &lt;code&gt;Default&lt;/code&gt; is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them.</source>
          <target state="translated">Если указан объект по &lt;code&gt;Default&lt;/code&gt; , он используется в качестве объекта, который будет обновлен, если ключ отсутствует в таблице. Значение вместо ключа игнорируется и заменяется правильным значением ключа. Возвращаемое значение такое, как если бы объект по умолчанию не использовался, то есть один обновленный элемент или их список.</target>
        </trans-unit>
        <trans-unit id="fedf7b02f05498afd04860368d31fbddefe371d5" translate="yes" xml:space="preserve">
          <source>If a directory is limited both by authentication directives in the HTTP server configuration file and by the &lt;code&gt;htaccess&lt;/code&gt; files, the user must be allowed to get access to the file by both methods for the request to succeed.</source>
          <target state="translated">Если каталог ограничен как директивами аутентификации в файле конфигурации HTTP-сервера, так и файлами &lt;code&gt;htaccess&lt;/code&gt; , для успешного выполнения запроса пользователю необходимо разрешить доступ к файлу обоими методами.</target>
        </trans-unit>
        <trans-unit id="06b77a14a9631e3efe172824e4438ea9844c1c57" translate="yes" xml:space="preserve">
          <source>If a disaster occurs and the &lt;code&gt;Mnesia&lt;/code&gt; database is corrupted, it can be reconstructed from a backup. Regard this as a last resort, as the backup contains old data. The data is hopefully consistent, but data is definitely lost when an old backup is used to restore the database.</source>
          <target state="translated">В случае аварии и повреждения базы данных &lt;code&gt;Mnesia&lt;/code&gt; ее можно восстановить из резервной копии. Рассматривайте это как последнее средство, поскольку резервная копия содержит старые данные. Мы надеемся, что данные согласованы, но данные определенно теряются, когда для восстановления базы данных используется старая резервная копия.</target>
        </trans-unit>
        <trans-unit id="5f3cf29891ec99694dc2c7c6253ad367ac7a3461" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node is about to start, file &lt;code&gt;start_erl.data&lt;/code&gt; is located in the client directory at the master node. Thus, the &lt;code&gt;START_ERL_DATA&lt;/code&gt; line is to look like:</source>
          <target state="translated">Если бездисковый клиентский узел и / или клиентский узел только для чтения вот-вот запустится, файл &lt;code&gt;start_erl.data&lt;/code&gt; находится в клиентском каталоге на главном узле. Таким образом, строка &lt;code&gt;START_ERL_DATA&lt;/code&gt; должна выглядеть так:</target>
        </trans-unit>
        <trans-unit id="82a0e287fdd1e5f6d5eb37393a55caeaa8bd420e" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node with the SASL configuration parameter &lt;code&gt;static_emulator&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is about to start, the &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; flags must be changed.</source>
          <target state="translated">Если бездисковый и / или доступный только для чтения клиентский узел с параметром конфигурации SASL &lt;code&gt;static_emulator&lt;/code&gt; , установленным на &lt;code&gt;true&lt;/code&gt; , вот-вот запустится, необходимо &lt;code&gt;-boot&lt;/code&gt; флаги -boot и &lt;code&gt;-config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="727df7ab6749918e93887b82b12046b24dcb7655" translate="yes" xml:space="preserve">
          <source>If a driver is used in a functional way (that is, holds no state, but only does some heavy calculation and returns a result), several ports with registered names can be opened beforehand, and the port to be used can be chosen based on the scheduler ID as follows:</source>
          <target state="translated">Если драйвер используется функционально (т.е.не содержит состояния,а только делает некоторые тяжелые вычисления и возвращает результат),то заранее можно открыть несколько портов с зарегистрированными именами,а порт,который будет использоваться,можно выбрать на основе ID планировщика следующим образом:</target>
        </trans-unit>
        <trans-unit id="3f6d6f3cd21444705a34e8bba2dffb954001faed" translate="yes" xml:space="preserve">
          <source>If a feature has been added in R13A or later, this is mentioned in the text.</source>
          <target state="translated">Если функция была добавлена в R13A или более поздней версии,это упоминается в тексте.</target>
        </trans-unit>
        <trans-unit id="34f202d62579e4feee1dfdcda9ab5acaef776ff3" translate="yes" xml:space="preserve">
          <source>If a filename is specified as argument, Debugger tries to load its settings from this file. For details about settings, see the User's Guide.</source>
          <target state="translated">Если в качестве аргумента указано имя файла,то Debugger пытается загрузить его настройки из этого файла.Подробнее о настройках смотрите в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="ea25cbb8b26670068e8ad47b07d6ef15d55f99f4" translate="yes" xml:space="preserve">
          <source>If a filter or handler still crashes, Logger will remove the filter or handler in question from the configuration, and print a short error message to the terminal. A debug event containing the crash reason and other details is also issued.</source>
          <target state="translated">Если фильтр или обработчик все равно выйдет из строя,Логгер удалит соответствующий фильтр или обработчик из конфигурации и распечатает короткое сообщение об ошибке на терминал.Также выдается отладочное событие,содержащее причину сбоя и другие подробности.</target>
        </trans-unit>
        <trans-unit id="cceb2b6f7ec210d1178bfcad319491366c2280e9" translate="yes" xml:space="preserve">
          <source>If a fun is already registered when attempting to register a fun, &lt;code&gt;{error, exists}&lt;/code&gt; is returned.</source>
          <target state="translated">Если при попытке зарегистрировать развлечение уже зарегистрировано, возвращается &lt;code&gt;{error, exists}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="369b66436bacc61b5a02e5467b68ce2d193e98ed" translate="yes" xml:space="preserve">
          <source>If a function is specified as input and the last input function returns &lt;code&gt;{end_of_input, Value}&lt;/code&gt;, the function specified as output is called with argument &lt;code&gt;{value, Value}&lt;/code&gt;. This makes it easy to initiate the sequence of output functions with a value calculated by the input functions.</source>
          <target state="translated">Если функция указана как ввод и последняя функция ввода возвращает &lt;code&gt;{end_of_input, Value}&lt;/code&gt; , функция, указанная как вывод, вызывается с аргументом &lt;code&gt;{value, Value}&lt;/code&gt; . Это позволяет легко инициировать последовательность выходных функций со значением, вычисленным входными функциями.</target>
        </trans-unit>
        <trans-unit id="6ebc3e92f35620a8a503c6277f4b94fd5dcf6d25" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system results in the allocated size of a heap being at least &lt;code&gt;Size&lt;/code&gt; words, a message &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; and &lt;code&gt;Info&lt;/code&gt; are the same as for &lt;code&gt;long_gc&lt;/code&gt; earlier, except that the tuple tagged with &lt;code&gt;timeout&lt;/code&gt; is not present.</source>
          <target state="translated">Если сборка мусора в системе приводит к тому, что выделенный размер кучи составляет не менее слов &lt;code&gt;Size&lt;/code&gt; , сообщение &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; отправляется в &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;GcPid&lt;/code&gt; и &lt;code&gt;Info&lt;/code&gt; такие же, как и для &lt;code&gt;long_gc&lt;/code&gt; ранее, за исключением того, что отсутствует кортеж, помеченный &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fa572748a61109872681b645add693c92c91ac0" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system takes at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; is the pid that was garbage collected. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the result of the garbage collection.</source>
          <target state="translated">Если сборка мусора в системе занимает не менее миллисекунд &lt;code&gt;Time&lt;/code&gt; wall clock, сообщение &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; отправляется в &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;GcPid&lt;/code&gt; - это идентификатор pid, который был собран сборщиком мусора. &lt;code&gt;Info&lt;/code&gt; - это список двухэлементных кортежей, описывающих результат сборки мусора.</target>
        </trans-unit>
        <trans-unit id="9fc0db6a6ffa20f6ce91fac40d2bed50efc41760" translate="yes" xml:space="preserve">
          <source>If a given module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">Если данный модуль не скомпилирован Cover, на это указывает причина ошибки &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fd4da11cbcec24fe617e2cfb21bda9700c3ceef" translate="yes" xml:space="preserve">
          <source>If a group contains subgroups, the execution properties for these can also be specified in the group tuple: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; Where, &lt;code&gt;SubGroups&lt;/code&gt; is a list of tuples, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; or &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; representing the subgroups. Any subgroups defined in &lt;code&gt;group/0&lt;/code&gt; for a group, that are not specified in the &lt;code&gt;SubGroups&lt;/code&gt; list, executes with their predefined properties.</source>
          <target state="translated">Если группа содержит подгруппы, свойства выполнения для них также могут быть указаны в кортеже группы: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; Где, &lt;code&gt;SubGroups&lt;/code&gt; - это список кортежей, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; или &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; представляющие подгруппы. Любые подгруппы, определенные в &lt;code&gt;group/0&lt;/code&gt; для группы, которые не указаны в списке &lt;code&gt;SubGroups&lt;/code&gt; , выполняются с их предопределенными свойствами.</target>
        </trans-unit>
        <trans-unit id="2666a5da5f12edc23c65da1ead81b4fae39f0c6b" translate="yes" xml:space="preserve">
          <source>If a group has a parallel property, its test cases are spawned simultaneously and get executed in parallel. However, a test case is not allowed to execute in parallel with &lt;code&gt;end_per_group/2&lt;/code&gt;, which means that the time to execute a parallel group is equal to the execution time of the slowest test case in the group. A negative side effect of running test cases in parallel is that the HTML summary pages are not updated with links to the individual test case logs until function &lt;code&gt;end_per_group/2&lt;/code&gt; for the group has finished.</source>
          <target state="translated">Если у группы есть свойство parallel, ее тестовые примеры создаются одновременно и выполняются параллельно. Однако тестовый пример не может выполняться параллельно с &lt;code&gt;end_per_group/2&lt;/code&gt; , что означает, что время выполнения параллельной группы равно времени выполнения самого медленного тестового примера в группе. Отрицательный побочный эффект параллельного выполнения тестовых примеров заключается в том, что сводные HTML-страницы не обновляются ссылками на журналы отдельных тестовых примеров до &lt;code&gt;end_per_group/2&lt;/code&gt; функции end_per_group / 2 для группы.</target>
        </trans-unit>
        <trans-unit id="8bb7010fa14d24ee8209de3626a77d1e0f85e457" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, and the key is known by Logger, the default value is used. If it is a custom key, then it is up to the handler implementation if the value is removed or a default value is inserted.</source>
          <target state="translated">Если ключ удален по сравнению с текущей конфигурацией,а ключ известен Журнальщику,используется значение по умолчанию.Если это пользовательский ключ,то в случае,если значение удалено или вставлено значение по умолчанию,то это зависит от реализации обработчика.</target>
        </trans-unit>
        <trans-unit id="11708959f85882a0251af3731723c98e8ebf01ea" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, the default value is used.</source>
          <target state="translated">Если ключ удален по сравнению с текущей конфигурацией,используется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5dfcb13b302f0d14decac13131536de1d6f9c84b" translate="yes" xml:space="preserve">
          <source>If a list of &lt;code&gt;ModFiles&lt;/code&gt; is given as input, a list of &lt;code&gt;Result&lt;/code&gt; will be returned. The order of the returned list is undefined.</source>
          <target state="translated">Если в качестве входных данных &lt;code&gt;ModFiles&lt;/code&gt; список ModFiles, будет возвращен список &lt;code&gt;Result&lt;/code&gt; . Порядок возвращенного списка не определен.</target>
        </trans-unit>
        <trans-unit id="f8890c3d642a5caba2f616485052ab5bd181a9ec" translate="yes" xml:space="preserve">
          <source>If a list of identifiers is used in an &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Если список идентификаторов используется в &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="69f7917cc57f0edf963801bba057a225f78af5d2" translate="yes" xml:space="preserve">
          <source>If a local function has the same name as an auto-imported BIF, the semantics is that implicitly qualified function calls are directed to the locally defined function, not to the BIF. To avoid confusion, there is a compiler directive available, &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt;, that makes a BIF not being auto-imported. In certain situations, such a compile-directive is mandatory.</source>
          <target state="translated">Если локальная функция имеет то же имя, что и автоматически импортированный BIF, семантика такова, что неявно определенные вызовы функций направляются в локально определенную функцию, а не в BIF. Чтобы избежать путаницы, доступна директива компилятора &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt; , которая запрещает автоматический импорт BIF. В определенных ситуациях такая директива компиляции является обязательной.</target>
        </trans-unit>
        <trans-unit id="6f9bef85716e3a896ddd92ef48c5bf0c2c758aee" translate="yes" xml:space="preserve">
          <source>If a log event passes through all primary filters and all handler filters for a specific handler, Logger forwards the event to the &lt;strong&gt;handler callback&lt;/strong&gt;. The handler formats and prints the event to its destination. See section &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">Если событие журнала проходит через все основные фильтры и все фильтры обработчика для определенного обработчика, Logger перенаправляет событие в &lt;strong&gt;обратный вызов обработчика&lt;/strong&gt; . Обработчик форматирует и выводит событие по назначению. Смотрите раздел &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="e96f947dd13a984704288142af512a8f72e3acc3" translate="yes" xml:space="preserve">
          <source>If a log is configured to be distributed, it is possible that all items are not logged on all nodes. &lt;code&gt;wrap_log_reader&lt;/code&gt; only reads the log on the called node; it is up to the user to be sure that all items are read.</source>
          <target state="translated">Если журнал настроен на распространение, возможно, что не все элементы регистрируются на всех узлах. &lt;code&gt;wrap_log_reader&lt;/code&gt; читает журнал только на вызываемом узле; Пользователь должен убедиться, что все элементы прочитаны.</target>
        </trans-unit>
        <trans-unit id="5666e4e832cec3f259cd26eabc4f7091a56c83aa" translate="yes" xml:space="preserve">
          <source>If a log with a specified name is local on some node, and one tries to open the log distributed on the same node, the tuple &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; is returned. The same tuple is returned if the log is distributed on some node, and one tries to open the log locally on the same node. Opening individual distributed disk logs for the first time adds those logs to a (possibly empty) distributed disk log. The supplied option values are used on all nodes mentioned by option &lt;code&gt;distributed&lt;/code&gt;. Individual distributed logs know nothing about each other's option values, so each node can be given unique option values by creating a distributed log with many calls to &lt;code&gt;open/1&lt;/code&gt;.</source>
          <target state="translated">Если журнал с указанным именем является локальным на каком-то узле, и кто-то пытается открыть журнал, распределенный на том же узле, возвращается кортеж &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; . Тот же кортеж возвращается, если журнал распределен на каком-то узле, и кто-то пытается открыть журнал локально на том же узле. Открытие отдельных журналов распределенного диска в первый раз добавляет эти журналы в (возможно, пустой) журнал распределенного диска. Предоставленные значения опций используются на всех узлах, упомянутых опцией &lt;code&gt;distributed&lt;/code&gt; . Отдельные распределенные журналы ничего не знают о значениях параметров друг друга, поэтому каждому узлу можно присвоить уникальные значения параметров, создав распределенный журнал с множеством вызовов &lt;code&gt;open/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b469c9bb8a16915f90eba775ff31e5fe6d62248d" translate="yes" xml:space="preserve">
          <source>If a macro is used in several modules, it is recommended that the macro definition is placed in an include file.</source>
          <target state="translated">Если макрос используется в нескольких модулях,рекомендуется поместить определение макроса в включаемый файл.</target>
        </trans-unit>
        <trans-unit id="0bac8e18db1d29ae2b7dd77be807faeccb09df3e" translate="yes" xml:space="preserve">
          <source>If a match specification (applicable only for &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; tracing) contains a &lt;code&gt;{message}&lt;/code&gt; action function with a non-boolean value, that value is added as an extra element to the message tuple either in the last position or before the timestamp (if it is present).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0e324c5eb502ceba59e0414f16795091f6741d" translate="yes" xml:space="preserve">
          <source>If a match specification passed as argument has excessive nesting which causes scheduler stack exhaustion for the scheduler that the calling process is executing on. &lt;code&gt;Scheduler stack size&lt;/code&gt; can be configured when starting the runtime system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f532881cad197bff88db03f3d5191a830d7bf595" translate="yes" xml:space="preserve">
          <source>If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for example of a web browser where you choose to accept an outdated certificate. This option enables implementation of such a function. This &lt;code&gt;fun/1&lt;/code&gt; is called when no &lt;code&gt;ReferenceID&lt;/code&gt; matches. The return value of the fun (a &lt;code&gt;boolean()&lt;/code&gt;) decides the outcome. If &lt;code&gt;true&lt;/code&gt; the the certificate is accepted otherwise it is rejected. See &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Если сопоставление не удается, могут возникнуть обстоятельства, при которых сертификат все равно следует принять. Представьте, например, веб-браузер, в котором вы решили принять устаревший сертификат. Эта опция позволяет реализовать такую ​​функцию. Эта &lt;code&gt;fun/1&lt;/code&gt; вызывается, когда не совпадает &lt;code&gt;ReferenceID&lt;/code&gt; . Возвращаемое значение забавы ( &lt;code&gt;boolean()&lt;/code&gt; ) определяет результат. Если &lt;code&gt;true&lt;/code&gt; , сертификат принят, в противном случае он отклоняется. См. &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="4aba75283b25dadf865010d69b6030de96baf1b7" translate="yes" xml:space="preserve">
          <source>If a member terminates, it is automatically removed from the group.</source>
          <target state="translated">Если участник прекращает свою деятельность,он автоматически удаляется из группы.</target>
        </trans-unit>
        <trans-unit id="1162149be57c33d9e6fc9573f2f1305c9430528f" translate="yes" xml:space="preserve">
          <source>If a message is received before the &quot;virtual&quot; connection has been established, the connection will be setup automatically. An MGC may be real open minded and dynamically decide which encoding and transport service to use depending on how the transport layer contact is performed. For IP transports two ports are standardized, one for textual encoding and one for binary encoding. If for example an UDP packet was received on the text port it would be possible to decide encoding and transport on the fly.</source>
          <target state="translated">Если до установления &quot;виртуального&quot; соединения будет получено сообщение,то соединение будет установлено автоматически.MGC может быть по-настоящему открытым и динамически решать,какую услугу кодирования и транспорта использовать в зависимости от того,как осуществляется контакт на транспортном уровне.Для IP транспорта стандартизированы два порта,один для текстовой кодировки,а другой для двоичной.Если,например,UDP-пакет был получен на текстовом порту,то можно решить кодировку и транспорт на лету.</target>
        </trans-unit>
        <trans-unit id="b24fb0bcd517815519471545f5c58487dce8e63f" translate="yes" xml:space="preserve">
          <source>If a module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">Если модуль не скомпилирован Cover, на это указывает причина ошибки &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7967640d362f8afe4a91bac33b7793d78de475b7" translate="yes" xml:space="preserve">
          <source>If a module was cover compiled from the &lt;code&gt;.beam&lt;/code&gt; file, i.e. using &lt;code&gt;compile_beam/1&lt;/code&gt; or &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt;, it is assumed that the source code can be found in the same directory as the &lt;code&gt;.beam&lt;/code&gt; file, in &lt;code&gt;../src&lt;/code&gt; relative to that directory, or using the source path in &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. When using the latter, two paths are examined: first the one constructed by joining &lt;code&gt;../src&lt;/code&gt; and the tail of the compiled path below a trailing &lt;code&gt;src&lt;/code&gt; component, then the compiled path itself. If no source code is found, this is indicated by the error reason &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt;.</source>
          <target state="translated">Если модуль был скомпилирован из файла &lt;code&gt;.beam&lt;/code&gt; , то есть с использованием &lt;code&gt;compile_beam/1&lt;/code&gt; или &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt; , предполагается, что исходный код может быть найден в том же каталоге, что и файл &lt;code&gt;.beam&lt;/code&gt; , в относительном &lt;code&gt;../src&lt;/code&gt; в этот каталог или используя исходный путь в &lt;code&gt;Module:module_info(compile)&lt;/code&gt; . При использовании последнего проверяются два пути: сначала путь, созданный путем объединения &lt;code&gt;../src&lt;/code&gt; , и хвост скомпилированного пути ниже завершающего компонента &lt;code&gt;src&lt;/code&gt; , затем сам скомпилированный путь. Если исходный код не найден, на это указывает причина ошибки &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f56a79590fe78f12a072ad074e3e889605db4d" translate="yes" xml:space="preserve">
          <source>If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages enlarge the process message queue and probably make the problem worse.</source>
          <target state="translated">Если процесс мониторинга становится настолько большим,что при сборе мусора он сам начинает вызывать сообщения системного мониторинга,то сообщения увеличивают очередь сообщений процесса и,возможно,усугубляют проблему.</target>
        </trans-unit>
        <trans-unit id="0f2d8b6af86eed1a143439cc301064ec94ca2bef" translate="yes" xml:space="preserve">
          <source>If a more complex change has been made, for example, a change to the format of the internal state of a &lt;code&gt;gen_server&lt;/code&gt;, simple code replacement is not sufficient. Instead, it is necessary to:</source>
          <target state="translated">Если было внесено более сложное изменение, например, изменение формата внутреннего состояния &lt;code&gt;gen_server&lt;/code&gt; , простой замены кода недостаточно. Вместо этого необходимо:</target>
        </trans-unit>
        <trans-unit id="9709ba0c2dc81a1b8284809a6f8a81abf726c6a5" translate="yes" xml:space="preserve">
          <source>If a name collision occurs, the compiler reports a &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; message that tells if a definition was renamed, and the new name that must be used to encode/decode data.</source>
          <target state="translated">Если происходит конфликт имен, компилятор сообщает сообщение &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; которое сообщает, было ли переименовано определение, и новое имя, которое необходимо использовать для кодирования / декодирования данных.</target>
        </trans-unit>
        <trans-unit id="cd783a31aebc8e052e7a2e8a344df67638bdfe57" translate="yes" xml:space="preserve">
          <source>If a name in &lt;code&gt;Files&lt;/code&gt; is not the name of an existing file, Igor assumes it represents a module name, and tries to locate and read the corresponding source file. The parsed files are appended to &lt;code&gt;Sources&lt;/code&gt; and passed on to &lt;code&gt;merge_sources/3&lt;/code&gt;, i.e., entries in &lt;code&gt;Sources&lt;/code&gt; are listed before entries read from files.</source>
          <target state="translated">Если имя в &lt;code&gt;Files&lt;/code&gt; не является именем существующего файла, Игорь предполагает, что оно представляет имя модуля, и пытается найти и прочитать соответствующий исходный файл. Проанализированные файлы добавляются в &lt;code&gt;Sources&lt;/code&gt; и передаются в &lt;code&gt;merge_sources/3&lt;/code&gt; , т. Е. Записи в &lt;code&gt;Sources&lt;/code&gt; перечисляются перед записями, считываемыми из файлов.</target>
        </trans-unit>
        <trans-unit id="5f3d40f62d554584090ae4d71b42895c212400c3" translate="yes" xml:space="preserve">
          <source>If a name is given by a single atom, it should either be a &quot;simple&quot; atom which does not need to be single-quoted in Erlang, or otherwise its print name should correspond to a proper Erlang variable, i.e., begin with an uppercase character or an underscore. Names on the form &lt;code&gt;{A, N}&lt;/code&gt; represent function name variables &quot;&lt;code&gt;A/N&lt;/code&gt;&quot;; these are special variables which may be bound only in the function definitions of a module or a &lt;code&gt;letrec&lt;/code&gt;. They may not be bound in &lt;code&gt;let&lt;/code&gt; expressions and cannot occur in clause patterns. The atom &lt;code&gt;A&lt;/code&gt; in a function name may be any atom; the integer &lt;code&gt;N&lt;/code&gt; must be nonnegative. The functions &lt;code&gt;c_fname/2&lt;/code&gt; etc. are utilities for handling function name variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb3773364e26824edee6292b7366b7013d08419" translate="yes" xml:space="preserve">
          <source>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type &lt;code&gt;bag&lt;/code&gt;, each key can map to several records. All records in type &lt;code&gt;bag&lt;/code&gt; tables are unique, only the keys can be duplicated.</source>
          <target state="translated">Если новый элемент вставлен с тем же ключом, что и существующая запись, старая запись перезаписывается. Однако, если таблица имеет тип &lt;code&gt;bag&lt;/code&gt; , каждый ключ может отображаться на несколько записей. Все записи в таблицах типа &lt;code&gt;bag&lt;/code&gt; уникальны, дублируются только ключи.</target>
        </trans-unit>
        <trans-unit id="105d061d00a8d9f92d43b213988e0acb45e2f7f6" translate="yes" xml:space="preserve">
          <source>If a new module is introduced, the following instruction is used:</source>
          <target state="translated">При вводе нового модуля используется следующая инструкция:</target>
        </trans-unit>
        <trans-unit id="5f35aad99efc30cb9fc4c6453834ff14def063cf" translate="yes" xml:space="preserve">
          <source>If a node goes down in the middle of a dirty operation, the table load mechanism ensures that the update is performed on all replicas, or none. Both asynchronous dirty updates and synchronous dirty updates use the same recovery principle as lightweight transactions.</source>
          <target state="translated">Если узел падает в середине грязной операции,механизм загрузки таблицы гарантирует,что обновление будет выполнено на всех репликах,или ни на одной.Как асинхронные грязные обновления,так и синхронные грязные обновления используют тот же принцип восстановления,что и легковесные операции.</target>
        </trans-unit>
        <trans-unit id="327048d2049523b0f127e33e21231e0e526e41f3" translate="yes" xml:space="preserve">
          <source>If a node goes down, all connections to that node are removed. Calling &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; forces disconnection of a node.</source>
          <target state="translated">Если узел выходит из строя, все подключения к этому узлу удаляются. Вызов &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; приводит к отключению узла.</target>
        </trans-unit>
        <trans-unit id="b4217b58d768f80a1045777fccb8ca8bcb03c9aa" translate="yes" xml:space="preserve">
          <source>If a node is started, which has higher priority according to &lt;code&gt;distributed&lt;/code&gt; than the node where a distributed application is running, the application is restarted at the new node and stopped at the old node. This is called a &lt;strong&gt;takeover&lt;/strong&gt;.</source>
          <target state="translated">Если запускается узел, который имеет более высокий приоритет согласно &lt;code&gt;distributed&lt;/code&gt; чем узел, на котором выполняется распределенное приложение, приложение перезапускается на новом узле и останавливается на старом узле. Это называется &lt;strong&gt;поглощением&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bc63ca0578b8d746c309ca79e6507b21130aadd5" translate="yes" xml:space="preserve">
          <source>If a particular clause can be selected, the function returns &lt;code&gt;{true, {Clause, Bindings}}&lt;/code&gt;, where &lt;code&gt;Clause&lt;/code&gt; is the selected clause and &lt;code&gt;Bindings&lt;/code&gt; is a list of pairs &lt;code&gt;{Var, SubExpr}&lt;/code&gt; associating the variables occurring in the patterns of &lt;code&gt;Clause&lt;/code&gt; with the corresponding subexpressions in &lt;code&gt;Exprs&lt;/code&gt;. The list of bindings is given in innermost-first order; see the &lt;code&gt;match/2&lt;/code&gt; function for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f888cd8bd0f80a569dfdaa82a2f031133a869106" translate="yes" xml:space="preserve">
          <source>If a pattern is compiled with option &lt;code&gt;extended&lt;/code&gt;, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</source>
          <target state="translated">Если шаблон компилируется с &lt;code&gt;extended&lt;/code&gt; опцией , пробелы в шаблоне (кроме класса символов) и символы между # вне класса символов и следующей новой строкой игнорируются. Экранирующую обратную косую черту можно использовать для включения пробела или символа # как части шаблона.</target>
        </trans-unit>
        <trans-unit id="9e8b4db27222acc7892ee1eda43334910e96e198" translate="yes" xml:space="preserve">
          <source>If a pattern starts with .* or .{0,} and option &lt;code&gt;dotall&lt;/code&gt; (equivalent to Perl option &lt;code&gt;/s&lt;/code&gt;) is set, thus allowing the dot to match newlines, the pattern is implicitly anchored, because whatever follows is tried against every character position in the subject string. So, there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as if it was preceded by \A.</source>
          <target state="translated">Если шаблон начинается с. * Или. {0,} и установлен параметр &lt;code&gt;dotall&lt;/code&gt; (эквивалент Perl option &lt;code&gt;/s&lt;/code&gt; ), что позволяет точке совпадать с новой строкой, шаблон неявно привязывается, потому что все, что следует за ним, проверяется для каждой позиции символа в строке темы. Таким образом, нет смысла повторять общее совпадение в любой позиции после первого. PCRE обычно обрабатывает такой шаблон, как если бы ему предшествовал \ A.</target>
        </trans-unit>
        <trans-unit id="b87ae6dafb0124e6e46c837d4958c2fa1f2a81db" translate="yes" xml:space="preserve">
          <source>If a pattern starts with &lt;code&gt;(*NO_START_OPT)&lt;/code&gt;, it has the same effect as setting option &lt;code&gt;no_start_optimize&lt;/code&gt; at compile time.</source>
          <target state="translated">Если шаблон начинается с &lt;code&gt;(*NO_START_OPT)&lt;/code&gt; , он имеет тот же эффект, что и установка опции &lt;code&gt;no_start_optimize&lt;/code&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="9510cfbb42b2f63e8d24764760322df07deba921" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">Если постоянное приложение прекращает свое действие,то прекращаются также все остальные приложения и весь узел Erlang.</target>
        </trans-unit>
        <trans-unit id="ae39c8a4064e4c9103a84535d6791f3c2355574b" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the runtime system are also terminated.</source>
          <target state="translated">В случае прекращения постоянного приложения все остальные приложения и исполнительная система также прекращают свою работу.</target>
        </trans-unit>
        <trans-unit id="7d39ec2ef37ef98a358722319b34017d061d33a4" translate="yes" xml:space="preserve">
          <source>If a port is put into or removed from the run queue, a message, &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">Если порт помещается в очередь выполнения или удаляется из нее, на &lt;code&gt;ProfilerPid&lt;/code&gt; отправляется сообщение &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0081080fd8645d025c38129c1f724e4dbeb1f5a" translate="yes" xml:space="preserve">
          <source>If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change.</source>
          <target state="translated">Если положительное утверждение,содержащее одну или более захватывающих подмаскадок,удается,но не удается найти совпадение позже в образце,то захваты внутри утверждения сбрасываются только в том случае,если уже не установлено ни одного захвата с более высоким номером.Это,к сожалению,является фундаментальным ограничением текущей реализации,и поскольку PCRE1 сейчас находится в состоянии только для обслуживания,вряд ли это когда-нибудь изменится.</target>
        </trans-unit>
        <trans-unit id="9cb8ee97edf59cd0007ed1238bc9ac0388e87e9d" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a3a5bfdb59e73fc8a0334b43ff4eba1a20ef35" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">Если для дальнейшей распаковки требуется предустановленный словарь, эта функция возвращает кортеж &lt;code&gt;need_dictionary&lt;/code&gt; . См. Подробности в &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="83f7f43de6aead79d3e988b3241d9856a34d875b" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; is called automatically.</source>
          <target state="translated">Если процесс вызывает &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; без предварительной установки начального числа, автоматически вызывается &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a36c70330162b05d5a32dea8c99f296dd07fa13f" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; is called automatically with the default algorithm and creates a non-constant seed.</source>
          <target state="translated">Если процесс вызывает &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; без предварительной установки начального числа, &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; вызывается автоматически с алгоритмом по умолчанию и создает непостоянное начальное число.</target>
        </trans-unit>
        <trans-unit id="ee2bd61bda12e84b2a6d621165135cd3817f20fe" translate="yes" xml:space="preserve">
          <source>If a process having the driver loaded dies, it has the same effect as if unloading is done.</source>
          <target state="translated">Если процесс,в котором был загружен водитель,умирает,то это имеет такой же эффект,как если бы разгрузка была произведена.</target>
        </trans-unit>
        <trans-unit id="15014d5a4ff0f8066241b0151c8891a216ed87df" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a busy port, a message &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending to &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">Если процесс в системе приостанавливается из-за того, что он отправляет на занятый порт, сообщение &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; отправляется в &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;SusPid&lt;/code&gt; - это идентификатор pid, который был приостановлен при отправке в &lt;code&gt;Port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d68a1d07888243eae02b4e13f79a1936bb61d64" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending through the inter-node communication port &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">Если процесс в системе приостанавливается из-за того, что он отправляет сообщение процессу на удаленном узле, связь между узлами которого обрабатывалась через занятый порт, сообщение &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; отправляется в &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;SusPid&lt;/code&gt; - это идентификатор pid, который был приостановлен при отправке через порт &lt;code&gt;Port&lt;/code&gt; связи между узлами .</target>
        </trans-unit>
        <trans-unit id="c045c61e4349e5f89593c090cba3d3de09bd27de" translate="yes" xml:space="preserve">
          <source>If a process is put into or removed from the run queue, a message, &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;. Running processes that are reinserted into the run queue after having been pre-empted do not trigger this message.</source>
          <target state="translated">Если процесс помещается в очередь выполнения или удаляется из &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt; на &lt;code&gt;ProfilerPid&lt;/code&gt; отправляется сообщение {profile, Pid, ​​State, Mfa, Ts} . Запущенные процессы, которые повторно вставляются в очередь выполнения после упреждения, не вызывают это сообщение.</target>
        </trans-unit>
        <trans-unit id="4105e92988b9e0273b2afe1380f53a0c26000be5" translate="yes" xml:space="preserve">
          <source>If a process or port in the system runs uninterrupted for at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;PidOrPort&lt;/code&gt; is the process or port that was running. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the event.</source>
          <target state="translated">Если процесс или порт в системе работает непрерывно в течение как минимум миллисекунд &lt;code&gt;Time&lt;/code&gt; wall clock, сообщение &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; отправляется в &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;PidOrPort&lt;/code&gt; - это запущенный процесс или порт. &lt;code&gt;Info&lt;/code&gt; - это список двухэлементных кортежей, описывающих событие.</target>
        </trans-unit>
        <trans-unit id="4369b22f5f2ff0b202004df9cfaa90a8b5c4a981" translate="yes" xml:space="preserve">
          <source>If a process simply keeps binaries (either in &quot;loop data&quot; or in the process dictionary), the garbage collector can eventually shrink the binaries. If only one such binary is kept, it will not be shrunk. If the process later appends to a binary that has been shrunk, the binary object will be reallocated to make place for the data to be appended.</source>
          <target state="translated">Если процесс просто хранит двоичные файлы (либо в &quot;данных цикла&quot;,либо в словаре процесса),то сборщик мусора может в конечном итоге сократить двоичные файлы.Если будет сохранен только один такой двоичный файл,то он не будет уменьшен.Если позже процесс присоединяется к двоичному файлу,который был сжат,двоичный объект будет перераспределен,чтобы сделать место для данных,которые будут добавлены.</target>
        </trans-unit>
        <trans-unit id="f775d4e54bbee2d9dbda35be5042e4e186972f7c" translate="yes" xml:space="preserve">
          <source>If a process that holds a lock dies, or the node goes down, the locks held by the process are deleted.</source>
          <target state="translated">Если процесс,удерживающий замок,умирает,или узел падает,замки,удерживаемые процессом,удаляются.</target>
        </trans-unit>
        <trans-unit id="349bb33896dc8851d34347287725d343380e07fb" translate="yes" xml:space="preserve">
          <source>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</source>
          <target state="translated">Если процесс с зарегистрированным именем умирает,или узел падает,то имя не регистрируется на всех узлах.</target>
        </trans-unit>
        <trans-unit id="17f27468045dfd75afeb4d681d13f4dbea90b34b" translate="yes" xml:space="preserve">
          <source>If a process, &lt;code&gt;P&lt;/code&gt;, is spawned during execution of, for example, &lt;code&gt;init_per_suite/1&lt;/code&gt;, it inherits the group leader of the &lt;code&gt;init_per_suite&lt;/code&gt; process. This group leader is the central I/O server process mentioned earlier. If, at a later time, &lt;strong&gt;during parallel test case execution&lt;/strong&gt;, some event triggers process &lt;code&gt;P&lt;/code&gt; to call &lt;code&gt;io:format/1/2&lt;/code&gt;, that call never returns (as the group leader is in a non-responsive state) and causes &lt;code&gt;P&lt;/code&gt; to hang.</source>
          <target state="translated">Если процесс &lt;code&gt;P&lt;/code&gt; создается во время выполнения, например, &lt;code&gt;init_per_suite/1&lt;/code&gt; , он наследует лидера группы процесса &lt;code&gt;init_per_suite&lt;/code&gt; . Этот лидер группы является центральным серверным процессом ввода-вывода, упомянутым ранее. Если позднее, &lt;strong&gt;во время параллельного выполнения тестового примера&lt;/strong&gt; , какое-то событие запускает процесс &lt;code&gt;P&lt;/code&gt; для вызова &lt;code&gt;io:format/1/2&lt;/code&gt; , этот вызов никогда не возвращается (поскольку лидер группы находится в неактивном состоянии) и заставляет &lt;code&gt;P&lt;/code&gt; зависать ,</target>
        </trans-unit>
        <trans-unit id="8bf8390a7e5daa53c1c72aaa18283abc83275ce3" translate="yes" xml:space="preserve">
          <source>If a public key is used for logging in, there is normally no checking of the user name. It could be enabled by setting the option &lt;code&gt;&lt;a href=&quot;ssh#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. In that case the pwdfun will get the atom &lt;code&gt;pubkey&lt;/code&gt; in the password argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1cac2bbd83699ad97f93b747512a76b2a8a979" translate="yes" xml:space="preserve">
          <source>If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\xc8-\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values &amp;gt; 255 only when it is compiled with Unicode property support.</source>
          <target state="translated">Если при установке сопоставления без регистра используется диапазон, включающий буквы, он соответствует буквам в любом случае. Например, [Wc] эквивалентно [] [\\ ^ _ `wxyzabc], сопоставленное без учета регистра. В режиме без UTF, если используются таблицы символов для французского языка, [\ xc8- \ xcb] соответствует символам E с диакритическими знаками в обоих случаях. В режимах UTF PCRE поддерживает концепцию регистра для символов со значениями&amp;gt; 255, только когда он скомпилирован с поддержкой свойств Unicode.</target>
        </trans-unit>
        <trans-unit id="cefcc947210800042f579f6706da18141c734c3a" translate="yes" xml:space="preserve">
          <source>If a received message contains several transaction requests, this option indicates whether the requests should be handled sequentially in the same process (&lt;code&gt;false&lt;/code&gt;), or if each request should be handled by its own process (&lt;code&gt;true&lt;/code&gt; i.e. a separate process is spawned for each request).</source>
          <target state="translated">Если полученное сообщение содержит несколько запросов транзакции, этот параметр указывает, должны ли запросы обрабатываться последовательно в одном процессе ( &lt;code&gt;false&lt;/code&gt; ), или каждый запрос должен обрабатываться собственным процессом ( &lt;code&gt;true&lt;/code&gt; т.е. для каждого запроса создается отдельный процесс) ,</target>
        </trans-unit>
        <trans-unit id="b2fc74a5a7f43f310bc65da23c24d79b44a52f9d" translate="yes" xml:space="preserve">
          <source>If a record is stuck at node &lt;code&gt;N1&lt;/code&gt; and you try to set a sticky lock for the record on node &lt;code&gt;N2&lt;/code&gt;, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue &lt;code&gt;s_write/1&lt;/code&gt; requests at &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">Если запись застряла в узле &lt;code&gt;N1&lt;/code&gt; , и вы пытаетесь установить липкую блокировку для записи на узле &lt;code&gt;N2&lt;/code&gt; , запись должна быть откреплена. Эта операция дорогая и снижает производительность. Открепление выполняется автоматически, если вы &lt;code&gt;s_write/1&lt;/code&gt; запросы s_write / 1 на &lt;code&gt;N2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bbe2237d0bda60b504f73886161206ea6b2f204" translate="yes" xml:space="preserve">
          <source>If a record is used in several modules, it is recommended that the record definition is placed in an include file.</source>
          <target state="translated">Если запись используется в нескольких модулях,рекомендуется поместить определение записи в включаемый файл.</target>
        </trans-unit>
        <trans-unit id="e2be8cb7a69f1955706c91f4c83ac23caeea40af" translate="yes" xml:space="preserve">
          <source>If a recoverable error occurs, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; and the original application specifications are restored. If a non-recoverable error occurs, the system is restarted.</source>
          <target state="translated">Если возникает исправимая ошибка, функция возвращает &lt;code&gt;{error,Reason}&lt;/code&gt; и восстанавливаются исходные спецификации приложения. Если возникает неисправимая ошибка, система перезагружается.</target>
        </trans-unit>
        <trans-unit id="22cf54ba81d8faabf766e624c3e7d1674171bb89" translate="yes" xml:space="preserve">
          <source>If a regular core dump is wanted, let &lt;code&gt;heart&lt;/code&gt; know by setting the kill signal to abort using environment variable &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt;. If unset, or not set to &lt;code&gt;SIGABRT&lt;/code&gt;, the default behavior is a kill signal using &lt;code&gt;SIGKILL&lt;/code&gt;:</source>
          <target state="translated">Если требуется обычный дамп ядра, дайте знать &lt;code&gt;heart&lt;/code&gt; , установив сигнал уничтожения на прерывание с помощью переменной среды &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt; . Если не задано или не установлено в &lt;code&gt;SIGABRT&lt;/code&gt; , поведение по умолчанию - сигнал уничтожения с использованием &lt;code&gt;SIGKILL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc4cda006faf8c5c4a357b487a51055ca7991742" translate="yes" xml:space="preserve">
          <source>If a regular directory called &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Name-Vsn&lt;/code&gt; exists in the code path with an &lt;code&gt;ebin&lt;/code&gt; subdirectory, the path to this directory is returned (not the &lt;code&gt;ebin&lt;/code&gt; directory).</source>
          <target state="translated">Если в пути кода с подкаталогом &lt;code&gt;Name-Vsn&lt;/code&gt; существует обычный каталог с именем &lt;code&gt;Name&lt;/code&gt; или Name-Vsn, &lt;code&gt;ebin&lt;/code&gt; путь к этому каталогу (не каталог &lt;code&gt;ebin&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d41dbfbe2ec7024dcb9b99c3ee2932c5b54d378" translate="yes" xml:space="preserve">
          <source>If a reply to a request is not received in time, the megaco stack removes all info about the request from its tables. If a reply should arrive after this has been done the app has no way of knowing where to send this message. The message is delivered to the &quot;user&quot; by calling this function on the local node (the node which has the link).</source>
          <target state="translated">Если ответ на запрос не получен вовремя,стек megaco удаляет всю информацию о запросе из своих таблиц.Если ответ должен прийти после того,как это было сделано,приложение не имеет возможности узнать,куда отправить это сообщение.Сообщение доставляется &quot;пользователю&quot;,вызывая эту функцию на локальном узле (узел,на котором есть ссылка).</target>
        </trans-unit>
        <trans-unit id="98d501fda955c0480d302e83623ef7940c95c989" translate="yes" xml:space="preserve">
          <source>If a row is created, we always set the internal column to &lt;code&gt;&quot;internal&quot;&lt;/code&gt;.</source>
          <target state="translated">Если создается строка, мы всегда устанавливаем для внутреннего столбца значение &lt;code&gt;&quot;internal&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bcc6cd834e1b61a016a579e0ab9636b50732f34" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebc1546b581fe9ec3e1aa902afae9065bac8290" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если планировщику не удается выполнить привязку, это часто незаметно игнорируется, поскольку не всегда возможно проверить действительные идентификаторы логического процессора. Если сообщается об ошибке, регистрируется событие ошибки. Чтобы убедиться, что планировщики связались в соответствии с запросом, вызовите &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a0818c4665c47cbb9e80ed0764a80aff0ec1b7a" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95196719288c8a4037a8712bcbf85254190e9568" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если планировщику не удается выполнить привязку, это часто незаметно игнорируется, поскольку не всегда возможно проверить действительные идентификаторы логического процессора. Если сообщается об ошибке, об этом сообщается &lt;code&gt;error_logger&lt;/code&gt; . Если вы хотите убедиться, что планировщики связаны в соответствии с запросом, вызовите &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70c51b792a482c1acceec2498ed07a15eeff4e4d" translate="yes" xml:space="preserve">
          <source>If a scheduler is put to sleep or awoken, a message, &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">Если планировщик &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt; в спящий режим или пробуждается, на &lt;code&gt;ProfilerPid&lt;/code&gt; отправляется сообщение {profile, scheduler, Id, State, NoScheds, Ts} .</target>
        </trans-unit>
        <trans-unit id="c83d78ce9bb009d70f32a1197570bf9131a81777" translate="yes" xml:space="preserve">
          <source>If a scheduler thread create a new reference each nano second, references will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">Если поток планировщика создает новую ссылку каждую наносекунду,то ссылки будут использоваться повторно не ранее,чем через 584 года.То есть в обозримом будущем они достаточно уникальны.</target>
        </trans-unit>
        <trans-unit id="4907dacbb20e81759e0cdf9eb1879f2ddefb0697" translate="yes" xml:space="preserve">
          <source>If a script is found, the first thing that happens is that the application specifications are updated according to the &lt;code&gt;.app&lt;/code&gt; files and &lt;code&gt;sys.config&lt;/code&gt; belonging to the release version &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">Если скрипт найден, то первое, что происходит , является то , что спецификации приложений обновляется в соответствии с &lt;code&gt;.app&lt;/code&gt; файлов и &lt;code&gt;sys.config&lt;/code&gt; принадлежащих к версии &lt;code&gt;Vsn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="332eeb8191104a7c5c740b708710a7e691d869fa" translate="yes" xml:space="preserve">
          <source>If a shell service request arrives to the server, an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d4a6395eb04a368d97e3a781384bca1f8ac150" translate="yes" xml:space="preserve">
          <source>If a shuffled test case group is repeated, the seed is not reset between turns.</source>
          <target state="translated">При повторении перетасовки контрольной группы посевной материал не сбрасывается между поворотами.</target>
        </trans-unit>
        <trans-unit id="f211a4f0b3b5f8149bc67ba0e458b150aec8e31c" translate="yes" xml:space="preserve">
          <source>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called &lt;strong&gt;simple code replacement&lt;/strong&gt; and for this the following instruction is used:</source>
          <target state="translated">Если в функциональный модуль было выполнено простое расширение, достаточно загрузить новую версию модуля в систему и удалить старую версию. Это называется &lt;strong&gt;простой заменой кода,&lt;/strong&gt; и для этого используется следующая инструкция:</target>
        </trans-unit>
        <trans-unit id="820e1f62550d2d1dc4b7d5110225b45b02793e4e" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it.</source>
          <target state="translated">Если сокет каким-то образом был подключен без использования &lt;code&gt;gen_tcp&lt;/code&gt; , используйте эту опцию, чтобы передать для него файловый дескриптор.</target>
        </trans-unit>
        <trans-unit id="bf685931edb5e2ee94fb5c82e823cca317fe8b98" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;{ip, Address}&lt;/code&gt; and/or &lt;code&gt;{port, port_number()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port before connecting. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">Если сокет каким-то образом был подключен без использования &lt;code&gt;gen_tcp&lt;/code&gt; , используйте эту опцию, чтобы передать для него файловый дескриптор. Если &lt;code&gt;{ip, Address}&lt;/code&gt; и / или &lt;code&gt;{port, port_number()}&lt;/code&gt; объединены с этой опцией, &lt;code&gt;fd&lt;/code&gt; привязывается к указанному интерфейсу и порту перед подключением. Если эти параметры не указаны, предполагается, что &lt;code&gt;fd&lt;/code&gt; уже привязан соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="88d20f7afcab3c9941388d26759eb43e0f494eda" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been opened without using &lt;code&gt;gen_udp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;Port&lt;/code&gt; is not set to &lt;code&gt;0&lt;/code&gt; and/or &lt;code&gt;{ip, ip_address()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port after it is being opened. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">Если сокет каким-то образом был открыт без использования &lt;code&gt;gen_udp&lt;/code&gt; , используйте эту опцию, чтобы передать для него файловый дескриптор. Если для &lt;code&gt;Port&lt;/code&gt; не задано значение &lt;code&gt;0&lt;/code&gt; и / или &lt;code&gt;{ip, ip_address()}&lt;/code&gt; комбинируется с этой опцией, &lt;code&gt;fd&lt;/code&gt; привязывается к указанному интерфейсу и порту после его открытия. Если эти параметры не указаны, предполагается, что &lt;code&gt;fd&lt;/code&gt; уже привязан соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="c3d4cd539d93fb17b915657f42699b04d0414500" translate="yes" xml:space="preserve">
          <source>If a socket is connected already, option &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; can be used to pass the open file descriptor to &lt;code&gt;gen_udp&lt;/code&gt;. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by &lt;code&gt;setuid_socket_wrap&lt;/code&gt;, the command-line argument &quot;-tftpd_69 22&quot; triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; is automatically added. See &lt;code&gt;init:get_argument/&lt;/code&gt; about command-line arguments and &lt;code&gt;gen_udp:open/2&lt;/code&gt; about UDP options.</source>
          <target state="translated">Если сокет уже подключен, опция &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; может использоваться для передачи дескриптора открытого файла в &lt;code&gt;gen_udp&lt;/code&gt; . Это можно автоматизировать, используя аргумент командной строки, в котором указывается номер предварительно связанного дескриптора файла. Например, если порт 69 и дескриптор файла 22 открыт с помощью &lt;code&gt;setuid_socket_wrap&lt;/code&gt; , аргумент командной строки &amp;laquo;-tftpd_69 22&amp;raquo; запускает предварительный привязанный файловый дескриптор 22, который будет использоваться вместо открытия порта 69. Параметр UDP &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; добавляется автоматически. См &lt;code&gt;init:get_argument/&lt;/code&gt; об аргументах командной строки и &lt;code&gt;gen_udp:open/2&lt;/code&gt; об опциях UDP.</target>
        </trans-unit>
        <trans-unit id="8adda14107128cbabef9332c232b6afdafabc519" translate="yes" xml:space="preserve">
          <source>If a subgroup is specified in a group with a &lt;code&gt;shuffle&lt;/code&gt; property, the execution order of this subgroup in relation to the test cases (and other subgroups) in the group, is random. The order of the test cases in the subgroup is however not random (unless the subgroup has a &lt;code&gt;shuffle&lt;/code&gt; property).</source>
          <target state="translated">Если подгруппа указана в группе со свойством &lt;code&gt;shuffle&lt;/code&gt; , порядок выполнения этой подгруппы по отношению к тестовым случаям (и другим подгруппам) в группе является случайным. Однако порядок тестовых примеров в подгруппе не является случайным (если только подгруппа не имеет свойства &lt;code&gt;shuffle&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8f9318070c1a0b76966d2350817b608770dbd93" translate="yes" xml:space="preserve">
          <source>If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port. The calling process is notified as &lt;code&gt;inactive&lt;/code&gt;, and later &lt;code&gt;active&lt;/code&gt; when the port callback returns.</source>
          <target state="translated">Если выполняется синхронный вызов порта из процесса, вызывающий процесс считается неработоспособным во время выполнения вызова порта. Вызывающий процесс уведомляется как &lt;code&gt;inactive&lt;/code&gt; , а затем становится &lt;code&gt;active&lt;/code&gt; когда возвращается обратный вызов порта.</target>
        </trans-unit>
        <trans-unit id="03163668ea38b2448adbb495833cb5c9d2fb18c2" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;bag&lt;/code&gt;, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function &lt;code&gt;delete_object/3&lt;/code&gt;. A complete record must be supplied to this function.</source>
          <target state="translated">Если таблица имеет тип &lt;code&gt;bag&lt;/code&gt; , иногда может потребоваться удалить только некоторые записи с определенным ключом. Это можно сделать с помощью функции &lt;code&gt;delete_object/3&lt;/code&gt; . Для этой функции должна быть предоставлена ​​полная запись.</target>
        </trans-unit>
        <trans-unit id="d6399fd24f009cc3e3ffb42705ab75b017db16fb" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;set&lt;/code&gt;, each key leads to either one or zero records.</source>
          <target state="translated">Если таблица имеет &lt;code&gt;set&lt;/code&gt; тип , каждый ключ ведет либо к одной, либо к нулю записей.</target>
        </trans-unit>
        <trans-unit id="cc60ddbc56bced221eb285cedf24eccba7391477" translate="yes" xml:space="preserve">
          <source>If a temporary application terminates, this is reported but no other applications are terminated.</source>
          <target state="translated">Если временное приложение прекращает свое действие,об этом сообщается,но никакие другие приложения не прекращаются.</target>
        </trans-unit>
        <trans-unit id="1c78c30e29b702d609a635a08cca518cae737159" translate="yes" xml:space="preserve">
          <source>If a terminal symbol is the only member of a category, and the symbol name is identical to the category name, the token format may be &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt;.</source>
          <target state="translated">Если терминальный символ является единственным членом категории, а имя символа идентично имени категории, формат токена может быть &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39831a6256c96762c2da58783be93b30bfb60bf0" translate="yes" xml:space="preserve">
          <source>If a test case belonging to a group (according to the group definition) is executed without a group specification, that is, simply by (using the command line):</source>
          <target state="translated">Если тестовый случай,относящийся к группе (в соответствии с определением группы),выполняется без спецификации группы,то есть просто (с помощью командной строки):</target>
        </trans-unit>
        <trans-unit id="502798b518aba9797ae119aec810b4ce5b5d0729" translate="yes" xml:space="preserve">
          <source>If a test case fails, this funcion is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если тестовый пример не проходит, эта функция вызывается после &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="335080793d3bf721193087f47f63eafaac01cbbd" translate="yes" xml:space="preserve">
          <source>If a test case is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если тестовый пример пропущен, эта функция вызывается после &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a471993c391b1bd64637c48e80cd9c14d7854c" translate="yes" xml:space="preserve">
          <source>If a test case needs to suspend itself for a time that also gets multipled by &lt;code&gt;multiply_timetraps&lt;/code&gt; (and possibly also scaled up if &lt;code&gt;scale_timetraps&lt;/code&gt; is enabled), the function &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; can be used (instead of, for example, &lt;code&gt;timer:sleep/1&lt;/code&gt;).</source>
          <target state="translated">Если тестовый пример должен приостановить себя на время, которое также &lt;code&gt;multiply_timetraps&lt;/code&gt; на multiply_timetraps (и, возможно, также увеличивается, если &lt;code&gt;scale_timetraps&lt;/code&gt; ), можно использовать функцию &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; (вместо, например, &lt;code&gt;timer:sleep/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5226c324f9ac4409e33361c519af1aca1d4d0288" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it are terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">При загрузке третьего экземпляра модуля сервер кода удаляет (очищает)старый код,а все затянувшиеся в нем процессы завершаются.Затем третий экземпляр становится 'текущим',а предыдущий текущий код-'старым'.</target>
        </trans-unit>
        <trans-unit id="4b71ff8bf7808e50acef36bf51fec54b753b169f" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it is terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">При загрузке третьего экземпляра модуля сервер кода удаляет (очищает)старый код,а все затянувшиеся в нем процессы завершаются.Затем третий экземпляр становится 'текущим',а предыдущий текущий код-'старым'.</target>
        </trans-unit>
        <trans-unit id="9b209316ada835a355f0bceb58d85107e4df7fa7" translate="yes" xml:space="preserve">
          <source>If a thread is already working, the calls are queued up and executed in order. Using the same thread for each driver instance ensures that the calls are made in sequence.</source>
          <target state="translated">Если поток уже работает,вызовы ставятся в очередь и выполняются по порядку.Использование одного и того же потока для каждого экземпляра драйвера обеспечивает последовательность вызовов.</target>
        </trans-unit>
        <trans-unit id="f81497c9931883554b1a22b52663496f9755cc27" translate="yes" xml:space="preserve">
          <source>If a thread pool is available, a thread is used. If argument &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the threads from the pool are used in a round-robin way, each call to &lt;code&gt;driver_async&lt;/code&gt; uses the next thread in the pool. With argument &lt;code&gt;key&lt;/code&gt; set, this behavior is changed. The two same values of &lt;code&gt;*key&lt;/code&gt; always get the same thread.</source>
          <target state="translated">Если доступен пул потоков, используется поток. Если &lt;code&gt;key&lt;/code&gt; аргумента - &lt;code&gt;NULL&lt;/code&gt; ( NULL) , потоки из пула используются циклически, каждый вызов &lt;code&gt;driver_async&lt;/code&gt; использует следующий поток в пуле. С установленным &lt;code&gt;key&lt;/code&gt; аргумента это поведение изменяется. Два одинаковых значения &lt;code&gt;*key&lt;/code&gt; всегда получают один и тот же поток.</target>
        </trans-unit>
        <trans-unit id="2ae4841a41da1bafc39b445eb14fcf5adc83b911" translate="yes" xml:space="preserve">
          <source>If a time-out is started with the time &lt;code&gt;0&lt;/code&gt; it will actually not be started. Instead the time-out event will immediately be inserted to be processed after any events already enqueued, and before any not yet received external events. Note that some time-outs are automatically cancelled so if you for example combine &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponing&lt;/a&gt;&lt;/code&gt; an event in a &lt;strong&gt;state change&lt;/strong&gt; with starting an &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;event time-out&lt;/a&gt;&lt;/code&gt; with time &lt;code&gt;0&lt;/code&gt; there will be no time-out event inserted since the event time-out is cancelled by the postponed event that is delivered due to the state change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed3fc97d55d4fa64719146d29086a7ad193da5e" translate="yes" xml:space="preserve">
          <source>If a time-out is started with the time &lt;code&gt;infinity&lt;/code&gt; it will never time out, in fact it will not even be started, and any running time-out with the same tag will be cancelled. The &lt;code&gt;EventContent&lt;/code&gt; will in this case be ignored, so why not set it to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f35f3c6d4b31e8b5610fe46bbb2c396d6dec610" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes can not be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Если порт трассировки (см. &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; ) работает на локальном узле, удаленные узлы не могут быть отслежены с помощью процесса трассировки. &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; причина ошибки cant_trace_remote_pid_to_local_port . Однако порт трассировки можно запустить на удаленном узле с помощью функции &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be4166c81b6aa45a3706a93a3be13529c5b52b9c" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes cannot be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763b6ed1f9356f6927dce6575fc162a00e017c98" translate="yes" xml:space="preserve">
          <source>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</source>
          <target state="translated">Если трассировщик указан в обоих списках,то приоритет имеет трассировщик в списке разрешений.Если трассировщик не указан,то используется тот же трассировщик,что и процесс,выполняющий спецификацию соответствия (не мета-трассировщик).Если и у этого процесса нет трассировщика,то флаги трассировки игнорируются.</target>
        </trans-unit>
        <trans-unit id="b082e683a06ac559acb1ef17f3dfa0a3a24bd825" translate="yes" xml:space="preserve">
          <source>If a transaction involves updates of asymmetrically replicated tables or updates of the schema table, a heavyweight commit protocol is used. This protocol can finish the transaction regardless of how the tables are replicated. The typical use of a heavyweight transaction is when a replica is to be moved from one node to another. Then ensure that the replica either is entirely moved or left as it was. Do never end up in a situation with replicas on both nodes, or on no node at all. Even if a node crashes in the middle of the commit protocol, the transaction must be guaranteed to be atomic. The heavyweight commit protocol involves more messages between the transaction coordinator and its participants than a lightweight protocol, and it performs recovery work at startup to finish the terminating or commit work.</source>
          <target state="translated">Если транзакция включает в себя обновление асимметрично реплицированных таблиц или обновление таблицы схем,используется тяжеловесный протокол коммитов.Этот протокол может завершить транзакцию независимо от того,как таблицы реплицируются.Типичное использование тяжеловесной транзакции-это когда репликация должна быть перемещена с одного узла на другой.Затем убедитесь,что реплика либо полностью перемещена,либо оставлена такой,какой она была.Никогда не попадайте в ситуацию с репликами на обоих узлах,или ни на одном из них вообще.Даже если узел рушится в середине протокола фиксации,транзакция должна быть гарантированно атомарной.Тяжеловесный протокол коммитов включает в себя больше сообщений между координатором транзакции и её участниками,чем легковесный протокол,и он выполняет восстановительные работы при запуске,чтобы завершить завершающую или коммитирующую работу.</target>
        </trans-unit>
        <trans-unit id="be9ed32b4b23ddaaa7542c4292ca46e3b1d16e3a" translate="yes" xml:space="preserve">
          <source>If a transaction terminates abnormally, &lt;code&gt;Mnesia&lt;/code&gt; automatically releases the locks held by the transaction.</source>
          <target state="translated">Если транзакция завершается ненормально, &lt;code&gt;Mnesia&lt;/code&gt; автоматически снимает блокировки, удерживаемые транзакцией.</target>
        </trans-unit>
        <trans-unit id="ddb095e9f47a7e392a2d545f1d0433b6aff3499a" translate="yes" xml:space="preserve">
          <source>If a transformation rule matched, the loader applies the transformation rules again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d768f6b886e49430d7bcd0e5e091ee1cc5e44534" translate="yes" xml:space="preserve">
          <source>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">Если переходное приложение прекращается аномально,то прекращаются также все остальные приложения и весь узел Erlang.</target>
        </trans-unit>
        <trans-unit id="1b042eac1f57ab6a81bbf8b7e159e1151ec77d9d" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with &lt;code&gt;Reason == normal&lt;/code&gt;, this is reported but no other applications are terminated.</source>
          <target state="translated">Если временное приложение завершается с &lt;code&gt;Reason == normal&lt;/code&gt; , об этом сообщается, но никакие другие приложения не завершаются.</target>
        </trans-unit>
        <trans-unit id="7d851ba83013456de4862df5a0550756dd9ddcb5" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with reason &lt;code&gt;normal&lt;/code&gt;, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than &lt;code&gt;normal&lt;/code&gt;, all other applications and the runtime system are also terminated.</source>
          <target state="translated">Если временное приложение завершается по &lt;code&gt;normal&lt;/code&gt; причине , об этом сообщается, но никакие другие приложения не закрываются. Если временное приложение завершает работу ненормально, то есть по любой другой причине, кроме &lt;code&gt;normal&lt;/code&gt; , все другие приложения и система времени выполнения также завершаются.</target>
        </trans-unit>
        <trans-unit id="2a6dabddba08d7663fc55e59a178732b34a37ab9" translate="yes" xml:space="preserve">
          <source>If a unique integer is created each nano second, unique integers will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">Если создается уникальное целое число каждую наносекунду,то уникальные целые числа будут повторно использоваться не ранее,чем через 584 года.То есть в обозримом будущем они достаточно уникальны.</target>
        </trans-unit>
        <trans-unit id="8212ea9be32c0602ffe0b39d535c8ff1c3704caf" translate="yes" xml:space="preserve">
          <source>If a user wants to run only a subset of a test suite, there is no way one test case could successfully depend on another.</source>
          <target state="translated">Если пользователь хочет запустить только подмножество тестового набора,то ни один тестовой случай не может успешно зависеть от другого.</target>
        </trans-unit>
        <trans-unit id="7a2111f1ccabd04661a065f18bb26413e12a43cc" translate="yes" xml:space="preserve">
          <source>If a value for an object is not given to the &lt;code&gt;send_notification&lt;/code&gt; function, the sub-agent will perform a get-operation to retrieve it. If the object is not implemented in this sub-agent, its parent agent tries to perform a get-operation to retrieve it. If the object is not implemented in this agent either, it forwards the object to its parent, and so on. Eventually the Master Agent is reached and at this point all unknown object values must be resolved. If some object is unknown even to the Master Agent, this is regarded as an error and is reported with a call to &lt;code&gt;user_err/2&lt;/code&gt; of the error report module. No notifications are sent in this case.</source>
          <target state="translated">Если значение для объекта не задано функции &lt;code&gt;send_notification&lt;/code&gt; , субагент выполнит операцию get для его получения. Если объект не реализован в этом подагенте, его родительский агент пытается выполнить операцию получения, чтобы получить его. Если объект также не реализован в этом агенте, он перенаправляет объект своему родительскому объекту и так далее. В конце концов, главный агент достигнут, и на этом этапе все неизвестные значения объектов должны быть разрешены. Если какой-либо объект неизвестен даже &lt;code&gt;user_err/2&lt;/code&gt; агенту, это считается ошибкой и сообщается с вызовом user_err / 2 модуля отчета об ошибках. Уведомления в этом случае не отправляются.</target>
        </trans-unit>
        <trans-unit id="7f05ffe858a8cb96ed8902253d604666829ad99b" translate="yes" xml:space="preserve">
          <source>If a variable in the notification is a table element, the &lt;code&gt;RowIndex&lt;/code&gt; for the element must be given in the &lt;code&gt;Varbinds&lt;/code&gt; list. In this case, the OBJECT IDENTIFIER sent in the notification is the OBJECT IDENTIFIER that identifies this element. This OBJECT IDENTIFIER could be used in a get operation later.</source>
          <target state="translated">Если переменная в уведомлении является элементом таблицы, &lt;code&gt;RowIndex&lt;/code&gt; для этого элемента должен быть указан в списке &lt;code&gt;Varbinds&lt;/code&gt; . В этом случае ИДЕНТИФИКАТОР ОБЪЕКТА, отправленный в уведомлении, является ИДЕНТИФИКАТОРОМ ОБЪЕКТА, который идентифицирует этот элемент. Этот ИДЕНТИФИКАТОР ОБЪЕКТА может быть использован позже в операции получения.</target>
        </trans-unit>
        <trans-unit id="efa23222c6a2a3e5338c7520ab1388a99a7dfcaa" translate="yes" xml:space="preserve">
          <source>If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions.</source>
          <target state="translated">Если глагол с именем встречается в положительном утверждении,которое является истинным,имя записывается и передаётся обратно,если оно встречается в последний раз.Это не происходит в случае отрицательных или отрицательных положительных утверждений.</target>
        </trans-unit>
        <trans-unit id="3c078e743c8ad3031e0b9776799a11e94ca09596" translate="yes" xml:space="preserve">
          <source>If a word is a keyword in any of SMIv1 or SMIv2, it is a keyword in the compiler (deviates from SMIv1 only).</source>
          <target state="translated">Если слово является ключевым словом в любом из SMIv1 или SMIv2,то оно является ключевым словом в компиляторе (отличается только от SMIv1).</target>
        </trans-unit>
        <trans-unit id="626f4bf2cfcfd59884034c767d316b8382a2cf65" translate="yes" xml:space="preserve">
          <source>If all above checks passed both &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt; Bloom filters are checked to detect if binder was already seen. Being a probabilistic data structure, false positives can occur and they trigger a full handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1149a0ac86645906ae73725e9fb076d1a22fe0f5" translate="yes" xml:space="preserve">
          <source>If all is going well, &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; is returned, where &lt;code&gt;ResultOfFun&lt;/code&gt; is the value of the last expression in &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">Если все идет хорошо, возвращается &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; , где &lt;code&gt;ResultOfFun&lt;/code&gt; - значение последнего выражения в &lt;code&gt;Fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b01530d249514addedfdbdbbd983e4e8a11a58ae" translate="yes" xml:space="preserve">
          <source>If all the alternatives of a pattern begin with \G, the expression is anchored to the starting match position, and the &quot;anchored&quot; flag is set in the compiled regular expression.</source>
          <target state="translated">Если все альтернативы шаблона начинаются с \G,то выражение привязывается к начальной позиции совпадения,а в скомпилированном регулярном выражении устанавливается флаг &quot;привязан&quot;.</target>
        </trans-unit>
        <trans-unit id="e1594cd6a4b2cab6cb92767668a0eff338a52692" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;.erlang&lt;/code&gt; file is found, it is assumed to contain valid Erlang expressions. These expressions are evaluated as if they were input to the shell.</source>
          <target state="translated">Если &lt;code&gt;.erlang&lt;/code&gt; файл .erlang , предполагается, что он содержит допустимые выражения Erlang. Эти выражения оцениваются так, как если бы они были введены в оболочку.</target>
        </trans-unit>
        <trans-unit id="af472d7bbaa2fc6a0ea1097c69c14756e497ac62" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocator has been disabled.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; отключен.</target>
        </trans-unit>
        <trans-unit id="09d966cba699040070b071c5c784aefbdf8752e2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout, connection loss, or an improper &lt;code&gt;Nodes&lt;/code&gt; list), the caller will not receive any further information about the result if/when the applied function completes. If the applied function communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fe7f6a7a0b539b5749a7e1d2f251c0f18f21ac" translate="yes" xml:space="preserve">
          <source>If an I/O device is set in binary mode, functions &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8.</source>
          <target state="translated">Если устройство ввода-вывода установлено в двоичном режиме, функции &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; могут возвращать двоичные файлы вместо списков. Бинарные файлы, как и в Erlang / OTP R13A, закодированы в UTF-8.</target>
        </trans-unit>
        <trans-unit id="950a5eee2a6c7e7d5ca333de354cd42eaef1ad34" translate="yes" xml:space="preserve">
          <source>If an I/O server encounters a request that it does not recognize (that is, the &lt;code&gt;io_request&lt;/code&gt; tuple has the expected format, but the &lt;code&gt;Request&lt;/code&gt; is unknown), the I/O server is to send a valid reply with the error tuple:</source>
          <target state="translated">Если сервер ввода-вывода встречает запрос, который он не распознает (то есть кортеж &lt;code&gt;io_request&lt;/code&gt; имеет ожидаемый формат, но &lt;code&gt;Request&lt;/code&gt; неизвестен), сервер ввода-вывода должен отправить действительный ответ с кортежем ошибки:</target>
        </trans-unit>
        <trans-unit id="a4f36f7aa69d8f80d8d7146716c4e8049b3bf51a" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry.</source>
          <target state="translated">Если экземпляр объекта MIB принадлежит ровно к одному поддереву,то он включается или исключается из соответствующего представления MIB в соответствии с типом этой записи.</target>
        </trans-unit>
        <trans-unit id="a99df1ec1c1a80894724865e2ce569291af72e66" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used.</source>
          <target state="translated">Если экземпляр объекта MIB принадлежит более чем одному поддереву,то используется поддерево,которое состоит из наибольшего числа суб-идентификаторов и является наибольшим в лексикографическом отношении.</target>
        </trans-unit>
        <trans-unit id="e6bdb8ad60adae512c56f4674456a5be529864a3" translate="yes" xml:space="preserve">
          <source>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view.</source>
          <target state="translated">Если экземпляр объекта MIB не принадлежит ни к одному из соответствующих поддеревьев,то этот экземпляр не отображается в представлении MIB.</target>
        </trans-unit>
        <trans-unit id="705cdb188be71ada04fc74b872d92dbacc75dd7e" translate="yes" xml:space="preserve">
          <source>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</source>
          <target state="translated">Если в функции algs_list()отсутствует функция alg_entry(),то для этой записи используется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5c83f6426a048bc4d7852aaa3ae581e49a373491" translate="yes" xml:space="preserve">
          <source>If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time.</source>
          <target state="translated">Если имя алгоритма встречается в списке несколько раз,поведение не определено.Также предполагается,что теги в списках свойств встречаются максимум один раз.</target>
        </trans-unit>
        <trans-unit id="ce7071090130d498a0f2639cfbfd5be9f3e8c347" translate="yes" xml:space="preserve">
          <source>If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either &lt;code&gt;{error,encode}&lt;/code&gt; or &lt;code&gt;{error,failure}&lt;/code&gt; is returned depending on whether or not there has been an attempt to send the request over the transport.</source>
          <target state="translated">Если обратный вызов приложения, выполненный при обработке запроса, завершается неудачно (pick_peer, prepare_request, prepare_retransmit, handle_answer или handle_error), то возвращается либо &lt;code&gt;{error,encode}&lt;/code&gt; , либо &lt;code&gt;{error,failure}&lt;/code&gt; в зависимости от того, была ли попытка отправить запрос. над транспортом.</target>
        </trans-unit>
        <trans-unit id="9bc38fb01d5bf31a73055c19a3816c95b41bcc62" translate="yes" xml:space="preserve">
          <source>If an application is given more than once or if an application has the same key given more than once, the behaviour is undefined and a warning message will be logged. In future releases, an error will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39738be45b65649837e2fb936bf724db2dc8cf3a" translate="yes" xml:space="preserve">
          <source>If an argument is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8620de6a5aec3c030672b28f6a7fdb90f2fa4d64" translate="yes" xml:space="preserve">
          <source>If an arithmetic expression, a Boolean expression, a short-circuit expression, or a call to a guard BIF fails (because of invalid arguments), the entire guard fails. If the guard was part of a guard sequence, the next guard in the sequence (that is, the guard following the next semicolon) is evaluated.</source>
          <target state="translated">Если арифметическое выражение,булевое выражение,выражение с коротким замыканием или вызов защитного BIF дает сбой (из-за недействительных аргументов),то сбой дает сбой весь защитный BIF.Если защита была частью последовательности защиты,то вычисляется следующая защита в последовательности (т.е.защита,следующая за следующей точкой с запятой).</target>
        </trans-unit>
        <trans-unit id="ee90b274af3aff2cc9d248f74e9b5167e0839059" translate="yes" xml:space="preserve">
          <source>If an attempt to open a log file for the first time fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt;. The function returns &lt;code&gt;{error, Reason}&lt;/code&gt; for all other errors.</source>
          <target state="translated">Если попытка открыть файл журнала в первый раз не удалась, процесс журнала диска завершается с сообщением EXIT &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt; . Функция возвращает &lt;code&gt;{error, Reason}&lt;/code&gt; для всех остальных ошибок.</target>
        </trans-unit>
        <trans-unit id="6c78e44d2f2d9461d5a0cc6159a7d3b1775f8cf6" translate="yes" xml:space="preserve">
          <source>If an attempt to reopen or truncate a log fails (see &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt;) the disk log process terminates immediately. Before the process terminates, links to owners and blocking processes (see &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt;) are removed. The effect is that the links work in one direction only. Any process using a disk log must check for error message &lt;code&gt;no_such_log&lt;/code&gt; if some other process truncates or reopens the log simultaneously.</source>
          <target state="translated">Если попытка повторно открыть или обрезать журнал не удалась (см. &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt; ), процесс журнала диска немедленно завершается. Перед завершением процесса ссылки на владельцев и блокирующие процессы (см. &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt; ) удаляются. В результате ссылки работают только в одном направлении. Любой процесс, использующий журнал диска, должен проверить сообщение об ошибке &lt;code&gt;no_such_log&lt;/code&gt; , если какой-либо другой процесс одновременно усекает или повторно открывает журнал.</target>
        </trans-unit>
        <trans-unit id="efa1a720322487c68ded0dc02a8c51e5dc94fcf9" translate="yes" xml:space="preserve">
          <source>If an edge is emanating from v and incident on w, then w is said to be an  &lt;strong id=&quot;out_neighbour&quot;&gt;out-neighbor&lt;/strong&gt; of v, and v is said to be an &lt;strong id=&quot;in_neighbour&quot;&gt;in-neighbor&lt;/strong&gt; of w.</source>
          <target state="translated">Если ребро исходит из v и инцидентно с w, то w называется внешним &lt;strong id=&quot;out_neighbour&quot;&gt;соседом&lt;/strong&gt; v, а v - внутренним &lt;strong id=&quot;in_neighbour&quot;&gt;соседом&lt;/strong&gt; w.</target>
        </trans-unit>
        <trans-unit id="a481b829b72ba85ee7ff861e87909f902fa230b7" translate="yes" xml:space="preserve">
          <source>If an employee started 1997 or later, but before 2001, return &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">Если сотрудник начал работу в 1997 году или позже, но до 2001 года, верните &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="267d94e1e64e36b71e95d1e768da8da0ab4dabd6" translate="yes" xml:space="preserve">
          <source>If an employee started before 1997, return the tuple &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">Если сотрудник начал работу до 1997 года, верните кортеж &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b9b3a599385dc1e77b6effb7fdcc0ba87017325" translate="yes" xml:space="preserve">
          <source>If an emulator restart is necessary and no upgrade instructions are needed, that is, if the restart itself is enough for the upgraded applications to start running the new versions, a simple &lt;code&gt;relup&lt;/code&gt; file can be created manually:</source>
          <target state="translated">Если перезапуск эмулятора необходим и инструкции по обновлению не требуются, то есть если самого перезапуска достаточно для того, чтобы обновленные приложения начали запускать новые версии, можно вручную создать простой файл &lt;code&gt;relup&lt;/code&gt; установки:</target>
        </trans-unit>
        <trans-unit id="0be98b96fbc89792dcc19067b12124fdf6e59e27" translate="yes" xml:space="preserve">
          <source>If an encode error takes place during retransmission then the request process fails and &lt;code&gt;{error,failure}&lt;/code&gt; is returned.</source>
          <target state="translated">Если во время повторной передачи происходит ошибка кодирования, то процесс запроса завершается ошибкой и возвращается &lt;code&gt;{error,failure}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d90f4b09c609d55842d57250ea621c86bccd2a5" translate="yes" xml:space="preserve">
          <source>If an entire packet is contained in &lt;code&gt;Bin&lt;/code&gt;, it is returned together with the remainder of the binary as &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt;.</source>
          <target state="translated">Если в &lt;code&gt;Bin&lt;/code&gt; содержится весь пакет , он возвращается вместе с остатком двоичного файла как &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="811984ae5951261acbbb238684d0b7c77bf502d9" translate="yes" xml:space="preserve">
          <source>If an error code is returned, the port is not started.</source>
          <target state="translated">При возврате кода ошибки порт не запускается.</target>
        </trans-unit>
        <trans-unit id="da4e739db10805f14ff747b7b4e80017ae2c1b09" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Если в файле конфигурации обнаружена ошибка, об этом сообщается с помощью функции &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; модуля отчета об ошибках, и функция завершается ошибкой по причине &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9669e70dbc35431ddeb5cae9c621269171a463e4" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the , and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Если в файле конфигурации обнаружена ошибка, об этом сообщается с помощью функции &lt;code&gt;config_err/2&lt;/code&gt; , и функция завершается с ошибкой по причине &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16106449fe5fc75aadfe943e285574d04cf0155a" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Если в файле конфигурации обнаружена ошибка, об этом сообщается с помощью функции &lt;code&gt;config_err/2&lt;/code&gt; модуля отчета об ошибках, и функция завершается ошибкой по причине &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f27e177a4e1612c45d2451a4b610d2b6a6e50b1" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Если в файле конфигурации обнаружена ошибка, об этом сообщается с помощью функции &lt;code&gt;config_err/2&lt;/code&gt; модуля отчета об ошибках, и функция завершается ошибкой по причине &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32a6f97b5644649bdcac70889144dbc30cbf50c8" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error, report module and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Если в файле конфигурации обнаружена ошибка, об этом сообщается с помощью функции &lt;code&gt;config_err/2&lt;/code&gt; ошибки, модуля отчета, и функция завершается с ошибкой по причине &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bbaf85823709f47c63afa4741f86471e008208" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can be due to errors in compilation of the match specification. Such errors are presented as a list of tuples &lt;code&gt;{error, string()}&lt;/code&gt; where the string is a textual explanation of the compilation error. An example:</source>
          <target state="translated">Если возвращается ошибка, это может быть связано с ошибками при составлении спецификации соответствия. Такие ошибки представлены в виде списка кортежей &lt;code&gt;{error, string()}&lt;/code&gt; где строка является текстовым объяснением ошибки компиляции. Пример:</target>
        </trans-unit>
        <trans-unit id="4a4d238b84b9d8f7ce4275d02e1e061ea04cf76d" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can either be due to a tracer server already running (&lt;code&gt;{error,already_started}&lt;/code&gt;) or due to the &lt;code&gt;HandlerFun&lt;/code&gt; throwing an exception.</source>
          <target state="translated">Если возвращается ошибка, это может быть связано либо с уже запущенным сервером трассировки ( &lt;code&gt;{error,already_started}&lt;/code&gt; ), либо с &lt;code&gt;HandlerFun&lt;/code&gt; , генерирующим исключение.</target>
        </trans-unit>
        <trans-unit id="4e9dbcebd3f214207a33235b48bfaaf49bf5e244" translate="yes" xml:space="preserve">
          <source>If an error occurred, this function is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function is called. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">Если произошла ошибка, эта функция вызывается после &lt;code&gt;is_set_ok&lt;/code&gt; функции is_set_ok . Если для этого объекта вызывается &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;undo&lt;/code&gt; не вызывается.</target>
        </trans-unit>
        <trans-unit id="4ffdf980152bda82758e93fa5363e955a51a162e" translate="yes" xml:space="preserve">
          <source>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</source>
          <target state="translated">Если во время установки произошла ошибка,система перезагружается,используя старую версию релиза.Если установка прошла успешно,то после этого система использует новую версию релиза,но если что-то происходит и система перезагружается,то она снова начинает использовать предыдущую версию.</target>
        </trans-unit>
        <trans-unit id="e3b9183a591452f1c5ebde1eae8e316833b13a50" translate="yes" xml:space="preserve">
          <source>If an error occurs on the socket, the following message is delivered (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Если в сокете возникает ошибка, доставляется следующее сообщение (если в списке опций для сокета не указано &lt;code&gt;{active, false}&lt;/code&gt; , и в этом случае пакеты извлекаются путем вызова &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ee097c045f410ae6ef1682702f02130e44879ffb" translate="yes" xml:space="preserve">
          <source>If an error occurs when accessing an open file with module &lt;code&gt;io&lt;/code&gt;, the process handling the file exits. The dead file process can hang if a process tries to access it later. This will be fixed in a future release.</source>
          <target state="translated">Если при доступе к открытому файлу с помощью модуля &lt;code&gt;io&lt;/code&gt; возникает ошибка , процесс обработки файла завершается. Мертвый файловый процесс может зависнуть, если процесс попытается получить к нему доступ позже. Это будет исправлено в следующем выпуске.</target>
        </trans-unit>
        <trans-unit id="1e80b8f25b6627161bccd2087c0375b81e9072e8" translate="yes" xml:space="preserve">
          <source>If an error occurs, The function &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">В случае возникновения ошибки функция &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; вызывается после функции &lt;code&gt;is_set_ok&lt;/code&gt; . Если для этого объекта вызывается &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;undo&lt;/code&gt; не вызывается.</target>
        </trans-unit>
        <trans-unit id="ae997c53a260dda31bdd5632662979a9e41a9ab0" translate="yes" xml:space="preserve">
          <source>If an error occurs, either in the &lt;code&gt;is_set_ok&lt;/code&gt; phase, or in the &lt;code&gt;set&lt;/code&gt; phase, all functions which were called with &lt;code&gt;is_set_ok&lt;/code&gt; but not &lt;code&gt;set&lt;/code&gt;, are called with &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">Если возникает ошибка, либо на этапе &lt;code&gt;is_set_ok&lt;/code&gt; , либо на этапе &lt;code&gt;set&lt;/code&gt; , все функции, которые были вызваны с &lt;code&gt;is_set_ok&lt;/code&gt; , но не были &lt;code&gt;set&lt;/code&gt; , вызываются с &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276746b794853efb127f75c7e5ec07717c8d976f" translate="yes" xml:space="preserve">
          <source>If an error occurs, the applications started by the function are stopped to bring the set of running applications back to its initial state.</source>
          <target state="translated">При возникновении ошибки приложения,запущенные функцией,останавливаются,чтобы вернуть набор запущенных приложений в исходное состояние.</target>
        </trans-unit>
        <trans-unit id="5c1a2d5fdbf25c48c2a0e3dd8bc47d65a9c912ff" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">Если возникает ошибка, процесс завершается с набором ошибок &lt;code&gt;{error, Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198b396c8242aa281ca2808a3e1fe29feecf86f5" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;. The error tuple is not returned, as it cannot be distinguished from a key.</source>
          <target state="translated">Если возникает ошибка, процесс завершается с набором ошибок &lt;code&gt;{error, Reason}&lt;/code&gt; . Кортеж с ошибкой не возвращается, так как его нельзя отличить от ключа.</target>
        </trans-unit>
        <trans-unit id="9366b8a06735f2ef6c5bd64e2d4894f28c5e9fd9" translate="yes" xml:space="preserve">
          <source>If an error occurs, the stack trace becomes empty in this case.</source>
          <target state="translated">При возникновении ошибки трасса стека в этом случае становится пустой.</target>
        </trans-unit>
        <trans-unit id="5334f6f487ef5e94e1d3f8d91a903cad1c7ae4ca" translate="yes" xml:space="preserve">
          <source>If an error occurs, there is no output. Example:</source>
          <target state="translated">При возникновении ошибки выходной сигнал отсутствует.Пример:</target>
        </trans-unit>
        <trans-unit id="eaf4f64d81bc2ecc63f1691d3a8ab14648012ce3" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;AfterBody&lt;/code&gt; itself, it is not caught. So if &lt;code&gt;AfterBody&lt;/code&gt; is evaluated after an exception in &lt;code&gt;Exprs&lt;/code&gt;, &lt;code&gt;Body&lt;/code&gt;, or &lt;code&gt;ExceptionBody&lt;/code&gt;, that exception is lost and masked by the exception in &lt;code&gt;AfterBody&lt;/code&gt;.</source>
          <target state="translated">Если во время оценки самого &lt;code&gt;AfterBody&lt;/code&gt; возникает исключение , оно не обнаруживается . Итак, если &lt;code&gt;AfterBody&lt;/code&gt; оценивается после исключения в &lt;code&gt;Exprs&lt;/code&gt; , &lt;code&gt;Body&lt;/code&gt; или &lt;code&gt;ExceptionBody&lt;/code&gt; , это исключение теряется и маскируется исключением в &lt;code&gt;AfterBody&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73b3692cd35fbb24365c57783d388c12c52b16ba" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;ExceptionBody&lt;/code&gt;, it is not caught.</source>
          <target state="translated">Если во время оценки &lt;code&gt;ExceptionBody&lt;/code&gt; возникает исключение , оно не перехватывается.</target>
        </trans-unit>
        <trans-unit id="15e21c88415fba00ea3b007d2430e70dde7b38c0" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;Exprs&lt;/code&gt; but there is no matching &lt;code&gt;ExceptionPattern&lt;/code&gt; of the right &lt;code&gt;Class&lt;/code&gt; with a true guard sequence, the exception is passed on as if &lt;code&gt;Exprs&lt;/code&gt; had not been enclosed in a &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">Если во время оценки &lt;code&gt;Exprs&lt;/code&gt; возникает исключение, но нет соответствия &lt;code&gt;ExceptionPattern&lt;/code&gt; правильного &lt;code&gt;Class&lt;/code&gt; с истинной защитной последовательностью, исключение передается, как если бы &lt;code&gt;Exprs&lt;/code&gt; не были заключены в выражение &lt;code&gt;try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d16bf5cd6125b26b68df1e48e19c1d35055d07b" translate="yes" xml:space="preserve">
          <source>If an exit signal is received as above, the tuple &lt;code&gt;{From,Name}&lt;/code&gt; is deleted from the servers &lt;code&gt;User_List&lt;/code&gt; using the &lt;code&gt;server_logoff&lt;/code&gt; function. If the node on which the server runs goes down, an exit signal (automatically generated by the system) is sent to all of the client processes: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; causing all the client processes to terminate.</source>
          <target state="translated">Если получен сигнал выхода, как указано выше, кортеж &lt;code&gt;{From,Name}&lt;/code&gt; удаляется с серверов &lt;code&gt;User_List&lt;/code&gt; с &lt;code&gt;server_logoff&lt;/code&gt; функции server_logoff . Если узел, на котором работает сервер, выходит из строя, сигнал выхода (автоматически генерируемый системой) отправляется всем клиентским процессам: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; , вызывая завершение всех клиентских процессов.</target>
        </trans-unit>
        <trans-unit id="b7e0ea0cc95b3d589060e057229e831ff5a8ff4e" translate="yes" xml:space="preserve">
          <source>If an instrumentation function in the association file for a variable &lt;code&gt;myVar&lt;/code&gt; does not have a name when compiling an MIB, the compiler generates an entry.</source>
          <target state="translated">Если инструментальная функция в файле ассоциации для переменной &lt;code&gt;myVar&lt;/code&gt; не имеет имени при компиляции MIB, компилятор создает запись.</target>
        </trans-unit>
        <trans-unit id="b4e274b3831003e60f76d89037c8e16f5e3d04d9" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt; Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4901f204507135ee6a79147a0e0e1064225a4fc4" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="translated">Если значение тайма-аут целого обеспечиваются, тайм-аут не происходит , если запрос или сообщения будут получены в течение &lt;code&gt;Timeout&lt;/code&gt; миллисекунд. &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; -аут представлен &lt;code&gt;timeout&lt;/code&gt; атома , который должен обрабатываться функцией обратного вызова Module: handle_info / 2 . &lt;code&gt;infinity&lt;/code&gt; атома может использоваться для ожидания неограниченное время, это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f34784d34b261e41d724f171d45d4c2db9bc38eb" translate="yes" xml:space="preserve">
          <source>If an option is set in more than one way, what happens?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c317bf8995de9827a88e47cfa9f960f031966c21" translate="yes" xml:space="preserve">
          <source>If an owner attempts to open a log as owner once again, it is acknowledged with the return value &lt;code&gt;{ok, Log}&lt;/code&gt;, but the state of the disk log is not affected.</source>
          <target state="translated">Если владелец пытается открыть журнал в качестве владельца еще раз, это подтверждается возвращаемым значением &lt;code&gt;{ok, Log}&lt;/code&gt; , но это не влияет на состояние журнала диска.</target>
        </trans-unit>
        <trans-unit id="6d1c8f7e5679322dcbb64d8108251b9319c084c5" translate="yes" xml:space="preserve">
          <source>If an unrecognized type option &lt;code&gt;T&lt;/code&gt; is specified or &lt;code&gt;Type&lt;/code&gt; is not a proper list, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если указан параметр &lt;code&gt;T&lt;/code&gt; нераспознанного типа или &lt;code&gt;Type&lt;/code&gt; не является правильным списком, &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="5edd7e14ee514521a82d9d312927e864fd8b6b43" translate="yes" xml:space="preserve">
          <source>If an unsupported algorithm is in the &lt;code&gt;modify_algs_list()&lt;/code&gt;, it will be silently ignored</source>
          <target state="translated">Если неподдерживаемый алгоритм находится в &lt;code&gt;modify_algs_list()&lt;/code&gt; , он будет автоматически проигнорирован</target>
        </trans-unit>
        <trans-unit id="ac90fe515c674df1b687955496c9be8fee6118f2" translate="yes" xml:space="preserve">
          <source>If an upgrade includes a change from an emulator earlier than OTP R15 to OTP R15 or later, the warning &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; is issued. For more information about this, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">Если обновление включает в себя переход от эмулятора до OTP R15 к OTP R15 или более позднему, &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; предупреждение pre_R15_emulator_upgrade . Для получения дополнительной информации об этом см. &lt;code&gt;Design Principles&lt;/code&gt; в &lt;strong&gt;системной документации&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c2bc5a0b1d5c34b06e7086cddd297167569f7462" translate="yes" xml:space="preserve">
          <source>If and how to compress the message. Examples are &lt;code&gt;none&lt;/code&gt;, that is, no compression and &lt;code&gt;zlib&lt;/code&gt;.</source>
          <target state="translated">Если и как сжать сообщение. Примеров &lt;code&gt;none&lt;/code&gt; , то есть без сжатия и &lt;code&gt;zlib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7a133c6b3bee84f3bf4462f30e02bb30fa3e98" translate="yes" xml:space="preserve">
          <source>If and only if the Unicode translation modifier is used in the format string (that is, &lt;code&gt;~ts&lt;/code&gt; or &lt;code&gt;~tc&lt;/code&gt;), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &amp;gt; 255). If so, the result is still an ordinary Erlang &lt;code&gt;string()&lt;/code&gt;, and can well be used in any context where Unicode data is allowed.</source>
          <target state="translated">Если и только если модификатор перевода Unicode используется в строке формата (то есть &lt;code&gt;~ts&lt;/code&gt; или &lt;code&gt;~tc&lt;/code&gt; ), результирующий список может содержать символы за пределами диапазона символов ISO Latin-1 (то есть числа&amp;gt; 255). Если это так, результатом будет обычная &lt;code&gt;string()&lt;/code&gt; Erlang () , и ее можно будет использовать в любом контексте, где разрешены данные Unicode.</target>
        </trans-unit>
        <trans-unit id="8c687f2de4701a7ffef4cc4c42ee7473077335c1" translate="yes" xml:space="preserve">
          <source>If and when you would like to start and manipulate &lt;code&gt;Mnesia&lt;/code&gt;, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. &lt;code&gt;Mnesia&lt;/code&gt; can be initialized with data read from a text file. The following two functions can be used to work with text files.</source>
          <target state="translated">Если и когда вы захотите запустить &lt;code&gt;Mnesia&lt;/code&gt; и управлять ею, часто проще записать определения и данные в обычный текстовый файл. Изначально ни таблицы, ни данные не существуют, ни какие таблицы требуются. На начальных этапах создания прототипа целесообразно записать все данные в один файл, обработать этот файл и вставить данные из файла в базу данных. &lt;code&gt;Mnesia&lt;/code&gt; может быть инициализирован данными, считанными из текстового файла. Следующие две функции могут использоваться для работы с текстовыми файлами.</target>
        </trans-unit>
        <trans-unit id="80417b144fe2bc5c20d55da668bc56d430c25c36" translate="yes" xml:space="preserve">
          <source>If another implementation of any of these variables is needed, e.g. to store the persistent variables in a Mnesia database, an own implementation of the variables must be made. That MIB will be compiled and loaded instead of the default MIB. The new compiled MIB must have the same name as the original MIB (i.e. STANDARD-MIB or SNMPv2-MIB), and be located in the SNMP configuration directory (see &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Если требуется другая реализация любой из этих переменных, например, для хранения постоянных переменных в базе данных Mnesia, должна быть создана собственная реализация переменных. Этот MIB будет скомпилирован и загружен вместо MIB по умолчанию. Новый скомпилированный MIB должен иметь то же имя, что и исходный MIB (например, STANDARD-MIB или SNMPv2-MIB), и находиться в каталоге конфигурации SNMP (см. &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a2491a0f8f402474246f9fb8f195513ec14b76dd" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; is present, the one with the highest level is used, that is, the &lt;code&gt;Option&lt;/code&gt; list parameter has the highest priority. Then the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; on all levels in order starting with level 0 are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ee411849a587dd3deef8de9d6f9689dcf9ebe0" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Dir&lt;/code&gt; is not a directory name</source>
          <target state="translated">Если любой &lt;code&gt;Dir&lt;/code&gt; не является именем каталога</target>
        </trans-unit>
        <trans-unit id="7226b47ac607cfe4ee033cbac112e9d47878f35b" translate="yes" xml:space="preserve">
          <source>If any Erlang process &lt;code&gt;Pid&lt;/code&gt; in the system has allocated more than a certain amount of total system memory, the alarm &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; is set.</source>
          <target state="translated">Если какой-либо &lt;code&gt;Pid&lt;/code&gt; процесса Erlang в системе выделил более определенного количества общей системной памяти, устанавливается сигнал тревоги &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56bae9cc860914f3d89871e3baff9cb1dcabb640" translate="yes" xml:space="preserve">
          <source>If any HTTP header fields are added by the script, they must be in the first call to &lt;code&gt;deliver/2&lt;/code&gt;, and the data in the call must be a string. Calls after the headers are complete can contain binary data to reduce copying overhead. Do not assume anything about the data type of &lt;code&gt;SessionID&lt;/code&gt;. &lt;code&gt;SessionID&lt;/code&gt; must be the value given as input to the ESI callback function that you implemented.</source>
          <target state="translated">Если какие-либо поля заголовка HTTP добавляются сценарием, они должны быть в первом вызове для &lt;code&gt;deliver/2&lt;/code&gt; , а данные в вызове должны быть строкой. Вызовы после завершения заголовков могут содержать двоичные данные для уменьшения накладных расходов на копирование. Не предполагайте ничего о типе данных &lt;code&gt;SessionID&lt;/code&gt; . &lt;code&gt;SessionID&lt;/code&gt; должен быть значением, указанным в качестве входных данных для реализованной вами функции обратного вызова ESI.</target>
        </trans-unit>
        <trans-unit id="5adb78f4f1efbc66139e964187c434397d354611" translate="yes" xml:space="preserve">
          <source>If any argument has the wrong format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b51878bfcad40bdb7c8e819fd02580c5711eff" translate="yes" xml:space="preserve">
          <source>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason &lt;code&gt;shutdown&lt;/code&gt; and then terminate itself and returns &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt;.</source>
          <target state="translated">Если какая-либо функция запуска дочернего процесса дает сбой или возвращает кортеж с ошибкой или ошибочное значение, супервизор сначала завершает все уже запущенные дочерние процессы с указанием причины &lt;code&gt;shutdown&lt;/code&gt; , а затем завершает себя и возвращает &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd2be4d8ca214fa53676834f412514083348fde" translate="yes" xml:space="preserve">
          <source>If any functions (for example, Telnet or FTP) using &quot;required configuration data&quot; are to be called from the Erlang shell, configuration data must first be required with &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если какие-либо функции (например, Telnet или FTP), использующие &amp;laquo;требуемые данные конфигурации&amp;raquo;, должны быть вызваны из оболочки Erlang, данные конфигурации должны сначала потребоваться с помощью &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="784d2fd65e27ddf88a5b740f50b285e092cfde1d" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt; ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f4af54f6decb45db597b9e963b792ae46e26cb" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если какие-либо функции, использующие &amp;laquo;требуемые данные конфигурации&amp;raquo; (например, функции &lt;code&gt;ct_telnet&lt;/code&gt; или &lt;code&gt;ct_ftp&lt;/code&gt; ) должны быть вызваны из оболочки Erlang, сначала требуются данные конфигурации с помощью &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; . Это эквивалентно оператору &lt;code&gt;require&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; или в &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50c6245e20c77d69a688a02f4c540697d905913f" translate="yes" xml:space="preserve">
          <source>If any of the arguments are invalid, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если какой-либо из аргументов недействителен, &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="b3295c7085224a5c975d29da6224a233ad1e1a01" translate="yes" xml:space="preserve">
          <source>If any of the socket &lt;code&gt;&lt;a href=&quot;#type-option&quot;&gt;options&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; are active, the &lt;code&gt;RecvData&lt;/code&gt; tuple contains an &lt;code&gt;AncData&lt;/code&gt; field, otherwise it does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692ed4da2eebf1c4f217366a6369dae2f3d80d78" translate="yes" xml:space="preserve">
          <source>If any of the tables does not exist or the Dets table is not open, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если какая-либо из таблиц не существует или таблица &lt;code&gt;badarg&lt;/code&gt; не открыта, возникает исключение badarg .</target>
        </trans-unit>
        <trans-unit id="570be644a648abf241c9b8dd2548fe13d19dd232" translate="yes" xml:space="preserve">
          <source>If any of these errors occur when &lt;code&gt;+sbt&lt;/code&gt; has been passed, the runtime system prints an error message, and refuses to start. If any of these errors occur when &lt;code&gt;+stbt&lt;/code&gt; has been passed, the runtime system silently ignores the error, and start up using unbound schedulers.</source>
          <target state="translated">Если при &lt;code&gt;+sbt&lt;/code&gt; возникает какая-либо из этих ошибок , система времени выполнения выводит сообщение об ошибке и отказывается запускаться. Если какая-либо из этих ошибок возникает при &lt;code&gt;+stbt&lt;/code&gt; , система времени выполнения молча игнорирует ошибку и запускается с использованием несвязанных планировщиков.</target>
        </trans-unit>
        <trans-unit id="eaa7aa976033707bd386e9983d12159b899132bc" translate="yes" xml:space="preserve">
          <source>If any one of these are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96761e0bc247ac872393ae1bb5eb9df6c975a841" translate="yes" xml:space="preserve">
          <source>If any position specified in &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; size of the replacement binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если любая позиция, указанная в &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; размер заменяющего двоичного &lt;code&gt;badarg&lt;/code&gt; , возникает исключение badarg .</target>
        </trans-unit>
        <trans-unit id="e3ad0f81da4a204750014fc62764a9cd40b26ee9" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;-daemon&lt;/code&gt; is not specified, &lt;code&gt;epmd&lt;/code&gt; runs as a normal program with the controlling terminal of the shell in which it is started. Normally, it is to be run as a daemon.</source>
          <target state="translated">Если аргумент &lt;code&gt;-daemon&lt;/code&gt; не указан, &lt;code&gt;epmd&lt;/code&gt; запускается как обычная программа с управляющим терминалом оболочки, в которой он запущен. Обычно он запускается как демон.</target>
        </trans-unit>
        <trans-unit id="dca95539f85ceb7c7fbb3f3a95acdd29f703f0c8" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Archive&lt;/code&gt; is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename.</source>
          <target state="translated">Если аргумент &lt;code&gt;Archive&lt;/code&gt; задан как двоичный, предполагается, что содержимое двоичного файла представляет собой zip-архив, в противном случае - имя файла.</target>
        </trans-unit>
        <trans-unit id="4234f7b924c77e169e97fc3a3a0a5fff439177f4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;MFA&lt;/code&gt; is the atom &lt;code&gt;on_load&lt;/code&gt;, the match specification and flag list are used on all modules that are newly loaded.</source>
          <target state="translated">Если аргумент &lt;code&gt;MFA&lt;/code&gt; - это атом &lt;code&gt;on_load&lt;/code&gt; , спецификация соответствия и список флагов используются для всех загружаемых модулей.</target>
        </trans-unit>
        <trans-unit id="5218de8ae45e50ce943a78eed5b9597b86f9e98a" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{binary,Binary}&lt;/code&gt;, the contents of the binary is assumed to be a tar archive.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; аргумента указано как &lt;code&gt;{binary,Binary}&lt;/code&gt; , предполагается, что содержимое двоичного файла является tar-архивом.</target>
        </trans-unit>
        <trans-unit id="2a16809777595118890feda8207e9529558557f0" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{file,Fd}&lt;/code&gt;, &lt;code&gt;Fd&lt;/code&gt; is assumed to be a file descriptor returned from function &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; аргумента указано как &lt;code&gt;{file,Fd}&lt;/code&gt; , &lt;code&gt;Fd&lt;/code&gt; считается файловым дескриптором, возвращаемым функцией &lt;code&gt;file:open/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8eca364f037b451eb12fd01d43884ccc2a4bd5d4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;type&lt;/code&gt; is specified, all loaded reports of this type are displayed. If an integer argument is specified, the report with this reference number is displayed. If no argument is specified, all reports are displayed.</source>
          <target state="translated">Если указан &lt;code&gt;type&lt;/code&gt; аргумента , отображаются все загруженные отчеты этого типа. Если указан целочисленный аргумент, отображается отчет с этим справочным номером. Если аргумент не указан, отображаются все отчеты.</target>
        </trans-unit>
        <trans-unit id="7d9ccdcf897aa5e543e57f74baa9344de03cc64a" translate="yes" xml:space="preserve">
          <source>If atom &lt;code&gt;start&lt;/code&gt; is specified as continuation, a disk log to read terms from is chosen. A local or distributed disk log on the current node is preferred to an individual distributed log on some other node.</source>
          <target state="translated">Если &lt;code&gt;start&lt;/code&gt; атома указано как продолжение, выбирается дисковый журнал для чтения терминов. Локальный или распределенный дисковый журнал на текущем узле предпочтительнее отдельного распределенного журнала на каком-либо другом узле.</target>
        </trans-unit>
        <trans-unit id="c7c06078653d000d4834d7b538bf165c25d0318c" translate="yes" xml:space="preserve">
          <source>If atomic grouping is used for the previous example, the matcher gives up immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of special parenthesis, starting with &lt;code&gt;(?&amp;gt;&lt;/code&gt; as in the following example:</source>
          <target state="translated">Если для предыдущего примера используется атомарная группировка, средство сопоставления немедленно прекращает работу, если не удается сопоставить &amp;laquo;foo&amp;raquo; в первый раз. Обозначения - это своего рода специальные скобки, начинающиеся с &lt;code&gt;(?&amp;gt;&lt;/code&gt; , Как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="6a9902259e3c589622f30bf01a90d5b7ffcb0cc1" translate="yes" xml:space="preserve">
          <source>If attribute &lt;code&gt;{local_content, true}&lt;/code&gt; is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</source>
          <target state="translated">Если атрибут &lt;code&gt;{local_content, true}&lt;/code&gt; указан при создании таблицы, таблица находится на узлах, на которых вы указываете, что таблица существует, но операции записи в таблицу выполняются только в локальной копии.</target>
        </trans-unit>
        <trans-unit id="ebd8d24d8a76114c5ed2e0d95e53c4aab5d47e75" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application.</source>
          <target state="translated">Если используется аутентификация или шифрование (только SNMPv3), запустите &lt;code&gt;crypto&lt;/code&gt; приложение.</target>
        </trans-unit>
        <trans-unit id="b32ca34021019e0bb153a3955d0b724a94e48269" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application. If this step is forgotten, the agent will not start, but report a &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; error.</source>
          <target state="translated">Если используется аутентификация или шифрование (только SNMPv3), запустите &lt;code&gt;crypto&lt;/code&gt; приложение. Если этот шаг забыт, агент не запустится, но сообщит об &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a84fea11161ee2b8221ded08279d7f5da6e7793e" translate="yes" xml:space="preserve">
          <source>If auto-skipped test cases do not affect the exit status. The default behavior can be changed using start flag:</source>
          <target state="translated">Если автоматически пропущенные тестовые случаи не влияют на статус выхода.Поведение по умолчанию может быть изменено с помощью флага запуска:</target>
        </trans-unit>
        <trans-unit id="a54c92e18be4a676b9c1c2d1749ff8f920d1f0f1" translate="yes" xml:space="preserve">
          <source>If automatic commit mode is turned on, each query will be considered as an individual transaction and will be automatically committed after it has been executed. If you want more than one query to be part of the same transaction the automatic commit mode should be turned off. Then you will have to call commit/3 explicitly to end a transaction.</source>
          <target state="translated">Если включен режим автоматической фиксации,то каждый запрос будет считаться отдельной транзакцией и будет автоматически зафиксирован после ее выполнения.Если вы хотите,чтобы несколько запросов были частью одной и той же транзакции,режим автоматической фиксации должен быть выключен.Тогда для завершения транзакции вам придется явно вызывать коммит/3.</target>
        </trans-unit>
        <trans-unit id="fe29c622b52d7e166afb8b3558351d082aa789d3" translate="yes" xml:space="preserve">
          <source>If available in the dump, this is the total number of atoms in the atom table. If the size of the atom table is unavailable, the number of atoms visible in the dump is displayed.</source>
          <target state="translated">Если доступно в дампе,то это общее количество атомов в таблице атомов.Если размер таблицы атомов недоступен,отображается количество атомов,видимых в дампе.</target>
        </trans-unit>
        <trans-unit id="1614181d9da9b94aedfb64164481447f45935dca" translate="yes" xml:space="preserve">
          <source>If binaries that are no longer used are to be thrown away as soon as possible. (Set &lt;code&gt;Number&lt;/code&gt; to zero.)</source>
          <target state="translated">Если двоичные файлы, которые больше не используются, необходимо как можно скорее выбросить. (Установите &lt;code&gt;Number&lt;/code&gt; в ноль.)</target>
        </trans-unit>
        <trans-unit id="88996aec0b15ab1d16ddf824ee8cf7cd32e2a161" translate="yes" xml:space="preserve">
          <source>If binding of schedulers is not supported.</source>
          <target state="translated">Если привязка планировщиков не поддерживается.</target>
        </trans-unit>
        <trans-unit id="90d98aa8f41f34030c7bdee94cac730737033718" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Destination&lt;/code&gt; refer to filenames, the files are opened with &lt;code&gt;[read, binary]&lt;/code&gt; and &lt;code&gt;[write, binary]&lt;/code&gt; prepended to their mode lists, respectively, to optimize the copy.</source>
          <target state="translated">Если и &lt;code&gt;Source&lt;/code&gt; и &lt;code&gt;Destination&lt;/code&gt; относятся к именам файлов, файлы открываются с &lt;code&gt;[read, binary]&lt;/code&gt; и &lt;code&gt;[write, binary]&lt;/code&gt; добавленными к их спискам режимов, соответственно, для оптимизации копирования.</target>
        </trans-unit>
        <trans-unit id="2c3e1b70d92e6d563bb5e9d6c3cd26f59813a13f" translate="yes" xml:space="preserve">
          <source>If call count tracing is started while already running, the count is restarted from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">Если отслеживание счетчика вызовов запускается, когда оно уже запущено, счетчик перезапускается с нуля. Чтобы приостановить работу счетчиков, используйте &lt;code&gt;MatchSpec == pause&lt;/code&gt; . Приостановленные и работающие счетчики могут быть перезапущены с нуля с помощью &lt;code&gt;MatchSpec == restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ddb54b87a2d744f4668c0309f8b603f7cbd2a39" translate="yes" xml:space="preserve">
          <source>If call counters are still running while &lt;code&gt;analyse/0..2&lt;/code&gt; is executing, you might get an inconsistent result. This happens if the process executing &lt;code&gt;analyse/0..2&lt;/code&gt; gets scheduled out so some other process can increment the counters that are being analysed, Calling &lt;code&gt;pause()&lt;/code&gt; before analysing takes care of the problem.</source>
          <target state="translated">Если счетчики вызовов все еще работают, пока выполняется &lt;code&gt;analyse/0..2&lt;/code&gt; , вы можете получить противоречивый результат. Это происходит, если процесс, выполняющий &lt;code&gt;analyse/0..2&lt;/code&gt; запланирован, чтобы какой-то другой процесс мог увеличить счетчики, которые анализируются, вызов &lt;code&gt;pause()&lt;/code&gt; перед анализом решит проблему.</target>
        </trans-unit>
        <trans-unit id="ad4325523bd9822e6e53cf121c4e7f2d415527ec" translate="yes" xml:space="preserve">
          <source>If call time tracing is started while already running, the count and time restart from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">Если отслеживание времени вызова запускается, когда оно уже запущено, счетчик и время перезапускаются с нуля. Чтобы приостановить работу счетчиков, используйте &lt;code&gt;MatchSpec == pause&lt;/code&gt; . Приостановленные и работающие счетчики могут быть перезапущены с нуля с помощью &lt;code&gt;MatchSpec == restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8441a1f4ebffc73cdc2dc005353bc55ee1751fa1" translate="yes" xml:space="preserve">
          <source>If called several times, only the last comment is printed. The test case return value &lt;code&gt;{comment,Comment}&lt;/code&gt; overwrites the string set by this function.</source>
          <target state="translated">При вызове несколько раз печатается только последний комментарий. Возвращаемое значение тестового примера &lt;code&gt;{comment,Comment}&lt;/code&gt; перезаписывает строку, установленную этой функцией.</target>
        </trans-unit>
        <trans-unit id="ada9d2aefe42bda67c41d0801c3618aeb38428b7" translate="yes" xml:space="preserve">
          <source>If called with an extension unknown to the user application, return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">Если &lt;code&gt;{unknown, UserState}&lt;/code&gt; с расширением, неизвестным пользовательскому приложению, должно использоваться возвращаемое значение {unknown, UserState} .</target>
        </trans-unit>
        <trans-unit id="610648cf712693e340f20ab9aac63c6b94c019dc" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;FormatFun&lt;/code&gt; with an argument including &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; fails, &lt;code&gt;FormatFun&lt;/code&gt; is called once again with an argument excluding &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; (&lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt;).</source>
          <target state="translated">Если вызов &lt;code&gt;FormatFun&lt;/code&gt; с аргументом, включающим &lt;code&gt;NElements&lt;/code&gt; и &lt;code&gt;DepthFun&lt;/code&gt; , завершается неудачно, &lt;code&gt;FormatFun&lt;/code&gt; вызывается еще раз с аргументом, исключающим &lt;code&gt;NElements&lt;/code&gt; и &lt;code&gt;DepthFun&lt;/code&gt; ( &lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; или &lt;code&gt;all&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="77f72ab6f85f6c9d8cbda669ebba998dc661fc5e" translate="yes" xml:space="preserve">
          <source>If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, although the original capturing subpattern is matched caselessly:</source>
          <target state="translated">Если на момент обратной ссылки действует казуальное совпадение,регистр букв является релевантным.Например,следующее соответствует &quot;rah rah&quot; и &quot;RAH RAH&quot;,но не &quot;RAH rah&quot;,хотя исходная подмаска для захвата безошибочно совпадает:</target>
        </trans-unit>
        <trans-unit id="e13d741efb191e9fa7c1727072c2302000c01f26" translate="yes" xml:space="preserve">
          <source>If certain port-specific data must be accessed from other threads than those calling the driver callbacks, a port data lock can be used to synchronize the operations on the data. Currently, the only port-specific data that the emulator associates with the port data lock is the driver queue.</source>
          <target state="translated">Если определенные данные по портам должны быть доступны из других потоков,кроме тех,которые вызывают обратные вызовы драйвера,то для синхронизации операций с данными можно использовать блокировку данных по портам.В настоящее время единственными данными по портам,которые эмулятор связывает с блокировкой данных по порту,является очередь драйвера.</target>
        </trans-unit>
        <trans-unit id="cd4b4afe54513271fef096e7c304b9cfa2e00765" translate="yes" xml:space="preserve">
          <source>If command line option +MMscrpm (Reserve Physical Memory) is set to false, only virtual space is allocated for the super carrier from start. The super carrier then acts as an &quot;alternative mmap&quot; implementation without changing the consumption of physical memory pages. Physical pages will be reserved on demand when an allocation is done from the super carrier and be unreserved when the memory is released back to the super carrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54d5e9e6d2fd31d6eabb83cccb9c261c4f828a5" translate="yes" xml:space="preserve">
          <source>If compilation fails for one or more suites, the compilation errors are printed to tty and the operator is asked if the test run is to proceed without the missing suites, or be aborted. If the operator chooses to proceed, the tests having missing suites are noted in the HTML log. If &lt;code&gt;Common Test&lt;/code&gt; is unable to prompt the user after compilation failure (if &lt;code&gt;Common Test&lt;/code&gt; does not control &lt;code&gt;stdin&lt;/code&gt;), the test run proceeds automatically without the missing suites. This behavior can however be modified with the &lt;code&gt;ct_run&lt;/code&gt; flag &lt;code&gt;-abort_if_missing_suites&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; option &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt;. If &lt;code&gt;abort_if_missing_suites&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the test run stops immediately if some suites fail to compile.</source>
          <target state="translated">Если компиляция не выполняется для одного или нескольких наборов, ошибки компиляции выводятся на tty, и оператору задается вопрос, следует ли продолжить тестовый запуск без недостающих наборов или прервать его. Если оператор решает продолжить, тесты с отсутствующими наборами отмечаются в журнале HTML. Если &lt;code&gt;Common Test&lt;/code&gt; не может запросить пользователя после сбоя компиляции (если &lt;code&gt;Common Test&lt;/code&gt; не управляет &lt;code&gt;stdin&lt;/code&gt; ), тестовый запуск продолжается автоматически без недостающих наборов. Такое поведение , однако , может быть изменен с &lt;code&gt;ct_run&lt;/code&gt; флагом &lt;code&gt;-abort_if_missing_suites&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; вариант &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt; . Если &lt;code&gt;abort_if_missing_suites&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , запуск теста немедленно прекращается, если некоторые комплекты не могут быть скомпилированы.</target>
        </trans-unit>
        <trans-unit id="ddef6fb238c70a7447c7b61165fd491bf02611b6" translate="yes" xml:space="preserve">
          <source>If compiling a NIF for static inclusion through &lt;code&gt;--enable-static-nifs&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; before the &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">При компиляции NIF для статического включения с помощью &lt;code&gt;--enable-static-nifs&lt;/code&gt; необходимо определить &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; перед объявлением &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cca373adf442d693560ee904763df365fc27eee" translate="yes" xml:space="preserve">
          <source>If compiling a driver for static inclusion through &lt;code&gt;--enable-static-drivers&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; before the &lt;code&gt;DRIVER_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">При компиляции драйвера для статического включения с помощью &lt;code&gt;--enable-static-drivers&lt;/code&gt; вы должны определить &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; перед объявлением &lt;code&gt;DRIVER_INIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7c1f0b07bbf198171947df86c5f80f0e8b91bec" translate="yes" xml:space="preserve">
          <source>If configuration elements (key-value tuples) are to be returned as result instead of values, use option &lt;code&gt;element&lt;/code&gt;. The returned elements are then on the form &lt;code&gt;{Required,Value}&lt;/code&gt;.</source>
          <target state="translated">Если элементы конфигурации (кортежи &amp;laquo;ключ-значение&amp;raquo;) должны быть возвращены как результат вместо значений, используйте &lt;code&gt;element&lt;/code&gt; option . Затем возвращенные элементы помещаются в форму &lt;code&gt;{Required,Value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e21b434342c495e7cd41bb3f46d93a5eba516c9" translate="yes" xml:space="preserve">
          <source>If containing a &quot;supported_groups&quot; extension, it MUST also contain a &quot;key_share&quot; extension, and vice versa. An empty KeyShare.client_shares vector is permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f827f0de33d203f9e3d3e27b4a69d02e3a754313" translate="yes" xml:space="preserve">
          <source>If cross cover analysis is performed, and there are accumulated coverage results for the current test, the link &quot;Coverdata collected over all tests&quot; takes you to these results.</source>
          <target state="translated">Если выполняется перекрестный анализ покрытия,и есть накопленные результаты покрытия для текущего теста,то по ссылке &quot;Coverdata collect over all tests&quot; (Собранные данные по всем тестам)можно перейти к этим результатам.</target>
        </trans-unit>
        <trans-unit id="5d96e5091e8d9707ed005b18c015f0afc06954f5" translate="yes" xml:space="preserve">
          <source>If data is sent to an &lt;code&gt;io_device()&lt;/code&gt; in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file is closed.</source>
          <target state="translated">Если данные отправляются в &lt;code&gt;io_device()&lt;/code&gt; в формате, который не может быть преобразован в указанную кодировку, или если данные считываются функцией, которая возвращает данные в формате, который не может соответствовать диапазону символов данных, возникает ошибка и файл закрыт.</target>
        </trans-unit>
        <trans-unit id="432e1b16af8182ee4323fbba32056a19e755694b" translate="yes" xml:space="preserve">
          <source>If defined, disables input and output flow control for the pty opend by &lt;code&gt;run_erl&lt;/code&gt;. Useful if you want to remove any risk of accidentally blocking the flow control by using Ctrl-S (instead of Ctrl-D to detach), which can result in blocking of the entire Beam process, and in the case of running heart as supervisor even the heart process becomes blocked when writing log message to terminal, leaving the heart process unable to do its work.</source>
          <target state="translated">Если определено, отключает управление потоком ввода и вывода для pty, &lt;code&gt;run_erl&lt;/code&gt; . Полезно, если вы хотите исключить любой риск случайной блокировки управления потоком с помощью Ctrl-S (вместо Ctrl-D для отсоединения), что может привести к блокировке всего процесса Beam, а в случае запуска Heart как супервизора даже сердечный процесс блокируется при записи сообщения журнала на терминал, в результате чего сердечный процесс не может выполнять свою работу.</target>
        </trans-unit>
        <trans-unit id="51ec3e002de949fe36acc63a13c907879ad3bcd0" translate="yes" xml:space="preserve">
          <source>If differentiation between empty matches and non-existing subpatterns is necessary, use the &lt;code&gt;type&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; and do the conversion to the final type in Erlang code.</source>
          <target state="translated">Если необходимо различать пустые совпадения и несуществующие подшаблоны, используйте &lt;code&gt;index&lt;/code&gt; &lt;code&gt;type&lt;/code&gt; и выполните преобразование в окончательный тип в коде Erlang.</target>
        </trans-unit>
        <trans-unit id="49295520e0b6d8a184569401922957d15009d327" translate="yes" xml:space="preserve">
          <source>If doing encryption, the &lt;code&gt;final_fun()&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;final_fun()&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e301f5120b552d4bf6f7613573c8dff6a6c32f8f" translate="yes" xml:space="preserve">
          <source>If empty, the scheduler was doing some work. If not empty, the scheduler is either in some state of sleep, or suspended. This entry is only present in an SMP-enabled emulator.</source>
          <target state="translated">Если пусто,то планировщик делал кое-какую работу.Если не пустой,то планировщик либо находится в состоянии покоя,либо временно отстранен от работы.Эта запись присутствует только в эмуляторе с поддержкой SMP.</target>
        </trans-unit>
        <trans-unit id="1afa77778077164a71f88c72fb4b32ad3297d31d" translate="yes" xml:space="preserve">
          <source>If enabled and available, shows the process SASL log entries.</source>
          <target state="translated">Если включено и доступно,показывает записи журнала процесса SASL.</target>
        </trans-unit>
        <trans-unit id="7f6edf3b58ff2519bb720cd88ea08b2b0a6a0946" translate="yes" xml:space="preserve">
          <source>If enabled, a signal will be sent to each scheduler to check its responsiveness. The system check occurs before any heartbeat sent to the port program. If any scheduler is not responsive enough the heart program will not receive its heartbeat and thus eventually terminate the node.</source>
          <target state="translated">Если эта функция включена,то каждому планировщику будет отправлен сигнал для проверки его реакции.Проверка системы происходит перед тем,как любое сердцебиение будет отправлено в программу порта.Если какой-нибудь планировщик недостаточно реагирует,то программа сердца не получит свой пульс и,таким образом,в конце концов,завершит работу узла.</target>
        </trans-unit>
        <trans-unit id="148b1ea2e5a9c15263dc8ca4149113489de1e307" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function can add possible default values or internal state values to the configuration, and return the adjusted map in &lt;code&gt;{ok,Config2}&lt;/code&gt;.</source>
          <target state="translated">Если все прошло успешно, функция обратного вызова может добавить возможные значения по умолчанию или значения внутреннего состояния в конфигурацию и вернуть скорректированную карту в &lt;code&gt;{ok,Config2}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df38b6fefb42b5ad05d2e66a0fe9a0579def5bda" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config3}&lt;/code&gt;.</source>
          <target state="translated">Если все прошло успешно, функция обратного вызова должна вернуть возможно скорректированную конфигурацию в &lt;code&gt;{ok,Config3}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fa1005e80fa8c58a4740b29710f28976ae1bc25" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364e140fe39154a26dff03af44ca4298c8c2ac50" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;-loader&lt;/code&gt; is omitted, it defaults to &lt;code&gt;efile&lt;/code&gt;.</source>
          <target state="translated">Если флаг &lt;code&gt;-loader&lt;/code&gt; не указан , по умолчанию используется &lt;code&gt;efile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1454b961b40da8803e24e93858c630e5ff3bb457" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, or &lt;code&gt;monotonic_timestamp&lt;/code&gt; is specified, the first tuple element is &lt;code&gt;trace_ts&lt;/code&gt; instead, and the time stamp is added as an extra element last in the message tuple. If multiple time stamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All time stamp flags are remembered, so if two are passed and the one with highest precedence later is disabled, the other one becomes active.</source>
          <target state="translated">Если флаг &lt;code&gt;timestamp&lt;/code&gt; , &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; или &lt;code&gt;monotonic_timestamp&lt;/code&gt; указано, первый элемент кортежа &lt;code&gt;trace_ts&lt;/code&gt; вместо, а штамп времени добавляется в качестве дополнительного элемента последней в кортеже сообщения. Если передано несколько флагов отметок &lt;code&gt;timestamp&lt;/code&gt; , отметка времени имеет приоритет над &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; , который, в свою очередь, имеет приоритет над &lt;code&gt;monotonic_timestamp&lt;/code&gt; . Все флаги отметок времени запоминаются, поэтому, если два переданы и один с наивысшим приоритетом позже отключается, другой становится активным.</target>
        </trans-unit>
        <trans-unit id="7e5b82748f9af0c18d76e825667a1416cb4f5744" translate="yes" xml:space="preserve">
          <source>If flags &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt; are specified in the &lt;code&gt;Common Test&lt;/code&gt; group of options (preceding &lt;code&gt;-erl_args&lt;/code&gt;), relative directories are converted to absolute and reinserted into the code path by &lt;code&gt;Common Test&lt;/code&gt;. This is to avoid problems loading user modules when &lt;code&gt;Common Test&lt;/code&gt; changes working directory during test runs. However, &lt;code&gt;Common Test&lt;/code&gt; ignores flags &lt;code&gt;-pa&lt;/code&gt; and &lt;code&gt;-pz&lt;/code&gt; following &lt;code&gt;-erl_args&lt;/code&gt; on the command line. These directories are added to the code path normally (that is, on specified form).</source>
          <target state="translated">Если флаги &lt;code&gt;-pa&lt;/code&gt; или &lt;code&gt;-pz&lt;/code&gt; указаны в &lt;code&gt;Common Test&lt;/code&gt; группы опций (предыдущие &lt;code&gt;-erl_args&lt;/code&gt; ), относительные каталоги преобразуются в абсолютный и повторно в путь кода по &lt;code&gt;Common Test&lt;/code&gt; . Это сделано для того, чтобы избежать проблем с загрузкой пользовательских модулей, когда &lt;code&gt;Common Test&lt;/code&gt; изменяет рабочий каталог во время выполнения тестов. Однако &lt;code&gt;Common Test&lt;/code&gt; игнорирует флаги &lt;code&gt;-pa&lt;/code&gt; и -pz &lt;code&gt;-pz&lt;/code&gt; следующие за &lt;code&gt;-erl_args&lt;/code&gt; в командной строке. Эти каталоги обычно добавляются в путь кода (то есть в указанной форме).</target>
        </trans-unit>
        <trans-unit id="1e378e106e4077ae24d5e6f29ec376f6a4bd3b26" translate="yes" xml:space="preserve">
          <source>If for some reason megaco is unable to deliver the reply, the reason for this will be passed to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;, unless &lt;code&gt;ack_action() = discard_ack&lt;/code&gt;.</source>
          <target state="translated">Если по какой-то причине megaco не может доставить ответ, причина этого будет передана пользователю через вызов функции обратного вызова &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; , если только &lt;code&gt;ack_action() = discard_ack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a3144d24e90d3f080c638b20288fd31695b9f8" translate="yes" xml:space="preserve">
          <source>If found, this file is automatically included when a release package is created.</source>
          <target state="translated">Если он найден,этот файл автоматически включается при создании пакета выпуска.</target>
        </trans-unit>
        <trans-unit id="88a8d1bcc6dc202674f35ee136d67e69ecbf0dcd" translate="yes" xml:space="preserve">
          <source>If function &lt;code&gt;start_link/3,4,5&lt;/code&gt; is used and the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;{error, Reason}&lt;/code&gt; is returned if the calling process traps exits.</source>
          <target state="translated">Если используется функция &lt;code&gt;start_link/3,4,5&lt;/code&gt; и процесс аварийно завершает работу до того, как он вызвал &lt;code&gt;init_ack/1,2&lt;/code&gt; , возвращается &lt;code&gt;{error, Reason}&lt;/code&gt; если вызывающий процесс прерывания завершается.</target>
        </trans-unit>
        <trans-unit id="fc69364c0ae557a1dbe6b4d9aa1b146e1216ffbd" translate="yes" xml:space="preserve">
          <source>If function calls are traced, trace patterns must be added by clicking button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt;. Select a module, function(s), and a match specification. If no functions are selected, all functions in the module are traced.</source>
          <target state="translated">Если отслеживаются вызовы функций, необходимо добавить образцы трассировки, нажав кнопку &amp;laquo; &lt;strong&gt;Добавить образец трассировки&amp;raquo;&lt;/strong&gt; . Выберите модуль, функцию (и) и спецификацию соответствия. Если никакие функции не выбраны, отслеживаются все функции в модуле.</target>
        </trans-unit>
        <trans-unit id="1f07e18dbc5f57c6c6717a768b0ed4eaba425e5a" translate="yes" xml:space="preserve">
          <source>If given, sets a minimum of bytes per second value for connections.</source>
          <target state="translated">Если дано,устанавливает минимальное значение байтов в секунду для соединений.</target>
        </trans-unit>
        <trans-unit id="b172d1229983e5a1a9ff5fbcf190541819d75da7" translate="yes" xml:space="preserve">
          <source>If header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is not included, the fun is not translated, which can result in a &lt;strong&gt;runtime error&lt;/strong&gt; (depending on whether the fun is valid in a pure Erlang context).</source>
          <target state="translated">Если файл заголовка &lt;code&gt;ms_transform.hrl&lt;/code&gt; не включен, удовольствие не транслируется, что может привести к &lt;strong&gt;ошибке выполнения&lt;/strong&gt; (в зависимости от того, допустимо ли удовольствие в контексте чистого Erlang).</target>
        </trans-unit>
        <trans-unit id="16995098726e7577905f8e4783d07b32252efedf" translate="yes" xml:space="preserve">
          <source>If heart should &lt;strong&gt;not&lt;/strong&gt; kill the Erlang runtime system, this can be indicated using the environment variable &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt;. This can be useful if the command executed by heart takes care of this, for example as part of a specific cleanup sequence. If unset, or not set to &lt;code&gt;TRUE&lt;/code&gt;, the default behaviour will be to kill as described above.</source>
          <target state="translated">Если сердце &lt;strong&gt;не&lt;/strong&gt; должно убивать систему времени выполнения Erlang, это можно указать с помощью переменной окружения &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt; . Это может быть полезно, если команда, выполняемая наизусть, позаботится об этом, например, как часть определенной последовательности очистки. Если не задано или не установлено в &lt;code&gt;TRUE&lt;/code&gt; , поведение по умолчанию будет убивать, как описано выше.</target>
        </trans-unit>
        <trans-unit id="b95d064b6fe476b33228869a58d35631e292ffa4" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;ch3&lt;/code&gt; belong to the same application, the &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">Если вместо этого &lt;code&gt;m1&lt;/code&gt; и &lt;code&gt;ch3&lt;/code&gt; принадлежат одному и тому же приложению, файл &lt;code&gt;.appup&lt;/code&gt; может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="dc6d61b4492f1c7e6142a54cbe978ede62016351" translate="yes" xml:space="preserve">
          <source>If instead the cover specification for &lt;code&gt;s2&lt;/code&gt; is like the following:</source>
          <target state="translated">Если вместо этого спецификация покрытия для &lt;code&gt;s2&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="0a7e93ff7cf25c1c8178af08584a9eabcf3e9a0a" translate="yes" xml:space="preserve">
          <source>If instead the following pattern is used, it matches &quot;sense and responsibility&quot; and the other two strings:</source>
          <target state="translated">Если вместо этого используется следующий шаблон,то он совпадает с &quot;чувством и ответственностью&quot; и двумя другими строками:</target>
        </trans-unit>
        <trans-unit id="2cc8cc207fcbebe26bafa392de36c0b0727d0b02" translate="yes" xml:space="preserve">
          <source>If it is determined during execution of &lt;code&gt;end_per_testcase&lt;/code&gt; that the status of a successful test case is to be changed to failed, &lt;code&gt;end_per_testcase&lt;/code&gt; can return the tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; (where &lt;code&gt;Reason&lt;/code&gt; describes why the test case fails).</source>
          <target state="translated">Если во время выполнения &lt;code&gt;end_per_testcase&lt;/code&gt; определено, что статус успешного тестового примера должен быть изменен на неудачный, &lt;code&gt;end_per_testcase&lt;/code&gt; может вернуть кортеж &lt;code&gt;{fail,Reason}&lt;/code&gt; (где &lt;code&gt;Reason&lt;/code&gt; описывает, почему тестовый пример терпит неудачу).</target>
        </trans-unit>
        <trans-unit id="7ff18467b22f0114a8805a4726fb2dcc0392ce69" translate="yes" xml:space="preserve">
          <source>If it is important to get similar indentation and newlines as in the original document you have to add #xmlText{} records with space and newline values in appropriate places. It may also be necessary to keep the original prolog where the DTD is referenced. If so, it is possible to pass a RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; to &lt;code&gt;export_simple/3&lt;/code&gt;. The following example code fixes those changes in the previous example:</source>
          <target state="translated">Если важно получить такие же отступы и символы новой строки, как в исходном документе, вам необходимо добавить записи #xmlText {} с пробелами и значениями новой строки в соответствующих местах. Также может потребоваться сохранить исходный пролог, в котором имеется ссылка на DTD. Если это так, то можно передать RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; prolog , Value} в &lt;code&gt;export_simple/3&lt;/code&gt; . В следующем примере кода исправлены эти изменения из предыдущего примера:</target>
        </trans-unit>
        <trans-unit id="0edefb6e50405687abd870a868c1bcff5bf5189f" translate="yes" xml:space="preserve">
          <source>If it is important to minimize the time that an application is inactive while changing code, use &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;atomic_load/1&lt;/code&gt;. Here is an example:</source>
          <target state="translated">Если важно минимизировать время, в течение которого приложение неактивно при изменении кода, используйте &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;atomic_load/1&lt;/code&gt; . Вот пример:</target>
        </trans-unit>
        <trans-unit id="04b581ca359dbb5b4e61555833c3a8149c91dfc0" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_server&lt;/code&gt; must be set to trap exit signals in function &lt;code&gt;init&lt;/code&gt;. When ordered to shutdown, the &lt;code&gt;gen_server&lt;/code&gt; then calls the callback function &lt;code&gt;terminate(shutdown, State)&lt;/code&gt;:</source>
          <target state="translated">Если необходимо выполнить очистку перед завершением, стратегия завершения работы должна быть значением тайм-аута, а &lt;code&gt;gen_server&lt;/code&gt; должен быть настроен на перехват сигналов выхода в функции &lt;code&gt;init&lt;/code&gt; . При получении команды на отключение &lt;code&gt;gen_server&lt;/code&gt; затем вызывает функцию обратного вызова &lt;code&gt;terminate(shutdown, State)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e79bb817b263e5ddf9ba4cef4ae14edfb7ff9782" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_statem&lt;/code&gt; must in function &lt;code&gt;init/1&lt;/code&gt; set itself to trap exit signals by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;:</source>
          <target state="translated">Если необходимо очистить перед завершением, стратегия выключения должна быть значением тайм-аута, а &lt;code&gt;gen_statem&lt;/code&gt; в функции &lt;code&gt;init/1&lt;/code&gt; должен установить себя для перехвата сигналов выхода путем вызова &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c10551de78ce4c13b76bdcb633906a358226cfc9" translate="yes" xml:space="preserve">
          <source>If it is needed to compile a set of &lt;code&gt;ASN.1&lt;/code&gt; modules into an Erlang file with encode/decode functions, ensure to list all involved files in a configuration file. This configuration file must have a double extension &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; (&lt;code&gt;&quot;.asn&quot;&lt;/code&gt; can alternatively be &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; or &lt;code&gt;&quot;.py&quot;&lt;/code&gt;). List the input file names within quotation marks (&quot;&quot;), one at each row in the file. If the input files are &lt;code&gt;File1.asn&lt;/code&gt;, &lt;code&gt;File2.asn&lt;/code&gt;, and &lt;code&gt;File3.asn&lt;/code&gt;, the configuration file must look as follows:</source>
          <target state="translated">Если необходимо скомпилировать набор модулей &lt;code&gt;ASN.1&lt;/code&gt; в файл Erlang с функциями кодирования / декодирования, убедитесь, что все задействованные файлы перечислены в файле конфигурации. Этот файл конфигурации должен иметь двойное расширение &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; ( &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; может альтернативно быть &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; или &lt;code&gt;&quot;.py&quot;&lt;/code&gt; ). Перечислите имена входных файлов в кавычках (&quot;&quot;), по одной в каждой строке файла. Если входные файлы - &lt;code&gt;File1.asn&lt;/code&gt; , &lt;code&gt;File2.asn&lt;/code&gt; и &lt;code&gt;File3.asn&lt;/code&gt; , файл конфигурации должен выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="ac7e64fc378f2a5b91895bad1f8c83d469b481c8" translate="yes" xml:space="preserve">
          <source>If it is not specified it will use a default list ([x25519, x448, secp256r1, secp384r1]) that is filtered based on the installed crypto library version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d51fd241eafb95c913d685374e5a264641108ee" translate="yes" xml:space="preserve">
          <source>If it is possible for a manager to create or delete rows in the table, there must be a &lt;code&gt;RowStatus&lt;/code&gt; column for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;undo&lt;/code&gt; to work properly.</source>
          <target state="translated">Если это возможно для менеджера создавать или удалять строки в таблице, должны быть &lt;code&gt;RowStatus&lt;/code&gt; колонки для &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; и &lt;code&gt;undo&lt;/code&gt; работать должным образом.</target>
        </trans-unit>
        <trans-unit id="78796728bcb7c7764f0d079115e6608598e07dda" translate="yes" xml:space="preserve">
          <source>If it is possible to load &lt;code&gt;Module&lt;/code&gt; and function &lt;code&gt;Function/N&lt;/code&gt; is exported, it is called.</source>
          <target state="translated">Если возможно загрузить &lt;code&gt;Module&lt;/code&gt; и функция &lt;code&gt;Function/N&lt;/code&gt; экспортируется, она вызывается.</target>
        </trans-unit>
        <trans-unit id="34f89c49da4f3e679accd5b84c8be09ec8b3341c" translate="yes" xml:space="preserve">
          <source>If it is required that Mnesia must build and maintain an extra index table on attribute &lt;code&gt;address&lt;/code&gt; of all the &lt;code&gt;person&lt;/code&gt; records that are inserted in the table, the following code would be issued:</source>
          <target state="translated">Если требуется , чтобы Mnesia должен создавать и поддерживать дополнительную таблицу индекса на атрибут &lt;code&gt;address&lt;/code&gt; все &lt;code&gt;person&lt;/code&gt; записей, которые вставляются в таблице, следующий код будет выдан:</target>
        </trans-unit>
        <trans-unit id="d545f3dffae84feb539a9a4a2658199f48d1fd1a" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;code&gt;auto&lt;/code&gt;, the client automatically handles received tickets and tries to use them when making new TLS connections (session resumption with pre-shared keys).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8576255de740a4f910003bb08212e24357ef1fd" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;code&gt;stateful&lt;/code&gt; or &lt;code&gt;stateless&lt;/code&gt;, session resumption with pre-shared keys is enabled and the server will send stateful or stateless session tickets to the client after successful connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cea858b85f406ece423faeb209b445f4f52401b" translate="yes" xml:space="preserve">
          <source>If it takes two arguments, the first is the report, and the second is a map containing extra data that allows direct coversion to a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bfd8938101283cd461120f722bba92f5d433c5" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing key in the map, a new association is created from key &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Если ключ &lt;code&gt;K&lt;/code&gt; не совпадает ни с существующего ключа в карте, новая ассоциация создается из ключа &lt;code&gt;K&lt;/code&gt; до значения &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="361674b6db4757a45860f6c0ff467ce229682848" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing keys in map &lt;code&gt;M&lt;/code&gt;, an exception of type &lt;code&gt;badarg&lt;/code&gt; is triggered at runtime. If a matching key &lt;code&gt;K&lt;/code&gt; is present in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;, and the evaluated map expression returns a new map.</source>
          <target state="translated">Если ключ &lt;code&gt;K&lt;/code&gt; не соответствует ни одному из существующих ключей в карте &lt;code&gt;M&lt;/code&gt; , во время выполнения запускается исключение типа &lt;code&gt;badarg&lt;/code&gt; . Если соответствующий ключ &lt;code&gt;K&lt;/code&gt; присутствует в карте &lt;code&gt;M&lt;/code&gt; , его связанное значение заменяется новым значением &lt;code&gt;V&lt;/code&gt; , и вычисленное выражение карты возвращает новую карту.</target>
        </trans-unit>
        <trans-unit id="c0a6ddca5224e31c09a05fdd6034a788ec478e89" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; matches an existing key in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;. In both cases, the evaluated map expression returns a new map.</source>
          <target state="translated">Если ключ &lt;code&gt;K&lt;/code&gt; соответствует существующий ключ в карте &lt;code&gt;M&lt;/code&gt; , связанный с ним значение заменяется новым значением &lt;code&gt;V&lt;/code&gt; . В обоих случаях вычисленное выражение карты возвращает новую карту.</target>
        </trans-unit>
        <trans-unit id="42a830a40777cba9136dab78e83126fb44890b72" translate="yes" xml:space="preserve">
          <source>If later &lt;code&gt;Pid&lt;/code&gt; terminates with a reason &lt;code&gt;Reason&lt;/code&gt;, the supervisor bridge terminates with reason &lt;code&gt;Reason&lt;/code&gt; as well. If later the supervisor bridge is stopped by its supervisor with reason &lt;code&gt;Reason&lt;/code&gt;, it calls &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; to terminate.</source>
          <target state="translated">Если позже &lt;code&gt;Pid&lt;/code&gt; завершается по причине &lt;code&gt;Reason&lt;/code&gt; , мост супервизора также завершается по причине &lt;code&gt;Reason&lt;/code&gt; . Если позже супервизор останавливает мост с &lt;code&gt;Reason&lt;/code&gt; причины Reason , он вызывает &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; для завершения.</target>
        </trans-unit>
        <trans-unit id="3a49b5785a5ebb3a3e817628501985a6f158407e" translate="yes" xml:space="preserve">
          <source>If long node node names are used, initiation is done by calling &lt;code&gt;erl_connect_xinit()&lt;/code&gt;:</source>
          <target state="translated">Если используются длинные имена узлов узлов, инициализация выполняется вызовом &lt;code&gt;erl_connect_xinit()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a0fdc2466475ba354acc0c8a05ce784a5bde5f7" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table.</source>
          <target state="translated">Если многие процессы фиксируют таблицу,то она остается фиксированной до тех пор,пока все процессы не освободят ее (или не закончат работу).Счетчик ссылок сохраняется для каждого процесса,и для N последовательных исправлений требуется N освобождений,чтобы освободить таблицу.</target>
        </trans-unit>
        <trans-unit id="0c297e380855cf1730e1b5795f833b28141150c8" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</source>
          <target state="translated">Если многие процессы фиксируют таблицу,она остается фиксированной до тех пор,пока все процессы не освободят ее или не завершат работу.Счетчик ссылок сохраняется для каждого процесса,и для N последовательных исправлений требуется N освобождений,чтобы освободить таблицу.</target>
        </trans-unit>
        <trans-unit id="53435afc4e831537f2a17e9899dbdd4cb79d80ed" translate="yes" xml:space="preserve">
          <source>If map &lt;code&gt;map_in&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, this function makes a copy of &lt;code&gt;map_in&lt;/code&gt; in &lt;code&gt;*map_out&lt;/code&gt;, and removes &lt;code&gt;key&lt;/code&gt; and the associated value. If map &lt;code&gt;map_in&lt;/code&gt; does not contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;*map_out&lt;/code&gt; is set to &lt;code&gt;map_in&lt;/code&gt;.</source>
          <target state="translated">Если карта &lt;code&gt;map_in&lt;/code&gt; содержит &lt;code&gt;key&lt;/code&gt; , эта функция делает копию &lt;code&gt;map_in&lt;/code&gt; в &lt;code&gt;*map_out&lt;/code&gt; и удаляет &lt;code&gt;key&lt;/code&gt; и связанное с ним значение. Если карта &lt;code&gt;map_in&lt;/code&gt; не содержит &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;*map_out&lt;/code&gt; устанавливается в &lt;code&gt;map_in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6edf0f9b76d8b501d4e816cd9d78be0eb60417a0" translate="yes" xml:space="preserve">
          <source>If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and the reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing requests are allowed to complete before the reload is done.</source>
          <target state="translated">Если режим нарушается,сервер принудительно блокируется,все текущие запросы прекращаются,и сразу же начинается перезагрузка.Если режим не нарушает работу,новые соединения не принимаются,но текущие запросы могут быть завершены до завершения перезагрузки.</target>
        </trans-unit>
        <trans-unit id="e360c70f0d772545e95505fb9d2d98d4f6aab9bb" translate="yes" xml:space="preserve">
          <source>If modules are compiled with inlining, spurious warnings can be emitted. In the &lt;strong&gt;Options&lt;/strong&gt; menu you can choose to ignore inline-compiled modules when analyzing byte code. When starting from source code, this is not a problem because inlining is explicitly turned off by Dialyzer. The option causes Dialyzer to suppress all warnings from inline-compiled modules, as there is currently no way for Dialyzer to find what parts of the code have been produced by inlining.</source>
          <target state="translated">Если модули скомпилированы с встраиванием, могут выдаваться ложные предупреждения. В меню &amp;laquo; &lt;strong&gt;Параметры&amp;raquo;&lt;/strong&gt; вы можете выбрать игнорировать встроенные скомпилированные модули при анализе байтового кода. При запуске из исходного кода это не проблема, потому что встраивание явно отключено Dialyzer. Эта опция заставляет Dialyzer подавлять все предупреждения от встроенных скомпилированных модулей, поскольку в настоящее время Dialyzer не может определить, какие части кода были созданы при встраивании.</target>
        </trans-unit>
        <trans-unit id="ae716d5d8a33ea589343e3a0fd8de6a8cb8c320e" translate="yes" xml:space="preserve">
          <source>If more complex filtering is needed, use &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; and specify the exact filter according to &quot;XML Schema for Event Notifications&quot; in RFC 5277.</source>
          <target state="translated">Если требуется более сложная фильтрация, используйте &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; и укажите точный фильтр в соответствии с &amp;laquo;XML-схемой для уведомлений о событиях&amp;raquo; в RFC 5277.</target>
        </trans-unit>
        <trans-unit id="36a1865d02dfc0df8a1f4e482a94e12100776ba1" translate="yes" xml:space="preserve">
          <source>If more than &lt;code&gt;MaxR&lt;/code&gt; number of restarts occur in the last &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all the child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">Если за последние &lt;code&gt;MaxT&lt;/code&gt; секунд происходит больше, чем &lt;code&gt;MaxR&lt;/code&gt; перезапусков , супервизор завершает все дочерние процессы, а затем и себя. Причиной завершения работы самого супервизора в этом случае будет &lt;code&gt;shutdown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4518103e529715a70474c2780a5c3ec980b88617" translate="yes" xml:space="preserve">
          <source>If more than a certain amount of available system memory is allocated, as reported by the underlying operating system, the alarm &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; is set.</source>
          <target state="translated">Если выделяется более определенного количества доступной системной памяти, как сообщает соответствующая операционная система, устанавливается аварийный сигнал &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d231020eccfbc66c22211e22df6c7cecb22eb6a5" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point.</source>
          <target state="translated">Если в шаблоне существует более одного обратного глагола,то сначала может сработать другой глагол (*COMMIT),поэтому простая передача (*COMMIT)во время совпадения не всегда гарантирует,что в этой начальной точке должно быть совпадение.</target>
        </trans-unit>
        <trans-unit id="3508e8e529ddb74814eed659592c5affc8d5bd2a" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments:</source>
          <target state="translated">Если в шаблоне присутствует более одного отступающего глагола,то тот,который отступает на первые действия.Например,рассмотрим следующий шаблон,где A,B и т.д.являются сложными фрагментами шаблона:</target>
        </trans-unit>
        <trans-unit id="aeb08026d08e982ee4c93506a7932708091433e1" translate="yes" xml:space="preserve">
          <source>If more than one process tries to load an already loaded driver with the same &lt;code&gt;Path&lt;/code&gt;, or if the same process tries to load it many times, the function returns &lt;code&gt;ok&lt;/code&gt;. The emulator keeps track of the &lt;code&gt;load/2&lt;/code&gt; calls, so that a corresponding number of &lt;code&gt;unload/2&lt;/code&gt; calls must be done from the same process before the driver gets unloaded. It is therefore safe for an application to load a driver that is shared between processes or applications when needed. It can safely be unloaded without causing trouble for other parts of the system.</source>
          <target state="translated">Если более одного процесса пытаются загрузить уже загруженный драйвер с одним и тем же &lt;code&gt;Path&lt;/code&gt; , или если один и тот же процесс пытается загрузить его много раз, функция возвращает &lt;code&gt;ok&lt;/code&gt; . Эмулятор отслеживает вызовы &lt;code&gt;load/2&lt;/code&gt; , так что соответствующее количество вызовов &lt;code&gt;unload/2&lt;/code&gt; должно быть выполнено из того же процесса до того, как драйвер будет выгружен. Поэтому для приложения безопасно загружать драйвер, который используется совместно процессами или приложениями, когда это необходимо. Его можно безопасно выгружать, не вызывая проблем для других частей системы.</target>
        </trans-unit>
        <trans-unit id="2967b6a58919e3d3f7de7bef014b85f80942bbf1" translate="yes" xml:space="preserve">
          <source>If multi-scheduling is enabled, more than one scheduler thread is used by the emulator. Multi-scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or all &lt;strong&gt;normal&lt;/strong&gt; schedulers but one is blocked. When only normal schedulers are blocked, dirty schedulers are free to continue to schedule processes.</source>
          <target state="translated">Если включено множественное планирование, эмулятор использует более одного потока планировщика. Множественное планирование можно заблокировать двумя способами. Заблокированы либо все планировщики, кроме одного, либо все &lt;strong&gt;обычные&lt;/strong&gt; планировщики, кроме одного. Когда заблокированы только обычные планировщики, грязные планировщики могут продолжать планировать процессы.</target>
        </trans-unit>
        <trans-unit id="e264c2c185809d37a3371b5c09778551bfdd2307" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;-eval&lt;/code&gt; expressions are specified, they are evaluated sequentially in the order specified. &lt;code&gt;-eval&lt;/code&gt; expressions are evaluated sequentially with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt; function calls (this also in the order specified). As with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt;, an evaluation that does not terminate blocks the system initialization process.</source>
          <target state="translated">Если &lt;code&gt;-eval&lt;/code&gt; несколько выражений -eval , они вычисляются последовательно в указанном порядке. Выражения &lt;code&gt;-eval&lt;/code&gt; вычисляются последовательно с вызовами функций &lt;code&gt;-s&lt;/code&gt; и &lt;code&gt;-run&lt;/code&gt; (это также в указанном порядке). Как и в случае с &lt;code&gt;-s&lt;/code&gt; и &lt;code&gt;-run&lt;/code&gt; , оценка, которая не завершается, блокирует процесс инициализации системы.</target>
        </trans-unit>
        <trans-unit id="97280216c73ddbe9bd1cfe50f8b9e6e9ba9af2e9" translate="yes" xml:space="preserve">
          <source>If multiple timestamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All timestamp flags are remembered, so if two are passed and the one with highest precedence later is disabled the other one will become active.</source>
          <target state="translated">Если передаются несколько флагов временной метки, &lt;code&gt;timestamp&lt;/code&gt; имеет приоритет над &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; , который в свою очередь , имеет приоритет над &lt;code&gt;monotonic_timestamp&lt;/code&gt; . Все флаги временных меток запоминаются, поэтому, если два переданы и один с наивысшим приоритетом позже будет отключен, другой станет активным.</target>
        </trans-unit>
        <trans-unit id="15446137a98bae984b924e92fba150a1dcc2db3c" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_server&lt;/code&gt; process calls the callback function &lt;code&gt;ch3:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt;. In this case, the state is the available channels.</source>
          <target state="translated">В случае успешной регистрации, новый &lt;code&gt;gen_server&lt;/code&gt; процесс вызывает функцию обратного вызова &lt;code&gt;ch3:init([])&lt;/code&gt; . Ожидается, что &lt;code&gt;init&lt;/code&gt; вернет &lt;code&gt;{ok, State}&lt;/code&gt; , где &lt;code&gt;State&lt;/code&gt; - это внутреннее состояние &lt;code&gt;gen_server&lt;/code&gt; . В этом случае состояние - это доступные каналы.</target>
        </trans-unit>
        <trans-unit id="2fbbe04e09f325bd4aa00a3af49946b86a67830b" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_statem&lt;/code&gt; process calls callback function &lt;code&gt;code_lock:init(Code)&lt;/code&gt;. This function is expected to return &lt;code&gt;{ok, State, Data}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial state of the &lt;code&gt;gen_statem&lt;/code&gt;, in this case &lt;code&gt;locked&lt;/code&gt;; assuming that the door is locked to begin with. &lt;code&gt;Data&lt;/code&gt; is the internal server data of the &lt;code&gt;gen_statem&lt;/code&gt;. Here the server data is a &lt;code&gt;map&lt;/code&gt; with key &lt;code&gt;code&lt;/code&gt; that stores the correct button sequence, key &lt;code&gt;length&lt;/code&gt; store its length, and key &lt;code&gt;buttons&lt;/code&gt; that stores the collected buttons up to the same length.</source>
          <target state="translated">Если регистрация имени &lt;code&gt;gen_statem&lt;/code&gt; успешно, новый процесс gen_statem вызывает функцию обратного вызова &lt;code&gt;code_lock:init(Code)&lt;/code&gt; . Ожидается, что эта функция вернет &lt;code&gt;{ok, State, Data}&lt;/code&gt; , где &lt;code&gt;State&lt;/code&gt; - это начальное состояние &lt;code&gt;gen_statem&lt;/code&gt; , в данном случае &lt;code&gt;locked&lt;/code&gt; ; предполагая, что дверь заперта для начала. &lt;code&gt;Data&lt;/code&gt; - это внутренние данные сервера &lt;code&gt;gen_statem&lt;/code&gt; . Здесь данные сервера представляют собой &lt;code&gt;map&lt;/code&gt; с &lt;code&gt;code&lt;/code&gt; клавиши, в которой хранится правильная последовательность кнопок, &lt;code&gt;length&lt;/code&gt; ключа хранит его длину, а ключевые &lt;code&gt;buttons&lt;/code&gt; хранят собранные кнопки до той же длины.</target>
        </trans-unit>
        <trans-unit id="7e65163ad8d72d6ee5d80daa0e098b4aadff312b" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;-minimal&lt;/code&gt;, nor &lt;code&gt;-sasl&lt;/code&gt; is passed as argument you will be prompted.</source>
          <target state="translated">Если ни &lt;code&gt;-minimal&lt;/code&gt; , ни &lt;code&gt;-sasl&lt;/code&gt; передается в качестве аргумента будет предложено.</target>
        </trans-unit>
        <trans-unit id="5532948dc2571760fbfaa0cdce397fe861e00347" translate="yes" xml:space="preserve">
          <source>If neither endpoint is desired you can test and re-try like this:</source>
          <target state="translated">Если ни одна из конечных точек не нужна,вы можете протестировать и повторить попытку следующим образом:</target>
        </trans-unit>
        <trans-unit id="7ed5063391f45e25222dbefda8015e8ee48fbb82" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt; is given the node will be started using &lt;code&gt;-sname undefined&lt;/code&gt;. If &lt;code&gt;Node&lt;/code&gt; does not contain a hostname, one is automatically taken from &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bad7222a27717f2f7fdcb509b4a128ed0ea2cf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContextName&lt;/code&gt; is specified, the default &lt;code&gt;&quot;&quot;&lt;/code&gt; context is used.</source>
          <target state="translated">Если нет &lt;code&gt;ContextName&lt;/code&gt; не указано, по умолчанию &lt;code&gt;&quot;&quot;&lt;/code&gt; контекст используется.</target>
        </trans-unit>
        <trans-unit id="5f8fa538da1412a2b10a3518391e831a5459dc85" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NotifyName&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets (&lt;code&gt;Addresses&lt;/code&gt; below).</source>
          <target state="translated">Если &lt;code&gt;NotifyName&lt;/code&gt; не указано (или указано &lt;code&gt;&quot;&quot;&lt;/code&gt; ), уведомление отправляется всем целям управления ( &lt;code&gt;Addresses&lt;/code&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="80ccb4b7a89fa0c5a71d360eba8cfe0f8b2d5620" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Type&lt;/code&gt; is specified, all reports are listed.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; не указан, отображаются все отчеты.</target>
        </trans-unit>
        <trans-unit id="ac9629aacf5a541205c4ec779ff11edb1576409e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;context&lt;/code&gt; is specified, the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;, is used.</source>
          <target state="translated">Если &lt;code&gt;context&lt;/code&gt; не указан, используется контекст по умолчанию &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed97555002c32aa9440a97e73ca69137e2f1b0fe" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;epmd&lt;/code&gt; (TCP port mapper daemon) is used, also command-line option &lt;code&gt;-no_epmd&lt;/code&gt; is to be specified, which makes Erlang skip the &lt;code&gt;epmd&lt;/code&gt; startup, both as an OS process and as an Erlang ditto.</source>
          <target state="translated">Если &lt;code&gt;epmd&lt;/code&gt; (демон сопоставления портов TCP) не используется, также необходимо указать параметр командной строки &lt;code&gt;-no_epmd&lt;/code&gt; , который заставляет Erlang пропускать запуск &lt;code&gt;epmd&lt;/code&gt; как как процесс ОС, так и как то же самое в Erlang.</target>
        </trans-unit>
        <trans-unit id="a8006619350a5226e5dc4b2683c9eea3a8bdbda4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;extended_info&lt;/code&gt; is present in the file and &lt;code&gt;{verify,true}&lt;/code&gt; is specified, the number of objects written is compared to the size of the original table when the dump was started. This can make verification fail if the table was &lt;code&gt;public&lt;/code&gt; and objects were added or removed while the table was dumped to file. To avoid this problem, either do not verify files dumped while updated simultaneously or use option &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;, which extends the information in the file with the number of objects written.</source>
          <target state="translated">Если в файле нет &lt;code&gt;extended_info&lt;/code&gt; и указано значение &lt;code&gt;{verify,true}&lt;/code&gt; , количество записанных объектов сравнивается с размером исходной таблицы при запуске дампа. Это может привести к сбою проверки, если таблица была &lt;code&gt;public&lt;/code&gt; а объекты были добавлены или удалены, когда таблица была выгружена в файл. Чтобы избежать этой проблемы, либо не проверяйте файлы, выгружаемые при одновременном обновлении, либо используйте опцию &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; , которая расширяет информацию в файле с количеством записанных объектов.</target>
        </trans-unit>
        <trans-unit id="8a45ca5e05cc70fae2783d55cbff20b1f8725403" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;name&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets.</source>
          <target state="translated">Если &lt;code&gt;name&lt;/code&gt; не указано (или указано &lt;code&gt;&quot;&quot;&lt;/code&gt; ), уведомление отправляется всем целям управления.</target>
        </trans-unit>
        <trans-unit id="32886c8cd8eda5943ea7814b65ec8cd639317821" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;tracer&lt;/code&gt; is specified, the calling process receives all the trace messages.</source>
          <target state="translated">Если &lt;code&gt;tracer&lt;/code&gt; не указан, вызывающий процесс получает все сообщения трассировки.</target>
        </trans-unit>
        <trans-unit id="8acb8279a4661a4f996c3af79ec9be1db1d63648" translate="yes" xml:space="preserve">
          <source>If no BEAM file contains debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">Если ни один файл BEAM не содержит отладочной информации,то возвращается список кортежей.Первый элемент каждого кортежа-один из них:</target>
        </trans-unit>
        <trans-unit id="44e5f3c4af2c18aaf89a34918cf838e205862cec" translate="yes" xml:space="preserve">
          <source>If no BOM is found, the function returns &lt;code&gt;{latin1,0}&lt;/code&gt;.</source>
          <target state="translated">Если спецификация не найдена, функция возвращает &lt;code&gt;{latin1,0}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e07f0cc9e55f8b5cf0585baaee7cd300085bb99c" translate="yes" xml:space="preserve">
          <source>If no CPU topology is available when flag &lt;code&gt;+sbt&lt;/code&gt; is processed and &lt;code&gt;BindType&lt;/code&gt; is any other type than &lt;code&gt;u&lt;/code&gt;, the runtime system fails to start. CPU topology can be defined using flag &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt;. Notice that flag &lt;code&gt;+sct&lt;/code&gt; can have to be passed before flag &lt;code&gt;+sbt&lt;/code&gt; on the command line (if no CPU topology has been automatically detected).</source>
          <target state="translated">Если при обработке flag &lt;code&gt;+sbt&lt;/code&gt; топология ЦП недоступна, а &lt;code&gt;BindType&lt;/code&gt; отличается от &lt;code&gt;u&lt;/code&gt; , система выполнения не запускается. Топологию процессора можно определить с помощью flag &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что flag &lt;code&gt;+sct&lt;/code&gt; может быть передан перед flag &lt;code&gt;+sbt&lt;/code&gt; в командной строке (если топология ЦП не была обнаружена автоматически).</target>
        </trans-unit>
        <trans-unit id="dccd7290f5c52ab540d1d1066d43a3aaf228c19a" translate="yes" xml:space="preserve">
          <source>If no argument is provided, Debugger starts in global mode.</source>
          <target state="translated">Если аргументов нет,отладчик запускается в глобальном режиме.</target>
        </trans-unit>
        <trans-unit id="622b281cf52c77f356f35ba9cbbad1c260bbd03f" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt; Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe7b07f514dd69941a31088b490f38f80374e4c" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если сценарий загрузки не указан, по умолчанию используется &lt;code&gt;ROOT/bin/start&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a8687c3d2fddc8ffec405bf127b2012f252abb2" translate="yes" xml:space="preserve">
          <source>If no carrier in &lt;code&gt;pooled_tree&lt;/code&gt; had a large enough free block, we search it again to find any carrier that may act as an entry point into the shared list of all pooled carriers. This in order to, if possible, avoid starting at the sentinel and thereby ease the &quot;bad clustering&quot; problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221abc0dca23710976162240a2b9fb59a1bb2e0e" translate="yes" xml:space="preserve">
          <source>If no clause could be definitely selected, the function returns &lt;code&gt;{false, NewClauses}&lt;/code&gt;, where &lt;code&gt;NewClauses&lt;/code&gt; is the list of entries in &lt;code&gt;Clauses&lt;/code&gt; that remain after eliminating unselectable clauses, preserving the relative order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11dd24d2508db0b969937d6f16c64e7e9a757da" translate="yes" xml:space="preserve">
          <source>If no command-line flag is entered, the &lt;code&gt;Mnesia&lt;/code&gt; directory becomes the current working directory on the node where the Erlang shell is started.</source>
          <target state="translated">Если не указан флаг командной строки, каталог &lt;code&gt;Mnesia&lt;/code&gt; становится текущим рабочим каталогом на узле, на котором запущена оболочка Erlang.</target>
        </trans-unit>
        <trans-unit id="19b61bf39702f61088362c4f3caf5fec39790a79" translate="yes" xml:space="preserve">
          <source>If no configuration exists for a server, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead, and specify all necessary options in the &lt;code&gt;Options&lt;/code&gt; parameter.</source>
          <target state="translated">Если для сервера не существует конфигурации, используйте вместо этого &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; и укажите все необходимые параметры в параметре &lt;code&gt;Options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0a2525519fce3b84f0628d21fec24d0d54a30b8" translate="yes" xml:space="preserve">
          <source>If no configuration file is specified with command &lt;code&gt;ct_run&lt;/code&gt;, a warning is displayed. If &lt;code&gt;Common Test&lt;/code&gt; has been run from the same directory earlier, the same configuration file(s) are used again. If &lt;code&gt;Common Test&lt;/code&gt; has not been run from this directory before, no configuration files are available.</source>
          <target state="translated">Если файл конфигурации не указан с помощью команды &lt;code&gt;ct_run&lt;/code&gt; , отображается предупреждение. Если &lt;code&gt;Common Test&lt;/code&gt; ранее был запущен из того же каталога, снова используются те же файлы конфигурации. Если &lt;code&gt;Common Test&lt;/code&gt; ранее не запускался из этого каталога, файлы конфигурации недоступны.</target>
        </trans-unit>
        <trans-unit id="905acdf151b0fff2093942d03e8fda7ba4d6ef97" translate="yes" xml:space="preserve">
          <source>If no connection reference is provided, a connection is set up, and the new connection is returned. An SSH channel process is started to handle the communication with the SFTP server. The returned &lt;code&gt;pid&lt;/code&gt; for this process is to be used as input to all other API functions in this module.</source>
          <target state="translated">Если ссылка на соединение не указана, соединение устанавливается, и возвращается новое соединение. Процесс канала SSH запускается для обработки связи с сервером SFTP. Возвращается &lt;code&gt;pid&lt;/code&gt; для этого процесса будет использоваться в качестве входных данных для всех других функций API в этом модуле.</target>
        </trans-unit>
        <trans-unit id="a012950e61dc5d03cdb78960de0564c38b5541f9" translate="yes" xml:space="preserve">
          <source>If no encoder module is given, the default is used (which is pretty).</source>
          <target state="translated">Если модуль энкодера не указан,то используется модуль по умолчанию (что довольно красиво).</target>
        </trans-unit>
        <trans-unit id="9348a769518853e44d89b99ac342c57ff1b5e15b" translate="yes" xml:space="preserve">
          <source>If no error occurs, the second phase is performed. This phase calls the user defined &lt;code&gt;set&lt;/code&gt; function for all variables.</source>
          <target state="translated">Если ошибки не возникает, выполняется второй этап. На этом этапе вызывается функция &lt;code&gt;set&lt;/code&gt; пользователем набора для всех переменных.</target>
        </trans-unit>
        <trans-unit id="3b135a2849366f4513f0e061b53465a7e3a779a4" translate="yes" xml:space="preserve">
          <source>If no exports are listed by an &lt;code&gt;export&lt;/code&gt; option (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details), then if &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, that module will be exported; otherwise, the first listed module will be exported. Cf. the examples under &lt;code&gt;merge/3&lt;/code&gt;.</source>
          <target state="translated">Если экспорт не указан параметром &lt;code&gt;export&lt;/code&gt; (подробности см. В &lt;code&gt;merge_sources/3&lt;/code&gt; ), то если &lt;code&gt;Name&lt;/code&gt; также является именем одного из модулей ввода, этот модуль будет экспортирован; в противном случае будет экспортирован первый указанный модуль. Ср примеры в разделе &lt;code&gt;merge/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="186696412f510e31ad8ed3a38fb86c31cd6ca5ca" translate="yes" xml:space="preserve">
          <source>If no extra options are specified with flag/option &lt;code&gt;step&lt;/code&gt;, breakpoints are set automatically on the test cases that are to be executed by &lt;code&gt;Common Test&lt;/code&gt;, and those functions only. If step option &lt;code&gt;config&lt;/code&gt; is specified, breakpoints are also initially set on the configuration functions in the suite, that is, &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, &lt;code&gt;end_per_group/2&lt;/code&gt;, &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2&lt;/code&gt;.</source>
          <target state="translated">Если с помощью параметра flag / option &lt;code&gt;step&lt;/code&gt; не указаны дополнительные параметры , точки останова устанавливаются автоматически для тестовых случаев, которые должны выполняться с помощью &lt;code&gt;Common Test&lt;/code&gt; , и только для этих функций. Если указана &lt;code&gt;config&lt;/code&gt; параметра шага , точки останова также изначально устанавливаются для функций конфигурации в наборе, то есть &lt;code&gt;init_per_suite/1&lt;/code&gt; , &lt;code&gt;end_per_suite/1&lt;/code&gt; , &lt;code&gt;init_per_group/2&lt;/code&gt; , &lt;code&gt;end_per_group/2&lt;/code&gt; , &lt;code&gt;init_per_testcase/2&lt;/code&gt; и &lt;code&gt;end_per_testcase/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e1803a2624ccbd4e21f90db6095850fb9331a7" translate="yes" xml:space="preserve">
          <source>If no formatter information is specified for a handler, Logger uses &lt;code&gt;logger_formatter&lt;/code&gt; as default. See the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page for more information about this module.</source>
          <target state="translated">Если для обработчика не указана информация форматировщика, Logger по умолчанию использует &lt;code&gt;logger_formatter&lt;/code&gt; . См. &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; руководства logger_formatter (3) для получения дополнительной информации об этом модуле.</target>
        </trans-unit>
        <trans-unit id="41b05b11e2a531a16c3ad32baf03f74559983750" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt; digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534f259af2115bebe106710668093e3ef6ffd155" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если тип графа не указан, для создания ориентированного графа используется &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; , в противном случае аргумент &lt;code&gt;GraphType&lt;/code&gt; передается как второй аргумент в &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eb03e181763fc340f89dd2fee8a41ea21ee5c23" translate="yes" xml:space="preserve">
          <source>If no guard sequence is evaluated as true, an &lt;code&gt;if_clause&lt;/code&gt; run-time error occurs. If necessary, the guard expression &lt;code&gt;true&lt;/code&gt; can be used in the last branch, as that guard sequence is always true.</source>
          <target state="translated">Если никакая защитная последовательность не оценивается как истина, возникает &lt;code&gt;if_clause&lt;/code&gt; выполнения if_clause . Если необходимо, в последней ветви можно использовать защитное выражение &amp;laquo; &lt;code&gt;true&lt;/code&gt; , поскольку эта защитная последовательность всегда истинна.</target>
        </trans-unit>
        <trans-unit id="b9f6b9adc1152f1b0fd0e1ed73ad8eec4e1f624e" translate="yes" xml:space="preserve">
          <source>If no log with the specified name exist on the specified node, &lt;code&gt;no_such_log&lt;/code&gt; is returned.</source>
          <target state="translated">Если на указанном узле нет журнала с указанным именем, возвращается &lt;code&gt;no_such_log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6ab79d1d5e9e2cd8b43d5f286fe816764eabff" translate="yes" xml:space="preserve">
          <source>If no match is found for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Result&lt;/code&gt; will be the empty string (&lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">Если для &lt;code&gt;Tag&lt;/code&gt; совпадения не найдено , &lt;code&gt;Result&lt;/code&gt; будет пустая строка ( &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="668861363db131d12510c671297ba7af08f41273" translate="yes" xml:space="preserve">
          <source>If no more event handlers exist after the deletion, &lt;code&gt;error_logger&lt;/code&gt; is removed as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is stopped.</source>
          <target state="translated">Если после удаления больше не существует обработчиков событий, &lt;code&gt;error_logger&lt;/code&gt; удаляется как обработчик Logger, а процесс &lt;code&gt;error_logger&lt;/code&gt; останавливается.</target>
        </trans-unit>
        <trans-unit id="97bba64e22bb5e3d712c27f199cd41bb5ed00da4" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor bridge is not registered.</source>
          <target state="translated">Если имя не указано,то мост руководителя не зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="145b04378100b2af31635cfab7037e102fc50e14" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor is not registered.</source>
          <target state="translated">Если имя не указано,супервайзер не зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="7209e6d7e59cd86554bad77c729bc91b2aac2993" translate="yes" xml:space="preserve">
          <source>If no new memory blocks are inserted into the list, it should eventually be emptied. All pointers to the list however expect to always point to something. This is solved by inserting an empty &quot;marker&quot; element, which only has to purpose of being there in the absense of other elements. That is when the list is empty it only contains this &quot;marker&quot; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962cccbaba0fe2900b8b208ab74fd43b13540b3f" translate="yes" xml:space="preserve">
          <source>If no object with key &lt;code&gt;Key&lt;/code&gt; exists, the function exits with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">Если объекта с ключом &lt;code&gt;Key&lt;/code&gt; не существует, функция завершается по причине &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ace922192dd1a66ce93d65f216be69e6bdcfa0" translate="yes" xml:space="preserve">
          <source>If no options are specified, a read lock is acquired, 100 results are returned in each chunk, and &lt;code&gt;select&lt;/code&gt; is used to traverse the table, that is:</source>
          <target state="translated">Если никакие параметры не указаны, устанавливается блокировка чтения, в каждом блоке возвращается 100 результатов, а &lt;code&gt;select&lt;/code&gt; используется для обхода таблицы, то есть:</target>
        </trans-unit>
        <trans-unit id="be43c0999b074d475f47490047515316aff57a56" translate="yes" xml:space="preserve">
          <source>If no or an unknown version is given, the &lt;strong&gt;best&lt;/strong&gt; version is used (which is v3).</source>
          <target state="translated">Если версия не указана или указана неизвестная, используется &lt;strong&gt;лучшая&lt;/strong&gt; версия (v3).</target>
        </trans-unit>
        <trans-unit id="bc0db3920bc02374e1ab1e1eb3ced79753b79531" translate="yes" xml:space="preserve">
          <source>If no output comes from the Erlang shell, but the Erlang machine still seems to be alive, an &quot;ALIVE&quot; message is written to the log; it is a time stamp and is written, by default, after 15 minutes of inactivity. Also, if output from Erlang is logged, but more than 5 minutes (default) has passed since last time we got anything from Erlang, a time stamp is written in the log. The &quot;ALIVE&quot; messages look as follows:</source>
          <target state="translated">Если ни один вывод не поступает из оболочки Erlang,но машина Erlang все еще кажется живой,в журнал записывается сообщение &quot;ALIVE&quot;;это временная метка и по умолчанию записывается после 15 минут бездействия.Также,если вывод с Erlang записан в журнал,но прошло более 5 минут (по умолчанию)с момента получения последнего сообщения от Erlang,в журнал записывается метка времени.Сообщения &quot;ALIVE&quot; выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="e2dda439a8b57752f5158a6910e3f618737cb035" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt; set_process_metadata/1 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609daf9d4941227cdd07f7a145c9f4b97a9dd23d" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если метаданные процесса не существуют, функция ведет себя как &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bcf9e8cbdaa54440e55a1604d7759707d84c686" translate="yes" xml:space="preserve">
          <source>If no response is received before &lt;code&gt;WaitTime&lt;/code&gt; milliseconds, the atom &lt;code&gt;no_response&lt;/code&gt; is returned. It is valid to continue waiting for a response as many times as needed up until a response has been received and completed by &lt;code&gt;erpc:check_response()&lt;/code&gt;, &lt;code&gt;erpc:receive_response()&lt;/code&gt;, or &lt;code&gt;erpc:wait_response()&lt;/code&gt;. If a response is received, the &lt;code&gt;call&lt;/code&gt; operation is completed and either the result is returned as &lt;code&gt;{response, Result}&lt;/code&gt; where &lt;code&gt;Result&lt;/code&gt; corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt;. That is, no &lt;code&gt;{erpc, timeout}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception can be raised. &lt;code&gt;erpc:wait_response()&lt;/code&gt; will fail with an &lt;code&gt;{erpc, badarg}&lt;/code&gt; exception if/when an invalid &lt;code&gt;RequestId&lt;/code&gt; is detected or if an invalid &lt;code&gt;WaitTime&lt;/code&gt; is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129f0fba3cda34f511f81ef498c5983a08b6fef4" translate="yes" xml:space="preserve">
          <source>If no service name is specified, a brief listing of all Erlang services is presented. If a service name is supplied, all options for that service are presented.</source>
          <target state="translated">Если название сервиса не указано,представляется краткий список всех сервисов Erlang.Если имя сервиса указано,то представлены все опции для этого сервиса.</target>
        </trans-unit>
        <trans-unit id="f74a0bc86a24e556d294700bf2367dba448274f4" translate="yes" xml:space="preserve">
          <source>If no specific browser start command is specified, Firefox is the default browser on Unix platforms, and Internet Explorer on Windows. If &lt;code&gt;Common Test&lt;/code&gt; fails to start a browser automatically, or &lt;code&gt;none&lt;/code&gt; is specified as the value for &lt;code&gt;-browser&lt;/code&gt; (that is, &lt;code&gt;-browser none&lt;/code&gt;), start your favourite browser manually and type the URL that &lt;code&gt;Common Test&lt;/code&gt; displays in the shell.</source>
          <target state="translated">Если конкретная команда запуска браузера не указана, Firefox является браузером по умолчанию на платформах Unix и Internet Explorer в Windows. Если &lt;code&gt;Common Test&lt;/code&gt; не запускает браузер автоматически или &lt;code&gt;none&lt;/code&gt; не указан в качестве значения для &lt;code&gt;-browser&lt;/code&gt; (то есть &lt;code&gt;-browser none&lt;/code&gt; ), запустите ваш любимый браузер вручную и введите URL-адрес, который &lt;code&gt;Common Test&lt;/code&gt; отображает в оболочке.</target>
        </trans-unit>
        <trans-unit id="3bd56a176fb29e1e8248ad526f6f69316f9b58af" translate="yes" xml:space="preserve">
          <source>If no such fun is registered, &lt;code&gt;beam_lib&lt;/code&gt; instead searches for an &lt;code&gt;.erlang.crypt&lt;/code&gt; file, see the next section.</source>
          <target state="translated">Если такого развлечения не зарегистрировано, &lt;code&gt;beam_lib&lt;/code&gt; вместо этого ищет файл &lt;code&gt;.erlang.crypt&lt;/code&gt; , см. Следующий раздел.</target>
        </trans-unit>
        <trans-unit id="287f2765f0e3b66bca8a3294ba1f1a9c4a144428" translate="yes" xml:space="preserve">
          <source>If no support is found for any tool, this function returns &lt;code&gt;{skip, Explanation}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40469f7012f9c99e344b26a6dfa3a4f344430f04" translate="yes" xml:space="preserve">
          <source>If no time-out of the same type is active instead insert the time-out event just like when starting a time-out with relative &lt;code&gt;Time = 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b73a3ec1f7134600f89a051364f83c286cb4411" translate="yes" xml:space="preserve">
          <source>If no transformation rule match, the loader will begin rewriting the first of generic instructions to a specific instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d762df86c391a1b492c91b19c8e6c06437bbda" translate="yes" xml:space="preserve">
          <source>If no user configuration file is specified and Erlang is started in non-distributed or short name distributed mode, Erlang uses default configuration settings and a native lookup method that works correctly under most circumstances. Erlang reads no information from system &lt;code&gt;inet&lt;/code&gt; configuration files (such as &lt;code&gt;/etc/host.conf&lt;/code&gt; and &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;) in these modes, except for &lt;code&gt;/etc/resolv.conf&lt;/code&gt; and &lt;code&gt;/etc/hosts&lt;/code&gt; that is read and monitored for changes on Unix platforms for the internal DNS client &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">Если файл конфигурации пользователя не указан и Erlang запущен в нераспределенном режиме или в распределенном режиме с коротким именем, Erlang использует параметры конфигурации по умолчанию и собственный метод поиска, который работает правильно в большинстве случаев. Erlang не считывает информацию из системных файлов конфигурации &lt;code&gt;inet&lt;/code&gt; (таких как &lt;code&gt;/etc/host.conf&lt;/code&gt; и &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; ) в этих режимах, за исключением &lt;code&gt;/etc/resolv.conf&lt;/code&gt; и &lt;code&gt;/etc/hosts&lt;/code&gt; , которые читаются и отслеживаются на предмет изменений. на платформах Unix для внутреннего DNS-клиента &lt;code&gt;inet_res(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13936c5aba4f403aada92256e268f1fefbc0b6d4" translate="yes" xml:space="preserve">
          <source>If no value for &lt;code&gt;Retries&lt;/code&gt; is specified, &lt;code&gt;infinity&lt;/code&gt; is used.</source>
          <target state="translated">Если значение для &lt;code&gt;Retries&lt;/code&gt; не указано, используется &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="205ea9177e47ff562742443567460c481c26083e" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;delayed_write&lt;/code&gt; or &lt;code&gt;{delayed_write,Size,Delay}&lt;/code&gt; is found in the list, &lt;code&gt;delayed_write&lt;/code&gt; is added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b55a7b8716a559ffcad32612bbf10761dc5678f" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt; or &lt;code&gt;exclusive&lt;/code&gt; is found in the list, &lt;code&gt;append&lt;/code&gt; is added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c3223fb92528e085bdc89d88a03ccfd3c590d9" translate="yes" xml:space="preserve">
          <source>If none of the above are available for your architecture/compiler, you are recommended to build and install &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; before building Erlang/OTP. The &lt;code&gt;libatomic_ops&lt;/code&gt; library provides native atomic memory operations for a variety of architectures and compilers. When building Erlang/OTP you need to inform the build system of where the &lt;code&gt;libatomic_ops&lt;/code&gt; library is installed using the &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt;&lt;code&gt;configure&lt;/code&gt; switch.</source>
          <target state="translated">Если ничего из вышеперечисленного недоступно для вашей архитектуры / компилятора, рекомендуется собрать и установить &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; перед сборкой Erlang / OTP. Библиотека &lt;code&gt;libatomic_ops&lt;/code&gt; предоставляет встроенные операции с атомарной памятью для различных архитектур и компиляторов. При сборке Erlang / OTP вам необходимо сообщить системе сборки, где &lt;code&gt;libatomic_ops&lt;/code&gt; библиотека &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt; &lt;code&gt;configure&lt;/code&gt; переключателя конфигурации --with-libatomic_ops = PATH .</target>
        </trans-unit>
        <trans-unit id="9440ff5a97925b9c13d62c177e03518391502a24" translate="yes" xml:space="preserve">
          <source>If none of the first three clauses match, the fourth clause match as a variable always matches.</source>
          <target state="translated">Если ни один из первых трех пунктов не совпадает,то четвертый пункт всегда совпадает как переменная.</target>
        </trans-unit>
        <trans-unit id="f62e5b4dade736a66aa048e49499435f1f4d7fdc" translate="yes" xml:space="preserve">
          <source>If none of the strings in &lt;code&gt;Pattern&lt;/code&gt; is found, the atom &lt;code&gt;nomatch&lt;/code&gt; is returned.</source>
          <target state="translated">Если ни одна из строк в &lt;code&gt;Pattern&lt;/code&gt; не найдено, атом &lt;code&gt;nomatch&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="aeb11b61b9cc24cd2031d9dda015e2462ccc0499" translate="yes" xml:space="preserve">
          <source>If none of the strings in a pattern is found, an empty list is returned.</source>
          <target state="translated">Если ни одна из строк в шаблоне не найдена,возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="c826d8a5c30fbaafd8ba535e4315b2bb2ea4206a" translate="yes" xml:space="preserve">
          <source>If not containing a &quot;pre_shared_key&quot; extension, it MUST contain both a &quot;signature_algorithms&quot; extension and a &quot;supported_groups&quot; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="652472f45cf3561f5b3dd17763a17700dfcd88cc" translate="yes" xml:space="preserve">
          <source>If not empty, a scheduler internal auxiliary work is scheduled to be done.</source>
          <target state="translated">Если не пусто,то запланирована внутренняя вспомогательная работа планировщика.</target>
        </trans-unit>
        <trans-unit id="9937b44a2ec57528d4de1534b4257202ba316ad9" translate="yes" xml:space="preserve">
          <source>If not implemented, the CTH acts as if this function returned a call to &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">Если не реализован, CTH действует так, как если бы эта функция вернула вызов &lt;code&gt;make_ref/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c288cca9f0fb59e5fd99ac4b40424bd7ecc21978" translate="yes" xml:space="preserve">
          <source>If not present, audit trail logging is not used.</source>
          <target state="translated">Если его нет,то протоколирование аудиторского следа не используется.</target>
        </trans-unit>
        <trans-unit id="3dcb002efb7975058562ec638f68a0e701480231" translate="yes" xml:space="preserve">
          <source>If not set, &lt;code&gt;ei&lt;/code&gt; will implement the timeout using &lt;code&gt;select()&lt;/code&gt; in order to determine when to call the callbacks and when to time out. The &lt;code&gt;tmo&lt;/code&gt; arguments of the &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;writev()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;read()&lt;/code&gt; callbacks should be ignored. The callbacks may be called in non-blocking mode. The callbacks are not allowed to change between blocking and non-blocking mode. In order for this to work, &lt;code&gt;select()&lt;/code&gt; needs to interact with the socket primitives used the same way as it interacts with the ordinary socket primitives. If this is not the case, the callbacks &lt;strong&gt;need&lt;/strong&gt; to implement timeouts and this flag should be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3b7ad4aa64090ecee7bb02c7f143402ada38cd" translate="yes" xml:space="preserve">
          <source>If not, the &lt;code&gt;&lt;a href=&quot;#type-reason&quot;&gt;reason()&lt;/a&gt;&lt;/code&gt; indicates what went wrong:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e29374c41854c469f97e992cbb29625d1d3ef4" translate="yes" xml:space="preserve">
          <source>If not, this is the atom &lt;code&gt;all&lt;/code&gt; which implies that the &lt;code&gt;UtilDesc&lt;/code&gt; contains information about all CPUs.</source>
          <target state="translated">Если нет, то это &lt;code&gt;all&lt;/code&gt; что подразумевает, что &lt;code&gt;UtilDesc&lt;/code&gt; содержит информацию обо всех процессорах.</target>
        </trans-unit>
        <trans-unit id="f15293549ba601ce95a5307be4274cf3a235ee45" translate="yes" xml:space="preserve">
          <source>If not, this is the sum of the percentage shares of the CPU cycles spent in all states identified as busy.</source>
          <target state="translated">Если нет,то это сумма процентных долей циклов процессора,потраченных во всех состояниях,определенных как занятые.</target>
        </trans-unit>
        <trans-unit id="a5425f5051ad47a7b173e5435c9b894080331b92" translate="yes" xml:space="preserve">
          <source>If nothing else is stated, it is presumed that the &lt;code&gt;otptest&lt;/code&gt; user has an entry in the &lt;strong&gt;authorized_keys&lt;/strong&gt; file of &lt;strong&gt;tarlop&lt;/strong&gt; (allowed to log in over &lt;code&gt;ssh&lt;/code&gt; without entering a password). Also, &lt;strong&gt;tarlop&lt;/strong&gt; is a known host in the &lt;code&gt;known_hosts&lt;/code&gt; file of the user &lt;code&gt;otptest&lt;/code&gt;. This means that host-verification can be done without user-interaction.</source>
          <target state="translated">Если ничего не указано, предполагается , что &lt;code&gt;otptest&lt;/code&gt; пользователь имеет запись в &lt;strong&gt;authorized_keys&lt;/strong&gt; файл &lt;strong&gt;tarlop&lt;/strong&gt; (разрешено войти через &lt;code&gt;ssh&lt;/code&gt; без ввода пароля). Кроме того , &lt;strong&gt;tarlop&lt;/strong&gt; является известным хозяином в &lt;code&gt;known_hosts&lt;/code&gt; файл пользователя &lt;code&gt;otptest&lt;/code&gt; . Это означает, что проверка хоста может выполняться без участия пользователя.</target>
        </trans-unit>
        <trans-unit id="85b52863c7b73a113224224b8a0c4d01a407b7d9" translate="yes" xml:space="preserve">
          <source>If objects have been added while the table was fixed, the hash list starts to grow when the table is released, which significantly slows down access to the table for a period of time.</source>
          <target state="translated">Если объекты были добавлены во время фиксации таблицы,то при освобождении таблицы хэш-список начинает расти,что значительно замедляет доступ к таблице на некоторое время.</target>
        </trans-unit>
        <trans-unit id="828acc15f06ea3d0ebf75bc3294946979fd85c6d" translate="yes" xml:space="preserve">
          <source>If on the other hand the Version argument is an integer, it means that this is the expected version of the message and the decoder for that version should be used.</source>
          <target state="translated">С другой стороны,если аргумент Version является целым числом,это означает,что это ожидаемая версия сообщения и следует использовать декодер для этой версии.</target>
        </trans-unit>
        <trans-unit id="7ee7ad00a53993074166a752357e3a491c2d6eb1" translate="yes" xml:space="preserve">
          <source>If one &lt;strong&gt;really&lt;/strong&gt; wants to monitor when the driver gets unloaded, this message distorts the picture, because no unloading was done. Option &lt;code&gt;unloaded_only&lt;/code&gt; creates a monitor similar to an &lt;code&gt;unloaded&lt;/code&gt; monitor, but never results in this message.</source>
          <target state="translated">Если кто-то &lt;strong&gt;действительно&lt;/strong&gt; хочет отслеживать, когда драйвер выгружается, это сообщение искажает картину, потому что выгрузка не производилась. Опция &lt;code&gt;unloaded_only&lt;/code&gt; создает монитор, аналогичный &lt;code&gt;unloaded&lt;/code&gt; монитору, но никогда не возвращает это сообщение.</target>
        </trans-unit>
        <trans-unit id="c5ebea37f196f871b2a70d380f83941fc18ead49" translate="yes" xml:space="preserve">
          <source>If one UTF character is split over two consecutive binaries in the &lt;code&gt;Data&lt;/code&gt;, the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is specified as input without errors occurring.</source>
          <target state="translated">Если один символ UTF разделен на два последовательных двоичных файла в &lt;code&gt;Data&lt;/code&gt; , преобразование завершается успешно. Это означает, что символ может быть декодирован из диапазона двоичных файлов, если весь диапазон указан как входной без возникновения ошибок.</target>
        </trans-unit>
        <trans-unit id="90ed92af5805bd230adc121faf96993bce08b918" translate="yes" xml:space="preserve">
          <source>If one of the &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; flags is set, and the runtime system has no support for dirty schedulers, the runtime system refuses to load the NIF library.</source>
          <target state="translated">Если установлен один из &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; и система времени выполнения не поддерживает грязные планировщики, система времени выполнения отказывается загружать библиотеку NIF.</target>
        </trans-unit>
        <trans-unit id="da2865f4d243741aece7d05e455898a782a870b4" translate="yes" xml:space="preserve">
          <source>If one of the nodes cannot process monitors, for example, C or Java nodes, and the &lt;code&gt;gen_server&lt;/code&gt; process is not started when the requests are sent, but starts within 2 seconds, this function waits the whole &lt;code&gt;Timeout&lt;/code&gt;, which may be infinity.</source>
          <target state="translated">Если один из узлов не может обрабатывать мониторы, например, узлы C или Java, и процесс &lt;code&gt;gen_server&lt;/code&gt; не запускается при отправке запросов, а запускается в течение 2 секунд, эта функция ожидает весь &lt;code&gt;Timeout&lt;/code&gt; , который может быть бесконечным.</target>
        </trans-unit>
        <trans-unit id="2ff50154efe11e68e30a0801c8327e55b0714e5d" translate="yes" xml:space="preserve">
          <source>If one or more carriers could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">Если один или несколько носителей не могут быть отсканированы полностью без ущерба для &lt;code&gt;UnscannedSize&lt;/code&gt; системы, UnscannedSize - это количество байтов, которые необходимо было пропустить.</target>
        </trans-unit>
        <trans-unit id="9b3b6b44750cd929fb5194f2e7f17a52f91bfeb2" translate="yes" xml:space="preserve">
          <source>If only one access file exists, setting this parameter to &lt;code&gt;none&lt;/code&gt; can ease the burden on the server as the server then stops looking for access files.</source>
          <target state="translated">Если существует только один файл доступа, установка для этого параметра значения &lt;code&gt;none&lt;/code&gt; может снизить нагрузку на сервер, так как сервер перестает искать файлы доступа.</target>
        </trans-unit>
        <trans-unit id="78efdbd37020ca2e2d25f04642dce2c0495aa809" translate="yes" xml:space="preserve">
          <source>If only one letter is specified with \p or \P, it includes all the general category properties that start with that letter. In this case, in the absence of negation, the curly brackets in the escape sequence are optional. The following two examples have the same effect:</source>
          <target state="translated">Если указана только одна буква с \p или \P,то она включает в себя все свойства общей категории,которые начинаются с этой буквы.В этом случае,при отсутствии отрицания,фигурные скобки в экранирующей последовательности являются необязательными.Следующие два примера имеют одинаковый эффект:</target>
        </trans-unit>
        <trans-unit id="d1f740d3ae5b1c6572bd4172c4f16e8373ec6b45" translate="yes" xml:space="preserve">
          <source>If only one value is present, it is the current value. &lt;code&gt;fix_alloc&lt;/code&gt; memory block types are presented by two values. The first value is the memory pool size and the second value is the used memory size.</source>
          <target state="translated">Если присутствует только одно значение, это текущее значение. &lt;code&gt;fix_alloc&lt;/code&gt; блоков памяти fix_alloc представлены двумя значениями. Первое значение - это размер пула памяти, а второе - размер используемой памяти.</target>
        </trans-unit>
        <trans-unit id="c5da55d1092af23b098acf7d69c8679113b881cd" translate="yes" xml:space="preserve">
          <source>If only the module name (i.e. not the full name of the &lt;code&gt;.beam&lt;/code&gt; file) is given to this function, the &lt;code&gt;.beam&lt;/code&gt; file is found by calling &lt;code&gt;code:which(Module)&lt;/code&gt;. If no &lt;code&gt;.beam&lt;/code&gt; file is found, the error reason &lt;code&gt;non_existing&lt;/code&gt; is returned. If the module is already cover compiled with &lt;code&gt;compile_beam/1&lt;/code&gt;, the &lt;code&gt;.beam&lt;/code&gt; file will be picked from the same location as the first time it was compiled. If the module is already cover compiled with &lt;code&gt;compile/1,2&lt;/code&gt;, there is no way to find the correct &lt;code&gt;.beam&lt;/code&gt; file, so the error reason &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; is returned.</source>
          <target state="translated">Если этой функции присвоено только имя модуля (т.е. не полное имя файла &lt;code&gt;.beam&lt;/code&gt; ), файл &lt;code&gt;.beam&lt;/code&gt; можно найти с помощью &lt;code&gt;code:which(Module)&lt;/code&gt; вызова : which (Module) . Если файл &lt;code&gt;.beam&lt;/code&gt; не найден, возвращается причина ошибки &lt;code&gt;non_existing&lt;/code&gt; . Если модуль уже скомпилирован с помощью &lt;code&gt;compile_beam/1&lt;/code&gt; , файл &lt;code&gt;.beam&lt;/code&gt; будет выбран из того же места, что и при первой компиляции. Если модуль уже скомпилирован с помощью &lt;code&gt;compile/1,2&lt;/code&gt; , нет способа найти правильный файл &lt;code&gt;.beam&lt;/code&gt; , поэтому &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; причина ошибки {уже_cover_compiled, no_beam_found, Module} .</target>
        </trans-unit>
        <trans-unit id="84bdcab65ed9e153d52722d8ccf698faa98c0614" translate="yes" xml:space="preserve">
          <source>If only undefined options are requested the resulting list can be empty.</source>
          <target state="translated">Если запрашиваются только неопределённые опции,то результирующий список может быть пустым.</target>
        </trans-unit>
        <trans-unit id="c3d6b0c4be9ac174bfcec9988c3498fdbe5d2f55" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="translated">Если в &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; присутствует опция {debug, Dbgs} , &lt;code&gt;Opts&lt;/code&gt; отладка через &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d1d165321c33bcdb22f8f6a5267e4f891a4d819" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {debug,Dbgs} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ab9ca1d15e67f3dd0537fe7133aa59008f55d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after,HibernateAfterTimeout} &lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3aa68b73e10a456d4b0d56c548ffefa2777a94" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {spawn_opt,SpawnOpts} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba326e78241846819e3473e15898cf1eb3e7fec" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {timeout,Time} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769611976869b84c5779bcf180081ddcd9ad1bfa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;c&lt;/code&gt; is used with &lt;code&gt;oldshell&lt;/code&gt; on Unix, &lt;code&gt;Ctrl-C&lt;/code&gt; will restart the shell process rather than interrupt it.</source>
          <target state="translated">Если опция &lt;code&gt;c&lt;/code&gt; используется с &lt;code&gt;oldshell&lt;/code&gt; в Unix, &lt;code&gt;Ctrl-C&lt;/code&gt; перезапустит процесс оболочки, а не прервет его.</target>
        </trans-unit>
        <trans-unit id="096a0eaa955fff41e809fc817940102bc82e3b7a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compact&lt;/code&gt; is specified, the trailing zeros at the end of the list are truncated. This option is only meaningful together with option &lt;code&gt;decimals&lt;/code&gt;.</source>
          <target state="translated">Если указан параметр &lt;code&gt;compact&lt;/code&gt; , завершающие нули в конце списка обрезаются. Этот параметр имеет смысл только вместе с &lt;code&gt;decimals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e006a20906cf19e410666b42e37a9c3e19a3e41a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compressed&lt;/code&gt; is provided, the external term format is compressed. The compressed format is automatically recognized by &lt;code&gt;binary_to_term/1&lt;/code&gt; as from Erlang/OTP R7B.</source>
          <target state="translated">Если указан параметр &lt;code&gt;compressed&lt;/code&gt; , формат внешнего термина будет сжат. Сжатый формат автоматически распознается &lt;code&gt;binary_to_term/1&lt;/code&gt; из Erlang / OTP R7B.</target>
        </trans-unit>
        <trans-unit id="5de3ee850f4f14cadbc9c1e776ec192b168f5ad1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;decimals&lt;/code&gt; is specified, the returned value contains at most &lt;code&gt;Decimals&lt;/code&gt; number of digits past the decimal point. If the number does not fit in the internal static buffer of 256 bytes, the function throws &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">Если указан параметр &lt;code&gt;decimals&lt;/code&gt; , возвращаемое значение содержит не более &lt;code&gt;Decimals&lt;/code&gt; знаков после десятичной точки. Если число не помещается во внутренний статический буфер размером 256 байт, функция выдает &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d32ea21453f7c1a1069cac8907bb379c47719c1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;eof&lt;/code&gt; is specified also, the messages &lt;code&gt;eof&lt;/code&gt; and &lt;code&gt;exit_status&lt;/code&gt; appear in an unspecified order.</source>
          <target state="translated">Если опция &lt;code&gt;eof&lt;/code&gt; указано также, сообщения &lt;code&gt;eof&lt;/code&gt; и &lt;code&gt;exit_status&lt;/code&gt; появляются в произвольном порядке.</target>
        </trans-unit>
        <trans-unit id="32ae7856c177425822832835b7fef1768d20a52e" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;force&lt;/code&gt; has been passed, but the driver of the port does not allow forcing through a busy port.</source>
          <target state="translated">Если параметр &lt;code&gt;force&lt;/code&gt; был передан, но драйвер порта не разрешает принудительное прохождение через занятый порт.</target>
        </trans-unit>
        <trans-unit id="441c9bb025fc2889c41f42aea8b90d9817c38b34" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the formatting is automatically done when stopping &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">Если для параметра &lt;code&gt;format&lt;/code&gt; указано значение &lt;code&gt;ttb:stop/1&lt;/code&gt; , форматирование выполняется автоматически при остановке &lt;code&gt;ttb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d2376aceac49d07a344ae2362a017172221e3a6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the trace logs are automatically formatted after tracing is stopped.</source>
          <target state="translated">Если для параметра &lt;code&gt;format&lt;/code&gt; указано значение &lt;code&gt;ttb:stop/1&lt;/code&gt; , журналы трассировки автоматически форматируются после остановки трассировки.</target>
        </trans-unit>
        <trans-unit id="06c4d5d9e31e528aa6774014ad6ec78d401b5e9f" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;info&lt;/code&gt; is combined with option &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is returned if a flush was needed, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;info&lt;/code&gt; параметрах сочетается с параметром &lt;code&gt;flush&lt;/code&gt; , возвращается &lt;code&gt;false&lt;/code&gt; , если требуется очистка, в противном случае - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6534bbbe7210a2a4f9c6ad85ccdb4879fb04d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;kill_ports&lt;/code&gt; is used, monitor trigging is crucial, as the ports are not guaranteed to be killed until the driver is unloaded. Thus, a monitor must be triggered for at least the &lt;code&gt;pending_driver&lt;/code&gt; case.</source>
          <target state="translated">Если используется опция &lt;code&gt;kill_ports&lt;/code&gt; , активация монитора имеет решающее значение, поскольку не гарантируется, что порты будут уничтожены, пока драйвер не будет выгружен. Таким образом, монитор должен срабатывать как минимум для случая &lt;code&gt;pending_driver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6aa1db8f0800b8eada993c86c8a59c1d17dfb52c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, all other options return &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt;, respectively.</source>
          <target state="translated">Если опция &lt;code&gt;linked_in_driver&lt;/code&gt; или &lt;code&gt;permanent&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , все остальные опции возвращают &lt;code&gt;linked_in_driver&lt;/code&gt; или &lt;code&gt;permanent&lt;/code&gt; , соответственно.</target>
        </trans-unit>
        <trans-unit id="c57ff6b7c6782f60fe59ca940f65912e4d479346" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;monitor&lt;/code&gt; is specified, the newly created process is monitored, and both the pid and reference for the monitor are returned.</source>
          <target state="translated">Если указан параметр &lt;code&gt;monitor&lt;/code&gt; ,отслеживается только что созданный процесс, и возвращаются как pid, так и ссылка для монитора.</target>
        </trans-unit>
        <trans-unit id="04d4436e947c7fe2bfe4be7b9ccd10a7ac2337af" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;no_dot_erlang&lt;/code&gt; is specified, the instruction to load the &lt;code&gt;.erlang&lt;/code&gt; file during boot is &lt;strong&gt;not&lt;/strong&gt; included.</source>
          <target state="translated">Если &lt;code&gt;no_dot_erlang&lt;/code&gt; опция no_dot_erlang , инструкция по загрузке файла &lt;code&gt;.erlang&lt;/code&gt; во время загрузки &lt;strong&gt;не&lt;/strong&gt; включается.</target>
        </trans-unit>
        <trans-unit id="dd0a5200f0c674efc5a1ca9a83309cd9b7fe26b6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;noexec&lt;/code&gt; is specified, the function returns the same values as for &lt;code&gt;silent&lt;/code&gt; but no &lt;code&gt;relup&lt;/code&gt; file is created.</source>
          <target state="translated">Если указан параметр &lt;code&gt;noexec&lt;/code&gt; , функция возвращает те же значения, что и для &lt;code&gt;silent&lt;/code&gt; &lt;code&gt;relup&lt;/code&gt; но файл повторной проверки не создается.</target>
        </trans-unit>
        <trans-unit id="3c2f80ddb4accdf1246a3219780f43c13b4e27f2" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;purge&lt;/code&gt; is specified, all old code that can be soft-purged is purged after all other checks are successfully completed. This can be useful to reduce the time needed by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если указана опция &lt;code&gt;purge&lt;/code&gt; , весь старый код, который можно мягко очистить, очищается после успешного завершения всех остальных проверок. Это может быть полезно для сокращения времени, необходимого для &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f207e9cbf62b31891d035fb3346f08b4121c927b" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;restart_emulator&lt;/code&gt; is specified, a low-level instruction to restart the emulator is appended to the &lt;code&gt;relup&lt;/code&gt; file. This ensures that a complete reboot of the system is done when the system is upgraded or downgraded.</source>
          <target state="translated">Если &lt;code&gt;restart_emulator&lt;/code&gt; опция restart_emulator , низкоуровневая инструкция по перезапуску эмулятора добавляется к файлу &lt;code&gt;relup&lt;/code&gt; . Это гарантирует, что полная перезагрузка системы будет выполнена при обновлении или понижении версии системы.</target>
        </trans-unit>
        <trans-unit id="ef31277dfcdd9b3fea33e70696e85cc6a58e6495" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;scientific&lt;/code&gt; is specified, the float is formatted using scientific notation with &lt;code&gt;Decimals&lt;/code&gt; digits of precision.</source>
          <target state="translated">Если указан параметр &lt;code&gt;scientific&lt;/code&gt; , число с плавающей запятой форматируется в &lt;code&gt;Decimals&lt;/code&gt; представлении с точностью до десятичных знаков.</target>
        </trans-unit>
        <trans-unit id="68354b12f57b501c10eb39d65b11549593ad808d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;src_tests&lt;/code&gt; is specified, a warning is issued if the source code for a module is missing or is newer than the object code.</source>
          <target state="translated">Если &lt;code&gt;src_tests&lt;/code&gt; параметр src_tests , выдается предупреждение, если исходный код модуля отсутствует или новее, чем код объекта.</target>
        </trans-unit>
        <trans-unit id="3b698628086185a232f3b1c8c64f2b5821c29478" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;sync&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it ensures that the content of the file is written to the disk before &lt;code&gt;tab2file&lt;/code&gt; returns. Defaults to &lt;code&gt;{sync, false}&lt;/code&gt;.</source>
          <target state="translated">Если для параметра &lt;code&gt;sync&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , это гарантирует, что содержимое файла будет записано на диск до &lt;code&gt;tab2file&lt;/code&gt; . По умолчанию &lt;code&gt;{sync, false}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c1274c0980810787faf4c8323f084b49c5a2fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;ungreedy&lt;/code&gt; is set (an option that is not available in Perl), the quantifiers are not greedy by default, but individual ones can be made greedy by following them with a question mark. That is, it inverts the default behavior.</source>
          <target state="translated">Если установлена ​​опция &lt;code&gt;ungreedy&lt;/code&gt; (опция, которая недоступна в Perl), квантификаторы по умолчанию не являются жадными, но отдельные из них можно сделать жадными, поставив после них вопросительный знак. То есть он меняет поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6ebecfa9ef794349da407c48663db38e0205dfc1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;url_base&lt;/code&gt; is set, an extra attribute named &lt;code&gt;url&lt;/code&gt; is added to each &lt;code&gt;testsuite&lt;/code&gt; and &lt;code&gt;testcase&lt;/code&gt; XML element. The value is constructed from &lt;code&gt;url_base&lt;/code&gt; and a relative path to the test suite or test case log, respectively, for example:</source>
          <target state="translated">Если параметр &lt;code&gt;url_base&lt;/code&gt; установлен, дополнительный атрибут с именем &lt;code&gt;url&lt;/code&gt; добавляется к каждому &lt;code&gt;testsuite&lt;/code&gt; и &lt;code&gt;testcase&lt;/code&gt; XML - элемент. Значение &lt;code&gt;url_base&lt;/code&gt; из url_base и относительного пути к набору тестов или журналу тестовых случаев, соответственно, например:</target>
        </trans-unit>
        <trans-unit id="7a53503422cb0ac19329aceb31af878b5ec300e5" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;warnings_as_errors&lt;/code&gt; is specified, warnings are treated as errors.</source>
          <target state="translated">Если указан параметр &lt;code&gt;warnings_as_errors&lt;/code&gt; , предупреждения обрабатываются как ошибки.</target>
        </trans-unit>
        <trans-unit id="41ac36f3b8b38269747bee1634966538895f2ee4" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{debug,Dbgs}&lt;/code&gt; is present, the corresponding &lt;code&gt;sys&lt;/code&gt; function is called for each item in &lt;code&gt;Dbgs&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если присутствует опция &lt;code&gt;{debug,Dbgs}&lt;/code&gt; , соответствующая функция &lt;code&gt;sys&lt;/code&gt; вызывается для каждого элемента в &lt;code&gt;Dbgs&lt;/code&gt; ; см. &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c08f8f94d4db76f6cc364152658be9a80df8fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e804aab039286890448ffee48895432a1b352c17" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если указана опция &lt;code&gt;{handshake, hello}&lt;/code&gt; , рукопожатие приостанавливается после получения приветственного сообщения клиента, а успешный ответ - &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; вместо &lt;code&gt;{ok, SslSocket}&lt;/code&gt; . После этого рукопожатие продолжается или отменяется вызовом &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9802b121f3f842baa16ccec18f6827e8efefe976" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_event&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если присутствует опция &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; , процесс &lt;code&gt;gen_event&lt;/code&gt; ожидает любого сообщения в течение миллисекунд &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; , а если сообщение не получено, процесс автоматически переходит в режим гибернации (путем вызова &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="80d6ad9348d486b54eb01008ea70fa22ab22a998" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если присутствует опция &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; , процесс &lt;code&gt;gen_server&lt;/code&gt; ожидает любого сообщения в течение миллисекунд &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; , а если сообщение не получено, процесс автоматически переходит в режим гибернации (вызывая &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1afccf80e87b972a02a03ba25b3fcfd4c6d492f1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. A directory in the path can be specified with a wildcard &lt;code&gt;*&lt;/code&gt;, this is expanded to all matching directories. Example: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt;.</source>
          <target state="translated">Если указан параметр &lt;code&gt;{path,[Dir]}&lt;/code&gt; , этот путь добавляется к текущему пути. Каталог в пути может быть указан с подстановочным знаком &lt;code&gt;*&lt;/code&gt; , он распространяется на все соответствующие каталоги. Пример: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="521a357383f837ccbed508cea165f5ba1a72a4ba" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. Wildcard &lt;code&gt;*&lt;/code&gt; is expanded to all matching directories, for example, &lt;code&gt;lib/*/ebin&lt;/code&gt;.</source>
          <target state="translated">Если указан параметр &lt;code&gt;{path,[Dir]}&lt;/code&gt; , этот путь добавляется к текущему пути. Подстановочный знак &lt;code&gt;*&lt;/code&gt; распространяется на все соответствующие каталоги, например, &lt;code&gt;lib/*/ebin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a5e0fc842c3e7f86267427d3814bd82d53e295a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt; spawn_opt/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319e803f0c4dc5797ff076e88abf3ae72c4731f8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt;spawn_opt/2&lt;/code&gt;.</source>
          <target state="translated">Если присутствует опция &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; , &lt;code&gt;SOpts&lt;/code&gt; передается как список &lt;code&gt;spawn_opt&lt;/code&gt; BIF spawn_opt , который используется для порождения процесса &lt;code&gt;gen_server&lt;/code&gt; ; см. &lt;code&gt;spawn_opt/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f134a5284d4d1605e5d535d5f02614e7f9564b83" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="translated">Если опция &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; присутствует в &lt;code&gt;Opts&lt;/code&gt; , &lt;code&gt;SpawnOpts&lt;/code&gt; передается как список опций в &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; , который используется для порождения процесса &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c971670358afb5846db5d77c2b0b19aad5a3c579" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если опция &lt;code&gt;{timeout,Time}&lt;/code&gt; присутствует в &lt;code&gt;Opts&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; может потратить миллисекунды &lt;code&gt;Time&lt;/code&gt; на инициализацию или она завершается, а функция запуска возвращает &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341a32ddba103c08ae86b78ec53524b7702998b8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it is terminated and the start function returns &lt;code&gt;{error,timeout}&lt;/code&gt;.</source>
          <target state="translated">Если присутствует опция &lt;code&gt;{timeout,Time}&lt;/code&gt; , процессу &lt;code&gt;gen_server&lt;/code&gt; разрешается потратить миллисекунды &lt;code&gt;Time&lt;/code&gt; на инициализацию или он завершается, а функция запуска возвращает &lt;code&gt;{error,timeout}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a928786d0e9ca7308ebc039e35ade6afdfb8bc1d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{tls, tls_options()}&lt;/code&gt; is present, the FTP session is transported over &lt;code&gt;tls&lt;/code&gt; (&lt;code&gt;ftps&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt;). The list &lt;code&gt;tls_options()&lt;/code&gt; can be empty. The function &lt;code&gt;ssl:connect/3&lt;/code&gt; is used for securing both the control connection and the data sessions.</source>
          <target state="translated">Если опция &lt;code&gt;{tls, tls_options()}&lt;/code&gt; присутствует, FTP сессия переносится на &lt;code&gt;tls&lt;/code&gt; ( &lt;code&gt;ftps&lt;/code&gt; см &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt; ). Список &lt;code&gt;tls_options()&lt;/code&gt; может быть пустым. Функция &lt;code&gt;ssl:connect/3&lt;/code&gt; используется для защиты как управляющего соединения, так и сеансов передачи данных.</target>
        </trans-unit>
        <trans-unit id="ec1a584f866f164173d4d24514175788fabda6fc" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{tls, tls_options()}&lt;/code&gt; is present, the FTP session is transported over &lt;code&gt;tls&lt;/code&gt; (&lt;code&gt;ftps&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt;). The list &lt;code&gt;tls_options()&lt;/code&gt; can be empty. The function &lt;code&gt;ssl:connect/3&lt;/code&gt; is used for securing both the control connection and the data sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a3a531905a20d30fd9f374cce827942989f5e9" translate="yes" xml:space="preserve">
          <source>If option&lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если параметр &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; присутствует, процесс &lt;code&gt;gen_statem&lt;/code&gt; ожидает любого сообщения в течение миллисекунд &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; , а если сообщение не получено, процесс автоматически переходит в режим гибернации (путем вызова &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2fd0a104622064a3e02a4f4c3eca0f47d309b91b" translate="yes" xml:space="preserve">
          <source>If or when &lt;code&gt;monitor/2&lt;/code&gt; is extended, other possible values for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;Info&lt;/code&gt; in the monitor message will be introduced.</source>
          <target state="translated">Если или когда &lt;code&gt;monitor/2&lt;/code&gt; расширен, будут представлены другие возможные значения для &lt;code&gt;Tag&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; и &lt;code&gt;Info&lt;/code&gt; в сообщении монитора.</target>
        </trans-unit>
        <trans-unit id="a47b00202aed4c182ff58ce236e280bf55db7d71" translate="yes" xml:space="preserve">
          <source>If other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have the driver loaded, this option has no effect.</source>
          <target state="translated">Если драйвер загружен другими &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; , этот параметр не действует.</target>
        </trans-unit>
        <trans-unit id="597bab21aef8fd8fbc55474998e0dbac33663b0f" translate="yes" xml:space="preserve">
          <source>If padding is &lt;code&gt;{padding,none}&lt;/code&gt; or not specifed and the total data from all subsequent &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_updates&lt;/a&gt;&lt;/code&gt; does not fill the last block fully, that last data is lost. In case of &lt;code&gt;{padding,none}&lt;/code&gt; there will be an error in this case. If padding is not specified, the bytes of the unfilled block is silently discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1578eb3698cf666fa7f690b04c9f11cc163c2d2b" translate="yes" xml:space="preserve">
          <source>If padding was not enabled, the call to &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; may be excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b3ce2063e2924ca7e8faa87611f5b6c2819567" translate="yes" xml:space="preserve">
          <source>If parameter &lt;code&gt;Dates&lt;/code&gt; is specified, the reports are filtered according to the date when they occurred. If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateFrom, from}&lt;/code&gt;, reports that occurred after &lt;code&gt;DateFrom&lt;/code&gt; are displayed.</source>
          <target state="translated">Если указан параметр &lt;code&gt;Dates&lt;/code&gt; , отчеты фильтруются по дате их появления. Если &lt;code&gt;Dates&lt;/code&gt; имеют форму &lt;code&gt;{DateFrom, from}&lt;/code&gt; , отображаются отчеты, &lt;code&gt;DateFrom&lt;/code&gt; после DateFrom .</target>
        </trans-unit>
        <trans-unit id="6511239690521e295477c51f44e7169510af0e54" translate="yes" xml:space="preserve">
          <source>If possible, avoid writing or deleting records in the same transaction before iterating over the table.</source>
          <target state="translated">По возможности избегайте записи или удаления записей в одной и той же транзакции перед итерацией по таблице.</target>
        </trans-unit>
        <trans-unit id="3eb1eeddf032eb186133fc7df8919fb2d11d384d" translate="yes" xml:space="preserve">
          <source>If possible, the client keeps its connections alive and uses persistent connections with or without pipeline depending on configuration and current circumstances. The HTTP/1.1 specification does not provide a guideline for how many requests that are ideal to be sent on a persistent connection. This depends much on the application.</source>
          <target state="translated">По возможности клиент сохраняет свои соединения и использует постоянные соединения с или без трубопровода в зависимости от конфигурации и текущих обстоятельств.Спецификация HTTP/1.1 не содержит указаний на то,сколько запросов,идеально подходящих для отправки по постоянному соединению.Это во многом зависит от приложения.</target>
        </trans-unit>
        <trans-unit id="6eb80024b1f8a5a58791d40e0d60ce7a9e24c7b7" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved before any preceding separator characters on the same line. E.g.:</source>
          <target state="translated">Если возможно,комментарий должен быть перемещен перед любыми предыдущими символами разделителя в той же строке.Например:</target>
        </trans-unit>
        <trans-unit id="11f459fa45ff86ea26d4123b486b2667eb195a88" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved past any following separator characters on the same line, rather than placing the separators on the following line. E.g.:</source>
          <target state="translated">По возможности,комментарий следует перемещать мимо любых последующих символов разделителя в одной строке,а не размещать разделители в следующей строке.Например:</target>
        </trans-unit>
        <trans-unit id="0e22a764d95b33db30751234a49a657e83e7510e" translate="yes" xml:space="preserve">
          <source>If possible, use the &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; module to extract the compiler options and the abstract code format from the Beam file and compile that instead.</source>
          <target state="translated">Если возможно, используйте &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; чтобы извлечь параметры компилятора и формат абстрактного кода из файла Beam и вместо этого скомпилировать его.</target>
        </trans-unit>
        <trans-unit id="aede57d6ae41eb953c1c470da89fb0e057e8b902" translate="yes" xml:space="preserve">
          <source>If precedence is client, the negotiated protocol is the first protocol to be shown on the client preference list, which is also on the server advertised list.</source>
          <target state="translated">Если приоритет является клиентом,то согласованный протокол является первым протоколом,который отображается в списке предпочтений клиента,который также находится в списке рекламируемых серверов.</target>
        </trans-unit>
        <trans-unit id="51ff54d9c737f36da2074bfa07dabdd6029e6f8a" translate="yes" xml:space="preserve">
          <source>If precedence is server, the negotiated protocol is the first protocol to be shown on the server advertised list, which is also on the client preference list.</source>
          <target state="translated">Если предпочтение отдается серверу,то согласованный протокол является первым протоколом,который отображается в списке объявлений сервера,который также находится в списке предпочтений клиента.</target>
        </trans-unit>
        <trans-unit id="6739d735ae41522a99fdf3833670c2cb63d21a98" translate="yes" xml:space="preserve">
          <source>If present, this option specifies the options for the &lt;strong&gt;audit trail logging&lt;/strong&gt;. The &lt;code&gt;disk_log&lt;/code&gt; module is used to maintain a wrap log. If present, the &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; options are mandatory.</source>
          <target state="translated">Если присутствует, этот параметр указывает параметры для &lt;strong&gt;ведения журнала аудита&lt;/strong&gt; . Модуль &lt;code&gt;disk_log&lt;/code&gt; используется для ведения журнала переноса . Если есть, параметры &lt;code&gt;dir&lt;/code&gt; и &lt;code&gt;size&lt;/code&gt; являются обязательными.</target>
        </trans-unit>
        <trans-unit id="c374078c3ce837fa7c145904897f0747ce0fa052" translate="yes" xml:space="preserve">
          <source>If process metadata exists for the current process, this function behaves as if it was implemented as follows:</source>
          <target state="translated">Если для текущего процесса существуют метаданные процесса,то эта функция ведет себя так,как если бы она была реализована следующим образом:</target>
        </trans-unit>
        <trans-unit id="6453efa6a699c594656266a7d0d5934c8aa65586" translate="yes" xml:space="preserve">
          <source>If pseudo function triggering the translation is &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single tuple. If the pseudo function is &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single list.</source>
          <target state="translated">Если &lt;code&gt;ets:fun2ms/1&lt;/code&gt; запускающая перевод, - ets: fun2ms / 1 , заголовок развлечения должен содержать одну переменную или один кортеж. Если &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; , заголовок развлечения должен содержать одну переменную или один список.</target>
        </trans-unit>
        <trans-unit id="3bbf5cb920ce0732e8a77fc0ab511fa8e53d27bc" translate="yes" xml:space="preserve">
          <source>If quantifier is {0,n}, where n &amp;gt; 0, it is treated as if it was {0,1}. At runtime, the remaining pattern match is tried with and without the assertion, the order depends on the greediness of the quantifier.</source>
          <target state="translated">Если квантификатор равен {0, n}, где n&amp;gt; 0, он обрабатывается так, как если бы он был {0,1}. Во время выполнения проверяется оставшееся сопоставление с шаблоном с утверждением и без него, порядок зависит от жадности квантификатора.</target>
        </trans-unit>
        <trans-unit id="a4e6534fccad96b9c365841e907e49b7cde2c28d" translate="yes" xml:space="preserve">
          <source>If records are written and deleted during the traversal, use the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;write&lt;/code&gt; lock. Or the function &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; when using &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">Если записи записываются и удаляются во время обхода, используйте функцию &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; с блокировкой &lt;code&gt;write&lt;/code&gt; . Или функция &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; при использовании &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="169c4bd14dbb4d6e16657fce0c0a61cc8e3f8798" translate="yes" xml:space="preserve">
          <source>If reloading is not requested, it can still be useful to specify option &lt;code&gt;monitor&lt;/code&gt;, as forced unloads (driver option &lt;code&gt;kill_ports&lt;/code&gt; or option &lt;code&gt;kill_ports&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;) trigger a transient state where driver loading cannot be performed until all closing ports are closed. Thus, as &lt;code&gt;try_unload&lt;/code&gt; can, in almost all situations, return &lt;code&gt;{ok, pending_driver}&lt;/code&gt;, always specify at least &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; in production code (see the monitor discussion earlier).</source>
          <target state="translated">Если перезагрузка не запрашивается, все еще может быть полезно указать &lt;code&gt;monitor&lt;/code&gt; параметров , поскольку принудительные выгрузки (параметр драйвера &lt;code&gt;kill_ports&lt;/code&gt; или параметр &lt;code&gt;kill_ports&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; ) запускают переходное состояние, при котором загрузка драйвера не может быть выполнена, пока все закрывающиеся порты не будут закрыты. Таким образом, поскольку &lt;code&gt;try_unload&lt;/code&gt; может почти во всех ситуациях возвращать &lt;code&gt;{ok, pending_driver}&lt;/code&gt; , всегда указывайте как минимум &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; в производственном коде (см. Обсуждение монитора ранее).</target>
        </trans-unit>
        <trans-unit id="55c076ea86b99a552c3ee63a0beaa5dfb25c1e33" translate="yes" xml:space="preserve">
          <source>If resolver option &lt;code&gt;inet6&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, an IPv6 address is looked up.</source>
          <target state="translated">Если опция распознаватель &lt;code&gt;inet6&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , IPv6 - адрес ищется.</target>
        </trans-unit>
        <trans-unit id="71218f752e39cbf302806385e7e620598fcd4560" translate="yes" xml:space="preserve">
          <source>If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode.</source>
          <target state="translated">Если на определенном узле включен режим ограниченного доступа,удаленные оболочки,соединяющиеся с этим узлом,также работают в режиме ограниченного доступа.</target>
        </trans-unit>
        <trans-unit id="81be79c2e31a4efcff85293a46775d5d0aa9c619" translate="yes" xml:space="preserve">
          <source>If run with option &lt;code&gt;caseless&lt;/code&gt;, this pattern matches phrases such as &quot;A man, a plan, a canal: Panama!&quot; and it works well in both PCRE and Perl. Notice the use of the possessive quantifier *+ to avoid backtracking into sequences of non-word characters. Without this, PCRE takes much longer (10 times or more) to match typical phrases, and Perl takes so long that you think it has gone into a loop.</source>
          <target state="translated">Если запустить с опцией &lt;code&gt;caseless&lt;/code&gt; , этот шаблон соответствует таким фразам, как &amp;laquo;Человек, план, канал: Панама!&amp;raquo; и он хорошо работает как в PCRE, так и в Perl. Обратите внимание на использование притяжательного квантификатора * +, чтобы избежать возврата к последовательностям несловесных символов. Без этого PCRE требует гораздо больше времени (в 10 или более раз) для сопоставления типичных фраз, а Perl занимает так много времени, что кажется, что он зациклился.</target>
        </trans-unit>
        <trans-unit id="56762a0f1f42178490b0db9862f2814f477e1842" translate="yes" xml:space="preserve">
          <source>If set before start, the &lt;code&gt;epmd&lt;/code&gt; daemon behaves as if option &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified at startup. Consequently, if this option is set before starting the Erlang virtual machine, the automatically started &lt;code&gt;epmd&lt;/code&gt; accepts the &lt;code&gt;-kill&lt;/code&gt; and &lt;code&gt;-stop&lt;/code&gt; commands without restrictions.</source>
          <target state="translated">Если установлено до запуска, демон &lt;code&gt;epmd&lt;/code&gt; ведет себя так, как если &lt;code&gt;-relaxed_command_check&lt;/code&gt; при запуске была указана опция -relaxed_command_check . Следовательно, если этот параметр установлен перед запуском виртуальной машины Erlang, автоматически запускаемый &lt;code&gt;epmd&lt;/code&gt; принимает команды &lt;code&gt;-kill&lt;/code&gt; и &lt;code&gt;-stop&lt;/code&gt; без ограничений.</target>
        </trans-unit>
        <trans-unit id="9f59dad82faaa4c2914703b6f2eec0c0bd7bf03c" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если установлен спящий режим, &lt;code&gt;gen_statem&lt;/code&gt; рассматривается в разделе &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="997d2e694bf42fce758c366fad9b952364db63dd" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60eef1c452cfc1dd1bd601c01baa121d5df8c903" translate="yes" xml:space="preserve">
          <source>If set in binary mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;{binary, true}&lt;/code&gt;), the I/O server sends binary data (encoded in UTF-8) as answers to the &lt;code&gt;get_line&lt;/code&gt;, &lt;code&gt;get_chars&lt;/code&gt;, and, if possible, &lt;code&gt;get_until&lt;/code&gt; requests (for details, see section &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt;) in the User's Guide). The immediate effect is that &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; return UTF-8 binaries instead of lists of characters for the affected I/O device.</source>
          <target state="translated">Если установлен в двоичном режиме ( &lt;code&gt;binary&lt;/code&gt; или &lt;code&gt;{binary, true}&lt;/code&gt; ), сервер ввода-вывода отправляет двоичные данные (закодированные в UTF-8) в качестве ответов на &lt;code&gt;get_line&lt;/code&gt; , &lt;code&gt;get_chars&lt;/code&gt; и, если возможно, &lt;code&gt;get_until&lt;/code&gt; (подробности см. раздел &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt; ) в Руководстве пользователя). Непосредственный эффект заключается в том, что &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; возвращают двоичные файлы UTF-8 вместо списков символов для затронутого устройства ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="60e11f2d401fbb6a7bc13e95b2d0df9464865aea" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если установлено отложить текущее событие, см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfee0bffb0c9371226233925794bed564e96b2bf" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2642f766dbab3720562602e51b82a07e9e8906" translate="yes" xml:space="preserve">
          <source>If set the scheduler id is to be included by the tracer.</source>
          <target state="translated">Если установлено,то идентификатор планировщика должен быть включен трассировщиком.</target>
        </trans-unit>
        <trans-unit id="913831f334573f274f7a4b77334d9d4e872f104b" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36ae2f0946222aa466ec9f357bec978063329ec" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если установлено, точка трассировки включала дополнительные данные о событии трассировки. Какие дополнительные данные будут зависеть от &lt;code&gt;TraceTag&lt;/code&gt; . Эти &lt;code&gt;extra&lt;/code&gt; соответствуют данным трассировки к пятому элементу в следовых кортежах описаны в &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="537421ac5bc876e1157770197d20f5be1d7bdfa8" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include a time stamp.</source>
          <target state="translated">Если в настройках трассировщика было запрошено включение временной метки.</target>
        </trans-unit>
        <trans-unit id="ebb92b7f506965bd75353ec4f02388501a5389c5" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include the output of a match specification that was run.</source>
          <target state="translated">Если задан параметр,то трассировщик должен включить вывод выполненной спецификации на соответствие.</target>
        </trans-unit>
        <trans-unit id="655f54de5d5fcd636afc8c5192a0cd83bf1d3634" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, TLS/DTLS Alert reports are not displayed. Deprecated in OTP 22, use {log_level, &lt;code&gt;&lt;a href=&quot;#type-logging_level&quot;&gt;logging_level()&lt;/a&gt;&lt;/code&gt;} instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c658f8f2f205584d1fb8b1c5da7c1178ed36dd48" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, error reports are not displayed.</source>
          <target state="translated">Если установлено значение &lt;code&gt;false&lt;/code&gt; , отчеты об ошибках не отображаются.</target>
        </trans-unit>
        <trans-unit id="2c4759d1764534d362731027d076405776344611" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on_heap&lt;/code&gt;, the sending process will first attempt to allocate the space for the message directly on the young heap block of the receiving process. This is not always possible as it requires taking the &lt;strong&gt;main lock&lt;/strong&gt; of the receiving process. The main lock is also held when the process is executing. The possibility for a lock conflict is thus likely in an intensely collaborating system. If the sending process cannot acquire the main lock, a heap fragment is instead created for the message and the message payload is copied onto that. With the &lt;code&gt;off_heap&lt;/code&gt; option the sender process always creates heap fragments for messages sent to that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310d96f77be1e1791ce6fea41e63aca706ddcee9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; a header field is added to logger_formatter's part of &lt;code&gt;Metadata&lt;/code&gt;. The value of this field is a string similar to the header created by the old &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; event handlers. It can be included in the log event by adding the list &lt;code&gt;[logger_formatter,header]&lt;/code&gt; to the template. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , поле заголовка добавляется в часть &lt;code&gt;Metadata&lt;/code&gt; logger_formatter . Значение этого поля представляет собой строку, аналогичную заголовку, создаваемому старыми обработчиками событий &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; . Его можно включить в событие журнала, добавив в &lt;code&gt;[logger_formatter,header]&lt;/code&gt; список [logger_formatter, header] . См. Описание типа &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="bd8fb908e24bb62be623e19143f8ea77156d0120" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TCLASS&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; option &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; or &lt;code&gt;IPV6_2292RECVTCLASS&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{tclass,TCLASS}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IPV6_TCLASS&lt;/code&gt; or an &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; CMSG value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1327e3fb152f87bc84a12b83acd5ce3c1ed9810" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TOS&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IP&lt;/code&gt; option &lt;code&gt;IP_RECVTOS&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{tos,TOS}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IP_TOS&lt;/code&gt; or an &lt;code&gt;IP_RECVTOS&lt;/code&gt; CMSG value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ca95fc90cd615829fa6bcc45ce252e70ac9443" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TTL&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IP&lt;/code&gt; option &lt;code&gt;IP_RECVTTL&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{ttl,TTL}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IP_TTL&lt;/code&gt; or an &lt;code&gt;IP_RECVTTL&lt;/code&gt; CMSG value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce4e9a3ec15985becd6d1fc4438e42ee9f02d87" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, all newlines in the message are replaced with &lt;code&gt;&quot;, &quot;&lt;/code&gt;, and white spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , все символы новой строки в сообщении заменяются на &lt;code&gt;&quot;, &quot;&lt;/code&gt; и пробелы, следующие сразу после удаления новой строки. Обратите внимание, что новые строки, добавленные параметром &lt;code&gt;template&lt;/code&gt; , не заменяются.</target>
        </trans-unit>
        <trans-unit id="bdbfcee3def687520000625ed9063759bcd7fdfe" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, each log event is printed as a single line. To achieve this, &lt;code&gt;logger_formatter&lt;/code&gt; sets the field width to &lt;code&gt;0&lt;/code&gt; for all &lt;code&gt;~p&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; control sequences in the format a string (see &lt;code&gt; io:format/2&lt;/code&gt;), and replaces all newlines in the message with &lt;code&gt;&quot;, &quot;&lt;/code&gt;. White spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bc2e449028a1b238287b1e7e1da57633ce0aa2" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;ct_master logs&lt;/code&gt; are written on a primitive HTML format, not using the &lt;code&gt;Common Test&lt;/code&gt; CSS style sheet.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;ct_master logs&lt;/code&gt; пишутся в примитивном формате HTML, без использования таблицы стилей CSS &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c67db27336a237041f3f770706b8f2027a618516" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; try to repair the source code as it seems fit, in certain cases where parsing would otherwise fail. Currently, it inserts &lt;code&gt;++&lt;/code&gt;-operators between string literals and macros where it looks like concatenation was intended. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , это заставляет &lt;code&gt;epp_dodger&lt;/code&gt; пытаться восстановить исходный код так, как он кажется нужным, в некоторых случаях, когда в противном случае синтаксический анализ не удался. В настоящее время он вставляет &lt;code&gt;++&lt;/code&gt; -операторы между строковыми литералами и макросами там, где, похоже, предполагалось объединение. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="553412c0540657c6dfbc0cf5ff30e8dae32d51db" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, use the server preference for cipher selection. If set to &lt;code&gt;false&lt;/code&gt; (the default), use the client preference.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , используйте предпочтения сервера для выбора шифра. Если установлено значение &lt;code&gt;false&lt;/code&gt; (по умолчанию), используйте предпочтения клиента.</target>
        </trans-unit>
        <trans-unit id="845d16e801c4d035d7da73e779db3b12f92e8193" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, workarounds for known server deviations from the HTTP-standard are enabled.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , разрешены обходные пути для известных отклонений сервера от стандарта HTTP.</target>
        </trans-unit>
        <trans-unit id="4e5151c0c30a4e7bb11fe24669fcb768cff8dff0" translate="yes" xml:space="preserve">
          <source>If set to anything else than &lt;code&gt;0&lt;/code&gt;, it makes all times displayed by &lt;code&gt;run_erl&lt;/code&gt; to be in UTC (GMT, CET, MET, without Daylight Saving Time), rather than in local time. This does not affect data coming from Erlang, only the logs output directly by &lt;code&gt;run_erl&lt;/code&gt;. Application SASL can be modified accordingly by setting the Erlang application variable &lt;code&gt;utc_log&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если установлено любое другое значение, кроме &lt;code&gt;0&lt;/code&gt; , все время, отображаемое &lt;code&gt;run_erl&lt;/code&gt; , будет отображаться в формате UTC (GMT, CET, MET, без перехода на летнее время), а не по местному времени. Это не влияет на данные, поступающие из Erlang, только на вывод логов напрямую &lt;code&gt;run_erl&lt;/code&gt; . SASL приложения можно соответствующим образом изменить, установив для переменной приложения Erlang &lt;code&gt;utc_log&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54ecba8897a2d3cf6ca4714afe4059ed1a0bc69c" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, an unlimited number of login attempts are allowed simultaneously.</source>
          <target state="translated">Если установлено значение false (значение по умолчанию),одновременно обрабатывается только один логин.Если установлено значение true,одновременно разрешено неограниченное количество попыток входа.</target>
        </trans-unit>
        <trans-unit id="d7a47f9a94c76c57c796417eab15c787a00acacf" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, the number of simultaneous login attempts are limited by the value of &lt;code&gt;&lt;a href=&quot;ssh#hardening_daemon_options--max_sessions&quot;&gt;max_sessions&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e5e755a8f0aa4316d9b9f5d9dcea02be971e72" translate="yes" xml:space="preserve">
          <source>If set to other than &quot;NoPassword&quot;, the password is required for all API calls. If the password is set to &quot;DummyPassword&quot;, the password must be changed before any other API calls. To secure the authenticating data, the password must be changed after the web server is started. Otherwise it is written in clear text in the configuration file.</source>
          <target state="translated">Если установлено значение,отличное от &quot;NoPassword&quot;,то пароль требуется для всех вызовов API.Если пароль установлен в &quot;DummyPassword&quot;,то пароль должен быть изменен перед любыми другими вызовами API.Для обеспечения безопасности аутентификационных данных,пароль должен быть изменен после запуска веб-сервера.В противном случае он записывается открытым текстом в конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="9508965c72b0132e5a02e474dd8d5307005afa10" translate="yes" xml:space="preserve">
          <source>If set, the &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;writev()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;read()&lt;/code&gt; callbacks implements timeouts. The timeout is passed in the &lt;code&gt;tmo&lt;/code&gt; argument and is given in milli seconds. Note that the &lt;code&gt;tmo&lt;/code&gt; argument to these callbacks differ from the timeout arguments in the &lt;code&gt;ei&lt;/code&gt; API. Zero means a zero timeout. That is, poll and timeout immediately unless the operation is successful. &lt;code&gt;EI_SCLBK_INF_TMO&lt;/code&gt; (max &lt;code&gt;unsigned&lt;/code&gt;) means infinite timeout. The file descriptor is in blocking mode when a callback is called, and it must be in blocking mode when the callback returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc8baf201837b9902d99d9c6ceeaafc45b233fd" translate="yes" xml:space="preserve">
          <source>If several fields are to be assigned the same value, the following construction can be used:</source>
          <target state="translated">Если нескольким полям необходимо присвоить одно и то же значение,можно использовать следующую конструкцию:</target>
        </trans-unit>
        <trans-unit id="21ef3b935d35dcc97954564f91b02dc29963a181" translate="yes" xml:space="preserve">
          <source>If so, or if possibly needed in future versions, then you should consider using &lt;code&gt;gen_statem&lt;/code&gt; over &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">Если это так, или , если возможно , необходимо в версиях будущих, то вам следует рассмотреть возможность использования &lt;code&gt;gen_statem&lt;/code&gt; над &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f43fb2b2715e85b137bcfdf2730b0beccbdd0c4b" translate="yes" xml:space="preserve">
          <source>If so, the user is authorized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f2cb0ac87e42cdbdf8827c536efd85bb8b5ca2" translate="yes" xml:space="preserve">
          <source>If some of the found BEAM files contain &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then those modules are checked and a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">Если некоторые из найденных файлов BEAM содержат &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; , то эти модули проверяются и возвращается список кортежей. Первый элемент каждого кортежа является одним из:</target>
        </trans-unit>
        <trans-unit id="6a5a8a25ced47d4519279df0ad60d300b9fdd3ac" translate="yes" xml:space="preserve">
          <source>If some variables were present in the configuration, but are not loaded using this function, they are removed from the configuration table together with their aliases.</source>
          <target state="translated">Если некоторые переменные присутствовали в конфигурации,но не были загружены с помощью этой функции,то они удаляются из таблицы конфигурации вместе с их псевдонимами.</target>
        </trans-unit>
        <trans-unit id="908c252e088323e888f147ff16d100c7706161d0" translate="yes" xml:space="preserve">
          <source>If something goes wrong, the function can also return an error tuple &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">Если что-то пойдет не так, функция также может вернуть кортеж &lt;code&gt;{error,Error}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70476ad38abe74628a91e231b10da869d250c572" translate="yes" xml:space="preserve">
          <source>If specified by its filename, the filename can include a path and the &lt;code&gt;.erl&lt;/code&gt; extension can be omitted. The object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for first in the same directory as the source code, then in an &lt;code&gt;ebin&lt;/code&gt; directory next to it, and then in the current path.</source>
          <target state="translated">Если указано в имени файла, имя файла может включать путь, а расширение &lt;code&gt;.erl&lt;/code&gt; можно не указывать. Объектный код &lt;code&gt;Module.beam&lt;/code&gt; ищется сначала в том же каталоге, что и исходный код, затем в каталоге &lt;code&gt;ebin&lt;/code&gt; рядом с ним, а затем по текущему пути.</target>
        </trans-unit>
        <trans-unit id="50b19f1c8b9a65cb742065615e51dec1da364a91" translate="yes" xml:space="preserve">
          <source>If specified by its module name, the object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for in the current path. The source code &lt;code&gt;Module.erl&lt;/code&gt; is searched for first in the same directory as the object code, then in an &lt;code&gt;src&lt;/code&gt; directory next to it.</source>
          <target state="translated">Если указано в имени модуля, объектный код &lt;code&gt;Module.beam&lt;/code&gt; ищется в текущем пути. Исходный код &lt;code&gt;Module.erl&lt;/code&gt; ищется сначала в том же каталоге, что и объектный код, а затем в каталоге &lt;code&gt;src&lt;/code&gt; рядом с ним.</target>
        </trans-unit>
        <trans-unit id="a8d0b6cf013a5c0d8770719696ef065b65aefbe7" translate="yes" xml:space="preserve">
          <source>If starting the test with a general verbosity level of 50 (&lt;code&gt;?STD_VERBOSITY&lt;/code&gt;):</source>
          <target state="translated">Если запускать тест с общим уровнем &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; 50 ( ? STD_VERBOSITY ):</target>
        </trans-unit>
        <trans-unit id="bff20119788e7f9fcb0386bb0ba5f7207f1771ed" translate="yes" xml:space="preserve">
          <source>If starting the test with:</source>
          <target state="translated">Если начать тест с:</target>
        </trans-unit>
        <trans-unit id="26a65a58a274c5e83de124292f3254f1ac090467" translate="yes" xml:space="preserve">
          <source>If status was &lt;code&gt;alive&lt;/code&gt;, node &lt;code&gt;A&lt;/code&gt; answers with another status message containing either &lt;code&gt;true&lt;/code&gt;, which means that the connection is to continue (the old connection from this node is broken), or &lt;code&gt;false&lt;/code&gt;, which means that the connection is to be closed (the connection attempt was a mistake.</source>
          <target state="translated">Если статус был &lt;code&gt;alive&lt;/code&gt; , узел &lt;code&gt;A&lt;/code&gt; отвечает другим статусным сообщением, содержащим либо &lt;code&gt;true&lt;/code&gt; , что означает, что соединение должно продолжаться (старое соединение с этого узла разорвано), либо &lt;code&gt;false&lt;/code&gt; , что означает, что соединение должно быть закрыто (соединение попытка была ошибкой.</target>
        </trans-unit>
        <trans-unit id="7b9b70b7cbd405f4ef48bddbc33725b6c4cf3c30" translate="yes" xml:space="preserve">
          <source>If sticky locks are used, the code must first be changed as follows:</source>
          <target state="translated">Если используются клейкие замки,то сначала необходимо изменить код следующим образом:</target>
        </trans-unit>
        <trans-unit id="c7eb71447bfe22582a45b3625c21c45102fb30a5" translate="yes" xml:space="preserve">
          <source>If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:</source>
          <target state="translated">Если в регулярном выражении указаны подвыражения,то в результирующем списке также возвращаются совпадающие подвыражения.Например:</target>
        </trans-unit>
        <trans-unit id="0b8ddaa042ba6e6a6e6f3aa8c56ca060f0b33630" translate="yes" xml:space="preserve">
          <source>If successful</source>
          <target state="translated">В случае успеха</target>
        </trans-unit>
        <trans-unit id="211664819a4310bd77112b972f6e1afd6ef67b18" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state in an &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple.</source>
          <target state="translated">В случае успеха функция должна вернуть обновленное внутреннее состояние в кортеже &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8c6ee9fde6d55757690d169dc69ff0e99e718e" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state.</source>
          <target state="translated">В случае успеха функция должна вернуть обновленное внутреннее состояние.</target>
        </trans-unit>
        <trans-unit id="932989b7c1361152a0b0809cc73761645d677b31" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; exists but the corresponding child process is running or is about to be restarted, the function returns &lt;code&gt;{error,running}&lt;/code&gt; or &lt;code&gt;{error,restarting}&lt;/code&gt;, respectively. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">В случае успеха функция возвращает &lt;code&gt;ok&lt;/code&gt; . Если дочерняя спецификация, идентифицированная идентификатором &lt;code&gt;Id&lt;/code&gt; , существует, но соответствующий дочерний процесс запущен или собирается перезапускаться, функция возвращает &lt;code&gt;{error,running}&lt;/code&gt; или &lt;code&gt;{error,restarting}&lt;/code&gt; соответственно. Если &lt;code&gt;{error,not_found}&lt;/code&gt; спецификация, идентифицированная &lt;code&gt;Id&lt;/code&gt; , не существует, функция возвращает {error, not_found} .</target>
        </trans-unit>
        <trans-unit id="2a7459c85147eae0af4289577e8d8cb1033070c0" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If there is no child specification with the specified &lt;code&gt;Id&lt;/code&gt;, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">В случае успеха функция возвращает &lt;code&gt;ok&lt;/code&gt; . Если &lt;code&gt;{error,not_found}&lt;/code&gt; спецификация с указанным &lt;code&gt;Id&lt;/code&gt; , функция возвращает {error, not_found} .</target>
        </trans-unit>
        <trans-unit id="6c554336fd49d3d6148f3873055df50396396c91" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;{ok,State}&lt;/code&gt; or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial internal state of the event handler.</source>
          <target state="translated">В случае успеха функция возвращает &lt;code&gt;{ok,State}&lt;/code&gt; или &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; , где &lt;code&gt;State&lt;/code&gt; - начальное внутреннее состояние обработчика событий.</target>
        </trans-unit>
        <trans-unit id="2203259483f235e1b092ade2119d4c07d6241b2e" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map or if it does not contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">В случае успеха эта функция устанавливает &lt;code&gt;*map_out&lt;/code&gt; для новой карты и возвращает &lt;code&gt;true&lt;/code&gt; . Возвращает &lt;code&gt;false&lt;/code&gt; , если &lt;code&gt;map_in&lt;/code&gt; не является картой или не содержит &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba18cbb490e9c8d2f3b6ef180516f04715f3defa" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map.</source>
          <target state="translated">В случае успеха эта функция устанавливает &lt;code&gt;*map_out&lt;/code&gt; для новой карты и возвращает &lt;code&gt;true&lt;/code&gt; . Возвращает &lt;code&gt;false&lt;/code&gt; , если &lt;code&gt;map_in&lt;/code&gt; не является картой.</target>
        </trans-unit>
        <trans-unit id="c57bdf287994755b6e44fdfc60facab5a9f11a53" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; there are any duplicate keys.</source>
          <target state="translated">В случае успеха эта функция устанавливает &lt;code&gt;*map_out&lt;/code&gt; для новой карты и возвращает &lt;code&gt;true&lt;/code&gt; . Возвращает &lt;code&gt;false&lt;/code&gt; , если есть повторяющиеся ключи.</target>
        </trans-unit>
        <trans-unit id="235077c5f09d774b9f3db45cd19ec2e827847cd9" translate="yes" xml:space="preserve">
          <source>If such a clause cannot be found, a &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">Если такое предложение не может быть найдено, возникает ошибка времени выполнения &lt;code&gt;function_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="283f86d98b5d92d6ad1ce6bfc63055da78218576" translate="yes" xml:space="preserve">
          <source>If such a clause is found, the corresponding clause body is evaluated. That is, the expressions in the body are evaluated sequentially and the value of the last expression is returned.</source>
          <target state="translated">Если такой пункт найден,то оценивается соответствующий орган пункта.То есть выражения в теле вычисляются последовательно и возвращается значение последнего выражения.</target>
        </trans-unit>
        <trans-unit id="b28412a4d9f9549fe2f357ee3ab836136e195e5c" translate="yes" xml:space="preserve">
          <source>If support is found, the option &lt;code&gt;{property_test_tool,ToolModule}&lt;/code&gt; with the selected tool main module name (&lt;code&gt;eqc&lt;/code&gt;, &lt;code&gt;proper&lt;/code&gt; or &lt;code&gt;triq&lt;/code&gt;) is added to the list &lt;code&gt;Config&lt;/code&gt; which then is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fcf16676aca666b69b183aa34b448a75829f94" translate="yes" xml:space="preserve">
          <source>If synchronization is not possible, an error report is sent to the error logger (see also &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если синхронизация невозможна, отчет об ошибке отправляется регистратору ошибок (см. Также &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36f347d7b778b3a4f6fb90496e2acb23c2a7a864" translate="yes" xml:space="preserve">
          <source>If syntax errors are discovered in these files they are reported with the function &lt;code&gt;config_err/2&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; at start-up.</source>
          <target state="translated">Если синтаксические ошибки обнаружены в этих файлах , они сообщаются с функцией &lt;code&gt;config_err/2&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; при запуске.</target>
        </trans-unit>
        <trans-unit id="e5db19b0c235be5b01f2325198c01dc60d89585f" translate="yes" xml:space="preserve">
          <source>If tagged allocations are not enabled on any of the specified allocator types, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">Если тегированные выделения не включены ни для одного из указанных типов распределителя, вызов завершится неудачно с &lt;code&gt;{error, not_enabled}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="430e9485ed1c99e4dac7dca3da3dfa4aa8c39ab8" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; cannot be compiled (does not represent a valid match specification), a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если термин &lt;code&gt;MatchSpec&lt;/code&gt; не может быть скомпилирован (не представляет допустимую спецификацию соответствия), &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="763ff93c3062ce44172fb309cebb5a06079fead9" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; does not represent a valid match specification, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34a1091c99e6fe485396a9633ee9cf35b5e6022" translate="yes" xml:space="preserve">
          <source>If test suites or help modules include header files stored in other locations than the test directory, these include directories can be specified by using flag &lt;code&gt;-include&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, or option &lt;code&gt;include&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. Also, an include path can be specified with an OS environment variable, &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt;.</source>
          <target state="translated">Если комплекты тестов или модули справки включают файлы заголовков, хранящиеся в других местах, кроме тестового каталога, эти &lt;code&gt;-include&lt;/code&gt; каталоги могут быть указаны с помощью флага -include с &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; или опции &lt;code&gt;include&lt;/code&gt; с &lt;code&gt;ct:run_test/1&lt;/code&gt; . Кроме того, путь включения можно указать с помощью переменной среды ОС &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e790d3acc547bf4dd4b0058bee91f205e4b15cf" translate="yes" xml:space="preserve">
          <source>If the &quot;certificate_authorities&quot; extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c1965cf3b85e5ae91bfc7f462d56b4e302c996" translate="yes" xml:space="preserve">
          <source>If the 'main' worker is busy, a temporary process is spawned to handle that 'get-request'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece8268eb3bcace140f99c6e854d866eed3ef694" translate="yes" xml:space="preserve">
          <source>If the 'main' worker is busy, a temporary process is spawned to handle that job ('get-request' or notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9279b9016abb718b19436b545788de84fa2134f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, BEAM files that contain no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; are ignored.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; сервера внешних ссылок - &lt;code&gt;functions&lt;/code&gt; , файлы BEAM, не содержащие &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; , игнорируются.</target>
        </trans-unit>
        <trans-unit id="c813a10d16024092b88cb717d0c880a3632b14a1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, and the BEAM file contains no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, the error message &lt;code&gt;no_debug_info&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; сервера внешних ссылок - это &lt;code&gt;functions&lt;/code&gt; , а файл BEAM не содержит &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; , возвращается сообщение об ошибке &lt;code&gt;no_debug_info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef80d1f8c11747796d02d57345e648de2094089e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9197e338e3401c234d140df6601d7f0bd0de9f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;handle_event_function&lt;/code&gt; , состояние может быть любым. После изменения состояния ( &lt;code&gt;NextState =/= State&lt;/code&gt; ) все отложенные события повторяются.</target>
        </trans-unit>
        <trans-unit id="77912caa4ee948d9b6eee0f54f2cb39e15b274ee" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom. After a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried. Note that the state &lt;code&gt;terminate&lt;/code&gt; is not possible to use since it would collide with the optional callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c7a5f40b37419e0dfdb9c000a09ebaefa7ede7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be of this type. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;state_functions&lt;/code&gt; , состояние должно быть этого типа. После изменения состояния ( &lt;code&gt;NextState =/= State&lt;/code&gt; ) все отложенные события повторяются.</target>
        </trans-unit>
        <trans-unit id="693335b3ceb4c3438c26542cdb03f54e066d8540" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt; erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720d616c478f9b1d1e0e376e567468c7cbccb10c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; был установлен в &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; , данные могут быть принудительно переданы в драйвер через &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; даже если драйвер сигнализировал, что он занят.</target>
        </trans-unit>
        <trans-unit id="24fb3b31f2e1a1b36aa86e0260daf033dbd388cc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;snmp_config#manager_irb&quot;&gt;inform request behaviour&lt;/a&gt;&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436abcfe6ccf26003670b7e8f6ead1ae9566d2af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b8a260b0935e82c1c23c647ce2490c52e709f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_control/3&lt;/code&gt; is a binary, the driver will be passed a pointer to the contents of the binary and the binary will not be copied. If the &lt;code&gt;Data&lt;/code&gt; argument is an iolist (list of binaries and lists), all binaries in the iolist will be copied.</source>
          <target state="translated">Если аргумент &lt;code&gt;Data&lt;/code&gt; для &lt;code&gt;port_control/3&lt;/code&gt; является двоичным, драйверу будет передан указатель на содержимое двоичного файла, и двоичный файл не будет скопирован. Если аргумент &lt;code&gt;Data&lt;/code&gt; - это список бинарных файлов (список двоичных файлов и списков), все двоичные файлы в списке будут скопированы.</target>
        </trans-unit>
        <trans-unit id="22cf2f621c573393bcc21b524ec1f8b2f0eb496f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;EI_SCLBK_FLG_FULL_IMPL&lt;/code&gt; flag has been set, &lt;code&gt;tmo&lt;/code&gt; contains timeout time in milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f73654015166f98aadbf7b3b123e17e68232e9b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;HEART_COMMAND&lt;/code&gt; environment variable is to be set in the &lt;code&gt;start&lt;/code&gt; script in &lt;strong&gt;Starting Erlang&lt;/strong&gt;, and if the value is to be set to the path of the Solaris &lt;code&gt;reboot&lt;/code&gt; command, that is:</source>
          <target state="translated">Если &lt;code&gt;HEART_COMMAND&lt;/code&gt; среды HEART_COMMAND должна быть установлена ​​в &lt;code&gt;start&lt;/code&gt; скрипте в &lt;strong&gt;Запуск Erlang&lt;/strong&gt; , и если значение должно быть установлено на путь к команде &lt;code&gt;reboot&lt;/code&gt; Solaris , то есть:</target>
        </trans-unit>
        <trans-unit id="944e73a76d9846f1844b61fadd1ef6be5fa46f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Item&lt;/code&gt; is a string &quot;&amp;lt;X.Y.Z&amp;gt;&quot; as returned from &lt;code&gt;pid_to_list/1&lt;/code&gt;, the process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">Если &lt;code&gt;Item&lt;/code&gt; является строкой &amp;laquo;&amp;lt;XYZ&amp;gt;&amp;raquo;, возвращенной из &lt;code&gt;pid_to_list/1&lt;/code&gt; , отслеживается процесс &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61eca5d5aa872cbcbe9a56199f7268cf843102ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Mod&lt;/code&gt; argument is given, the result contains a &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for module &lt;code&gt;Mod&lt;/code&gt; only, otherwise the result contains one &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for all modules returned from &lt;code&gt;code:all_loaded()&lt;/code&gt; except &lt;code&gt;cprof&lt;/code&gt; itself.</source>
          <target state="translated">Если указан аргумент &lt;code&gt;Mod&lt;/code&gt; , результат содержит кортеж &lt;code&gt;ModAnalysis&lt;/code&gt; только для модуля &lt;code&gt;Mod&lt;/code&gt; , в противном случае результат содержит один кортеж &lt;code&gt;ModAnalysis&lt;/code&gt; для всех модулей, возвращаемых из &lt;code&gt;code:all_loaded()&lt;/code&gt; кроме самого &lt;code&gt;cprof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="692d7ddeb29364bd451d87d06edbd7eec80bea02" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has been set, a &lt;code&gt;NewAtomCacheRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">Если &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; для следующего &lt;code&gt;AtomCacheRef&lt;/code&gt; был установлен, &lt;code&gt;NewAtomCacheRef&lt;/code&gt; в следующем формате следует:</target>
        </trans-unit>
        <trans-unit id="04c0254fa6d70d431ad5a486ddf123ee44618a15" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has not been set, a &lt;code&gt;CachedAtomRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">Если &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; для следующего &lt;code&gt;AtomCacheRef&lt;/code&gt; не был установлен, &lt;code&gt;CachedAtomRef&lt;/code&gt; в следующем формате следует:</target>
        </trans-unit>
        <trans-unit id="8c90300fd144cf66a22b387cf8df2ba0e1883646" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ssh2_pubkey&lt;/code&gt;, the &lt;code&gt;InData&lt;/code&gt; shall be &lt;code&gt;InData_ssh2_pubkey&lt;/code&gt;. Otherwise it shall be &lt;code&gt;OtherInData&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5892c57f59a62e642afcb7987d330a6a6bddcb6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ssh2_pubkey&lt;/code&gt;, the result will be &lt;code&gt;Decoded_ssh2_pubkey&lt;/code&gt;. Otherwise it will be &lt;code&gt;Decoded_OtherType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abbbca51e0d96970bfc6e932a6073fa6c1b8d91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WrapSize&lt;/code&gt; is specified as &lt;code&gt;{time, WrapTime}&lt;/code&gt;, the current file is closed when it has been open more than &lt;code&gt;WrapTime&lt;/code&gt; milliseconds, regardless of it being empty or not.</source>
          <target state="translated">Если &lt;code&gt;WrapSize&lt;/code&gt; указан как &lt;code&gt;{time, WrapTime}&lt;/code&gt; , текущий файл закрывается, если он был открыт более &lt;code&gt;WrapTime&lt;/code&gt; миллисекунд, независимо от того, пуст он или нет.</target>
        </trans-unit>
        <trans-unit id="3bce9200cd49c0302061751c509bff17706e1d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;collector_pid&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; a new &lt;code&gt;et_collector&lt;/code&gt; will be started with the following parameter settings: &lt;code&gt;parent_pid&lt;/code&gt;, &lt;code&gt;event_order&lt;/code&gt;, &lt;code&gt;trace_global&lt;/code&gt;, &lt;code&gt;trace_pattern&lt;/code&gt;, &lt;code&gt;trace_port&lt;/code&gt;, &lt;code&gt;trace_max_queue&lt;/code&gt;, &lt;code&gt;trace_client&lt;/code&gt;, &lt;code&gt;dict_insert&lt;/code&gt; and &lt;code&gt;dict_delete&lt;/code&gt;. The new &lt;code&gt;et_viewer&lt;/code&gt; will register itself as an &lt;code&gt;et_collector&lt;/code&gt; subscriber.</source>
          <target state="translated">Если &lt;code&gt;collector_pid&lt;/code&gt; не &lt;code&gt;undefined&lt;/code&gt; новый &lt;code&gt;et_collector&lt;/code&gt; будет запущен со следующими настройками параметров: &lt;code&gt;parent_pid&lt;/code&gt; , &lt;code&gt;event_order&lt;/code&gt; , &lt;code&gt;trace_global&lt;/code&gt; , &lt;code&gt;trace_pattern&lt;/code&gt; , &lt;code&gt;trace_port&lt;/code&gt; , &lt;code&gt;trace_max_queue&lt;/code&gt; , &lt;code&gt;trace_client&lt;/code&gt; , &lt;code&gt;dict_insert&lt;/code&gt; и &lt;code&gt;dict_delete&lt;/code&gt; . Новый &lt;code&gt;et_viewer&lt;/code&gt; зарегистрируется как подписчик &lt;code&gt;et_collector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef49ec23c42d8c8e08d0e1a55605acb0e8d5ac7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;crypto_fun()&lt;/code&gt; reurns a &lt;code&gt;chunk_size()&lt;/code&gt;, that value is as block size for further blocks in calls to &lt;code&gt;crypto_fun()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1705267e03ee01724d59b40bc5f0214567319c46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; and/or &lt;code&gt;per_cpu&lt;/code&gt; option is given, this is the CPU number, or a list of the CPU numbers.</source>
          <target state="translated">Если &lt;code&gt;detailed&lt;/code&gt; и / или &lt;code&gt;per_cpu&lt;/code&gt; опция задана, то это число CPU, или список номеров процессоров.</target>
        </trans-unit>
        <trans-unit id="e77d603a3001a1e9c1762cdeaacfe7bfa22a3f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; option is given, this is a list of &lt;code&gt;{State, Share}&lt;/code&gt; tuples, where each tuple contains information about a processor state that has been identified as a busy processor state (see below). The atom &lt;code&gt;State&lt;/code&gt; is the name of the state, and the float &lt;code&gt;Share&lt;/code&gt; represents the percentage share of the CPU cycles spent in this state since the last call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt;.</source>
          <target state="translated">Если указан &lt;code&gt;detailed&lt;/code&gt; вариант, это список кортежей &lt;code&gt;{State, Share}&lt;/code&gt; , где каждый кортеж содержит информацию о состоянии процессора, которое было идентифицировано как состояние занятости процессора (см. Ниже). Атом &lt;code&gt;State&lt;/code&gt; является имя государства, а поплавок &lt;code&gt;Share&lt;/code&gt; представляет собой процентную долю циклов процессора , потраченных в этом состоянии с момента последнего вызова &lt;code&gt;util/0&lt;/code&gt; или &lt;code&gt;util/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceeca0dd799d0c2b30a43e745da4464b5bf6bdd0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e75076deae26fb176f6e6643de28792f0d16c28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62b99585baeb954cbb0731a4ba30894bb10a1da" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a3a64fa23b1c369a1e49078a7eef230d3e65da" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a too large wait time value, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f6b148b35fa3a772ed4cf02b8f14d1a3fb663b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;excl_lib&lt;/code&gt; option is set to &lt;code&gt;otp_root&lt;/code&gt; then reltool will not copy anything from the Erlang/OTP installation ($OTP_ROOT) into the target structure. The goal is to create a &quot;slim&quot; release which can be used together with an existing Erlang/OTP installation. The target structure will therefore only contain a &lt;code&gt;lib&lt;/code&gt; directory with the applications that were found outside of $OTP_ROOT (typically your own applications), and a &lt;code&gt;releases&lt;/code&gt; directory with the generated &lt;code&gt;.rel,&lt;/code&gt;&lt;code&gt;.script&lt;/code&gt; and &lt;code&gt;.boot&lt;/code&gt; files.</source>
          <target state="translated">Если для параметра &lt;code&gt;excl_lib&lt;/code&gt; задано значение &lt;code&gt;otp_root&lt;/code&gt; , то reltool не будет копировать ничего из установки Erlang / OTP ($ OTP_ROOT) в целевую структуру. Цель состоит в том, чтобы создать &amp;laquo;тонкий&amp;raquo; выпуск, который можно было бы использовать вместе с существующей установкой Erlang / OTP. Таким образом, целевая структура будет содержать только каталог &lt;code&gt;lib&lt;/code&gt; с приложениями, которые были обнаружены вне $ OTP_ROOT (обычно ваши собственные приложения), и каталог &lt;code&gt;releases&lt;/code&gt; со сгенерированными &lt;code&gt;.rel,&lt;/code&gt; &lt;code&gt;.script&lt;/code&gt; и &lt;code&gt;.boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be47c608e84207db441f123dc3b022c3bdfe3832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fprof&lt;/code&gt; server is not running, this function returns immediately with the same return value.</source>
          <target state="translated">Если сервер &lt;code&gt;fprof&lt;/code&gt; не запущен, эта функция немедленно возвращается с тем же возвращаемым значением.</target>
        </trans-unit>
        <trans-unit id="4cfc64c80cf0754288971ed2f55082185d9efbaf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_event&lt;/code&gt; is to be able to receive other messages than events, the callback function &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_event&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">Если &lt;code&gt;gen_event&lt;/code&gt; должен иметь возможность получать сообщения, отличные от событий, функция обратного вызова &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; должна быть реализована для их обработки. Примерами других сообщений являются сообщения о выходе, если &lt;code&gt;gen_event&lt;/code&gt; связан с другими процессами (кроме супервизора) и перехватывает сигналы выхода.</target>
        </trans-unit>
        <trans-unit id="5aad944a4a47c5bc78a9273e949274df0e9ed557" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is not part of a supervision tree, a stop function can be useful, for example:</source>
          <target state="translated">Если &lt;code&gt;gen_server&lt;/code&gt; не является частью дерева надзора, может быть полезна функция остановки, например:</target>
        </trans-unit>
        <trans-unit id="4832a13c9684cb02c06fa828f9150cd6ab481d33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_server&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">Если &lt;code&gt;gen_server&lt;/code&gt; является частью дерева надзора, функция остановки не требуется. &lt;code&gt;gen_server&lt;/code&gt; автоматически прекращается его руководителем. Как именно это делается, определяется &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; установленной в супервизоре.</target>
        </trans-unit>
        <trans-unit id="3b4cc7e563bc4ab43d392728008910f94dfb10ae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is to be able to receive other messages than requests, the callback function &lt;code&gt;handle_info(Info, State)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_server&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">Если &lt;code&gt;gen_server&lt;/code&gt; должен иметь возможность получать сообщения, отличные от запросов, для их обработки должна быть реализована функция обратного вызова &lt;code&gt;handle_info(Info, State)&lt;/code&gt; . Примерами других сообщений являются сообщения о выходе, если &lt;code&gt;gen_server&lt;/code&gt; связан с другими процессами (кроме супервизора) и перехватывает сигналы выхода.</target>
        </trans-unit>
        <trans-unit id="2f9738619fd7812022c1fdbad1b01a2e041bfacc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason=shutdown&lt;/code&gt; if the following conditions apply:</source>
          <target state="translated">Если процесс &lt;code&gt;gen_server&lt;/code&gt; является частью дерева надзора и его супервизор приказал завершить работу, эта функция вызывается с &lt;code&gt;Reason=shutdown&lt;/code&gt; , если выполняются следующие условия:</target>
        </trans-unit>
        <trans-unit id="deb0cd9df07520473713789c264957ed22e0fd37" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is successfully created and initialized, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the &lt;code&gt;gen_server&lt;/code&gt; process. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">Если процесс &lt;code&gt;gen_server&lt;/code&gt; успешно создан и инициализирован, функция возвращает &lt;code&gt;{ok,Pid}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это pid процесса &lt;code&gt;gen_server&lt;/code&gt; . Если процесс с указанным &lt;code&gt;ServerName&lt;/code&gt; уже существует, функция возвращает &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это pid этого процесса.</target>
        </trans-unit>
        <trans-unit id="7b56e5a9d7d5389ddf0dc35b8aa333d9d01bbefc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process needs to perform an action immediately after initialization or to break the execution of a callback into multiple steps, it can return &lt;code&gt;{continue,Continue}&lt;/code&gt; in place of the time-out or hibernation value, which will immediately invoke the &lt;code&gt;handle_continue/2&lt;/code&gt; callback.</source>
          <target state="translated">Если процессу &lt;code&gt;gen_server&lt;/code&gt; необходимо выполнить действие сразу после инициализации или разбить выполнение обратного вызова на несколько шагов, он может вернуть &lt;code&gt;{continue,Continue}&lt;/code&gt; вместо значения тайм-аута или режима гибернации, что немедленно вызовет &lt;code&gt;handle_continue/2&lt;/code&gt; обратный звонок.</target>
        </trans-unit>
        <trans-unit id="490e75ed674d410c271a45a56872f3c49ab0b58b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is not part of a supervision tree, it can be stopped using &lt;code&gt;gen_statem:stop&lt;/code&gt;, preferably through an API function:</source>
          <target state="translated">Если &lt;code&gt;gen_statem&lt;/code&gt; не является частью дерева надзора, его можно остановить с помощью &lt;code&gt;gen_statem:stop&lt;/code&gt; , предпочтительно с помощью функции API:</target>
        </trans-unit>
        <trans-unit id="36f4edf0379e907c933af357c419f98ac2861c66" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason = shutdown&lt;/code&gt; if both the following conditions apply:</source>
          <target state="translated">Если &lt;code&gt;gen_statem&lt;/code&gt; является частью дерева надзора и его супервизор приказал завершить работу, эта функция вызывается с &lt;code&gt;Reason = shutdown&lt;/code&gt; если выполняются оба следующих условия:</target>
        </trans-unit>
        <trans-unit id="ac199e9236c5ed4f285d3986ed2287bb9a4c55ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_statem&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">Если &lt;code&gt;gen_statem&lt;/code&gt; является частью дерева надзора, функция остановки не требуется. &lt;code&gt;gen_statem&lt;/code&gt; автоматически прекращается его руководителем. Как именно это делается, определяется &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; установленной в супервизоре.</target>
        </trans-unit>
        <trans-unit id="622dc023e6ca738739a4198b61e3fabf701c009b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is successfully created and initialized, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of the &lt;code&gt;gen_statem&lt;/code&gt;. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of that process.</source>
          <target state="translated">Если &lt;code&gt;gen_statem&lt;/code&gt; успешно создан и инициализирован, эта функция возвращает &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; является &lt;code&gt;pid()&lt;/code&gt; из &lt;code&gt;gen_statem&lt;/code&gt; . Если процесс с указанным &lt;code&gt;ServerName&lt;/code&gt; уже существует, эта функция возвращает &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это &lt;code&gt;pid()&lt;/code&gt; этого процесса.</target>
        </trans-unit>
        <trans-unit id="6640f29cc42fa72e56c964d772278b2e50af15d6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the &lt;strong&gt;state enter call&lt;/strong&gt; is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, other than that &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d4b7b9947ceb2e1f75b847cb2c2cefc610ce87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inform request behaviour&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="translated">Если для параметра конфигурации &lt;code&gt;inform request behaviour&lt;/code&gt; установлено значение &lt;code&gt;user&lt;/code&gt; или &lt;code&gt;{user, integer()}&lt;/code&gt; , ответ (подтверждение) на этот информационный запрос будет отправлен, когда эта функция вернется.</target>
        </trans-unit>
        <trans-unit id="f12a4aa7db27654fb06f0356ee419770a3c5990d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;main/1&lt;/code&gt; function in the script returns successfully, the exit status for the script is &lt;code&gt;0&lt;/code&gt;. If an exception is generated during execution, a short message is printed and the script terminates with exit status &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">Если функция &lt;code&gt;main/1&lt;/code&gt; в сценарии завершается успешно, статус выхода для сценария равен &lt;code&gt;0&lt;/code&gt; . Если во время выполнения генерируется исключение, печатается короткое сообщение, и сценарий завершается со статусом выхода &lt;code&gt;127&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6df86c1718762f44b04c0cb308484d1d6c310a34" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;max_sessions&lt;/code&gt; option is set to &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;parallel_login&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the maximum number of simultaneous login attempts at any time is limited to &lt;code&gt;N-K&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; is the number of authenticated connections present at this daemon.</source>
          <target state="translated">Если для параметра &lt;code&gt;max_sessions&lt;/code&gt; установлено значение &lt;code&gt;N&lt;/code&gt; , а для параметра &lt;code&gt;parallel_login&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , максимальное количество одновременных попыток входа в систему в любое время ограничено &lt;code&gt;N-K&lt;/code&gt; , где &lt;code&gt;K&lt;/code&gt; - количество аутентифицированных подключений, присутствующих в этом демоне.</target>
        </trans-unit>
        <trans-unit id="279c740df4997832935268858ff97ba56a5fb972" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;parse_transform&lt;/code&gt; is not applied to a module that calls this pseudo function, the call fails in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The &lt;code&gt;ets&lt;/code&gt; module exports a function with this name, but it is never to be called except when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including header file &lt;code&gt;ms_transform.hrl&lt;/code&gt;, compiled code never calls the function, but the function call is replaced by a literal match specification.</source>
          <target state="translated">Если &lt;code&gt;parse_transform&lt;/code&gt; не применяется к модулю, который вызывает эту &lt;code&gt;badarg&lt;/code&gt; , вызов завершается ошибкой во время выполнения (с ошибкой ). Модуль &lt;code&gt;ets&lt;/code&gt; экспортирует функцию с этим именем, но ее нельзя вызывать, кроме случаев использования функции в оболочке. Если &lt;code&gt;parse_transform&lt;/code&gt; правильно применяется путем включения файла заголовка &lt;code&gt;ms_transform.hrl&lt;/code&gt; , скомпилированный код никогда не вызывает функцию, но вызов функции заменяется спецификацией буквального соответствия.</target>
        </trans-unit>
        <trans-unit id="91c8b62af5511bc181fbe7c0815f7318805644f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;per_cpu&lt;/code&gt; is not given, the value(s) presented are the average of all CPUs.</source>
          <target state="translated">Если &lt;code&gt;per_cpu&lt;/code&gt; не указан, представленные значения являются средними для всех процессоров.</target>
        </trans-unit>
        <trans-unit id="2c4b5f09b562c0e8df5ab61a0939a3cca6eab6e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;qlc&lt;/code&gt; module at compile time can determine that some constant is free of integers, it does not matter which one of &lt;code&gt;==/2&lt;/code&gt; or &lt;code&gt;=:=/2&lt;/code&gt; is used:</source>
          <target state="translated">Если модуль &lt;code&gt;qlc&lt;/code&gt; во время компиляции может определить, что некоторая константа не содержит целых чисел, не имеет значения, какой из &lt;code&gt;==/2&lt;/code&gt; или &lt;code&gt;=:=/2&lt;/code&gt; используется:</target>
        </trans-unit>
        <trans-unit id="9ebaa062ac28936382e2d57abb7b4e12d177d78c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It is only to contain low-level instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d6310f85895e6842a34eabfe92151229e6b95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It it only to contain low-level instructions.</source>
          <target state="translated">Если файл &lt;code&gt;relup&lt;/code&gt; относительно простой, его можно создать вручную. Это только для того, чтобы содержать низкоуровневые инструкции.</target>
        </trans-unit>
        <trans-unit id="c30c579f26aae9f62a722f68b38557366dc19832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если в &lt;code&gt;restart_new_emulator&lt;/code&gt; инструкция restart_new_emulator , &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; . Это потому, что &lt;code&gt;restart_new_emulator&lt;/code&gt; требует, чтобы новая версия эмулятора была запущена перед выполнением остальных инструкций по обновлению, и это можно сделать только с помощью &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3734548d24c8fafceb3c3b7a48423c44c0a982c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если в &lt;code&gt;restart_new_emulator&lt;/code&gt; обнаружена инструкция restart_new_emulator , &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; . Это потому, что &lt;code&gt;restart_new_emulator&lt;/code&gt; требует, чтобы новая версия эмулятора была запущена перед выполнением остальных инструкций по обновлению, и это можно сделать только с помощью &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52741bb5942e459f72dab152ca12b8b26eff70c9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/3,4&lt;/code&gt; function is used, all management targets are selected, as defined in RFC2273. The &lt;code&gt;Receiver&lt;/code&gt; parameter defines where the agent should send information about the delivery of inform requests.</source>
          <target state="translated">Если используется &lt;code&gt;send_notification/3,4&lt;/code&gt; , выбираются все цели управления, как определено в RFC2273. Параметр &lt;code&gt;Receiver&lt;/code&gt; определяет, куда агент должен отправлять информацию о доставке информационных запросов.</target>
        </trans-unit>
        <trans-unit id="4e603d462637bea7ebad3ed1b02ae3e6befcd5e2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/5&lt;/code&gt; function is used, an &lt;code&gt;NotifyName&lt;/code&gt; must be provided. This parameter is used as an index in the &lt;code&gt;snmpNotifyTable&lt;/code&gt;, and the management targets defined by that single entry is used.</source>
          <target state="translated">Если используется &lt;code&gt;send_notification/5&lt;/code&gt; , необходимо &lt;code&gt;NotifyName&lt;/code&gt; . Этот параметр используется как индекс в &lt;code&gt;snmpNotifyTable&lt;/code&gt; , и используются цели управления, определенные этой единственной записью.</target>
        </trans-unit>
        <trans-unit id="dde37de921a26a59041af8e4c9013eabdc7311af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system_logger&lt;/code&gt; process dies, this flag will be reset to &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bd2cdf7f65d1258410067e1dbfa02e06ec92b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt;, enable it.</source>
          <target state="translated">Если &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; не включен в &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt; , включите его.</target>
        </trans-unit>
        <trans-unit id="d160ec14cdba130b3a52eed8160428fd608a596b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;c:/opt/local64/pgm/wxWidgets-3.1.3/include/wx/msw/setup.h&lt;/code&gt;, enable it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99871da2f295c0790df21d324a78c1b82d11e8b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;{extra_files, ExtraFiles}&lt;/code&gt; option is given then the &lt;code&gt;ExtraFiles&lt;/code&gt; are added to the tarball after everything else to be included has been added. The &lt;code&gt;ExtraFiles&lt;/code&gt; list is a list of files or directories in the same format as the &lt;code&gt;add_type()&lt;/code&gt; tuple for &lt;code&gt;erl_tar:add/3,4&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275e62491f49fb1a70d7127de6210ff8d9a19127" translate="yes" xml:space="preserve">
          <source>If the ASN.1 module has been compiled with option &lt;code&gt;maps&lt;/code&gt;, the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; are represented as maps.</source>
          <target state="translated">Если модуль ASN.1 был скомпилирован с &lt;code&gt;maps&lt;/code&gt; опций , типы &lt;code&gt;SEQUENCE&lt;/code&gt; и &lt;code&gt;SET&lt;/code&gt; представлены как карты.</target>
        </trans-unit>
        <trans-unit id="722c5c772253cfa0375f5705288b0321c521aa8d" translate="yes" xml:space="preserve">
          <source>If the AckStatus is ok, it is indicating that this is a true acknowledgement of the transaction reply.</source>
          <target state="translated">Если AckStatus в порядке,это означает,что это истинное подтверждение ответа на транзакцию.</target>
        </trans-unit>
        <trans-unit id="d0f84b01e010783659e66100fe954814d18e563f" translate="yes" xml:space="preserve">
          <source>If the AckStatus is {error, Reason}, it is an indication that the acknowledgement or even the reply (for which this is an acknowledgement) was not delivered, but there is no point in waiting any longer for it to arrive. This happens when:</source>
          <target state="translated">Если AckStatus имеет значение {error,Reason},это означает,что подтверждение или даже ответ (для которого это подтверждение)не были доставлены,но нет смысла больше ждать его прибытия.Это происходит,когда:</target>
        </trans-unit>
        <trans-unit id="88faac2c33abe1fdc3fc1b10f5136c262bb64e7a" translate="yes" xml:space="preserve">
          <source>If the BEAM file contains &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">Если файл BEAM содержит &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; , возвращается список кортежей. Первый элемент каждого кортежа является одним из:</target>
        </trans-unit>
        <trans-unit id="52ebbcd03e14972b092b8f0cc1bbe4c3dd868b59" translate="yes" xml:space="preserve">
          <source>If the BEAM file does not contain debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">Если файл BEAM не содержит отладочной информации,то возвращается список кортежей.Первый элемент каждого кортежа-один из них:</target>
        </trans-unit>
        <trans-unit id="5e318cbbe5a1c0ec48c8b2b2021ac1f10131570e" translate="yes" xml:space="preserve">
          <source>If the C node acts as a server, it must first create a socket (call &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt;) listening to a certain port number &lt;code&gt;port&lt;/code&gt;. It then publishes its name and port number with &lt;code&gt;epmd&lt;/code&gt;, the Erlang port mapper daemon. For details, see the &lt;code&gt;epmd&lt;/code&gt; manual page in ERTS:</source>
          <target state="translated">Если узел C действует как сервер, он должен сначала создать сокет (вызовы &lt;code&gt;bind()&lt;/code&gt; и &lt;code&gt;listen()&lt;/code&gt; ), прослушивающий порт с определенным номером &lt;code&gt;port&lt;/code&gt; . Затем он публикует свое имя и номер порта с помощью &lt;code&gt;epmd&lt;/code&gt; , демона сопоставления портов на Erlang. Дополнительные сведения см. На &lt;code&gt;epmd&lt;/code&gt; руководства epmd в ERTS:</target>
        </trans-unit>
        <trans-unit id="82d38ec527a550307461604062c03b211a833f6c" translate="yes" xml:space="preserve">
          <source>If the COND1 pattern matches, FOO is tried (and possibly further items after the end of the group if FOO succeeds). On failure, the matcher skips to the second alternative and tries COND2, without backtracking into COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails, there are no more alternatives, so there is a backtrack to whatever came before the entire group. If (*THEN) is not inside an alternation, it acts like (*PRUNE).</source>
          <target state="translated">Если шаблон COND1 совпадает,FOO пробуются (и,возможно,дополнительные элементы после окончания группы,если FOO удается).При неудаче матч переходит ко второму варианту и пытается COND2,без обратного перехода к COND1.Если это удается,и BAR не удается,то происходит попытка COND3.Если BAZ проваливается,больше нет никаких альтернатив,так что есть обратная дорога к тому,что пришло до конца группы.Если (*THEN)не находится внутри очереди,он действует как (*PRUNE).</target>
        </trans-unit>
        <trans-unit id="ac5eaef6ff1820888de0ffa5ad9b4186d0234433" translate="yes" xml:space="preserve">
          <source>If the CPU information has changed since the last time it was read, the atom &lt;code&gt;changed&lt;/code&gt; is returned, otherwise the atom &lt;code&gt;unchanged&lt;/code&gt;. If the CPU information has changed, you probably want to &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt;. You typically want to have as many schedulers online as &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если информация ЦП изменилась с момента последнего чтения, возвращается &lt;code&gt;changed&lt;/code&gt; атом , в противном случае атом не &lt;code&gt;unchanged&lt;/code&gt; . Если информация о процессоре изменилась, вы, вероятно, захотите &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt; . Обычно вы хотите иметь в сети столько планировщиков, сколько доступно &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a41da23020d6b98e8307d0411d62373331fcee35" translate="yes" xml:space="preserve">
          <source>If the CertificateRequest message contained a non-empty &quot;oid_filters&quot; extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674a0c6bf29cc8c8f0b253946e997318f6046675" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the group database is maintained by Dets and must not be edited by hand. Use the API for module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the group database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that the &lt;code&gt;auth_group_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">Если используется метод хранения Dets, база данных группы поддерживается Dets и не должна редактироваться вручную. Используйте API для модуля &lt;code&gt;mod_auth&lt;/code&gt; для создания / редактирования базы данных группы. Эта директива игнорируется, если используется метод хранения Mnesia. По соображениям безопасности убедитесь, что &lt;code&gt;auth_group_file&lt;/code&gt; хранится вне дерева документов веб-сервера. Если он помещен в каталог, который он защищает, клиенты могут его загрузить.</target>
        </trans-unit>
        <trans-unit id="2690e1607b444fbdfb4354a7fc5e69fab4fc5a65" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the user database is maintained by Dets and must not be edited by hand. Use the API functions in module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the user database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that &lt;code&gt;auth_user_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">Если используется метод хранения Dets, база данных пользователей поддерживается Dets и не должна редактироваться вручную. Используйте функции API в модуле &lt;code&gt;mod_auth&lt;/code&gt; для создания / редактирования базы данных пользователей. Эта директива игнорируется, если используется метод хранения Mnesia. По соображениям безопасности убедитесь, что &lt;code&gt;auth_user_file&lt;/code&gt; хранится вне дерева документов веб-сервера. Если он помещен в каталог, который он защищает, клиенты могут его загрузить.</target>
        </trans-unit>
        <trans-unit id="5d6f0952016312ac237e99b15d9161adf55f700d" translate="yes" xml:space="preserve">
          <source>If the Erlang node was alive, that is, set up for communicating with other nodes, this section lists the connections that were active. The following fields can exist:</source>
          <target state="translated">Если узел Erlang был жив,то есть настроен на взаимодействие с другими узлами,в этом разделе перечислены соединения,которые были активны.Могут существовать следующие поля:</target>
        </trans-unit>
        <trans-unit id="18daf2db870215dd47d6849bc420623f1e0d4030" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only OS process binding threads to logical processors, this improves the performance of the runtime system. However, if other OS processes (for example, another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. Sometimes this performance penalty can be severe. If so, it is recommended to not bind the schedulers.</source>
          <target state="translated">Если исполнительная система Erlang является единственной ОС,связывающей потоки процессов с логическими процессорами,это улучшает производительность исполнительных систем.Однако,если другие процессы ОС (например,другая исполнительная система Erlang)также связывают потоки с логическими процессорами,то вместо этого может быть снижена производительность.Иногда такой штраф может быть очень серьезным.Если это так,то рекомендуется не связывать планировщики.</target>
        </trans-unit>
        <trans-unit id="3549c6b8d3c0426e098c164e7bd7160b6e4be362" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only operating system process that binds threads to logical processors, this improves the performance of the runtime system. However, if other operating system processes (for example another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. This performance penalty can sometimes be severe. If so, you are advised not to bind the schedulers.</source>
          <target state="translated">Если исполнительная система Erlang-единственный процесс операционной системы,который связывает потоки с логическими процессорами,то это повышает производительность исполнительных систем.Однако если другие процессы операционной системы (например,другая исполнительная система Erlang)также связывают потоки с логическими процессорами,то вместо этого может быть снижена производительность.Этот штраф за производительность иногда может быть суровым.Если это так,то не рекомендуется связывать планировщики.</target>
        </trans-unit>
        <trans-unit id="78b8e3a5a6a0636736a794de9e5a1415d4c36fbf" translate="yes" xml:space="preserve">
          <source>If the Erlang shell buffer would be killed the command line history is saved to a file. The command line history is automatically retrieved when a new Erlang shell is started.</source>
          <target state="translated">Если буфер оболочки Erlang был бы убит,то история командной строки сохраняется в файл.История командной строки автоматически извлекается при запуске новой оболочки Erlang.</target>
        </trans-unit>
        <trans-unit id="5ad331d93d63bf83b44ef888cb4e43e94ea364bb" translate="yes" xml:space="preserve">
          <source>If the INDEX column is of type INTEGER, or derived from INTEGER, the corresponding type should be &lt;code&gt;integer&lt;/code&gt;. If it is a variable length type (e.g. OBJECT IDENTIFIER, OCTET STRING), the corresponding type should be &lt;code&gt;string&lt;/code&gt;. Finally, if the type is of variable length, but with a fixed size restriction (e.g. IpAddress), the corresponding type should be &lt;code&gt;fix_string&lt;/code&gt;.</source>
          <target state="translated">Если столбец INDEX имеет тип INTEGER или является производным от INTEGER, соответствующий тип должен быть &lt;code&gt;integer&lt;/code&gt; . Если это тип переменной длины (например, ИДЕНТИФИКАТОР ОБЪЕКТА, СТРОКА ОКТЕТОВ), соответствующий тип должен быть &lt;code&gt;string&lt;/code&gt; . Наконец, если тип переменной длины, но с ограничением фиксированного размера (например, IpAddress), соответствующий тип должен быть &lt;code&gt;fix_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27815f723f23d4e4cf3d912f3476eb64c838477e" translate="yes" xml:space="preserve">
          <source>If the MG cannot be provisioned with the MID of the MGC, the MG can use the atom 'preliminary_mid' as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">Если MG не может быть обеспечен MID MGC,то MG может использовать атом 'preliminary_mid' в качестве параметра RemoteMid to megaco:connect/4 и поток вызовов будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="291d17d4be116cb44759c41864d170474773407f" translate="yes" xml:space="preserve">
          <source>If the MG has been provisioned with the MID of the MGC it can be given as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">Если MG был обеспечен MID MGC,то он может быть задан как параметр RemoteMid для megaco:connect/4 и поток вызовов будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="3d3ec8b1bad21c29a9fcf6552b6d84ffcf7600b8" translate="yes" xml:space="preserve">
          <source>If the Mnesia database is used, this function calls &lt;code&gt;mnesia:write&lt;/code&gt; to store the values. This means that this function must be called from within a transaction (&lt;code&gt;mnesia:transaction/1&lt;/code&gt; or &lt;code&gt;mnesia:dirty/1&lt;/code&gt;).</source>
          <target state="translated">Если используется база данных Mnesia, эта функция вызывает &lt;code&gt;mnesia:write&lt;/code&gt; для сохранения значений. Это означает, что эта функция должна вызываться из транзакции ( &lt;code&gt;mnesia:transaction/1&lt;/code&gt; или &lt;code&gt;mnesia:dirty/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="40a56f15bd541bd82f926eed2c112eaac90f9e71" translate="yes" xml:space="preserve">
          <source>If the NIF call is too lengthy, this must be handled in one of the following ways to avoid degraded responsiveness, scheduler load balancing problems, and other strange behaviors:</source>
          <target state="translated">Если вызов NIF слишком длительный,это должно быть обработано одним из следующих способов,чтобы избежать ухудшения ответной реакции,проблем с балансировкой нагрузки планировщика и других странных действий:</target>
        </trans-unit>
        <trans-unit id="436a83604c57a3e3475d1d2d6359ca37e137b110" translate="yes" xml:space="preserve">
          <source>If the OBJECT IDENTIFIER is longer than an OBJECT IDENTIFIER of an object type in the MIB, it refers to object instances. Because of this, it is possible to control whether or not particular rows in a table shall be visible.</source>
          <target state="translated">Если ОБЪЕКТНЫЙ ИДЕНТИФАЙЕР длиннее,чем ОБЪЕКТНЫЙ ИДЕНТИФАЙЕР типа объекта в MIB,он относится к экземплярам объектов.Благодаря этому можно контролировать,должны ли быть видны отдельные строки в таблице.</target>
        </trans-unit>
        <trans-unit id="b1b26d2a72fe7f32dcd9c24e2f00608157279f71" translate="yes" xml:space="preserve">
          <source>If the OS used does not support non-blocking &lt;code&gt;sendfile&lt;/code&gt;, an Erlang fallback using &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Если операционная система используется не поддерживает неблокирующую &lt;code&gt;sendfile&lt;/code&gt; , Erlang Откат с помощью &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="b3598222fc1bb53b9989c1f5e6bfd02eed50487d" translate="yes" xml:space="preserve">
          <source>If the SNMP agent needs to interact with sub-agents constructed in another package, a special sub-agent should be used, which communicates through a protocol specified by the other package.</source>
          <target state="translated">Если агенту SNMP необходимо взаимодействовать с субагентами,построенными в другом пакете,следует использовать специальный субагент,который взаимодействует по протоколу,заданному другим пакетом.</target>
        </trans-unit>
        <trans-unit id="1c500f599c51107a79c77a136f03f46d05fafc58" translate="yes" xml:space="preserve">
          <source>If the SNMP table has more than one INDEX column, the corresponding Mnesia row is a tuple, where the first element is a tuple with the INDEX columns. Generally, if the SNMP table has &lt;strong&gt;N&lt;/strong&gt; INDEX columns and &lt;strong&gt;C&lt;/strong&gt; data columns, the Mnesia table is of arity &lt;strong&gt;(C-N)+1&lt;/strong&gt;, where the key is a tuple of arity &lt;strong&gt;N&lt;/strong&gt; if &lt;strong&gt;N &amp;gt; 1&lt;/strong&gt;, or a single term if &lt;strong&gt;N = 1&lt;/strong&gt;.</source>
          <target state="translated">Если в таблице SNMP имеется более одного столбца INDEX, соответствующая строка Mnesia является кортежем, где первый элемент является кортежем со столбцами INDEX. Обычно, если таблица SNMP имеет &lt;strong&gt;N&lt;/strong&gt; столбцов INDEX и столбцов данных &lt;strong&gt;C&lt;/strong&gt; , таблица Mnesia имеет арность &lt;strong&gt;(CN) +1&lt;/strong&gt; , где ключ является кортежем с арностью &lt;strong&gt;N,&lt;/strong&gt; если &lt;strong&gt;N&amp;gt; 1&lt;/strong&gt; , или одним членом, если &lt;strong&gt;N = 1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3c217a2396ebcee146469f461600abdf337e010c" translate="yes" xml:space="preserve">
          <source>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it ignores the new request if the request is equal to the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server consumes less resources.</source>
          <target state="translated">Если TFTP-сервер получает еще один запрос от того же клиента (тот же самый хост и порт),в то время как у него уже есть активное соединение с клиентом,он игнорирует новый запрос,если он равен первому (те же имя файла и опции).Это означает,что (новый)клиент будет обслуживаться уже существующим соединением на стороне сервера.Не устанавливая еще одно соединение,параллельно с текущим,сервер потребляет меньше ресурсов.</target>
        </trans-unit>
        <trans-unit id="89cbc4f7538c3f8a055eafb734ab8d43e17f7e9a" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to 255, otherwise it is masked with 16#FF:</source>
          <target state="translated">Если действует модификатор перевода Unicode ( &lt;code&gt;t&lt;/code&gt; ), целочисленный аргумент может быть любым числом, представляющим действительную кодовую точку Unicode, в противном случае это должно быть целое число, меньшее или равное 255, в противном случае оно маскируется с помощью 16 # FF:</target>
        </trans-unit>
        <trans-unit id="cc5c86359b9d2f999369876543233d4ea822c7b0" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is used in the format string, all event handlers must ensure that the formatted output is correctly encoded for the I/O device.</source>
          <target state="translated">Если в строке формата используется модификатор перевода Unicode ( &lt;code&gt;t&lt;/code&gt; ), все обработчики событий должны гарантировать, что форматированный вывод правильно закодирован для устройства ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="9a64305e88f74d03f63e30e4aff9344ad3928f49" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function clause:</source>
          <target state="translated">Если анализ выполняется на уровне предложения, результат выдается в виде списка кортежей &lt;code&gt;{Clause,Calls}&lt;/code&gt; . Здесь &lt;code&gt;Calls&lt;/code&gt; - это количество вызовов каждого предложения функции:</target>
        </trans-unit>
        <trans-unit id="7bb518d0fd97d3152a60a637270e37af04b13222" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt;, one for each function clause in the module. A clause is specified by its module name, function name, arity and position within the function definition:</source>
          <target state="translated">Если анализ выполняется на уровне предложения, результат выдается в виде списка кортежей &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt; , по одному для каждого функционального предложения в модуле. Предложение определяется его именем модуля, именем функции, арностью и положением в определении функции:</target>
        </trans-unit>
        <trans-unit id="2478a8c8617596c655cc3da82b5c379b47e51b09" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function:</source>
          <target state="translated">Если анализ выполняется на уровне функции, результат выдается в виде списка кортежей &lt;code&gt;{Function,Calls}&lt;/code&gt; . Здесь &lt;code&gt;Calls&lt;/code&gt; - это количество вызовов каждой функции:</target>
        </trans-unit>
        <trans-unit id="55b7df1c13246cf49b1f19e127c65003b3a10d37" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt;, one for each function in the module. A function is specified by its module name, function name and arity:</source>
          <target state="translated">Если анализ выполняется на уровне функции, результат выдается в виде списка кортежей &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt; , по одному для каждой функции в модуле. Функция определяется по имени модуля, имени функции и арности:</target>
        </trans-unit>
        <trans-unit id="77e592dc92d7ea0f9403bfb4d1e1860bc8a3fe5a" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given as a tuple &lt;code&gt;{Module,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the total number of calls to functions in the module:</source>
          <target state="translated">Если анализ выполняется на уровне модуля, результат выдается в виде кортежа &lt;code&gt;{Module,Calls}&lt;/code&gt; . Здесь &lt;code&gt;Calls&lt;/code&gt; - это общее количество вызовов функций в модуле:</target>
        </trans-unit>
        <trans-unit id="5cba27c146502c3ec8e1044a59eca78a126f8832" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given for the entire module as a tuple &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt;:</source>
          <target state="translated">Если анализ выполняется на уровне модуля, результат выдается для всего модуля в виде кортежа &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b39d0ccaa857b9f0a8f4a5ffffbdf43a68463d85" translate="yes" xml:space="preserve">
          <source>If the application SSH &lt;strong&gt;is&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt;, the command &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; delvers the list of algorithms after application of level 0 and level 1 configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53045943992891c562424981e5024fb26dfffc6" translate="yes" xml:space="preserve">
          <source>If the application SSH is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt;, the command &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; delivers the list of default (hardcoded) algorithms with respect to the support in the current cryptolib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde9769f09668ea79529ce6edefab85a0899d6da" translate="yes" xml:space="preserve">
          <source>If the application detects a communication failure (in a potentially partitioned network) that can have caused an inconsistent database, it can use the function &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; to define from which nodes each table is to be loaded. At startup, the Mnesia normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of when and if Mnesia terminated on other nodes. &lt;code&gt;MasterNodes&lt;/code&gt; can only contain nodes where the table has a replica. If the &lt;code&gt;MasterNodes&lt;/code&gt; list is empty, the master node recovery mechanism for the particular table is reset, and the normal load mechanism is used at the next restart.</source>
          <target state="translated">Если приложение обнаруживает сбой связи (в потенциально разделенной сети), который мог вызвать несогласованную базу данных, оно может использовать функцию &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; чтобы определить, из каких узлов должна быть загружена каждая таблица. При запуске алгоритм обычной загрузки таблицы Mnesia игнорируется, и таблица загружается с одного из главных узлов, определенных для таблицы, независимо от того, когда и если Mnesia завершилась на других узлах. &lt;code&gt;MasterNodes&lt;/code&gt; могут содержать только узлы, в которых таблица имеет реплику. Если список &lt;code&gt;MasterNodes&lt;/code&gt; пуст, механизм восстановления главного узла для конкретной таблицы сбрасывается, и при следующем перезапуске используется обычный механизм загрузки.</target>
        </trans-unit>
        <trans-unit id="130ab90516f90ac945b3ebb327eb04a5eb66e021" translate="yes" xml:space="preserve">
          <source>If the application detects that there has been a communication failure that can have caused an inconsistent database, it can use the function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; to pinpoint from which nodes each table can be loaded.</source>
          <target state="translated">Если приложение обнаруживает, что произошел сбой связи, который мог вызвать несогласованную базу данных, оно может использовать функцию &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; чтобы точно определить, из каких узлов может быть загружена каждая таблица.</target>
        </trans-unit>
        <trans-unit id="afc60992fdf5138ada7ac0487b61ff57acf63af0" translate="yes" xml:space="preserve">
          <source>If the application is distributed, setting the permission to &lt;code&gt;false&lt;/code&gt; means that the application will be started at, or moved to, another node according to how its distribution is configured (see &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если приложение распространяется, установка разрешения на &lt;code&gt;false&lt;/code&gt; означает, что приложение будет запущено или перемещено на другой узел в зависимости от того, как настроено его распространение (см. &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff80acb30d9dab81e0a46a50c51388e4dd17f7a3" translate="yes" xml:space="preserve">
          <source>If the application is not already loaded, the application controller first loads it using &lt;code&gt;application:load/1&lt;/code&gt;. It checks the value of the &lt;code&gt;applications&lt;/code&gt; key, to ensure that all applications that are to be started before this application are running.</source>
          <target state="translated">Если приложение еще не загружено, контроллер приложения сначала загружает его с помощью &lt;code&gt;application:load/1&lt;/code&gt; . Он проверяет значение ключа &lt;code&gt;applications&lt;/code&gt; , чтобы убедиться, что все приложения, которые должны быть запущены, прежде чем это приложение будут запущены.</target>
        </trans-unit>
        <trans-unit id="04b974d958e0b100d3e2e5b38644fd0a6abff6f9" translate="yes" xml:space="preserve">
          <source>If the application needs to include a generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e7f4b69d5dbe87fef4344be83c638457c7eec7" translate="yes" xml:space="preserve">
          <source>If the application needs to include the generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="translated">Если приложению необходимо включить сгенерированный файл &lt;code&gt;.hrl&lt;/code&gt; , оно должно использовать директиву &lt;code&gt;-include_lib&lt;/code&gt; для компилятора Erlang:</target>
        </trans-unit>
        <trans-unit id="683ef606c81dc1c47b5d3b9c095a4243030bc6f8" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;Func&lt;/code&gt;, the timetrap is triggered when this function returns. &lt;code&gt;Func&lt;/code&gt; can also return a new &lt;code&gt;Time&lt;/code&gt; value, which in that case is the value for the new timetrap.</source>
          <target state="translated">Если аргументом является &lt;code&gt;Func&lt;/code&gt; , при возврате из этой функции срабатывает ловушка времени. &lt;code&gt;Func&lt;/code&gt; также может возвращать новое значение &lt;code&gt;Time&lt;/code&gt; , которое в этом случае является значением для новой временной ловушки.</target>
        </trans-unit>
        <trans-unit id="0044e9d649274cc90388ee08844dd19dea89fffe" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;false&lt;/code&gt;, the call trace message mode for the current process is set to normal (non-silent) for this call and all later calls.</source>
          <target state="translated">Если аргумент &lt;code&gt;false&lt;/code&gt; , режим сообщения трассировки вызовов для текущего процесса устанавливается на нормальный (немой) для этого вызова и всех последующих вызовов.</target>
        </trans-unit>
        <trans-unit id="580f4ef0ac5467ad7d400143bdf178fbf747f519" translate="yes" xml:space="preserve">
          <source>If the argument is invalid</source>
          <target state="translated">Если аргумент недействителен</target>
        </trans-unit>
        <trans-unit id="c3def1ea3a84c13010f731140dbb829f22745007" translate="yes" xml:space="preserve">
          <source>If the argument is not &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the call trace message mode is unaffected.</source>
          <target state="translated">Если аргумент не является &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , режим сообщения трассировки вызовов не изменяется.</target>
        </trans-unit>
        <trans-unit id="259c1b3a1fe7d6190505c0293c344282223212ec" translate="yes" xml:space="preserve">
          <source>If the arguments or options are malformed, the function throws a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">Если аргументы или параметры имеют неправильный &lt;code&gt;badarg&lt;/code&gt; , функция выдает исключение badarg .</target>
        </trans-unit>
        <trans-unit id="6b60aa2a26e0a24944e43c25dc549ab30b52857b" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, and &lt;code&gt;I&lt;/code&gt; is greater than &lt;code&gt;size(Array)-1&lt;/code&gt;, the array grows to size &lt;code&gt;I+1&lt;/code&gt;.</source>
          <target state="translated">Если массив не имеет фиксированного размера, а &lt;code&gt;I&lt;/code&gt; больше &lt;code&gt;size(Array)-1&lt;/code&gt; , массив увеличивается до размера &lt;code&gt;I+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e97eb155a25d26096ef78fc2b67cf5447071cfc9" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, the default value for any index &lt;code&gt;I&lt;/code&gt; greater than &lt;code&gt;size(Array)-1&lt;/code&gt; is returned.</source>
          <target state="translated">Если массив не имеет фиксированного размера, возвращается значение по умолчанию для любого индекса &lt;code&gt;I&lt;/code&gt; больше &lt;code&gt;size(Array)-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5552e65bff8e7b19a94e0b983a0ae9846e97b32b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;len&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">Если атом уже существует, эта функция сохраняет термин в &lt;code&gt;*atom&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; . Также возвращает &lt;code&gt;false&lt;/code&gt; , если &lt;code&gt;len&lt;/code&gt; превышает максимальную длину, разрешенную для атома (255 символов).</target>
        </trans-unit>
        <trans-unit id="0d657f088165dffa1fac0e9bbe37e81e0983227b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if the length of &lt;code&gt;name&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">Если атом уже существует, эта функция сохраняет термин в &lt;code&gt;*atom&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; . Также возвращает &lt;code&gt;false&lt;/code&gt; , если длина &lt;code&gt;name&lt;/code&gt; превышает максимально допустимую для атома (255 символов).</target>
        </trans-unit>
        <trans-unit id="9a4fe1851aab21eaf10695f8609bb67b63980301" translate="yes" xml:space="preserve">
          <source>If the atomic compare and swap described above failed, the last pointer didn't point to the last element. In this case we need to insert the new element somewhere between the element that the last pointer pointed to and the actual last element. If we do it this way the last pointer will eventually end up at the last element when threads stop adding new elements. When trying to insert somewhere near the end and failing to do so, the inserting thread sometimes moves to the next element and sometimes tries with the same element again. This in order to spread the inserted elements during heavy contention. That is, we try to spread the modifications of memory to different locations instead of letting all threads continue to try to modify the same location in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc8e0e10b7bf47bd128f48e3648baa81fc6271d" translate="yes" xml:space="preserve">
          <source>If the attempt to truncate the log fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">Если попытка усечь журнал неудачна, процесс журнала диска завершается с сообщением EXIT &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt; . Другие процессы, у которых есть запросы в очереди, получают сообщение &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a48f973bcaa36e009e8c2234922f730ca71334" translate="yes" xml:space="preserve">
          <source>If the binder is not seen, the binder is validated. If the binder is valid, the server proceeds with the 0-RTT handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ec818fc01c7aa387cc6cab61ea5c97ff0c8f49" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt; systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7576e0423d861bfb48c83bfa3b5b0c281c96ce4" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt;systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="translated">Если сценарий загрузки содержит переменную пути &lt;code&gt;Var&lt;/code&gt; ,отличную от &lt;code&gt;$ROOT&lt;/code&gt; , эта переменная расширяется до &lt;code&gt;Dir&lt;/code&gt; . Используется, когда приложения устанавливаются в каталог, &lt;code&gt;$ROOT/lib&lt;/code&gt; от $ ROOT / lib ; см. &lt;code&gt;systools:make_script/1,2&lt;/code&gt; в SASL.</target>
        </trans-unit>
        <trans-unit id="dc4746e92bb60b88599fe7a3e474a68b05603534" translate="yes" xml:space="preserve">
          <source>If the call times out, a &lt;code&gt;timeout&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если время &lt;code&gt;timeout&lt;/code&gt; истекло, возникает исключение тайм-аута .</target>
        </trans-unit>
        <trans-unit id="55cc2b4bba08ca73afe9b3ccf29541b97304c864" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;erlang:load_nif/2&lt;/code&gt; fails, the module is unloaded and a warning report is sent to the error loader.</source>
          <target state="translated">Если вызов &lt;code&gt;erlang:load_nif/2&lt;/code&gt; завершается неудачно, модуль выгружается, и в загрузчик ошибок отправляется отчет с предупреждением.</target>
        </trans-unit>
        <trans-unit id="4b48d532db57aebd987ac6820de7ad7436dd64ed" translate="yes" xml:space="preserve">
          <source>If the callback module cannot be loaded, an error tuple is returned. The &lt;code&gt;Reason&lt;/code&gt; in the error tuple is the one returned by the code loader when trying to load the code of the callback module.</source>
          <target state="translated">Если модуль обратного вызова не может быть загружен, возвращается кортеж ошибки. &lt;code&gt;Reason&lt;/code&gt; в кортеже ошибки является один возвращаемый код загрузчика при попытке загрузить код модуля обратного вызова.</target>
        </trans-unit>
        <trans-unit id="8bf050fe2cb79b5d36a88eaed63edd7eed898889" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_get_state/1&lt;/code&gt; function, &lt;code&gt;get_state/1,2&lt;/code&gt; assumes that the &lt;code&gt;Misc&lt;/code&gt; value is the state of the callback module and returns it directly instead.</source>
          <target state="translated">Если модуль обратного вызова не экспортирует функцию &lt;code&gt;system_get_state/1&lt;/code&gt; , &lt;code&gt;get_state/1,2&lt;/code&gt; предполагает, что значение &lt;code&gt;Misc&lt;/code&gt; является состоянием модуля обратного вызова, и вместо этого возвращает его напрямую.</target>
        </trans-unit>
        <trans-unit id="883a1351f7fb38c93f27abac246b139ddf314ded" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_replace_state/2&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; assumes that &lt;code&gt;Misc&lt;/code&gt; is the state of the callback module, passes it to &lt;code&gt;StateFun&lt;/code&gt; and uses the return value as both the new state and as the new value of &lt;code&gt;Misc&lt;/code&gt;.</source>
          <target state="translated">Если модуль обратного вызова не экспортирует функцию &lt;code&gt;system_replace_state/2&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; предполагает, что &lt;code&gt;Misc&lt;/code&gt; является состоянием модуля обратного вызова, передает его в &lt;code&gt;StateFun&lt;/code&gt; и использует возвращаемое значение как новое состояние и как новое значение &lt;code&gt;Misc&lt;/code&gt; . ,</target>
        </trans-unit>
        <trans-unit id="79079b06e33e739dcb437556ed9482e9eedc90a9" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt; system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0469d22f2398ad4902a9f0274d691cde96d200" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="translated">Если модуль обратного вызова экспортирует функцию &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; , она вызывается в целевом процессе для замены ее состояния с помощью &lt;code&gt;StateFun&lt;/code&gt; . Его двумя аргументами являются &lt;code&gt;StateFun&lt;/code&gt; и &lt;code&gt;Misc&lt;/code&gt; , где &lt;code&gt;Misc&lt;/code&gt; совпадает со значением &lt;code&gt;Misc&lt;/code&gt; , возвращаемым &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;system_replace_state/2&lt;/code&gt; функция должна вернуть &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt; , где &lt;code&gt;NewState&lt;/code&gt; это новое состояние модуля обратного вызова, полученный путем вызова &lt;code&gt;StateFun&lt;/code&gt; и &lt;code&gt;NewMisc&lt;/code&gt; это возможно , новое значение используется для замены исходной &lt;code&gt;Misc&lt;/code&gt; (требуется , как &lt;code&gt;Misc&lt;/code&gt; часто содержит в себе состояние модуля обратного вызова).</target>
        </trans-unit>
        <trans-unit id="cdcc08df51274710d006dbff0355880927f9ffef" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt; Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c3eecf9345190c4251d4199b67e06fe9f176a1" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="translated">Если модуль обратного вызова экспортирует функцию &lt;code&gt;system_get_state/1&lt;/code&gt; , она вызывается в целевом процессе для получения ее состояния. Его аргумент такой же, как и значение &lt;code&gt;Misc&lt;/code&gt; , возвращаемое &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; , и ожидается , что функция &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; извлечет из него состояние модуля обратного вызова. Функция &lt;code&gt;system_get_state/1&lt;/code&gt; должна возвращать &lt;code&gt;{ok, State}&lt;/code&gt; , где &lt;code&gt;State&lt;/code&gt; - это состояние модуля обратного вызова.</target>
        </trans-unit>
        <trans-unit id="01c2d9fbdbf4902fbd9ed598640b451a617bf5cc" translate="yes" xml:space="preserve">
          <source>If the callback module's &lt;code&gt;system_get_state/1&lt;/code&gt; function crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception.</source>
          <target state="translated">Если функция &lt;code&gt;system_get_state/1&lt;/code&gt; модуля обратного вызова дает сбой или вызывает исключение, вызывающий абонент завершает работу с ошибкой &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt; , где &lt;code&gt;Module&lt;/code&gt; - это имя модуля обратного вызова, а &lt;code&gt;Class&lt;/code&gt; и &lt;code&gt;Reason&lt;/code&gt; указывают подробности исключения.</target>
        </trans-unit>
        <trans-unit id="7986fc8d38f019b96fd636349aa5cfd63d9efc6a" translate="yes" xml:space="preserve">
          <source>If the callback module's function &lt;code&gt;system_replace_state/2&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception. If the callback module does not provide a &lt;code&gt;system_replace_state/2&lt;/code&gt; function and &lt;code&gt;StateFun&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt;.</source>
          <target state="translated">Если функция модуля обратного вызова &lt;code&gt;system_replace_state/2&lt;/code&gt; дает сбой или вызывает исключение, вызывающий абонент завершает работу с ошибкой &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt; , где &lt;code&gt;Module&lt;/code&gt; - это имя модуля обратного вызова, а &lt;code&gt;Class&lt;/code&gt; и &lt;code&gt;Reason&lt;/code&gt; указывают подробности исключения. Если модуль обратного вызова не предоставляет функцию &lt;code&gt;system_replace_state/2&lt;/code&gt; и &lt;code&gt;StateFun&lt;/code&gt; аварийно завершает работу или выдает исключение, вызывающий абонент завершает работу с ошибкой &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f20f590333f587ce4f158c6bd3d9e3042df378fe" translate="yes" xml:space="preserve">
          <source>If the caller of the function wants to know whether or not acknowledgments are received for a certain notification (provided it is sent as an inform), the &lt;code&gt;Receiver&lt;/code&gt; parameter can be specified as &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; (refer to the Reference Manual, section snmp, module &lt;code&gt;snmp&lt;/code&gt; for more details). In this case, the agent send a message &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; or &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; for each management target.</source>
          <target state="translated">Если вызывающий функцию хочет знать, получены ли подтверждения для определенного уведомления (при условии, что оно отправлено как информационное), параметр &lt;code&gt;Receiver&lt;/code&gt; может быть указан как &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; (см. Справочное руководство, раздел snmp , модуль &lt;code&gt;snmp&lt;/code&gt; для более подробной информации). В этом случае агент отправляет сообщение &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; или &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; для каждой цели управления.</target>
        </trans-unit>
        <trans-unit id="b596624aa0902d380836d0a8912ab2326ff5b443" translate="yes" xml:space="preserve">
          <source>If the calling process holds on to the value of the persistent term and the persistent term is deleted in the future, the term will be copied to the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d99e3904aef3995d136af596a2f043101aa1f9" translate="yes" xml:space="preserve">
          <source>If the calling process is not trapping exits, and checking &lt;code&gt;PidOrPort&lt;/code&gt; is cheap (that is, if &lt;code&gt;PidOrPort&lt;/code&gt; is local), &lt;code&gt;link/1&lt;/code&gt; fails with reason &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">Если вызывающий процесс не перехватывает выходы, а проверка &lt;code&gt;PidOrPort&lt;/code&gt; дёшево (то есть, если &lt;code&gt;PidOrPort&lt;/code&gt; является локальным), &lt;code&gt;link/1&lt;/code&gt; не выполняется по причине &lt;code&gt;noproc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51149d8666bb19147118b83bb274dae83a5f60ca" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a8b4f21577fe3cc5ca8d0fd53bd3ee9424f7f7" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="translated">Если вызывающий процесс позже завершается с помощью &lt;code&gt;Reason&lt;/code&gt; , диспетчер событий удаляет обработчик событий, вызывая &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; с аргументом &lt;code&gt;{stop,Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f41eb527b8f8f2ec9a45659469012def9325921e" translate="yes" xml:space="preserve">
          <source>If the capture options describe that no substring capturing is to be done (&lt;code&gt;{capture, none}&lt;/code&gt;), the function returns the single atom &lt;code&gt;match&lt;/code&gt; upon successful matching, otherwise the tuple &lt;code&gt;{match, ValueList}&lt;/code&gt;. Disabling capturing can be done either by specifying &lt;code&gt;none&lt;/code&gt; or an empty list as &lt;code&gt;ValueSpec&lt;/code&gt;.</source>
          <target state="translated">Если в параметрах захвата указано, что захват подстроки не требуется ( &lt;code&gt;{capture, none}&lt;/code&gt; ), функция возвращает &lt;code&gt;match&lt;/code&gt; одного атома после успешного совпадения, в противном случае - кортеж &lt;code&gt;{match, ValueList}&lt;/code&gt; . Отключить захват можно, не указав &lt;code&gt;none&lt;/code&gt; или пустой список как &lt;code&gt;ValueSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dfe9740232e522c9dccf1bcdb49e9bacfa76b87" translate="yes" xml:space="preserve">
          <source>If the carrier could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">Если несущая не может быть просканирована полностью без ущерба для &lt;code&gt;UnscannedSize&lt;/code&gt; системы, UnscannedSize - это количество байтов, которые нужно было пропустить.</target>
        </trans-unit>
        <trans-unit id="b3d882b62bc462be24a22c4ebd1a0b80e4bbf23e" translate="yes" xml:space="preserve">
          <source>If the character escaping feature needs to be disabled (typically for backwards compatibility reasons), use the &lt;code&gt;ct_run&lt;/code&gt; start flag &lt;code&gt;-no_esc_chars&lt;/code&gt;, or the &lt;code&gt;ct:run_test/1&lt;/code&gt; start option &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; (this start option is also supported in test specifications).</source>
          <target state="translated">Если функция побега символов должна быть отключена ( как правило , из соображений совместимости в обратном направлении), использовать &lt;code&gt;ct_run&lt;/code&gt; флаг старта &lt;code&gt;-no_esc_chars&lt;/code&gt; , или &lt;code&gt;ct:run_test/1&lt;/code&gt; старт опции &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; (этот вариант запуска также поддерживается в спецификациях тестов) ,</target>
        </trans-unit>
        <trans-unit id="93733502359d2306f277753fcf5f39262e0db10b" translate="yes" xml:space="preserve">
          <source>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that &lt;code&gt;delete_child/2&lt;/code&gt; has no meaning and &lt;code&gt;restart_child/2&lt;/code&gt; cannot be used for these children.</source>
          <target state="translated">Если дочерний элемент временный, дочерняя спецификация удаляется, как только процесс завершается. Это означает, что &lt;code&gt;delete_child/2&lt;/code&gt; не имеет значения и &lt;code&gt;restart_child/2&lt;/code&gt; не может использоваться для этих потомков.</target>
        </trans-unit>
        <trans-unit id="43bb63cf5661d4a237a06093eced5cd149d67b35" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="translated">Если дочерний процесс является другим супервизором, он должен быть установлен на &lt;code&gt;infinity&lt;/code&gt; чтобы дать поддереву достаточно времени для завершения работы. Также можно установить его на &lt;code&gt;infinity&lt;/code&gt; , если дочерний процесс является рабочим. См. Предупреждение ниже:</target>
        </trans-unit>
        <trans-unit id="d5e42700559025ed548daef3157e2a83d1175a5d" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it must be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ca616fb018a5f7ed9b1457ccf717eb545a0d6c" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker.</source>
          <target state="translated">Если дочерний процесс является другим супервизором, время выключения должно быть установлено на &lt;code&gt;infinity&lt;/code&gt; чтобы дать поддереву достаточно времени для выключения. Также можно установить его на &lt;code&gt;infinity&lt;/code&gt; , если дочерний процесс является рабочим.</target>
        </trans-unit>
        <trans-unit id="65acda7f63f750f753fdf6f71ac3163eb7c73a09" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time must be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c8d2313d1867bff7ceabb992796a9dc2cb660e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the child specification is added to the supervisor (unless the supervisor is a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor, see below), the pid is set to &lt;code&gt;undefined&lt;/code&gt;, and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;ignore&lt;/code&gt; , дочерняя спецификация добавляется к супервизору (если супервизор не является супервизором &lt;code&gt;simple_one_for_one&lt;/code&gt; , см. Ниже), для pid устанавливается значение &lt;code&gt;undefined&lt;/code&gt; , а функция возвращает &lt;code&gt;{ok,undefined}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef5502f7b080e1244d616694cf24b3ea2478505" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the pid remains set to &lt;code&gt;undefined&lt;/code&gt; and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;ignore&lt;/code&gt; , pid остается &lt;code&gt;undefined&lt;/code&gt; а функция возвращает &lt;code&gt;{ok,undefined}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7a47396e2013d77055f46cf69011c8dbc710aa" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the child specification and pid are added to the supervisor and the function returns the same value.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;{ok,Child}&lt;/code&gt; или &lt;code&gt;{ok,Child,Info}&lt;/code&gt; , дочерняя спецификация и pid добавляются к супервизору, и функция возвращает то же значение.</target>
        </trans-unit>
        <trans-unit id="48c5d696f2b0fd45c1b44f5e625a2accf1b0ea21" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the pid is added to the supervisor and the function returns the same value.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает &lt;code&gt;{ok,Child}&lt;/code&gt; или &lt;code&gt;{ok,Child,Info}&lt;/code&gt; , pid добавляется в супервизор, и функция возвращает то же значение.</target>
        </trans-unit>
        <trans-unit id="6d773deb857a328ed14a9080339dfab940c8161a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает кортеж ошибок или ошибочное значение, или если это не удается, дочерняя спецификация отбрасывается, и функция возвращает &lt;code&gt;{error,Error}&lt;/code&gt; , где &lt;code&gt;Error&lt;/code&gt; - это термин, содержащий информацию об ошибке и дочерней спецификации.</target>
        </trans-unit>
        <trans-unit id="1b122e474c03f3cefc84e42bbf3408fd35e5bb5e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error.</source>
          <target state="translated">Если функция запуска дочернего процесса возвращает кортеж с ошибкой или ошибочное значение, или если это не удается, функция возвращает &lt;code&gt;{error,Error}&lt;/code&gt; , где &lt;code&gt;Error&lt;/code&gt; - термин, содержащий информацию об ошибке.</target>
        </trans-unit>
        <trans-unit id="4b1288099957500451c193cb8d9ad26569f30036" translate="yes" xml:space="preserve">
          <source>If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification exists but the corresponding process is already running, the function returns &lt;code&gt;{error,running}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;{error,not_found}&lt;/code&gt; спецификация, идентифицированная &lt;code&gt;Id&lt;/code&gt; , не существует, функция возвращает {error, not_found} . Если дочерняя спецификация существует, но соответствующий процесс уже запущен, функция возвращает &lt;code&gt;{error,running}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdb0f0cbc98dc7d94d6b59162ff7e5e589d60364" translate="yes" xml:space="preserve">
          <source>If the client does not support any of the server advertised protocols or the server does not advertise any protocols, the client falls back to the first protocol in its list or to the default protocol (if a default is supplied). If the server does not support Next Protocol Negotiation, the connection terminates if no default protocol is supplied.</source>
          <target state="translated">Если клиент не поддерживает ни один из рекламируемых протоколов сервера или сервер не рекламирует ни один из протоколов,клиент возвращается к первому протоколу в своем списке или к протоколу по умолчанию (если поставляется протокол по умолчанию).Если сервер не поддерживает Next Protocol Negotiation,соединение прекращается,если не поставляется протокол по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1eacb16ee64844ecf9771b5e95710813db228ddf" translate="yes" xml:space="preserve">
          <source>If the client earlier has acquired a lock through &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt;, this operation releases the associated lock. To access another target than &lt;code&gt;running&lt;/code&gt;, the server must support &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">Если клиент ранее получил блокировку через &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt; , эта операция снимает связанную блокировку. Чтобы получить доступ к другой цели, кроме &lt;code&gt;running&lt;/code&gt; , сервер должен поддерживать &lt;code&gt;:candidate&lt;/code&gt; и / или &lt;code&gt;:startup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35cb61822f1edfb65ab7f8cb515f968decf80d92" translate="yes" xml:space="preserve">
          <source>If the client fails to send the first ssh message after a tcp connection setup within this time (in milliseconds), the connection is closed. The default value is 30 seconds. This is actualy a generous time, so it can lowered to make the daemon less prone to DoS attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1ef493c0d6b60856faddf62e5c3f0669465abe" translate="yes" xml:space="preserve">
          <source>If the code cannot be structured as in the &lt;code&gt;multiple_setelement/1&lt;/code&gt; example, the best way to modify multiple elements in a large tuple is to convert the tuple to a list, modify the list, and convert it back to a tuple.</source>
          <target state="translated">Если код не может быть структурирован, как в примере &lt;code&gt;multiple_setelement/1&lt;/code&gt; , лучший способ изменить несколько элементов в большом кортеже - это преобразовать кортеж в список, изменить список и преобразовать его обратно в кортеж.</target>
        </trans-unit>
        <trans-unit id="929332aa79f38c1ef62558eac8beb42b63e4173b" translate="yes" xml:space="preserve">
          <source>If the common &lt;strong&gt;state callback&lt;/strong&gt; needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b7ca0808d04f400f34111028c04d20133e9b2d" translate="yes" xml:space="preserve">
          <source>If the common event handler needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="translated">Если обычному обработчику событий необходимо знать текущее состояние, вместо этого можно использовать функцию &lt;code&gt;handle_common/4&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff5b1741be466acda153b10a36fc7487f2ca70d6" translate="yes" xml:space="preserve">
          <source>If the compiler is to warn for missing callback functions, as it does for the OTP behaviours, add &lt;code&gt;-callback&lt;/code&gt; attributes in the behaviour module to describe the expected callbacks:</source>
          <target state="translated">Если компилятор должен предупреждать об отсутствующих функциях обратного вызова, как это делается для поведения OTP, добавьте атрибуты &lt;code&gt;-callback&lt;/code&gt; в модуль поведения для описания ожидаемых обратных вызовов:</target>
        </trans-unit>
        <trans-unit id="523bb4f391597ed38f62115f28e3a49961855867" translate="yes" xml:space="preserve">
          <source>If the complete history is to be stored in the configuration file, &lt;code&gt;Config&lt;/code&gt; must be &lt;code&gt;all&lt;/code&gt;. If only a selected number of entries from the history are to be stored, &lt;code&gt;Config&lt;/code&gt; must be a list of integers pointing out the entries to be stored.</source>
          <target state="translated">Если полная история должна храниться в файле конфигурации, &lt;code&gt;Config&lt;/code&gt; должен быть &lt;code&gt;all&lt;/code&gt; . Если необходимо сохранить только выбранное количество записей из истории, &lt;code&gt;Config&lt;/code&gt; должен быть списком целых чисел, указывающих записи, которые будут сохранены.</target>
        </trans-unit>
        <trans-unit id="21e0716b03f7aa9ffd13782b0d420ef9a664a3d2" translate="yes" xml:space="preserve">
          <source>If the condition is not in any of the above formats, it must be an assertion. This can be a positive or negative lookahead or lookbehind assertion. Consider the following pattern, containing non-significant whitespace, and with the two alternatives on the second line:</source>
          <target state="translated">Если условие не в одном из вышеперечисленных форматов,то это должно быть утверждение.Это может быть положительное или отрицательное внешнее или внешнее утверждение.Рассмотрим следующий шаблон,содержащий несущественные пробелы,и два варианта на второй линии:</target>
        </trans-unit>
        <trans-unit id="8a2fdb8b039278dbbab74f5b7bfb97af967770cd" translate="yes" xml:space="preserve">
          <source>If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern (if present). If more than two alternatives exist in the subpattern, a compile-time error occurs. Each of the two alternatives can itself contain nested subpatterns of any form, including conditional subpatterns; the restriction to two alternatives applies only at the level of the condition. The following pattern fragment is an example where the alternatives are complex:</source>
          <target state="translated">Если условие выполнено,используется образец &quot;да&quot;,в противном случае образец &quot;нет&quot; (если имеется).Если в подмаскировке существует более двух альтернатив,возникает ошибка компиляции.Каждая из двух альтернатив может сама содержать вложенные подмаски любой формы,включая условные подмаски;ограничение на две альтернативы действует только на уровне условия.Следующий фрагмент подмаски является примером,где альтернативы сложны:</target>
        </trans-unit>
        <trans-unit id="fa304219623acf477a2744ed1bbab72da379738b" translate="yes" xml:space="preserve">
          <source>If the condition is the string (DEFINE), and there is no subpattern with the name DEFINE, the condition is always false. In this case, there can be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern. The idea of DEFINE is that it can be used to define &quot;subroutines&quot; that can be referenced from elsewhere. (The use of subroutines is described below.) For example, a pattern to match an IPv4 address, such as &quot;192.168.23.245&quot;, can be written like this (ignore whitespace and line breaks):</source>
          <target state="translated">Если условием является строка (DEFINE),и нет подмаски с именем DEFINE,то условие всегда ложно.В этом случае в подмаскировке может быть только одна альтернатива.Оно всегда пропускается,если элемент управления достигает этой точки на детали.Идея функции DEFINE заключается в том,что ее можно использовать для определения &quot;подмаскидок&quot;,на которые можно ссылаться из других мест.(Использование подпрограмм описано ниже.)Например,деталь,соответствующая адресу IPv4,такая как &quot;192.168.23.245&quot;,может быть записана таким образом (игнорируйте пробелы и разрывы линий):</target>
        </trans-unit>
        <trans-unit id="8e3f4e65a85b857108a35b24009e6fe7e2ac2084" translate="yes" xml:space="preserve">
          <source>If the condition is the string (R), and there is no subpattern with the name R, the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R, for example:</source>
          <target state="translated">Если условием является строка (R),а подмасказка с именем R отсутствует,то условие истинно,если был произведен рекурсивный вызов всей детали или любой подмаски.Например,если цифры или имя,которому предшествует амперсанд,следуют за буквой R:</target>
        </trans-unit>
        <trans-unit id="95c431a360008991bb1b7759c9f06391d6e75043" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, or if the initiation fails, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">Если конфигурация ошибочна или инициализация не удалась, функция обратного вызова должна вернуть &lt;code&gt;{error,Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18a294113eb6042d9ad2a36514917a6dc077c344" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">Если конфигурация ошибочна, функция обратного вызова должна вернуть &lt;code&gt;{error,Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a82e12e149afd95e3ddf1bb75d52a9982f828ca" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the same arguments as when &lt;code&gt;enable/2&lt;/code&gt; was called.</source>
          <target state="translated">Если параметр конфигурации &lt;code&gt;os_sup_enable&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; , эта функция автоматически &lt;code&gt;os_sup&lt;/code&gt; с теми же аргументами, что и при вызове &lt;code&gt;enable/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aedee7601f2ce3a18dc9a8c63054f54ca3093e3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the values of &lt;code&gt;os_sup_own&lt;/code&gt; and &lt;code&gt;os_sup_syslogconf&lt;/code&gt; as arguments.</source>
          <target state="translated">Если параметр конфигурации &lt;code&gt;os_sup_enable&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; , эта функция вызывается автоматически &lt;code&gt;os_sup&lt;/code&gt; , используя значения &lt;code&gt;os_sup_own&lt;/code&gt; и &lt;code&gt;os_sup_syslogconf&lt;/code&gt; в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="b2ffcf1c22e3ce76143a4b07b440007a5df05ea7" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;relocatable&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt; there is no need to install the target system with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be started. In that case the file tree containing the target system can be moved without re-installation.</source>
          <target state="translated">Если для параметра конфигурации &lt;code&gt;relocatable&lt;/code&gt; задано значение &lt;code&gt;true&lt;/code&gt; , нет необходимости устанавливать целевую систему с помощью &lt;code&gt;reltool:install/2&lt;/code&gt; до ее запуска. В этом случае файловое дерево, содержащее целевую систему, можно переместить без переустановки.</target>
        </trans-unit>
        <trans-unit id="f9be9f192141862f112332246e5a8f6499cf62cb" translate="yes" xml:space="preserve">
          <source>If the connection between the nodes involved in the spawn operation is lost during the spawn operation, the spawn operation will fail with an error reason of &lt;code&gt;noconnection&lt;/code&gt;. A new process may or may not have been created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9759af159af887f4fafa82c8992b674a1e93e4" translate="yes" xml:space="preserve">
          <source>If the connection between the nodes involved in the spawn operation is lost during the spawn operation, the spawn operation will fail with an error reason of &lt;code&gt;noconnection&lt;/code&gt;. A new process may or may not have been created. If it has been created, it will be delivered an exit signal with an exit reason of &lt;code&gt;noconnection&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f42cb19285f317fb015c9fad2016cce36110ed" translate="yes" xml:space="preserve">
          <source>If the connection timeout option &lt;code&gt;connect_timeout&lt;/code&gt; is set, that value is used also for the negotiation timeout and this option (&lt;code&gt;timeout&lt;/code&gt;) is ignored.</source>
          <target state="translated">Если установлена ​​опция времени ожидания соединения &lt;code&gt;connect_timeout&lt;/code&gt; , это значение также используется для тайм-аута согласования, и эта опция ( &lt;code&gt;timeout&lt;/code&gt; ) игнорируется.</target>
        </trans-unit>
        <trans-unit id="860a4598c1d1ec6a83570120e591b858d6e8f890" translate="yes" xml:space="preserve">
          <source>If the connection to a remote node goes down, the main node will mark it as lost. If the node comes back it will be added again. If the remote node was alive during the disconnected periode, cover data from before and during this periode will be included in the analysis.</source>
          <target state="translated">Если соединение с удаленным узлом прервется,основной узел пометит его как потерянный.Если узел вернется,он будет добавлен снова.Если удаленный узел был жив в течение периода отключения,то в анализ будут включены данные,полученные до и в течение этого периода.</target>
        </trans-unit>
        <trans-unit id="a99ee1cb6fcf81c8bae71874c193979ebe43ebab" translate="yes" xml:space="preserve">
          <source>If the constraints described so far is not enough, additional constraints can be written in C in &lt;code&gt;beam_load.c&lt;/code&gt; and be called as a guard function on the left side of the transformation. If the guard function returns a non-zero value, the matching of the rule will continue, otherwise the match will fail. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b7535bf38d5e1053e0dcfad4dfa786c040f2e7" translate="yes" xml:space="preserve">
          <source>If the contents of &lt;code&gt;.erlang&lt;/code&gt; are changed and a private version of &lt;code&gt;user_default&lt;/code&gt; is defined, the Erlang/OTP environment can be customized. More powerful changes can be made by supplying command-line arguments in the startup script &lt;code&gt;erl&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если содержимое &lt;code&gt;.erlang&lt;/code&gt; изменено и определена частная версия &lt;code&gt;user_default&lt;/code&gt; , среда Erlang / OTP может быть настроена. Более важные изменения можно внести, указав аргументы командной строки в сценарии запуска &lt;code&gt;erl&lt;/code&gt; . Для получения дополнительной информации см. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6279554b0d57c5f26b8ffa794daeaf8c67036750" translate="yes" xml:space="preserve">
          <source>If the context requires an integer rather than a variable, an atom, or a string, you cannot use the uppercase convention to mark an automatic metavariable. Instead, if the integer (without the &lt;code&gt;909&lt;/code&gt;-prefix and lift/glob markers) ends in a &lt;code&gt;9&lt;/code&gt;, the integer will become an Erlang-level variable prefixed with &lt;code&gt;Q&lt;/code&gt;, and if it ends with &lt;code&gt;99&lt;/code&gt; it will also be automatically abstracted. For example, the following will increment the arity of the exported function f:</source>
          <target state="translated">Если для контекста требуется целое число, а не переменная, атом или строка, вы не можете использовать соглашение о верхнем регистре для пометки автоматической метапеременной. Вместо этого, если целое число (без префикса &lt;code&gt;909&lt;/code&gt; и маркеров подъема / подстановки) заканчивается на &lt;code&gt;9&lt;/code&gt; , целое число станет переменной уровня Erlang с префиксом &lt;code&gt;Q&lt;/code&gt; , а если оно заканчивается на &lt;code&gt;99&lt;/code&gt; , оно также будет автоматически абстрагировано. Например, следующее будет увеличивать арность экспортируемой функции f:</target>
        </trans-unit>
        <trans-unit id="e14244783ffadbf99f1d872c65ba8477af77375e" translate="yes" xml:space="preserve">
          <source>If the converse of a function F is a function F', then F' is called the &lt;strong id=&quot;inverse&quot;&gt;inverse&lt;/strong&gt; of F.</source>
          <target state="translated">Если функция F, обратная функции F, является функцией F ', то F называется &lt;strong id=&quot;inverse&quot;&gt;обратной&lt;/strong&gt; функцией F.</target>
        </trans-unit>
        <trans-unit id="04e1722c7eed1557956908ac595866c524c53815" translate="yes" xml:space="preserve">
          <source>If the cross compilation tools are prefixed by &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; you probably do not need to set these variables (where &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; is what has been passed as &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt;).</source>
          <target state="translated">Если инструменты кросс-компиляции имеют префикс &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; вам, вероятно, не нужно устанавливать эти переменные (где &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; - это то, что было передано как аргумент &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; для &lt;code&gt;configure&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="97604b617615c0b88c829c8abf48415d16d68d04" translate="yes" xml:space="preserve">
          <source>If the current working directory for &lt;code&gt;erlc&lt;/code&gt; is different from the working directory active when the compile server was started, &lt;strong&gt;and&lt;/strong&gt; if the compile server has active jobs, it will be restarted as soon as those jobs have finished. (Build systems that build files randomly across multiple directories in parallel will probably not benefit from the compile server.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693638c468a0a688aceae31ef9d5b589f67e3d3d" translate="yes" xml:space="preserve">
          <source>If the data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag &lt;code&gt;error&lt;/code&gt;, a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging, as it still constitutes a possibly deep or mixed list, or both, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is returned &quot;as is&quot;.</source>
          <target state="translated">Если данные не могут быть преобразованы либо из-за недопустимых символов Unicode / ISO Latin-1 в списке, либо из-за недопустимой кодировки UTF в любых двоичных файлах, возвращается кортеж с ошибкой. Кортеж ошибок содержит тег &lt;code&gt;error&lt;/code&gt; , список, представляющий символы, которые могли быть преобразованы до возникновения ошибки, и представление символов, включая и после ошибочного целого числа / байтов. Последняя часть в основном предназначена для отладки, так как она по-прежнему представляет собой, возможно, глубокий или смешанный список, или и то, и другое, не обязательно той же глубины, что и исходные данные. Ошибка возникает при просмотре списка, и все, что осталось декодировать, возвращается &amp;laquo;как есть&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="830c19e2812b5ad638344d6692b4a5d1c14189d2" translate="yes" xml:space="preserve">
          <source>If the data in the table is to be accessed so that the order of the keys in the table is significant, the table type &lt;code&gt;ordered_set&lt;/code&gt; can be used instead of the more usual &lt;code&gt;set&lt;/code&gt; table type. An &lt;code&gt;ordered_set&lt;/code&gt; is always traversed in Erlang term order regarding the key field so that the return values from functions such as &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;match_object&lt;/code&gt;, and &lt;code&gt;foldl&lt;/code&gt; are ordered by the key values. Traversing an &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; operations also returns the keys ordered.</source>
          <target state="translated">Если необходимо получить доступ к данным в таблице, чтобы порядок ключей в таблице был значимым, можно использовать тип таблицы &lt;code&gt;ordered_set&lt;/code&gt; вместо более обычного типа таблицы &lt;code&gt;set&lt;/code&gt; . &lt;code&gt;ordered_set&lt;/code&gt; всегда проходится в Erlang срок порядка относительно ключевого поля , так что значения возврата из функций , таких как &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;match_object&lt;/code&gt; и &lt;code&gt;foldl&lt;/code&gt; упорядочены по ключевым значениям. &lt;code&gt;ordered_set&lt;/code&gt; к указанному набору с &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; операциями также возвращает упорядоченные ключи.</target>
        </trans-unit>
        <trans-unit id="c7cef7dde804ec38da41a38a959068e58669e710" translate="yes" xml:space="preserve">
          <source>If the data is to be sent from the driver to the port owner process, it is faster to use &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если данные должны быть отправлены от драйвера к процессу владельца порта, быстрее использовать &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d69f0718531a0dc4b5192097fe34a9a400874115" translate="yes" xml:space="preserve">
          <source>If the database is huge, it it not always possible to restore it online. In such cases, restore the old database by installing a fallback and then restart.</source>
          <target state="translated">Если база данных огромна,то не всегда можно восстановить ее в режиме онлайн.В таких случаях восстановите старую базу данных,установив запасной вариант,а затем перезапустите.</target>
        </trans-unit>
        <trans-unit id="1a465de33f0929289f4ba867f52979d6f1b60be6" translate="yes" xml:space="preserve">
          <source>If the decoded message happens to be received before the connection is established, a new &quot;virtual&quot; connection is established. This is typically the case for the Media Gateway Controller (MGC) upon the first Service Change. When this occurs the following callback function will be invoked:</source>
          <target state="translated">Если декодированное сообщение приходит до установления соединения,устанавливается новое &quot;виртуальное&quot; соединение.Как правило,это происходит с контроллером шлюза мультимедиа (MGC)при первом изменении службы.В этом случае будет вызвана следующая функция обратного вызова:</target>
        </trans-unit>
        <trans-unit id="fbdce8830ddb42e0e285519e4fb52411ce2090fe" translate="yes" xml:space="preserve">
          <source>If the decoded message instead of transactions contains a message error, the following callback function will be invoked:</source>
          <target state="translated">Если декодированное сообщение вместо транзакций содержит ошибку в сообщении,то будет вызвана следующая функция обратного вызова:</target>
        </trans-unit>
        <trans-unit id="6be7e8b5958c0936e75a2ab6e68f6fdfd8645d72" translate="yes" xml:space="preserve">
          <source>If the default value is not suitable, the type letter can be followed by &lt;code&gt;=&lt;/code&gt; and a value. Most types take an integer value. The value for an atom is written the same way as in the C source code. For example, the atom &lt;code&gt;false&lt;/code&gt; is written as &lt;code&gt;am_false&lt;/code&gt;. The atom must be listed in &lt;code&gt;atom.names&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05877711912cb7abc7753f9ce969b4440e6bb55" translate="yes" xml:space="preserve">
          <source>If the definitions are identical, the output module keeps only one definition with the original name.</source>
          <target state="translated">Если определения идентичны,модуль вывода сохраняет только одно определение с оригинальным именем.</target>
        </trans-unit>
        <trans-unit id="709eb064721592f0145e0c9870df4b79e36f2fb2" translate="yes" xml:space="preserve">
          <source>If the definitions have the same name and differs in the definition, they are renamed. The new names are the definition name and the original module name concatenated.</source>
          <target state="translated">Если определения имеют одно и то же имя и отличаются от определения,они переименовываются.Новые имена-это имя определения,а оригинальное имя модуля-конкатенированное.</target>
        </trans-unit>
        <trans-unit id="c3055c07c7bca6e36c452534d5a6de3daec9136a" translate="yes" xml:space="preserve">
          <source>If the deleted entry is a registered subscriber, it will imply that the subscriber process gets is unregistered as subscriber as well as it gets it final message.</source>
          <target state="translated">Если удаленная запись является зарегистрированным абонентом,то это будет означать,что полученный абонентом процесс является незарегистрированным абонентом,а также получит итоговое сообщение.</target>
        </trans-unit>
        <trans-unit id="b7794972861adba2b5114706df92a0c8a22b1b7d" translate="yes" xml:space="preserve">
          <source>If the deleted term (or any part of it) is still used by a process, that process will do a major (fullsweep) garbage collection and copy the term into the process. However, at most two processes at a time will be scheduled to do that kind of garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818e5bafa76101bf732fc51de14593ea48da629f" translate="yes" xml:space="preserve">
          <source>If the destination node would have to be auto-connected to do the send, &lt;code&gt;noconnect&lt;/code&gt; is returned instead.</source>
          <target state="translated">Если узел назначения должен быть автоматически подключен для отправки, вместо этого возвращается &lt;code&gt;noconnect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa49b96a6e23a80a21210ac903528ecee8169a93" translate="yes" xml:space="preserve">
          <source>If the directory for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is &lt;code&gt;/etc&lt;/code&gt;, the line in &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is as follows:</source>
          <target state="translated">Если каталог для файлов &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; и &lt;code&gt;syslog.conf.OTP&lt;/code&gt; - &lt;code&gt;/etc&lt;/code&gt; , строка в &lt;code&gt;syslog.conf.OTP&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="1cfa13bd96270a398f97e146ebd653c8f1622e36" translate="yes" xml:space="preserve">
          <source>If the directory is not found</source>
          <target state="translated">Если каталог не найден</target>
        </trans-unit>
        <trans-unit id="ee9c7c20028055c752f1006405fb6ac3dd62c654" translate="yes" xml:space="preserve">
          <source>If the directory refers to a directory in an archive, the archive name is stripped away before the path is returned. For example, if directory &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; is in the path, &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; is returned. This means that the library directory for an application is the same, regardless if the application resides in an archive or not.</source>
          <target state="translated">Если каталог ссылается на каталог в архиве, имя архива удаляется перед возвратом пути. Например, если каталог &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; находится в пути, &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; возвращается. Это означает, что каталог библиотеки для приложения одинаков, независимо от того, находится приложение в архиве или нет.</target>
        </trans-unit>
        <trans-unit id="f85643a441c622fdd2576beffc4873deda4e4256" translate="yes" xml:space="preserve">
          <source>If the dirty NIF is expected to be CPU-bound, its &lt;code&gt;flags&lt;/code&gt; field is to be set to &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt;.</source>
          <target state="translated">Если ожидается, что грязный NIF будет связан с ЦП, его поле &lt;code&gt;flags&lt;/code&gt; должно быть установлено в &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; или &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23d292909c9d32167cfb8c2e96fc30eeaf637bf8" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt; stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2ddfd812a9a461d82c50bcdf565e3ca018a4da" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="translated">Если драйвер по какой-то причине хочет сохранить двоичный файл драйвера, например, в статической переменной, счетчик ссылок должен быть увеличен, а двоичный файл может быть позже освобожден в &lt;code&gt;driver_free_binary&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; с помощью driver_free_binary .</target>
        </trans-unit>
        <trans-unit id="a12df4e4fa0309d2f4f4f74b51f81225f4bdeeaf" translate="yes" xml:space="preserve">
          <source>If the driver has option &lt;code&gt;kill_ports&lt;/code&gt; set, or if &lt;code&gt;kill_ports&lt;/code&gt; is specified as an option to this function, all pending ports using this driver are killed when unloading is done by the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. If no port-killing is involved and there are open ports, the unloading is delayed until no more open ports use the driver. If, in this case, another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (or even this user) loads the driver again before the driver is unloaded, the unloading never takes place.</source>
          <target state="translated">Если в драйвере установлена ​​опция &lt;code&gt;kill_ports&lt;/code&gt; или если &lt;code&gt;kill_ports&lt;/code&gt; указан как опция для этой функции, все ожидающие порты, использующие этот драйвер, уничтожаются, когда выгрузка выполняется последним &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; . Если не происходит уничтожение портов и есть открытые порты, выгрузка откладывается до тех пор, пока не перестанут использоваться открытые порты. Если в этом случае другой &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (или даже этот пользователь) снова загружает драйвер до его выгрузки, выгрузка никогда не происходит.</target>
        </trans-unit>
        <trans-unit id="fcf785a336b2c213c45577e83eb09e396c7e3eab" translate="yes" xml:space="preserve">
          <source>If the driver is unloaded (not present in the system), error code &lt;code&gt;not_loaded&lt;/code&gt; is returned. Option &lt;code&gt;reload&lt;/code&gt; is intended for when the user has already loaded the driver in advance.</source>
          <target state="translated">Если драйвер выгружен (отсутствует в системе), возвращается код ошибки &lt;code&gt;not_loaded&lt;/code&gt; . Опция &lt;code&gt;reload&lt;/code&gt; предназначена для случаев , когда пользователь уже заранее загрузил драйвер.</target>
        </trans-unit>
        <trans-unit id="4d39f81561d0eb5e9555b68509516e98553687c4" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt; erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3e2b2e4d5d486f038ae4047d709485c51ebafd" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если драйвер хочет вернуть данные, он должен вернуть их в &lt;code&gt;rbuf&lt;/code&gt; . Когда вызывается &lt;code&gt;control&lt;/code&gt; , &lt;code&gt;*rbuf&lt;/code&gt; указывает на буфер &lt;code&gt;rlen&lt;/code&gt; байтов по умолчанию , который можно использовать для возврата данных. Данные возвращаются по-разному в зависимости от флагов управления портом (тех, которые установлены с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f299a698f91b18144d2db6873d22e3355371e343" translate="yes" xml:space="preserve">
          <source>If the driver was previously unloaded, but is still present because of open ports to it, a call to &lt;code&gt;load/2&lt;/code&gt; stops the unloading and keeps the driver (as long as &lt;code&gt;Path&lt;/code&gt; is the same), and &lt;code&gt;ok&lt;/code&gt; is returned. If you really want the object code to be reloaded, use &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; or the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead. See also the description of &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; for loading/unloading in the introduction.</source>
          <target state="translated">Если драйвер был ранее выгружен, но все еще присутствует из-за открытых для него портов, вызов &lt;code&gt;load/2&lt;/code&gt; останавливает выгрузку и сохраняет драйвер (до тех пор, пока &lt;code&gt;Path&lt;/code&gt; остается таким же), и возвращается &lt;code&gt;ok&lt;/code&gt; . Если вы действительно хотите перезагрузить объектный код, используйте вместо этого &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; или низкоуровневый интерфейс &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; . См. Также описание &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; погрузки / разгрузки во введении.</target>
        </trans-unit>
        <trans-unit id="73cd90e7e567fcfaa60abf0aba49564831915adf" translate="yes" xml:space="preserve">
          <source>If the edge would create a cycle in an &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; is returned. If &lt;code&gt;G&lt;/code&gt; already has an edge with value &lt;code&gt;E&lt;/code&gt; connecting a different pair of vertices, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; is returned. If either of &lt;code&gt;V1&lt;/code&gt; or &lt;code&gt;V2&lt;/code&gt; is not a vertex of digraph &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt;V&lt;code&gt;}}&lt;/code&gt; is returned, V = &lt;code&gt;V1&lt;/code&gt; or V = &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">Если ребро создаст цикл в &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt; , возвращается &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; . Если у &lt;code&gt;G&lt;/code&gt; уже есть ребро со значением &lt;code&gt;E&lt;/code&gt; , соединяющее другую пару вершин, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; . Если любой из &lt;code&gt;V1&lt;/code&gt; или &lt;code&gt;V2&lt;/code&gt; не является вершиной орграфа &lt;code&gt;G&lt;/code&gt; , возвращается &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt; V &lt;code&gt;}}&lt;/code&gt; , V = &lt;code&gt;V1&lt;/code&gt; или V = &lt;code&gt;V2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88548b0769c08599153c91bedffecba4076939a2" translate="yes" xml:space="preserve">
          <source>If the emulator detects an internal error (or runs out of memory), it, by default, generates both a crash dump and a core dump. The core dump is, however, not very useful as the content of process heaps is destroyed by the crash dump generation.</source>
          <target state="translated">Если эмулятор обнаруживает внутреннюю ошибку (или заканчивается память),то по умолчанию он генерирует как дамп падения,так и дамп ядра.Однако,дамп ядра не очень полезен,так как содержимое кучи процессов разрушается при генерации аварийного дампа.</target>
        </trans-unit>
        <trans-unit id="1c268e0a4f924dc7fcacea261eaf98d33a0b39dd" translate="yes" xml:space="preserve">
          <source>If the emulator needs to be restarted after upgrading or downgrading, that is, if the ERTS version differs between &lt;code&gt;Name.rel&lt;/code&gt; and &lt;code&gt;Name2.rel&lt;/code&gt;</source>
          <target state="translated">Если эмулятор необходимо перезапустить после обновления или понижения, то есть если версия ERTS отличается между &lt;code&gt;Name.rel&lt;/code&gt; и &lt;code&gt;Name2.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5cf3cf162417b51e0a5af24e5040b612349b1b" translate="yes" xml:space="preserve">
          <source>If the emulator needs to write a crash dump, the value of this variable is the filename of the crash dump file. If the variable is not set, the name of the crash dump file is &lt;code&gt;erl_crash.dump&lt;/code&gt; in the current directory.</source>
          <target state="translated">Если эмулятору необходимо записать аварийный дамп, значением этой переменной является имя файла аварийного дампа. Если переменная не задана, имя файла аварийного дампа - &lt;code&gt;erl_crash.dump&lt;/code&gt; в текущем каталоге.</target>
        </trans-unit>
        <trans-unit id="2eec4c147205e5216572281566e1e6a996fb672c" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt; dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c61683ad15fa177c304fbdf476f8b2479cdc64" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">Если эмулятор был построен с поддержкой &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt; , изменение количества планировщиков онлайн также может изменить количество грязных планировщиков ЦП в онлайн. Например, если 12 планировщиков и 6 планировщиков грязного ЦП находятся в режиме онлайн, а &lt;code&gt;system_flag/2&lt;/code&gt; используется для установки количества активных планировщиков на 6, то количество активных планировщиков ЦП также автоматически уменьшается вдвое, до 3. Точно так же количество активных планировщиков ЦП увеличивается пропорционально увеличению количества онлайн-планировщиков.</target>
        </trans-unit>
        <trans-unit id="53196a3c7142e79d1e176b567fb18778d22d10f3" translate="yes" xml:space="preserve">
          <source>If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9353bd702a35793ac18305b8482171f21007231" translate="yes" xml:space="preserve">
          <source>If the end of the pattern is reached, the match succeeds and you can retrieve the contents of the variable.</source>
          <target state="translated">Если конец детали достигнут,то совпадение будет успешным,и можно будет получить содержимое переменной.</target>
        </trans-unit>
        <trans-unit id="ec86b8e10359d9eb0c69eab5270c60f057cce319" translate="yes" xml:space="preserve">
          <source>If the engine is located in the OpenSSL/LibreSSL installation &lt;code&gt;engines&lt;/code&gt; directory.</source>
          <target state="translated">Если движок находится в каталоге &lt;code&gt;engines&lt;/code&gt; установки OpenSSL / LibreSSL .</target>
        </trans-unit>
        <trans-unit id="46c40e2b5cd9693ace2f62de74c9f71bc27ab4c5" translate="yes" xml:space="preserve">
          <source>If the entire log is successfully converted, the function will return &lt;code&gt;ok&lt;/code&gt;. If one of more entries fail to convert, the function will instead return &lt;code&gt;{ok, {NumOK, NumERR}}&lt;/code&gt;, where the counters indicate how many valid and erroneous entries where found. If instead &lt;code&gt;{error, Reason}&lt;/code&gt; is returned, the conversion encountered a fatal error and where either never done of aborted midway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17edef4a35e3cca0ca8935fe0f2de48f9e5dfe47" translate="yes" xml:space="preserve">
          <source>If the entry is a new subscriber, it will imply that the new subscriber process first will get one message for each already stored dictionary entry, before it and all old subscribers will get this particular entry. The collector process links to and then supervises the subscriber process. If the subscriber process dies it will imply that it gets unregistered as with a normal dict_delete/2.</source>
          <target state="translated">Если запись является новым абонентом,это будет означать,что новый абонент сначала получит по одному сообщению на каждую уже сохраненную запись словаря,а затем все старые абоненты получат эту конкретную запись.Процесс коллектора связывается с абонентским процессом,а затем контролирует его.Если процесс подписчика умрет,то это будет означать,что он получит незарегистрированную запись,как при обычном dict_delete/2.</target>
        </trans-unit>
        <trans-unit id="4d245a9827d109c394220e412fd90299a8b7ff0f" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs instead of a &lt;code&gt;case_clause&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a094e54489c949e55e10b1bfd099675a9945d8d2" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Если оценка &lt;code&gt;Exprs&lt;/code&gt; завершается успешно без исключения, шаблоны &lt;code&gt;Pattern&lt;/code&gt; последовательно сопоставляются с результатом так же, как и для выражения &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; , за исключением того, что если сопоставление не удается, возникает &lt;code&gt;try_clause&lt;/code&gt; выполнения try_clause .</target>
        </trans-unit>
        <trans-unit id="1729265d2a1b2d02d46f2b13db7a6628cfce7401" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt; add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631031b9e342940aba31e2236569e617b51e7128" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="translated">Если обработчик событий добавлен из-за вызова &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;InitArgs&lt;/code&gt; является аргументом &lt;code&gt;Args&lt;/code&gt; этих функций.</target>
        </trans-unit>
        <trans-unit id="72f67e0f506eeca69ed3305947843432edc7a69d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3160cb662d43645579ff66ccf206017473a57cb3" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="translated">Если обработчик событий удален из-за вызова &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;Arg&lt;/code&gt; является аргументом &lt;code&gt;Args&lt;/code&gt; этого вызова функции.</target>
        </trans-unit>
        <trans-unit id="89ab1aecc97fe6f0f9ffea8f0aa54544b441d79d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted later, the event manager sends a message &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; to the calling process. &lt;code&gt;Reason&lt;/code&gt; is one of the following:</source>
          <target state="translated">Если обработчик событий удаляется позже, диспетчер событий отправляет сообщение &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; вызывающему процессу. &lt;code&gt;Reason&lt;/code&gt; одна из следующих:</target>
        </trans-unit>
        <trans-unit id="b5a39103796e2c04d1e2ceb8b092ca0d507d8cca" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a4d7864917b404d52d14fae5596ac8786e5389" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если обработчик событий заменяет другой обработчик событий из-за вызова &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; , или из-за возвращаемого кортежа &lt;code&gt;swap&lt;/code&gt; из одной из других функций обратного вызова, &lt;code&gt;InitArgs&lt;/code&gt; представляет собой кортеж &lt;code&gt;{Args,Term}&lt;/code&gt; , где &lt;code&gt;Args&lt;/code&gt; - это аргумент, указанный в кортеже вызова / возврата функции, а &lt;code&gt;Term&lt;/code&gt; является результатом завершения старого обработчика событий, см. &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce21bfa638e6a6dac050034a055b97270608155" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. However, it detects this state and loses no records that are not overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd74a922c6e5b981bbc80b4da38fda2c75c0b1ea" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. It however detects this state and loses no records that are not overwritten.</source>
          <target state="translated">Если журнал событий настроен на автоматический &lt;code&gt;nteventlog&lt;/code&gt; , записи, которые поступили в журнал и были перезаписаны, когда nteventlog не был запущен, будут потеряны. Однако он обнаруживает это состояние и не теряет записи, которые не были перезаписаны.</target>
        </trans-unit>
        <trans-unit id="1781a9137364e9b0633c2b37fb076419c90678b9" translate="yes" xml:space="preserve">
          <source>If the event manager is part of a supervision tree, no stop function is needed. The event manager is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">Если диспетчер событий является частью дерева наблюдения, функция остановки не требуется. Диспетчер событий автоматически завершается его супервайзером. Как именно это делается, определяется &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; установленной в супервизоре.</target>
        </trans-unit>
        <trans-unit id="23a26a698f7576e3a5781ee1ace5ea565efded8a" translate="yes" xml:space="preserve">
          <source>If the event manager is successfully created, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the event manager. If a process with the specified &lt;code&gt;EventMgrName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">Если менеджер событий успешно создан, функция возвращает &lt;code&gt;{ok,Pid}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это pid менеджера событий. Если процесс с указанным &lt;code&gt;EventMgrName&lt;/code&gt; уже существует, функция возвращает &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; , где &lt;code&gt;Pid&lt;/code&gt; - это pid этого процесса.</target>
        </trans-unit>
        <trans-unit id="85c7349696150a1895889e8faf7c4713894d022f" translate="yes" xml:space="preserve">
          <source>If the exclusive decode function has, for example, the name &lt;code&gt;decode_exclusive&lt;/code&gt; and an ASN.1 encoded message &lt;code&gt;Bin&lt;/code&gt; is to be exclusive decoded, the call is as follows:</source>
          <target state="translated">Если функция эксклюзивного декодирования имеет, например, имя &lt;code&gt;decode_exclusive&lt;/code&gt; и &lt;code&gt;Bin&lt;/code&gt; сообщения, закодированного в ASN.1, должен быть эксклюзивно декодирован, вызов будет следующим:</target>
        </trans-unit>
        <trans-unit id="03f0f3b2eabafa60c9e9c721aa1cad9fcc5b78a3" translate="yes" xml:space="preserve">
          <source>If the failed test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">Если неудачный тестовый пример принадлежит к группе тестовых примеров, первым аргументом является кортеж &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; , в противном случае - только имя функции.</target>
        </trans-unit>
        <trans-unit id="ae5596ad95475cf2f268aa093acd0a50a12f5551" translate="yes" xml:space="preserve">
          <source>If the file contains source code (as in the example above), it is processed by the &lt;code&gt;epp&lt;/code&gt; preprocessor. This means that you, for example, can use predefined macros (such as &lt;code&gt;?MODULE&lt;/code&gt;) and include directives like the &lt;code&gt;-include_lib&lt;/code&gt; directive. For example, use</source>
          <target state="translated">Если файл содержит исходный код (как в примере выше), он обрабатывается препроцессором &lt;code&gt;epp&lt;/code&gt; . Это означает, что вы, например, можете использовать предопределенные макросы (такие как &lt;code&gt;?MODULE&lt;/code&gt; ) и включать такие директивы, как директива &lt;code&gt;-include_lib&lt;/code&gt; . Например, используйте</target>
        </trans-unit>
        <trans-unit id="09f7b5f0081b8333cb37ae76ae1513548332cd8c" translate="yes" xml:space="preserve">
          <source>If the file is opened in binary mode, the read bytes are returned in a binary, otherwise in a list.</source>
          <target state="translated">Если файл открыт в двоичном режиме,прочитанные байты возвращаются в двоичном,в противном случае-в списке.</target>
        </trans-unit>
        <trans-unit id="d43d376c036cd6704fab6602e0a821d2fca0f536" translate="yes" xml:space="preserve">
          <source>If the file is opened with &lt;code&gt;encoding&lt;/code&gt; set to something else than &lt;code&gt;latin1&lt;/code&gt;, each byte written can result in many bytes being written to the file, as the byte range 0..255 can represent anything between one and four bytes depending on value and UTF encoding type.</source>
          <target state="translated">Если файл открывается с &lt;code&gt;encoding&lt;/code&gt; &lt;code&gt;latin1&lt;/code&gt; от latin1 , каждый записанный байт может привести к тому, что в файл будет записано много байтов, поскольку диапазон байтов 0..255 может представлять что угодно от одного до четырех байтов в зависимости от значения и кодировки UTF. тип.</target>
        </trans-unit>
        <trans-unit id="3ff2942f4038fb71563badd19ea96ee04bc36590" translate="yes" xml:space="preserve">
          <source>If the file is read past &lt;code&gt;eof&lt;/code&gt;, only the remaining bytes are read and returned. If no bytes are read, &lt;code&gt;eof&lt;/code&gt; is returned.</source>
          <target state="translated">Если файл читается после &lt;code&gt;eof&lt;/code&gt; , считываются и возвращаются только оставшиеся байты. Если байты не прочитаны, возвращается &lt;code&gt;eof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0301143503899c06f595e73d4da8e12a605f082d" translate="yes" xml:space="preserve">
          <source>If the file is specified as an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;, no file is read or monitored in the future. This emulates the old behavior of not configuring the DNS client when the node is started in short name distributed mode.</source>
          <target state="translated">Если файл указан как пустая строка &lt;code&gt;&quot;&quot;&lt;/code&gt; , в будущем файл не будет прочитан и не будет отслеживаться. Это имитирует старое поведение, когда DNS-клиент не настраивался при запуске узла в распределенном режиме коротких имен.</target>
        </trans-unit>
        <trans-unit id="f524572ea2342154f69f71b644500e15cc9901dc" translate="yes" xml:space="preserve">
          <source>If the file server of this node is not a slave, the file was opened by the file server of this node (this implies that &lt;code&gt;Pid&lt;/code&gt; must be a local pid) and the file is not closed. &lt;code&gt;Filename&lt;/code&gt; is the filename in flat string format.</source>
          <target state="translated">Если файловый сервер этого узла не является подчиненным, файл был открыт файловым сервером этого узла (это означает, что &lt;code&gt;Pid&lt;/code&gt; должен быть локальным pid), и файл не закрывается. &lt;code&gt;Filename&lt;/code&gt; - это имя файла в формате плоской строки.</target>
        </trans-unit>
        <trans-unit id="19dad8b9ff6393c913546c9bff544a5e8d858493" translate="yes" xml:space="preserve">
          <source>If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a list. The list or binary is shorter than the number of bytes requested if end of file was reached.</source>
          <target state="translated">Если файл был открыт в двоичном режиме,прочитанные байты возвращаются в двоичном,в противном случае-в списке.Список или двоичный файл короче,чем количество запрашиваемых байтов,если был достигнут конец файла.</target>
        </trans-unit>
        <trans-unit id="ead416d9e5e17b9f14938d13eb799b54c7ee7032" translate="yes" xml:space="preserve">
          <source>If the file write fails (for example, &lt;code&gt;enospc&lt;/code&gt;), the command is aborted and &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; is returned. However, the file is &lt;strong&gt;not&lt;/strong&gt; removed.</source>
          <target state="translated">Если запись в файл не удалась (например, &lt;code&gt;enospc&lt;/code&gt; ), команда прерывается и &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; . Однако файл &lt;strong&gt;не&lt;/strong&gt; удаляется.</target>
        </trans-unit>
        <trans-unit id="3f0c09a69dc8ebf1e91578b9796f029369abc850" translate="yes" xml:space="preserve">
          <source>If the filename &lt;code&gt;File&lt;/code&gt; is absolute (possibly after variable substitution), the include file with that name is included. Otherwise, the specified file is searched for in the following directories, and in this order:</source>
          <target state="translated">Если имя файла &lt;code&gt;File&lt;/code&gt; является абсолютным (возможно, после подстановки переменных), включаемый файл с таким именем включается. В противном случае указанный файл ищется в следующих каталогах и в таком порядке:</target>
        </trans-unit>
        <trans-unit id="f6fdb5791718e9cf14d2a9c0a809646872e636fd" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, decide if the event is allowed or not.</source>
          <target state="translated">Если фильтр не соответствует, он возвращает &lt;code&gt;ignore&lt;/code&gt; , что означает, что другие фильтры или значение параметра конфигурации &lt;code&gt;filter_default&lt;/code&gt; решают, разрешено событие или нет.</target>
        </trans-unit>
        <trans-unit id="298fc01aae2302d31a30ab2828690b737a94df8b" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, will decide if the event is allowed or not.</source>
          <target state="translated">Если фильтр не соответствует, он возвращает &lt;code&gt;ignore&lt;/code&gt; , что означает, что другие фильтры или значение параметра конфигурации &lt;code&gt;filter_default&lt;/code&gt; будут решать, разрешено событие или нет.</target>
        </trans-unit>
        <trans-unit id="3e713bc836d6d924cbd200c2e55ce5f9136754b5" translate="yes" xml:space="preserve">
          <source>If the filter function returns &lt;code&gt;ignore&lt;/code&gt;, it means that it did not recognize the log event, and thus leaves to other filters to decide the event's destiny.</source>
          <target state="translated">Если функция фильтра возвращает &lt;code&gt;ignore&lt;/code&gt; , это означает, что она не распознала событие журнала и, таким образом, оставляет на усмотрение других фильтров решение судьбы события.</target>
        </trans-unit>
        <trans-unit id="957041343c23aa2d4654805ac48c48dc4fb915f8" translate="yes" xml:space="preserve">
          <source>If the filter has the form &lt;code&gt;{Key, RegExp, re}&lt;/code&gt;, the report must contain an element with key equal to &lt;code&gt;Key&lt;/code&gt; and the value must match the regular expression &lt;code&gt;RegExp&lt;/code&gt;.</source>
          <target state="translated">Если фильтр имеет форму &lt;code&gt;{Key, RegExp, re}&lt;/code&gt; , отчет должен содержать элемент с ключом, равным &lt;code&gt;Key&lt;/code&gt; , а значение должно соответствовать регулярному выражению &lt;code&gt;RegExp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e1184361ce4e087a6b4dd8211b45d80ed4f9e48" translate="yes" xml:space="preserve">
          <source>If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the log event is allowed. If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the log event is stopped.</source>
          <target state="translated">Если фильтр соответствует и &lt;code&gt;Action&lt;/code&gt; в &lt;code&gt;log&lt;/code&gt; , журнал событий допускается. Если фильтр соответствует и &lt;code&gt;Action&lt;/code&gt; является &lt;code&gt;stop&lt;/code&gt; , событие журнала прекращается.</target>
        </trans-unit>
        <trans-unit id="32e9da768719e8b90b1faba156fc380cf35dffea" translate="yes" xml:space="preserve">
          <source>If the final string is too long, it is truncated according to the value of configuration parameter &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если последняя строка слишком длинная, она обрезается в соответствии со значением параметра конфигурации &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42b76af1133577086d028a4fb0a1a30d07e3d9f8" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt; erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ebf0a745164970b389f3300cbccd27f4b3b5d3" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="translated">Если флаг установлен в &lt;code&gt;0&lt;/code&gt; , данные возвращаются в виде списка целых чисел. Либо используйте буфер по умолчанию, либо установите &lt;code&gt;*rbuf&lt;/code&gt; , чтобы указать на больший буфер, выделенный с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt; . Буфер автоматически освобождается после возврата &lt;code&gt;control&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c08f7138ffb7c0800eaee0ee64686780f8678ed" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt; erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt; erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt; erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdf06cbeca702cf9635bd5a2282dbe52c9f9489" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">Если установлен флаг &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; , возвращается двоичный файл. Небольшие двоичные файлы можно вернуть, записав необработанные данные в буфер по умолчанию. Двоичный файл также можно вернуть, установив &lt;code&gt;*rbuf&lt;/code&gt; для указания на двоичный файл, выделенный с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt; . Этот двоичный файл автоматически освобождается после возврата &lt;code&gt;control&lt;/code&gt; . Драйвер может сохранить двоичный файл для доступа &lt;strong&gt;только&lt;/strong&gt; для &lt;strong&gt;чтения&lt;/strong&gt; с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; , чтобы позже освободить его с помощью &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt; . Никогда не разрешается изменять двоичный файл после возврата &lt;code&gt;control&lt;/code&gt; . Если &lt;code&gt;*rbuf&lt;/code&gt; установлен в &lt;code&gt;NULL&lt;/code&gt; , возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="ba4d8831063581aeb6c792a1b032f97e23a799b0" translate="yes" xml:space="preserve">
          <source>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject:</source>
          <target state="translated">Если следующий образец применяется к строке,не начинающейся с &quot;а&quot; или &quot;b&quot;,то она обычно совпадает с пустой строкой в начале объекта:</target>
        </trans-unit>
        <trans-unit id="f145ecc5627d0896817e500b5d377db659310775" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt; check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2009a1faa40085a7c2fd996ec540bc12d65d8f07" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="translated">Если модуль форматирования экспортирует необязательную функцию обратного вызова &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt; , Logger вызывает эту функцию, когда информация средства форматирования установлена ​​или изменена, чтобы проверить правильность конфигурации средства форматирования.</target>
        </trans-unit>
        <trans-unit id="05f7a6a810b002e4a0681949501258c2a927f78c" translate="yes" xml:space="preserve">
          <source>If the fragment option is &lt;code&gt;true&lt;/code&gt;, the URI fragment is returned as part of the parsing result, otherwise it is ignored.</source>
          <target state="translated">Если параметр фрагмента &lt;code&gt;true&lt;/code&gt; , фрагмент URI возвращается как часть результата синтаксического анализа, в противном случае он игнорируется.</target>
        </trans-unit>
        <trans-unit id="a9f39219b3544f3ad6a57e7c4b45e2e83b08a49c" translate="yes" xml:space="preserve">
          <source>If the fully connected network is not set up properly, try first to increase the value of &lt;code&gt;net_setuptime&lt;/code&gt;.</source>
          <target state="translated">Если полностью подключенная сеть не настроена должным образом, попробуйте сначала увеличить значение &lt;code&gt;net_setuptime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9be0c3ab255377067e7c9ca15639a8fa64c8dbb" translate="yes" xml:space="preserve">
          <source>If the fun/3 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="translated">Если используется fun/3,то он вызывается,когда происходит фактическая аутентификация,и поэтому может возвращать динамические данные,такие как время,удаленный ip и т.д.</target>
        </trans-unit>
        <trans-unit id="1a6e0071d7a3ba398410b3a04cc87132cfab9e23" translate="yes" xml:space="preserve">
          <source>If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10d9917bf561ed6546055b4ad6ae668ede9a486" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;mnesia:table_info/2&lt;/code&gt; is started in the activity context of module &lt;code&gt;mnesia_frag&lt;/code&gt;, information of several new items can be obtained:</source>
          <target state="translated">Если функция &lt;code&gt;mnesia:table_info/2&lt;/code&gt; запущена в контексте активности модуля &lt;code&gt;mnesia_frag&lt;/code&gt; , можно получить информацию о нескольких новых элементах:</target>
        </trans-unit>
        <trans-unit id="b7b2e6d233f123be817d60a836703d289792c0af" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;print_name/1&lt;/code&gt;, and so on, had been interface functions, the situation would have been different, as you do not want the user of the interface to know about the internal data representation.</source>
          <target state="translated">Если бы функция &lt;code&gt;print_name/1&lt;/code&gt; и т. Д. Были функциями интерфейса, ситуация была бы другой, поскольку вы не хотите, чтобы пользователь интерфейса знал о внутреннем представлении данных.</target>
        </trans-unit>
        <trans-unit id="ac91618962c7d06d3c9f00caac895bd89a410ca3" translate="yes" xml:space="preserve">
          <source>If the function is called, it will be called again with &lt;code&gt;undo&lt;/code&gt;, or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">Если функция вызывается, она будет вызвана снова с &lt;code&gt;undo&lt;/code&gt; или с параметром &lt;code&gt;set&lt;/code&gt; в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="40c262c2c2a844d0cf26a7433449f15feea3fd0e" translate="yes" xml:space="preserve">
          <source>If the function is found, the function clauses are scanned sequentially until a clause is found that fulfills both of the following two conditions:</source>
          <target state="translated">Если функция найдена,клаузулы функции сканируются последовательно до тех пор,пока не будет найдено клаузула,удовлетворяющее обоим из следующих двух условий:</target>
        </trans-unit>
        <trans-unit id="c5c83cab902e2b61262a72c526eeaa77228c4460" translate="yes" xml:space="preserve">
          <source>If the function is rewritten as follows, the compiler is free to rearrange the clauses:</source>
          <target state="translated">Если функция переписана следующим образом,компилятор может свободно переставлять пункты:</target>
        </trans-unit>
        <trans-unit id="b63119293c0f8660be248a19b2479210b58e3c5a" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;ignore&lt;/code&gt;, then it is assumed that either:</source>
          <target state="translated">Если функция возвращает &lt;code&gt;ignore&lt;/code&gt; , то предполагается, что либо:</target>
        </trans-unit>
        <trans-unit id="d3d840a1e8e533a047b65414d5bcef0d60c4bcbd" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{cancel, Reason}&lt;/code&gt;, this means the transport module decided not to send the message. This is &lt;strong&gt;not&lt;/strong&gt; an error. No error messages will be issued and no error counters incremented. What actions this will result in depends on what kind of message was sent.</source>
          <target state="translated">Если функция возвращает &lt;code&gt;{cancel, Reason}&lt;/code&gt; , это означает, что транспортный модуль решил не отправлять сообщение. Это &lt;strong&gt;не&lt;/strong&gt; ошибка. Сообщения об ошибках не выдаются, и счетчики ошибок не увеличиваются. К каким действиям это приведет, зависит от того, какое сообщение было отправлено.</target>
        </trans-unit>
        <trans-unit id="7fa5ac3ae4df99fa5b9b2dd8db96506aecf3fefc" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release.</source>
          <target state="translated">Если функция возвращает &lt;code&gt;{error,Reason}&lt;/code&gt; , текущее обновление завершается ошибкой и выполняется откат к старой версии.</target>
        </trans-unit>
        <trans-unit id="cace8ed5fbcae8411e61d141c38b3af395942b38" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; can not be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="translated">Если функция возвращает &lt;code&gt;Reason&lt;/code&gt; сбоя , текущее обновление завершается ошибкой и выполняется откат к старому выпуску. Обратите внимание , что &lt;code&gt;Reason&lt;/code&gt; не может быть &lt;code&gt;{ok,_,_}&lt;/code&gt; кортеж , так что будет рассматриваться как &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; кортеж, и что соответствующий кортеж &lt;code&gt;{ok,_}&lt;/code&gt; является также недействительным отказ &lt;code&gt;Reason&lt;/code&gt; . Рекомендуется использовать атом в качестве &lt;code&gt;Reason&lt;/code&gt; поскольку он будет заключен в кортеж &lt;code&gt;{error,Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c37aef2f6cca5a5ce8aa9a711a7c69aab7ee274a" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; cannot be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b279a0456aa090aac1cc8d9973e0efdd61b891" translate="yes" xml:space="preserve">
          <source>If the function returns anything else, the test case is considered successful. The return value always gets printed in the test case log file.</source>
          <target state="translated">Если функция возвращает что-либо еще,тестовый случай считается удачным.Возвращаемое значение всегда выводится в лог-файл тестового случая.</target>
        </trans-unit>
        <trans-unit id="f7a01fb7804d1dc8b9d59f7e2487cb33130c4689" translate="yes" xml:space="preserve">
          <source>If the functionality of a long-running NIF can be split so that its work can be achieved through a series of shorter NIF calls, the application has two options:</source>
          <target state="translated">Если функциональность долговременного NIF может быть разделена таким образом,что его работа может быть достигнута с помощью серии более коротких вызовов NIF,то у приложения есть два варианта:</target>
        </trans-unit>
        <trans-unit id="ba5aec2652bfb4fd0698f0092b5faec8c5e7749c" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;ebin&lt;/code&gt;, modules (BEAM files) are searched for in that directory, otherwise modules are searched for in the given directory.</source>
          <target state="translated">Если в данном каталоге есть подкаталог с именем &lt;code&gt;ebin&lt;/code&gt; , модули (файлы BEAM) ищутся в этом каталоге, в противном случае модули ищутся в данном каталоге.</target>
        </trans-unit>
        <trans-unit id="206b9b6e0e97d510493a5ac088ad8e22427aae29" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;lib&lt;/code&gt;, the directories in that directory are assumed to be application directories, otherwise all subdirectories of the given directory are assumed to be application directories. If there are several versions of some application, the one with the highest version is chosen.</source>
          <target state="translated">Если в данном каталоге есть подкаталог с именем &lt;code&gt;lib&lt;/code&gt; , каталоги в этом каталоге считаются каталогами приложений, в противном случае все подкаталоги данного каталога считаются каталогами приложений. Если существует несколько версий какого-либо приложения, выбирается версия с самой высокой версией.</target>
        </trans-unit>
        <trans-unit id="33fb4bc732c4bac52e2f3ecc8dc02b6458e5f64a" translate="yes" xml:space="preserve">
          <source>If the global name server fails to connect nodes (&lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; in the example), a warning event is sent to the error logger. The presence of such an event does not exclude the nodes to connect later (you can, for example, try command &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; in the Erlang shell), but it indicates a network problem.</source>
          <target state="translated">Если глобальному серверу имен не удается соединить узлы ( &lt;code&gt;N1&lt;/code&gt; и &lt;code&gt;N3&lt;/code&gt; в примере), в регистратор ошибок отправляется предупреждение. Наличие такого события не исключает, что узлы подключатся позже (вы можете, например, попробовать команду &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; в оболочке Erlang), но это указывает на сетевую проблему.</target>
        </trans-unit>
        <trans-unit id="90420c92850a1634589e73fa3152ae2df519947e" translate="yes" xml:space="preserve">
          <source>If the guard test &lt;code&gt;is_integer(Int)&lt;/code&gt; succeeds, the fourth clause is executed.</source>
          <target state="translated">Если проверка &lt;code&gt;is_integer(Int)&lt;/code&gt; завершается успешно, выполняется четвертое предложение.</target>
        </trans-unit>
        <trans-unit id="51156ed0f0b60bdec0db2a3c5c342e77e9337761" translate="yes" xml:space="preserve">
          <source>If the guard test fails, the input value is compared to &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, and the appropriate clause is selected. (There is a &lt;code&gt;function_clause&lt;/code&gt; exception if none of the values matched.)</source>
          <target state="translated">Если защитный тест не проходит, входное значение сравнивается с &lt;code&gt;four&lt;/code&gt; , &lt;code&gt;five&lt;/code&gt; и &lt;code&gt;six&lt;/code&gt; , и выбирается соответствующий пункт. ( Если ни одно из значений не совпадает, возникает исключение &lt;code&gt;function_clause&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="042ae23e884f62c0355d18895948d09799091a5c" translate="yes" xml:space="preserve">
          <source>If the handler is meant to replace the default handler, the Kernel's default handler have to be disabled before the new handler is added. A &lt;code&gt;sys.config&lt;/code&gt; file that disables the Kernel handler and adds a custom handler could look like this:</source>
          <target state="translated">Если обработчик предназначен для замены обработчика по умолчанию, обработчик ядра по умолчанию должен быть отключен перед добавлением нового обработчика. &lt;code&gt;sys.config&lt;/code&gt; файл , который отключает обработчик ядра и добавляет пользовательский обработчик может выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="65f1827df55837b13a3b7ed59d4d8ea4a1983d32" translate="yes" xml:space="preserve">
          <source>If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value &lt;code&gt;infinity&lt;/code&gt; prevents restarts.</source>
          <target state="translated">Если обработчик завершен, он автоматически перезапускается после задержки, указанной в миллисекундах. Значение &lt;code&gt;infinity&lt;/code&gt; предотвращает перезапуск.</target>
        </trans-unit>
        <trans-unit id="b7ef0ec4d5b98a48302f9d89b544d31dce7e98f5" translate="yes" xml:space="preserve">
          <source>If the handler process is terminated because of overload, it prints information about it in the log. It also prints information about when a restart has taken place, and the handler is back in action.</source>
          <target state="translated">Если обработчик завершает процесс из-за перегрузки,он печатает информацию о нем в лог.Также он печатает информацию о том,когда произошел перезапуск,и обработчик снова в действии.</target>
        </trans-unit>
        <trans-unit id="71ca4e1b2a57423c539bf11275ee92c1598c8e04" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to listen on.</source>
          <target state="translated">Если у хоста много сетевых интерфейсов,эта опция определяет,какой из них прослушивать.</target>
        </trans-unit>
        <trans-unit id="5938c2bcb45adfa6db096780d07c1f69ca15570f" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to use.</source>
          <target state="translated">Если у хоста много сетевых интерфейсов,то эта опция определяет,какой из них использовать.</target>
        </trans-unit>
        <trans-unit id="7a3654ae9fae9da43a3b1501da91842a28524e6b" translate="yes" xml:space="preserve">
          <source>If the included application itself contains included applications, instead the &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; option must be included.</source>
          <target state="translated">Если само включенное приложение содержит включенные приложения, вместо этого должен быть включен параметр &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93280124390abf78f821c80eb86f0bf50631ec9d" translate="yes" xml:space="preserve">
          <source>If the initial call is to one of the system-defined behaviors such as &lt;code&gt;gen_server&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;, it is translated to more useful information. If a &lt;code&gt;gen_server&lt;/code&gt; is spawned, the returned &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Function&lt;/code&gt; is &lt;code&gt;init&lt;/code&gt; (the function that initiates the new server).</source>
          <target state="translated">Если первоначальный вызов к одной из определенной системы поведения , такие как &lt;code&gt;gen_server&lt;/code&gt; или &lt;code&gt;gen_event&lt;/code&gt; , переводятся на более полезную информацию. Если создается &lt;code&gt;gen_server&lt;/code&gt; , возвращаемый &lt;code&gt;Module&lt;/code&gt; - это имя модуля обратного вызова, а &lt;code&gt;Function&lt;/code&gt; - это &lt;code&gt;init&lt;/code&gt; (функция, которая инициирует новый сервер).</target>
        </trans-unit>
        <trans-unit id="e36a8cae40a2ccda598cbf83afe268a5c720aa0e" translate="yes" xml:space="preserve">
          <source>If the initial encode of the outgoing request fails, then the request process fails and &lt;code&gt;{error,encode}&lt;/code&gt; is returned.</source>
          <target state="translated">Если первоначальное кодирование исходящего запроса не удается, то процесс запроса не выполняется и возвращается &lt;code&gt;{error,encode}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="512a1cbc51d5459f85caaea2fd4bfade04f37668" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">Если инициализация не удалась, функция должна вернуть &lt;code&gt;{error,Error}&lt;/code&gt; , где &lt;code&gt;Error&lt;/code&gt; - любой термин, или &lt;code&gt;ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4efffcc1b527bd1b225e810cb600a2ae77401619" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{stop,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">Если инициализация не удалась, функция должна вернуть &lt;code&gt;{stop,Reason}&lt;/code&gt; , где &lt;code&gt;Reason&lt;/code&gt; - любой термин, или &lt;code&gt;ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9346621e797dd1360944a672ab82ead28612c984" translate="yes" xml:space="preserve">
          <source>If the initialization is successful, the function is to return &lt;code&gt;{ok,State}&lt;/code&gt;, &lt;code&gt;{ok,State,Timeout}&lt;/code&gt;, or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">Если инициализация прошла успешно, функция должна вернуть &lt;code&gt;{ok,State}&lt;/code&gt; , &lt;code&gt;{ok,State,Timeout}&lt;/code&gt; или &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; , где &lt;code&gt;State&lt;/code&gt; - это внутреннее состояние процесса &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc28d6116f22c2a3f33906970ce46ac4053da35d" translate="yes" xml:space="preserve">
          <source>If the input encoding is not UTF-8, an error tuple is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddc615bd88d8608ab31b9841323633dc12870aa" translate="yes" xml:space="preserve">
          <source>If the installation fails, the system can be rebooted. The old release version is then automatically used.</source>
          <target state="translated">В случае сбоя установки система может быть перезагружена.В этом случае автоматически используется старая версия релиза.</target>
        </trans-unit>
        <trans-unit id="c0e9d4940ae270a2841d572606f563a099b85e09" translate="yes" xml:space="preserve">
          <source>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</source>
          <target state="translated">Если установка прошла успешно,новая версия становится версией по умолчанию,которая будет использоваться в случае перезагрузки системы.</target>
        </trans-unit>
        <trans-unit id="08dbb0e86d47275a0a4e636be8892780b15448e3" translate="yes" xml:space="preserve">
          <source>If the instruction appears after instruction &lt;code&gt;point_of_no_return&lt;/code&gt; and the function call fails, the system is restarted.</source>
          <target state="translated">Если инструкция появляется после инструкции &lt;code&gt;point_of_no_return&lt;/code&gt; и вызов функции завершается неудачно, система перезапускается.</target>
        </trans-unit>
        <trans-unit id="efab2c6cbaff99e6149cda9413164011c49b633d" translate="yes" xml:space="preserve">
          <source>If the instruction appears before instruction &lt;code&gt;point_of_no_return&lt;/code&gt;, a failure is caught. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; then returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt;, unless &lt;code&gt;{error,Error}&lt;/code&gt; is thrown or returned. Then it returns &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">Если инструкция появляется перед инструкцией &lt;code&gt;point_of_no_return&lt;/code&gt; , обнаруживается сбой. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; затем возвращает &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; , если только &lt;code&gt;{error,Error}&lt;/code&gt; не выбрасывается или не возвращается. Затем он возвращает &lt;code&gt;{error,Error}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6accd78db997b4f0cc8c3eb17cc0cfe9969dd581" translate="yes" xml:space="preserve">
          <source>If the instrumentation functions communicate with UNIX processes, it might be a good idea to use a special sub-agent. This sub-agent sends the SNMP request to the other process in one packet in order to minimize context switches. For example, if a whole MIB is implemented on the C level in UNIX, but you still want to use the Erlang SNMP tool, then you may have one special sub-agent, which sends the variables in the request as a single operation down to C.</source>
          <target state="translated">Если приборные функции взаимодействуют с процессами UNIX,то,возможно,было бы неплохо использовать специальный субагент.Этот субагент посылает запрос SNMP другому процессу в одном пакете,чтобы свести к минимуму использование контекстных переключателей.Например,если весь MIB реализован на уровне C в UNIX,но вы все еще хотите использовать SNMP-инструмент Erlang,то у вас может быть один специальный субагент,который посылает переменные в запросе как одну операцию вплоть до C.</target>
        </trans-unit>
        <trans-unit id="6073ddc2f6ff51455fef10943643ff33d4a41b31" translate="yes" xml:space="preserve">
          <source>If the key attribute is bound in a pattern, the match operation is efficient. However, if the key attribute in a pattern is given as &lt;code&gt;'_'&lt;/code&gt; or &lt;code&gt;'$1'&lt;/code&gt;, the whole &lt;code&gt;employee&lt;/code&gt; table must be searched for records that match. Hence if the table is large, this can become a time-consuming operation, but it can be remedied with indexes (see &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt;) if the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Если ключевой атрибут привязан к шаблону, операция сопоставления эффективна. Однако, если ключевой атрибут в шаблоне задан как &lt;code&gt;'_'&lt;/code&gt; или &lt;code&gt;'$1'&lt;/code&gt; , необходимо искать соответствующие записи во всей таблице &lt;code&gt;employee&lt;/code&gt; . Следовательно, если таблица большая, это может занять много времени, но ее можно исправить с помощью индексов (см. &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt; ), если используется функция &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702da889833ee1dc6797c2ff9a6559f2d21f93ff" translate="yes" xml:space="preserve">
          <source>If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large.</source>
          <target state="translated">Если в шаблоне указана клавиша,то совпадение очень эффективно.Если ключ не указан,то есть,если это переменная или символ подчеркивания,то необходимо искать всю таблицу.Время поиска может быть существенным,если таблица очень большая.</target>
        </trans-unit>
        <trans-unit id="006f97d543b8ad5e428fa64fac1606142a9e3339" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to all objects of the table with the correct key(s). If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always handled at the same time, which implies that the match specification can be applied to more than N objects.</source>
          <target state="translated">Если keypos'th элемент &lt;code&gt;MatchSpec&lt;/code&gt; привязан, спецификация соответствия применяется ко всем объектам таблицы с правильным ключом (ключами). Если элемент &lt;code&gt;MatchSpec&lt;/code&gt; не связан , спецификация соответствия применяется ко всем объектам таблицы, &lt;code&gt;N&lt;/code&gt; объектам за раз, пока не будет найден хотя бы один объект или пока не будет достигнут конец таблицы. Значение по умолчанию, обозначенное присвоением &lt;code&gt;N&lt;/code&gt; значения по &lt;code&gt;default&lt;/code&gt; , позволяет количеству объектов варьироваться в зависимости от размеров объектов. Все объекты с одним и тем же ключом всегда обрабатываются одновременно, что означает, что спецификация соответствия может применяться к более чем N объектам.</target>
        </trans-unit>
        <trans-unit id="5b16233e004fe373963364905dc9a2ad762556f0" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">Если элемент &lt;code&gt;MatchSpec&lt;/code&gt; привязан, спецификация соответствия применяется только к объектам с правильным ключом (ключами).</target>
        </trans-unit>
        <trans-unit id="f90ff4fedc7cf136ced2894c42e307fbd5a5c73b" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">Если элемент &lt;code&gt;MatchSpec&lt;/code&gt; не привязан, спецификация соответствия применяется ко всем объектам таблицы. Если элемент keypos'th связан, спецификация соответствия применяется только к объектам с правильным ключом (ключами).</target>
        </trans-unit>
        <trans-unit id="c802fc2a3fde97f62fdbabfc7b66189e18b5dfc7" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All matching objects with the same key are always returned in the same reply, which implies that more than N objects can sometimes be returned.</source>
          <target state="translated">Если элемент keypos'th &lt;code&gt;Pattern&lt;/code&gt; привязан, все объекты таблицы совпадают. Если элемент keypos'th не связан, сопоставляются все объекты таблицы, по &lt;code&gt;N&lt;/code&gt; объектов за раз, пока не будет найден хотя бы один объект или не будет достигнут конец таблицы. Значение по умолчанию, обозначенное присвоением &lt;code&gt;N&lt;/code&gt; значения по &lt;code&gt;default&lt;/code&gt; , позволяет количеству объектов варьироваться в зависимости от размеров объектов. Все совпадающие объекты с одним и тем же ключом всегда возвращаются в одном и том же ответе, что означает, что иногда может быть возвращено более N объектов.</target>
        </trans-unit>
        <trans-unit id="ee8399b71f2614d1c169eead97f1d70700fb4b6e" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always matched at the same time, which implies that more than N objects can sometimes be matched.</source>
          <target state="translated">Если элемент keypos'th &lt;code&gt;Pattern&lt;/code&gt; привязан, все объекты таблицы совпадают. Если элемент keypos'th не связан, сопоставляются все объекты таблицы, по &lt;code&gt;N&lt;/code&gt; объектов за раз, пока не будет найден хотя бы один объект или не будет достигнут конец таблицы. Значение по умолчанию, обозначенное присвоением &lt;code&gt;N&lt;/code&gt; значения по &lt;code&gt;default&lt;/code&gt; , позволяет количеству объектов варьироваться в зависимости от размеров объектов. Все объекты с одним и тем же ключом всегда сопоставляются одновременно, что означает, что иногда может быть сопоставлено более N объектов.</target>
        </trans-unit>
        <trans-unit id="81cd44a63c897e4a4fbbf303d633ae129d55b04f" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">Если элемент keypos'th &lt;code&gt;Pattern&lt;/code&gt; привязан, сопоставляются только объекты с правильным ключом.</target>
        </trans-unit>
        <trans-unit id="519fdb3cbbeb8df2c304203d27f11912d501b21d" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is unbound, all table objects are matched. If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">Если элемент keypos'th &lt;code&gt;Pattern&lt;/code&gt; не связан , все объекты таблицы совпадают. Если элемент keypos'th &lt;code&gt;Pattern&lt;/code&gt; привязан, сопоставляются только объекты с правильным ключом.</target>
        </trans-unit>
        <trans-unit id="56e84a693998be360a017f2de3532689d94a7f87" translate="yes" xml:space="preserve">
          <source>If the last expression of a function body is a function call, a &lt;strong&gt;tail recursive&lt;/strong&gt; call is done. This is to ensure that no system resources, for example, call stack, are consumed. This means that an infinite loop can be done if it uses tail-recursive calls.</source>
          <target state="translated">Если последнее выражение тела функции является вызовом функции, выполняется &lt;strong&gt;хвостовой рекурсивный&lt;/strong&gt; вызов. Это необходимо для обеспечения того, чтобы системные ресурсы, например стек вызовов, не использовались. Это означает, что бесконечный цикл может быть выполнен, если он использует хвостовые рекурсивные вызовы.</target>
        </trans-unit>
        <trans-unit id="9ae06ba70f228c8b154f39f0df23503609bcb3bd" translate="yes" xml:space="preserve">
          <source>If the length of the message queue grows larger than this threshold, a flush (delete) operation takes place. To flush events, the handler discards the messages in the message queue by receiving them in a loop without logging. Client processes waiting for a response from a synchronous log request receive a reply from the handler indicating that the request is dropped. The handler process increases its priority during the flush loop to make sure that no new events are received during the operation. Notice that after the flush operation is performed, the handler prints information in the log about how many events have been deleted.</source>
          <target state="translated">Если длина очереди сообщений становится больше этого порога,то происходит операция промывки (удаления).Чтобы смыть события,обработчик отбрасывает сообщения в очереди сообщений,получая их в цикле без протоколирования.Клиентские процессы,ожидающие ответа от синхронного лог-запроса,получают от обработчика ответ о том,что запрос сброшен.Процесс-обработчик увеличивает свой приоритет во время цикла флеша,чтобы убедиться,что во время выполнения операции не будет получено новых событий.Обратите внимание,что после выполнения операции флеш обработчик выводит в журнал информацию о том,сколько событий было удалено.</target>
        </trans-unit>
        <trans-unit id="d10dfdc12d1915667ccceb0a8869e7352174a1a5" translate="yes" xml:space="preserve">
          <source>If the level for &lt;code&gt;mymodule&lt;/code&gt; is now set to &lt;code&gt;debug&lt;/code&gt;, then debug events from this module will be logged by the handler &lt;code&gt;h2&lt;/code&gt;, but not by handler &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">Если уровень для &lt;code&gt;mymodule&lt;/code&gt; теперь установлен на &lt;code&gt;debug&lt;/code&gt; , то события отладки из этого модуля будут регистрироваться обработчиком &lt;code&gt;h2&lt;/code&gt; , но не обработчиком &lt;code&gt;h1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57aa00c976a435bf8bda5a05ad6230ef4e15342c" translate="yes" xml:space="preserve">
          <source>If the library path is set to &lt;code&gt;code_path&lt;/code&gt;, the set of library modules is not determined, and the &lt;code&gt;info&lt;/code&gt; functions will return empty lists of library modules.</source>
          <target state="translated">Если для пути к библиотеке задано значение &lt;code&gt;code_path&lt;/code&gt; , набор библиотечных модулей не определяется, и &lt;code&gt;info&lt;/code&gt; функции будут возвращать пустые списки библиотечных модулей.</target>
        </trans-unit>
        <trans-unit id="5a12290de86cdc8197c1cbb41227356d8ad7a7f4" translate="yes" xml:space="preserve">
          <source>If the list contains more than one object with &lt;strong&gt;matching&lt;/strong&gt; keys and the table type is &lt;code&gt;set&lt;/code&gt;, one is inserted, which one is not defined. The same holds for table type &lt;code&gt;ordered_set&lt;/code&gt; if the keys &lt;strong&gt;compare equal&lt;/strong&gt;.</source>
          <target state="translated">Если список содержит более одного объекта с &lt;strong&gt;совпадающими&lt;/strong&gt; ключами и &lt;code&gt;set&lt;/code&gt; тип таблицы , вставляется один, а какой не определен. То же самое верно и для типа таблицы &lt;code&gt;ordered_set&lt;/code&gt; если ключи &lt;strong&gt;сравниваются одинаково&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="306fdef74e5ed0763cd6967950f14b6cd849bc3e" translate="yes" xml:space="preserve">
          <source>If the list of applications contains core applications, i.e &lt;code&gt;erts&lt;/code&gt;, &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt; or &lt;code&gt;sasl&lt;/code&gt;, the &lt;code&gt;Install&lt;/code&gt; script in the patched Erlang/OTP installation must be rerun.</source>
          <target state="translated">Если список приложений содержит основные приложения, то есть &lt;code&gt;erts&lt;/code&gt; , &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; или &lt;code&gt;sasl&lt;/code&gt; , сценарий &lt;code&gt;Install&lt;/code&gt; в исправленной установке Erlang / OTP необходимо запустить повторно.</target>
        </trans-unit>
        <trans-unit id="e5dc7d4fb91d3eb052a864414f12051609f1bc34" translate="yes" xml:space="preserve">
          <source>If the local implementation of Erlang defines &lt;code&gt;char()&lt;/code&gt; as a subset of &lt;code&gt;integer()&lt;/code&gt;, then &lt;code&gt;is_c_int(Node)&lt;/code&gt; will also yield &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acd485e36998d865f417532aa218ed4f2b0d80e" translate="yes" xml:space="preserve">
          <source>If the local node is part of a global group, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;synced&lt;/code&gt;. If no global groups are defined, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;no_conf&lt;/code&gt;.</source>
          <target state="translated">Если локальный узел является частью глобальной группы, &lt;code&gt;State&lt;/code&gt; равно &lt;code&gt;synced&lt;/code&gt; . Если глобальные группы не определены, &lt;code&gt;State&lt;/code&gt; равно &lt;code&gt;no_conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3dc78cf933189665aca88d0f65ce3644c34d9ac" translate="yes" xml:space="preserve">
          <source>If the log event is returned, the next filter function is called with the returned value as the first argument. That is, if a filter function modifies the log event, the next filter function receives the modified event. The value returned from the last filter function is the value that the handler callback receives.</source>
          <target state="translated">Если возвращается событие журнала,то вызывается следующая функция фильтрации с возвращаемым значением в качестве первого аргумента.То есть,если функция фильтрации изменяет событие журнала,то функция следующего фильтра получает измененное событие.Значение,возвращаемое функцией последнего фильтра,является значением,которое обработчик получает обратно.</target>
        </trans-unit>
        <trans-unit id="d41baef54ef4b512298e69bbec24ae875c8c68a0" translate="yes" xml:space="preserve">
          <source>If the log is blocked by the closing process, the log is also unblocked.</source>
          <target state="translated">Если журнал блокируется в процессе закрытия,он также разблокируется.</target>
        </trans-unit>
        <trans-unit id="8605585ed728deb58354312d2da402db9d75ef1c" translate="yes" xml:space="preserve">
          <source>If the log is local on the current node, &lt;code&gt;Dist&lt;/code&gt; has the value &lt;code&gt;local&lt;/code&gt;, otherwise all nodes where the log is distributed are returned as a list.</source>
          <target state="translated">Если журнал является локальным на текущем узле, &lt;code&gt;Dist&lt;/code&gt; имеет значение &lt;code&gt;local&lt;/code&gt; , в противном случае все узлы, на которых распространяется журнал, возвращаются в виде списка.</target>
        </trans-unit>
        <trans-unit id="b9bd861272d3ff7a5522d24a3e8060f05d2cf0e7" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments, or directly to a string. See the type definition of &lt;code&gt;&lt;a href=&quot;#type-report_cb&quot;&gt;report_cb()&lt;/a&gt;&lt;/code&gt;, and section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafa7b7f2609edae55f58fdb8dad531885491f7e" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="translated">Если сообщение журнала указано как &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt; , ключ &lt;code&gt;report_cb&lt;/code&gt; может быть связан с забавой (обратный вызов отчета), которая преобразует отчет в строку формата и аргументы. См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; в Руководстве пользователя для получения дополнительной информации об обратных вызовах отчетов.</target>
        </trans-unit>
        <trans-unit id="de16ab6d2dd843eaf98a56613e46e210c0e2c90f" translate="yes" xml:space="preserve">
          <source>If the log size is decreased, for example, to save space, function &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; can be used to force the log to wrap.</source>
          <target state="translated">Если размер журнала уменьшен, например, для экономии места, функция &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; может использоваться для принудительного переноса журнала.</target>
        </trans-unit>
        <trans-unit id="720cb0ae706744e4ee9df32b00d37adc564581fe" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined before the &lt;code&gt;merl.hrl&lt;/code&gt; header file is included, the parse transform used by Merl will be disabled, and in that case, the match expressions &lt;code&gt;?Q(...) = ...&lt;/code&gt;, case switches using &lt;code&gt;?Q(...)&lt;/code&gt; patterns, and automatic metavariables like &lt;code&gt;_@Tuple&lt;/code&gt; cannot be used in your code, but the Merl macros and functions still work. To do metavariable substitution, you need to use the &lt;code&gt;?Q(Text, Map)&lt;/code&gt; macro, e.g.:</source>
          <target state="translated">Если макрос &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; определен до &lt;code&gt;merl.hrl&lt;/code&gt; файла заголовка merl.hrl , преобразование синтаксического анализа, используемое Merl, будет отключено, и в этом случае выражения соответствия &lt;code&gt;?Q(...) = ...&lt;/code&gt; , переключатели регистра используют &lt;code&gt;?Q(...)&lt;/code&gt; Шаблоны Q (...) и автоматические метапеременные, такие как &lt;code&gt;_@Tuple&lt;/code&gt; нельзя использовать в вашем коде, но макросы и функции Merl по-прежнему работают. Чтобы выполнить замену метапеременной, вам необходимо использовать макрос &lt;code&gt;?Q(Text, Map)&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="2f7a0ebf63b23efbe71cc89202b72b358a0f129b" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NOASSERT&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect when testing is also disabled; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">Если макрос &lt;code&gt;NOASSERT&lt;/code&gt; определен до включения файла заголовка EUnit, эти макросы не действуют, когда тестирование также отключено; подробности см. в разделе &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="146cb0ce4e92421175ea3746cf274e2455137df9" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NODEBUG&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">Если макрос &lt;code&gt;NODEBUG&lt;/code&gt; определен до включения файла заголовка EUnit, эти макросы не действуют; подробности см. в разделе &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b5a901ceceb4e69c701bf0dc03c50b6bae11f7b" translate="yes" xml:space="preserve">
          <source>If the manager is not configured to use any particular transport domain, the behaviour &lt;code&gt;handle_agent/4&lt;/code&gt; will for backwards copmpatibility reasons be called with the old &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments</source>
          <target state="translated">Если диспетчер не настроен на использование какого-либо конкретного транспортного домена, поведение &lt;code&gt;handle_agent/4&lt;/code&gt; будет вызываться по причинам обратной совместимости со старыми аргументами &lt;code&gt;IpAddr&lt;/code&gt; и &lt;code&gt;PortNumber&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6efb33521a71965325da2bbd03e23ab8ae58659" translate="yes" xml:space="preserve">
          <source>If the manager tries to set the same variable many times in the same PDU, the agent is free to improvise. There is no definition which determines if the instrumentation will be called once or twice. If called once only, there is no definition that determines which of the new values is going to be supplied.</source>
          <target state="translated">Если менеджер пытается установить одну и ту же переменную много раз в одном и том же PDU,агент может импровизировать.Нет определения,которое бы определяло,будет ли приборостроение вызываться один или два раза.Если вызывается только один раз,то нет определения,определяющего,какое из новых значений будет поставляться.</target>
        </trans-unit>
        <trans-unit id="74415b1346dd0ddc93d29cb9c0389734be028243" translate="yes" xml:space="preserve">
          <source>If the master node fails, the entire pool exits.</source>
          <target state="translated">Если главный узел выйдет из строя,весь пул выйдет из строя.</target>
        </trans-unit>
        <trans-unit id="ada210019d5db3434b3a98372ed4ed0f124b6d6b" translate="yes" xml:space="preserve">
          <source>If the match specification contains errors, tuple &lt;code&gt;{error, Errors}&lt;/code&gt; is returned, where &lt;code&gt;Errors&lt;/code&gt; is a list of natural language descriptions of what was wrong with the match specification.</source>
          <target state="translated">Если спецификация соответствия содержит ошибки, возвращается кортеж &lt;code&gt;{error, Errors}&lt;/code&gt; , где &lt;code&gt;Errors&lt;/code&gt; - это список описаний на естественном языке того, что было не так со спецификацией соответствия.</target>
        </trans-unit>
        <trans-unit id="73520de0bbd30344138b28e89ae6e3ad45ab6a3d" translate="yes" xml:space="preserve">
          <source>If the match specification is executed when selecting objects from an ETS table:</source>
          <target state="translated">Если при выборе объектов из таблицы ETS выполняется спецификация соответствия:</target>
        </trans-unit>
        <trans-unit id="c4b956c127ba515516d186daa8a6509787e44051" translate="yes" xml:space="preserve">
          <source>If the match specification is executing when tracing:</source>
          <target state="translated">Если при трассировке выполняется спецификация соответствия:</target>
        </trans-unit>
        <trans-unit id="8673441fb53d8c53d833ea8413d411b45f3c363b" translate="yes" xml:space="preserve">
          <source>If the match specification is syntactically correct, the function either returns &lt;code&gt;{ok,Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">Если спецификация соответствия синтаксически верна, функция либо возвращает &lt;code&gt;{ok,Result}&lt;/code&gt; , где &lt;code&gt;Result&lt;/code&gt; - это результат реального вызова &lt;code&gt;select/2&lt;/code&gt; , либо &lt;code&gt;false&lt;/code&gt; , если спецификация соответствия не соответствует объекту &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="760d740968a06c49ac007f36a245af2196bd1b34" translate="yes" xml:space="preserve">
          <source>If the matching conditions are not met, the match fails, either with:</source>
          <target state="translated">Если условия совпадения не соблюдаются,то и совпадение не удается:</target>
        </trans-unit>
        <trans-unit id="1935f33d435bd33bb34072fa05214583d09d6dc0" translate="yes" xml:space="preserve">
          <source>If the matching fails, a &lt;code&gt;badmatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Если сопоставление не удается, возникает &lt;code&gt;badmatch&lt;/code&gt; выполнения недопустимого сопоставления .</target>
        </trans-unit>
        <trans-unit id="5e6c9dcffff87aa8aa658e5eae30b4366a1b2bb3" translate="yes" xml:space="preserve">
          <source>If the matching subpart of &lt;code&gt;Subject&lt;/code&gt; giving raise to the replacement is to be inserted in the result, option &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; inserts the matching part into &lt;code&gt;Replacement&lt;/code&gt; at the specified position (or positions) before inserting &lt;code&gt;Replacement&lt;/code&gt; into &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">Если соответствующая часть &lt;code&gt;Subject&lt;/code&gt; , вызывающая замену, должна быть вставлена ​​в результат, опция &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; вставляет совпадающую часть в &lt;code&gt;Replacement&lt;/code&gt; в указанную позицию (или позиции) перед вставкой &lt;code&gt;Replacement&lt;/code&gt; в &lt;code&gt;Subject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdd041679c28a1dfb5c5129e21e191da62b2500c" translate="yes" xml:space="preserve">
          <source>If the matching succeeds, any unbound variable in the pattern becomes bound and the value of &lt;code&gt;Expr2&lt;/code&gt; is returned.</source>
          <target state="translated">Если сопоставление прошло успешно, любая несвязанная переменная в шаблоне становится связанной и возвращается значение &lt;code&gt;Expr2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5059fa619d98d60a3d0f2e7f4484d57de08a27f3" translate="yes" xml:space="preserve">
          <source>If the maximum depth is reached, it cannot be read in the resultant output. Also, the &lt;code&gt;,...&lt;/code&gt; form in a tuple denotes that there are more elements in the tuple but these are below the print depth.</source>
          <target state="translated">Если максимальная глубина достигнута, она не может быть прочитана в результирующем выводе. Кроме того &lt;code&gt;,...&lt;/code&gt; форма , ... в кортеже означает, что в кортеже есть другие элементы, но они ниже глубины печати.</target>
        </trans-unit>
        <trans-unit id="6c939753050268aea10f52760cad514608911137" translate="yes" xml:space="preserve">
          <source>If the message cannot be decoded the following callback function will be invoked:</source>
          <target state="translated">Если сообщение не может быть расшифровано,будет вызвана следующая функция обратного вызова:</target>
        </trans-unit>
        <trans-unit id="fa13ca2255dfd047e4217a3af88a01b044ce4d8d" translate="yes" xml:space="preserve">
          <source>If the message is on report form, it is converted to &lt;code&gt;{Format,Args}&lt;/code&gt; by calling the report callback. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for more information about report callbacks and valid forms of log messages.</source>
          <target state="translated">Если сообщение находится в форме отчета, оно преобразуется в &lt;code&gt;{Format,Args}&lt;/code&gt; путем вызова функции обратного вызова отчета. См. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; в Руководстве пользователя ядра для получения дополнительной информации об обратных вызовах отчетов и допустимых формах сообщений журнала.</target>
        </trans-unit>
        <trans-unit id="c5713a5c2133c11304f85627e2ccde367a7ac635" translate="yes" xml:space="preserve">
          <source>If the minimum repetition is &amp;gt; 0, the quantifier is ignored. The assertion is obeyed only once when encountered during matching.</source>
          <target state="translated">Если минимальное повторение&amp;gt; 0, квантификатор игнорируется. Утверждение выполняется только один раз, когда встречается во время сопоставления.</target>
        </trans-unit>
        <trans-unit id="5f724a3bd58fe6f9ce42fc406728de7f89ce0ad1" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;m1&lt;/code&gt; is introduced in version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt;, it must also be loaded when upgrading and deleted when downgrading:</source>
          <target state="translated">Если модуль &lt;code&gt;m1&lt;/code&gt; представлен в версии &quot;2&quot; &lt;code&gt;ch_app&lt;/code&gt; , он также должен быть загружен при обновлении и удален при понижении:</target>
        </trans-unit>
        <trans-unit id="7aff411ea6299d7bca7ad227ec0e1bc26a882a00" translate="yes" xml:space="preserve">
          <source>If the module cannot be found, &lt;code&gt;non_existing&lt;/code&gt; is returned.</source>
          <target state="translated">Если модуль не может быть найден, возвращается &lt;code&gt;non_existing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5745afeece7b41ec1bfc061d3b5f18d8e8d1dfba" translate="yes" xml:space="preserve">
          <source>If the module is Cover-compiled, &lt;code&gt;cover_compiled&lt;/code&gt; is returned.</source>
          <target state="translated">Если модуль скомпилирован с помощью Cover, возвращается &lt;code&gt;cover_compiled&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52f516f712d9242bfd152b08a6fd0f4a2793c3fd" translate="yes" xml:space="preserve">
          <source>If the module is loaded, it returns the name of the file containing the loaded object code.</source>
          <target state="translated">При загрузке модуля возвращается имя файла с загруженным объектным кодом.</target>
        </trans-unit>
        <trans-unit id="46dba590f6c1f6f800702e68508881918dc97bf9" translate="yes" xml:space="preserve">
          <source>If the module is not loaded, this function searches the code path for the first file containing object code for &lt;code&gt;Module&lt;/code&gt; and returns the absolute filename.</source>
          <target state="translated">Если модуль не загружен, эта функция ищет путь кода для первого файла, содержащего объектный код для &lt;code&gt;Module&lt;/code&gt; и возвращает абсолютное имя файла.</target>
        </trans-unit>
        <trans-unit id="229acd9737c1671ac97dd505de45081f475b5a4e" translate="yes" xml:space="preserve">
          <source>If the module is preloaded, &lt;code&gt;preloaded&lt;/code&gt; is returned.</source>
          <target state="translated">Если модуль предварительно &lt;code&gt;preloaded&lt;/code&gt; , возвращается предварительно загруженный .</target>
        </trans-unit>
        <trans-unit id="ea6cb550bcdaadfe5116319b2dd6e7b241b066a1" translate="yes" xml:space="preserve">
          <source>If the module is successfully Cover compiled, the function returns &lt;code&gt;{ok,Module}&lt;/code&gt;. Otherwise the function returns &lt;code&gt;{error,File}&lt;/code&gt;. Errors and warnings are printed as they occur.</source>
          <target state="translated">Если модуль успешно скомпилирован Cover, функция возвращает &lt;code&gt;{ok,Module}&lt;/code&gt; . В противном случае функция возвращает &lt;code&gt;{error,File}&lt;/code&gt; . Ошибки и предупреждения печатаются по мере их возникновения.</target>
        </trans-unit>
        <trans-unit id="1e0a91a6b9e2e2cfbc8f28ae6d3d48928ca8ba21" translate="yes" xml:space="preserve">
          <source>If the modules used to implement the process change dynamically during runtime, the process must understand one more message. An example is the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; processes. The message is &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt;. The reply to this message is &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt;, where &lt;code&gt;Modules&lt;/code&gt; is a list of the currently active modules in the process.</source>
          <target state="translated">Если модули, используемые для реализации процесса, изменяются динамически во время выполнения, процесс должен понять еще одно сообщение. Примером могут &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; процессы gen_event . Сообщение: &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt; . Ответ на это сообщение &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt; , где &lt;code&gt;Modules&lt;/code&gt; - это список модулей, активных в данный момент в процессе.</target>
        </trans-unit>
        <trans-unit id="df61dd8b4c6d4d214b129a5077aaee5f7910b304" translate="yes" xml:space="preserve">
          <source>If the name after the prefix and any lift and glob markers is &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, the variable is treated as an anonymous catch-all pattern in matches. For example, &lt;code&gt;_@_&lt;/code&gt;, &lt;code&gt;_@@_&lt;/code&gt;, &lt;code&gt;_@__&lt;/code&gt;, or even &lt;code&gt;_@__@_&lt;/code&gt;.</source>
          <target state="translated">Если имя после префикса и любых маркеров подъема и глобуса равно &lt;code&gt;_&lt;/code&gt; или &lt;code&gt;0&lt;/code&gt; , переменная обрабатывается как анонимный универсальный шаблон в совпадениях. Например, &lt;code&gt;_@_&lt;/code&gt; , &lt;code&gt;_@@_&lt;/code&gt; , &lt;code&gt;_@__&lt;/code&gt; или даже &lt;code&gt;_@__@_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c34344ea584c9364120e1acb56d82e908a1af1b" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_server&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the &lt;code&gt;gen_server&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Если имя не указано, &lt;code&gt;gen_server&lt;/code&gt; не зарегистрирован. Вместо этого должен использоваться его pid. Имя также может быть указано как &lt;code&gt;{global, Name}&lt;/code&gt; , и в этом случае &lt;code&gt;gen_server&lt;/code&gt; регистрируется с использованием &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f90545e460868142094a7469ef7c519e7a99526" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_statem&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be specified as &lt;code&gt;{global,Name}&lt;/code&gt;, then the &lt;code&gt;gen_statem&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt; in Kernel.</source>
          <target state="translated">Если имя не указано, &lt;code&gt;gen_statem&lt;/code&gt; не зарегистрирован. Вместо этого должен использоваться его pid. Имя также может быть указано как &lt;code&gt;{global,Name}&lt;/code&gt; , тогда &lt;code&gt;gen_statem&lt;/code&gt; регистрируется с помощью &lt;code&gt;global:register_name/2&lt;/code&gt; в ядре.</target>
        </trans-unit>
        <trans-unit id="bce770e9e17197a693d6f9ec8afdca775fdac582" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the event manager is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the event manager is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Если имя не указано, диспетчер событий не зарегистрирован. Вместо этого должен использоваться его pid. Имя также может быть указано как &lt;code&gt;{global, Name}&lt;/code&gt; , и в этом случае менеджер событий регистрируется с использованием &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="980ec5f2e4cbb3a6bcddf606d02e3f399d751b31" translate="yes" xml:space="preserve">
          <source>If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them has matched.</source>
          <target state="translated">Если имя,используемое в условии такого рода,является дубликатом,то тест применяется ко всем подмаскадкам одного и того же имени,и является истинным,если какая-либо из них совпала.</target>
        </trans-unit>
        <trans-unit id="15ab8218177de1094fcd225608c4c1ed9bb318cc" translate="yes" xml:space="preserve">
          <source>If the node identified by &lt;code&gt;Node&lt;/code&gt; does not support distributed &lt;code&gt;spawn_monitor()&lt;/code&gt;, the call will fail with a &lt;code&gt;notsup&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bffa909b81c50ee39e3329bfdea53c42d35846" translate="yes" xml:space="preserve">
          <source>If the node is distributed, all referenced nodes are visible. Column &lt;strong&gt;Connection type&lt;/strong&gt; shows if the node is visible, hidden, or not connected. Visible nodes are alive nodes with a living connection to the originating node. Hidden nodes are the same as visible nodes, except they are started with flag &lt;code&gt;-hidden&lt;/code&gt;. Not connected nodes are nodes that are not connected to the originating node anymore, but references (that is, process or port identifiers) exist.</source>
          <target state="translated">Если узел распределен, все узлы, на которые есть ссылка, видны. Столбец &lt;strong&gt;Тип подключения&lt;/strong&gt; показывает, является ли узел видимым, скрытым или не подключенным. Видимые узлы - это живые узлы с живым подключением к исходному узлу. Скрытые узлы такие же, как и видимые узлы, за исключением того, что они запускаются с флагом &lt;code&gt;-hidden&lt;/code&gt; . Неподключенные узлы - это узлы, которые больше не подключены к исходному узлу, но ссылки (то есть идентификаторы процессов или портов) существуют.</target>
        </trans-unit>
        <trans-unit id="9c56f0553bb17f48448269d8c3f6b6f7e5b7e66d" translate="yes" xml:space="preserve">
          <source>If the node is started with command-line flag &lt;code&gt;-sname&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the short name of the host (not the fully qualified domain name). If started with flag &lt;code&gt;-name&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified domain name. For more information, see &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Если узел запускается с флагом командной строки &lt;code&gt;-sname&lt;/code&gt; , имя узла - &lt;code&gt;foobar@Host&lt;/code&gt; , где &lt;code&gt;Host&lt;/code&gt; - это краткое имя хоста (а не полное доменное имя). Если запускается с флагом &lt;code&gt;-name&lt;/code&gt; , имя узла - &lt;code&gt;foobar@Host&lt;/code&gt; , где &lt;code&gt;Host&lt;/code&gt; - полное доменное имя. Для получения дополнительной информации см. &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95b56bcd18c923019bf4643e2b58f9471a6acfb9" translate="yes" xml:space="preserve">
          <source>If the node was not distributed.</source>
          <target state="translated">Если узел не был распределен.</target>
        </trans-unit>
        <trans-unit id="aedd11aac41ef6bf71a8b2c8d09b6e7316fb0ef3" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, &lt;code&gt;0&lt;/code&gt; is returned, otherwise &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">Если регистрация узла в EPMD была успешно отменена, возвращается &lt;code&gt;0&lt;/code&gt; , в противном случае возвращается &lt;code&gt;-1&lt;/code&gt; , а &lt;code&gt;erl_errno&lt;/code&gt; устанавливается в &lt;code&gt;EIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9460cf94d8c06eac24b50547fafb0d6e9b4fd6e1" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, the function returns &lt;code&gt;0&lt;/code&gt;. Otherwise, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">Если регистрация узла в EPMD была успешно отменена, функция возвращает &lt;code&gt;0&lt;/code&gt; . В противном случае возвращается &lt;code&gt;-1&lt;/code&gt; , а &lt;code&gt;erl_errno&lt;/code&gt; устанавливается в &lt;code&gt;EIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5ac939fb10f304c0c8f3c91721403a64646c5e" translate="yes" xml:space="preserve">
          <source>If the node where the application is running goes down, the application is restarted (after the specified time-out) at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. This is called a &lt;strong&gt;failover&lt;/strong&gt;.</source>
          <target state="translated">Если узел, на котором работает приложение, выходит из строя, приложение перезапускается (по истечении заданного времени ожидания) на первом рабочем узле, который указан в списке узлов в параметре &lt;code&gt;distributed&lt;/code&gt; конфигурации. Это называется &lt;strong&gt;аварийным переключением&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d2b0ad4edfef4bb3e88a7ddeeff16d1de18813" translate="yes" xml:space="preserve">
          <source>If the number of arguments are known at compile time, the call is better written as &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt;.</source>
          <target state="translated">Если количество аргументов известно во время компиляции, вызов лучше записать как &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37c7a476d1b0b827d6493e10ef324cd201488a29" translate="yes" xml:space="preserve">
          <source>If the number of elements in the arguments are known at compile time, the call is better written as &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt;.</source>
          <target state="translated">Если количество элементов в аргументах известно во время компиляции, вызов лучше записать как &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed56e6304627b8d6f8ad0ab5b8d27fa5330578a8" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt; logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1678d016c144fe15d956c065fed8204d1f4e8c" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="translated">Если старое поведение является предпочтительным, для параметра конфигурации ядра &lt;code&gt;logger_sasl_compatible&lt;/code&gt; можно установить значение &lt;code&gt;true&lt;/code&gt; . После этого &lt;code&gt;SASL configuration parameters&lt;/code&gt; можно использовать, как и раньше, и отчеты SASL будут печататься только в том случае, если приложение SASL запущено, через второй обработчик журнала с именем &lt;code&gt;sasl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5231cf8edc57a7fbd05d3b31ba66fb76e90acd0" translate="yes" xml:space="preserve">
          <source>If the operation fails, a bad match error occurs that terminates the test case.</source>
          <target state="translated">Если операция не удается,то происходит ошибка в совпадении,которая завершает тестовый случай.</target>
        </trans-unit>
        <trans-unit id="279228e8ee1eea55ae3919811a086bb57153efdc" translate="yes" xml:space="preserve">
          <source>If the operation is aborted for whatever reason (e.g. if the socket is closed &quot;by someone else&quot;). The &lt;code&gt;Info&lt;/code&gt; part contains the abort reason (in this case that the socket has been closed &lt;code&gt;Info = {SelectRef, closed}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c8fb74e6d95469ef49c5c6891c58f75c46dd19" translate="yes" xml:space="preserve">
          <source>If the operation is denied because of table access rights (&lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb00786bd693115a31f9e1bae9c1bd9187b7cb1" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;active&lt;/code&gt; is set to &lt;code&gt;once&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or an integer value, the process owning the sslsocket will receive messages of type &lt;code&gt;&lt;a href=&quot;#type-active_msgs&quot;&gt; active_msgs() &lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660ac0936f3ad9df7f0818b651fbd055b3e48bf8" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;anti_replay&lt;/code&gt; is defined in the server, a pair of Bloom filters (&lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;) are used to record incoming ClientHello messages (it is the unique binder value that is actually stored). The &lt;strong&gt;current&lt;/strong&gt; Bloom filter is used for &lt;code&gt;WindowSize&lt;/code&gt; seconds to store new elements. At the end of the time window the Bloom filters are rotated (the &lt;strong&gt;current&lt;/strong&gt; Bloom filter becomes the &lt;strong&gt;old&lt;/strong&gt; and an empty Bloom filter is set as &lt;strong&gt;current&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965b40d04fea8544035ae2adb0a45bfab2ddc16f" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned.</source>
          <target state="translated">Если установлена ​​опция &lt;code&gt;raw&lt;/code&gt; , файловый сервер не вызывается и возвращается только информация о локальных файлах.</target>
        </trans-unit>
        <trans-unit id="4e75c5ca6851d3d1260e2334b0fd3550965b29e5" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f856775e657213352223a21e03401b4aa2a209" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e127046f0102151c6ef18467d6c0abf9dd2f077" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если установлена ​​опция &lt;code&gt;raw&lt;/code&gt; , файловый сервер не вызывается и возвращается только информация о локальных файлах. Обратите внимание, что это нарушит гарантии атомарности этого модуля, поскольку он может конкурировать с одновременным вызовом &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="400845971be3dd0decd026d5b02cf869e6e7945b" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;user_dir_fun&lt;/code&gt; is defined, that fun is called and the returned directory is used,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d027da67948b3928fcb8c40cf4bee29a349c9ad" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is proably not what you want.</source>
          <target state="translated">Если параметр &lt;code&gt;verify&lt;/code&gt; установлен в &lt;code&gt;verify_peer&lt;/code&gt; опции &lt;code&gt;server_name_indication&lt;/code&gt; также должно быть указано, если это не без расширения Указания Имени сервера не будет отправлено, и &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; будет называться с IP-адресом соединения , как &lt;code&gt;ReferenceID&lt;/code&gt; , который вероятно, не то, что вы хотите.</target>
        </trans-unit>
        <trans-unit id="8ee4266e447f2d44213209bd3f7598d7638964ff" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is probably not what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f682b6a405b33cd20dc6b87dfbd76f644b7558" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a18e0b35e87dbcf1a9dcdd4db312f82e11bde7" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если используется опция &lt;code&gt;{handshake, hello}&lt;/code&gt; , рукопожатие приостанавливается после получения сообщения hello от сервера, а успешный ответ - &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; вместо &lt;code&gt;{ok, SslSocket}&lt;/code&gt; . После этого рукопожатие продолжается или отменяется вызовом &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a077df380f70545e70cd306e5e5521ae67d9f379" translate="yes" xml:space="preserve">
          <source>If the option is enabled, and no &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; is present, the user name must present in the &lt;code&gt;&lt;a href=&quot;#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; for the check to succeed but the value of the password is not checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948c45ffdeba267366402b1a519f264bb85a2b52" translate="yes" xml:space="preserve">
          <source>If the option is intended only for a server or for a client, it may be set in this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f7f3873edec45c49aeb8ad204a603fa73eff84" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;allow deny&lt;/code&gt;, the users network address is first controlled to be in the allow subset. If the user network address is not in the allowed subset, the user is denied to get the asset. If the network address is in the allowed subset, a second control is performed. That is, the user network address is not in the subset of network addresses to be denied as specified by parameter &lt;code&gt;deny&lt;/code&gt;.</source>
          <target state="translated">Если установлен порядок, &lt;code&gt;allow deny&lt;/code&gt; , сначала контролируется, чтобы сетевой адрес пользователя находился в разрешенном подмножестве. Если сетевой адрес пользователя не входит в разрешенное подмножество, пользователю отказывают в получении актива. Если сетевой адрес находится в разрешенном подмножестве, выполняется второй контроль. То есть сетевой адрес пользователя не входит в подмножество сетевых адресов, которые должны быть запрещены, как указано параметром &lt;code&gt;deny&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48d8a47c543c2d39d92d2c1d202bacab80c1642d" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;deny allow&lt;/code&gt;, only users from networks specified to be in the allowed subset succeeds to request assets in the limited area.</source>
          <target state="translated">Если установлен порядок &lt;code&gt;deny allow&lt;/code&gt; , только пользователи из сетей, указанных как входящие в разрешенное подмножество, смогут запросить активы в ограниченной области.</target>
        </trans-unit>
        <trans-unit id="5413791d17ed0b4814f8fb694ad1efb815f76c05" translate="yes" xml:space="preserve">
          <source>If the order of the answers is not important, there is an alternative to the &lt;code&gt;unique&lt;/code&gt; option, namely to sort the answers uniquely:</source>
          <target state="translated">Если порядок ответов не важен, есть альтернатива &lt;code&gt;unique&lt;/code&gt; варианту, а именно однозначная сортировка ответов:</target>
        </trans-unit>
        <trans-unit id="b054305581b7663ed91514b307669add31ca5b5b" translate="yes" xml:space="preserve">
          <source>If the packet does not conform to the protocol format, &lt;code&gt;{error,Reason}&lt;/code&gt; is returned.</source>
          <target state="translated">Если пакет не соответствует формату протокола, возвращается &lt;code&gt;{error,Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2c9f15b9a918cfc529cc22dc69ae62a00c732a6" translate="yes" xml:space="preserve">
          <source>If the page is empty, it means either of the following:</source>
          <target state="translated">Если страница пуста,это означает одно из следующего:</target>
        </trans-unit>
        <trans-unit id="f52fa558245396ce59f0c16eb282e09760e84891" translate="yes" xml:space="preserve">
          <source>If the parse_transform is not applied to a module which calls this pseudo function, the call will fail in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The module &lt;code&gt;dbg&lt;/code&gt; actually exports a function with this name, but it should never really be called except for when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including the &lt;code&gt;ms_transform.hrl&lt;/code&gt; header file, compiled code will never call the function, but the function call is replaced by a literal match_spec.</source>
          <target state="translated">Если parse_transform не применяется к модулю, который вызывает эту псевдофункцию, вызов завершится ошибкой во время выполнения (с &lt;code&gt;badarg&lt;/code&gt; ). Модуль &lt;code&gt;dbg&lt;/code&gt; на самом деле экспортирует функцию с этим именем, но на самом деле он никогда не должен вызываться, за исключением случаев использования функции в оболочке. Если &lt;code&gt;parse_transform&lt;/code&gt; правильно применен путем включения &lt;code&gt;ms_transform.hrl&lt;/code&gt; заголовка ms_transform.hrl , скомпилированный код никогда не вызовет функцию, но вызов функции будет заменен литералом match_spec.</target>
        </trans-unit>
        <trans-unit id="7c4c35e1fed61f85f87d7154c2244f967d2936c6" translate="yes" xml:space="preserve">
          <source>If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next starting character then occurs. Backtracking can occur as usual to the left of (*PRUNE), before it is reached, or when matching to the right of (*PRUNE), but if there is no match to the right, backtracking cannot cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an alternative to an atomic group or possessive quantifier, but there are some uses of (*PRUNE) that cannot be expressed in any other way. In an anchored pattern, (*PRUNE) has the same effect as (*COMMIT).</source>
          <target state="translated">Если образец не имеет штриховки,то происходит переход к следующему стартовому символу.Отслеживание может происходить как обычно слева от (*PRUNE),до его достижения или при совпадении справа от (*PRUNE),но если нет совпадений справа,то отслеживание не может пересекаться (*PRUNE).В простых случаях использование (*PRUNE)является лишь альтернативой атомной группе или притязательному квантификатору,но есть и такие использования (*PRUNE),которые не могут быть выражены никаким другим способом.В привязанном шаблоне (*PRUNE)имеет тот же эффект,что и (*COMMIT).</target>
        </trans-unit>
        <trans-unit id="caf53e7076db6e332a206c64cff8afbb0ab34c47" translate="yes" xml:space="preserve">
          <source>If the permission of a loaded, but not started, application is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; but the application is not started until the permission is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если разрешение загруженного, но не запущенного приложения установлено на &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; возвращает &lt;code&gt;ok&lt;/code&gt; , но приложение не запускается, пока разрешение не будет установлено на &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5424927d13c1c2f8655ecb9fa4aea52eaa565c" translate="yes" xml:space="preserve">
          <source>If the permission of a running application is set to &lt;code&gt;false&lt;/code&gt;, the application is stopped. If the permission later is set to &lt;code&gt;true&lt;/code&gt;, it is restarted.</source>
          <target state="translated">Если для разрешения запущенного приложения установлено значение &lt;code&gt;false&lt;/code&gt; , приложение останавливается. Если разрешение позже будет установлено в значение &lt;code&gt;true&lt;/code&gt; , оно будет перезапущено.</target>
        </trans-unit>
        <trans-unit id="1f18562fd499738cfc53fedde95228c6abb3a3c9" translate="yes" xml:space="preserve">
          <source>If the platform implements the IPv4 option &lt;code&gt;IP_PKTOPTIONS&lt;/code&gt;, or the IPv6 option &lt;code&gt;IPV6_PKTOPTIONS&lt;/code&gt; or &lt;code&gt;IPV6_2292PKTOPTIONS&lt;/code&gt; for the socket this value is returned from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; when called with the option name &lt;code&gt;&lt;a href=&quot;#type-option_name&quot;&gt;pktoptions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
