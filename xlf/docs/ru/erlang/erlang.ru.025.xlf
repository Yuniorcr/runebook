<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="00525383d9d58422c948ae43bf89fd05e4f983f1" translate="yes" xml:space="preserve">
          <source>Grouping. It matches &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Группировка. Соответствует &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca2a2d5844ec58a2c24e751f2553b4b5f79d344" translate="yes" xml:space="preserve">
          <source>Groups are automatically created when any process joins, and are removed when all processes leave the group. Non-existing group is considered empty (containing no processes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a121fa06623a2cf82b642092526102dbfe1e92e" translate="yes" xml:space="preserve">
          <source>Groups together the part of the string with the parts of the string matching the subexpressions of the regular expression.</source>
          <target state="translated">Сгруппируйте вместе часть строки с частями строки,соответствующими подвыражениям регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="52a003ff3b98a10e8f4a8754529d8e0afcb36923" translate="yes" xml:space="preserve">
          <source>Groups: all standard groups supported for the Diffie-Hellman key exchange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d59dfad8a207c19fb03d23c5fa725918ccbc3d3" translate="yes" xml:space="preserve">
          <source>Guard constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f29b3c3ec5d955af2fe66cafaa0331a892e76b" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;bit_size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbfeacdb74b0b04f59a3235c6e9c0ab7f512a3c" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;bit_size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt; | &lt;code&gt;get_tcw&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f5854029d7445b6d33c8e8357f38846f74074b" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">GuardFunction :: = BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26ab9f4a7563027538eea5c8069b4656a1e5e814" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt; | &lt;code&gt;get_tcw&lt;/code&gt;</source>
          <target state="translated">GuardFunction :: = BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt; | &lt;code&gt;get_tcw&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="bce8571c4897351cf59857c7ecbf1e4a1a421968" translate="yes" xml:space="preserve">
          <source>Guide: Design principles</source>
          <target state="translated">Путеводитель:Принципы проектирования</target>
        </trans-unit>
        <trans-unit id="efdf80231713b1d4e801ca0c584a421f5e8f439b" translate="yes" xml:space="preserve">
          <source>Guide: ERTS</source>
          <target state="translated">Путеводитель:ERTS</target>
        </trans-unit>
        <trans-unit id="665e5b30bae9bb0925493ecb48fee34c2fef01e1" translate="yes" xml:space="preserve">
          <source>Guide: Efficiency guide</source>
          <target state="translated">Путеводитель:Руководство по эффективности</target>
        </trans-unit>
        <trans-unit id="758e398526fc027576517b8abb810d97bc7d1a3e" translate="yes" xml:space="preserve">
          <source>Guide: Embedded</source>
          <target state="translated">Путеводитель:Встроенный</target>
        </trans-unit>
        <trans-unit id="f0581c94431aa05c2eb8472879c7cc801044559b" translate="yes" xml:space="preserve">
          <source>Guide: Getting started</source>
          <target state="translated">Путеводитель:Начало работы</target>
        </trans-unit>
        <trans-unit id="f240a19e5c8b7cc00f916b707fbdf32023e21d53" translate="yes" xml:space="preserve">
          <source>Guide: Installation guide</source>
          <target state="translated">Путеводитель:Руководство по установке</target>
        </trans-unit>
        <trans-unit id="d502df217602b5fdaf2f55dc2c547ef0fbf862f7" translate="yes" xml:space="preserve">
          <source>Guide: OAM</source>
          <target state="translated">Путеводитель:OAM</target>
        </trans-unit>
        <trans-unit id="5e2bf177d1d38ced2ec568d128c1257de3a75f5f" translate="yes" xml:space="preserve">
          <source>Guide: Programming examples</source>
          <target state="translated">Путеводитель:Примеры программирования</target>
        </trans-unit>
        <trans-unit id="e1e72627945ab63186b7656050547019c49d74d8" translate="yes" xml:space="preserve">
          <source>Guide: Reference manual</source>
          <target state="translated">Путеводитель:Справочное руководство</target>
        </trans-unit>
        <trans-unit id="7a69b32cf3986c2b7ac7acbcdbda8e61534fb840" translate="yes" xml:space="preserve">
          <source>Guide: System principles</source>
          <target state="translated">Путеводитель:Системные принципы</target>
        </trans-unit>
        <trans-unit id="0e2c2ebdd60572423288c669f8e6a4bab450c3df" translate="yes" xml:space="preserve">
          <source>Guide: Tutorial</source>
          <target state="translated">Путеводитель:Учебное пособие</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="380eb30f2d5ab1cdac2a8d64b79d28cfa75198ff" translate="yes" xml:space="preserve">
          <source>HMAC</source>
          <target state="translated">HMAC</target>
        </trans-unit>
        <trans-unit id="a82c464d40e8920d0a12d5e2c7fa455ce1ecf101" translate="yes" xml:space="preserve">
          <source>HTML presentation of test suite code</source>
          <target state="translated">HTML-презентация кода тестового набора</target>
        </trans-unit>
        <trans-unit id="4994badab8d9e0b3f67ec8c58caac837b4abe642" translate="yes" xml:space="preserve">
          <source>HTML presentation of test suite results</source>
          <target state="translated">HTML-презентация результатов тестового набора</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="20305aa9587f9aff479101ecd817e441076f14af" translate="yes" xml:space="preserve">
          <source>HTTP option (&lt;code&gt;http_option()&lt;/code&gt;) details:</source>
          <target state="translated">&lt;code&gt;http_option()&lt;/code&gt; HTTP-опции ( http_option () ):</target>
        </trans-unit>
        <trans-unit id="20f1936f4eab83709aee013d0385ff1c94b37fcb" translate="yes" xml:space="preserve">
          <source>HTTP request method.</source>
          <target state="translated">Метод HTTP-запроса.</target>
        </trans-unit>
        <trans-unit id="fcfac1cc550ec5fe8503b865623fd3395d7a477a" translate="yes" xml:space="preserve">
          <source>HTTP server API</source>
          <target state="translated">API HTTP-сервера</target>
        </trans-unit>
        <trans-unit id="b5b6a9832e57f59fa9ba1970b4197664e77906ed" translate="yes" xml:space="preserve">
          <source>HTTP version, currently &quot;HTTP/1.1&quot;</source>
          <target state="translated">HTTP версия,в настоящее время &quot;HTTP/1.1&quot;.</target>
        </trans-unit>
        <trans-unit id="415221bf4b248b264aa84fda2df240cd373a09c7" translate="yes" xml:space="preserve">
          <source>Hair space</source>
          <target state="translated">Волосы пространство</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="74c85e2b16d60ea1dcaab2f9e4e25d96c53123be" translate="yes" xml:space="preserve">
          <source>Handle a inform message.</source>
          <target state="translated">Обращайтесь с информационным сообщением.</target>
        </trans-unit>
        <trans-unit id="8c78d25f102ef8eda10b5a75012e8b64805bd431" translate="yes" xml:space="preserve">
          <source>Handle a notification to be sent. The filter can either accept the notification as is, return &lt;code&gt;send&lt;/code&gt;, modify the notification, return &lt;code&gt;{send, NewNotif}&lt;/code&gt; or suppress the notification, return &lt;code&gt;dont_send&lt;/code&gt;.</source>
          <target state="translated">Обработать уведомление, которое будет отправлено. Фильтр может принять уведомление как есть, вернуть &lt;code&gt;send&lt;/code&gt; , изменить уведомление, вернуть &lt;code&gt;{send, NewNotif}&lt;/code&gt; или подавить уведомление, вернуть &lt;code&gt;dont_send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0760030c5c3f38e40c1b890da4d533b3c3fc8c" translate="yes" xml:space="preserve">
          <source>Handle a report message.</source>
          <target state="translated">Обращайтесь с сообщением.</target>
        </trans-unit>
        <trans-unit id="45fa6cc9728ceb60ac0a051db0f488d3202736ce" translate="yes" xml:space="preserve">
          <source>Handle a trap/notification message from an agent.</source>
          <target state="translated">Обработать сообщение о ловушке/уведомлении от агента.</target>
        </trans-unit>
        <trans-unit id="f9c7fc7481552d6aff278b1c974d55353318d9fe" translate="yes" xml:space="preserve">
          <source>Handle for a specific FTP connection, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Дескриптор конкретного FTP-соединения, см. Модуль &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbda4bcf7ac58978c155de552f386a7cabd7519e" translate="yes" xml:space="preserve">
          <source>Handle for a specific SSH/SFTP connection, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Дескриптор конкретного SSH / SFTP-соединения, см. Модуль &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75e91cbb42fd0e3d90b67be347008953368d932a" translate="yes" xml:space="preserve">
          <source>Handle for a specific Telnet connection, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Дескриптор конкретного соединения Telnet, см. Модуль &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16bec71f169580069c04eb366b2e7edd0709fd66" translate="yes" xml:space="preserve">
          <source>Handle the reply to an asynchronous request, such as &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обрабатывайте ответ на асинхронный запрос, например &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d44a583cd21c337171ab088369294e9f1adf157" translate="yes" xml:space="preserve">
          <source>Handle the reply to an asynchronous request, such as &lt;code&gt;&lt;a href=&quot;snmpm#async_get2&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next2&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;snmpm#async_set2&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbbec4581856cdf831ad92220e8c0c524192fd1" translate="yes" xml:space="preserve">
          <source>Handle to a NETCONF session, as required by signaling functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b159af3f46722bc08fb303932f585dbf455dbca5" translate="yes" xml:space="preserve">
          <source>Handle to a connection to a NETCONF server as returned by &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt;, or to a session as returned by &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#only_open-1&quot;&gt;only_open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b5cbd72ade701ab78a0c66eea3cc365bc59eac" translate="yes" xml:space="preserve">
          <source>Handle to the &lt;code&gt;epp&lt;/code&gt; server.</source>
          <target state="translated">Дескриптор сервера &lt;code&gt;epp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e52aaa094b5e8a1137aac218cd0a979749732ffd" translate="yes" xml:space="preserve">
          <source>Handler Callback Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200f27a9fd62c17ba568575a28f8cc78a29e0aa9" translate="yes" xml:space="preserve">
          <source>Handler configuration data for Logger. The following default values apply:</source>
          <target state="translated">Данные конфигурации обработчика для логгера.Применяются следующие значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="e767bf13ab13407d576b285180deba35039b9c4c" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4e5ac3ff721d07867e9b05c8337ed55ee393d3" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Фильтры-обработчики добавляются с помощью &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; и удаляются с помощью &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; . Их также можно указать непосредственно в конфигурации при добавлении обработчика с помощью &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; или через &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; параметров конфигурации ядра .</target>
        </trans-unit>
        <trans-unit id="a19df29c14bb59d2df47c78d5601e95477f6e53a" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa2c83d2d8b95dd0f46137f7539ec6164e318e2" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Фильтры обработчика указываются при добавлении обработчика или добавляются или удаляются во время выполнения с помощью &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="f0065b00d67594d8a62cb8fb9796876e1d8da5ac" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;.</source>
          <target state="translated">Данные конфигурации конкретного обработчика вставляются самим обратным вызовом обработчика в подструктуру, связанную с полем с именем &lt;code&gt;config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17e94ab879668328c0d7f838700deffb10d37fcd" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;. See the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages for information about the specifc configuration for these handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a11f027cd6db3a106cb106c781e7e6546c3308" translate="yes" xml:space="preserve">
          <source>Handler specific configuration, that is, configuration data related to a specific handler implementation.</source>
          <target state="translated">Конфигурация конкретного обработчика,то есть данные конфигурации,связанные с конкретной реализацией обработчика.</target>
        </trans-unit>
        <trans-unit id="8dd3565abe30287cdd82dbf04dfe72c3a01322cc" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обрабатывает сообщения протокола подключения SSH, которые могут требовать внимания конкретной службы. Подробнее см. &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="351ea12c7488865cb104522ed06fb519daaf6841" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection#type-event&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c94d64476ed5597f8322dfbff2cf130463d724" translate="yes" xml:space="preserve">
          <source>Handles messages from Erlang. The messages can either be plain data to be sent or more subtle instructions to the driver. This function is here mostly for data pumping.</source>
          <target state="translated">Обрабатывает сообщения от Эрланга.Сообщения могут быть либо простыми данными для отправки,либо более тонкими инструкциями для водителя.Эта функция в основном предназначена для перекачки данных.</target>
        </trans-unit>
        <trans-unit id="921a347faf64cd8a16325d957876e1c04d6d75e2" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Обрабатывает сообщения, отправленные вызовом &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1b9f0ea31717ef2e1c8cb50a77717454cf70a8b" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;cast/2&lt;/code&gt;.</source>
          <target state="translated">Обрабатывает сообщения, отправленные вызовом &lt;code&gt;cast/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b904f520d22bb388f5046965390b894bfa3594" translate="yes" xml:space="preserve">
          <source>Handles other messages than SSH Connection Protocol, call, or cast messages sent to the channel.</source>
          <target state="translated">Обрабатывает другие сообщения,кроме протокола соединения SSH,звонков или литых сообщений,отправляемых на канал.</target>
        </trans-unit>
        <trans-unit id="2fd2edfd14e358bb3197eb296e3226354fa0bcbd" translate="yes" xml:space="preserve">
          <source>Handles storing of scanner information when parsing.</source>
          <target state="translated">Ручки для хранения информации о сканере при разборе.</target>
        </trans-unit>
        <trans-unit id="9787eca8b55e04c46475fed50a4b8ca6fa155b36" translate="yes" xml:space="preserve">
          <source>Handles the OTP-MIB</source>
          <target state="translated">Обрабатывает OTP-MIB</target>
        </trans-unit>
        <trans-unit id="a6c4fd9a67f6ff85d671fb367281d35a7948d754" translate="yes" xml:space="preserve">
          <source>Handling any other memory management</source>
          <target state="translated">Обработка любого другого управления памятью</target>
        </trans-unit>
        <trans-unit id="8aef8f3753bae4ea18f0ce0e73cebcd5d20ccb5d" translate="yes" xml:space="preserve">
          <source>Handling instruction with variable number of operands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b341e45d0db6d71ec15e4a0de6c3934aeec4ccd4" translate="yes" xml:space="preserve">
          <source>Handling of binary data (binaries / bit syntax).</source>
          <target state="translated">Обработка двоичных данных (двоичные/битовые синтаксис).</target>
        </trans-unit>
        <trans-unit id="a2823aadf112ce5f5e68f202feabf8215b84b288" translate="yes" xml:space="preserve">
          <source>Handling of configuration files specifying data related to the System Under Test (SUT) (and any other variable data)</source>
          <target state="translated">Обработка конфигурационных файлов с указанием данных,связанных с тестируемой системой (SUT)(и любых других переменных данных).</target>
        </trans-unit>
        <trans-unit id="33fefddaf63d1b186bf16cc5d6c16046d15037f4" translate="yes" xml:space="preserve">
          <source>Handshake, interchange node name, and authenticate (2)</source>
          <target state="translated">Рукопожатие,обмен имени узла и аутентификация (2)</target>
        </trans-unit>
        <trans-unit id="c51f6db8fb76d17c47c7e717ca4c6c5f2b5b4133" translate="yes" xml:space="preserve">
          <source>Handy shortcuts for common tracing settings.</source>
          <target state="translated">Удобные ярлыки для общих настроек трассировки.</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="de7ed76e4bc7658794475e0cb1788bf730fb9c21" translate="yes" xml:space="preserve">
          <source>Hard links are not supported on this platform.</source>
          <target state="translated">Жесткие ссылки не поддерживаются на этой платформе.</target>
        </trans-unit>
        <trans-unit id="e7bcf0ff0ecf672bee67708eac571eebae762e22" translate="yes" xml:space="preserve">
          <source>Hard real-time systems.</source>
          <target state="translated">Жесткие системы реального времени.</target>
        </trans-unit>
        <trans-unit id="df63d1ff1b01b407251d0ded52b5cebe7b3b5ed8" translate="yes" xml:space="preserve">
          <source>Hardware Watchdog</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bebc8f73cff6923a62cf86dbdad6dcd9f3de59" translate="yes" xml:space="preserve">
          <source>Hardware memory barriers or memory fences are instructions that can be used to enforce order between memory accesses. Different hardware architectures provide different memory barriers. Lock free algorithms need to use memory barriers in order to ensure that memory accesses are not reordered in such ways that the algorithm breaks down. Memory barriers are also expensive instructions, so you typically want to minimize the use of these instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66d0faec5f252a3b8add8ab78a2b77dfef38ca3" translate="yes" xml:space="preserve">
          <source>Hash algorithm to be used for signing the certificate together with the key option. Defaults to sha that is sha1.</source>
          <target state="translated">Хэш-алгоритм,который будет использоваться для подписания сертификата вместе с опцией ключа.По умолчанию sha1.</target>
        </trans-unit>
        <trans-unit id="c1abd7377d4f44f416003defcad46c11c4076434" translate="yes" xml:space="preserve">
          <source>Hash functions - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Хеш-функции - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36646a9df5be6ffe4361209dc14cd9eabb8a54c1" translate="yes" xml:space="preserve">
          <source>Hash tables for Erlang terms (ETS).</source>
          <target state="translated">Хэш-таблицы для Erlang терминов (ETS).</target>
        </trans-unit>
        <trans-unit id="66d9fc0e303c1db9ac127804366374bdb8ad808d" translate="yes" xml:space="preserve">
          <source>Hashes &lt;code&gt;term&lt;/code&gt; according to the specified &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt;&lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Хэш &lt;code&gt;term&lt;/code&gt; в соответствии с указанным &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt; &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93e30adaf0176847ba666855ceca8fa26f1db0ad" translate="yes" xml:space="preserve">
          <source>Having the source code in UTF-8 also allows you to write string literals, function names, and atoms containing Unicode characters with code points &amp;gt; 255. Module names, application names, and node names are still restricted to the ISO Latin-1 range. Binary literals, where you use type &lt;code&gt;/utf8&lt;/code&gt;, can also be expressed using Unicode characters &amp;gt; 255. Having module names or application names using characters other than 7-bit ASCII can cause trouble on operating systems with inconsistent file naming schemes, and can hurt portability, so it is not recommended.</source>
          <target state="translated">Наличие исходного кода в UTF-8 также позволяет вам писать строковые литералы, имена функций и атомы, содержащие символы Unicode с кодовыми точками&amp;gt; 255. Имена модулей, имена приложений и имена узлов по-прежнему ограничены диапазоном ISO Latin-1. Двоичные литералы, в которых используется type &lt;code&gt;/utf8&lt;/code&gt; , также могут быть выражены с использованием символов Unicode&amp;gt; 255. Использование в именах модулей или имен приложений символов, отличных от 7-битного ASCII, может вызвать проблемы в операционных системах с несовместимыми схемами именования файлов и может повредить переносимости , поэтому не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="9f670bf76875dd0a7bbc3b0854cf6973e8fd4fce" translate="yes" xml:space="preserve">
          <source>Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Необходимость генерировать дополнительные случайные биты для небольших чисел снижает производительность. Эта функция примерно на 20% медленнее, чем обычная &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4449e9b5eb52175eb4e08b8a7330653b852def9" translate="yes" xml:space="preserve">
          <source>Header elements: Module, Author - These commands insert lines on the form &lt;code&gt;-module(&lt;/code&gt;xxx&lt;code&gt;).&lt;/code&gt; and &lt;code&gt;-author('my@home').&lt;/code&gt;. They can be used directly, but are also used as part of the full headers described below.</source>
          <target state="translated">Элементы заголовка: Module, Author - эти команды вставляют строки в форму &lt;code&gt;-module(&lt;/code&gt; xxx &lt;code&gt;).&lt;/code&gt; и &lt;code&gt;-author('my@home').&lt;/code&gt; , Их можно использовать напрямую, но они также используются как часть полных заголовков, описанных ниже.</target>
        </trans-unit>
        <trans-unit id="a6fe09edcf76c414cb39902b06a907d362c636fc" translate="yes" xml:space="preserve">
          <source>Header file for configuration data</source>
          <target state="translated">Заголовочный файл для конфигурационных данных</target>
        </trans-unit>
        <trans-unit id="a12c4113e1bb8f1f4886664bda35d4aa27d7be74" translate="yes" xml:space="preserve">
          <source>Heading for a hidden node. A hidden node is the same as a visible node, except that it is started with the &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; flag. States the channel number for the node.</source>
          <target state="translated">Направление к скрытому узлу. Скрытый узел - это то же самое, что и видимый узел, за исключением того, что он запускается с флагом &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; . Устанавливает номер канала для узла.</target>
        </trans-unit>
        <trans-unit id="fed55dc039cca5dcc6f8b46a4f4ace2200d528da" translate="yes" xml:space="preserve">
          <source>Heading for a node that was connected to the crashed node earlier. References (that is, process or port identifiers) to the not connected node existed at the time of the crash. States the channel number for the node.</source>
          <target state="translated">Направление к узлу,который ранее был подключен к разбившемуся узлу.Ссылки (т.е.идентификаторы процессов или портов)на неподключенный узел существовали на момент аварии.Указывает номер канала для узла.</target>
        </trans-unit>
        <trans-unit id="952129998156402241d678235a6162ddb355874b" translate="yes" xml:space="preserve">
          <source>Heading for a visible node, that is, an alive node with a connection to the node that crashed. States the channel number for the node.</source>
          <target state="translated">Направление на видимый узел,то есть живой узел с соединением с разрушенным узлом.Назначает номер канала для узла.</target>
        </trans-unit>
        <trans-unit id="c243e47447e24ffdd605f179f0a2cab8a40d6b7a" translate="yes" xml:space="preserve">
          <source>Heading.</source>
          <target state="translated">Heading.</target>
        </trans-unit>
        <trans-unit id="4fa5946d7c0314c7ba622549aa822d84deddf1a7" translate="yes" xml:space="preserve">
          <source>Heading. States the module name.</source>
          <target state="translated">Направление.Составляет название модуля.</target>
        </trans-unit>
        <trans-unit id="150c7cf2786a06b4ea8a7aed067ae6ad9d638983" translate="yes" xml:space="preserve">
          <source>Heading. States the process identifier.</source>
          <target state="translated">Направление.Идентификатор процесса.</target>
        </trans-unit>
        <trans-unit id="7145dfcf409c4e094b7363fa76ac09665f29cbd7" translate="yes" xml:space="preserve">
          <source>Heading. States the scheduler identifier.</source>
          <target state="translated">Направление.Указывает идентификатор планировщика.</target>
        </trans-unit>
        <trans-unit id="05a03b6ce3444cc92f49fde9b3239e70eade9242" translate="yes" xml:space="preserve">
          <source>Heading. States the table owner (a process identifier).</source>
          <target state="translated">Направление.Указывает владельца таблицы (идентификатор процесса).</target>
        </trans-unit>
        <trans-unit id="410899dc76f34f1fabf6ebe98f9e99757d1588a0" translate="yes" xml:space="preserve">
          <source>Heading. States the timer owner (a process identifier), that is, the process to receive the message when the timer expires.</source>
          <target state="translated">Направление.Указывает владельца таймера (идентификатор процесса),т.е.процесс получения сообщения по истечении срока действия таймера.</target>
        </trans-unit>
        <trans-unit id="c2d66ec52324213cab485604b51c2b78378fa0a7" translate="yes" xml:space="preserve">
          <source>Heap binaries are small binaries, up to 64 bytes, and are stored directly on the process heap. They are copied when the process is garbage-collected and when they are sent as a message. They do not require any special handling by the garbage collector.</source>
          <target state="translated">Двоичные файлы кучи-это небольшие двоичные файлы,до 64 байт,которые хранятся непосредственно в куче процесса.Они копируются,когда процесс собирает мусор и когда они отправляются в виде сообщения.Они не требуют специальной обработки сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="21e21ed9381d58c024ca753fbeee40b36f3a6b32" translate="yes" xml:space="preserve">
          <source>Heartbeat interval, in milliseconds</source>
          <target state="translated">Интервал сердцебиения,в миллисекундах</target>
        </trans-unit>
        <trans-unit id="4106d21c7ff6614f8b1f5e63e9c6e5e9cdc9e04e" translate="yes" xml:space="preserve">
          <source>Heartbeat monitoring of an Erlang runtime system.</source>
          <target state="translated">Мониторинг сердцебиения системы Эрланга.</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="c933a30976c11ef549273b016b878d75f830e3f9" translate="yes" xml:space="preserve">
          <source>HelloRetryRequest</source>
          <target state="translated">HelloRetryRequest</target>
        </trans-unit>
        <trans-unit id="268bfdeda15e6e6a18f731bf9369b4adf0706327" translate="yes" xml:space="preserve">
          <source>Help Menu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62999fd30064fd05e82c60b2a94d7ce3e73892c" translate="yes" xml:space="preserve">
          <source>Hence, 1996 is a leap year, 1900 is not, but 2000 is.</source>
          <target state="translated">Следовательно,1996 год-это високосный год,1900-нет,а 2000-да.</target>
        </trans-unit>
        <trans-unit id="e085c6d848b4c5dcb06ae3d79bc98bb5ed8aaaab" translate="yes" xml:space="preserve">
          <source>Hence, the argument entered as input is doubled as follows:</source>
          <target state="translated">Следовательно,аргумент,введенный как входной,удваивается следующим образом:</target>
        </trans-unit>
        <trans-unit id="42595144f616321737f8b5e7f141df36f0ea93d3" translate="yes" xml:space="preserve">
          <source>Hence, the previous list comprehension demonstrates the formation of the list &lt;code&gt;E#employee.name&lt;/code&gt; such that &lt;code&gt;E&lt;/code&gt; is taken from the table of employees, and attribute &lt;code&gt;sex&lt;/code&gt; of each record is equal to the atom &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">Следовательно, предыдущее понимание списка демонстрирует формирование списка &lt;code&gt;E#employee.name&lt;/code&gt; таким образом, что &lt;code&gt;E&lt;/code&gt; берется из таблицы сотрудников, а &lt;code&gt;sex&lt;/code&gt; атрибута каждой записи равен &lt;code&gt;female&lt;/code&gt; атому .</target>
        </trans-unit>
        <trans-unit id="0305883084fd7655771a803404eb6b396bb82e43" translate="yes" xml:space="preserve">
          <source>Hence, when a disc-less node needs to find the schema definitions from a remote node on the network, this information must be supplied through application parameter &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt;. Without this configuration parameter set, &lt;code&gt;Mnesia&lt;/code&gt; starts as a single node system. Also, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; can be used to assign a value to &lt;code&gt;extra_db_nodes&lt;/code&gt; and force a connection after &lt;code&gt;Mnesia&lt;/code&gt; has been started, that is, &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt;.</source>
          <target state="translated">Следовательно, когда узлу без диска необходимо найти определения схемы от удаленного узла в сети, эта информация должна быть предоставлена ​​через параметр приложения &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt; . Без этого набора параметров конфигурации &lt;code&gt;Mnesia&lt;/code&gt; запускается как одноузловая система. Кроме того, функцию &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; можно использовать для присвоения значения &lt;code&gt;extra_db_nodes&lt;/code&gt; и принудительного подключения после запуска &lt;code&gt;Mnesia&lt;/code&gt; , то есть &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9a6ade28837bafcd59b3b5f9e9096aa0c39c5a" translate="yes" xml:space="preserve">
          <source>Here (?(R) is the start of a conditional subpattern, with two different alternatives for the recursive and non-recursive cases. Item (?R) is the actual recursive call.</source>
          <target state="translated">Здесь (?(R)-начало условной подмаскировки,с двумя разными альтернативами для рекурсивных и не рекурсивных случаев.Пункт (?R)-это фактический рекурсивный вызов.</target>
        </trans-unit>
        <trans-unit id="95eada3e2f0063def4189cbe7e1ac07f33e51ad4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; is the base release and &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; is the release to upgrade to.</source>
          <target state="translated">Здесь &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; - это базовый выпуск, а &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; - это выпуск для обновления.</target>
        </trans-unit>
        <trans-unit id="c3ae7fc887a9fc509a0c94f1f548abf5e88538b2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;+W w&lt;/code&gt; and &lt;code&gt;+R 9&lt;/code&gt; are emulator flags. &lt;code&gt;-s my_init&lt;/code&gt; is an init flag, interpreted by &lt;code&gt;init&lt;/code&gt;. &lt;code&gt;-sname arnie&lt;/code&gt; is a user flag, stored by &lt;code&gt;init&lt;/code&gt;. It is read by Kernel and causes the Erlang runtime system to become distributed. Finally, everything after &lt;code&gt;-extra&lt;/code&gt; (that is, &lt;code&gt;+bertie&lt;/code&gt;) is considered as plain arguments.</source>
          <target state="translated">Здесь &lt;code&gt;+W w&lt;/code&gt; и &lt;code&gt;+R 9&lt;/code&gt; - флаги эмулятора. &lt;code&gt;-s my_init&lt;/code&gt; - это флаг инициализации, интерпретируемый &lt;code&gt;init&lt;/code&gt; . &lt;code&gt;-sname arnie&lt;/code&gt; - это пользовательский флаг, хранящийся в &lt;code&gt;init&lt;/code&gt; . Он читается ядром и приводит к распределению системы времени выполнения Erlang. Наконец, все после &lt;code&gt;-extra&lt;/code&gt; (то есть &lt;code&gt;+bertie&lt;/code&gt; ) считается простыми аргументами.</target>
        </trans-unit>
        <trans-unit id="18878a7a47d8170e6d38bdbab2ec1dd97fe93f48" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Binary&lt;/code&gt; is an Erlang binary that contains the encoded data. (If option &lt;code&gt;legacy_erlang_types&lt;/code&gt; has been given, only the binary is returned.)</source>
          <target state="translated">Здесь &lt;code&gt;Binary&lt;/code&gt; - это двоичный файл Erlang, содержащий закодированные данные. (Если &lt;code&gt;legacy_erlang_types&lt;/code&gt; опция legacy_erlang_types , возвращается только двоичный файл.)</target>
        </trans-unit>
        <trans-unit id="37df4c092f43bb499bc403c1f4e4f375ce537f8f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;BytesForOpenType&lt;/code&gt; is a list of bytes constituting the encoding of the &quot;unknown&quot; &lt;code&gt;CHOICE&lt;/code&gt; alternative.</source>
          <target state="translated">Здесь &lt;code&gt;BytesForOpenType&lt;/code&gt; - это список байтов, составляющих кодировку &amp;laquo;неизвестной&amp;raquo; альтернативы &lt;code&gt;CHOICE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46f5f684a77da256af5aa4d76e5b9497068275f5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Fd&lt;/code&gt; was specified to function &lt;code&gt;init/3&lt;/code&gt; as:</source>
          <target state="translated">Здесь &lt;code&gt;Fd&lt;/code&gt; был указан для функции &lt;code&gt;init/3&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="54d075fd5d42e82f879a36d53b74d7b98bbbfc33" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M0&lt;/code&gt; is any map. It follows that &lt;code&gt;M1 .. M4&lt;/code&gt; are maps as well.</source>
          <target state="translated">Здесь &lt;code&gt;M0&lt;/code&gt; - любая карта. Отсюда следует, что &lt;code&gt;M1 .. M4&lt;/code&gt; являются отображениями.</target>
        </trans-unit>
        <trans-unit id="5980443888fa1217e79c3bb79e1e66f80464dd29" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map and &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are any expression.</source>
          <target state="translated">Здесь &lt;code&gt;M&lt;/code&gt; - член типа map, а &lt;code&gt;K&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; - любое выражение.</target>
        </trans-unit>
        <trans-unit id="b1f20246edf736a721e4d108cf1124970da81a07" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map, &lt;code&gt;V&lt;/code&gt; is an expression and &lt;code&gt;K&lt;/code&gt; is an expression that evaluates to an existing key in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;M&lt;/code&gt; представляет собой термин , тип карты, &lt;code&gt;V&lt;/code&gt; является выражением и &lt;code&gt;K&lt;/code&gt; представляет собой выражение , которое вычисляется в существующий ключ в &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0698d19c4d4c3905620eb9ca2f7560cc47809caa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be a &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt;, with all variables already bound. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6105a70c4b87b25ae269fb373351faa4cb7f203" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be an expression with bound variables or literals. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="translated">Здесь &lt;code&gt;M&lt;/code&gt; - любая карта. Ключ &lt;code&gt;K&lt;/code&gt; должен быть выражением со связанными переменными или литералами. &lt;code&gt;V&lt;/code&gt; может быть любым шаблоном с привязанными или несвязанными переменными.</target>
        </trans-unit>
        <trans-unit id="cfa51aff5e200195c56f9fac50cfa48993ce7499" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the old node.</source>
          <target state="translated">Здесь &lt;code&gt;Node&lt;/code&gt; - это старый узел.</target>
        </trans-unit>
        <trans-unit id="40663b6a0bc17a6c5bb5be7fc0a8ec85eb9e5df4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the terminated node.</source>
          <target state="translated">Здесь &lt;code&gt;Node&lt;/code&gt; - это оконечный узел.</target>
        </trans-unit>
        <trans-unit id="3f0cf7c1aa3a9460f5702ed6ce4797a96c09937c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is bound to the value in the first byte of the binary. &lt;code&gt;Sz&lt;/code&gt; is then used at the number of bytes to match out as a binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5a7de11b2a0f9a883784c833a5e64495abf297" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is the combined size of the header and the payload, so we will need to subtract one byte to get the size of the payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa26917569777b811a459c8edac3b1f6928d1a9" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; gets the value &lt;code&gt;paris&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;&lt;code&gt;{f,28}&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;X&lt;/code&gt; получает значение &lt;code&gt;paris&lt;/code&gt; , а &lt;code&gt;Y&lt;/code&gt; &lt;code&gt;{f,28}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0491a2d3210236bc79073f011f175603cf95e651" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;bin&lt;/code&gt; is a driver binary of length at least 50 and &lt;code&gt;drvport&lt;/code&gt; is a port handle. Notice that &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; comes after the elements of the list, likewise &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;bin&lt;/code&gt; - это двоичный файл драйвера длиной не менее 50, а &lt;code&gt;drvport&lt;/code&gt; - дескриптор порта. Обратите внимание, что &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; идет после элементов списка, аналогично &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03614fcdf5fd8628354c2dc566e6863e0b8468ca" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;format_temps/1&lt;/code&gt; calls &lt;code&gt;convert_list_to_c/1&lt;/code&gt;. &lt;code&gt;convert_list_to_c/1&lt;/code&gt; takes off the head of the &lt;code&gt;List_of_cities&lt;/code&gt;, converts it to Celsius if needed. The | operator is used to add the (maybe) converted to the converted rest of the list:</source>
          <target state="translated">Здесь &lt;code&gt;format_temps/1&lt;/code&gt; вызывает &lt;code&gt;convert_list_to_c/1&lt;/code&gt; . &lt;code&gt;convert_list_to_c/1&lt;/code&gt; снимает &lt;code&gt;List_of_cities&lt;/code&gt; , при необходимости конвертирует его в градусы Цельсия. | используется для добавления (возможно) преобразованного в преобразованный остаток списка:</target>
        </trans-unit>
        <trans-unit id="0d41f0b5f278025a79f179eb50cbcf1d17def2de" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;kb.example.org&lt;/code&gt; serves any protocol while &lt;code&gt;www.example.org&lt;/code&gt; presents a secure web server.</source>
          <target state="translated">Здесь &lt;code&gt;kb.example.org&lt;/code&gt; обслуживает любой протокол, а &lt;code&gt;www.example.org&lt;/code&gt; представляет собой безопасный веб-сервер.</target>
        </trans-unit>
        <trans-unit id="f36f1eb025a53a1dc6cfb7f8014034366d975093" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;pipe_name&lt;/code&gt; defaults to &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;pipe_name&lt;/code&gt; умолчанию &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445ee2128dde70c3cdab895146aba251b7587bf5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; the corresponding &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; list passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;watchdog&lt;/code&gt; entry shows the state of a connection's RFC 3539 watchdog state machine. The &lt;code&gt;peer&lt;/code&gt; entry identifies the &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; for which there will have been &lt;code&gt;peer_up/3&lt;/code&gt; callbacks for the Diameter applications identified by the &lt;code&gt;apps&lt;/code&gt; entry, &lt;code&gt;common&lt;/code&gt; being the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;caps&lt;/code&gt; entry identifies the capabilities sent by the local node and received from the peer during capabilities exchange. The &lt;code&gt;port&lt;/code&gt; entry displays socket-level information about the transport connection. The &lt;code&gt;statistics&lt;/code&gt; entry presents Diameter-level counters, an entry like &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; saying that the client has received 2 DWR messages: &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;ref&lt;/code&gt; - это &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; и &lt;code&gt;options&lt;/code&gt; соответствующий список &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; переданный в &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; . Запись &lt;code&gt;watchdog&lt;/code&gt; показывает состояние конечного автомата сторожевого таймера соединения RFC 3539. Запись &lt;code&gt;peer&lt;/code&gt; &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; идентифицирует dia_app: peer_ref (), для которого будут &lt;code&gt;peer_up/3&lt;/code&gt; обратные вызовы peer_up / 3 для приложений Diameter, идентифицированных записью &lt;code&gt;apps&lt;/code&gt; , &lt;code&gt;common&lt;/code&gt; это &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; . В &lt;code&gt;caps&lt;/code&gt; запись идентифицирует возможности, отправленные локальным узлом и полученные от однорангового узла во время обмена возможностями. Запись &lt;code&gt;port&lt;/code&gt; отображает информацию о транспортном соединении на уровне сокета. Запись &lt;code&gt;statistics&lt;/code&gt; представляет счетчики уровня диаметра, запись вроде &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; говорит о том, что клиент получил 2 сообщения DWR: &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff06bab188b6989420caf73f4bedde0091d8f752" translate="yes" xml:space="preserve">
          <source>Here a &lt;code&gt;TestDir&lt;/code&gt; can be used to point out the path to a &lt;code&gt;Suite&lt;/code&gt;. Option &lt;code&gt;testcase&lt;/code&gt; corresponds to option &lt;code&gt;-case&lt;/code&gt; in program &lt;code&gt;ct_run&lt;/code&gt;. Configuration files specified in &lt;code&gt;Opts&lt;/code&gt; are installed automatically at startup.</source>
          <target state="translated">Здесь &lt;code&gt;TestDir&lt;/code&gt; можно использовать для указания пути к &lt;code&gt;Suite&lt;/code&gt; . Опция &lt;code&gt;testcase&lt;/code&gt; соответствует опции &lt;code&gt;-case&lt;/code&gt; в программе &lt;code&gt;ct_run&lt;/code&gt; . Файлы конфигурации, указанные в &lt;code&gt;Opts&lt;/code&gt; , устанавливаются автоматически при запуске.</target>
        </trans-unit>
        <trans-unit id="1d215e0a4d1f50aa10db8d5770d81f093532091e" translate="yes" xml:space="preserve">
          <source>Here a system configuration with an MG and MGC residing in one Erlang node each is outlined:</source>
          <target state="translated">Здесь описывается конфигурация системы с MG и MGC,расположенными в одном узле Erlang:</target>
        </trans-unit>
        <trans-unit id="98f9cd42bd3f2f651c624dd6456d93b42bb7d908" translate="yes" xml:space="preserve">
          <source>Here also the path to the &lt;code&gt;pea-1.0&lt;/code&gt; ebin directory is provided.</source>
          <target state="translated">Здесь также указан путь к каталогу ebin &lt;code&gt;pea-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37285c244117c11d8428f0cbdceb6d27dd880c01" translate="yes" xml:space="preserve">
          <source>Here are a few suggestions for how to avoid deadlock:</source>
          <target state="translated">Вот несколько предложений,как избежать тупика:</target>
        </trans-unit>
        <trans-unit id="922875c8c4eca4e656e135b3c76a4d89fd7a3552" translate="yes" xml:space="preserve">
          <source>Here are all type letters that are allowed on the left side of a transformation rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64246a03dadd5871d19e3c38c5d243139b6de281" translate="yes" xml:space="preserve">
          <source>Here d is any number of decimal digits. However, the value of the setting must be less than the value set by the caller of &lt;code&gt;run/3&lt;/code&gt; for it to have any effect. That is, the pattern writer can lower the limit set by the programmer, but not raise it. If there is more than one setting of one of these limits, the lower value is used.</source>
          <target state="translated">Здесь d - любое количество десятичных цифр. Однако значение параметра должно быть меньше значения, установленного вызывающим оператором &lt;code&gt;run/3&lt;/code&gt; , чтобы он имел какой-либо эффект. То есть разработчик шаблонов может снизить установленный программистом предел, но не повысить его. Если существует несколько настроек одного из этих пределов, используется меньшее значение.</target>
        </trans-unit>
        <trans-unit id="50c6e27284216f0fe5f85c8a2e068c1f3dc4d9db" translate="yes" xml:space="preserve">
          <source>Here each &lt;code&gt;ValueI&lt;/code&gt; is the default value for &lt;code&gt;FieldI&lt;/code&gt;.</source>
          <target state="translated">Здесь каждое &lt;code&gt;ValueI&lt;/code&gt; является значением по умолчанию для &lt;code&gt;FieldI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42052c3c2c41c15b35977cf7cbb047bcba82e64f" translate="yes" xml:space="preserve">
          <source>Here follows a client side example, divide into several steps for readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbca54b367e1a4f6983365c6ace0c9e807f6a44" translate="yes" xml:space="preserve">
          <source>Here follows a description of the variables that are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4292ce9c08f629230d2ca9c9a4b58e4451d521bd" translate="yes" xml:space="preserve">
          <source>Here follows a series of examples ranging from simple to more complex.</source>
          <target state="translated">Далее следует серия примеров от простых до более сложных.</target>
        </trans-unit>
        <trans-unit id="7de541520f50013aebeb6484b87ccc69628a3a4f" translate="yes" xml:space="preserve">
          <source>Here follows a simple example of turning a gen_fsm into a &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt;. The example comes from the previous Users Guide for &lt;code&gt;gen_fsm&lt;/code&gt;</source>
          <target state="translated">Вот простой пример превращения gen_fsm в &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; . Пример &lt;code&gt;gen_fsm&lt;/code&gt; из предыдущего Руководства пользователя для gen_fsm.</target>
        </trans-unit>
        <trans-unit id="056d3b9258e32cd2a4368560fe9287c17631f021" translate="yes" xml:space="preserve">
          <source>Here follows a simple test specification example:</source>
          <target state="translated">Ниже приведен простой пример спецификации теста:</target>
        </trans-unit>
        <trans-unit id="d1a5f798f4fca1457852fb5ded06b31390f422db" translate="yes" xml:space="preserve">
          <source>Here follows a summary of the settings affecting Unicode:</source>
          <target state="translated">Ниже приведена краткая информация о настройках,влияющих на Юникод:</target>
        </trans-unit>
        <trans-unit id="e3b0266f7e1ec5f16aeffe2f3cad390ea2d7f486" translate="yes" xml:space="preserve">
          <source>Here follows all types that are allowed to be used in operands for instructions being constructed on the right side of a transformation rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f3b865fe0de9bfe34af31066b4e1fd4775070c" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty printed, well indented version with long keywords:</source>
          <target state="translated">Ниже приведен пример текстового сообщения,чтобы дать представление о разнице между симпатичной и компактной версией текстового сообщения.Сначала симпатичная печатная,хорошо отпечатанная версия с длинными ключевыми словами:</target>
        </trans-unit>
        <trans-unit id="7f638f5d7f0c6d062a7666cb5822d5e70a90f9fb" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty, well indented version with long keywords:</source>
          <target state="translated">Ниже приведен пример текстового сообщения,чтобы дать представление о разнице между симпатичной и компактной версией текстового сообщения.Сначала симпатичная,хорошо изрезанная версия с длинными ключевыми словами:</target>
        </trans-unit>
        <trans-unit id="63d190124d61370d24019073f53f96c2b39b3a1c" translate="yes" xml:space="preserve">
          <source>Here follows some questions that you might have after reading this section with corresponding tips and links to the answers:</source>
          <target state="translated">Здесь следуют некоторые вопросы,которые могут возникнуть у вас после прочтения этого раздела с соответствующими советами и ссылками на ответы:</target>
        </trans-unit>
        <trans-unit id="bbd3c491062bf2c5eaa657373046fe305f85357c" translate="yes" xml:space="preserve">
          <source>Here follows the details of what exactly is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5e0247c5bebffe1acdce6f9b2820393133d959" translate="yes" xml:space="preserve">
          <source>Here follows the function of the old API. These functions only work on a list of Latin-1 characters.</source>
          <target state="translated">Здесь следует функция старого API.Эти функции работают только со списком символов латинского алфавита.</target>
        </trans-unit>
        <trans-unit id="1e03b2fb11709d9ee5694c2236ecb3d219a8b412" translate="yes" xml:space="preserve">
          <source>Here follows the general configuration terms that are allowed in a cover specification file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7402642ba6204e4b5e86065a76f140fdda43cbe" translate="yes" xml:space="preserve">
          <source>Here follows the type letters that more or less directly corresponds to the types for generic instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3bb36613c3cfade2e1099d8162ab6ab7c75926" translate="yes" xml:space="preserve">
          <source>Here follows type definitions that are used by more than one function in the ODBC API.</source>
          <target state="translated">Здесь следуют определения типов,которые используются более чем одной функцией в ODBC API.</target>
        </trans-unit>
        <trans-unit id="4cdd0b6622fc9da41960fdfdea1968c18c462ed7" translate="yes" xml:space="preserve">
          <source>Here is a bit more complex calculation:</source>
          <target state="translated">Вот немного более сложный расчет:</target>
        </trans-unit>
        <trans-unit id="f4538b53d8767dd2d98b8e1093b19420fc4852f6" translate="yes" xml:space="preserve">
          <source>Here is a complete example. The &lt;code&gt;new_map&lt;/code&gt; instruction is defined like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d349cc2e55bbdec82aca8231149986fa8cec97cd" translate="yes" xml:space="preserve">
          <source>Here is a function call as &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; as the argument to the function &lt;code&gt;print_temp&lt;/code&gt;. When function calls are &lt;strong&gt;nested&lt;/strong&gt; like this, they execute (evaluate) from the inside out. That is, first &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; is evaluated, which gives the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; as the temperature is already in Celsius. Then &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; is evaluated. The function &lt;code&gt;convert_to_celsius&lt;/code&gt; works in a similar way to the &lt;code&gt;convert_length&lt;/code&gt; function in the previous example.</source>
          <target state="translated">Вот вызов функции &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; в качестве аргумента функции &lt;code&gt;print_temp&lt;/code&gt; . Когда вызовы функций так &lt;strong&gt;вложены&lt;/strong&gt; , они выполняются (оцениваются) изнутри. То есть сначала &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; , что дает значение &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; , поскольку температура уже находится в градусах Цельсия. Затем &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; . Функция &lt;code&gt;convert_to_celsius&lt;/code&gt; работает аналогично функции &lt;code&gt;convert_length&lt;/code&gt; в предыдущем примере.</target>
        </trans-unit>
        <trans-unit id="7b73ef99e7403f3927ff26a039c6e2a2236690f9" translate="yes" xml:space="preserve">
          <source>Here is a list of some of the MIBs defined in the OTP system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22821c0d8cd96a6861d0a1d65f8c0f8148458395" translate="yes" xml:space="preserve">
          <source>Here is a more complete sequence that contains both adding, updating and removing breakpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72c798b29ccb529841e5627093d7a56fd4814a8" translate="yes" xml:space="preserve">
          <source>Here is an example how the reserved virtual address space for literals can be raised to 2 GB (2048 MB):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba858455c144cf3056c405c091e7501e673c5076" translate="yes" xml:space="preserve">
          <source>Here is an example of a suitable expression sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e38b026becd87996568d41fcc3b8f1d79752be" translate="yes" xml:space="preserve">
          <source>Here is an example of this option:</source>
          <target state="translated">Вот пример этого варианта:</target>
        </trans-unit>
        <trans-unit id="3f74118ff53b9ac72b1f1d3c138c82f074dbcd87" translate="yes" xml:space="preserve">
          <source>Here is an example showing how values can be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09da04e514cbcbfa274d3aa81a9da1bf964eb8e" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to count how many times each instruction is executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17a454a258af8149a5983e38860d0dd63592107" translate="yes" xml:space="preserve">
          <source>Here is an example. The config-file has the following contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a08ca8184b592a01eaaa55a20f8527f4cca1b8" translate="yes" xml:space="preserve">
          <source>Here is an overview what has been done so far:</source>
          <target state="translated">Вот обзор того,что было сделано до сих пор:</target>
        </trans-unit>
        <trans-unit id="368746ba7f8d7397bdc8b79dac1f30fb770a5d1c" translate="yes" xml:space="preserve">
          <source>Here is defined a function that doubles the value of a number and assigned this function to a variable. Thus &lt;code&gt;Xf(5)&lt;/code&gt; returns value 10. Two useful functions when working with lists are &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;, which are defined as follows:</source>
          <target state="translated">Здесь определена функция, которая удваивает значение числа и присваивает эту функцию переменной. Таким образом, &lt;code&gt;Xf(5)&lt;/code&gt; возвращает значение 10. Две полезные функции при работе со списками - это &lt;code&gt;foreach&lt;/code&gt; и &lt;code&gt;map&lt;/code&gt; , которые определены следующим образом:</target>
        </trans-unit>
        <trans-unit id="7ce731a790a4205763d05d03b9cf196ef4e9261e" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using a generic time-out named for example &lt;code&gt;open&lt;/code&gt;:</source>
          <target state="translated">Вот как выполнить тайм-аут состояния в предыдущем примере, вместо этого используя общий тайм-аут с именем, например, &lt;code&gt;open&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a0d2cc3be9345b9bae90d4c70bae158e4ffa9f78" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using an Erlang Timer:</source>
          <target state="translated">Вот как выполнить тайм-аут состояния в предыдущем примере,вместо этого используя таймер Эрланга:</target>
        </trans-unit>
        <trans-unit id="eaf5ed4c0dabc7f41cc89c5f4a3aa5a863561e75" translate="yes" xml:space="preserve">
          <source>Here is only considered the case when Erlang/OTP is running on a UNIX system.</source>
          <target state="translated">Здесь рассматривается только случай,когда Erlang/OTP запущен на UNIX системе.</target>
        </trans-unit>
        <trans-unit id="5522fd885b43a2eff23d532ec8cfc36c8effcd85" translate="yes" xml:space="preserve">
          <source>Here is the definition of &lt;code&gt;deallocate_return/1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f17fc708829cfc6fb00458e5b09fdb85b5ef940" translate="yes" xml:space="preserve">
          <source>Here is the ping pong example modified to run on two separate nodes:</source>
          <target state="translated">Вот пример пинг-понга,модифицированный для запуска на двух отдельных узлах:</target>
        </trans-unit>
        <trans-unit id="36bfcb0b8532e087fad81f46e3b585565729333b" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all key expressions evalute successfully and all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274b953d352c36df895d0e17f80b41429f1a2865" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="translated">Здесь ключи &lt;code&gt;K1 .. Kn&lt;/code&gt; - любые выражения с литералами или связанные переменные. Если все ключи существуют в карте &lt;code&gt;M&lt;/code&gt; , все переменные в &lt;code&gt;V1 .. Vn&lt;/code&gt; сопоставляются со связанными значениями их соответствующих ключей.</target>
        </trans-unit>
        <trans-unit id="69f329541992e8d01a4e5a912d3401c2919e27cf" translate="yes" xml:space="preserve">
          <source>Here more than one list is built. In each iteration step a new list is created that is one element longer than the new previous list.</source>
          <target state="translated">Здесь построен не один список.На каждом шаге итерации создается новый список,который на один элемент длиннее нового предыдущего списка.</target>
        </trans-unit>
        <trans-unit id="4207694f60edbd73e98081488a51ba1699a0f859" translate="yes" xml:space="preserve">
          <source>Here only the Kernel and STDLIB applications are started, that is, the system is started as an ordinary development system. Only two files are needed for all this to work:</source>
          <target state="translated">Здесь запускаются только приложения Kernel и STDLIB,то есть система запускается как обычная система разработки.Для того,чтобы все это работало,нужно только два файла:</target>
        </trans-unit>
        <trans-unit id="1a01cbab019a5244984e7111de8ade2f66f53c2f" translate="yes" xml:space="preserve">
          <source>Here some initialization is done, &lt;code&gt;start&lt;/code&gt; is called from &lt;code&gt;open_port&lt;/code&gt;. The data will be passed to &lt;code&gt;control&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">Здесь выполняется некоторая инициализация, &lt;code&gt;start&lt;/code&gt; вызывается из &lt;code&gt;open_port&lt;/code&gt; . Данные будут переданы в &lt;code&gt;control&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dd38392b306d639490f3bfdab336a2923914d6c" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;is_eq_exact&lt;/code&gt; instruction is replaced with a specialized instruction that only compares literals, but only if the first operand is a register and the second operand is a literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8285a3adddfb3c22982d47841765517ced8bef67" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;start/0&lt;/code&gt; function,</source>
          <target state="translated">Здесь функция &lt;code&gt;start/0&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6d1513bbb3276cbd3a38ec95089202ddef094a3d" translate="yes" xml:space="preserve">
          <source>Here the Ti's are atoms (the name of the type) and the Ai's are their arguments</source>
          <target state="translated">Здесь Ti-это атомы (имя типа),а Ai-их аргументы.</target>
        </trans-unit>
        <trans-unit id="9acec98c2e5c443462282bed38bd34c514085f2c" translate="yes" xml:space="preserve">
          <source>Here the call to the GC BIF &lt;code&gt;'+'/2&lt;/code&gt; will be replaced with the instruction &lt;code&gt;gen_plus/5&lt;/code&gt;. Note that the same name as used in the C source code must be used for the BIF, which in this case is &lt;code&gt;splus&lt;/code&gt;. It is defined like this in &lt;code&gt;bit.tab&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b79b4c75297735efc429805d3857e3fd989ff1f" translate="yes" xml:space="preserve">
          <source>Here the concept of an &lt;strong&gt;anonymous variable&lt;/strong&gt; &quot;_&quot; is introduced. This is simply shorthand for a variable that gets a value, but the value is ignored. This can be used anywhere suitable, not just in funs. &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Temp1&lt;/code&gt; is less than &lt;code&gt;Temp2&lt;/code&gt;.</source>
          <target state="translated">Здесь вводится понятие &lt;strong&gt;анонимной переменной&lt;/strong&gt; &amp;laquo;_&amp;raquo;. Это просто сокращение для переменной, которая получает значение, но значение игнорируется. Его можно использовать где угодно, а не только в развлечениях. &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;Temp1&lt;/code&gt; меньше &lt;code&gt;Temp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af3c6eb665702670ccab0184a2424627dfa000a9" translate="yes" xml:space="preserve">
          <source>Here the empty binary (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;) represents the unassigned subpattern. In the &lt;code&gt;binary&lt;/code&gt; case, some information about the matching is therefore lost, as &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can also be an empty string captured.</source>
          <target state="translated">Здесь пустой двоичный файл ( &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ) представляет неназначенный подшаблон. В &lt;code&gt;binary&lt;/code&gt; случае некоторая информация о сопоставлении теряется, так как &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; также может быть захваченной пустой строкой.</target>
        </trans-unit>
        <trans-unit id="1abd874c2e02ed54ed46fd6eb351fd6b4434ff43" translate="yes" xml:space="preserve">
          <source>Here the file I/O server returns all available options for a file, which are the expected ones, &lt;code&gt;encoding&lt;/code&gt; and &lt;code&gt;binary&lt;/code&gt;. However, the standard shell has some more options:</source>
          <target state="translated">Здесь сервер ввода-вывода файла возвращает все доступные параметры для файла, которые являются ожидаемыми, &lt;code&gt;encoding&lt;/code&gt; и &lt;code&gt;binary&lt;/code&gt; кодом . Однако в стандартной оболочке есть еще несколько опций:</target>
        </trans-unit>
        <trans-unit id="e6b28a4e54bbbd54cef63a1e3115ada96bc39316" translate="yes" xml:space="preserve">
          <source>Here the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; in module &lt;code&gt;tut1&lt;/code&gt; is called with argument &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Здесь функция &lt;code&gt;fac&amp;gt;&lt;/code&gt; в модуле &lt;code&gt;tut1&lt;/code&gt; вызывается с аргументом &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0d195818a01c51c6fa746b1e3cba1a090681218" translate="yes" xml:space="preserve">
          <source>Here the key to be retrieved is constructed from an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e0ad7418ef3374cc17d038856a722ae97d8a0c" translate="yes" xml:space="preserve">
          <source>Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found.</source>
          <target state="translated">Здесь регулярное выражение сначала совпадает с &quot;l&quot;,что приводит к тому,что &quot;Er&quot; является первой частью результата.Когда регулярное выражение совпадает,(единственное)подвыражение привязывается к &quot;l&quot;,поэтому &quot;l&quot; вставляется в группу вместе с &quot;Er&quot;.Следующее совпадение-&quot;n&quot;,что делает &quot;a&quot; следующей частью,подлежащей возврату.Так как подвыражение в этом случае привязано к подстроке &quot;n&quot;,то &quot;n&quot; вставляется в эту группу.Последняя группа состоит из оставшейся строки,так как больше никаких совпадений не найдено.</target>
        </trans-unit>
        <trans-unit id="1da2c5952d714e65a29c19457fda0a08e5b2194a" translate="yes" xml:space="preserve">
          <source>Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long:</source>
          <target state="translated">Здесь возвращаемое значение соответственно указывает на всю строку,начинающуюся с индекса 0,и имеет длину 10 символов:</target>
        </trans-unit>
        <trans-unit id="8a03dce83b236db4e1a3d7678c31aea14b2cf2d3" translate="yes" xml:space="preserve">
          <source>Here the second operand of &lt;code&gt;move&lt;/code&gt; is constrained to be X register 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8588926d91ef055e0e752b5cc02d17b611653864" translate="yes" xml:space="preserve">
          <source>Here the shell detects lists containing printable characters or binaries containing printable characters in bytewise or UTF-8 encoding. But what is a printable character? One view is that anything the Unicode standard thinks is printable, is also printable according to the heuristic detection. The result is then that almost any list of integers are deemed a string, and all sorts of characters are printed, maybe also characters that your terminal lacks in its font set (resulting in some unappreciated generic output). Another way is to keep it backward compatible so that only the ISO Latin-1 character set is used to detect a string. A third way is to let the user decide exactly what Unicode ranges that are to be viewed as characters.</source>
          <target state="translated">Здесь оболочка обнаруживает списки,содержащие печатаемые символы или двоичные файлы,содержащие печатаемые символы в байтовой или UTF-8 кодировке.Но что такое печатаемый символ? Согласно одной из точек зрения,все,что стандарт Юникод считает печатаемым,также может быть распечатано в соответствии с эвристическим определением.В результате почти любой список целых чисел считается строкой,и печатаются всевозможные символы,возможно,также символы,которых не хватает в наборе шрифтов вашего терминала (что приводит к некоторому недооцененному общему выводу).Другой способ-сохранить обратную совместимость,чтобы для обнаружения строки использовался только набор символов ISO Latin-1.Третий способ-позволить пользователю решать,какие именно диапазоны Юникода следует рассматривать как символы.</target>
        </trans-unit>
        <trans-unit id="74160bc743886e5a3198a381b4d2136a5e539152" translate="yes" xml:space="preserve">
          <source>Here the signature and message in the last example is verifyed using the public key. The public key is stored in an engine, only to exemplify that it is possible. The public key could of course be handled openly as usual.</source>
          <target state="translated">Здесь подпись и сообщение в последнем примере проверяются с помощью открытого ключа.Открытый ключ хранится в движке,только для того,чтобы показать,что это возможно.Конечно же,с открытым ключом можно обращаться открыто,как обычно.</target>
        </trans-unit>
        <trans-unit id="d2d4f1fdcedde1498c2f363b018c87e4697de1db" translate="yes" xml:space="preserve">
          <source>Here the user flag &lt;code&gt;-myflag 1&lt;/code&gt; is passed to and stored by the &lt;code&gt;init&lt;/code&gt; process. It is a user-defined flag, presumably used by some user-defined application.</source>
          <target state="translated">Здесь пользовательский флаг &lt;code&gt;-myflag 1&lt;/code&gt; передается процессу &lt;code&gt;init&lt;/code&gt; и сохраняется им . Это определяемый пользователем флаг, предположительно используемый некоторым пользовательским приложением.</target>
        </trans-unit>
        <trans-unit id="402b80a6663c605b1c8ebefde4ea19bbe39ddf28" translate="yes" xml:space="preserve">
          <source>Here we also handle the mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;) that can be set by request &lt;code&gt;setopts&lt;/code&gt;. By default, all OTP I/O servers send data back to the client as lists, but switching mode to &lt;code&gt;binary&lt;/code&gt; can increase efficiency if the I/O server handles it in an appropriate way. The implementation of &lt;code&gt;get_until&lt;/code&gt; is difficult to get efficient, as the supplied function is defined to take lists as arguments, but &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; can be optimized for binary mode. However, this example does not optimize anything.</source>
          <target state="translated">Здесь мы также обрабатываем режим ( &lt;code&gt;binary&lt;/code&gt; или &lt;code&gt;list&lt;/code&gt; ), который может быть установлен с помощью &lt;code&gt;setopts&lt;/code&gt; запроса . По умолчанию все серверы ввода-вывода OTP отправляют данные обратно клиенту в виде списков, но переключение режима на &lt;code&gt;binary&lt;/code&gt; может повысить эффективность, если сервер ввода-вывода обрабатывает их соответствующим образом. Реализацию &lt;code&gt;get_until&lt;/code&gt; сложно добиться эффективной, поскольку предоставленная функция определена так, чтобы принимать списки в качестве аргументов, но &lt;code&gt;get_chars&lt;/code&gt; и &lt;code&gt;get_line&lt;/code&gt; могут быть оптимизированы для двоичного режима. Однако этот пример ничего не оптимизирует.</target>
        </trans-unit>
        <trans-unit id="713d45f85233ed9eece81ff1efd22a57b2efbd58" translate="yes" xml:space="preserve">
          <source>Here we check the result from postgres. If it is data, we encode it as lists of lists with column data. Everything from postgres is C strings, so we use &lt;code&gt;ei_x_encode_string&lt;/code&gt; to send the result as strings to Erlang. (The head of the list contains the column names.)</source>
          <target state="translated">Здесь мы проверяем результат postgres. Если это данные, мы кодируем их как списки списков с данными столбца. Все из postgres - это строки C, поэтому мы используем &lt;code&gt;ei_x_encode_string&lt;/code&gt; , чтобы отправить результат в виде строк в Erlang. (Заголовок списка содержит имена столбцов.)</target>
        </trans-unit>
        <trans-unit id="8cf9c63e747cf336dd3ef22dd8cb27c624c36fc6" translate="yes" xml:space="preserve">
          <source>Here we create an archive script containing both Erlang code and Beam code, then we iterate over all files in the archive and collect their contents and some information about them:</source>
          <target state="translated">Здесь мы создаем архивный скрипт,содержащий как Erlang код,так и Beam код,затем мы выполняем итерацию по всем файлам в архиве и собираем их содержимое и некоторую информацию о них:</target>
        </trans-unit>
        <trans-unit id="1a6714f5fe50c9a6bae77694ae3f43b0dac16cb9" translate="yes" xml:space="preserve">
          <source>Here we create file named &lt;code&gt;TAGS&lt;/code&gt; placed it in the directory &lt;code&gt;../projectdir&lt;/code&gt;. The file contains information about the functions, records, and macro definitions of the three files.</source>
          <target state="translated">Здесь мы создаем файл с именем &lt;code&gt;TAGS&lt;/code&gt; и помещаем его в каталог &lt;code&gt;../projectdir&lt;/code&gt; . Файл содержит информацию о функциях, записях и определениях макросов трех файлов.</target>
        </trans-unit>
        <trans-unit id="9874d5ad87ce020d9aa6aeca71513d4b4236fc2e" translate="yes" xml:space="preserve">
          <source>Here we have cheated a little by more or less only implementing &lt;code&gt;get_until&lt;/code&gt; and using internal helpers to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt;. In production code, this can be inefficient, but that depends on the frequency of the different requests. Before we start implementing functions &lt;code&gt;put_chars/2&lt;/code&gt; and &lt;code&gt;get_until/5&lt;/code&gt;, we examine the few remaining requests:</source>
          <target state="translated">Здесь мы немного обманули, более или менее реализовав только &lt;code&gt;get_until&lt;/code&gt; и используя внутренние помощники для реализации &lt;code&gt;get_chars&lt;/code&gt; и &lt;code&gt;get_line&lt;/code&gt; . В производственном коде это может быть неэффективно, но это зависит от частоты различных запросов. Прежде чем мы начнем реализовывать функции &lt;code&gt;put_chars/2&lt;/code&gt; и &lt;code&gt;get_until/5&lt;/code&gt; , мы исследуем несколько оставшихся запросов:</target>
        </trans-unit>
        <trans-unit id="6510718f8630e547e008ebde09d2abc7f3c89e66" translate="yes" xml:space="preserve">
          <source>Here we see that no function distinguishes itself considerably, which is very normal.</source>
          <target state="translated">Здесь мы видим,что ни одна функция не выделяется существенно,что очень нормально.</target>
        </trans-unit>
        <trans-unit id="465ac4aff2d9132b9905c273ca86662ca9c4c44b" translate="yes" xml:space="preserve">
          <source>Here we will show how &lt;code&gt;i_increment&lt;/code&gt; can be implemented as a combined instruction. We will show each individual fragment first, and then show how to connect them together. First we will need a variable that we can store the value fetched from the register in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf2aac2ad0fe378997e3d3e60e43ee8d81edf6f" translate="yes" xml:space="preserve">
          <source>Here you see the use of &lt;code&gt;|&lt;/code&gt; to get the first two elements from the list. If you try to get more elements from the list than there are elements in the list, an error is returned. Notice also the special case of the list with no elements, []:</source>
          <target state="translated">Здесь вы видите использование &lt;code&gt;|&lt;/code&gt; чтобы получить первые два элемента из списка. Если вы попытаетесь получить больше элементов из списка, чем имеется в списке, возвращается ошибка. Также обратите внимание на особый случай списка без элементов, []:</target>
        </trans-unit>
        <trans-unit id="08b89fd2c7d9c7d70984a33c283c54baceee4244" translate="yes" xml:space="preserve">
          <source>Here's another example:</source>
          <target state="translated">Вот еще один пример:</target>
        </trans-unit>
        <trans-unit id="7996ce3c70bc2e6c31030c0947978923388510ef" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are any expressions and &lt;code&gt;M0&lt;/code&gt; through &lt;code&gt;M4&lt;/code&gt; are the resulting map terms.</source>
          <target state="translated">Здесь &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; - любые выражения, а от &lt;code&gt;M0&lt;/code&gt; до &lt;code&gt;M4&lt;/code&gt; - результирующие термины карты.</target>
        </trans-unit>
        <trans-unit id="c7c0f63e6feeafed42e889764b5df7fa6ae6b07c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Arguments&lt;/code&gt; is a list of zero or more arguments. The &lt;code&gt;-callback&lt;/code&gt; attribute is to be preferred since the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">Здесь &lt;code&gt;Arguments&lt;/code&gt; - это список из нуля или более аргументов. &lt;code&gt;-callback&lt;/code&gt; атрибут является предпочтительным , так как информация дополнительного типа может использоваться инструментами для получения документации или найти несоответствие.</target>
        </trans-unit>
        <trans-unit id="2f63ec204ef51669a64a9412596d13bb3d314da9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Bin&lt;/code&gt; is bound and the elements are bound or unbound, as in any match.</source>
          <target state="translated">Здесь &lt;code&gt;Bin&lt;/code&gt; привязан, а элементы привязаны или не привязаны, как и в любом совпадении.</target>
        </trans-unit>
        <trans-unit id="973cdf584bee5b3aebaf02a66418e8e39a601f3c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Expr&lt;/code&gt; is an arbitrary expression, and each &lt;code&gt;Qualifier&lt;/code&gt; is either a generator or a filter.</source>
          <target state="translated">Здесь &lt;code&gt;Expr&lt;/code&gt; - произвольное выражение, а каждый &lt;code&gt;Qualifier&lt;/code&gt; - либо генератор, либо фильтр.</target>
        </trans-unit>
        <trans-unit id="bfa551fd993d5a7e252540038e550aefce8b5242" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Fd&lt;/code&gt; is the file descriptor for the destination file, or the atom &lt;code&gt;standard_io&lt;/code&gt;. &lt;code&gt;_TraceInfo&lt;/code&gt; contains information from the trace information file (see section &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;State&lt;/code&gt; is a state variable for the format handler fun. The initial value of variable &lt;code&gt;State&lt;/code&gt; is specified with the handler option, for example:</source>
          <target state="translated">Здесь &lt;code&gt;Fd&lt;/code&gt; - это файловый дескриптор для файла назначения или атом &lt;code&gt;standard_io&lt;/code&gt; . &lt;code&gt;_TraceInfo&lt;/code&gt; содержит информацию из файла информации о трассировке (см. Раздел &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;State&lt;/code&gt; - это переменная состояния для развлечения обработчика формата. Начальное значение переменной &lt;code&gt;State&lt;/code&gt; задается опцией обработчика, например:</target>
        </trans-unit>
        <trans-unit id="034cc33bbe80f01fd04e26b576b575b1176dd3da" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;File&lt;/code&gt; is used as the new variable instead of &lt;code&gt;X&lt;/code&gt;. This is not so wise because code in the fun body cannot refer to the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside of the fun. Compiling this example gives the following diagnostic:</source>
          <target state="translated">Здесь &lt;code&gt;File&lt;/code&gt; используется в качестве новой переменной вместо &lt;code&gt;X&lt;/code&gt; . Это не так разумно, потому что код в теле fun не может ссылаться на переменную &lt;code&gt;File&lt;/code&gt; , которая определена вне fun. Компиляция этого примера дает следующую диагностику:</target>
        </trans-unit>
        <trans-unit id="5adef5db9dcd73f5eebe767f23b82b503f930844" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S1LogDir&lt;/code&gt; and &lt;code&gt;S2LogDir&lt;/code&gt; are the directories named &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; for each test respectively.</source>
          <target state="translated">Здесь &lt;code&gt;S1LogDir&lt;/code&gt; и &lt;code&gt;S2LogDir&lt;/code&gt; - это каталоги с именем &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; для каждого теста соответственно.</target>
        </trans-unit>
        <trans-unit id="eb55d7bcff03863047df1e0e245a8ad25b9600d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;conn_types&lt;/code&gt; specifies SSH, Telnet, FTP, RPC, and/or SNMP.</source>
          <target state="translated">Здесь &lt;code&gt;conn_types&lt;/code&gt; указывает SSH, Telnet, FTP, RPC и / или SNMP.</target>
        </trans-unit>
        <trans-unit id="4daf6d3bc463f7669637809f88efe649c2ac2625" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo()&lt;/code&gt; evaluates to &lt;code&gt;&quot;Robert&quot;&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;demo()&lt;/code&gt; оценивается как &lt;code&gt;&quot;Robert&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fefc36dd07702f1db04b9023b0ea8fdf578263c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;init&lt;/code&gt; does not need any input data and ignores its argument. For &lt;code&gt;terminal_logger&lt;/code&gt;, the internal state is not used. For &lt;code&gt;file_logger&lt;/code&gt;, the internal state is used to save the open file descriptor.</source>
          <target state="translated">Здесь &lt;code&gt;init&lt;/code&gt; не требует никаких входных данных и игнорирует свой аргумент. Для &lt;code&gt;terminal_logger&lt;/code&gt; внутреннее состояние не используется. Для &lt;code&gt;file_logger&lt;/code&gt; внутреннее состояние используется для сохранения дескриптора открытого файла.</target>
        </trans-unit>
        <trans-unit id="aba5e0fd19010e47f153b1c0f6d8f4209d232205" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tuplep&lt;/code&gt; points to an &lt;code&gt;ETERM&lt;/code&gt; struct representing a tuple with two elements; the function name (atom) and the argument (integer). Using the function &lt;code&gt;erl_element()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;, these elements can be extracted, but they must also be declared as pointers to an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">Здесь &lt;code&gt;tuplep&lt;/code&gt; указывает на структуру &lt;code&gt;ETERM&lt;/code&gt; , представляющую кортеж с двумя элементами; имя функции (атом) и аргумент (целое число). Используя функцию &lt;code&gt;erl_element()&lt;/code&gt; из &lt;code&gt;erl_eterm&lt;/code&gt; , эти элементы можно извлечь, но они также должны быть объявлены как указатели на структуру &lt;code&gt;ETERM&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3c764964387488a9567355a791b642a791153d46" translate="yes" xml:space="preserve">
          <source>Here, the communication with C is hidden in the implementation of &lt;code&gt;complex.erl&lt;/code&gt;. In the following sections, it is shown how this module can be implemented using the different interoperability mechanisms.</source>
          <target state="translated">Здесь связь с C скрыта в реализации &lt;code&gt;complex.erl&lt;/code&gt; . В следующих разделах показано, как этот модуль может быть реализован с использованием различных механизмов взаимодействия.</target>
        </trans-unit>
        <trans-unit id="a9363a371565a254c5f940c661f77bc4aea0306a" translate="yes" xml:space="preserve">
          <source>Here, the data type &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; is represented as the following Erlang record:</source>
          <target state="translated">Здесь тип данных &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; представлен в виде следующей записи Erlang:</target>
        </trans-unit>
        <trans-unit id="27fe64fbf8e84fafc5f91f9a5e3d6acc46a097cf" translate="yes" xml:space="preserve">
          <source>Here, the directive &lt;code&gt;on_load&lt;/code&gt; is used to get function &lt;code&gt;init&lt;/code&gt; to be automatically called when the module is loaded. If &lt;code&gt;init&lt;/code&gt; returns anything other than &lt;code&gt;ok&lt;/code&gt;, such when the loading of the NIF library fails in this example, the module is unloaded and calls to functions within it, fail.</source>
          <target state="translated">Здесь директива &lt;code&gt;on_load&lt;/code&gt; используется для автоматического вызова функции &lt;code&gt;init&lt;/code&gt; при загрузке модуля. Если &lt;code&gt;init&lt;/code&gt; возвращает что-либо, кроме &lt;code&gt;ok&lt;/code&gt; , например, когда загрузка библиотеки NIF в этом примере не удалась, модуль выгружается и вызовы функций в нем завершаются ошибкой.</target>
        </trans-unit>
        <trans-unit id="6256ecd948c793aa1993c3c12236863caa0abcfe" translate="yes" xml:space="preserve">
          <source>Here, the handler also provides for dynamically reloading of configuration variables. If &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; is called from the test case function, all variables loaded with &lt;code&gt;config_driver:read_config/1&lt;/code&gt; are updated with their latest values, and the new value for variable &lt;code&gt;localtime&lt;/code&gt; is returned.</source>
          <target state="translated">Здесь обработчик также обеспечивает динамическую перезагрузку переменных конфигурации. Если &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; вызывается из функции тестового примера, все переменные, загруженные с помощью &lt;code&gt;config_driver:read_config/1&lt;/code&gt; , обновляются с их последними значениями, и возвращается новое значение переменной &lt;code&gt;localtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9736652812b2b809017435f7a09559dc888bc0b" translate="yes" xml:space="preserve">
          <source>Here, the same test run as in the previous examples are executed (and possibly repeated). However, when the time-out occurs, after 1 hour, &lt;code&gt;Common Test&lt;/code&gt; finishes the entire test run before stopping (that is, both &lt;code&gt;to1&lt;/code&gt; and &lt;code&gt;to2&lt;/code&gt; are always executed in the same test run).</source>
          <target state="translated">Здесь выполняется тот же тестовый прогон, что и в предыдущих примерах (и, возможно, повторяется). Однако, когда истекает тайм-аут, через 1 час &lt;code&gt;Common Test&lt;/code&gt; завершает весь тестовый прогон перед остановкой (то есть и &lt;code&gt;to1&lt;/code&gt; , и &lt;code&gt;to2&lt;/code&gt; всегда выполняются в одном и том же тестовом прогоне).</target>
        </trans-unit>
        <trans-unit id="3cf47ffc88aa174995add08f4cbe16924d5664a9" translate="yes" xml:space="preserve">
          <source>Here, the same tests as in Example 1 are run, but with flag &lt;code&gt;force_stop&lt;/code&gt; set to &lt;code&gt;skip_rest&lt;/code&gt;. If time-out occurs while executing tests in directory &lt;code&gt;to1&lt;/code&gt;, the remaining test cases in &lt;code&gt;to1&lt;/code&gt; are skipped and the test is aborted without running the tests in &lt;code&gt;to2&lt;/code&gt; another time. If time-out occurs while executing tests in directory &lt;code&gt;to2&lt;/code&gt;, the remaining test cases in &lt;code&gt;to2&lt;/code&gt; are skipped and the test is aborted.</source>
          <target state="translated">Здесь выполняются те же тесты, что и в Примере 1, но с флагом &lt;code&gt;force_stop&lt;/code&gt; , установленным в &lt;code&gt;skip_rest&lt;/code&gt; . Если тайм-аут происходит при выполнении тестов в каталоге &lt;code&gt;to1&lt;/code&gt; , оставшиеся тестовые случаи в &lt;code&gt;to1&lt;/code&gt; пропускаются, и тест прерывается без выполнения тестов в &lt;code&gt;to2&lt;/code&gt; в другой раз. Если время ожидания истекает при выполнении тестов в каталоге &lt;code&gt;to2&lt;/code&gt; , оставшиеся тестовые примеры в &lt;code&gt;to2&lt;/code&gt; пропускаются, и тест прерывается.</target>
        </trans-unit>
        <trans-unit id="8725eccd38a40d0e24f360a6bca5f39b565b9081" translate="yes" xml:space="preserve">
          <source>Here, the segment corresponding to the &lt;code&gt;Opts&lt;/code&gt; variable has a &lt;strong&gt;type modifier&lt;/strong&gt;, specifying that &lt;code&gt;Opts&lt;/code&gt; is to bind to a binary. All other variables have the default type equal to unsigned integer.</source>
          <target state="translated">Здесь сегмент, соответствующий переменной &lt;code&gt;Opts&lt;/code&gt; , имеет &lt;strong&gt;модификатор типа&lt;/strong&gt; , указывающий, что &lt;code&gt;Opts&lt;/code&gt; должен связываться с двоичным файлом . Все остальные переменные имеют тип по умолчанию, равный целому числу без знака.</target>
        </trans-unit>
        <trans-unit id="38c740b102d15d34f934831a4b2e6f07729ae300" translate="yes" xml:space="preserve">
          <source>Here, the suites in test directory &lt;code&gt;to1&lt;/code&gt;, followed by the suites in &lt;code&gt;to2&lt;/code&gt;, are executed in one test run. A time-out event occurs after 10 minutes. As long as there is time left, &lt;code&gt;Common Test&lt;/code&gt; repeats the test run (that is, starting over with test &lt;code&gt;to1&lt;/code&gt;). After time-out, &lt;code&gt;Common Test&lt;/code&gt; stops when the current job is finished (because of flag &lt;code&gt;force_stop&lt;/code&gt;). As a result, the specified test run can be aborted after test &lt;code&gt;to1&lt;/code&gt; and before test &lt;code&gt;to2&lt;/code&gt;.</source>
          <target state="translated">Здесь комплекты в тестовом каталоге &lt;code&gt;to1&lt;/code&gt; , за которыми следуют комплекты в &lt;code&gt;to2&lt;/code&gt; , выполняются за один тестовый прогон. Событие тайм-аута происходит через 10 минут. Пока остается время, &lt;code&gt;Common Test&lt;/code&gt; повторяет тестовый прогон (то есть, начиная с теста &lt;code&gt;to1&lt;/code&gt; ). По истечении времени ожидания &lt;code&gt;Common Test&lt;/code&gt; останавливается по завершении текущего задания (из-за флага &lt;code&gt;force_stop&lt;/code&gt; ). В результате указанный тестовый прогон может быть прерван после теста &lt;code&gt;to1&lt;/code&gt; и перед тестом &lt;code&gt;to2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fe1239da690637d154f58466f31d750de5a7b" translate="yes" xml:space="preserve">
          <source>Here, the test run, including both the &lt;code&gt;to1&lt;/code&gt; and the &lt;code&gt;to2&lt;/code&gt; test, is repeated five times.</source>
          <target state="translated">Здесь тестовый прогон, включая тесты &lt;code&gt;to1&lt;/code&gt; и &lt;code&gt;to2&lt;/code&gt; , повторяется пять раз.</target>
        </trans-unit>
        <trans-unit id="52a7e5fe849b80f2c39e4eb11c178f9187a0c7ff" translate="yes" xml:space="preserve">
          <source>Here, the tests specified by &quot;ts1&quot; run first, then the tests specified by &quot;ts2&quot;, and finally the tests specified by both &quot;ts3&quot; and &quot;ts4&quot;.</source>
          <target state="translated">Здесь сначала выполняются тесты,указанные в &quot;ts1&quot;,затем тесты,указанные в &quot;ts2&quot;,и,наконец,тесты,указанные в &quot;ts3&quot; и &quot;ts4&quot;.</target>
        </trans-unit>
        <trans-unit id="872d6af667b9983eb38e96eba5f3443d21c88017" translate="yes" xml:space="preserve">
          <source>Here, the variable &lt;code&gt;X&lt;/code&gt;, defined in the head of the fun, is a new variable. The variable &lt;code&gt;Stream&lt;/code&gt;, which is used within the fun, gets its value from the &lt;code&gt;file:open&lt;/code&gt; line.</source>
          <target state="translated">Здесь переменная &lt;code&gt;X&lt;/code&gt; , определенная в заголовке игры, является новой переменной. Переменная &lt;code&gt;Stream&lt;/code&gt; , которая используется в игре, получает свое значение из &lt;code&gt;file:open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e0c04fa994ff203608b787f3eac3297ddf1fb91" translate="yes" xml:space="preserve">
          <source>Here, white text is used instead of the default black for &lt;code&gt;div.error&lt;/code&gt; printouts (and no other attribute settings for &lt;code&gt;pre&lt;/code&gt; are affected).</source>
          <target state="translated">Здесь белый текст используется вместо черного по умолчанию для распечаток &lt;code&gt;div.error&lt;/code&gt; (и никакие другие настройки атрибутов для &lt;code&gt;pre&lt;/code&gt; не затрагиваются).</target>
        </trans-unit>
        <trans-unit id="714626a23a6977a3ba1a4332c0cb63aa0f04303b" translate="yes" xml:space="preserve">
          <source>Here,&lt;code&gt;ERL_NIF_INIT&lt;/code&gt; has the following arguments:</source>
          <target state="translated">Здесь &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; имеет следующие аргументы:</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="ad89343a3d3c4ba891ac4b0730bfade95df05420" translate="yes" xml:space="preserve">
          <source>Heuristic Identification of UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3b73d033962cbf0bbbb6396f3106e5fadd47c5" translate="yes" xml:space="preserve">
          <source>Heuristic String Detection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6e39c49e52c38684133449dae27a843c8c9f66" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits</source>
          <target state="translated">шестнадцатеричные цифры</target>
        </trans-unit>
        <trans-unit id="01a101ab62a2560ab10ccb525aa4aba316d01a17" translate="yes" xml:space="preserve">
          <source>HiPE is automatically enabled on the following systems:</source>
          <target state="translated">HiPE автоматически включается в следующих системах:</target>
        </trans-unit>
        <trans-unit id="49e76954bbaf300a103840561af720f16c024018" translate="yes" xml:space="preserve">
          <source>HiPE supports the following system configurations:</source>
          <target state="translated">HiPE поддерживает следующие конфигурации системы:</target>
        </trans-unit>
        <trans-unit id="c5263066d763fc26b746c69fd8481a0f61325e1a" translate="yes" xml:space="preserve">
          <source>Hide menu:</source>
          <target state="translated">Скрыть меню:</target>
        </trans-unit>
        <trans-unit id="a02b1f8d870b852383550616297df9f10e5bc8ba" translate="yes" xml:space="preserve">
          <source>High fault tolerance</source>
          <target state="translated">Высокая отказоустойчивость</target>
        </trans-unit>
        <trans-unit id="fb49d95db3dc9749450850f23cb259dfa334590a" translate="yes" xml:space="preserve">
          <source>High-Level Instructions</source>
          <target state="translated">Инструкции высокого уровня</target>
        </trans-unit>
        <trans-unit id="e5a92cb9a3146c86050022c2169e16055f62bf41" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7116b5f034f81df6881fb6c021d526c89a62a5d" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322a5670551101a31a0c53538057253089ee212f" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">Максимально возможное &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; текущего монотонного источника времени ОС в частях в секунду. Если информация о разрешении не может быть получена из ОС, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; устанавливается на разрешение единицы времени возвращаемого значения &lt;code&gt;Function&lt;/code&gt; . То есть фактическое разрешение может быть ниже &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; . Обратите внимание, что разрешение ничего не говорит о &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; или о том, совпадает ли &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; с разрешением. Однако вы знаете, что точность не лучше, чем у &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fab9cfbcb573ef66eead85a0dd57991922c30f3e" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">Максимально возможное &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; текущего источника системного времени ОС в частях в секунду. Если информация о разрешении не может быть получена из ОС, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; устанавливается на разрешение единицы времени возвращаемого значения &lt;code&gt;Function&lt;/code&gt; . То есть реальное разрешение может быть ниже &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; . Обратите внимание, что разрешение ничего не говорит о &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; или о том, совпадает ли &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; с разрешением. Однако вы знаете, что точность не лучше, чем &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="b5e5ac0463ba83ccbf0cfb19cb8721b646cc77b2" translate="yes" xml:space="preserve">
          <source>Hmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Функции Hmac - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="e62704259a03fb1bde2c8d41669196ad51d0310c" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; can be used to change the &lt;code&gt;cth_conn_log&lt;/code&gt; behavior. The default value of this option is &lt;code&gt;raw&lt;/code&gt;, which results in the behavior described above. If the value is set to &lt;code&gt;html&lt;/code&gt;, all Telnet communication is printed to the test case HTML log instead.</source>
          <target state="translated">Опция &lt;code&gt;log_type&lt;/code&gt; может использоваться для изменения поведения &lt;code&gt;cth_conn_log&lt;/code&gt; . Значение по умолчанию для этой опции - &lt;code&gt;raw&lt;/code&gt; , что приводит к поведению, описанному выше. Если установлено значение &lt;code&gt;html&lt;/code&gt; , вместо этого все сообщения Telnet печатаются в журнале HTML тестового примера.</target>
        </trans-unit>
        <trans-unit id="e16590a1a84c1baec0f43c0dcc1d470ab6fb6020" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; specifies the type of logging:</source>
          <target state="translated">Опция &lt;code&gt;log_type&lt;/code&gt; указывает тип ведения журнала:</target>
        </trans-unit>
        <trans-unit id="2b7ba976df46f73b2bc0332579201ada04d174eb" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.</source>
          <target state="translated">Опции перехвата,указанные в конфигурационном файле,перезаписывают все жестко закодированные опции перехвата в тестовом наборе.</target>
        </trans-unit>
        <trans-unit id="e5130a72c3ee4bac41361eafe24a09e720b6ee4d" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.</source>
          <target state="translated">Опции перехвата,указанные в конфигурационном файле,перезаписывают жестко закодированные опции перехвата в тестовом наборе.</target>
        </trans-unit>
        <trans-unit id="5699a47d64ec5afff9a00f44aa11f36f6b5577a8" translate="yes" xml:space="preserve">
          <source>Hop-by-Hop and End-to-End Identifiers are set by diameter when sending outgoing requests.</source>
          <target state="translated">Идентификаторы Hop-by-Hop и End-to-End устанавливаются по диаметру при отправке исходящих запросов.</target>
        </trans-unit>
        <trans-unit id="b856160c3f11849f763958bfca750f4da4f8b030" translate="yes" xml:space="preserve">
          <source>Horizontal tab (HT)</source>
          <target state="translated">Горизонтальная вкладка (HT)</target>
        </trans-unit>
        <trans-unit id="de7f8e30d370dbed377d6f3ec1e0f3638d8f7cd7" translate="yes" xml:space="preserve">
          <source>Host :: string(),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288369442ce4af9ee861578e5997944104806d11" translate="yes" xml:space="preserve">
          <source>Host = &lt;code&gt;string() | ip_address()&lt;/code&gt;</source>
          <target state="translated">Хост = &lt;code&gt;string() | ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0506d8d8a9c994a9c2061822e71fa219eaa60fb" translate="yes" xml:space="preserve">
          <source>Host is not found, FTP server is not found, or connection is rejected by FTP server.</source>
          <target state="translated">Хост не найден,FTP-сервер не найден или соединение отклонено FTP-сервером.</target>
        </trans-unit>
        <trans-unit id="19cf18d3bb45fb6c52bc7c972db763badac874f9" translate="yes" xml:space="preserve">
          <source>Host key algorithm.</source>
          <target state="translated">Алгоритм ключа хоста.</target>
        </trans-unit>
        <trans-unit id="072282c1e2f294945717832e050c84248cb48a99" translate="yes" xml:space="preserve">
          <source>Host key(s)</source>
          <target state="translated">Ключ(ы)хоста</target>
        </trans-unit>
        <trans-unit id="addc5b9c7be01cab649badaad9fe245dd85b99a6" translate="yes" xml:space="preserve">
          <source>Host public key(s)</source>
          <target state="translated">Открытый(ые)ключ(ы)хозяина</target>
        </trans-unit>
        <trans-unit id="8dea1bfa3d5f782d439b94a2dc9e26fd4b92b4b3" translate="yes" xml:space="preserve">
          <source>Host,</source>
          <target state="translated">Host,</target>
        </trans-unit>
        <trans-unit id="22d5d7183ae1bff52681fe92c469a1efdf2db570" translate="yes" xml:space="preserve">
          <source>Host-IP-Address AVP</source>
          <target state="translated">Host-IP-Address AVP</target>
        </trans-unit>
        <trans-unit id="1db3d3092adcf5851af85b54fd2dcaa3d13b20b7" translate="yes" xml:space="preserve">
          <source>Hostname extraction</source>
          <target state="translated">Извлечение имени хоста</target>
        </trans-unit>
        <trans-unit id="cc902a2f4f94e0590cff3fb32bacd18c59026842" translate="yes" xml:space="preserve">
          <source>Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called.</source>
          <target state="translated">Имя хоста является результатом вызова net_adm:localhost()в узле Erlang,где вызывается этот funcion.</target>
        </trans-unit>
        <trans-unit id="e41e038a1831d791d3fb46209bc95e438998e2ba" translate="yes" xml:space="preserve">
          <source>Hostname of the node, &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">Имя хоста узла, &lt;code&gt;host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abd2f083d046f4cdd3824b5ac6815216f33f9d44" translate="yes" xml:space="preserve">
          <source>Hostnames and host addresses</source>
          <target state="translated">Имена и адреса хостов</target>
        </trans-unit>
        <trans-unit id="acf387fac0d70500029ecc75aef45e78a2439ddf" translate="yes" xml:space="preserve">
          <source>How categories can be mapped to CSS tags is documented in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">Как категории могут быть сопоставлены с тегами CSS, описано в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; в разделе &amp;laquo;Выполнение тестов и анализ результатов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4591aaae8b0152f47a2818f3eda6105fd1deb44b" translate="yes" xml:space="preserve">
          <source>How code is compiled and loaded is not a language issue, but is system-dependent. This section describes compilation and code loading in Erlang/OTP with references to relevant parts of the documentation.</source>
          <target state="translated">То,как код компилируется и загружается,не является языковой проблемой,а зависит от системы.В данном разделе описана компиляция и загрузка кода в Erlang/OTP со ссылками на соответствующие части документации.</target>
        </trans-unit>
        <trans-unit id="15c87cc7450111c7682bfcb2fe07b8147a9660ab" translate="yes" xml:space="preserve">
          <source>How long Erlang needs to be inactive before output is preceded with a time stamp. Defaults to &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt;, minimum is 1.</source>
          <target state="translated">Как долго Erlang должен быть неактивен, прежде чем вывод будет отмечен меткой времени. По умолчанию &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt; , минимум 1.</target>
        </trans-unit>
        <trans-unit id="f7148ef82d3951a0ef8aeff5732b56bd65e5d5a7" translate="yes" xml:space="preserve">
          <source>How long to wait for output (in minutes) before writing an &quot;ALIVE&quot; message to the log. Defaults to 15, minimum is 1.</source>
          <target state="translated">Сколько времени нужно ждать вывода (в минутах),прежде чем записывать в журнал сообщение &quot;ALIVE&quot;.По умолчанию 15,минимум 1.</target>
        </trans-unit>
        <trans-unit id="1a8eccc781fb3d6e08ed9cc46cafd132607b31bb" translate="yes" xml:space="preserve">
          <source>How many bytes that are read (received) from the socket, used in similar ways as &lt;code&gt;sent&lt;/code&gt;.</source>
          <target state="translated">Сколько байтов прочитано (получено) из сокета и использовано таким же образом, как и &lt;code&gt;sent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2063d1711356aa5cf80622e43bafe411dc016ccf" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f341bd6607eedd11420fecb92a331dcfda1889" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">Сколько байтов было отправлено через сокет. Это можно обернуть, но это не проблема для распределения, так как распределение Erlang интересует, только если это значение изменилось. (Эрланг &lt;code&gt;net_kernel&lt;/code&gt; &lt;code&gt;ticker&lt;/code&gt; использует это значение путем вызова драйвера для извлечения его, что это делается через &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; . Рутинного)</target>
        </trans-unit>
        <trans-unit id="7f7085d139029fad5626d71df4a69c37165c0004" translate="yes" xml:space="preserve">
          <source>How schedulers are bound matters. For example, in situations when there are fewer running processes than schedulers online, the runtime system tries to migrate processes to schedulers with low scheduler identifiers. The more the schedulers are spread over the hardware, the more resources are available to the runtime system in such situations.</source>
          <target state="translated">Как планировщики связаны между собой.Например,в ситуациях,когда запущенных процессов меньше,чем планировщиков в сети,исполнительная система пытается мигрировать процессы на планировщики с низкими идентификаторами планировщиков.Чем больше планировщиков распределено по аппаратному обеспечению,тем больше ресурсов доступно исполняющей системе в таких ситуациях.</target>
        </trans-unit>
        <trans-unit id="22fb0d06b90905c411643c4b8d63177262432872" translate="yes" xml:space="preserve">
          <source>How the different levels of configuration &quot;interfer&quot; with this, see the section &lt;code&gt;&lt;a href=&quot;configurations#algorithm-configuration&quot;&gt;Algorithm Configuration&lt;/a&gt;&lt;/code&gt; in the chapter &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20136af8c4b0c2e0978139eaccb368f03d6d08f3" translate="yes" xml:space="preserve">
          <source>How to Build a Debug Enabled Erlang RunTime System</source>
          <target state="translated">Как построить отладочную систему с поддержкой Erlang RunTime System</target>
        </trans-unit>
        <trans-unit id="d0e7345d074a8ac083420a87f267a9efe5441d6f" translate="yes" xml:space="preserve">
          <source>How to Work with the New API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9e65c5426cc2af60f611bbcd0bef6a2d2545ba" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt; Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c1dadaae2a29663af54cb6cd0c08758049e535" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">Как общаться с внешним миром и программное обеспечение, написанное на других языках (порты); это описано в &lt;code&gt;Interoperability Tutorial&lt;/code&gt; по взаимодействию .</target>
        </trans-unit>
        <trans-unit id="d5c10a361408710884679a3441fc66b438898423" translate="yes" xml:space="preserve">
          <source>How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как поступать с ошибками в поле &amp;laquo;Длина сообщения&amp;raquo; в заголовке &amp;laquo;Диаметр&amp;raquo; входящего сообщения. Ошибка в этом контексте заключается в том, что длина не составляет не менее 20 байтов (длина заголовка), не кратна 4 (допустимая длина) или не является длиной рассматриваемого сообщения, полученного по транспорту. интерфейс задокументирован в &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbdf00e07b9b9e2844d8c343abd36e9a64cbb60" translate="yes" xml:space="preserve">
          <source>How to install a release in a target environment is described in the section about target systems in Section 2 System Principles.</source>
          <target state="translated">Как установить релиз в целевой среде описано в разделе о целевых системах в Разд.2 Системные принципы.</target>
        </trans-unit>
        <trans-unit id="a8aa9d6c524adcbf7e604a1f12ced88b214a5951" translate="yes" xml:space="preserve">
          <source>How to program applications is described in &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как программировать приложения описано в &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276dc4ca7f730347d6af07741689ad055269eecd" translate="yes" xml:space="preserve">
          <source>How to program releases is described in &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как программировать релизы описано в &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4b3d991be0d0efdd7895d65ece3d2af255f1d4" translate="yes" xml:space="preserve">
          <source>How to send a trap by sending the &lt;code&gt;fTrap&lt;/code&gt; from the master agent is shown in this section. The master agent has the MIB &lt;code&gt;EX1-MIB&lt;/code&gt; loaded, where the trap is defined. This trap specifies that two variables should be sent along with the trap, &lt;code&gt;myName&lt;/code&gt; and &lt;code&gt;fIndex&lt;/code&gt;. &lt;code&gt;fIndex&lt;/code&gt; is a table column, so we must provide its value and the index for the row in the call to &lt;code&gt;snmpa:send_trap/4&lt;/code&gt;. In the example below, we assume that the row in question is indexed by 2 (the row with &lt;code&gt;fIndex&lt;/code&gt; 2).</source>
          <target state="translated">В этом разделе показано, как отправить ловушку путем отправки &lt;code&gt;fTrap&lt;/code&gt; от главного агента. У главного агента загружена MIB &lt;code&gt;EX1-MIB&lt;/code&gt; , в которой определена ловушка. Эта ловушка указывает, что вместе с ловушкой должны быть отправлены две переменные: &lt;code&gt;myName&lt;/code&gt; и &lt;code&gt;fIndex&lt;/code&gt; . &lt;code&gt;fIndex&lt;/code&gt; - это столбец таблицы, поэтому мы должны предоставить его значение и индекс для строки в вызове &lt;code&gt;snmpa:send_trap/4&lt;/code&gt; . В приведенном ниже примере мы предполагаем, что рассматриваемая строка проиндексирована 2 (строка с &lt;code&gt;fIndex&lt;/code&gt; 2).</target>
        </trans-unit>
        <trans-unit id="cd51a27fca892f8fff8444cd28b8146e7bbe5364" translate="yes" xml:space="preserve">
          <source>How to start and stop the code for the application, that is, the supervision tree, is described by two callback functions:</source>
          <target state="translated">Как запустить и остановить код приложения,то есть дерево контроля,описывается двумя функциями обратного вызова:</target>
        </trans-unit>
        <trans-unit id="41bdc386e84c42a60e9c78fd7063eb79494fd670" translate="yes" xml:space="preserve">
          <source>How to write &lt;code&gt;d&lt;/code&gt; programs or &lt;code&gt;systemtap&lt;/code&gt; scripts can be learned from books and from a lot of pages on the Internet. This manual page does not include any documentation about using the dynamic trace tools of respective platform. The &lt;code&gt;examples&lt;/code&gt; directory of the &lt;code&gt;runtime_tools&lt;/code&gt; application however contains comprehensive examples of both &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;systemtap&lt;/code&gt; programs that will help you get started. Another source of information is the &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; chapters in the Runtime Tools Users' Guide.</source>
          <target state="translated">О том, как писать &lt;code&gt;d&lt;/code&gt; - программы или сценарии &lt;code&gt;systemtap&lt;/code&gt; , можно узнать из книг и на многих страницах в Интернете. Эта страница руководства не включает никакой документации об использовании инструментов динамической трассировки соответствующей платформы. &lt;code&gt;examples&lt;/code&gt; директория &lt;code&gt;runtime_tools&lt;/code&gt; приложения , однако содержит исчерпывающие примеры как &lt;code&gt;d&lt;/code&gt; и &lt;code&gt;systemtap&lt;/code&gt; программ , которые помогут вам начать работу. Еще один источник информации - это &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; dtrace и systemtap, в Руководстве пользователя средств выполнения.</target>
        </trans-unit>
        <trans-unit id="0838c6817793504aa13c17409bac1788b9b01886" translate="yes" xml:space="preserve">
          <source>However, NTP is not fail-safe. The NTP server can be unavailable, &lt;code&gt;ntp.conf&lt;/code&gt; can be wrongly configured, or your computer can sometimes be disconnected from Internet. Furthermore, you can have a user (or even system administrator) who thinks the correct way to handle Daylight Saving Time is to adjust the clock one hour two times a year (which is the incorrect way to do it). To complicate things further, this user fetched your software from Internet and has not considered what the correct time is as perceived by a computer. The user does not care about keeping the wall clock in sync with the correct time. The user expects your program to have unlimited knowledge about the time.</source>
          <target state="translated">Однако NTP не является отказоустойчивым. Сервер NTP может быть недоступен, &lt;code&gt;ntp.conf&lt;/code&gt; может быть неправильно настроен, или ваш компьютер может иногда отключаться от Интернета. Кроме того, у вас может быть пользователь (или даже системный администратор), который считает, что правильным способом перехода на летнее время является корректировка часов на один час два раза в год (что является неправильным способом сделать это). Еще больше усложняет ситуацию то, что этот пользователь загрузил ваше программное обеспечение из Интернета и не учел, какое точное время воспринимается компьютером. Пользователь не заботится о том, чтобы настенные часы синхронизировали правильное время. Пользователь ожидает, что ваша программа будет иметь неограниченные знания о времени.</target>
        </trans-unit>
        <trans-unit id="1d1ccf19c7bc531f33d5809c585dc1826e4637e4" translate="yes" xml:space="preserve">
          <source>However, a node started in this way refuses to talk to other nodes, as no TLS parameters are supplied (see the next section).</source>
          <target state="translated">Однако узел,запущенный таким образом,отказывается общаться с другими узлами,так как параметры TLS не предоставляются (см.следующий раздел).</target>
        </trans-unit>
        <trans-unit id="b227076a401b39e896ee55916a33ca73c07f48da" translate="yes" xml:space="preserve">
          <source>However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded.</source>
          <target state="translated">Однако,битовые строки,которые не являются целыми байтами,не допускаются,поэтому символ UTF должен быть разделен по 8-битным границам,чтобы когда-либо быть расшифрованным.</target>
        </trans-unit>
        <trans-unit id="8ea8d93f3410c8633f2cc78f1bbe03d8844b4ed7" translate="yes" xml:space="preserve">
          <source>However, certificates can also be decoded using &lt;code&gt;pkix_decode_cert/2&lt;/code&gt;, which can customize and recursively decode standard parts of a certificate:</source>
          <target state="translated">Однако сертификаты также можно декодировать с помощью &lt;code&gt;pkix_decode_cert/2&lt;/code&gt; , который может настраивать и рекурсивно декодировать стандартные части сертификата:</target>
        </trans-unit>
        <trans-unit id="0c4ccce2e74bd8ac8ec245b1dfb747183f0ffc13" translate="yes" xml:space="preserve">
          <source>However, escaping other non-alphanumeric characters does no harm.</source>
          <target state="translated">Однако бегство от других не-алфавитно-цифровых символов не причиняет вреда.</target>
        </trans-unit>
        <trans-unit id="46e5131246ec14a5499a18be55e9b7179d7c9b66" translate="yes" xml:space="preserve">
          <source>However, for a value of type &lt;code&gt;SET OF&lt;/code&gt;, the DER encoding format requires the elements to be sent in ascending order of their encoding, which implies an expensive sorting procedure in runtime. Therefore it is recommended to use &lt;code&gt;SEQUENCE OF&lt;/code&gt; instead of &lt;code&gt;SET OF&lt;/code&gt; if possible.</source>
          <target state="translated">Однако для значения типа &lt;code&gt;SET OF&lt;/code&gt; формат кодирования DER требует, чтобы элементы отправлялись в порядке возрастания их кодировки, что подразумевает дорогостоящую процедуру сортировки во время выполнения. Поэтому рекомендуется по возможности использовать &lt;code&gt;SEQUENCE OF&lt;/code&gt; вместо &lt;code&gt;SET OF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc244468b711f7696ac604f858e8d4fc9b46e19b" translate="yes" xml:space="preserve">
          <source>However, here you will find some examples of how to use and to what you can use xmerl. A detailed description of the user interface can be found in the reference manual.</source>
          <target state="translated">Однако,здесь вы найдете некоторые примеры использования и того,что можно использовать xmerl.Подробное описание пользовательского интерфейса можно найти в справочном руководстве.</target>
        </trans-unit>
        <trans-unit id="0b9d56ea76c3544f39f6889a33eb80d1c637ad55" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;cp1&lt;/code&gt; also restarts, the function &lt;code&gt;application:takeover/2&lt;/code&gt; moves &lt;code&gt;myapp&lt;/code&gt; to &lt;code&gt;cp1&lt;/code&gt;, as &lt;code&gt;cp1&lt;/code&gt; has a higher priority than &lt;code&gt;cp3&lt;/code&gt; for this application. In this case, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; is executed at &lt;code&gt;cp1&lt;/code&gt; to start the application.</source>
          <target state="translated">Однако, если &lt;code&gt;cp1&lt;/code&gt; также перезапускается, функция &lt;code&gt;application:takeover/2&lt;/code&gt; перемещает &lt;code&gt;myapp&lt;/code&gt; на &lt;code&gt;cp1&lt;/code&gt; , поскольку &lt;code&gt;cp1&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;cp3&lt;/code&gt; для этого приложения. В этом случае &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; выполняется на &lt;code&gt;cp1&lt;/code&gt; для запуска приложения.</target>
        </trans-unit>
        <trans-unit id="d56d68a6f8912b74bb9d4335dc57800fe8ebb077" translate="yes" xml:space="preserve">
          <source>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:</source>
          <target state="translated">Однако,если за квантификатором следует вопросительный знак,он перестает быть жадным,а вместо этого соответствует минимально возможному количеству раз,поэтому следующий шаблон делает правильные вещи с комментариями на языке C:</target>
        </trans-unit>
        <trans-unit id="263a65ad8dda64685d084610e95a9d4761d42dff" translate="yes" xml:space="preserve">
          <source>However, if another process has the driver loaded, calling &lt;code&gt;reload_driver&lt;/code&gt; returns error code &lt;code&gt;pending_process&lt;/code&gt;. As stated earlier, the recommended design is to not allow other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; than the &quot;driver reloader&quot; to demand loading of the driver in question.</source>
          <target state="translated">Однако, если драйвер загружен другим процессом, вызов &lt;code&gt;reload_driver&lt;/code&gt; возвращает код ошибки &lt;code&gt;pending_process&lt;/code&gt; . Как указывалось ранее, рекомендуемая конструкция не позволяет другим &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; кроме &quot;загрузчика драйверов&quot;, требовать загрузки соответствующего драйвера.</target>
        </trans-unit>
        <trans-unit id="fdd9ab210aada3daba577507d301fd6bfe3e97ab" translate="yes" xml:space="preserve">
          <source>However, if the decimal number following the backslash is &amp;lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &amp;lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.</source>
          <target state="translated">Однако, если десятичное число после обратной косой черты меньше 10, оно всегда используется как обратная ссылка и вызывает ошибку только в том случае, если во всем шаблоне не так много захватывающих левых скобок. То есть круглые скобки, на которые делается ссылка, не обязательно должны быть слева от ссылки для чисел &amp;lt;10. &amp;laquo;Прямая обратная ссылка&amp;raquo; этого типа может иметь смысл, когда задействовано повторение, и подшаблон справа участвовал в более ранняя итерация.</target>
        </trans-unit>
        <trans-unit id="2a812868f08ecc593ae34f24cb42a6aa95624434" translate="yes" xml:space="preserve">
          <source>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is kept in the queue and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</source>
          <target state="translated">Однако,если первый образец не совпадает,проверяется второй.При совпадении,сообщение удаляется из очереди и выполняются действия,соответствующие второму шаблону.Если второй шаблон не совпадает,выполняются действия,соответствующие второму шаблону,и так далее,до тех пор,пока не будет больше никаких шаблонов для тестирования.Если нет больше тестируемых шаблонов,первое сообщение остается в очереди и вместо него выполняются действия,соответствующие второму шаблону.Если это соответствует какому-либо шаблону,то выполняются соответствующие действия и второе сообщение удаляется из очереди (сохраняя первое сообщение и любые другие сообщения в очереди).Если второе сообщение не совпадает,то выполняется третье сообщение и так далее,до тех пор,пока не будет достигнут конец очереди.Если конец очереди достигнут,процесс блокирует (останавливает выполнение)и ждет получения нового сообщения,после чего эта процедура повторяется.</target>
        </trans-unit>
        <trans-unit id="24786ae2162520de2c90e9e1d62681cc611c7770" translate="yes" xml:space="preserve">
          <source>However, if the input &lt;code&gt;Data&lt;/code&gt; is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</source>
          <target state="translated">Однако, если входные &lt;code&gt;Data&lt;/code&gt; являются чисто двоичными, третья часть кортежа ошибок также гарантированно будет двоичной.</target>
        </trans-unit>
        <trans-unit id="16d0a6fc945512ce80fc9d4797b016ad95bcce03" translate="yes" xml:space="preserve">
          <source>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</source>
          <target state="translated">Однако,если таблица создана с явным именем записи в качестве аргумента,как показано в следующем примере,записи абонента могут храниться в обеих таблицах независимо от имен таблиц:</target>
        </trans-unit>
        <trans-unit id="1b7421b4ed5e29d178756408b1fb811393c80202" translate="yes" xml:space="preserve">
          <source>However, if this is done and a &lt;code&gt;relup&lt;/code&gt; file is generated, not only would it contain instructions for restarting (that is, removing and adding) &lt;code&gt;prim_app&lt;/code&gt;, it would also contain instructions for starting &lt;code&gt;ch_app&lt;/code&gt; (and stopping it, in the case of downgrade). This is because &lt;code&gt;ch_app&lt;/code&gt; is included in the new &lt;code&gt;.rel&lt;/code&gt; file, but not in the old one.</source>
          <target state="translated">Однако, если это будет сделано и &lt;code&gt;relup&lt;/code&gt; файл relup , он не только будет содержать инструкции для перезапуска (то есть удаления и добавления) &lt;code&gt;prim_app&lt;/code&gt; , но также будет содержать инструкции для запуска &lt;code&gt;ch_app&lt;/code&gt; (и его остановки в случае перехода на более раннюю версию ) , Это связано с тем, что &lt;code&gt;ch_app&lt;/code&gt; включен в новый файл &lt;code&gt;.rel&lt;/code&gt; , но не в старый.</target>
        </trans-unit>
        <trans-unit id="88d142963f00e274bf0e73a5e3da8dd76b986238" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line do not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671dba1e8a971cf15a413c5af3f46c832eef8168" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">Однако, если вы вызываете &lt;code&gt;escript&lt;/code&gt; следующим образом, содержимое первой строки не имеет значения, но оно не может содержать код Erlang, так как он будет проигнорирован:</target>
        </trans-unit>
        <trans-unit id="7c6cbfad60b53ec8d8298796a95d996bcb875534" translate="yes" xml:space="preserve">
          <source>However, if you just want to change it for the current session you can also do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733932a016243e1521c912130b4ad01ef9fa9412" translate="yes" xml:space="preserve">
          <source>However, it can also be convenient to replace variables in within a &lt;code&gt;sys.config&lt;/code&gt; on the target after unpacking but before running the release. If you have a &lt;code&gt;sys.config.src&lt;/code&gt; it will be included and is not required to be a valid Erlang term file like &lt;code&gt;sys.config&lt;/code&gt;. Before running the release you must have a valid &lt;code&gt;sys.config&lt;/code&gt; in the same directory, so using &lt;code&gt;sys.config.src&lt;/code&gt; requires having some tool to populate what is needed and write &lt;code&gt;sys.config&lt;/code&gt; to disk before booting the release.</source>
          <target state="translated">Однако также может быть удобно заменить переменные в &lt;code&gt;sys.config&lt;/code&gt; на целевом компьютере после распаковки, но до запуска выпуска. Если у вас есть &lt;code&gt;sys.config.src&lt;/code&gt; , он будет включен и не обязательно должен быть действительным файлом &lt;code&gt;sys.config&lt;/code&gt; Erlang, например sys.config . Перед запуском выпуска у вас должен быть действующий &lt;code&gt;sys.config&lt;/code&gt; в том же каталоге, поэтому для использования &lt;code&gt;sys.config.src&lt;/code&gt; требуется некоторый инструмент для заполнения того, что необходимо, и записи &lt;code&gt;sys.config&lt;/code&gt; на диск перед загрузкой выпуска.</target>
        </trans-unit>
        <trans-unit id="e2548bff9e540af4d0fb0d83f010b390353ac3c3" translate="yes" xml:space="preserve">
          <source>However, it is acceptable to PCRE if rewritten to use two top-level branches:</source>
          <target state="translated">Однако для PCRE допустимо переписывание с использованием двух ветвей верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="fb5d7ab90418502bf4a66c357b3062b87e79e461" translate="yes" xml:space="preserve">
          <source>However, it is up to the tools that process the specifications to choose whether to take this extra information into account or not.</source>
          <target state="translated">Однако именно от инструментов,обрабатывающих спецификации,зависит,принимать ли во внимание эту дополнительную информацию или нет.</target>
        </trans-unit>
        <trans-unit id="bfce5f1fc516ae2dd7d55f261e0b8f21a3259164" translate="yes" xml:space="preserve">
          <source>However, more dot-separated parts than this can exist. The dot-separated parts consist of non-negative integers. If all parts less significant than &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;, they are omitted. The three normal parts &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; are changed as follows:</source>
          <target state="translated">Однако может существовать больше частей, разделенных точками. Части, разделенные точками, состоят из неотрицательных целых чисел. Если все части менее значимые, чем &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; равны &lt;code&gt;0&lt;/code&gt; , они опускаются. Три обычные части &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; изменены следующим образом:</target>
        </trans-unit>
        <trans-unit id="7df44a8a1e1ba914a7e56b28dc0791a84d52cf6e" translate="yes" xml:space="preserve">
          <source>However, no expansion is done in the following call because &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Однако в следующем вызове расширение не выполняется, потому что &lt;code&gt;{foo, false}&lt;/code&gt; затеняет &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d572d552eed7e268241fcd56330d5bd074e5ab5" translate="yes" xml:space="preserve">
          <source>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</source>
          <target state="translated">Однако обратите внимание,что существует риск того,что база данных может остаться в непоследовательном состоянии,если для ее обновления будут использоваться грязные операции.Грязные операции следует использовать только из соображений производительности,когда это абсолютно необходимо.</target>
        </trans-unit>
        <trans-unit id="a529ad494df4a251bbb90b6a1eb0a32b4600b075" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes or act as a proxy filter, which sends some packets to a proxy agent and some packets to the master agent.</source>
          <target state="translated">Однако это простое поведение может быть изменено различными способами.Например,сеть,если процесс может применять какую-то схему шифрования/дешифрования в байтах или действовать в качестве прокси-фильтра,который посылает некоторые пакеты прокси-агенту,а некоторые пакеты-главному агенту.</target>
        </trans-unit>
        <trans-unit id="d14e5363806cde8cb157cc5a01dc9d77816a23da" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes.</source>
          <target state="translated">Однако это простое поведение может быть изменено различными способами.Например,Net,если процесс может применять какую-то схему шифрования/дешифрования на байтах.</target>
        </trans-unit>
        <trans-unit id="bb8e8fcb075fb17e39be5eb5b27fd3315e7094ac" translate="yes" xml:space="preserve">
          <source>However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:</source>
          <target state="translated">Однако есть случаи,когда оптимизация не может быть использована.Когда .*заключен в круглые скобки,которые являются предметом обратной ссылки в другом месте шаблона,совпадение в начале шаблона может не сработать,если последующее совпадение будет успешным.Рассмотрим,например:</target>
        </trans-unit>
        <trans-unit id="fa09d853f290abccb9c6e1093393c3c7791a824e" translate="yes" xml:space="preserve">
          <source>However, there is an exception. Within a macro definition, a line that starts with whitespace followed by &lt;code&gt;//|&lt;/code&gt; is treated specially. The rest of the line is assumed to contain directives to control code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4528e70959d30b530219f34dfc215c6d0cefc18" translate="yes" xml:space="preserve">
          <source>However, this feature of delaying thread progress from unmanaged threads should preferably be used as little as possible, since heavy use of it will cause contention on the reference counter cache lines. The functionality is however very useful in code which normally only executes in managed threads, but which may under some infrequent circumstances be executed in other threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1d42158bbcefd3e41b94056683aaeb566a73aa" translate="yes" xml:space="preserve">
          <source>However, this procedure can be time-consuming, the shortcut function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</source>
          <target state="translated">Однако эта процедура может занять много времени, функция быстрого доступа &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; загружает все таблицы с диска с большей скоростью. Функция заставляет таблицы загружаться с диска независимо от сетевой ситуации.</target>
        </trans-unit>
        <trans-unit id="7ec657f07edbe2adca75ca4efe20bdbbe6a76973" translate="yes" xml:space="preserve">
          <source>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</source>
          <target state="translated">Однако,чтобы избежать изменения поведения старого (до R14)кода при компиляции с OTP версии R14A или более поздней,применяется следующее ограничение:Если вы переопределили имя BIF,который был автоматически импортирован в версии OTP до R14A (ERTS версии 5.8),и в вашем коде есть неявный вызов этой функции,вам необходимо либо явно удалить автоимпорт с помощью директивы компилятора,либо заменить вызов на полностью квалифицированный вызов функции.В противном случае вы получите ошибку компиляции.См.следующий пример:</target>
        </trans-unit>
        <trans-unit id="0d770aae36addee1e6eb41cd37aaf79237dbd85a" translate="yes" xml:space="preserve">
          <source>However, what reservation of physical memory actually means highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b9c43d3cdd19de7c3638848d794e6192e00af7" translate="yes" xml:space="preserve">
          <source>However, when using, for example, IA5String (which closely resembles ASCII), byte 65 (in decimal notation) &lt;strong&gt;means&lt;/strong&gt; character 'A'.</source>
          <target state="translated">Однако при использовании, например, IA5String (который очень похож на ASCII), байт 65 (в десятичной системе счисления) &lt;strong&gt;означает&lt;/strong&gt; символ &amp;laquo;A&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8f5f28cc9ea54e0ce758adaa70edd19d2c7df7a4" translate="yes" xml:space="preserve">
          <source>Http client service start/stop</source>
          <target state="translated">Начало/остановка обслуживания Http-клиентов</target>
        </trans-unit>
        <trans-unit id="2a4e8cc587ce6e7e113504c978e34c1e185e42f2" translate="yes" xml:space="preserve">
          <source>Http data types</source>
          <target state="translated">Http-типы данных</target>
        </trans-unit>
        <trans-unit id="421eac8e9d0f0d4fccaca857739a0c79fd890424" translate="yes" xml:space="preserve">
          <source>Hyphen (only where it can be interpreted as specifying a range)</source>
          <target state="translated">Дефис (только там,где он может быть интерпретирован как указание диапазона)</target>
        </trans-unit>
        <trans-unit id="df1da1414681b4aaf7b9dd8c935cd29628d37ea7" translate="yes" xml:space="preserve">
          <source>Hyphens are allowed in SMIv2 (a pragmatic approach). The reason for this is that according to SMIv2, hyphens are allowed for objects converted from SMIv1, but not for others. This is impossible to check for the compiler.</source>
          <target state="translated">Дефисы разрешены в SMIv2 (прагматичный подход).Причина этого в том,что согласно SMIv2 дефисы разрешены для объектов,преобразованных из SMIv1,но не для других.Это невозможно проверить на компиляторе.</target>
        </trans-unit>
        <trans-unit id="c5bc42a4cab12cb2ea8fc597fa696281af9382e3" translate="yes" xml:space="preserve">
          <source>I will only present the most important functions in the API here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317126fec2c76144e4651e497f8a410a786df087" translate="yes" xml:space="preserve">
          <source>I/O error.</source>
          <target state="translated">Ошибка ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="629b47de797063a0b6b561c862c608954c3da6aa" translate="yes" xml:space="preserve">
          <source>I/O from a function called in an Erlang ssh daemon</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0868350648287b8190bf9c980b2ea9c46ef7d5" translate="yes" xml:space="preserve">
          <source>I/O is by far the most problematic area for Unicode. A file is an entity where bytes are stored, and the lore of programming has been to treat characters and bytes as interchangeable. With Unicode characters, you must decide on an encoding when you want to store the data in a file. In Erlang, you can open a text file with an encoding option, so that you can read characters from it rather than bytes, but you can also open a file for bytewise I/O.</source>
          <target state="translated">Вход/выход-на сегодняшний день самая проблематичная область для Юникода.Файл-это сущность,в которой хранятся байты,а история программирования сводится к тому,что символы и байты должны рассматриваться как взаимозаменяемые.При использовании символов Юникода вам необходимо выбрать кодировку,когда вы хотите хранить данные в файле.В Erlang вы можете открыть текстовый файл с опцией кодировки,чтобы вы могли читать из него символы,а не байты,но вы также можете открыть файл для байтового ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="1fb1f4a96f553bd9d56bd14c304eff4f10d68c9d" translate="yes" xml:space="preserve">
          <source>I/O library functions.</source>
          <target state="translated">Функции библиотеки ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="e689b6630f1d0a364819fdd2b5731bcddd521358" translate="yes" xml:space="preserve">
          <source>I/O servers behave a little differently. The I/O servers connected to terminals (or &lt;code&gt;stdout&lt;/code&gt;) can usually cope with Unicode data regardless of the encoding option. This is convenient when one expects a modern environment but do not want to crash when writing to an archaic terminal or pipe.</source>
          <target state="translated">Серверы ввода-вывода ведут себя немного иначе. Серверы ввода-вывода, подключенные к терминалам (или &lt;code&gt;stdout&lt;/code&gt; ), обычно могут обрабатывать данные Unicode независимо от варианта кодировки. Это удобно, когда вы ожидаете современной среды, но не хотите давать сбой при записи в архаичный терминал или канал.</target>
        </trans-unit>
        <trans-unit id="2b536593017ca7fbb86fdac576736ff840ff5f41" translate="yes" xml:space="preserve">
          <source>I/O signals may however be aborted. This could be solved by letting the port specific scheduling lock also protect the private task data structure, but then the port very frequently would have to fight with others enqueueing new tasks. In order to handle this while keeping the private task data structure lock free, we use a similar &quot;non aggressive&quot; approach as we use when handling processes that gets suspended while in the run queue. Instead of removing the aborted port task, we just mark it as aborted using an atomic memory operation. When a task is selected for execution, we first verify that it has not been aborted. If aborted we, just drop the task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc86a2ee6eb5947817dfe748e38a27770d8f566" translate="yes" xml:space="preserve">
          <source>I/O-servers throughout the system can handle Unicode data and have options for converting data upon output or input to/from the device. As shown earlier, the &lt;code&gt;shell&lt;/code&gt; module has support for Unicode terminals and the &lt;code&gt;file&lt;/code&gt; module allows for translation to and from various Unicode formats on disk.</source>
          <target state="translated">Серверы ввода-вывода во всей системе могут обрабатывать данные Unicode и иметь опции для преобразования данных при выводе или вводе в / из устройства. Как было показано ранее, модуль &lt;code&gt;shell&lt;/code&gt; поддерживает терминалы Unicode, а &lt;code&gt;file&lt;/code&gt; модуль позволяет выполнять перевод в различные форматы Unicode на диске и обратно.</target>
        </trans-unit>
        <trans-unit id="bcfd9b9aeb407171a7e2324b4088b3abd516b2fd" translate="yes" xml:space="preserve">
          <source>IANA Considerations</source>
          <target state="translated">соображения ИАНА</target>
        </trans-unit>
        <trans-unit id="3e38df6d2fac16695ca12a7c20a2020653e3dafb" translate="yes" xml:space="preserve">
          <source>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface specification, automatically generates stub code in Erlang, C, or Java. See the IC User's Guide and IC Reference Manual.</source>
          <target state="translated">IC (Erlang IDL Compiler)-это генератор интерфейсов,который,учитывая спецификацию IDL-интерфейса,автоматически генерирует код заглушки на Erlang,C или Java.См.руководство пользователя IC и справочное руководство IC.</target>
        </trans-unit>
        <trans-unit id="0bf03f10d1813cb5d0b794bb41322a916930011c" translate="yes" xml:space="preserve">
          <source>IC file. It runs the IDL compiler.</source>
          <target state="translated">IC-файл.Он запускает компилятор IDL.</target>
        </trans-unit>
        <trans-unit id="881271d3bb93e752931432a69d275e6c5c697b27" translate="yes" xml:space="preserve">
          <source>IDEA cipher suites are not supported as they have become deprecated by the TLS 1.2 specification so it is not motivated to implement them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51d7c7db41d3c06e8b204e1bc79bfc7925a9210" translate="yes" xml:space="preserve">
          <source>IETF - which calls the protocol Megaco</source>
          <target state="translated">IETF-которая называет протокол Megaco.</target>
        </trans-unit>
        <trans-unit id="7d26936a60ddb99baf38e0efb1e3118fc3bedbec" translate="yes" xml:space="preserve">
          <source>IG (Interface Generator) automatically generated code for port or socket communication between an Erlang program and a C program, given a C header file with certain keywords.</source>
          <target state="translated">IG (Interface Generator)автоматически генерирует код для связи порта или сокета между программой Erlang и C-программой,предоставляя C-заголовочный файл с определенными ключевыми словами.</target>
        </trans-unit>
        <trans-unit id="02cd32b9b05d3968d24a31f2968a004c733872e9" translate="yes" xml:space="preserve">
          <source>IG - Removed from Erlang/OTP R6B.</source>
          <target state="translated">IG-удален из Erlang/OTP R6B.</target>
        </trans-unit>
        <trans-unit id="67d2109a8b5d8e4bb7b9df8f8ac917b156dee2f0" translate="yes" xml:space="preserve">
          <source>IIOP (CORBA)</source>
          <target state="translated">МИОП (КОРБА)</target>
        </trans-unit>
        <trans-unit id="e11de130ad140b3de05ef1e6704f79955721f5c1" translate="yes" xml:space="preserve">
          <source>INTEGER, INT, SMALLINT</source>
          <target state="translated">ЦЕЛОЕ ЧИСЛО,INT,SMALLINT</target>
        </trans-unit>
        <trans-unit id="46a2b346d175bbcf022a9a889eb0d86d5bfeb44a" translate="yes" xml:space="preserve">
          <source>IOString</source>
          <target state="translated">IOString</target>
        </trans-unit>
        <trans-unit id="d191822111684cb0a3235f7ff4be7401211b5c9d" translate="yes" xml:space="preserve">
          <source>IP address, &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">IP - адрес, &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c4e4f4977f53cb13c9e71db88ccd9dabd0d8c68" translate="yes" xml:space="preserve">
          <source>IP v4 address and nodename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a762fd412e63e6cdda70621754e625a105c877a8" translate="yes" xml:space="preserve">
          <source>IP v4 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b376f791ddb908dfa5eec43b3c5893ba79b006b" translate="yes" xml:space="preserve">
          <source>IP version to use when the host address is specified as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Версия IP, используемая, когда адрес хоста указан как &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a0cbf4fd8e6bbadf81a2623591ae93a5fab7c6" translate="yes" xml:space="preserve">
          <source>IPsec is transparent to diameter.</source>
          <target state="translated">IPsec прозрачна для диаметра.</target>
        </trans-unit>
        <trans-unit id="18ab43ebeda307979a5cae1e044580f0b576b6b9" translate="yes" xml:space="preserve">
          <source>ISO Latin-1 (0-255, one character per byte). Here, case parameter &lt;code&gt;InEncoding&lt;/code&gt; is to be specified as &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">ISO Latin-1 (0&amp;ndash;255, один символ на байт). Здесь параметр &lt;code&gt;InEncoding&lt;/code&gt; должен быть указан как &lt;code&gt;latin1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e544629e4d17007bac72590a9cae9dd3b4b775" translate="yes" xml:space="preserve">
          <source>ITU - which calls the protocol H.248</source>
          <target state="translated">МСЭ-который называет протокол H.248</target>
        </trans-unit>
        <trans-unit id="c633b237421559cb6821152c0d77a40227baef6f" translate="yes" xml:space="preserve">
          <source>Id of the &lt;code&gt;ssh&lt;/code&gt; channel as returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Идентификатор &lt;code&gt;ssh&lt;/code&gt; - канала, возвращенный &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee9bf2e79695b73d87e005e3af0acf3c8bf8e02" translate="yes" xml:space="preserve">
          <source>Ideally, your code only contains the first type of efficient code. If that turns out to be too slow, profile the application to find out where the performance bottlenecks are and optimize only the bottlenecks. Let other code stay as clean as possible.</source>
          <target state="translated">В идеале,ваш код содержит только первый тип эффективного кода.Если это окажется слишком медленным,профиль приложения,чтобы узнать,где узкие места в производительности и оптимизировать только узкие места.Пусть другой код остается как можно более чистым.</target>
        </trans-unit>
        <trans-unit id="c30e59972c073691c1e830409d7104410fccdf7c" translate="yes" xml:space="preserve">
          <source>Identified processor states may be different on different operating systems and may change between different versions of &lt;code&gt;cpu_sup&lt;/code&gt; on the same operating system. The sum of the percentage shares of the CPU cycles spent in all busy and all non-busy processor states will always add up to 100%, though.</source>
          <target state="translated">Идентифицированные состояния процессора могут отличаться в разных операционных системах и могут меняться между разными версиями &lt;code&gt;cpu_sup&lt;/code&gt; в одной и той же операционной системе. Однако сумма процентных долей циклов ЦП, проведенных во всех состояниях занятости и во всех состояниях процессора, всегда будет составлять 100%.</target>
        </trans-unit>
        <trans-unit id="b46580854e82988aa9e6377bc948b9ced562fe4b" translate="yes" xml:space="preserve">
          <source>Identifiers.</source>
          <target state="translated">Identifiers.</target>
        </trans-unit>
        <trans-unit id="c4b828ddf628f41cc4d390c6deaa0302ac12c3dd" translate="yes" xml:space="preserve">
          <source>Identifies a TLS session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bb32d0a7ac84997a35ee28f73ca250b15a818d" translate="yes" xml:space="preserve">
          <source>Identifies a counter array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d9be73f1ae427426eb7dad6ec17364635870b5" translate="yes" xml:space="preserve">
          <source>Identifies an atomic array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1aea5ef7b08c4fe2e094b55f89ec9a27cc6266" translate="yes" xml:space="preserve">
          <source>Identifies and returns the type of Erlang term encoded in a buffer. It skips a trailing &lt;strong&gt;magic&lt;/strong&gt; identifier.</source>
          <target state="translated">Определяет и возвращает тип термина Erlang, закодированного в буфере. Он пропускает завершающий &lt;strong&gt;магический&lt;/strong&gt; идентификатор.</target>
        </trans-unit>
        <trans-unit id="d4286448984448b29096cfc37d85e421cb0b828a" translate="yes" xml:space="preserve">
          <source>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">Определяет файловую систему,в которой находится файл.В Windows номер обозначает диск следующим образом:0 означает А:,1 означает Б:и так далее.</target>
        </trans-unit>
        <trans-unit id="a78e241d75b4386f5966c1f03850bc25044aab1e" translate="yes" xml:space="preserve">
          <source>Identifies the key to be used. The format depends on the loaded engine. It is passed to the &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; functions in libcrypto.</source>
          <target state="translated">Обозначает ключ, который будет использоваться. Формат зависит от загруженного движка. Он передается &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; в libcrypto.</target>
        </trans-unit>
        <trans-unit id="5c6a3f5a562e2ce595bdeeb857c4ae74f4eb3a1c" translate="yes" xml:space="preserve">
          <source>Identifies what information to sort by.</source>
          <target state="translated">Определяет,по какой информации сортировать.</target>
        </trans-unit>
        <trans-unit id="4c35819884b50461c098d94e30fb5a14c994b48c" translate="yes" xml:space="preserve">
          <source>Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.</source>
          <target state="translated">Определить круглые скобки по числу очень просто,но в сложных регулярных выражениях может быть сложно отслеживать цифры.Также,в случае изменения выражения,числа могут меняться.Чтобы помочь с этой сложностью,PCRE поддерживает именование подмастерн.Эта функция не добавлялась в Perl до релиза 5.10.Ранее эта возможность была у Python,а PCRE представила её в релизе 4.0,используя синтаксис Python.PCRE теперь поддерживает как Perl,так и синтаксис Python.Perl позволяет одинаково пронумерованным подшаблонам иметь разные имена,но PCRE-нет.</target>
        </trans-unit>
        <trans-unit id="86dd18440c1a33a5adeeb3446934c0824c7a25f8" translate="yes" xml:space="preserve">
          <source>Identity of connection or session configuration in a configuration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee66e066bf8a35e6b819408cf3275f475346209" translate="yes" xml:space="preserve">
          <source>Ideographic space</source>
          <target state="translated">идеографическое пространство</target>
        </trans-unit>
        <trans-unit id="772dd6d712cea08023a9c33b5e08bad4fba86f2b" translate="yes" xml:space="preserve">
          <source>Idle.</source>
          <target state="translated">Idle.</target>
        </trans-unit>
        <trans-unit id="d71d2a6296b765e49d14ea0b96f03799b0b788cf" translate="yes" xml:space="preserve">
          <source>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses.</source>
          <target state="translated">Если (*ACCEPT)находится внутри скобок захвата,данные до сих пор захватываются.Например,&quot;AB&quot;,&quot;AAD&quot; или &quot;ACD&quot;.При совпадении с &quot;AB&quot;,&quot;B&quot; захватывается внешними круглыми скобками.</target>
        </trans-unit>
        <trans-unit id="17049b973641f08ec5c309099cc30f3f32903038" translate="yes" xml:space="preserve">
          <source>If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; is committed to find a match at the current starting point, or not at all, for example:</source>
          <target state="translated">Если (* COMMIT) - единственный встреченный глагол возврата, после того, как он был передан, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; фиксируется, чтобы найти совпадение в текущей начальной точке, или не найти вообще, например:</target>
        </trans-unit>
        <trans-unit id="4f0f3a8fd87c3eaeb73231280dec7eb243d5903c" translate="yes" xml:space="preserve">
          <source>If +MMscrpm is set to true, which is default, the initial allocation will reserve physical memory for the entire super carrier. This can be used by users that want to ensure a certain &lt;strong&gt;minimum&lt;/strong&gt; amount of physical memory for the VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ba26284bd6bedd0128033397652d534ba6ab6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bd65b9d1cb2983119740d6067afd32e3a7d58b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d780bbcc021b00d62054ba34ee21d203ad8580fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is returned that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; известно &lt;code&gt;global&lt;/code&gt; модулю &lt;code&gt;Kernel&lt;/code&gt; , возвращается идентификатор Erlang, который можно использовать для отправки сообщений в службу расписания. Кроме того, &lt;code&gt;node&lt;/code&gt; инициализируется и содержит имя узла, на котором зарегистрирована служба, поэтому вы можете подключиться к нему, просто передав переменную в &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd779b7143c0739432543164284fa524cccd2f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is written to the_pid. This pid that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e26772d0fb234e217566d6d19fae8939ae23412" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6005483687ef9ab80b3590fb0cf13631ca631c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">Если используется &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; , все события обрабатываются в &lt;code&gt;Module:handle_event/4&lt;/code&gt; , и мы можем (но не обязаны) использовать подход, ориентированный на события, когда мы сначала выполняем переход в зависимости от события, а затем в зависимости от состояния:</target>
        </trans-unit>
        <trans-unit id="bebc3f9361919a37bdadad08140e7c6cde4d32d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no &lt;strong&gt;state enter calls&lt;/strong&gt; are done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5cadc65f5f231df3ce6310110d1f4f33d8f4c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no state enter calls are done.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; не возвращает такой список, вызовы ввода состояния не выполняются.</target>
        </trans-unit>
        <trans-unit id="f1ede23ffb5bebc5707015ac6f688b4dfda3fb06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every &lt;strong&gt;state change&lt;/strong&gt;, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; or &lt;code&gt;(enter, OldState, State, Data)&lt;/code&gt;, depending on the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. This may look like an event but is really a call performed after the previous &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; returned and before any event is delivered to the new &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; tuple from the &lt;strong&gt;state callback&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdd1ca7763b0bdfa6212efd72aad6a1d16e6bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every state change, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt;. This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; tuple from the state callback.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; возвращает список, содержащий &lt;code&gt;state_enter&lt;/code&gt; , механизм &lt;code&gt;gen_statem&lt;/code&gt; будет при каждом изменении состояния вызывать &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; вызов состояния с аргументами &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; . Это может выглядеть как событие, но на самом деле это вызов, выполняемый после возврата обратного вызова предыдущего состояния и до того, как какое-либо событие будет доставлено в обратный вызов нового состояния. См. &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; . Такой вызов можно повторить, вернув кортеж &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; из обратного вызова состояния.</target>
        </trans-unit>
        <trans-unit id="c28ef58b982d1f354c9c1bb974e90b1d95e0f6b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a &lt;strong&gt;state change&lt;/strong&gt;, which will not cause a &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69858e99b09a6a2285a4ba103a8f8d3c928ade9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a state change, which will not cause a state enter call.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; должен преобразовать состояние, это считается переименованием состояния, а не изменением состояния, которое не вызовет вызов входа в состояние.</target>
        </trans-unit>
        <trans-unit id="c3e9d1ef03578b7d4de76213b44cdc398818f9bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current event is postponed.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , текущее событие откладывается.</target>
        </trans-unit>
        <trans-unit id="af5f4ef54abaee17eded82e21fef9696e20a28ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and either it is the initial state or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; is used the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the current state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd474c164e6c98dd34c39ad22b25553a62777256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and the state changes the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e210051c1bffc48ec6b9fc364560332e7094f3fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are used, and either: the state changes, it is the initial state, or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; is used; the &lt;code&gt;gen_statem&lt;/code&gt; calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если используются &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; , и либо: состояние изменяется, это начальное состояние, либо используется один из результатов обратного вызова &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;gen_statem&lt;/code&gt; называет новую государственную функцию обратного вызова с аргументами &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16fb9d916c4a4fe6d38e2fad03d1c0057e0a3ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; is used, exactly one system configuration file is to be used and that file is to be called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">Если используется &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; использоваться только один файл конфигурации системы, и этот файл должен называться &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51507c4f6a07b6ee28c5c354867983982dadbd0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt; erlang:start_timer/4 &lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6115cbb4f02f28f406dcce7ea93217a4c99b305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt;erlang:start_timer/4&lt;/code&gt; for details.</source>
          <target state="translated">Если &lt;code&gt;Abs&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; абсолютным запускается таймер, и если оно &lt;code&gt;false&lt;/code&gt; родственник, который по умолчанию. Подробнее см. &lt;code&gt;erlang:start_timer/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0a20b01d494121fa23ac0f013c356e2645f0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt;, &lt;code&gt;Suspendee&lt;/code&gt; is currently in the suspended state.</source>
          <target state="translated">Если &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt; , &lt;code&gt;Suspendee&lt;/code&gt; в настоящее время находится в приостановленном состоянии.</target>
        </trans-unit>
        <trans-unit id="10d7f30204e89013efcda3ea67f9618ecad92260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto&lt;/code&gt; this function behaves exactly like &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Alg&lt;/code&gt; является &lt;code&gt;crypto&lt;/code&gt; эта функция ведет себя точно так же, как &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3833f82acaa575d2a76a8a6ea669ec6336dec8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto_cache&lt;/code&gt; this function fetches random data with OpenSSL's &lt;code&gt;RAND_bytes&lt;/code&gt; and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.</source>
          <target state="translated">Если &lt;code&gt;Alg&lt;/code&gt; - это &lt;code&gt;crypto_cache&lt;/code&gt; , эта функция выбирает случайные данные с помощью &lt;code&gt;RAND_bytes&lt;/code&gt; OpenSSL и кэширует их для повышения скорости, используя внутренний размер слова 56 бит, что ускоряет вычисления на 64-битных машинах.</target>
        </trans-unit>
        <trans-unit id="81e735d9039bbf6127ac283e19b140ef66799a72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1Type&lt;/code&gt; is &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt; must be either an &lt;code&gt;rsa_public_key()&lt;/code&gt;, &lt;code&gt;dsa_public_key()&lt;/code&gt; or an &lt;code&gt;ec_public_key()&lt;/code&gt; and this function creates the appropriate &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540115359cf8a83ae29b77cf40e5db9ee30403e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1module&lt;/code&gt; is a filename without extension, first &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; is assumed, then &lt;code&gt;&quot;.asn&quot;&lt;/code&gt;, and finally &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (to be compatible with the old ASN.1 compiler). &lt;code&gt;Asn1module&lt;/code&gt; can be a full pathname (relative or absolute) including filename with (or without) extension.</source>
          <target state="translated">Если &lt;code&gt;Asn1module&lt;/code&gt; - имя файла без расширения, сначала предполагается &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; , затем &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; и, наконец, &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (для совместимости со старым компилятором ASN.1). &lt;code&gt;Asn1module&lt;/code&gt; может быть полным путем (относительным или абсолютным), включая имя файла с (или без) расширением.</target>
        </trans-unit>
        <trans-unit id="9fdaeedafeeda6ab32c9d50b3c97381ca731e512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bin&lt;/code&gt; does not contain the entire packet, &lt;code&gt;{more,Length}&lt;/code&gt; is returned. &lt;code&gt;Length&lt;/code&gt; is either the expected &lt;strong&gt;total size&lt;/strong&gt; of the packet, or &lt;code&gt;undefined&lt;/code&gt; if the expected packet size is unknown. &lt;code&gt;decode_packet&lt;/code&gt; can then be called again with more data added.</source>
          <target state="translated">Если &lt;code&gt;Bin&lt;/code&gt; не содержит весь пакет, возвращается &lt;code&gt;{more,Length}&lt;/code&gt; . &lt;code&gt;Length&lt;/code&gt; - это либо ожидаемый &lt;strong&gt;общий размер&lt;/strong&gt; пакета, либо &lt;code&gt;undefined&lt;/code&gt; если ожидаемый размер пакета неизвестен. &lt;code&gt;decode_packet&lt;/code&gt; затем может быть вызван снова с добавлением дополнительных данных.</target>
        </trans-unit>
        <trans-unit id="f95f96eeb6722b14446ed74c5ef5dfae744b890d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BinRel1&lt;/code&gt; is omitted, the relation of equality between the elements of the &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; of the ranges of R[i], range R[1] &amp;times; ... &amp;times; range R[n], is used instead (intuitively, nothing is &quot;lost&quot;).</source>
          <target state="translated">Если &lt;code&gt;BinRel1&lt;/code&gt; опущен, вместо него используется отношение равенства между элементами &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; диапазонов R [i], диапазон R [1] &amp;times; ... &amp;times; диапазон R [n] (интуитивно ничего не значит &quot; потерянный&quot;).</target>
        </trans-unit>
        <trans-unit id="ab7b5f7a351be014914684701b08694a59a8d0bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binaries&lt;/code&gt; is not a flat list of binaries, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если двоичные &lt;code&gt;Binaries&lt;/code&gt; не являются плоским списком двоичных файлов, &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="aec03c703d777c73a4a57e3a4befcb0a209f3691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binary&lt;/code&gt; contains the object code for module &lt;code&gt;Module&lt;/code&gt;, this BIF loads that object code. If the code for module &lt;code&gt;Module&lt;/code&gt; already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</source>
          <target state="translated">Если &lt;code&gt;Binary&lt;/code&gt; содержит объектный код для модуля &lt;code&gt;Module&lt;/code&gt; , этот BIF загружает этот объектный код. Если код для модуля &lt;code&gt;Module&lt;/code&gt; уже существует, все ссылки экспорта заменяются так, чтобы они указывали на только что загруженный код. Ранее загруженный код сохраняется в системе как старый код, так как все еще могут быть процессы, выполняющие этот код.</target>
        </trans-unit>
        <trans-unit id="bf1ea3c8c99142091a2f51c1e81be7adb284b19c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block&lt;/code&gt;, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If &lt;code&gt;BlockState =:= unblock&lt;/code&gt; and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</source>
          <target state="translated">Если &lt;code&gt;BlockState =:= block&lt;/code&gt; , множественное планирование блокируется. То есть будет выполняться один и только один поток планировщика. Если &lt;code&gt;BlockState =:= unblock&lt;/code&gt; и никто другой не блокирует множественное планирование, и этот процесс заблокирован только один раз, множественное планирование разблокируется.</target>
        </trans-unit>
        <trans-unit id="39adb796c018ce57c270103c3c52ab7a2219f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block_normal&lt;/code&gt;, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</source>
          <target state="translated">Если &lt;code&gt;BlockState =:= block_normal&lt;/code&gt; , нормальное множественное планирование блокируется. То есть будет выполняться только один нормальный поток планировщика, но могут выполняться несколько грязных планировщиков. Если &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; и никто другой не блокирует нормальное множественное планирование, и этот процесс заблокирован только один раз, нормальное множественное планирование разблокируется.</target>
        </trans-unit>
        <trans-unit id="4eabdce3dc316d89d6448638269f7e3485875fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Body&lt;/code&gt; is returned and equal to &lt;code&gt;{Fun,Arg}&lt;/code&gt;, the web server tries &lt;code&gt;apply/2&lt;/code&gt; on &lt;code&gt;Fun&lt;/code&gt; with &lt;code&gt;Arg&lt;/code&gt; as argument. The web server expects that the fun either returns a list &lt;code&gt;(Body)&lt;/code&gt; that is an HTTP repsonse, or the atom &lt;code&gt;sent&lt;/code&gt; if the HTTP response is sent back to the client. If &lt;code&gt;close&lt;/code&gt; is returned from the fun, something has gone wrong and the server signals this to the client by closing the connection.</source>
          <target state="translated">Если &lt;code&gt;Body&lt;/code&gt; возвращается и равно &lt;code&gt;{Fun,Arg}&lt;/code&gt; , веб-сервер пытается &lt;code&gt;apply/2&lt;/code&gt; для &lt;code&gt;Fun&lt;/code&gt; с аргументом &lt;code&gt;Arg&lt;/code&gt; . Веб-сервер ожидает, что игра вернет либо список &lt;code&gt;(Body)&lt;/code&gt; , который является HTTP-ответом, либо &lt;code&gt;sent&lt;/code&gt; атом, если HTTP-ответ будет отправлен обратно клиенту. Если из развлечения возвращается &lt;code&gt;close&lt;/code&gt; , что-то пошло не так, и сервер сообщает об этом клиенту, закрывая соединение.</target>
        </trans-unit>
        <trans-unit id="501ba76048afe6c06b0d19442d6fa569952e8089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default value), &lt;code&gt;rb&lt;/code&gt; prints an error message to &lt;code&gt;stdout&lt;/code&gt; for every bad report it encounters, but the logging process is never ended. All printable reports are written. If logging to file is enabled, &lt;code&gt;rb&lt;/code&gt; prints &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; in the log file at the location of an unprintable report.</source>
          <target state="translated">Если &lt;code&gt;Bool&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; (значение по умолчанию), &lt;code&gt;rb&lt;/code&gt; выводит сообщение об ошибке на стандартный &lt;code&gt;stdout&lt;/code&gt; для каждого обнаруженного неверного отчета, но процесс регистрации никогда не заканчивается. Написаны все отчеты для печати. Если &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; в файл разрешена, &lt;code&gt;rb&lt;/code&gt; печатает * НЕПЕЧАТИВАЕМЫЙ ОТЧЕТ * в файле журнала в месте расположения непечатаемого отчета.</target>
        </trans-unit>
        <trans-unit id="adf90318c831c61cd69b483b3f045a3d3bf9c68f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;rb&lt;/code&gt; stops logging (and prints an error message to &lt;code&gt;stdout&lt;/code&gt;) if it encounters a badly formatted report. If logging to file is enabled, an error message is appended to the log file as well.</source>
          <target state="translated">Если &lt;code&gt;Bool&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;rb&lt;/code&gt; прекращает регистрацию (и выводит сообщение об ошибке на стандартный &lt;code&gt;stdout&lt;/code&gt; ), если обнаруживает плохо отформатированный отчет. Если ведение журнала в файл включено, сообщение об ошибке также добавляется в файл журнала.</target>
        </trans-unit>
        <trans-unit id="f4e4245f2e5400c897f04314650c4ae5a083dc43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, option &lt;code&gt;TCP_NODELAY&lt;/code&gt; is turned on for the socket, which means that also small amounts of data are sent immediately.</source>
          <target state="translated">Если &lt;code&gt;Boolean == true&lt;/code&gt; , опция &lt;code&gt;TCP_NODELAY&lt;/code&gt; включена для сокета, что означает, что также немедленно отправляются небольшие объемы данных.</target>
        </trans-unit>
        <trans-unit id="694f121851d48acf6a07239b2f70a6b720fe0aa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, the corresponding option is turned on for the socket, which means that small amounts of data are accumulated until a full MSS-worth of data is available or this option is turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81aeea37b05ee5c673682e9fcc0d5b3b90b2fd57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Button&lt;/code&gt; is a top type and it is needed to exclude component &lt;code&gt;number&lt;/code&gt; from decode, &lt;code&gt;Type_List&lt;/code&gt; in the instruction in the configuration file is &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt;. If you call the decode function &lt;code&gt;decode_Button_exclusive&lt;/code&gt;, &lt;code&gt;Decode_Instruction&lt;/code&gt; is &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Button&lt;/code&gt; является верхним типом и необходимо исключить &lt;code&gt;number&lt;/code&gt; компонента из декодирования, &lt;code&gt;Type_List&lt;/code&gt; в инструкции в файле конфигурации - &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt; . Если вы вызываете функцию декодирования &lt;code&gt;decode_Button_exclusive&lt;/code&gt; , &lt;code&gt;Decode_Instruction&lt;/code&gt; будет &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a8d1dadfc486d1483799d20461767cefd8ed40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Common Test&lt;/code&gt; Master fails initially to connect to any of the test nodes specified in a test specification or in the &lt;code&gt;InclNodes&lt;/code&gt; list, the operator is prompted with the option to either start over again (after manually checking the status of the nodes in question), to run without the missing nodes, or to abort the operation.</source>
          <target state="translated">Если &lt;code&gt;Common Test&lt;/code&gt; Master изначально не может подключиться к любому из тестовых узлов, указанных в спецификации теста или в списке &lt;code&gt;InclNodes&lt;/code&gt; , оператору предлагается выбрать вариант начать заново (после ручной проверки статуса рассматриваемых узлов), запустить без недостающих узлов или прервать операцию.</target>
        </trans-unit>
        <trans-unit id="7f9aad828bfbe4d21e5a879fcef15f035543f64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CurrentIndentation&lt;/code&gt; is negative, there are no line breaks and only a space is used as a separator.</source>
          <target state="translated">Если &lt;code&gt;CurrentIndentation&lt;/code&gt; отрицательно, разрывы строк отсутствуют, и в качестве разделителя используется только пробел.</target>
        </trans-unit>
        <trans-unit id="5c9db23221c4effc6df13f53f295b1b05c8bade4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Data&lt;/code&gt; is an invalid I/O list.</source>
          <target state="translated">Если &lt;code&gt;Data&lt;/code&gt; являются недопустимым списком ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="d49ad8995eb2ed767b688b2071df0c58e2d5482e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateTo, to}&lt;/code&gt;, reports that occurred before &lt;code&gt;DateTo&lt;/code&gt; are displayed.</source>
          <target state="translated">Если &lt;code&gt;Dates&lt;/code&gt; имеет форму &lt;code&gt;{DateTo, to}&lt;/code&gt; , отображаются отчеты, &lt;code&gt;DateTo&lt;/code&gt; до DateTo .</target>
        </trans-unit>
        <trans-unit id="9a74df3b45fff783ce83be5e48dd039ecedaba02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, it must be a &lt;code&gt;pid()&lt;/code&gt; of a process created on the current runtime system instance. This process has either terminated or not. If &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</source>
          <target state="translated">Если &lt;code&gt;Dest&lt;/code&gt; - это &lt;code&gt;pid()&lt;/code&gt; , это должен быть &lt;code&gt;pid()&lt;/code&gt; процесса, созданного в текущем экземпляре системы времени выполнения. Этот процесс либо завершен, либо нет. Если &lt;code&gt;Dest&lt;/code&gt; - это &lt;code&gt;atom()&lt;/code&gt; , он интерпретируется как имя локально зарегистрированного процесса. Процесс, указанный в названии, просматривается во время истечения таймера. Если имя не относится к процессу, ошибка не возвращается.</target>
        </trans-unit>
        <trans-unit id="815563aae4c2a11f4a34513e2da4caef9eb431be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, the timer is automatically canceled if the process referred to by the &lt;code&gt;pid()&lt;/code&gt; is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Dest&lt;/code&gt; является &lt;code&gt;pid()&lt;/code&gt; , таймер автоматически отменяется, если процесс, на который ссылается &lt;code&gt;pid()&lt;/code&gt; , не работает или процесс завершается. Эта функция была представлена ​​в ERTS 5.4.11. Обратите внимание, что таймеры не отменяются автоматически, если &lt;code&gt;Dest&lt;/code&gt; является &lt;code&gt;atom()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="444e6101a0cf1c543819e121052f438f584a1b39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Destination&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;write&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">Если &lt;code&gt;Destination&lt;/code&gt; ссылается на имя файла, он открывается с режимом &lt;code&gt;write&lt;/code&gt; добавленным к списку режимов перед копией, и закрывается по завершении.</target>
        </trans-unit>
        <trans-unit id="4f4e05199aa0bb385a948469feaaa5b970e7e3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dir&lt;/code&gt; does not exist</source>
          <target state="translated">Если &lt;code&gt;Dir&lt;/code&gt; не существует</target>
        </trans-unit>
        <trans-unit id="ee2b254fd6abe2a90dfea4382f11c9cb30169e97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == default&lt;/code&gt;, the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;Distributed == default&lt;/code&gt; , используется значение для приложения в параметре конфигурации ядра &lt;code&gt;distributed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49d3ece08d6530837a1ab0ddc7b321c040846a53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt;, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt;. &lt;code&gt;Application&lt;/code&gt; must be the application name (same as in the first argument). If a node crashes and &lt;code&gt;Time&lt;/code&gt; is specified, the application controller waits for &lt;code&gt;Time&lt;/code&gt; milliseconds before attempting to restart the application on another node. If &lt;code&gt;Time&lt;/code&gt; is not specified, it defaults to &lt;code&gt;0&lt;/code&gt; and the application is restarted immediately.</source>
          <target state="translated">Если &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt; , приложение становится распределенным. Аргумент переопределяет значение для приложения в &lt;code&gt;distributed&lt;/code&gt; параметре конфигурации ядра . &lt;code&gt;Application&lt;/code&gt; должно быть именем приложения (как в первом аргументе). Если узел выходит из строя , и &lt;code&gt;Time&lt;/code&gt; указывается, контроллер приложения ожидает &lt;code&gt;Time&lt;/code&gt; миллисекунд , прежде чем пытаться перезапустить приложение на другой узел. Если &lt;code&gt;Time&lt;/code&gt; не указано, по умолчанию оно равно &lt;code&gt;0&lt;/code&gt; , и приложение немедленно перезапускается.</target>
        </trans-unit>
        <trans-unit id="4152fae1a454be09c28651bdb166f8066323431a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, lists of integers &lt;code&gt;0..255&lt;/code&gt; or binaries containing plain bytes are sent back to the client when possible. If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;, lists with integers in the whole Unicode range or binaries encoded in UTF-8 are sent to the client. The user-supplied function always sees lists of integers, never binaries, but the list can contain numbers &amp;gt; 255 if &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Encoding&lt;/code&gt; - &lt;code&gt;latin1&lt;/code&gt; , списки целых чисел &lt;code&gt;0..255&lt;/code&gt; или двоичные файлы, содержащие простые байты, отправляются обратно клиенту, когда это возможно. Если &lt;code&gt;Encoding&lt;/code&gt; - &lt;code&gt;unicode&lt;/code&gt; , клиенту отправляются списки с целыми числами во всем диапазоне Unicode или двоичные файлы, закодированные в UTF-8. Пользовательская функция всегда видит списки целых чисел, а не двоичные файлы, но список может содержать числа&amp;gt; 255, если &lt;code&gt;Encoding&lt;/code&gt; - &lt;code&gt;unicode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795ff54ae5d53c3fcba2e08602c3c1f2e9df291a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == close&lt;/code&gt;, data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns &lt;code&gt;{timeout,Data}&lt;/code&gt; (where &lt;code&gt;Data&lt;/code&gt; is the data received so far).</source>
          <target state="translated">Если &lt;code&gt;End == close&lt;/code&gt; , данные возвращаются вызывающей стороне, когда канал закрывается сервером. Если тайм-аут происходит до того, как это произойдет, функция возвращает &lt;code&gt;{timeout,Data}&lt;/code&gt; (где &lt;code&gt;Data&lt;/code&gt; - данные, полученные на данный момент).</target>
        </trans-unit>
        <trans-unit id="4c405ae6dd72ff067086a677208e5abd694be786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == timeout&lt;/code&gt;, a time-out is expected and &lt;code&gt;{ok,Data}&lt;/code&gt; is returned both in the case of a time-out and when the channel is closed.</source>
          <target state="translated">Если &lt;code&gt;End == timeout&lt;/code&gt; , ожидается тайм-аут, и &lt;code&gt;{ok,Data}&lt;/code&gt; возвращается как в случае тайм-аута, так и при закрытии канала.</target>
        </trans-unit>
        <trans-unit id="9a4d4ab4678c1a0d9f4a6cd0d0cd26eccd4b8374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End&lt;/code&gt; is a fun, this fun is called with one argument, the data value in a received &lt;code&gt;ssh_cm&lt;/code&gt; message (see &lt;code&gt;ssh_connection(3)&lt;/code&gt;. The fun is to return either &lt;code&gt;true&lt;/code&gt; to end the receiving operation (and have the so far collected data returned) or &lt;code&gt;false&lt;/code&gt; to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).</source>
          <target state="translated">Если &lt;code&gt;End&lt;/code&gt; - это развлечение, это развлечение вызывается с одним аргументом, значением данных в полученном сообщении &lt;code&gt;ssh_cm&lt;/code&gt; (см. &lt;code&gt;ssh_connection(3)&lt;/code&gt; . Самое интересное - вернуть либо &lt;code&gt;true&lt;/code&gt; , чтобы завершить операцию получения (и вернуть уже собранные данные ) или &lt;code&gt;false&lt;/code&gt; , чтобы дождаться получения дополнительных данных от сервера. Даже если предоставляется развлечение, функция немедленно возвращается, если сервер закрывает канал).</target>
        </trans-unit>
        <trans-unit id="91045bcf979078e315cc68ac468e5a360ddec33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EnumTypeName&lt;/code&gt; does not exist in the ASN.1 specification, the compilation stops with an error code.</source>
          <target state="translated">Если &lt;code&gt;EnumTypeName&lt;/code&gt; не существует в спецификации ASN.1, компиляция останавливается с кодом ошибки.</target>
        </trans-unit>
        <trans-unit id="bd759ced4b466f7b939196360d08509e4b762583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ac5b0475b7a71717a3a976c82dd686c7a2b338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">Если &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; , менеджер событий регистрируется глобально как &lt;code&gt;GlobalName&lt;/code&gt; с использованием &lt;code&gt;global:register_name/2&lt;/code&gt; . Если имя не указано, менеджер событий не зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="145008a8fe8d11833ffba04465b46c305eac398a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt;, the event manager is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt; , менеджер событий регистрируется локально как &lt;code&gt;Name&lt;/code&gt; с помощью &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d48cb710ca1d3e34d2637a454ccf4af2333759" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt;, the event manager registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave as the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Если &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt; , диспетчер событий регистрируется в реестре, представленном &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; обратного вызова для экспорта функции &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; , и &lt;code&gt;send/2&lt;/code&gt; , которые ведут себя как соответствующие функции в &lt;code&gt;global&lt;/code&gt; . Таким образом, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; является допустимой ссылкой.</target>
        </trans-unit>
        <trans-unit id="9ad87f8334c21e8f203f8f813c8a18649ff573f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e635b8f737737ba5a05f0c993e3dfac9ac242c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;EventType&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; , вызывающий абонент ожидает ответа. Ответ может быть отправлен из этого или из любого другого &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; путем возврата с помощью &lt;code&gt;{reply,From,Reply}&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; , в &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; или путем вызова &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ef91cec4b18110476efaead7f796da1eca29a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Expr1&lt;/code&gt; evaluates to a name, but this name is not registered, a &lt;code&gt;badarg&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Если &lt;code&gt;Expr1&lt;/code&gt; оценивается как имя, но это имя не зарегистрировано, возникает &lt;code&gt;badarg&lt;/code&gt; выполнения badarg .</target>
        </trans-unit>
        <trans-unit id="abad608745399cb2e4372968eab18b8ca631a3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExprF&lt;/code&gt; is an atom, the function is said to be called by using the &lt;strong&gt;implicitly qualified function name&lt;/strong&gt;. If the function &lt;code&gt;ExprF&lt;/code&gt; is locally defined, it is called. Alternatively, if &lt;code&gt;ExprF&lt;/code&gt; is explicitly imported from the &lt;code&gt;M&lt;/code&gt; module, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; is called. If &lt;code&gt;ExprF&lt;/code&gt; is neither declared locally nor explicitly imported, &lt;code&gt;ExprF&lt;/code&gt; must be the name of an automatically imported BIF.</source>
          <target state="translated">Если &lt;code&gt;ExprF&lt;/code&gt; является атомом, функция называется вызываемой с использованием &lt;strong&gt;неявно определенного имени функции&lt;/strong&gt; . Если функция &lt;code&gt;ExprF&lt;/code&gt; определена локально, она вызывается. С другой стороны , если &lt;code&gt;ExprF&lt;/code&gt; явно импортирован из &lt;code&gt;M&lt;/code&gt; модуля, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; называется. Если &lt;code&gt;ExprF&lt;/code&gt; не объявлен локально и не импортируется явно, &lt;code&gt;ExprF&lt;/code&gt; должно быть именем автоматически импортируемого BIF.</target>
        </trans-unit>
        <trans-unit id="292de33996b21603ce18c953090ce4d3bb28c1aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the matching events are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the matching events are stopped.</source>
          <target state="translated">Если &lt;code&gt;Extra&lt;/code&gt; - это &lt;code&gt;log&lt;/code&gt; , соответствующие события разрешены. Если &lt;code&gt;Extra&lt;/code&gt; - &lt;code&gt;stop&lt;/code&gt; , соответствующие события останавливаются.</target>
        </trans-unit>
        <trans-unit id="0c63a514bfa0d0eec024a84c5585b4db685eb8d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the progress reports are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the progress reports are stopped.</source>
          <target state="translated">Если &lt;code&gt;Extra&lt;/code&gt; - &lt;code&gt;log&lt;/code&gt; , отчеты о ходе выполнения разрешены. Если &lt;code&gt;Extra&lt;/code&gt; - &lt;code&gt;stop&lt;/code&gt; , отчеты о ходе выполнения останавливаются.</target>
        </trans-unit>
        <trans-unit id="676697b8c810137bc5f3cbd3dba9cf47ed56934a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Pad&lt;/code&gt; is a &lt;code&gt;*&lt;/code&gt; character, the next argument in &lt;code&gt;Data&lt;/code&gt; is used as the value. For example:</source>
          <target state="translated">Если &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; или &lt;code&gt;Pad&lt;/code&gt; - это символ &lt;code&gt;*&lt;/code&gt; , в качестве значения используется следующий аргумент в &lt;code&gt;Data&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="58d27e8ccd9fb7397c53540d079879af93136abc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FIPS_mode_set&lt;/code&gt; returns &lt;code&gt;no&lt;/code&gt; the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</source>
          <target state="translated">Если &lt;code&gt;FIPS_mode_set&lt;/code&gt; возвращает &lt;code&gt;no&lt;/code&gt; , библиотека OpenSSL не поддерживает FIPS, и шифрование также не поддерживает режим FIPS.</target>
        </trans-unit>
        <trans-unit id="03e0cd5df5f6d73de87e5cdb82e5a381f90cc69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is equal to the index set of &lt;code&gt;Family1&lt;/code&gt;, and &lt;code&gt;Family3&lt;/code&gt;[i] is the difference between &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if &lt;code&gt;Family2&lt;/code&gt; maps i, otherwise &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; и &lt;code&gt;Family2&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;Family3&lt;/code&gt; - это семейство, такое, что набор индексов совпадает с набором индексов &lt;code&gt;Family1&lt;/code&gt; , а &lt;code&gt;Family3&lt;/code&gt; [i] - это разница между &lt;code&gt;Family1&lt;/code&gt; [i] и &lt;code&gt;Family2&lt;/code&gt; [i], если &lt;code&gt;Family2&lt;/code&gt; отображает i, в противном случае &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="707694b53f4e6ff34f03b06100b8fc3bb1a63a00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the intersection of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the intersection of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; и &lt;code&gt;Family2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;Family3&lt;/code&gt; - это семейство, в котором индексное множество является пересечением индексных множеств &lt;code&gt;Family1&lt;/code&gt; : s и &lt;code&gt;Family2&lt;/code&gt; : s, а &lt;code&gt;Family3&lt;/code&gt; [i] является пересечением &lt;code&gt;Family1&lt;/code&gt; [i] и &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="c3481789d9f11af86121200c69343c46693c383d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the union of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the union of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if both map i, otherwise &lt;code&gt;Family1&lt;/code&gt;[i] or &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; и &lt;code&gt;Family2&lt;/code&gt; являются &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;Family3&lt;/code&gt; - это семейство, такое что индексное множество является объединением индексных наборов &lt;code&gt;Family1&lt;/code&gt; : s и &lt;code&gt;Family2&lt;/code&gt; : s, а &lt;code&gt;Family3&lt;/code&gt; [i] является объединением &lt;code&gt;Family1&lt;/code&gt; [i] и &lt;code&gt;Family2&lt;/code&gt; [i], если оба отображают i, иначе &lt;code&gt;Family1&lt;/code&gt; [i] или &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="901cb0563eae4ae927b85e3235bb204abe3eeb2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;Family1&lt;/code&gt; [I] представляет собой бинарное отношение для каждого г в индексе набора &lt;code&gt;Family1&lt;/code&gt; , то &lt;code&gt;Family2&lt;/code&gt; это семейство с тем же набором индексов как &lt;code&gt;Family1&lt;/code&gt; таким образом, что &lt;code&gt;Family2&lt;/code&gt; [I] представляет собой &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;Family1[i]&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="10edd17f93cf8b662a14cd64ee029b216f69998c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;Family1&lt;/code&gt; [I] представляет собой бинарное отношение для каждого г в индексе набора &lt;code&gt;Family1&lt;/code&gt; , то &lt;code&gt;Family2&lt;/code&gt; это семейство с тем же набором индексов как &lt;code&gt;Family1&lt;/code&gt; таким образом, что &lt;code&gt;Family2&lt;/code&gt; [I] представляет собой &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;Family1&lt;/code&gt; [я] ,</target>
        </trans-unit>
        <trans-unit id="603f807d85acd930990c4dcffafa135bbe46960c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;Family1&lt;/code&gt; [I] представляет собой бинарное отношение для каждого г в индексе набора &lt;code&gt;Family1&lt;/code&gt; , то &lt;code&gt;Family2&lt;/code&gt; это семейство с тем же набором индексов как &lt;code&gt;Family1&lt;/code&gt; таким образом, что &lt;code&gt;Family2&lt;/code&gt; [I] является &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; от &lt;code&gt;Family1&lt;/code&gt; [я] ,</target>
        </trans-unit>
        <trans-unit id="df7eb7122ac171a82f2f5b7eabda31d098834629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for each i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;Family1&lt;/code&gt; [I] представляет собой набор множеств для каждого г в индексе набора &lt;code&gt;Family1&lt;/code&gt; , то &lt;code&gt;Family2&lt;/code&gt; это семейство с тем же набором индексов как &lt;code&gt;Family1&lt;/code&gt; таким образом, что &lt;code&gt;Family2&lt;/code&gt; [I] является &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;Family1&lt;/code&gt; [я ].</target>
        </trans-unit>
        <trans-unit id="9f6dbbe306d7fe1ab285e45f10bed30dc90b32b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;Family1&lt;/code&gt; [I] представляет собой набор множеств для каждого г в индексе набора &lt;code&gt;Family1&lt;/code&gt; , то &lt;code&gt;Family2&lt;/code&gt; это семейство с тем же набором индексов как &lt;code&gt;Family1&lt;/code&gt; таким образом, что &lt;code&gt;Family2&lt;/code&gt; [I] является &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;Family1&lt;/code&gt; [I ].</target>
        </trans-unit>
        <trans-unit id="6513fd3da5029f77ec7aae42fce09531984adc2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt; to those elements i of the index set for which &lt;code&gt;Fun&lt;/code&gt; applied to &lt;code&gt;Family1&lt;/code&gt;[i] returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Fun&lt;/code&gt; is a tuple &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt;, then &lt;code&gt;Fun2&lt;/code&gt; is applied to the &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i], otherwise &lt;code&gt;Fun&lt;/code&gt; is applied to &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;Family2&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; по &lt;code&gt;Family1&lt;/code&gt; к тех элементов я из множества индексов , для которых &lt;code&gt;Fun&lt;/code&gt; , применяемых к &lt;code&gt;Family1&lt;/code&gt; [I] возвращает &lt;code&gt;true&lt;/code&gt; . Если &lt;code&gt;Fun&lt;/code&gt; является кортежем &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt; , то &lt;code&gt;Fun2&lt;/code&gt; применяется к &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;Family1&lt;/code&gt; [I], в противном случае &lt;code&gt;Fun&lt;/code&gt; применяется к &lt;code&gt;Family1&lt;/code&gt; [I].</target>
        </trans-unit>
        <trans-unit id="0036be6edcb9af44b23cf453b297b5ff3815e4ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the result of calling &lt;code&gt;SetFun&lt;/code&gt; with &lt;code&gt;Family1&lt;/code&gt;[i] as argument.</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;Family2&lt;/code&gt; - это семейство с тем же набором &lt;code&gt;Family1&lt;/code&gt; , что и &lt;code&gt;Family2&lt;/code&gt; что Family2 [i] является результатом вызова &lt;code&gt;SetFun&lt;/code&gt; с &lt;code&gt;Family1&lt;/code&gt; [i] в ​​качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="a3ed4a237eeb2ac6e0edeeca8e08129966f3f00f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt;[i] is an empty set for some i, the process exits with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">Если &lt;code&gt;Family1&lt;/code&gt; [i] является пустым набором для некоторого i, процесс завершается с сообщением &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15ab50a2f9b83c85c1bf92e12df53a14b6fa72a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;BinRel&lt;/code&gt; is the binary relation containing all pairs (i, x) such that i belongs to the index set of &lt;code&gt;Family&lt;/code&gt; and x belongs to &lt;code&gt;Family&lt;/code&gt;[i].</source>
          <target state="translated">Если &lt;code&gt;Family&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;BinRel&lt;/code&gt; - это бинарное отношение, содержащее все пары (i, x), такие что i принадлежит набору индексов &lt;code&gt;Family&lt;/code&gt; , а x принадлежит &lt;code&gt;Family&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="8cca7739eb38698717638b6eb6af393def280970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; is not specified, a file dialog is opened where the crashdump can be selected.</source>
          <target state="translated">Если &lt;code&gt;File&lt;/code&gt; не указан, открывается диалоговое окно файла, в котором можно выбрать аварийный дамп.</target>
        </trans-unit>
        <trans-unit id="64e8f8682c5f33b6a09cda03b8458e6523b8dd31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error &lt;code&gt;enoent&lt;/code&gt; is raised when an attempt is made to run a program that is not found and &lt;code&gt;eacces&lt;/code&gt; is raised when the specified file is not executable.</source>
          <target state="translated">Если &lt;code&gt;FileName&lt;/code&gt; не может быть запущен, возникает исключение ошибки с кодом ошибки POSIX в качестве причины. Причина ошибки может различаться в зависимости от ОС. Обычно ошибка &lt;code&gt;enoent&lt;/code&gt; возникает при попытке запустить программу, которая не найдена, и &lt;code&gt;eacces&lt;/code&gt; возникает, когда указанный файл не является исполняемым.</target>
        </trans-unit>
        <trans-unit id="d64f4daf12cc430f6c5ecc07bc1247a82079bedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; has a suffix that indicates an object file (&lt;code&gt;.beam&lt;/code&gt;), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function &lt;code&gt;file:path_consult/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;FileName&lt;/code&gt; имеет суффикс, указывающий на объектный файл ( &lt;code&gt;.beam&lt;/code&gt; ), EUnit попытается перезагрузить модуль из указанного файла и протестировать его. В противном случае предполагается, что файл является текстовым файлом, содержащим спецификации теста, который будет считан с использованием &lt;code&gt;file:path_consult/2&lt;/code&gt; стандартной библиотечной функции : path_consult / 2 .</target>
        </trans-unit>
        <trans-unit id="f69d9680f0ea2ac6663d58bccc19bea7f9110950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is a &lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;make_config/1&lt;/code&gt; will use &lt;code&gt;FileNameOrIODev&lt;/code&gt; as a filename. A file named &lt;code&gt;FileNameOrIODev&lt;/code&gt; is created and the configuration will be written to that file. If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is an &lt;code&gt;io_device()&lt;/code&gt; (see the documentation of the module &lt;code&gt;io&lt;/code&gt;), the configuration will be written to the io device.</source>
          <target state="translated">Если &lt;code&gt;FileNameOrIODev&lt;/code&gt; является &lt;code&gt;string()&lt;/code&gt; , &lt;code&gt;make_config/1&lt;/code&gt; будет использовать &lt;code&gt;FileNameOrIODev&lt;/code&gt; в качестве имени файла. Будет создан файл с именем &lt;code&gt;FileNameOrIODev&lt;/code&gt; , и в этот файл будет записана конфигурация. Если &lt;code&gt;FileNameOrIODev&lt;/code&gt; является &lt;code&gt;io_device()&lt;/code&gt; (см. Документацию модуля &lt;code&gt;io&lt;/code&gt; ), конфигурация будет записана на устройство io.</target>
        </trans-unit>
        <trans-unit id="abe7ea2e6f95f6e74b291e53017c69e3872b70e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Filename&lt;/code&gt; is not a symbolic link, this function returns exactly the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Filename&lt;/code&gt; не является символической ссылкой, эта функция возвращает точно такой же результат, как &lt;code&gt;read_file_info/1&lt;/code&gt; . На платформах, которые не поддерживают символические ссылки, эта функция всегда эквивалентна &lt;code&gt;read_file_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb890f105737b8f693a0a5c7d392809221b9ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fix&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, table &lt;code&gt;Name&lt;/code&gt; is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</source>
          <target state="translated">Если &lt;code&gt;Fix&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; таблицы фиксируется (еще раз) вызывающим процессом, в противном случае таблица освобождается. Таблица также освобождается, когда процесс исправления завершается.</target>
        </trans-unit>
        <trans-unit id="35e7f62cf2a411f7548edbc78f5bda5268f86881" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, a list of all logged events is returned.</source>
          <target state="translated">Если &lt;code&gt;Flag&lt;/code&gt; имеет значение &lt;code&gt;get&lt;/code&gt; , возвращается список всех зарегистрированных событий.</target>
        </trans-unit>
        <trans-unit id="381028fa2c7469ac85a20d5087b1b0fd8afdf82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;print&lt;/code&gt;, the logged events are printed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Flag&lt;/code&gt; - &lt;code&gt;print&lt;/code&gt; , зарегистрированные события печатаются в &lt;code&gt;standard_io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b722fce5cc319fa08cae29348ebef98f92c444d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a new subscription is started. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, all previous subscriptions started with the same &lt;code&gt;Options&lt;/code&gt; are stopped. Two option lists are considered the same if they contain the same set of options.</source>
          <target state="translated">Если &lt;code&gt;Flag&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , начинается новая подписка. Если &lt;code&gt;Flag&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , все предыдущие подписки, запущенные с теми же &lt;code&gt;Options&lt;/code&gt; , останавливаются. Два списка параметров считаются одинаковыми, если они содержат одинаковый набор параметров.</target>
        </trans-unit>
        <trans-unit id="7ca78e84b760984f52335bac15cc8a1e618b6c52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flags = all&lt;/code&gt;, all possible flags are set.</source>
          <target state="translated">Если &lt;code&gt;Flags = all&lt;/code&gt; , устанавливаются все возможные флаги.</target>
        </trans-unit>
        <trans-unit id="2613d68b6d252e8fa327001ad657894c48452d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;finish&lt;/code&gt;, pending input is processed, pending output is flushed, and &lt;code&gt;deflate/3&lt;/code&gt; returns. Afterwards the only possible operations on the stream are &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Flush&lt;/code&gt; настроен на &lt;code&gt;finish&lt;/code&gt; , ожидающий ввод обрабатывается, ожидающий вывод сбрасывается, а &lt;code&gt;deflate/3&lt;/code&gt; возвращается. Впоследствии единственные возможные операции с потоком - &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a28ee970d5c9d1771957ed2098a6a9bd614a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;full&lt;/code&gt;, all output is flushed as with &lt;code&gt;sync&lt;/code&gt;, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using &lt;code&gt;full&lt;/code&gt; too often can seriously degrade the compression.</source>
          <target state="translated">Если &lt;code&gt;Flush&lt;/code&gt; установлен на &lt;code&gt;full&lt;/code&gt; , все выходные данные сбрасываются, как при &lt;code&gt;sync&lt;/code&gt; , и состояние сжатия сбрасывается, так что декомпрессия может возобновиться с этой точки, если предыдущие сжатые данные были повреждены или если требуется произвольный доступ. Слишком частое использование &lt;code&gt;full&lt;/code&gt; файла может серьезно ухудшить сжатие.</target>
        </trans-unit>
        <trans-unit id="5b162b87236f918abd12b2632484cedd86b7642d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;sync&lt;/code&gt;, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</source>
          <target state="translated">Если &lt;code&gt;Flush&lt;/code&gt; установлен на &lt;code&gt;sync&lt;/code&gt; , весь ожидающий вывод сбрасывается в буфер вывода, и вывод выравнивается по границе байта, так что декомпрессор может получить все входные данные, доступные на данный момент. Сброс может ухудшить сжатие для некоторых алгоритмов сжатия; поэтому используйте его только при необходимости.</target>
        </trans-unit>
        <trans-unit id="3748c496d0aee0e31ef9623ffe6c9c459e673128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</source>
          <target state="translated">Если &lt;code&gt;Force = true&lt;/code&gt; то агент продолжит попытки загрузить каждый mib даже после того, как не смог загрузить предыдущий mib. Используйте с осторожностью.</target>
        </trans-unit>
        <trans-unit id="2cad12b8139e1623aaeb8a5ccd722b61cea66f96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</source>
          <target state="translated">Если &lt;code&gt;Force = true&lt;/code&gt; агент продолжит попытки выгрузить каждый MIB даже после неудачной попытки выгрузить предыдущий MIB. Используйте с осторожностью.</target>
        </trans-unit>
        <trans-unit id="7d0a736a5ea9ae64f8bc28b164008b5e41f8db91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt;, &lt;code&gt;et_viewer&lt;/code&gt; in application ET is used for presenting the trace log graphically. &lt;code&gt;ttb&lt;/code&gt; provides a few different filters that can be selected from menu &lt;strong&gt;Filters and scaling&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt; , &lt;code&gt;et_viewer&lt;/code&gt; в приложении ET используется для графического представления журнала трассировки. &lt;code&gt;ttb&lt;/code&gt; предоставляет несколько различных фильтров, которые можно выбрать в меню &amp;laquo; &lt;strong&gt;Фильтры и масштабирование&amp;raquo;&lt;/strong&gt; в &lt;code&gt;et_viewer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="754c4ebe3c963dad574555e13a437f625208b390" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; is called for each trace message.</source>
          <target state="translated">Если &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; вызывается для каждого сообщения трассировки.</target>
        </trans-unit>
        <trans-unit id="e464e53752a8478fcd48d7d7806a6c052a202fab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler&lt;/code&gt; is not specified, a default handler is used presenting each trace message as a text line.</source>
          <target state="translated">Если &lt;code&gt;FormatHandler&lt;/code&gt; не указан, используется обработчик по умолчанию, представляющий каждое сообщение трассировки в виде текстовой строки.</target>
        </trans-unit>
        <trans-unit id="52add321b909cb81e422136ee5da910496779dbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Forms&lt;/code&gt; is a syntax tree of some other type than &lt;code&gt;form_list&lt;/code&gt;, the comments will be inserted directly using &lt;code&gt;recomment_tree/2&lt;/code&gt;, and any comments left over from that process are added as postcomments on the result.</source>
          <target state="translated">Если &lt;code&gt;Forms&lt;/code&gt; является синтаксическим деревом какого-либо другого типа, кроме &lt;code&gt;form_list&lt;/code&gt; , комментарии будут вставлены напрямую с помощью Recomment_tree &lt;code&gt;recomment_tree/2&lt;/code&gt; , а любые комментарии, оставшиеся от этого процесса, добавляются как посткомментарии к результату.</target>
        </trans-unit>
        <trans-unit id="c4eba9b5275105788875dd801e1636ad9a4cb30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun(Item)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is copied to the result queue. If it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is not copied. If it returns a list, the list elements are inserted instead of &lt;code&gt;Item&lt;/code&gt; in the result queue.</source>
          <target state="translated">Если &lt;code&gt;Fun(Item)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Item&lt;/code&gt; копируется в очередь результатов. Если он возвращает &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;Item&lt;/code&gt; не копируется. Если он возвращает список, элементы списка вставляются вместо &lt;code&gt;Item&lt;/code&gt; в очередь результатов.</target>
        </trans-unit>
        <trans-unit id="366fc356581d7fe3b943ae954f2a4d6cf716ab8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Module&lt;/code&gt; is the module in which the fun is defined.</source>
          <target state="translated">Если &lt;code&gt;Fun&lt;/code&gt; - это локальное развлечение, &lt;code&gt;Module&lt;/code&gt; - это модуль, в котором оно определено.</target>
        </trans-unit>
        <trans-unit id="1842cf53be67683035afaacc37fa7bea8be6bb1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Name&lt;/code&gt; is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, &lt;code&gt;[]&lt;/code&gt; is returned instead of an atom.</source>
          <target state="translated">Если &lt;code&gt;Fun&lt;/code&gt; - это локальное развлечение, &lt;code&gt;Name&lt;/code&gt; - это имя локальной функции, реализующей это развлечение. (Это имя было сгенерировано компилятором и используется только в информационных целях. Поскольку это локальная функция, ее нельзя вызвать напрямую.) Если в настоящее время не загружен код для развлечения, вместо атома возвращается &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f28f2ecd1a2a78b09a1a1bba86bfe7cd1e5abac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Module&lt;/code&gt; is the module that the fun refers to.</source>
          <target state="translated">Если &lt;code&gt;Fun&lt;/code&gt; - это внешнее развлечение, &lt;code&gt;Module&lt;/code&gt; - это модуль, к которому относится развлечение.</target>
        </trans-unit>
        <trans-unit id="7a891fa1f8c1fc67f4bfac48d75e87475a7bea29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Name&lt;/code&gt; is the name of the exported function that the fun refers to.</source>
          <target state="translated">Если &lt;code&gt;Fun&lt;/code&gt; - внешнее развлечение, &lt;code&gt;Name&lt;/code&gt; - это имя экспортируемой функции, к которой относится развлечение.</target>
        </trans-unit>
        <trans-unit id="c30588de4c7f0612e073a3883c335ac9373ebde3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Function&lt;/code&gt; inserts objects into the table, or another process inserts objects into the table, those objects &lt;strong&gt;can&lt;/strong&gt; (depending on key ordering) be included in the traversal.</source>
          <target state="translated">Если &lt;code&gt;Function&lt;/code&gt; вставляет объекты в таблицу или другой процесс вставляет объекты в таблицу, эти объекты &lt;strong&gt;могут&lt;/strong&gt; (в зависимости от порядка клавиш) быть включены в обход.</target>
        </trans-unit>
        <trans-unit id="8903d3c31d338fd3102b10a98c169c7def053e70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;HandlerId&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, then this entry modifies the default handler, equivalent to calling</source>
          <target state="translated">Если &lt;code&gt;HandlerId&lt;/code&gt; установлен по &lt;code&gt;default&lt;/code&gt; , эта запись изменяет обработчик по умолчанию, что эквивалентно вызову</target>
        </trans-unit>
        <trans-unit id="900d11629569ab220c3331823293a0c6bc8ed798" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How == read&lt;/code&gt; or there is no outgoing data buffered in the &lt;code&gt;Socket&lt;/code&gt; port, the socket is shut down immediately and any error encountered is returned in &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;How == read&lt;/code&gt; или исходящие данные не помещаются в буфер в порту &lt;code&gt;Socket&lt;/code&gt; , сокет немедленно отключается, и любая обнаруженная ошибка возвращается в &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c71e7f1f85187ddc4b81962dde74a95d9e96b0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How&lt;/code&gt; is not one of the documented alternatives.</source>
          <target state="translated">Если &lt;code&gt;How&lt;/code&gt; не является одной из задокументированных альтернатив.</target>
        </trans-unit>
        <trans-unit id="37742d0df7de57a88343a93bbae5c582e200b4bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I&lt;/code&gt; is not a non-negative integer, or if the array has fixed size and &lt;code&gt;I&lt;/code&gt; is larger than the maximum index, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;; compare &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;I&lt;/code&gt; не является неотрицательным целым числом или если массив имеет фиксированный размер и &lt;code&gt;I&lt;/code&gt; больше максимального индекса, вызов завершается ошибкой по причине &lt;code&gt;badarg&lt;/code&gt; ; сравнить &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b40958d947f1e3e1dfb64d8ec37bb529fd8c2ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = &amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, no IV is used. This is intended for ciphers without an IV (nounce). See &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17757dd0369fed1b521cdc06c576ee0641e25d48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = undefined&lt;/code&gt;, the IV must be added by calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt;. This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption. See &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192de0c6fdc2dc6ed90c9948b113d350638c9ee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt; casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9833c3a956d76bfddbabd05552d4c92a4ea96e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">Если &lt;code&gt;IgnoreCase&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; функция делает &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; на лету перед испытанием равенства.</target>
        </trans-unit>
        <trans-unit id="816e7270d9b2f0ac993fa2ef79b1a16b6e25ce74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, an error occurs whenever an integer &amp;gt; 255 is found in the lists.</source>
          <target state="translated">Если &lt;code&gt;InEncoding&lt;/code&gt; - &lt;code&gt;latin1&lt;/code&gt; , ошибка возникает всякий раз, когда в списках встречается целое число&amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="4425120ccc2526ec06a49a423343d05e8207c756" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range.</source>
          <target state="translated">Если &lt;code&gt;InEncoding&lt;/code&gt; - &lt;code&gt;latin1&lt;/code&gt; , двоичные файлы всегда действительны, если они содержат целые байты, поскольку каждый байт попадает в допустимый диапазон ISO Latin-1.</target>
        </trans-unit>
        <trans-unit id="ff1d0ed37f6966c578d637dcaf03e020ca40d09f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; corresponds to the &lt;code&gt;iodata()&lt;/code&gt; type, but for &lt;code&gt;unicode&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; can contain integers &amp;gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;InEncoding&lt;/code&gt; - &lt;code&gt;latin1&lt;/code&gt; , параметр &lt;code&gt;Data&lt;/code&gt; соответствует &lt;code&gt;iodata()&lt;/code&gt; , но для &lt;code&gt;unicode&lt;/code&gt; параметр &lt;code&gt;Data&lt;/code&gt; может содержать целые числа&amp;gt; 255 (символы Unicode за пределами диапазона ISO Latin-1), что делает его недействительным как &lt;code&gt;iodata()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c8391d802fddc5ccbafb2a99174fde559e23a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is of a Unicode type, an error occurs whenever either of the following is found:</source>
          <target state="translated">Если &lt;code&gt;InEncoding&lt;/code&gt; имеет тип Unicode, ошибка возникает всякий раз, когда обнаруживается одно из следующего:</target>
        </trans-unit>
        <trans-unit id="476e00e23216a072f0d4f2055cfb67b48c128bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is one of the UTF types, the bytes in any binaries must be valid in that encoding.</source>
          <target state="translated">Если &lt;code&gt;InEncoding&lt;/code&gt; является одним из типов UTF, байты в любых двоичных файлах должны быть действительными в этой кодировке.</target>
        </trans-unit>
        <trans-unit id="22f3829c6bb886763ec35ffd0a67a42f39f5713e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Incr =:= 0&lt;/code&gt; and &lt;code&gt;From =/= To&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Incr =:= 0&lt;/code&gt; и &lt;code&gt;From =/= To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b35d113bc1f0b8b177b00f244bbbf3e4ac06f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IpPort&lt;/code&gt; is omitted &lt;code&gt;162&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;IpPort&lt;/code&gt; не указан, используется &lt;code&gt;162&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57bfc33f769c9b0a788a08b107a1cedbd213bce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IsDst == true&lt;/code&gt;, &lt;code&gt;Localtime&lt;/code&gt; is during Daylight Saving Time, if &lt;code&gt;IsDst == false&lt;/code&gt; it is not. If &lt;code&gt;IsDst == undefined&lt;/code&gt;, the underlying OS can guess, which is the same as calling &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;IsDst == true&lt;/code&gt; , &lt;code&gt;Localtime&lt;/code&gt; время переходит на летнее время, если &lt;code&gt;IsDst == false&lt;/code&gt; - нет. Если &lt;code&gt;IsDst == undefined&lt;/code&gt; , базовая ОС может угадать, что аналогично вызову &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d88ab1af3b32ccae8c47bc290fd76139417148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Item&lt;/code&gt; is an invalid item.</source>
          <target state="translated">Если &lt;code&gt;Item&lt;/code&gt; является недопустимым.</target>
        </trans-unit>
        <trans-unit id="0ff6e5e0312fb6570b28f21e065635f71bd160e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ItemList&lt;/code&gt; is specified, the result is &lt;code&gt;InfoTupleList&lt;/code&gt;. The &lt;code&gt;InfoTuple&lt;/code&gt;s in &lt;code&gt;InfoTupleList&lt;/code&gt; are included with the corresponding &lt;code&gt;Item&lt;/code&gt;s in the same order as the &lt;code&gt;Item&lt;/code&gt;s were included in &lt;code&gt;ItemList&lt;/code&gt;. Valid &lt;code&gt;Item&lt;/code&gt;s can be included multiple times in &lt;code&gt;ItemList&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ItemList&lt;/code&gt; , результатом будет &lt;code&gt;InfoTupleList&lt;/code&gt; . &lt;code&gt;InfoTuple&lt;/code&gt; с в &lt;code&gt;InfoTupleList&lt;/code&gt; включены соответствующий &lt;code&gt;Item&lt;/code&gt; с в том же порядке, что и &lt;code&gt;Item&lt;/code&gt; с были включены в &lt;code&gt;ItemList&lt;/code&gt; . Правильный &lt;code&gt;Item&lt;/code&gt; s может быть включен несколько раз в &lt;code&gt;ItemList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af422b91ec82e2dd9338132983b67650395edbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; do not exists, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">Если &lt;code&gt;Key&lt;/code&gt; не существует, создается новая запись со значением &lt;code&gt;Incr&lt;/code&gt; , если оно больше 0, в противном случае устанавливается значение 0.</target>
        </trans-unit>
        <trans-unit id="c41410c8bc0b6250bb7c2a4f58129afe15bfcff0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; does not exist, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6283720a87b385d954928cf8467ee97a261a260e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; exists in &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new associated value.</source>
          <target state="translated">Если &lt;code&gt;Key&lt;/code&gt; существует в &lt;code&gt;Map1&lt;/code&gt; , старое связанное значение заменяется значением &lt;code&gt;Value&lt;/code&gt; . Функция возвращает новую карту &lt;code&gt;Map2&lt;/code&gt; , содержащую новое связанное значение.</target>
        </trans-unit>
        <trans-unit id="1dc230226eb63b450b632e9c874a80bd2fe8c24b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyOrName&lt;/code&gt; is a configured &lt;code&gt;server_id()&lt;/code&gt; or a &lt;code&gt;target_name()&lt;/code&gt; associated with such an Id, then the options for this server are fetched from the configuration file.</source>
          <target state="translated">Если &lt;code&gt;KeyOrName&lt;/code&gt; - это сконфигурированный &lt;code&gt;server_id()&lt;/code&gt; или &lt;code&gt;target_name()&lt;/code&gt; связанный с таким идентификатором, то параметры для этого сервера выбираются из файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="caeb4bb064b11f2b7bb8eeb778050c5ea54186c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LinkTo&lt;/code&gt; is a pid, it becomes an owner of the log. If &lt;code&gt;LinkTo&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, the log records that it is used anonymously by some process by incrementing the &lt;code&gt;users&lt;/code&gt; counter. By default, the process that calls &lt;code&gt;open/1&lt;/code&gt; owns the log.</source>
          <target state="translated">Если &lt;code&gt;LinkTo&lt;/code&gt; является pid, он становится владельцем журнала. Если &lt;code&gt;LinkTo&lt;/code&gt; не &lt;code&gt;none&lt;/code&gt; , журнальные записи , что он используется анонимно каким - либо процесс приращения &lt;code&gt;users&lt;/code&gt; счетчика. По умолчанию процесс, вызывающий &lt;code&gt;open/1&lt;/code&gt; , владеет журналом.</target>
        </trans-unit>
        <trans-unit id="9888882ab2a6e6b491af7cf81626c46b51b8c093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListOfBinRels&lt;/code&gt; is a non-empty list [R[1], ..., R[n]] of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ListOfBinRels&lt;/code&gt; - это непустой список [R [1], ..., R [n]] бинарных отношений, а &lt;code&gt;BinRel1&lt;/code&gt; - бинарное отношение, то &lt;code&gt;BinRel2&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; упорядоченного набора (R [i] ,. .., R [n]) и &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6668fcef53284c1666f849594130ecb9a9e9189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Loader&lt;/code&gt; is something else, the user-supplied &lt;code&gt;Loader&lt;/code&gt; port program is started.</source>
          <target state="translated">Если &lt;code&gt;Loader&lt;/code&gt; - это что-то еще, запускается предоставленная пользователем программа порта &lt;code&gt;Loader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4902233d819e3e7d17b192cdb14eea6c3a8ffc0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a binary, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;LocalFilename&lt;/code&gt; является двоичным, &lt;code&gt;tftp_binary&lt;/code&gt; используется как модуль обратного вызова. Двоичный файл передается блок за блоком, и количество переданных байтов возвращается в &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="514092af0b1076e970f978d5d6c41dea98a0f33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It reads the file named &lt;code&gt;LocalFilename&lt;/code&gt; block by block and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;LocalFilename&lt;/code&gt; является строкой и нет зарегистрированных модулей обратного вызова, &lt;code&gt;tftp_file&lt;/code&gt; используется как модуль обратного вызова. Он читает файл с именем &lt;code&gt;LocalFilename&lt;/code&gt; блок за блоком и возвращает количество переданных байтов в &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172a77adcec95a2025499b6cae24513646d7c3be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It writes each transferred block to the file named &lt;code&gt;LocalFilename&lt;/code&gt; and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;LocalFilename&lt;/code&gt; является строкой и нет зарегистрированных модулей обратного вызова, &lt;code&gt;tftp_file&lt;/code&gt; используется как модуль обратного вызова. Он записывает каждый переданный блок в файл с именем &lt;code&gt;LocalFilename&lt;/code&gt; и возвращает количество переданных байтов в &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd17776ebe8291ef5b56762e6914f21f0e371fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are registered callback modules, &lt;code&gt;LocalFilename&lt;/code&gt; is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</source>
          <target state="translated">Если &lt;code&gt;LocalFilename&lt;/code&gt; является строкой и есть зарегистрированные модули обратного вызова, &lt;code&gt;LocalFilename&lt;/code&gt; проверяется на соответствие их регулярным выражениям, и используется модуль обратного вызова, соответствующий первому совпадению, или возвращается кортеж ошибки, если подходящее регулярное выражение не найдено.</target>
        </trans-unit>
        <trans-unit id="e10f4bb7329e24a46f5a2fd1d389f1d3eaa1ef41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is the atom &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. It concatenates all transferred blocks and returns them as one single binary in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;LocalFilename&lt;/code&gt; - это &lt;code&gt;binary&lt;/code&gt; атома , &lt;code&gt;tftp_binary&lt;/code&gt; используется как модуль обратного вызова. Он объединяет все переданные блоки и возвращает их как один двоичный файл в &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f45f2e11d4c10074cfecd5aefc75c9eeb1e623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; is not of type map, an exception of type &lt;code&gt;badmap&lt;/code&gt; is thrown.</source>
          <target state="translated">Если &lt;code&gt;M&lt;/code&gt; не относится к типу map, генерируется исключение типа &lt;code&gt;badmap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687a37c16da4f8deeaf271a8bf79963858a6f256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; in a key exchange, it will fail with a disconnect.</source>
          <target state="translated">Если &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; при обмене ключами, произойдет сбой с отключением.</target>
        </trans-unit>
        <trans-unit id="7c02225a551052905fddcfce82626e17b4c75202" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Message&lt;/code&gt; does not correspond to the response, the atom &lt;code&gt;no_response&lt;/code&gt; is returned. If &lt;code&gt;Message&lt;/code&gt; corresponds to the response, the &lt;code&gt;call&lt;/code&gt; operation is completed and either the result is returned as &lt;code&gt;{response, Result}&lt;/code&gt; where &lt;code&gt;Result&lt;/code&gt; corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt;. That is, no &lt;code&gt;{erpc, timeout}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception can be raised. &lt;code&gt;erpc:check_response()&lt;/code&gt; will fail with an &lt;code&gt;{erpc, badarg}&lt;/code&gt; exception if/when an invalid &lt;code&gt;RequestId&lt;/code&gt; is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec574cad80dd815a39ff074fa450bce09ec6bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Minutes&lt;/code&gt; is set to &lt;code&gt;infinity&lt;/code&gt;, no rekeying will ever occur due to that max time has passed. Setting &lt;code&gt;Bytes&lt;/code&gt; to &lt;code&gt;infinity&lt;/code&gt; will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to &lt;code&gt;{infinity, infinity}&lt;/code&gt;, no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.</source>
          <target state="translated">Если &lt;code&gt;Minutes&lt;/code&gt; установлены на &lt;code&gt;infinity&lt;/code&gt; , повторного ввода ключей никогда не произойдет из-за того, что прошло максимальное время. Установка &lt;code&gt;Bytes&lt;/code&gt; на &lt;code&gt;infinity&lt;/code&gt; запретит смену ключей после передачи определенного количества данных. Если значение параметра установлено на &lt;code&gt;{infinity, infinity}&lt;/code&gt; , изменение ключей не инициируется. Обратите внимание, что изменение ключей, инициированное партнером, все равно будет выполнено.</target>
        </trans-unit>
        <trans-unit id="a9f8b097c0197afbf6ad454085a81f83c68dd174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects an inconsistent transaction decision, an &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; system event is generated to give the application a chance to install a fallback or other appropriate measures to resolve the inconsistency. The default behavior of the &lt;code&gt;Mnesia&lt;/code&gt; event handler is the same as if the database became inconsistent as a result of partitioned network (as described earlier).</source>
          <target state="translated">Если &lt;code&gt;Mnesia&lt;/code&gt; обнаруживает несогласованное решение о транзакции, генерируется системное событие &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; чтобы дать приложению возможность установить запасной вариант или другие соответствующие меры для устранения несоответствия. Поведение по умолчанию обработчика событий &lt;code&gt;Mnesia&lt;/code&gt; такое же, как если бы база данных стала несогласованной в результате многораздельной сети (как описано ранее).</target>
        </trans-unit>
        <trans-unit id="5ca626a4154bdde85262a0b351b9ffb8e56064dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects at startup that both the local node and another node received &lt;code&gt;mnesia_down&lt;/code&gt; from each other, &lt;code&gt;Mnesia&lt;/code&gt; generates an &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; system event and acts as described in the previous item.</source>
          <target state="translated">Если &lt;code&gt;Mnesia&lt;/code&gt; обнаруживает при запуске, что и локальный узел, и другой узел получили &lt;code&gt;mnesia_down&lt;/code&gt; друг от друга, &lt;code&gt;Mnesia&lt;/code&gt; генерирует системное событие &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; start_partitioned_network , Node} и действует, как описано в предыдущем пункте.</target>
        </trans-unit>
        <trans-unit id="8a5aa5b6bb0338ccad2dd9a24afe157f5c87240b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects that a file has not been properly closed, possibly as a result of a power failure, it tries to repair the bad file in a similar manner. Data can be lost, but &lt;code&gt;Mnesia&lt;/code&gt; can be restarted even if the data is inconsistent. Configuration parameter &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; can be used to control the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; tries to repair the file. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; does not restart if it detects a suspect file. This configuration parameter affects the repair behavior of log files, &lt;code&gt;DAT&lt;/code&gt; files, and the default backup media.</source>
          <target state="translated">Если &lt;code&gt;Mnesia&lt;/code&gt; обнаруживает, что файл не был должным образом закрыт, возможно, в результате сбоя питания, он пытается восстановить поврежденный файл аналогичным образом. Данные могут быть потеряны, но &lt;code&gt;Mnesia&lt;/code&gt; можно перезапустить, даже если данные несовместимы. Параметр конфигурации &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; можно использовать для управления поведением &lt;code&gt;Mnesia&lt;/code&gt; при запуске. Если &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; пытается восстановить файл. Если &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; не перезапускается, если обнаруживает подозрительный файл. Этот параметр конфигурации влияет на поведение восстановления файлов журнала, &lt;code&gt;DAT&lt;/code&gt; . файлы и резервный носитель по умолчанию.</target>
        </trans-unit>
        <trans-unit id="29d3fae27e18aeedb269f53e1a8f041e114e54d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; has not started on some of the nodes that are involved in the transaction &lt;strong&gt;and&lt;/strong&gt; neither the local node nor any of the already running nodes know the outcome of the transaction, &lt;code&gt;Mnesia&lt;/code&gt; waits for one, by default. In the worst case scenario, all other involved nodes must start before &lt;code&gt;Mnesia&lt;/code&gt; can make the correct decision about the transaction and finish its startup.</source>
          <target state="translated">Если &lt;code&gt;Mnesia&lt;/code&gt; не запущена на некоторых узлах, участвующих в транзакции, &lt;strong&gt;и&lt;/strong&gt; ни локальный узел, ни какой-либо из уже запущенных узлов не знают результата транзакции, &lt;code&gt;Mnesia&lt;/code&gt; ожидает его по умолчанию. В худшем случае все остальные задействованные узлы должны запуститься, прежде чем &lt;code&gt;Mnesia&lt;/code&gt; сможет принять правильное решение о транзакции и завершить ее запуск.</target>
        </trans-unit>
        <trans-unit id="dd38ec2de0e096904bd79c96261fe3dfca545808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; malfunctions, system information is dumped to file &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt;. The type of system information contained in this file can also be generated with the function &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt;. If a &lt;code&gt;Mnesia&lt;/code&gt; system behaves strangely, it is recommended that a &lt;code&gt;Mnesia&lt;/code&gt; core dump file is included in the bug report.</source>
          <target state="translated">Если &lt;code&gt;Mnesia&lt;/code&gt; не работает, системная информация сбрасывается в файл &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt; . Тип системной информации, содержащейся в этом файле, также можно сгенерировать с помощью функции &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt; . Если система &lt;code&gt;Mnesia&lt;/code&gt; ведет себя странно, рекомендуется включить файл дампа ядра &lt;code&gt;Mnesia&lt;/code&gt; в отчет об ошибке.</target>
        </trans-unit>
        <trans-unit id="78d126042be1f1bd5d152bedd102bc2c27a70a3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module2:init/1&lt;/code&gt; returns a correct value, this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module2:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">Если &lt;code&gt;Module2:init/1&lt;/code&gt; возвращает правильное значение, эта функция возвращает &lt;code&gt;ok&lt;/code&gt; . Если &lt;code&gt;Module2:init/1&lt;/code&gt; завершается с ошибкой с &lt;code&gt;Reason&lt;/code&gt; или возвращает неожиданное значение &lt;code&gt;Term&lt;/code&gt; , эта функция возвращает &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; или &lt;code&gt;{error,Term}&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="2800f17b5a7a3294a30bce9d692cce033e777bbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an error tuple or an incorrect value, this function returns &lt;code&gt;{error,Errorr}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term with information about the error, and the supervisor bridge terminates with reason &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Module:init/1&lt;/code&gt; завершается с ошибкой или возвращает кортеж ошибок или неправильное значение, эта функция возвращает &lt;code&gt;{error,Errorr}&lt;/code&gt; , где &lt;code&gt;Error&lt;/code&gt; - это термин с информацией об ошибке, а мост супервизора завершается с &lt;code&gt;Error&lt;/code&gt; причины .</target>
        </trans-unit>
        <trans-unit id="dd9e3be966d4953b313f0b3139d9921bb88d0b55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an incorrect value, this function returns &lt;code&gt;{error,Term}&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;Term&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Module:init/1&lt;/code&gt; дает сбой или возвращает неверное значение, эта функция возвращает &lt;code&gt;{error,Term}&lt;/code&gt; , где &lt;code&gt;Term&lt;/code&gt; - это термин с информацией об ошибке, а супервизор завершает работу по причине &lt;code&gt;Term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06a79b06d12276baeba24803b1a67f3a90f7af4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, the process is terminated and the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">Если &lt;code&gt;Module:init/1&lt;/code&gt; не работает с &lt;code&gt;Reason&lt;/code&gt; , функция возвращает &lt;code&gt;{error,Reason}&lt;/code&gt; . Если &lt;code&gt;Module:init/1&lt;/code&gt; возвращает &lt;code&gt;{stop,Reason}&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; , процесс завершается, а функция возвращает &lt;code&gt;{error,Reason}&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; , соответственно.</target>
        </trans-unit>
        <trans-unit id="08a85009b7d63daa3876ac0bbe64563be6e4667a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Если &lt;code&gt;Module:init/1&lt;/code&gt; не работает с &lt;code&gt;Reason&lt;/code&gt; , эта функция возвращает &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; . Если &lt;code&gt;Module:init/1&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , процесс завершается, и эта функция возвращает &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , соответственно.</target>
        </trans-unit>
        <trans-unit id="b964744cac9c86474eba0929df72fddd8367b88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor bridge terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Module:init/1&lt;/code&gt; возвращает &lt;code&gt;ignore&lt;/code&gt; , эта функция также возвращает &lt;code&gt;ignore&lt;/code&gt; , и мост супервизора завершает работу по &lt;code&gt;normal&lt;/code&gt; причине .</target>
        </trans-unit>
        <trans-unit id="7e2bd739756c272b047be065f7e266ff83f96304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well, and the supervisor terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Module:init/1&lt;/code&gt; возвращает &lt;code&gt;ignore&lt;/code&gt; , эта функция также возвращает &lt;code&gt;ignore&lt;/code&gt; , и супервизор завершает работу по &lt;code&gt;normal&lt;/code&gt; причине .</target>
        </trans-unit>
        <trans-unit id="e0a0e47ea971ab5cb4ee104b3ddf1785be6b28da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns a correct value indicating successful completion, the event manager adds the event handler and this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the event handler is ignored and this function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;, respectively.</source>
          <target state="translated">Если &lt;code&gt;Module:init/1&lt;/code&gt; возвращает правильное значение, указывающее на успешное завершение, менеджер событий добавляет обработчик событий, и эта функция возвращает &lt;code&gt;ok&lt;/code&gt; . Если &lt;code&gt;Module:init/1&lt;/code&gt; завершается с ошибкой с &lt;code&gt;Reason&lt;/code&gt; или возвращает &lt;code&gt;{error,Reason}&lt;/code&gt; , обработчик событий игнорируется, и эта функция возвращает &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; или &lt;code&gt;{error,Reason}&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="09a967e619be6af84ec5d9fcc2d540f2231d235c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="dd0d2fb7d1f38864cd0e105f7caff1a473b3f495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="6e0f9d357b53cd19411dbd2755262448109533a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="c30a59478d9813033d5db1ba6eb7b720e1f8a281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="8b31af596bd3564305ac89780dcd5037ca72eed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="3389cc7f2c4854aa000a5dc7cbbbd118b6386a3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="fa0c6abab53f3a1832ad70236445abe23313c949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="4220e81587ad22a96ae86a7cc023800c3211a2ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="827b0497b91b5175e901d63a74e9ca29d1d28466" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="547d2d680c102fd734e63aee60c0764a91aca79d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Если &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; не экспортируется, common_test вместо этого попытается вызвать &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; . Это для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="21fb0625232bdf7d33e9683b493cf013dd5244be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; is used to search for it relative to the directory of the object file.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; является атомом, а не путем к исходному файлу, то выполняется поиск по пути кода, чтобы найти объектный файл для модуля и извлечь его исходные параметры компилятора и исходный путь. Если исходный файл не найден в исходном месте, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; используется для его поиска относительно каталога объектного файла.</target>
        </trans-unit>
        <trans-unit id="2f35893e15d66156fbf46d4e4af24041aed07f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is interpreted, the interpreter is invoked and the return value of the interpreted &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; call is returned.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; интерпретируется, вызывается интерпретатор и возвращается значение, возвращаемое интерпретированным &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67c2474f76236eb774fc89b2d1d56a6f0f7c3f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded and the object file exists and contains the same code.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; загружен, а объектный файл существует и содержит тот же код.</target>
        </trans-unit>
        <trans-unit id="8e3e08e194bdd0bde8a181db6a7f4ea876ef7dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but does not have native code</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; загружен, но не имеет собственного кода</target>
        </trans-unit>
        <trans-unit id="6ed685bf101eabc82b65e519e9da522892714f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but no corresponding object file can be found in the code path.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; загружен, но соответствующий объектный файл не может быть найден в пути кода.</target>
        </trans-unit>
        <trans-unit id="a3d8ad064c879fd2b635248fe4428064d2c2287b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but the object file contains code with a different MD5 checksum.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; загружен, но объектный файл содержит код с другой контрольной суммой MD5.</target>
        </trans-unit>
        <trans-unit id="0d66cbf854873559817431ac8657e00f31894e65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not Cover compiled, the function returns &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; не скомпилирован Cover, функция возвращает &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35affc64e4462796f41658b1b89a47205a5418f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not an atom.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; не атом.</target>
        </trans-unit>
        <trans-unit id="28eaadbc7b4906a161654ae8a696f70005c80dff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not currently loaded.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; в настоящее время не загружен.</target>
        </trans-unit>
        <trans-unit id="2f4aff325466dff627c5e688d76bc4df8a1246e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not given, data for all Cover compiled or earlier imported modules is exported.</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; не указан, экспортируются данные для всех скомпилированных Cover или ранее импортированных модулей.</target>
        </trans-unit>
        <trans-unit id="4388daad92dd73ddcb6294d3f0538fdaca71514b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not loaded</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; не загружен</target>
        </trans-unit>
        <trans-unit id="3de1d5c36e26d7596ce7561b07882f4daa22a030" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is the name of a loaded module that has native code loaded</source>
          <target state="translated">Если &lt;code&gt;Module&lt;/code&gt; - это имя загруженного модуля, в который загружен собственный код</target>
        </trans-unit>
        <trans-unit id="dc068e6c6fb49a84acb5b9f82ce4f1b82380c161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;Answer&lt;/code&gt;, else the return will be a list, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Modules&lt;/code&gt; представляет собой атом (один модуль), возвращается &lt;code&gt;Answer&lt;/code&gt; , иначе возвращается список, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2129780e47085f58784cab38168e42cd913f8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;OneResult&lt;/code&gt;, else the return will be &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Modules&lt;/code&gt; является атомом (один модуль), возвращается &lt;code&gt;OneResult&lt;/code&gt; , иначе возвращается &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c5660afecaaa6ae9b7c2e1dd31118d79f4a48c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is not given, all modules that have data in the cover data table, are analysed. Note that this includes both cover compiled modules and imported modules.</source>
          <target state="translated">Если &amp;laquo; &lt;code&gt;Modules&lt;/code&gt; не указано, анализируются все модули, которые имеют данные в таблице данных обложки. Обратите внимание, что сюда входят как скомпилированные, так и импортированные модули обложки.</target>
        </trans-unit>
        <trans-unit id="8a375b70a231e530df5647867765137b186f5486" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules=dynamic&lt;/code&gt;, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (&lt;code&gt;gen_event&lt;/code&gt;), and it is checked if the module name is in this list instead.</source>
          <target state="translated">Если &lt;code&gt;Modules=dynamic&lt;/code&gt; , как в случае менеджеров событий, процесс менеджера событий информирует обработчик выпуска о списке установленных в настоящее время обработчиков событий ( &lt;code&gt;gen_event&lt;/code&gt; ), и вместо этого проверяется, присутствует ли имя модуля в этом списке.</target>
        </trans-unit>
        <trans-unit id="e8cecedc28fd848e48458244703056a1ac1a339f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; does not exist.</source>
          <target state="translated">Если &lt;code&gt;MonitorPid&lt;/code&gt; не существует.</target>
        </trans-unit>
        <trans-unit id="373a002dc9620bdf865a5b5e6f260b3dd1f5301f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Если &lt;code&gt;MonitorPid&lt;/code&gt; не является локальным процессом.</target>
        </trans-unit>
        <trans-unit id="89660705a87398108d22c38f81698b872c41d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorRef&lt;/code&gt; is a reference that the calling process obtained by calling &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">Если &lt;code&gt;MonitorRef&lt;/code&gt; - это ссылка, которую вызывающий процесс получил, вызвав &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; , этот мониторинг отключен. Если мониторинг уже отключен, ничего не происходит.</target>
        </trans-unit>
        <trans-unit id="4fd962484b4478493735ba1be0d09ca7b30e44ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="790d7222607fd455375f3a15db7f9612e76c7d20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</source>
          <target state="translated">Если &lt;code&gt;N&lt;/code&gt; = 0, сохранение вызовов для процесса отключено, что является значением по умолчанию. Каждый раз, когда устанавливается размер списка сохранения вызовов, его содержимое сбрасывается.</target>
        </trans-unit>
        <trans-unit id="917defb768e26d53c01d843240d1452bda349978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; (an alias name for &lt;code&gt;Key&lt;/code&gt;) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with &lt;code&gt;Name&lt;/code&gt; is possible. If &lt;code&gt;Key&lt;/code&gt; is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by &lt;code&gt;Key&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; (псевдоним для &lt;code&gt;Key&lt;/code&gt; ) используется для идентификации соединения, это имя может использоваться как ссылка на соединение для последующих вызовов. Одновременно возможно только одно открытое соединение, связанное с &lt;code&gt;Name&lt;/code&gt; . Если используется &lt;code&gt;Key&lt;/code&gt; , возвращаемый дескриптор должен использоваться для последующих вызовов (несколько соединений могут быть открыты с использованием данных конфигурации, указанных &lt;code&gt;Key&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="656dd80cf80ca49ab5d3f335d4b4b338f312a58e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra &quot;header&quot; comments will be added. In other words, the look of that module will be preserved.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; также является именем одного из модулей ввода, код этого модуля будет находиться в верхней части результирующего кода, и никакие дополнительные комментарии &amp;laquo;заголовка&amp;raquo; добавляться не будут. Другими словами, внешний вид этого модуля будет сохранен.</target>
        </trans-unit>
        <trans-unit id="ce802579fca60cdc1ea685ad322c443678165ff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is an &lt;code&gt;ip_address()&lt;/code&gt;, the domain name to query for is generated as the standard reverse &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; name for an IPv4 address, or the &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; name for an IPv6 address. In this case, you most probably want to use &lt;code&gt;Class = in&lt;/code&gt; and &lt;code&gt;Type = ptr&lt;/code&gt;, but it is not done automatically.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; - это &lt;code&gt;ip_address()&lt;/code&gt; , запрашиваемое имя домена создается как стандартный обратный &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; имя для IPv4-адреса или &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; имя для IPv6-адреса. В этом случае вы, скорее всего, захотите использовать &lt;code&gt;Class = in&lt;/code&gt; и &lt;code&gt;Type = ptr&lt;/code&gt; , но это не делается автоматически.</target>
        </trans-unit>
        <trans-unit id="a8688d593066763d843262dfe2006d94c1dcdd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, message &lt;code&gt;Msg&lt;/code&gt; is sent to the corresponding pid. The pid is also the return value of the function. If the name is not found, the function returns &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; найдено, сообщение &lt;code&gt;Msg&lt;/code&gt; отправляется соответствующему pid. Pid также является возвращаемым значением функции. Если имя не найдено, функция возвращает &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e52354c073c213988ffe84ec279249d3ad68b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, the corresponding pid is returned. If the name is not found, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; найдено, возвращается соответствующий pid. Если имя не найдено, функция возвращает &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b00a3532b853c4357137d1d6716fd7be18c249ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a globally registered name, the calling function exits with reason &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; не является глобально зарегистрированным именем, вызывающая функция завершается с причиной &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db414ecce81f54e0e73f62d5d1f1d7174a6bde93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a symbolic link, this function returns the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; не является символической ссылкой, эта функция возвращает тот же результат, что и &lt;code&gt;read_file_info/1&lt;/code&gt; . На платформах, которые не поддерживают символические ссылки, эта функция всегда эквивалентна &lt;code&gt;read_file_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8984feb7e9675020b1675cc50fa02225487141b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not found</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; не найдено</target>
        </trans-unit>
        <trans-unit id="83d7d8a185c6a27fcabc1c06a33f11f825598937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is set to &lt;strong&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/strong&gt; the node will be started in a special mode optimized to be the temporary client of another node. When enabled the node will request a &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_NAME_ME&quot;&gt;dynamic node name&lt;/a&gt;&lt;/code&gt; from the first node it connects to. In addition these distribution settings will be set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d520edb0115ce9349b43d81a86232f4def5a898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Dir&lt;/code&gt; is invalid</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; или &lt;code&gt;Dir&lt;/code&gt; недействительны</target>
        </trans-unit>
        <trans-unit id="f315d1f10b092b6fd3887d5883429c8b05c69dd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt;, the &lt;code&gt;net_ticktime&lt;/code&gt; change is done at the end of the transition period; otherwise at the beginning. During the transition period, &lt;code&gt;net_kernel&lt;/code&gt; ensures that there is outgoing traffic on all connections at least every &lt;code&gt;MTTI&lt;/code&gt; millisecond.</source>
          <target state="translated">Если &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt; , изменение &lt;code&gt;net_ticktime&lt;/code&gt; выполняется в конце переходного периода; иначе в начале. В течение переходного периода &lt;code&gt;net_kernel&lt;/code&gt; гарантирует наличие исходящего трафика по всем соединениям, по крайней мере, каждую миллисекунду &lt;code&gt;MTTI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3470b5ebd8e369aa1cfb7ac34ffa140b95c20443" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NewVsn&lt;/code&gt; is installed with option &lt;code&gt;{update_paths,true}&lt;/code&gt;, then &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; returns &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;NewVsn&lt;/code&gt; установлен с опцией &lt;code&gt;{update_paths,true}&lt;/code&gt; , тогда &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; возвращает &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7547eeec41488135afba55363382ea4a68e45c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; the state machine changes to a new state. A &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed if enabled and all &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; are retried.</source>
          <target state="translated">Если &lt;code&gt;NextState =/= State&lt;/code&gt; автомат переходит в новое состояние. &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; выполняется , если включено , и все &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; являются повторены.</target>
        </trans-unit>
        <trans-unit id="985454129fa65531f94519e19f8ec9b0b8e0bac3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; this is a &lt;strong&gt;state change&lt;/strong&gt; so the extra things &lt;code&gt;gen_statem&lt;/code&gt; does are: the event queue is restarted from the oldest &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed event&lt;/a&gt;&lt;/code&gt;, any current &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; is cancelled, and a &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed, if enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192634e65d22edbbba862eb9814d7d7d08c39bad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; fails or does not exist, the message &lt;code&gt;{nodedown, Node}&lt;/code&gt; is delivered to the process. If a process has made two calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; terminates, two &lt;code&gt;nodedown&lt;/code&gt; messages are delivered to the process. If there is no connection to &lt;code&gt;Node&lt;/code&gt;, an attempt is made to create one. If this fails, a &lt;code&gt;nodedown&lt;/code&gt; message is delivered.</source>
          <target state="translated">Если &lt;code&gt;Node&lt;/code&gt; выходит из строя или не существует, сообщение &lt;code&gt;{nodedown, Node}&lt;/code&gt; доставляется процессу. Если процесс сделал два вызова &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; и &lt;code&gt;Node&lt;/code&gt; завершился, &lt;code&gt;nodedown&lt;/code&gt; доставлены два сообщения nodedown . Если нет подключения к &lt;code&gt;Node&lt;/code&gt; , делается попытка его создать. Если это не удается, &lt;code&gt;nodedown&lt;/code&gt; сообщение nodedown .</target>
        </trans-unit>
        <trans-unit id="68714d151c87dc360bf98fc14620b6c335f0dd18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;Options&lt;/code&gt; will then also be added to kernel configration parameters &lt;code&gt;inet_dist_listen_options&lt;/code&gt; and &lt;code&gt;inet_dist_connect_options&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Node&lt;/code&gt; является &lt;code&gt;new&lt;/code&gt; в &lt;code&gt;Options&lt;/code&gt; будет также добавлена к ядру параметров configration &lt;code&gt;inet_dist_listen_options&lt;/code&gt; и &lt;code&gt;inet_dist_connect_options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a374c5564c071bca33b827b4d05f4d121d56e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is a connected node the return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Sock&lt;/code&gt; is the distribution socket for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Node&lt;/code&gt; является подключенным узлом, возвращаемое значение такое же, как и из &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; где &lt;code&gt;Sock&lt;/code&gt; - это распределительный сокет для &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a745393bc7f4f706da8daca8a06958d92906e5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;all_nodes&lt;/code&gt;, the operation or test is performed on all specified test nodes. (Declaring a term without a &lt;code&gt;NodeRefs&lt;/code&gt; element has the same effect). If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;master&lt;/code&gt;, the operation is only performed on the &lt;code&gt;Common Test&lt;/code&gt; Master node (namely set the log directory or install an event handler).</source>
          <target state="translated">Если &lt;code&gt;NodeRefs&lt;/code&gt; имеет значение &lt;code&gt;all_nodes&lt;/code&gt; , операция или тест выполняется на всех указанных тестовых узлах. (Объявление термина без элемента &lt;code&gt;NodeRefs&lt;/code&gt; имеет тот же эффект). Если &lt;code&gt;NodeRefs&lt;/code&gt; имеет значение &lt;code&gt;master&lt;/code&gt; , операция выполняется только на узле &lt;code&gt;Common Test&lt;/code&gt; Master (а именно, установить каталог журнала или установить обработчик событий).</target>
        </trans-unit>
        <trans-unit id="0a2bb885a5c6676f0b55789e9e3cebe681cef1a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Nodename&lt;/code&gt; is the local node, the error reason &lt;code&gt;cant_add_local_node&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;Nodename&lt;/code&gt; является локальным узлом, возвращается причина ошибки &lt;code&gt;cant_add_local_node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88f13b4b4a78ad3eb8641157bd00453fceefb7e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt; nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt; nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt; nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd44685473bdc36e9c30c5fd35ef39651321ff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Norm&lt;/code&gt; не равно &lt;code&gt;none&lt;/code&gt; , функция применяет нормализацию на лету перед проверкой равенства. Есть четыре доступных нормализации формы: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e6781b735fbde5662ff5d701d6df3c8fc8b882" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ObjectOrObjects&lt;/code&gt; is a list, the function checks &lt;strong&gt;every&lt;/strong&gt; key before inserting anything. Nothing is inserted unless &lt;strong&gt;all&lt;/strong&gt; keys present in the list are absent from the table. Like &lt;code&gt;insert/2&lt;/code&gt;, the entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ObjectOrObjects&lt;/code&gt; является списком, функция проверяет &lt;strong&gt;каждый&lt;/strong&gt; ключ перед тем, как что-либо вставлять. Ничего не вставляется, если &lt;strong&gt;все&lt;/strong&gt; ключи, представленные в списке, отсутствуют в таблице. Как и &lt;code&gt;insert/2&lt;/code&gt; , вся операция гарантированно &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea049099ad2942c413fff09669264ab1e5dd87b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; cannot fit in a 32-bit integer.</source>
          <target state="translated">Если &lt;code&gt;Operation&lt;/code&gt; не может поместиться в 32-битное целое число.</target>
        </trans-unit>
        <trans-unit id="9a2af5fb3189d023dbe0c347471fbf3afbf37fe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; does not fit in a 32-bit integer.</source>
          <target state="translated">Если &lt;code&gt;Operation&lt;/code&gt; не подходит для 32-битного целого числа.</target>
        </trans-unit>
        <trans-unit id="2ef59a44cc7221066ae352f1c66be399d1a45ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opt&lt;/code&gt; is any atom, it is interpreted as &lt;code&gt;{Opt,true}&lt;/code&gt; unless the atom string starts with &lt;code&gt;&quot;no&quot;&lt;/code&gt;, making the interpretation &lt;code&gt;{Opt,false}&lt;/code&gt;. For example, &lt;code&gt;usevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,true}&lt;/code&gt; and &lt;code&gt;nousevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,false}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Opt&lt;/code&gt; - это любой атом, он интерпретируется как &lt;code&gt;{Opt,true}&lt;/code&gt; , если строка атомов не начинается с &lt;code&gt;&quot;no&quot;&lt;/code&gt; , что делает интерпретацию &lt;code&gt;{Opt,false}&lt;/code&gt; . Например, &lt;code&gt;usevc&lt;/code&gt; - это псевдоним для &lt;code&gt;{usevc,true}&lt;/code&gt; , а &lt;code&gt;nousevc&lt;/code&gt; - это псевдоним для &lt;code&gt;{usevc,false}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31127aa2062d718c77d7a07ba00f404218c5e042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptList&lt;/code&gt; is not a proper list of valid &lt;code&gt;Opt&lt;/code&gt;s.</source>
          <target state="translated">Если &lt;code&gt;OptList&lt;/code&gt; не является правильным списком допустимых &lt;code&gt;Opt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b4363da74d53cb9c45989d6ac83b5d6bbd19064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptParams&lt;/code&gt; is not given, the default value &lt;code&gt;[]&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;OptParams&lt;/code&gt; не указан, используется значение по умолчанию &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a510b4980f05110bb42f2051f210307d0b27183c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Option&lt;/code&gt; is an invalid option.</source>
          <target state="translated">Если &lt;code&gt;Option&lt;/code&gt; является недопустимым вариантом.</target>
        </trans-unit>
        <trans-unit id="12e88c8f64ffe2e4621e2429aa9df040b6734c5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid list of options.</source>
          <target state="translated">Если &lt;code&gt;OptionList&lt;/code&gt; является недопустимым списком параметров.</target>
        </trans-unit>
        <trans-unit id="28172abefdf60c0ffbe1b8a62b1fc04dc23fb874" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid option list.</source>
          <target state="translated">Если &lt;code&gt;OptionList&lt;/code&gt; является недопустимым списком опций.</target>
        </trans-unit>
        <trans-unit id="93bbd7b2e7d83031f59c92a0c8ccb1cc60d19148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is not a list.</source>
          <target state="translated">Если &lt;code&gt;OptionList&lt;/code&gt; не является списком.</target>
        </trans-unit>
        <trans-unit id="47de326f53be67167a635f5060809e5db271ba9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt; float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6133e7ac28cc0038bd62a0b0ae71e4da87c1eca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Options&lt;/code&gt; - &lt;code&gt;[]&lt;/code&gt; , функция ведет себя как &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7730b5d34ec1da622c3e568e7e8a64ba1d2bd89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is a list, this is equivalent to &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt;, otherwise it is equivalent to &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt;. However, using this function directly is more efficient.</source>
          <target state="translated">Если &lt;code&gt;Options&lt;/code&gt; является списком, это эквивалентно &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt; , в противном случае оно эквивалентно &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt; . Однако использование этой функции напрямую более эффективно ,</target>
        </trans-unit>
        <trans-unit id="9fde3e06c0c33f9a7645abc8b6b8f5e2ebe7f59a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, the format is as follows:</source>
          <target state="translated">Если &lt;code&gt;Options&lt;/code&gt; не &lt;code&gt;[]&lt;/code&gt; , формат будет следующим:</target>
        </trans-unit>
        <trans-unit id="30be8f5cb2762ca72a34cc75e497114c5814d418" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opts&lt;/code&gt; is not specified or if it is &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created. If &lt;code&gt;Opts = [append]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is not deleted. The new information is appended at the end of the file.</source>
          <target state="translated">Если &lt;code&gt;Opts&lt;/code&gt; не указан или имеет значение &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; удаляется и создается новый файл. Если &lt;code&gt;Opts = [append]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; не удаляется. Новая информация добавляется в конец файла.</target>
        </trans-unit>
        <trans-unit id="373e624d641069009ec67c8a54cd85bd2a2d72ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Out&lt;/code&gt; is specified, &lt;code&gt;FormatHandler&lt;/code&gt; gets the file descriptor to &lt;code&gt;Out&lt;/code&gt; as the first parameter.</source>
          <target state="translated">Если указан &lt;code&gt;Out&lt;/code&gt; , &lt;code&gt;FormatHandler&lt;/code&gt; получает дескриптор файла как &lt;code&gt;Out&lt;/code&gt; в качестве первого параметра.</target>
        </trans-unit>
        <trans-unit id="fad332308463a8263339bd3390b05cbefc19f3b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt;, option &lt;code&gt;asynchronous&lt;/code&gt; of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; has been used and the suspendee has not yet been suspended by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt; , вариант &lt;code&gt;asynchronous&lt;/code&gt; из &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; был использован и suspendee до сих пор не была приостановлена &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbfc8cfc7a6d48dbab3e59b020a0ba36f02f8cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Path&lt;/code&gt; is a directory, &lt;code&gt;default_index/2&lt;/code&gt;, it starts searching for resources or files that are specified in the config directive &lt;code&gt;DirectoryIndex&lt;/code&gt;. If an appropriate resource or file is found, it is appended to the end of &lt;code&gt;Path&lt;/code&gt; and then returned. &lt;code&gt;Path&lt;/code&gt; is returned unaltered if no appropriate file is found or if &lt;code&gt;Path&lt;/code&gt; is not a directory. &lt;code&gt;config_db()&lt;/code&gt; is the server config file in ETS table format as described in &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Path&lt;/code&gt; - это каталог, &lt;code&gt;default_index/2&lt;/code&gt; , он начинает поиск ресурсов или файлов, указанных в директиве конфигурации &lt;code&gt;DirectoryIndex&lt;/code&gt; . Если соответствующий ресурс или файл найден, он добавляется в конец &lt;code&gt;Path&lt;/code&gt; и затем возвращается. &lt;code&gt;Path&lt;/code&gt; возвращается без изменений, если соответствующий файл не найден или если &lt;code&gt;Path&lt;/code&gt; не является каталогом. &lt;code&gt;config_db()&lt;/code&gt; - это файл конфигурации сервера в формате таблицы ETS, как описано в &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beefd85af55dff03d967de6fd4d575f5153ffe35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are valid patterns, the following is also a valid pattern:</source>
          <target state="translated">Если &lt;code&gt;Pattern1&lt;/code&gt; и &lt;code&gt;Pattern2&lt;/code&gt; являются действительными модели, следующий правильный образец:</target>
        </trans-unit>
        <trans-unit id="92bd28fe3699fc72ccf1ee88565e6cbd3a896278" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern&lt;/code&gt; is not a binary or a flat proper list of binaries with length &amp;gt; 0, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;Pattern&lt;/code&gt; не является двоичным или плоским правильным списком двоичных файлов с длиной&amp;gt; 0, &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="e7fc7f98492ea4c007c2957660a86f1f0df53bcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; does not exist, the 'DOWN' message is sent immediately with &lt;code&gt;Reason&lt;/code&gt; set to &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Pid2&lt;/code&gt; не существует, немедленно отправляется сообщение DOWN с параметром &lt;code&gt;Reason&lt;/code&gt; , установленным в &lt;code&gt;noproc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4791446d4ac7a4577450d1706f57f608bc60d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; terminates with exit reason &lt;code&gt;Reason&lt;/code&gt;, a 'DOWN' message is sent to &lt;code&gt;Pid1&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;Pid2&lt;/code&gt; завершается с указанием причины выхода &lt;code&gt;Reason&lt;/code&gt; , на &lt;code&gt;Pid1&lt;/code&gt; отправляется сообщение DOWN :</target>
        </trans-unit>
        <trans-unit id="c802432eb292a24b574add89af76bf12c415ea21" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4ad4270f00a30d3a004edfbf6bb0907bb89e24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">Если &lt;code&gt;Pid&lt;/code&gt; равен &lt;code&gt;self()&lt;/code&gt; и не &lt;code&gt;async&lt;/code&gt; опция async , сборка мусора выполняется сразу, то есть так же, как при вызове &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; . В противном случае запрос на сборку мусора отправляется процессу, идентифицированному &lt;code&gt;Pid&lt;/code&gt; , и будет обработан при необходимости. Если параметр &lt;code&gt;async&lt;/code&gt; не был передан, вызывающий блокируется до &lt;code&gt;GCResult&lt;/code&gt; пор, пока GCResult не станет доступным и не будет возвращен.</target>
        </trans-unit>
        <trans-unit id="e39d7c1dcb4424a9d8e01705e3e21bd11e62c069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and is handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;CheckResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">Если &lt;code&gt;Pid&lt;/code&gt; равен &lt;code&gt;self()&lt;/code&gt; и не была передана опция &lt;code&gt;async&lt;/code&gt; , операция выполняется сразу. В противном случае запрос операции отправляется процессу, указанному &lt;code&gt;Pid&lt;/code&gt; , и обрабатывается, когда это необходимо. Если параметр &lt;code&gt;async&lt;/code&gt; не был передан, вызывающий блокируется до &lt;code&gt;CheckResult&lt;/code&gt; пор, пока CheckResult не станет доступным и может быть возвращен.</target>
        </trans-unit>
        <trans-unit id="9a5e58475adf385dca728b097c7c732d60714c40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is an I/O device, that is, a pid returned from &lt;code&gt;open/2&lt;/code&gt;, this function returns the filename, or rather:</source>
          <target state="translated">Если &lt;code&gt;Pid&lt;/code&gt; является устройством ввода-вывода, то есть pid, возвращенным из &lt;code&gt;open/2&lt;/code&gt; , эта функция возвращает имя файла, а точнее:</target>
        </trans-unit>
        <trans-unit id="2c88872158412481d4632dbb6c4d0828fafd3ef7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Если &lt;code&gt;Pid&lt;/code&gt; не является локальным процессом.</target>
        </trans-unit>
        <trans-unit id="0c4258af24e0c809dc0bd9d32eeea697ff1e2cb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a node local process identifier.</source>
          <target state="translated">Если &lt;code&gt;Pid&lt;/code&gt; не является идентификатором локального процесса узла.</target>
        </trans-unit>
        <trans-unit id="a85548fa2767eaff370c38aaf90f8964627aa367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not trapping exits, &lt;code&gt;Pid&lt;/code&gt; itself exits with exit reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Pid&lt;/code&gt; не является захватом, &lt;code&gt;Pid&lt;/code&gt; сам выходит с причиной выхода &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981b0f8c411a07f7ef682ac79981f9ce74ca69e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Pid&lt;/code&gt; перехватывает выходы, сигнал выхода преобразуется в сообщение &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; и доставляется в очередь сообщений &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="946409162988d6dc1aff5bb11d67c23349fa4844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist and checking it is cheap, a &lt;code&gt;noproc&lt;/code&gt; error is raised. Currently, checking is cheap if the &lt;code&gt;PidOrPort&lt;/code&gt; is local and the caller does not trap exits (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2 &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e139aa51e35a6da6edcc143ed04c057990132602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Если &lt;code&gt;PidOrPort&lt;/code&gt; не существует, поведение BIF зависит от того, перехватывает ли вызывающий процесс выходы или нет (см. &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="266b9e9cd253c4e1b334cac8528b2a62708531c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; is not an existing local process or port.</source>
          <target state="translated">Если &lt;code&gt;PidOrPort&lt;/code&gt; не является существующим локальным процессом или портом.</target>
        </trans-unit>
        <trans-unit id="ea3c1727e46c2f29d355231a14b993fe9ee7f045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns a free UDP port, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">Если &lt;code&gt;Port == 0&lt;/code&gt; , базовая ОС назначает свободный порт UDP, используйте &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; для его получения.</target>
        </trans-unit>
        <trans-unit id="d7fa31d4ca670522aa140145b3a60537cc2e5b54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns an available port number, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">Если &lt;code&gt;Port == 0&lt;/code&gt; , базовая ОС назначает доступный номер порта, используйте &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; для его получения.</target>
        </trans-unit>
        <trans-unit id="fb219559d25b9731f030a5d6d757dbdd7db890b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">Если &lt;code&gt;Port&lt;/code&gt; не является идентификатором открытого порта или зарегистрированным именем открытого порта. Если вызывающий процесс был ранее связан с закрытым портом, идентифицированным &lt;code&gt;Port&lt;/code&gt; , сигнал выхода из порта гарантированно будет доставлен до того, как &lt;code&gt;badarg&lt;/code&gt; это исключение badarg .</target>
        </trans-unit>
        <trans-unit id="0702a363d6583ab49124103adeca84fa54bd565c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an open port or the registered name of an open port.</source>
          <target state="translated">Если &lt;code&gt;Port&lt;/code&gt; не является открытым портом или зарегистрированным именем открытого порта.</target>
        </trans-unit>
        <trans-unit id="ad97fac62d783a4932985f8dd89585d539b9ba38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;PosLen&lt;/code&gt; каким-либо образом ссылается за пределы двоичного &lt;code&gt;badarg&lt;/code&gt; , возникает исключение badarg .</target>
        </trans-unit>
        <trans-unit id="5fa9284a8e57969389fe13ab25086a491ce7496c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is the prefix of &lt;code&gt;String&lt;/code&gt;, removes it and returns the remainder of &lt;code&gt;String&lt;/code&gt;, otherwise returns &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Prefix&lt;/code&gt; является префиксом &lt;code&gt;String&lt;/code&gt; , удаляет его и возвращает остаток &lt;code&gt;String&lt;/code&gt; , в противном случае возвращает &lt;code&gt;nomatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4e6b8924461855959440e4adc224de1af86a752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QH2&lt;/code&gt; is a call to the function for &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt;, as defined in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;gb_table:table/1&lt;/code&gt;, the iterator for the gb-tree is initiated for each answer to &lt;code&gt;QH1&lt;/code&gt;. The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if &lt;code&gt;QH2&lt;/code&gt; is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating &lt;code&gt;QH2&lt;/code&gt; has no side effects so that the meaning of the query does not change if &lt;code&gt;QH2&lt;/code&gt; is evaluated only once. One way of caching the answers is to evaluate &lt;code&gt;QH2&lt;/code&gt; first of all and substitute the list of answers for &lt;code&gt;QH2&lt;/code&gt; in the query. Another way is to use option &lt;code&gt;cache&lt;/code&gt;. It is expressed like this:</source>
          <target state="translated">Если &lt;code&gt;QH2&lt;/code&gt; - это вызов функции для &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; , как определено в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;gb_table:table/1&lt;/code&gt; , итератор для gb-дерева инициируется для каждого ответа на &lt;code&gt;QH1&lt;/code&gt; . Затем объекты gb-дерева возвращаются один за другим. Это, вероятно, наиболее эффективный способ обхода таблицы в этом случае, поскольку для получения следующего объекта требуется минимальная вычислительная мощность. Но если &lt;code&gt;QH2&lt;/code&gt; - это не таблица, а более сложный QLC, может быть более эффективным использовать некоторую оперативную память для сбора ответов в кеше, особенно если ответов всего несколько. Следовательно, следует предположить, что оценка &lt;code&gt;QH2&lt;/code&gt; не имеет побочных эффектов, так что смысл запроса не меняется, если &lt;code&gt;QH2&lt;/code&gt; оценивается только один раз. Один из способов кэширования ответов - сначала оценить &lt;code&gt;QH2&lt;/code&gt; и заменить в запросе список ответов на &lt;code&gt;QH2&lt;/code&gt; . Другой способ - использовать &lt;code&gt;cache&lt;/code&gt; опций . Выражается это так:</target>
        </trans-unit>
        <trans-unit id="491d904b6ae249fbebb7daf8bc786e22605cc650" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;kill&lt;/code&gt;, that is, if &lt;code&gt;exit(Pid, kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;Pid&lt;/code&gt;, which unconditionally exits with exit reason &lt;code&gt;killed&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Reason&lt;/code&gt; является атом &lt;code&gt;kill&lt;/code&gt; , то есть, если &lt;code&gt;exit(Pid, kill)&lt;/code&gt; , называется, untrappable сигнал выхода посылаются &lt;code&gt;Pid&lt;/code&gt; , который безоговорочно выходит с выходом причиной &lt;code&gt;killed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35fbbe7923611fc3677c5eb123690517ee7e8658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;Pid&lt;/code&gt; does not exit. If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">Если &lt;code&gt;Reason&lt;/code&gt; &lt;code&gt;normal&lt;/code&gt; атом , &lt;code&gt;Pid&lt;/code&gt; не выходит. Если это захват выхода, сигнал выхода преобразуется в сообщение &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; и доставляется в его очередь сообщений.</target>
        </trans-unit>
        <trans-unit id="cd196dac154540858e61e812e21e07f3f0b754dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; has the value &lt;code&gt;{Tag, Recv}&lt;/code&gt;, the delivery is done according to &lt;code&gt;Recv&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;Receiver&lt;/code&gt; имеет значение &lt;code&gt;{Tag, Recv}&lt;/code&gt; , доставка осуществляется в соответствии с &lt;code&gt;Recv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="868986f0a85c44f9afa64f0b61bdc67eb57beed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; is a &lt;code&gt;notification_delivery_info()&lt;/code&gt; record, then the information about the notification delivery will be delivered to the &lt;code&gt;receiver&lt;/code&gt; via the callback functions defined by the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour according to the content of the &lt;code&gt;notification_delivery_info()&lt;/code&gt; record.</source>
          <target state="translated">Если &lt;code&gt;Receiver&lt;/code&gt; - это запись &lt;code&gt;notification_delivery_info()&lt;/code&gt; , то информация о доставке уведомления будет доставлена &lt;code&gt;receiver&lt;/code&gt; через функции обратного вызова, определенные поведением &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; в соответствии с содержимым записи &lt;code&gt;notification_delivery_info()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="508d6986d5eeb87f61b9a5f9d5b4f17fa77bcfb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is already in use.</source>
          <target state="translated">Если &lt;code&gt;RegName&lt;/code&gt; уже используется.</target>
        </trans-unit>
        <trans-unit id="ae95dfac53a373131ac9010b1c1e1134c4182f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;RegName&lt;/code&gt; - это атом &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f5e564e5fd5ab3c1d7b8ad071d580aac2f45e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Repair&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current log file is repaired, if needed. As the restoration is initiated, a message is output on the error log. If &lt;code&gt;false&lt;/code&gt; is specified, no automatic repair is attempted. Instead, the tuple &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; is returned if an attempt is made to open a corrupt log file. If &lt;code&gt;truncate&lt;/code&gt; is specified, the log file becomes truncated, creating an empty log. Defaults to &lt;code&gt;true&lt;/code&gt;, which has no effect on logs opened in read-only mode.</source>
          <target state="translated">Если &lt;code&gt;Repair&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , текущий файл журнала ремонта, если это необходимо. Когда восстановление начато, в журнал ошибок выводится сообщение. Если указано значение &lt;code&gt;false&lt;/code&gt; , попытки автоматического восстановления не выполняются. Вместо этого возвращается кортеж &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; если делается попытка открыть поврежденный файл журнала. Если указано &lt;code&gt;truncate&lt;/code&gt; , файл журнала усекается, создавая пустой журнал. По умолчанию установлено значение &lt;code&gt;true&lt;/code&gt; , что не влияет на журналы, открытые в режиме только для чтения.</target>
        </trans-unit>
        <trans-unit id="fba0a2d131df8af1eeb91211c8b8a8dde41e75fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Report&lt;/code&gt; is a map, it is converted to a key-value list before formatting as such.</source>
          <target state="translated">Если &lt;code&gt;Report&lt;/code&gt; представляет собой карту, он преобразуется в список ключей и значений перед форматированием как таковым.</target>
        </trans-unit>
        <trans-unit id="15d8d66582408c3486d2e25500d0a72b68b8cb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ReqId&lt;/code&gt; is less then 0, it means that this information was not available to the manager (that info was never retrieved before the message was discarded).</source>
          <target state="translated">Если &lt;code&gt;ReqId&lt;/code&gt; меньше 0, это означает, что эта информация не была доступна менеджеру (эта информация никогда не была получена до того, как сообщение было отброшено).</target>
        </trans-unit>
        <trans-unit id="0dee047b2dfd5610136ab93118e486cde7422df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, the packet only consists of &lt;code&gt;[119, Result]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, пакет состоит только из &lt;code&gt;[119, Result]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c802495174a415d0a94a21a32d111d68231fb125" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This because the timer had expired, or been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</source>
          <target state="translated">Если &lt;code&gt;Result&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; , таймер, соответствующий &lt;code&gt;TimerRef&lt;/code&gt; , не может быть найден. Это связано с тем, что таймер истек, или он был отменен, или потому, что &lt;code&gt;TimerRef&lt;/code&gt; никогда не соответствовал таймеру. Даже если таймер истек, он не сообщает вам, прибыло ли сообщение о тайм-ауте по назначению.</target>
        </trans-unit>
        <trans-unit id="c0a8cfe624c240dfdb507f48e9d219914e2f948e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This can be either because the timer had expired, already had been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</source>
          <target state="translated">Если &lt;code&gt;Result&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; , таймер, соответствующий &lt;code&gt;TimerRef&lt;/code&gt; , не может быть найден. Это может происходить либо потому, что таймер истек, либо уже был отменен, либо потому, что &lt;code&gt;TimerRef&lt;/code&gt; никогда не соответствовал таймеру. Даже если таймер истек, он не сообщает вам, прибыло ли сообщение о тайм-ауте по назначению.</target>
        </trans-unit>
        <trans-unit id="bd4390894559b806475261afd409260099fb0615" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</source>
          <target state="translated">Если &lt;code&gt;Result&lt;/code&gt; является целым числом, он представляет время в миллисекундах, оставшееся до истечения отмененного таймера.</target>
        </trans-unit>
        <trans-unit id="8b2e483082bcb6a7c95be17d5564ab01e1806263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the timer expires.</source>
          <target state="translated">Если &lt;code&gt;Result&lt;/code&gt; является целым числом, он представляет время в миллисекундах, оставшееся до истечения таймера.</target>
        </trans-unit>
        <trans-unit id="996c07f00aef0bf25f1adad8d4b5c2f0b7da6aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Rules&lt;/code&gt; is left out or is an empty list, the default system rules are used. See also the Kernel application parameter &lt;code&gt;source_search_rules&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Rules&lt;/code&gt; не указаны или это пустой список, используются системные правила по умолчанию. См. Также параметр приложения ядра &lt;code&gt;source_search_rules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="914c10ab17b1be80fb703c7a051a9650d90020cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Schedulers&lt;/code&gt; or &lt;code&gt;SchedulersOnline&lt;/code&gt; is specified as a negative number, the value is subtracted from the default number of logical processors configured or logical processors available, respectively.</source>
          <target state="translated">Если &lt;code&gt;Schedulers&lt;/code&gt; или &lt;code&gt;SchedulersOnline&lt;/code&gt; указаны как отрицательное число, значение вычитается из числа настроенных логических процессоров по умолчанию или доступных логических процессоров соответственно.</target>
        </trans-unit>
        <trans-unit id="1d347e571bfea9b8b89077684381b3f15fcd946f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Scope&lt;/code&gt; of the operation is &lt;code&gt;local&lt;/code&gt;, the fallback is only installed on the local node.</source>
          <target state="translated">Если &lt;code&gt;Scope&lt;/code&gt; действия является &lt;code&gt;local&lt;/code&gt; , резервная копия устанавливается только на локальном узле.</target>
        </trans-unit>
        <trans-unit id="998a85ab406edc34895d37ac87304bcc5cc05937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">Если &lt;code&gt;Server&lt;/code&gt; является &lt;code&gt;self()&lt;/code&gt; , анонимный сервер создается так же, как при использовании &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt; . Если &lt;code&gt;Server&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; именованный сервер создается так же, как при использовании &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt; . Однако имя &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; должно быть соответствующим образом зарегистрировано &lt;strong&gt;перед вызовом&lt;/strong&gt; этой функции.</target>
        </trans-unit>
        <trans-unit id="1c6410f6c768335757d34c90fcb80d9e00d2828e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link|_monitor]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link|_monitor]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26e129826cd4fdc57a94f1e90b9b33f3e22dc0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ccf350dd38e4a46c92e05cf1457282aa2a2b57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">Если &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; , тот &lt;code&gt;gen_server&lt;/code&gt; идентификатор процесс зарегистрирован во всем мире как &lt;code&gt;GlobalName&lt;/code&gt; использование &lt;code&gt;global:register_name/2&lt;/code&gt; Если имя не предусмотрено, то &lt;code&gt;gen_server&lt;/code&gt; процесс не зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="c99d7d2ec0751d55a79f6c64ef86b68f3b33366c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={local,Name}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ServerName={local,Name}&lt;/code&gt; , процесс &lt;code&gt;gen_server&lt;/code&gt; регистрируется локально как &lt;code&gt;Name&lt;/code&gt; с помощью &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4471e49d4ac17a2da6d90db02e958498fd4eca78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Если &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt; , те &lt;code&gt;gen_server&lt;/code&gt; регистры процесса с реестром представлены &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; обратного вызова для экспорта функции &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; , и &lt;code&gt;send/2&lt;/code&gt; , которые ведут себя , как соответствующие функции в &lt;code&gt;global&lt;/code&gt; . Таким образом, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; является допустимой ссылкой.</target>
        </trans-unit>
        <trans-unit id="1a7d3d4777e0d9530a017faf5e5e71aeba400cf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server_or_Actions&lt;/code&gt; is a &lt;code&gt;list()&lt;/code&gt;, the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered and &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt;. This creates an anonymous server.</source>
          <target state="translated">Если &lt;code&gt;Server_or_Actions&lt;/code&gt; - это &lt;code&gt;list()&lt;/code&gt; , то же самое, что и &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; , за исключением того, что не должно быть зарегистрировано имя &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; и Действия = Server_or_Actions . Это создает анонимный сервер.</target>
        </trans-unit>
        <trans-unit id="0cc5ba33de3003e688f8911d6e6894d616033d12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SetFun&lt;/code&gt; is a number i &amp;gt;= 1 and &lt;code&gt;Set1&lt;/code&gt; is a relation, then the returned set is the &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set1&lt;/code&gt; onto coordinate i.</source>
          <target state="translated">Если &lt;code&gt;SetFun&lt;/code&gt; этого числа я&amp;gt; = 1 и &lt;code&gt;Set1&lt;/code&gt; есть отношение, то возвращается множество является &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;Set1&lt;/code&gt; на координатах А.</target>
        </trans-unit>
        <trans-unit id="fa9d9044e1d8e367fe63682c042ce5ba7e21718e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">Если &lt;code&gt;Socket&lt;/code&gt; является обычным &lt;code&gt;socket()&lt;/code&gt; : обновляет &lt;code&gt;gen_tcp&lt;/code&gt; или эквивалентный сокет до SSL-сокета, то есть выполняет квитирование SSL / TLS на стороне сервера и возвращает сокет TLS.</target>
        </trans-unit>
        <trans-unit id="3a8532805c883f6bbdef2dbf1ab5fafde57ede65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the TLS server-side handshake and returns a TLS socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51cfa021b587914b8d535a367aab8a9c4e3a8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;#type-sslsocket&quot;&gt; sslsocket() &lt;/a&gt;&lt;/code&gt;: provides extra TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7fd7fd2a8598b74434eb489d432414fe4daa4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;sslsocket()&lt;/code&gt;: provides extra SSL/TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">Если &lt;code&gt;Socket&lt;/code&gt; является &lt;code&gt;sslsocket()&lt;/code&gt; : предоставляет дополнительные параметры SSL / TLS / DTLS к тем, которые указаны в &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; , а затем выполняет квитирование SSL / TLS / DTLS. Возвращает новый сокет TLS / DTLS, если рукопожатие прошло успешно.</target>
        </trans-unit>
        <trans-unit id="4841c9f7a71e862586a5146811fbbbda9e0a5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;read&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">Если &lt;code&gt;Source&lt;/code&gt; ссылается на имя файла, он открывается с режимом &lt;code&gt;read&lt;/code&gt; добавленным к списку режимов перед копией, и закрывается по завершении.</target>
        </trans-unit>
        <trans-unit id="b32d5c9aabdee11f000c96e5dc5cd00d32eea8d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt;, separate tests will be created per specification. If &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt;, all specifications will be merge into one test.</source>
          <target state="translated">Если &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt; , для каждой спецификации будут созданы отдельные тесты. Если &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt; , все спецификации будут объединены в один тест.</target>
        </trans-unit>
        <trans-unit id="64318942ad99e2a283846e85b41c1a1a90a245d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Streams&lt;/code&gt; is an empty list, &lt;strong&gt;all&lt;/strong&gt; streams are requested by sending the following filter:</source>
          <target state="translated">Если &lt;code&gt;Streams&lt;/code&gt; - пустой список, &lt;strong&gt;все&lt;/strong&gt; потоки запрашиваются путем отправки следующего фильтра:</target>
        </trans-unit>
        <trans-unit id="5a57f3a703460decb9f940e7b918e0ac60764ffe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bddbecc2df41f591669985046f32e7a92f59d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; , мост супервизора регистрируется глобально как &lt;code&gt;Name&lt;/code&gt; с использованием &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b58db32cac80b6fba959bc6eb9beb456afa271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt;, the supervisor bridge is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt; , мост супервизора регистрируется локально как &lt;code&gt;Name&lt;/code&gt; с использованием &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72424d21ee1e4f64401815083aa13a425812c98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt;, the supervisor bridge is registered as &lt;code&gt;Name&lt;/code&gt; using a registry represented by Module. The &lt;code&gt;Module&lt;/code&gt; callback is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Если &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt; , мост супервизора регистрируется как &lt;code&gt;Name&lt;/code&gt; с использованием реестра, представленного модулем. &lt;code&gt;Module&lt;/code&gt; обратного вызова для функции экспорта &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , и &lt;code&gt;send/2&lt;/code&gt; , которые ведут себя , как соответствующие функции в &lt;code&gt;global&lt;/code&gt; . Таким образом, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; является допустимой ссылкой.</target>
        </trans-unit>
        <trans-unit id="e6570ba727a9a3893fd9a3d0b799b833bf1451e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7b2fcdf9c47fb2dceee651299ffa41113ce50c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;SupName={global,Name}&lt;/code&gt; , супервизор регистрируется глобально как &lt;code&gt;Name&lt;/code&gt; с использованием &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94898f62db8e0366c9e39384d40e7b1aeef50e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={local,Name}&lt;/code&gt;, the supervisor is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;SupName={local,Name}&lt;/code&gt; , супервизор регистрируется локально как &lt;code&gt;Name&lt;/code&gt; с помощью &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="302a4ec0f93e1a3b85f4525fc68100cb7ea134fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt;, the supervisor is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback must export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which must behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Если &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt; , супервизор регистрируется как &lt;code&gt;Name&lt;/code&gt; с использованием реестра, представленного &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; обратного вызова должен экспортировать функции &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , и &lt;code&gt;send/2&lt;/code&gt; , который должен вести себя , как соответствующие функции в &lt;code&gt;global&lt;/code&gt; . Таким образом, &lt;code&gt;{via,global,Name}&lt;/code&gt; является допустимой ссылкой.</target>
        </trans-unit>
        <trans-unit id="e19abc8d0154d9b15c235deec3229c13afe0bfd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Suspendee&lt;/code&gt; is not a process identifier.</source>
          <target state="translated">Если &lt;code&gt;Suspendee&lt;/code&gt; не является идентификатором процесса.</target>
        </trans-unit>
        <trans-unit id="c9f3eb71690e00c625f528d1a166e4c2803c3742" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; can be matched, the function returns a non-zero value and binds any unbound variables in &lt;code&gt;Pattern&lt;/code&gt;. If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; do not match, &lt;code&gt;0&lt;/code&gt; is returned. For example:</source>
          <target state="translated">Если &lt;code&gt;Term&lt;/code&gt; и &lt;code&gt;Pattern&lt;/code&gt; могут быть сопоставлены, функция возвращает ненулевое значение и связывает любые несвязанные переменные в &lt;code&gt;Pattern&lt;/code&gt; . Если &lt;code&gt;Term&lt;/code&gt; и &lt;code&gt;Pattern&lt;/code&gt; не совпадают, возвращается &lt;code&gt;0&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="c379e61ba098c472d84880da68787d8cf49e4a92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;, no timer is started, as it never would expire anyway.</source>
          <target state="translated">Если &lt;code&gt;Time&lt;/code&gt; равно &lt;code&gt;infinity&lt;/code&gt; , таймер не запускается, так как он никогда не истечет.</target>
        </trans-unit>
        <trans-unit id="361b493363d47b76898e36a3b534cb11d8d0b1ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events.</source>
          <target state="translated">Если &lt;code&gt;Time&lt;/code&gt; является относительным и &lt;code&gt;0&lt;/code&gt; таймер фактически не запущен, вместо этого событие тайм-аута ставится в очередь, чтобы гарантировать, что оно будет обработано до любого еще не полученного внешнего события, но после уже поставленных в очередь событий.</target>
        </trans-unit>
        <trans-unit id="53be15db077d9f7386a9212d414b5bbc5efc8b98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event.</source>
          <target state="translated">Если &lt;code&gt;Time&lt;/code&gt; является относительным и &lt;code&gt;0&lt;/code&gt; таймер фактически не запущен, вместо этого событие тайм-аута ставится в очередь, чтобы гарантировать, что оно будет обработано до любого еще не полученного внешнего события.</target>
        </trans-unit>
        <trans-unit id="576d56f7b80afa9316129970fc76da4c8c90a6b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;Ret = {error, timeout}&lt;/code&gt; will be returned, and the process is killed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df42bd176e1545f79c00a2e65e652086e9d32d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;{error, timeout}&lt;/code&gt; is returned, and the process is killed.</source>
          <target state="translated">Если &lt;code&gt;Time&lt;/code&gt; указано как целое число, эта функция ожидает в миллисекундах &lt;code&gt;Time&lt;/code&gt; , пока новый процесс вызовет &lt;code&gt;init_ack&lt;/code&gt; , или возвращается &lt;code&gt;{error, timeout}&lt;/code&gt; , и процесс завершается .</target>
        </trans-unit>
        <trans-unit id="4be60462090656e0a73c06a85dd1300e3f12ecfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Timeout&lt;/code&gt; is set to an integer value in milliseconds, Mnesia forces &quot;heavyweight transactions&quot; to be finished, even if the outcome of the transaction for the moment is unclear. After &lt;code&gt;Timeout&lt;/code&gt; milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</source>
          <target state="translated">Если для &lt;code&gt;Timeout&lt;/code&gt; установлено целочисленное значение в миллисекундах, Mnesia принудительно завершает &amp;laquo;тяжелые транзакции&amp;raquo;, даже если результат транзакции на данный момент неясен. После &lt;code&gt;Timeout&lt;/code&gt; миллисекунд, Mnesia совершает или прекращает транзакцию и продолжает с запуском. Это может привести к ситуации, когда транзакция фиксируется на некоторых узлах и завершается на других узлах. Если транзакция является транзакцией схемы, несогласованность может быть фатальной.</target>
        </trans-unit>
        <trans-unit id="714a8fc4e60ac83febb0eba6e2e43aa29c1e43cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; и &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116f28b654e1b2114f084ce63da092181669b950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; и &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54f93f73769a89bfaa867aaa2f8894d3965b6413" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TupleOfBinRels&lt;/code&gt; is a non-empty tuple {R[1], ..., R[n]} of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;TupleOfBinRels&lt;/code&gt; - это непустой кортеж {R [1], ..., R [n]} бинарных отношений, а &lt;code&gt;BinRel1&lt;/code&gt; - бинарное отношение, то &lt;code&gt;BinRel2&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; упорядоченного набора (R [i], ..., R [n]) и &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c970d03f8f213aa54cea6a63852543e1427736a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded.</source>
          <target state="translated">Если &lt;code&gt;Type = load&lt;/code&gt; , приложение только загружается.</target>
        </trans-unit>
        <trans-unit id="ef46ddc91155f5582e897510a78e384c324f3ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">Если &lt;code&gt;Type = none&lt;/code&gt; , приложение не загружается и не запускается, хотя код его модулей загружается.</target>
        </trans-unit>
        <trans-unit id="ee9c99386deae4cad26ab6d667423f3c8e7d9d82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt;, the application is loaded and started in the corresponding way, see &lt;code&gt;application(3)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt; , приложение загружается и запускается соответствующим образом, см. &lt;code&gt;application(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d0f32ad447a0f124722ae3ffd089ea15b0187a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;file&lt;/code&gt;, the client reads all trace messages stored in the file named &lt;code&gt;Filename&lt;/code&gt; or specified by &lt;code&gt;WrapFilesSpec&lt;/code&gt; (must be the same as used when creating the trace, see trace_port/2) and let's the default handler function format the messages on the console. This is one way to interpret the data stored in a file by the file trace port driver.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; - это &lt;code&gt;file&lt;/code&gt; , клиент читает все сообщения трассировки, хранящиеся в файле с именем &lt;code&gt;Filename&lt;/code&gt; или указанные в &lt;code&gt;WrapFilesSpec&lt;/code&gt; (должно быть таким же, как при создании трассировки, см. Trace_port / 2), и позволяет функции обработчика по умолчанию форматировать сообщения на консоли. , Это один из способов интерпретации данных, хранящихся в файле, драйвером порта трассировки файла.</target>
        </trans-unit>
        <trans-unit id="a4858c659d369e53d254b355df46af5fbf4c16d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;follow_file&lt;/code&gt;, the client behaves as in the &lt;code&gt;file&lt;/code&gt; case, but keeps trying to read (and process) more data from the file until stopped by &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;WrapFilesSpec&lt;/code&gt; is not allowed as second argument for this &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; - &lt;code&gt;follow_file&lt;/code&gt; , клиент ведет себя так же, как и в случае с &lt;code&gt;file&lt;/code&gt; , но продолжает попытки прочитать (и обработать) больше данных из файла до тех пор, пока не будет остановлен &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;WrapFilesSpec&lt;/code&gt; не допускается в качестве второго аргумента для этого &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="180a1fd075134b1e3a57e62da41207ab78634934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ip&lt;/code&gt;, the client connects to the TCP/IP port &lt;code&gt;PortNumber&lt;/code&gt; on the host &lt;code&gt;Hostname&lt;/code&gt;, from where it reads trace messages until the TCP/IP connection is closed. If no &lt;code&gt;Hostname&lt;/code&gt; is specified, the local host is assumed.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; равен &lt;code&gt;ip&lt;/code&gt; , клиент подключается к порту TCP / IP &lt;code&gt;PortNumber&lt;/code&gt; на хосте &lt;code&gt;Hostname&lt;/code&gt; , откуда он читает сообщения трассировки, пока соединение TCP / IP не будет закрыто. Если имя &lt;code&gt;Hostname&lt;/code&gt; не указано, предполагается локальный хост.</target>
        </trans-unit>
        <trans-unit id="e7f9b8934106158303967177ea69d38323fb0f5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;port&lt;/code&gt;, then the second parameter should be a &lt;strong&gt;fun&lt;/strong&gt; which takes no arguments and returns a newly opened trace port when called. Such a &lt;strong&gt;fun&lt;/strong&gt; is preferably generated by calling &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; - &lt;code&gt;port&lt;/code&gt; , то второй параметр должен быть &lt;strong&gt;забавным,&lt;/strong&gt; не принимающим аргументов и возвращающим вновь открытый порт трассировки при вызове. Такое &lt;strong&gt;развлечение&lt;/strong&gt; предпочтительно генерируется вызовом &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcff9f93e9e05e724456b0bced8193fb3bde0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;process&lt;/code&gt;, a message handler function can be specified (&lt;code&gt;HandlerSpec&lt;/code&gt;). The handler function, which should be a &lt;code&gt;fun&lt;/code&gt; taking two arguments, will be called for each trace message, with the first argument containing the message as it is and the second argument containing the return value from the last invocation of the fun. The initial value of the second parameter is specified in the &lt;code&gt;InitialData&lt;/code&gt; part of the &lt;code&gt;HandlerSpec&lt;/code&gt;. The &lt;code&gt;HandlerFun&lt;/code&gt; may choose any appropriate action to take when invoked, and can save a state for the next invocation by returning it.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; - это &lt;code&gt;process&lt;/code&gt; , можно указать функцию обработчика сообщений ( &lt;code&gt;HandlerSpec&lt;/code&gt; ). Функция-обработчик, которая должна быть &lt;code&gt;fun&lt;/code&gt; принимая два аргумента, будет вызываться для каждого сообщения трассировки, причем первый аргумент будет содержать сообщение как есть, а второй аргумент будет содержать возвращаемое значение из последнего вызова развлечения. Начальное значение второго параметра задается в &lt;code&gt;InitialData&lt;/code&gt; части &lt;code&gt;HandlerSpec&lt;/code&gt; . &lt;code&gt;HandlerFun&lt;/code&gt; может выбрать любое соответствующее действие, предпринимаемое при вызове, и может сохранить состояние для следующего вызова, возвращая его.</target>
        </trans-unit>
        <trans-unit id="a4b1b3641b22ef8f8d51a93d3b2d1b2337213cb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;public_key&lt;/code&gt; the binary can be either an RFC4716 public key or an OpenSSH public key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a5ca48186c13c4c06e74ef1db2027011e4bcd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, the object to match against is to be a tuple. The function then returns &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;ets:select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match the object tuple.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; - &lt;code&gt;table&lt;/code&gt; , то объект для сопоставления должен быть кортежем. Затем функция возвращает &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt; , где &lt;code&gt;Result&lt;/code&gt; - это результат реального вызова &lt;code&gt;ets:select/2&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , если спецификация соответствия не соответствует кортежу объекта.</target>
        </trans-unit>
        <trans-unit id="79b1b01424133793a9f87e15e6618830f393c840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;trace&lt;/code&gt;, the object to match against is to be a list. The function returns &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is one of the following:</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; - &lt;code&gt;trace&lt;/code&gt; , то объект для сопоставления должен быть списком. Функция возвращает &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt; , где &lt;code&gt;Result&lt;/code&gt; может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="55c96c3e31c21901d76762cfc3c55a1a75e182d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is not one of the memory types listed in the description of &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Type&lt;/code&gt; не является одним из типов памяти, перечисленных в описании &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09015d085c4ba86f35f77e160ea74ab1cc97841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[]&lt;/code&gt; is returned, no OS monotonic time is available. The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">Если возвращается &lt;code&gt;[]&lt;/code&gt; , монотонное время ОС недоступно. Список содержит два кортежа с &lt;code&gt;Key&lt;/code&gt; s в качестве первого элемента и &lt;code&gt;Value&lt;/code&gt; s в качестве второго элемента. Порядок этих кортежей не определен. Следующие кортежи могут быть частью списка, но в будущем могут быть добавлены другие кортежи:</target>
        </trans-unit>
        <trans-unit id="0dab6e7436a7ad654f072804193938c789548d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[node()]&lt;/code&gt; then a connection is rejected if another already exists on any of the specified nodes. Types &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;nodes&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[node()]&lt;/code&gt;, &lt;code&gt;[node()|nodes()]&lt;/code&gt; and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that &lt;code&gt;false&lt;/code&gt; allows an unlimited number of connections to be established with the same peer.</source>
          <target state="translated">Если &lt;code&gt;[node()]&lt;/code&gt; то соединение отклоняется, если другое уже существует на любом из указанных узлов. Типы &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; , &lt;code&gt;nodes&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; эквивалентны &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;[node()]&lt;/code&gt; , &lt;code&gt;[node()|nodes()]&lt;/code&gt; и оцененному значению соответственно, оценка каждого выражения происходит всякий раз, когда новое соединение должно быть установлено. Обратите внимание, что &lt;code&gt;false&lt;/code&gt; позволяет устанавливать неограниченное количество соединений с одним и тем же узлом.</target>
        </trans-unit>
        <trans-unit id="295d7333eb893d35be93e144e1767e5d9b639f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;active&lt;/code&gt; is specified as an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), that number is added to the socket's counting of data messages to be delivered to the controlling process. If the result of the addition is negative, the count is set to &lt;code&gt;0&lt;/code&gt;. Once the count reaches &lt;code&gt;0&lt;/code&gt;, either through the delivery of messages or by being explicitly set with &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, the socket mode is automatically reset to passive (&lt;code&gt;{active, false}&lt;/code&gt;). When a socket in this active mode transitions to passive mode, the message &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; to set the socket back into an active mode.</source>
          <target state="translated">Если &lt;code&gt;active&lt;/code&gt; указано как целое число &lt;code&gt;N&lt;/code&gt; в диапазоне от -32768 до 32767 (включительно), это число добавляется к подсчету сокетом сообщений с данными, которые должны быть доставлены контролирующему процессу. Если результат сложения отрицательный, счетчик устанавливается на &lt;code&gt;0&lt;/code&gt; . Как только счетчик достигает &lt;code&gt;0&lt;/code&gt; , либо посредством доставки сообщений, либо путем явной установки с помощью &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; , режим сокета автоматически сбрасывается на пассивный ( &lt;code&gt;{active, false}&lt;/code&gt; ). Когда сокет в этом активном режиме переходит в пассивный режим, сообщение &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; отправляется контролирующему процессу, чтобы уведомить его о том, что, если он хочет получить больше сообщений с данными от сокета, он должен вызвать &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; , чтобы вернуть сокет в активный режим.</target>
        </trans-unit>
        <trans-unit id="03b183ed01691db59614d150f25d033d938031cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alloc&lt;/code&gt; succeeds, &lt;code&gt;dealloc&lt;/code&gt; is also executed. If &lt;code&gt;alloc&lt;/code&gt; fails however, &lt;code&gt;dealloc&lt;/code&gt; is not executed but marked as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log. &lt;code&gt;get_resource_status&lt;/code&gt; runs no matter what happens to the &lt;code&gt;alloc_and_dealloc&lt;/code&gt; cases.</source>
          <target state="translated">Если &lt;code&gt;alloc&lt;/code&gt; успешно, &lt;code&gt;dealloc&lt;/code&gt; также выполняется. Если &lt;code&gt;alloc&lt;/code&gt; не удается , однако, &lt;code&gt;dealloc&lt;/code&gt; не выполняется , но помечено как &lt;code&gt;SKIPPED&lt;/code&gt; в журнале HTML. &lt;code&gt;get_resource_status&lt;/code&gt; запускается независимо от того, что происходит с случаями &lt;code&gt;alloc_and_dealloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="352b5321f6cc2147596cc6f32fa64b28aba14c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;answer_3xxx&lt;/code&gt; then requests are answered without a &lt;code&gt;handle_request/3&lt;/code&gt; callback taking place. If &lt;code&gt;answer&lt;/code&gt; then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If &lt;code&gt;callback&lt;/code&gt; then a &lt;code&gt;handle_request/3&lt;/code&gt; callback always takes place and its return value determines the answer sent to the peer, if any.</source>
          <target state="translated">Если &lt;code&gt;answer_3xxx&lt;/code&gt; , то на запросы отвечают без обратного вызова &lt;code&gt;handle_request/3&lt;/code&gt; . Если &lt;code&gt;answer&lt;/code&gt; то даже на ошибки 5xxx будет дан ответ без обратного вызова, если рассматриваемое соединение не настроило общий словарь RFC 3588, как указано ниже. Если &lt;code&gt;callback&lt;/code&gt; то всегда выполняется обратный вызов &lt;code&gt;handle_request/3&lt;/code&gt; , и его возвращаемое значение определяет ответ, отправленный партнеру, если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="cdb44b71a12e090bedfcba4386a9f7329590c298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;audit_trail_log&lt;/code&gt; specifies that logging should take place, this parameter &lt;strong&gt;must&lt;/strong&gt; be defined.</source>
          <target state="translated">Если &lt;code&gt;audit_trail_log&lt;/code&gt; указывает, что ведение журнала должно выполняться, этот параметр &lt;strong&gt;должен&lt;/strong&gt; быть определен.</target>
        </trans-unit>
        <trans-unit id="5c3452c6586d61bda15fc59fe771d58878ac0b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;auto_ack&lt;/code&gt; is true, then if &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, ack's will be sent immediately. If &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then ack's will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;auto_ack&lt;/code&gt; имеет значение true, то если &lt;code&gt;trans_ack&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , подтверждение будет отправлено немедленно. Если &lt;code&gt;trans_ack&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , то Ack - х вместо этого будет направлен в процесс отправителя транзакций для накопления и последующей отправки (см &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; и &lt;code&gt;trans_timer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f3ff30c8bf2c3590c81efa740a7d601076daf88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; then errors result in a &lt;code&gt;handle_answer/4&lt;/code&gt; callback in the same fashion as for &lt;code&gt;handle_request/3&lt;/code&gt;, with errors communicated in the &lt;code&gt;errors&lt;/code&gt; field of the &lt;code&gt;#diameter_packet{}&lt;/code&gt; passed to the callback. If &lt;code&gt;report&lt;/code&gt; then an answer containing errors is discarded without a callback and a warning report is written to the log. If &lt;code&gt;discard&lt;/code&gt; then an answer containing errors is silently discarded without a callback. In both the &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; cases the return value for the &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; invocation in question is as if a callback had taken place and returned &lt;code&gt;{error, failure}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;callback&lt;/code&gt; то ошибки приводят к &lt;code&gt;handle_answer/4&lt;/code&gt; таким же образом, как и для &lt;code&gt;handle_request/3&lt;/code&gt; , с сообщением об &lt;code&gt;errors&lt;/code&gt; поле ошибок &lt;code&gt;#diameter_packet{}&lt;/code&gt; переданного в обратный вызов. Если &lt;code&gt;report&lt;/code&gt; то ответ, содержащий ошибки, отбрасывается без обратного вызова, а отчет с предупреждением записывается в журнал. Если &lt;code&gt;discard&lt;/code&gt; то ответ, содержащий ошибки, автоматически отбрасывается без обратного вызова. И в случае &lt;code&gt;report&lt;/code&gt; и в случае &lt;code&gt;discard&lt;/code&gt; возвращаемое значение для рассматриваемого &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; такое, как если бы был выполнен обратный вызов и возвращено &lt;code&gt;{error, failure}&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="62c065b9fb27488b0e771951e56438f1b6383335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch4&lt;/code&gt; is part of the application &lt;code&gt;sp_app&lt;/code&gt; and a new version of the module is to be loaded when upgrading from version &quot;1&quot; to &quot;2&quot; of this application, &lt;code&gt;sp_app.appup&lt;/code&gt; can look as follows:</source>
          <target state="translated">Если &lt;code&gt;ch4&lt;/code&gt; является частью приложения &lt;code&gt;sp_app&lt;/code&gt; и новая версия модуля должна быть загружена при обновлении с версии &amp;laquo;1&amp;raquo; до &amp;laquo;2&amp;raquo; этого приложения, &lt;code&gt;sp_app.appup&lt;/code&gt; может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="704192b50b25e6b4c8a4a69ec853e8732712c9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cp1&lt;/code&gt; goes down, the system checks which one of the other nodes, &lt;code&gt;cp2&lt;/code&gt; or &lt;code&gt;cp3&lt;/code&gt;, has the least number of running applications, but waits for 5 seconds for &lt;code&gt;cp1&lt;/code&gt; to restart. If &lt;code&gt;cp1&lt;/code&gt; does not restart and &lt;code&gt;cp2&lt;/code&gt; runs fewer applications than &lt;code&gt;cp3&lt;/code&gt;, &lt;code&gt;myapp&lt;/code&gt; is restarted on &lt;code&gt;cp2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;cp1&lt;/code&gt; выходит из строя, система проверяет, какой из других узлов, &lt;code&gt;cp2&lt;/code&gt; или &lt;code&gt;cp3&lt;/code&gt; , имеет наименьшее количество запущенных приложений, но ожидает в течение 5 секунд перезапуска &lt;code&gt;cp1&lt;/code&gt; . Если &lt;code&gt;cp1&lt;/code&gt; не перезапускается и &lt;code&gt;cp2&lt;/code&gt; запускает меньше приложений, чем &lt;code&gt;cp3&lt;/code&gt; , &lt;code&gt;myapp&lt;/code&gt; перезапускается на &lt;code&gt;cp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17771800350279f555431c07bc7909375d85a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ct_run&lt;/code&gt; is called with option &lt;code&gt;-help&lt;/code&gt;, it prints all valid start flags to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ct_run&lt;/code&gt; вызывается с опцией &lt;code&gt;-help&lt;/code&gt; , он выводит все допустимые стартовые флаги в стандартный &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d7ad1711ae125314f622ecddd1f476bedaa098f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;drop_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;flush_qlen&lt;/code&gt;, drop mode is disabled and can never occur.</source>
          <target state="translated">Если &lt;code&gt;drop_mode_qlen&lt;/code&gt; имеет то же значение, что и &lt;code&gt;flush_qlen&lt;/code&gt; , режим отбрасывания отключен и никогда не произойдет.</target>
        </trans-unit>
        <trans-unit id="c399745e103b947fe1a2d216d913038686b47941" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; called then a connected emulator will send bit strings and export funs correctly encoded. The functions &lt;code&gt;&lt;a href=&quot;#ei_decode_bitstring&quot;&gt;ei_decode_bitstring&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#ei_decode_fun&quot;&gt;ei_decode_fun&lt;/a&gt;&lt;/code&gt; has to be used to decode such terms. Calling &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; should only be done as a workaround to keep an old implementation alive, which expects to receive the undocumented tuple formats for bit strings and/or export funs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173618b78a011b048e525d9c552841f6185552f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_call/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_call/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="585b6dae1b75f75f6d17ff008d7c715232f527c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b7353e255834b234c18ea03d27108e34a19f8a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_ports/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d175b45d5ebd8073a81917e2e671529596546a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_procs/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ebe9ceea886c3c6d1719971aa43295e9c7ed38b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_receive/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_receive/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10f4f080f33a6c7add14620c4ce363f7b8950eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_running_ports/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4a84bb3f76762c65d3520facf2a72bcfc1f2ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_running_procs/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b251834b95dc454e5654dddcf65d7d5d05abbdf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_send/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;enabled_send/3&lt;/code&gt; не определен, вместо него вызывается &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48960527f8e8df817720dc59ec79a9e715127fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read_line/1&lt;/code&gt; call fails if the data contains characters larger than 255, why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">Если для &lt;code&gt;encoding&lt;/code&gt; установлено значение , &lt;code&gt;read_line/1&lt;/code&gt; от &lt;code&gt;latin1&lt;/code&gt; , вызов read_line / 1 завершится ошибкой, если данные содержат символы больше 255, поэтому при чтении такого файла предпочтительнее использовать модуль &lt;code&gt;io(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02ece68d22a0388d64a0607adb76ac441dd5ca33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the (unfortunately undocumented) &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">Если &lt;code&gt;epmd&lt;/code&gt; должен использоваться для обнаружения узлов, вы обычно хотите использовать (к сожалению, недокументированный) модуль &lt;code&gt;erl_epmd&lt;/code&gt; (часть приложения &lt;code&gt;kernel&lt;/code&gt; ), чтобы зарегистрировать порт прослушивания в &lt;code&gt;epmd&lt;/code&gt; и получить &lt;code&gt;Creation&lt;/code&gt; для использования.</target>
        </trans-unit>
        <trans-unit id="c86ec487c7e02fab4d117367477d9817cdcbd441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48eb5a7215dde7b0dc8037cba2427a3618b189d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если для &lt;code&gt;erl_script_nocache&lt;/code&gt; задано значение &lt;code&gt;true&lt;/code&gt; , сервер добавляет поля заголовка HTTP, не позволяющие прокси-серверам кэшировать страницу. Как правило, это хорошая идея для динамического содержимого, поскольку содержимое часто меняется в зависимости от запроса. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74b3b9e997b2f242f5469345dd4b6f37734c75d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_timeout&lt;/code&gt; sets the time in seconds the server waits between each chunk of data to be delivered through &lt;code&gt;mod_esi:deliver/2&lt;/code&gt;. Default is &lt;code&gt;15&lt;/code&gt;. This is only relevant for scripts that use the erl scheme.</source>
          <target state="translated">Если &lt;code&gt;erl_script_timeout&lt;/code&gt; устанавливает время в секундах, сервер ожидает между каждым &lt;code&gt;mod_esi:deliver/2&lt;/code&gt; данных, который будет доставлен через mod_esi: delivery / 2 . По умолчанию &lt;code&gt;15&lt;/code&gt; . Это актуально только для скриптов, использующих схему erl.</target>
        </trans-unit>
        <trans-unit id="642c708a719a284794b6696e0acb8a429739f8e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c49f84d1938c55d129db8f559247ec6ced174b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;error_logger&lt;/code&gt; не определен на карте, используется системное значение по умолчанию. Системное значение по умолчанию &lt;code&gt;true&lt;/code&gt; . Его можно изменить с помощью опции &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1f0b5e86017500297a623ccd787481972405c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, all ones that is &lt;code&gt;-1&lt;/code&gt; type cast to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; are returned.</source>
          <target state="translated">Если &lt;code&gt;ev&lt;/code&gt; равно &lt;code&gt;NULL&lt;/code&gt; , возвращаются все те, которые имеют тип &lt;code&gt;-1&lt;/code&gt; , приведенный к &lt;code&gt;ErlDrvSizeT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a523dc7e77a84691bbad3e5ffc300c86d69172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit&lt;/code&gt; then the transport process in question exits. If &lt;code&gt;handle&lt;/code&gt; then the message is processed as usual, a resulting &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callback (if one takes place) indicating the &lt;code&gt;5015&lt;/code&gt; error (DIAMETER_INVALID_MESSAGE_LENGTH). If &lt;code&gt;discard&lt;/code&gt; then the message in question is silently discarded.</source>
          <target state="translated">В случае &lt;code&gt;exit&lt;/code&gt; соответствующий транспортный процесс завершается. Если &lt;code&gt;handle&lt;/code&gt; , то сообщение обрабатывается как обычно, в результате &lt;code&gt;handle_request/3&lt;/code&gt; обратный вызов handle_request / 3 или &lt;code&gt;handle_answer/4&lt;/code&gt; (если он имеет место), указывающий на ошибку &lt;code&gt;5015&lt;/code&gt; (DIAMETER_INVALID_MESSAGE_LENGTH). Если &lt;code&gt;discard&lt;/code&gt; то рассматриваемое сообщение автоматически отбрасывается.</target>
        </trans-unit>
        <trans-unit id="ca99bf6a729fabb69715993d01ee3f7329b5f3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, Epp}&lt;/code&gt;.</source>
          <target state="translated">Если в &lt;code&gt;Options&lt;/code&gt; указано &lt;code&gt;extra&lt;/code&gt; , возвращаемое значение будет &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; вместо &lt;code&gt;{ok, Epp}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621b05f8dd3dbf24d54370fe9dfbe14fc856ec52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, [Form]}&lt;/code&gt;.</source>
          <target state="translated">Если в &lt;code&gt;Options&lt;/code&gt; указано &lt;code&gt;extra&lt;/code&gt; , возвращаемое значение будет &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; вместо &lt;code&gt;{ok, [Form]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3047d3a672144cba0e123255c2c3997f12bb72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; (passive mode, the default), the caller must do an explicit &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; call to retrieve the available data from the socket.</source>
          <target state="translated">Если &lt;code&gt;false&lt;/code&gt; (пассивный режим, по умолчанию), вызывающий должен сделать явный вызов &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; , чтобы получить доступные данные из сокета.</target>
        </trans-unit>
        <trans-unit id="56e3643f360d9383768007f097296d7135ef22f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then peers are not shared. If &lt;code&gt;[node()]&lt;/code&gt; then peers are shared with the specified list of nodes. If &lt;code&gt;eval()&lt;/code&gt; then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</source>
          <target state="translated">Если &lt;code&gt;false&lt;/code&gt; , одноранговые узлы не используются. Если &lt;code&gt;[node()]&lt;/code&gt; то одноранговые узлы используются совместно с указанным списком узлов. Если &lt;code&gt;eval()&lt;/code&gt; то одноранговые узлы используются совместно с узлами, возвращаемыми указанной функцией, и оцениваются всякий раз, когда одноранговое соединение становится доступным или удаленная служба запрашивает информацию о локальных соединениях. Значение &lt;code&gt;true&lt;/code&gt; эквивалентно &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; . Значение &lt;code&gt;node()&lt;/code&gt; в списке игнорируется, поэтому можно настроить набор служб для совместного использования с одним и тем же списком узлов.</target>
        </trans-unit>
        <trans-unit id="61331cf5138ed4df60722b0902d831feeb5514c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then remote peers are not used. If &lt;code&gt;[node()]&lt;/code&gt; then only peers from the specified list of nodes are used. If &lt;code&gt;eval()&lt;/code&gt; then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored.</source>
          <target state="translated">Если &lt;code&gt;false&lt;/code&gt; , то удаленные узлы не используются. Если &lt;code&gt;[node()]&lt;/code&gt; то используются только одноранговые узлы из указанного списка узлов. Если &lt;code&gt;eval()&lt;/code&gt; то используются только одноранговые узлы, возвращенные указанной функцией, которые оцениваются всякий раз, когда удаленная служба передает информацию о доступном одноранговом соединении. Значение &lt;code&gt;true&lt;/code&gt; эквивалентно &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; . Значение &lt;code&gt;node()&lt;/code&gt; в списке игнорируется.</target>
        </trans-unit>
        <trans-unit id="515f5f660b2b6a5321a3301134d45702f7c8d34e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the &lt;code&gt;known_hosts&lt;/code&gt; file, or supplying a password.</source>
          <target state="translated">Если &lt;code&gt;false&lt;/code&gt; , запрещает клиенту подключаться к серверу, если требуется какое-либо взаимодействие с пользователем, например принятие сервера для добавления в файл &lt;code&gt;known_hosts&lt;/code&gt; или предоставление пароля.</target>
        </trans-unit>
        <trans-unit id="2f21ed8efde9cbba7a84e9561d2bee32978fafa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, the key is not saved and the key will still be unknown at the next access of the same host.</source>
          <target state="translated">Если &lt;code&gt;false&lt;/code&gt; , ключ не сохраняется, и ключ все равно будет неизвестен при следующем доступе того же хоста.</target>
        </trans-unit>
        <trans-unit id="6c171a334054ea3d178b695378164bb4717dbc73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">Если &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; возвращает &lt;code&gt;latin1&lt;/code&gt; , перевод имен путей не выполняется.</target>
        </trans-unit>
        <trans-unit id="174e5b29f214dbcb97eabc33b079cdd65ed3ff4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">Если &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; возвращает &lt;code&gt;utf8&lt;/code&gt; , имена путей кодируются в UTF-8 при создании файлов tar, а имена путей предполагается кодировать в UTF-8 при извлечении файлов tar.</target>
        </trans-unit>
        <trans-unit id="53f00d54c4cf2784d07f86c8a1f69d22126e8edd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;final&lt;/code&gt; is returned, the time offset was already in the final state. This either because another &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; call or because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Если возвращается &lt;code&gt;final&lt;/code&gt; , смещение времени уже было в конечном состоянии. Это либо из-за другого &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; либо из-за того, что &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; используется режим временной деформации .</target>
        </trans-unit>
        <trans-unit id="7d84ff72a66a5f1dc4702c44281724bb233b3cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; , резервная копия включает только те объекты, которые были созданы, изменены или удалены с момента последнего резервного копирования или восстановления (то есть инкрементной резервной копии). После резервного копирования все объекты, которые были помечены как грязные, теперь чистые, а все объекты, которые были помечены для удаления, удаляются.</target>
        </trans-unit>
        <trans-unit id="1b22e611455eedf00229374381cf3ded5d86286d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;int *size&lt;/code&gt; is required, so that the size of the object can be returned.</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; - &lt;code&gt;EI_BIN&lt;/code&gt; , требуется пятый аргумент &lt;code&gt;int *size&lt;/code&gt; , чтобы можно было вернуть размер объекта.</target>
        </trans-unit>
        <trans-unit id="5d03c462ed0e1501d3ca648701da33656f727855" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;size&lt;/code&gt; is required, indicating the size in bytes of the object pointed to by &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; - &lt;code&gt;EI_BIN&lt;/code&gt; , требуется пятый &lt;code&gt;size&lt;/code&gt; аргумента , указывающий размер в байтах объекта, на который указывает &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef97c9cebbac0fa5b4a15003e98bfbe9b002c14c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a12847c8010acaf74585bb590e3d2d2892d7bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если вместо значения тайм-аута указан &lt;code&gt;hibernate&lt;/code&gt; , процесс переходит в спящий режим при ожидании прибытия следующего сообщения (путем вызова &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4370781db47a41ab4e7732b376aa87b3dd2e229d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indent_opt&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; (default), line breaks are inserted in types, contracts, and Erlang code to improve readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81060f399c0748631583d69217b03e975ffd94c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_group&lt;/code&gt; is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;init_per_group&lt;/code&gt; пропущен, эта функция вызывается после &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a09af08638c9468193e1b25b2f9c1bcc8d0b0d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; exists, it is called initially before the test cases are executed. It typically contains initializations common for all test cases in the suite, which are only to be performed once. &lt;code&gt;init_per_suite&lt;/code&gt; is recommended for setting up and verifying state and environment on the System Under Test (SUT) or the &lt;code&gt;Common Test&lt;/code&gt; host node, or both, so that the test cases in the suite executes correctly. The following are examples of initial configuration operations:</source>
          <target state="translated">Если &lt;code&gt;init_per_suite&lt;/code&gt; существует, он сначала вызывается перед выполнением тестовых примеров. Обычно он содержит общие для всех тестовых случаев в наборе инициализации, которые должны выполняться только один раз. &lt;code&gt;init_per_suite&lt;/code&gt; рекомендуется для настройки и проверки состояния и среды в тестируемой системе (SUT) или хост-узле &lt;code&gt;Common Test&lt;/code&gt; , либо на обоих, чтобы тестовые случаи в наборе выполнялись правильно. Ниже приведены примеры операций начальной настройки:</target>
        </trans-unit>
        <trans-unit id="e3cc6a46f9d6f7424ecfecec26999fd0b60da6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, all test cases in the test suite are skipped automatically (so called &lt;strong&gt;auto skipped&lt;/strong&gt;), including &lt;code&gt;end_per_suite&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;init_per_suite&lt;/code&gt; не работает, все тестовые примеры в наборе тестов пропускаются автоматически (так называемый &lt;strong&gt;автоматический пропуск&lt;/strong&gt; ), включая &lt;code&gt;end_per_suite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894e342a0e85afde6f3b96340c645a2b4dd22b1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;init_per_suite&lt;/code&gt; не работает, эта функция вызывается после &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe02f751dfef43151df61c0738ad37b3fb27d99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes (called &lt;strong&gt;auto skipped&lt;/strong&gt;).</source>
          <target state="translated">Если &lt;code&gt;init_per_testcase&lt;/code&gt; дает сбой (так называемый &lt;strong&gt;автоматический пропуск&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="7150a88f54c0b7881134625da98b5bed12371c8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes, or returns &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt;, function &lt;code&gt;end_per_testcase&lt;/code&gt; is not called.</source>
          <target state="translated">Если &lt;code&gt;init_per_testcase&lt;/code&gt; дает сбой или возвращает &lt;code&gt;{skip,Reason}&lt;/code&gt; или &lt;code&gt;{fail,Reason}&lt;/code&gt; , функция &lt;code&gt;end_per_testcase&lt;/code&gt; не вызывается.</target>
        </trans-unit>
        <trans-unit id="89e72fa5ab521b91a322a6c022357a5ac272ea72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; exists, it is called before each test case in the suite. It typically contains initialization that must be done for each test case (analog to &lt;code&gt;init_per_suite&lt;/code&gt; for the suite).</source>
          <target state="translated">Если &lt;code&gt;init_per_testcase&lt;/code&gt; существует, он вызывается перед каждым тестовым примером в наборе. Обычно он содержит инициализацию, которая должна выполняться для каждого тестового примера (аналог &lt;code&gt;init_per_suite&lt;/code&gt; для набора).</target>
        </trans-unit>
        <trans-unit id="72f622c1b041a5f9b4ffb1e9a77eb43b9ec5d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; returns a tuple &lt;code&gt;{skip,Reason}&lt;/code&gt; (called &lt;strong&gt;user skipped&lt;/strong&gt;).</source>
          <target state="translated">Если &lt;code&gt;init_per_testcase&lt;/code&gt; возвращает кортеж &lt;code&gt;{skip,Reason}&lt;/code&gt; (называемый &lt;strong&gt;пропущенным пользователем&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="d395c2bde7c4e5cd016e96c83e2790c6164bde6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt; are implemented similarly, we could write a &lt;code&gt;generic_access&lt;/code&gt; function using the &lt;code&gt;ListOfExtraArguments&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;ip_access&lt;/code&gt; и &lt;code&gt;name_access&lt;/code&gt; реализованы аналогично, мы могли бы написать функцию &lt;code&gt;generic_access&lt;/code&gt; , используя &lt;code&gt;ListOfExtraArguments&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab359c8b6df991113724100b5a067f71b56dbab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns the atom &lt;code&gt;false&lt;/code&gt;, some error has occurred and the server sends back the message:</source>
          <target state="translated">Если &lt;code&gt;keysearch&lt;/code&gt; возвращает атом &lt;code&gt;false&lt;/code&gt; , произошла некоторая ошибка, и сервер отправляет обратно сообщение:</target>
        </trans-unit>
        <trans-unit id="471dd07d8c17d433b665f7f28142ddb0c9a5ccb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns:</source>
          <target state="translated">Если &lt;code&gt;keysearch&lt;/code&gt; вернет:</target>
        </trans-unit>
        <trans-unit id="1a3183f931de40dbb6f7631f18d3f43161a10688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8473687ede2e043c5626f2dc6d081f3c7f8c834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;kill&lt;/code&gt; не определен на карте, будет использоваться системное значение по умолчанию. Системное значение по умолчанию &lt;code&gt;true&lt;/code&gt; . Его можно изменить с помощью опции &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;erl(1)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bce3cc2e82b9a6fd5502ccdd6aead42b567ec06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;local&lt;/code&gt; is specified as argument, Debugger interprets code only at the current node. If &lt;code&gt;global&lt;/code&gt; is specified as argument, Debugger interprets code at all known nodes, this is the default.</source>
          <target state="translated">Если в качестве аргумента указано &lt;code&gt;local&lt;/code&gt; , отладчик интерпретирует код только на текущем узле. Если в качестве аргумента указано &lt;code&gt;global&lt;/code&gt; , отладчик интерпретирует код на всех известных узлах, это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f7b7e2ac7280eca021f5062e79e83b7222745d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m:fact/1&lt;/code&gt; is called with a negative number as argument, no clause head matches. A &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">Если &lt;code&gt;m:fact/1&lt;/code&gt; вызывается с отрицательным числом в качестве аргумента, заголовок предложения не совпадает. Возникает ошибка времени выполнения &lt;code&gt;function_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78902773cd5b20b28d3f472a6d23e48932225627" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;master&lt;/code&gt;, one master agent is started. Otherwise, no agents are started.</source>
          <target state="translated">Если &lt;code&gt;master&lt;/code&gt; , запускается один главный агент. В противном случае никакие агенты не запускаются.</target>
        </trans-unit>
        <trans-unit id="ababfa264cf2c0471a517629bda5d420f24412f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is passed as &lt;code&gt;Type&lt;/code&gt; and the emulator is not run in instrumented mode.</source>
          <target state="translated">Если в качестве &lt;code&gt;Type&lt;/code&gt; передается &lt;code&gt;maximum&lt;/code&gt; а эмулятор не работает в инструментальном режиме.</target>
        </trans-unit>
        <trans-unit id="fb16ce380eb14a73a96ecf98dda7ccaebbde8485" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mon&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, a successful call stores the identity of the monitor in the &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; struct pointed to by &lt;code&gt;mon&lt;/code&gt;. This identifier is used to refer to the monitor for later removal with &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; or compare with &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt;. A monitor is automatically removed when it triggers or when the resource is deallocated.</source>
          <target state="translated">Если &lt;code&gt;mon&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , при успешном вызове идентификатор монитора &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; структуре ErlNifMonitor, на которую указывает &lt;code&gt;mon&lt;/code&gt; . Этот идентификатор используется для ссылки на монитор для последующего удаления с помощью &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; или сравнения с &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; . Монитор автоматически удаляется при срабатывании или освобождении ресурса.</target>
        </trans-unit>
        <trans-unit id="e7557ef34e7c482b82151565597fe49987e4f520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg_env&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;msg&lt;/code&gt; term is copied and the original term and its environment is still valid after the call.</source>
          <target state="translated">Если &lt;code&gt;msg_env&lt;/code&gt; установлено в &lt;code&gt;NULL&lt;/code&gt; , термин &lt;code&gt;msg&lt;/code&gt; копируется, а исходный термин и его окружение остаются действительными после вызова.</target>
        </trans-unit>
        <trans-unit id="3324f7db747bf81fb1767f13442861504e9e2dd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is running at &lt;code&gt;cp3&lt;/code&gt;, and if &lt;code&gt;cp2&lt;/code&gt; now restarts, it does not restart &lt;code&gt;myapp&lt;/code&gt;, as the order between the &lt;code&gt;cp2&lt;/code&gt; and &lt;code&gt;cp3&lt;/code&gt; nodes is undefined.</source>
          <target state="translated">Если &lt;code&gt;myapp&lt;/code&gt; работает на &lt;code&gt;cp3&lt;/code&gt; и если &lt;code&gt;cp2&lt;/code&gt; теперь перезапускается, он не перезапускает &lt;code&gt;myapp&lt;/code&gt; , поскольку порядок между &lt;code&gt;cp2&lt;/code&gt; и &lt;code&gt;cp3&lt;/code&gt; не определен.</target>
        </trans-unit>
        <trans-unit id="410c990db3f3097c54b66efc65b17fbe9e2bad60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nc&lt;/code&gt; is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carrier allocated by this allocator is roughly &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; when &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt;, and &lt;code&gt;lmbcs&lt;/code&gt; when &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt;. If the value of parameter &lt;code&gt;sbct&lt;/code&gt; is larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, the allocator may have to create multiblock carriers that are larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, though. Singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; are sized to whole pages.</source>
          <target state="translated">Если &lt;code&gt;nc&lt;/code&gt; - текущее количество многоблочных несущих (исключая основную многоблочную несущую), управляемую распределителем, размер следующей многоблочной несущей &lt;code&gt;mseg_alloc&lt;/code&gt; , выделенной этим распределителем, составляет примерно &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; , когда &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt; и &lt;code&gt;lmbcs&lt;/code&gt; , когда &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt; . Если значение параметра &lt;code&gt;sbct&lt;/code&gt; больше, чем значение параметра &lt;code&gt;lmbcs&lt;/code&gt; , распределителю может потребоваться создать многоблочные несущие, которые больше, чем значение параметра &lt;code&gt;lmbcs&lt;/code&gt; . Несущие одиночные блоки, выделенные через &lt;code&gt;mseg_alloc&lt;/code&gt; , имеют размер целых страниц.</target>
        </trans-unit>
        <trans-unit id="00a9d4efd00c94ba68d6320fea95c0909f36f665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated file sync operation is disabled, and it is the operating system settings that determine how quickly or slowly data is written to disk. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a file sync.</source>
          <target state="translated">Если &lt;code&gt;no_repeat&lt;/code&gt; задано как значение, повторная операция синхронизации файлов отключена, и именно параметры операционной системы определяют, насколько быстро или медленно данные записываются на диск. Пользователь также может вызвать &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; чтобы выполнить синхронизацию файлов.</target>
        </trans-unit>
        <trans-unit id="cf5fe50553f5c7b137deba5f80790419102c9acc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1 &lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960e9f5afba10edf0b60921b0e8e69fa2c34179d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">Если &lt;code&gt;no_repeat&lt;/code&gt; установлено как значение, повторная операция синхронизации отключена. Пользователь также может вызвать &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; для выполнения синхронизации disk_log.</target>
        </trans-unit>
        <trans-unit id="a26d7bcc04c3b56013d1be0c1072c79ecbf5d9d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;ei_connect()&lt;/code&gt; if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fc938fa7cba74ec1f9bb43ffd7daba5627a4cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;erl_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">Если &lt;code&gt;node&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , это указатель на буфер, в котором функция может заполнить имя узла, в котором найдено &lt;code&gt;name&lt;/code&gt; . &lt;code&gt;node&lt;/code&gt; может быть передан непосредственно в &lt;code&gt;erl_connect()&lt;/code&gt; если необходимо.</target>
        </trans-unit>
        <trans-unit id="8bcb0ecfc7e63283704c689b708fb3722abb28bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;once&lt;/code&gt;, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control and the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</source>
          <target state="translated">Если &lt;code&gt;once&lt;/code&gt; , в очередь сообщений автоматически помещается только одно сообщение, после чего режим автоматически сбрасывается на пассивный. Это обеспечивает управление потоком и возможность для получателя прослушивать входящие данные SCTP, чередующиеся с другими сообщениями между процессами.</target>
        </trans-unit>
        <trans-unit id="ef8342250cfaa0e36ec9bd08880c6f82e62cfce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;after&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is stopped. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;os_sup_enable&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , эта функция должна быть вызвана &lt;strong&gt;после&lt;/strong&gt; OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; останавливается. &lt;code&gt;Dir&lt;/code&gt; определяет каталог, который содержит резервную копию и специфичные для Erlang файлы конфигурации для &lt;code&gt;syslogd&lt;/code&gt; , а также именованный канал для получения сообщений от &lt;code&gt;syslogd&lt;/code&gt; . По умолчанию &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; . &lt;code&gt;Conf&lt;/code&gt; определяет полное имя файла конфигурации для &lt;code&gt;syslogd&lt;/code&gt; . По умолчанию &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a700fd6dad9f4c64ccd4666632fae200f7d79bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;before&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is started. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;os_sup_enable&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , эта функция должна быть вызвана &lt;strong&gt;до&lt;/strong&gt; того OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; запускается. &lt;code&gt;Dir&lt;/code&gt; определяет каталог, который содержит резервную копию и специфичные для Erlang файлы конфигурации для &lt;code&gt;syslogd&lt;/code&gt; , а также именованный канал для получения сообщений от &lt;code&gt;syslogd&lt;/code&gt; . По умолчанию &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; . &lt;code&gt;Conf&lt;/code&gt; определяет полное имя файла конфигурации для &lt;code&gt;syslogd&lt;/code&gt; . По умолчанию &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77f7d7d94477bf710f75a97f120cb44318c86bb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preliminary&lt;/code&gt; is returned, finalization was performed and the time offset is now final.</source>
          <target state="translated">Если возвращено &lt;code&gt;preliminary&lt;/code&gt; , завершение было выполнено, и теперь смещение по времени окончательное.</target>
        </trans-unit>
        <trans-unit id="68ca185ba5a790749853b97ac87472bb69e0f79b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;raw&lt;/code&gt; is not found in the list, it is added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a44d264c5bd3a087ba168aa0cf5ef541ffc19d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read/2&lt;/code&gt; calls are for sizes not significantly less than, or even greater than &lt;code&gt;Size&lt;/code&gt; bytes, no performance gain can be expected.</source>
          <target state="translated">Если вызовы &lt;code&gt;read/2&lt;/code&gt; предназначены для размеров, не намного меньше или даже больше, чем &lt;code&gt;Size&lt;/code&gt; bytes, нельзя ожидать увеличения производительности.</target>
        </trans-unit>
        <trans-unit id="3f7ab732c2a40901f7be417a921a39c57a4d5b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only get requests are logged.</source>
          <target state="translated">Если указано &lt;code&gt;read&lt;/code&gt; , в журнал записываются только запросы на получение.</target>
        </trans-unit>
        <trans-unit id="3b544ab09dc82eacf7049bd88c54823547cf046b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only received messages are logged.</source>
          <target state="translated">Если указано &lt;code&gt;read&lt;/code&gt; , в журнал записываются только полученные сообщения.</target>
        </trans-unit>
        <trans-unit id="4b7ba5f30d6fa892ea1037782ff4251339643dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">Если &lt;code&gt;read_concurrency&lt;/code&gt; был включен для таблицы.</target>
        </trans-unit>
        <trans-unit id="b29a25b884982cf8d002411e5810c5627d5ba822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, all requests are logged.</source>
          <target state="translated">Если &lt;code&gt;read_write&lt;/code&gt; , все запросы регистрируются.</target>
        </trans-unit>
        <trans-unit id="015bb54da55bcc930a4cbf6d43e9056cf7cdedf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, both outgoing and incoming messages are logged.</source>
          <target state="translated">Если &lt;code&gt;read_write&lt;/code&gt; , как исходящие, так и входящие сообщения регистрируются.</target>
        </trans-unit>
        <trans-unit id="b1376e2f35266b87691b21e50d6085d572b9fcbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;registered_name&lt;/code&gt; is part of &lt;code&gt;ItemList&lt;/code&gt; and the process has no name registered, a &lt;code&gt;{registered_name, []}&lt;/code&gt;, &lt;code&gt;InfoTuple&lt;/code&gt;&lt;strong&gt;will&lt;/strong&gt; be included in the resulting &lt;code&gt;InfoTupleList&lt;/code&gt;. This behavior is different when a single &lt;code&gt;Item =:= registered_name&lt;/code&gt; is specified, and when &lt;code&gt;process_info/1&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;registered_name&lt;/code&gt; является частью &lt;code&gt;ItemList&lt;/code&gt; , а у процесса нет зарегистрированного имени, в &lt;code&gt;InfoTuple&lt;/code&gt; &lt;strong&gt;будет&lt;/strong&gt; включен &lt;code&gt;{registered_name, []}&lt;/code&gt; , &lt;code&gt;InfoTupleList&lt;/code&gt; . Это поведение отличается, если указан один &lt;code&gt;Item =:= registered_name&lt;/code&gt; имя_регистрации и &lt;code&gt;process_info/1&lt;/code&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c5b2b100f53895b2b8688baa94d7b9678f28feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handler&lt;/code&gt; is returned, the event handler is deleted by calling &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt;.</source>
          <target state="translated">Если возвращается &lt;code&gt;remove_handler&lt;/code&gt; , обработчик события удаляется вызовом &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068df812b1be7a5c6fb7ba1d84c59687bbec92c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если для &lt;code&gt;script_nocache&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , HTTP-сервер по умолчанию добавляет поля заголовка, необходимые для предотвращения кэширования страницы прокси-серверами. Обычно это предпочтительно. По умолчанию &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d372c1d474f731f0f4b202ab8bda7211457e68a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_env/4&lt;/code&gt; is called before the application is loaded, the application environment values specified in file &lt;code&gt;Application.app&lt;/code&gt; override the ones previously set. This is also true for application reloads.</source>
          <target state="translated">Если &lt;code&gt;set_env/4&lt;/code&gt; вызывается до загрузки приложения, значения среды приложения, указанные в файле &lt;code&gt;Application.app&lt;/code&gt; , переопределяют ранее установленные. Это также верно для перезагрузки приложений.</target>
        </trans-unit>
        <trans-unit id="82d435019a14ecf65737ecf3db3bfd456332513c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the size of the head is placed there.</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , туда помещается размер головы.</target>
        </trans-unit>
        <trans-unit id="4feb70b4204ade06d5e528b8d52ed62d294cf47b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stop&lt;/code&gt; is returned, the log event is immediately discarded. If the filter is primary, no handler filters or callbacks are called. If it is a handler filter, the corresponding handler callback is not called, but the log event is forwarded to filters attached to the next handler, if any.</source>
          <target state="translated">Если возвращается &lt;code&gt;stop&lt;/code&gt; , событие журнала немедленно отбрасывается. Если фильтр является основным, фильтры обработчиков или обратные вызовы не вызываются. Если это фильтр обработчика, соответствующий обратный вызов обработчика не вызывается, но событие журнала пересылается фильтрам, прикрепленным к следующему обработчику, если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="4b0fd3902aab568d673cab668aeb876afecb3d16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, all log events are handled synchronously. That is, asynchronous logging is disabled.</source>
          <target state="translated">Если &lt;code&gt;sync_mode_qlen&lt;/code&gt; установлено в &lt;code&gt;0&lt;/code&gt; , все события журнала обрабатываются синхронно. То есть асинхронное ведение журнала отключено.</target>
        </trans-unit>
        <trans-unit id="fe26b781dc9f18c574b4f5cea83e1dc7a0898036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;drop_mode_qlen&lt;/code&gt;, synchronous mode is disabled. That is, the handler always runs in asynchronous mode, unless dropping or flushing is invoked.</source>
          <target state="translated">Если &lt;code&gt;sync_mode_qlen&lt;/code&gt; установлен в то же значение, что и &lt;code&gt;drop_mode_qlen&lt;/code&gt; , синхронный режим отключен. То есть обработчик всегда работает в асинхронном режиме, если не вызывается отбрасывание или сброс.</target>
        </trans-unit>
        <trans-unit id="df2d416ddedf4f1525642d418b4917eca16a89fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; identifies a node local port, this function initializes the port variable &lt;code&gt;*port_id&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the port is alive.</source>
          <target state="translated">Если &lt;code&gt;term&lt;/code&gt; идентифицирует локальный порт узла, эта функция инициализирует из него переменную порта &lt;code&gt;*port_id&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае возвращает &lt;code&gt;false&lt;/code&gt; . Проверка работоспособности порта не выполняется.</target>
        </trans-unit>
        <trans-unit id="bb931f96868f0894c3ee44964627cb220396fbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is a tuple, this function sets &lt;code&gt;*array&lt;/code&gt; to point to an array containing the elements of the tuple, and sets &lt;code&gt;*arity&lt;/code&gt; to the number of elements. Notice that the array is read-only and &lt;code&gt;(*array)[N-1]&lt;/code&gt; is the Nth element of the tuple. &lt;code&gt;*array&lt;/code&gt; is undefined if the arity of the tuple is zero.</source>
          <target state="translated">Если &lt;code&gt;term&lt;/code&gt; является кортежем, эта функция устанавливает &lt;code&gt;*array&lt;/code&gt; , чтобы он указывал на массив, содержащий элементы кортежа, и устанавливает &lt;code&gt;*arity&lt;/code&gt; на количество элементов. Обратите внимание, что массив доступен только для чтения и &lt;code&gt;(*array)[N-1]&lt;/code&gt; является N-м элементом кортежа. &lt;code&gt;*array&lt;/code&gt; не определен, если арность кортежа равна нулю.</target>
        </trans-unit>
        <trans-unit id="99ce7d95b89f5e150dfbf95c1a3d757a096ea716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is the pid of a node local process, this function initializes the pid variable &lt;code&gt;*pid&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the process is alive.</source>
          <target state="translated">Если &lt;code&gt;term&lt;/code&gt; - это pid локального процесса узла, эта функция инициализирует из него переменную &lt;code&gt;*pid&lt;/code&gt; и возвращает &lt;code&gt;true&lt;/code&gt; . В противном случае возвращает &lt;code&gt;false&lt;/code&gt; . Проверка работоспособности процесса не выполняется.</target>
        </trans-unit>
        <trans-unit id="335749543c3f3f2a3a67c44896ae9fd2f2a9abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;throw/1&lt;/code&gt; is not evaluated within a catch, a &lt;code&gt;nocatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Если &lt;code&gt;throw/1&lt;/code&gt; не оценивается в пределах catch, возникает &lt;code&gt;nocatch&lt;/code&gt; выполнения nocatch .</target>
        </trans-unit>
        <trans-unit id="2871fa0784bdb523b8ad094e354b3376cbc7c2d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531f47b8f34afb9e971187a621871b405723e46a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">Если &lt;code&gt;timetrap&lt;/code&gt; или &lt;code&gt;require&lt;/code&gt; не установлены, используются значения по умолчанию, указанные в &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (или &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="976ebeb2288ae33fa6c9a2ec2a28980aa636376c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">Если &lt;code&gt;timetrap&lt;/code&gt; или &lt;code&gt;require&lt;/code&gt; , или и то, и другое не установлены специально для конкретного тестового примера, используются значения по умолчанию, указанные в функции &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5b1ebc718d9766e9f004a96387fa62f22f383b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744ac3e017c02db9473330a8d4a2dec44a7e8e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_call/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_call/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e1c20b572719c3331469687919f2defd8437750" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6da64932aab510304a9e86727b1e2bcbdfe8f0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_ports/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50d620a56eb39b36411e41b4bc5a97c7bbafbd69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_procs/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9603bcd32c947b80ea34517cb4f3a01b71d378ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_receive/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_receive/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df75f373657f0f91332cb47e91e892abb9c113a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_running_ports/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5559d0a97110b67775d63df3a3e94529bc745fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_running_procs/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93b8b767ba992ffc91ebcedb4793839177d0df72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_send/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Если &lt;code&gt;trace_send/5&lt;/code&gt; не определен, вместо этого вызывается &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="901bf723e7561c2418b0b1c71d7584f891124177" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then request(s) will be sent immediately (in its own message).</source>
          <target state="translated">Если &lt;code&gt;trans_req&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; , то запрос (ы) будет отправлен немедленно (в своем сообщении).</target>
        </trans-unit>
        <trans-unit id="680ea9ebc8cd511dd23a5a2d9935ba441ee109e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is true, then request(s) will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;trans_req&lt;/code&gt; истинно, то вместо этого запрос (ы) будет отправлен процессу отправителя транзакции для накопления и последующей отправки (см. &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; и &lt;code&gt;trans_timer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="287b344c66382cf8b1edce4da0960025c7e9b57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (default), the server sends a cookie extension in its HelloRetryRequest messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70881a85aca398937951a4668c24337f4bc60ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode) there is no flow control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48e65bf83526cb9dd2dcc5eaa66577b4aa53e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode), the pending data or events are sent to the owning process.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; (полный активный режим), ожидающие данные или события отправляются процессу-владельцу.</target>
        </trans-unit>
        <trans-unit id="25420436cf7ea356d88467267bb54e499c6238b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;extended&lt;/code&gt;), the agent is multi-threaded, with one thread for each get request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d949864e0ff9ac2295f12de502f8af44fe5554" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the configuration files are re-read during start-up, and the contents of the configuration database ignored. Thus, if &lt;code&gt;true&lt;/code&gt;, changes to the configuration database are lost upon reboot of the agent.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , файлы конфигурации перечитываются во время запуска, а содержимое базы данных конфигурации игнорируется. Таким образом, если это &lt;code&gt;true&lt;/code&gt; , изменения в базе данных конфигурации теряются при перезагрузке агента.</target>
        </trans-unit>
        <trans-unit id="5742f9a48f2a77c8abfa93b7448bf87101200ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, hibernates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; before going into &lt;code&gt;receive&lt;/code&gt; to wait for a new external event.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; вызывая proc_lib: hibernate / 3 перед переходом в режим &lt;code&gt;receive&lt;/code&gt; для ожидания нового внешнего события.</target>
        </trans-unit>
        <trans-unit id="1c34bbe208e229e88b9cf884fe83c6e4487267fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, induces an error on an attempt to send a message larger than the current PMTU size (which would require fragmentation/reassembling). Notice that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , вызывает ошибку при попытке отправить сообщение, размер которого превышает текущий размер PMTU (что потребует фрагментации / повторной сборки). Обратите внимание, что фрагментация сообщения не влияет на логическую атомарность его доставки; эта опция предоставляется только по соображениям производительности.</target>
        </trans-unit>
        <trans-unit id="14dea9808b1f89c089706dd845be50b4ae8f0440" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if binds to the IP address. If &lt;code&gt;false&lt;/code&gt;, net_if listens on any IP address on the host where it is running.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , net_if привязывается к IP-адресу. Если &lt;code&gt;false&lt;/code&gt; , net_if прослушивает любой IP-адрес на хосте, на котором он запущен.</target>
        </trans-unit>
        <trans-unit id="1a887d631ac5987f669427d5f352faeefbf326b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if does not specify that the IP and port address should be reusable. If &lt;code&gt;false&lt;/code&gt;, the address is set to reusable.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , net_if не указывает, что IP-адрес и адрес порта должны быть повторно использованы. Если &lt;code&gt;false&lt;/code&gt; , адрес устанавливается повторно.</target>
        </trans-unit>
        <trans-unit id="f8ccef0dc480afe24c0ff21ece83c8c3800b5e39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it after a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd4ac0f7d30d624066e424ed5179bc26eafc35f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it when the state changes (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , откладывает текущее событие и повторяет его при изменении состояния ( &lt;code&gt;NextState =/= State&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="520af4aded931229fa7189fca614aa3fa7995a83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , агент является многопоточным, с одним потоком для каждого запроса на получение.</target>
        </trans-unit>
        <trans-unit id="89015f594d36423a0e641bd12c827ea801ee5cfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client does not print anything on authorization.</source>
          <target state="translated">Если это &lt;code&gt;true&lt;/code&gt; , то при авторизации клиент ничего не печатает.</target>
        </trans-unit>
        <trans-unit id="23b8e026fd6aadff53ba83122b74ea4391419aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , клиент сохраняет принятый ключ хоста, чтобы избежать вопроса о принятии при следующем подключении того же хоста. Если опция &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; отсутствует, ключ сохраняется в файле &amp;laquo;known_hosts&amp;raquo;. Смотрите опцию &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; для определения местоположения этого файла.</target>
        </trans-unit>
        <trans-unit id="95c8aecfc16da9f44601b813f0d7e51d5bf0f4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b356ac942be95783b518ac898149e69ff7f29e06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the execution time and reductions are accumulated.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , время выполнения и сокращения суммируются.</target>
        </trans-unit>
        <trans-unit id="a2c9b567f4306cd17d762c08a52cc878115d08b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the log owners are notified when certain log events occur. Defaults to &lt;code&gt;false&lt;/code&gt;. The owners are sent one of the following messages when an event occurs:</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , владельцы журналов получают уведомление при возникновении определенных событий журнала. По умолчанию - &lt;code&gt;false&lt;/code&gt; . При возникновении события владельцам отправляется одно из следующих сообщений:</target>
        </trans-unit>
        <trans-unit id="dac3885367e9c29a28f95ee9e91f474fd1b0d8a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; replace any program forms that could not be parsed with nodes of type &lt;code&gt;text&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt;), representing the raw token sequence of the form, instead of reporting a parse error. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , это заставляет &lt;code&gt;epp_dodger&lt;/code&gt; заменять любые формы программы, которые не могут быть проанализированы, узлами типа &lt;code&gt;text&lt;/code&gt; (см. &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt; ), представляющими необработанную последовательность токенов формы, вместо сообщения об ошибке синтаксического анализа. Значение по умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05b7850adc53f90dafb4ed1b3efc538359d746ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true|once|N&lt;/code&gt; (active modes) received data or events are sent to the owning process. See &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0..2&lt;/a&gt;&lt;/code&gt; for the message format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40234d0ab231968f3d6203cda0f55c4df8e790c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d87db40121a7b6b4e4f2f28996811db47d8d7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, or &lt;code&gt;T&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">Если &lt;code&gt;u&lt;/code&gt; используется как идентификатор подсистемы (то есть &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; ), &lt;code&gt;alloc_util&lt;/code&gt; все распределители на основе alloc_util . Если &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; или &lt;code&gt;T&lt;/code&gt; используются в качестве идентификатора подсистемы, применяется только конкретный идентификатор распределителя.</target>
        </trans-unit>
        <trans-unit id="784b625fc8171fa4983940bde7848ec14a3e23bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;volatile&lt;/code&gt; is returned, the time offset cannot be finalized because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Если возвращается &lt;code&gt;volatile&lt;/code&gt; , временное смещение не может быть завершено, поскольку используется &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20c03db910bef2b3379b92930db1f3ebc527788d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only sent messages are logged.</source>
          <target state="translated">Если указана &lt;code&gt;write&lt;/code&gt; , в журнал записываются только отправленные сообщения.</target>
        </trans-unit>
        <trans-unit id="a95ad12798c19a97f99824236c8f188c8076b6b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only set requests are logged.</source>
          <target state="translated">Если указана &lt;code&gt;write&lt;/code&gt; , в журнал регистрируются только запросы набора.</target>
        </trans-unit>
        <trans-unit id="b0db310b8af51df282663eafc88eec4c7003919f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">Если &lt;code&gt;write_concurrency&lt;/code&gt; была включена для таблицы.</target>
        </trans-unit>
        <trans-unit id="d130e60ef67783037417bccce56bcf5768c8e099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; is returned, the emulator is restarted before the upgrade instructions are executed. This occurs if the emulator or any of the applications Kernel, STDLIB, or SASL are updated. The new emulator version and these core applications execute after the restart. For all other applications the old versions are started and the upgrade is performed as normal by executing the upgrade instructions.</source>
          <target state="translated">Если &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; , эмулятор перезапускается перед выполнением инструкций по обновлению. Это происходит при обновлении эмулятора или любого из приложений Kernel, STDLIB или SASL. Новая версия эмулятора и эти основные приложения запускаются после перезапуска. Для всех других приложений запускаются старые версии, и обновление выполняется в обычном режиме путем выполнения инструкций по обновлению.</target>
        </trans-unit>
        <trans-unit id="320cf62f527c030692a3479a90eabc62ad79a175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned immediately, the call to &lt;code&gt;parse_and_scan/1&lt;/code&gt; returns &lt;code&gt;{ok, eof}&lt;/code&gt;. If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned before the parser expects end of input, &lt;code&gt;parse_and_scan/1&lt;/code&gt; will, of course, return an error message (see above). Otherwise &lt;code&gt;{ok, Result}&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;{eof, Endline}&lt;/code&gt; возвращается немедленно, вызов &lt;code&gt;parse_and_scan/1&lt;/code&gt; возвращает &lt;code&gt;{ok, eof}&lt;/code&gt; . Если &lt;code&gt;{eof, Endline}&lt;/code&gt; возвращается до того, как синтаксический анализатор ожидает окончания ввода, &lt;code&gt;parse_and_scan/1&lt;/code&gt; , конечно, вернет сообщение об ошибке (см. Выше). В противном случае возвращается &lt;code&gt;{ok, Result}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedb9788552103a1f455c74f781f00865ba7c935" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{merge_tests,true}&lt;/code&gt; is set in the source specification (which is the default setting), terms in joined specifications are merged with terms in the source specification (according to the description of &lt;code&gt;merge_tests&lt;/code&gt; earlier).</source>
          <target state="translated">Если &lt;code&gt;{merge_tests,true}&lt;/code&gt; установлен в исходной спецификации (что является настройкой по умолчанию), термины в объединенных спецификациях объединяются с терминами в исходной спецификации (согласно описанию &lt;code&gt;merge_tests&lt;/code&gt; ранее).</target>
        </trans-unit>
        <trans-unit id="e19028ea4203966a6e00632a19c4871950b28ef8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{noreply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt;, or &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process continues executing with &lt;code&gt;NewState&lt;/code&gt;. Any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;{noreply,NewState}&lt;/code&gt; возвращается, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt; или &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt; , то &lt;code&gt;gen_server&lt;/code&gt; процесс продолжает выполняться с &lt;code&gt;NewState&lt;/code&gt; . Любой ответ на &lt;code&gt;From&lt;/code&gt; должен быть явно указан с помощью &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e61ed5c3d675fd060bf7a5ba0b7669c540660308" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1637361f321011df9f0024cdad416df7e559bbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">Если &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; , диспетчер событий также переходит в режим гибернации (путем вызова &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), ожидая, пока произойдет следующее событие. Достаточно, чтобы один из обработчиков событий возвратил &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; , чтобы весь процесс менеджера событий перешел в спящий режим.</target>
        </trans-unit>
        <trans-unit id="7bf6373c4c4feb0b7b12ba83feca28174cdeeb31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState}&lt;/code&gt; or &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event handler remains in the event manager with the possible updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;{ok,NewState}&lt;/code&gt; или &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; , обработчик событий остается в диспетчере событий с возможным обновленным внутренним состоянием &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="622b2b9487b410e4b5c3a44646686c10053b1e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; is returned, the event manager goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur.</source>
          <target state="translated">Если возвращается &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; , диспетчер событий переходит в режим гибернации (путем вызова &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), ожидая, пока произойдет следующее событие.</target>
        </trans-unit>
        <trans-unit id="4733cd19b2819c31e3b9d228b0a9153e3ac1bda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; or &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt;, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt; as the return value of &lt;code&gt;call/2,3&lt;/code&gt; or included in the return value of &lt;code&gt;multi_call/2,3,4&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then continues executing with the possibly updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">Если возвращается &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; , &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; или &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt; , &lt;code&gt;Reply&lt;/code&gt; возвращается &lt;code&gt;From&lt;/code&gt; в качестве возвращаемого значения &lt;code&gt;call/2,3&lt;/code&gt; или включается в возвращаемое значение &lt;code&gt;multi_call/2,3,4&lt;/code&gt; . Затем процесс &lt;code&gt;gen_server&lt;/code&gt; продолжает выполнение с возможно обновленным внутренним состоянием &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d1c1849381a9a2934c0c67001278a230ee2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{save_calls,N}&lt;/code&gt; has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</source>
          <target state="translated">Если для процесса было установлено &lt;code&gt;{save_calls,N}&lt;/code&gt; , вызовы функций не сохраняются в списке сохранения вызовов. (Список сохраненных вызовов не очищается. Кроме того, в список по-прежнему добавляются события отправки, получения и тайм-аута.)</target>
        </trans-unit>
        <trans-unit id="bfb24986f0a70731e0b63f3291fa396e2f3c519f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start + Length&lt;/code&gt; is &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если в параметрах указано &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; например &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt;0 или &lt;code&gt;Start + Length&lt;/code&gt; is&amp;gt; size of &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="de6994202966362118bb8cacc9efab5d034d0b7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; указано в таких параметрах, как &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt;0 или &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;badarg&lt;/code&gt; исключение badarg .</target>
        </trans-unit>
        <trans-unit id="22f0dd2e07f51ba0bec6f71cc1bb3b006093d94a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9167afbdea5d3a67e5f541cf0e5e6e2773017130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e478cc8acb7bdb77b1dae6158305c98359cc9ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e08b34f61f1a4d3777b205be5de380bc841d230" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb02f05292552a7ce9695f8e039ca2486be0efc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">Если возвращается &lt;code&gt;{skip,Reason}&lt;/code&gt; , все тестовые случаи в группе пропускаются, и &lt;code&gt;Reason&lt;/code&gt; печатается в обзорном журнале для группы.</target>
        </trans-unit>
        <trans-unit id="07c6e6c33ab904cab102b2ef7313020f30f3b33b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">Если возвращается &lt;code&gt;{skip,Reason}&lt;/code&gt; , все тестовые примеры в модуле пропускаются, а &lt;code&gt;Reason&lt;/code&gt; печатается на странице результатов HTML.</target>
        </trans-unit>
        <trans-unit id="7176131e2ab61dc6ca1a310323b87e804a6b01fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">Если возвращается &lt;code&gt;{skip,Reason}&lt;/code&gt; , все тестовые примеры в наборе пропускаются, и &lt;code&gt;Reason&lt;/code&gt; печатается в обзорном журнале для набора.</target>
        </trans-unit>
        <trans-unit id="1d2a5b747d22c7eede603eddd2e58170ad2ad7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">Если возвращается &lt;code&gt;{skip,Reason}&lt;/code&gt; , тестовый пример пропускается, и &lt;code&gt;Reason&lt;/code&gt; печатается в обзорном журнале для набора.</target>
        </trans-unit>
        <trans-unit id="43c5190e594ca77d2bcd9761108619b8160ca730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; is returned, any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then calls &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; and terminates.</source>
          <target state="translated">Если возвращается &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; , любой ответ на &lt;code&gt;From&lt;/code&gt; должен быть явно указан с помощью &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;gen_server&lt;/code&gt; процесс затем вызывает &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; и заканчивается.</target>
        </trans-unit>
        <trans-unit id="555db6a996a08647cb4789219558187a695b3e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt;.</source>
          <target state="translated">Если возвращается &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; , &lt;code&gt;Reply&lt;/code&gt; возвращается &lt;code&gt;From&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f07068ef6474408f3b2f01c567a6aa9dc31fae9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; is returned, the event handler is replaced by &lt;code&gt;Handler2&lt;/code&gt; by first calling &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; and then &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; , обработчик события заменяется &lt;code&gt;Handler2&lt;/code&gt; , сначала вызывая &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; а затем &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; , где &lt;code&gt;Term&lt;/code&gt; - это возвращаемое значение &lt;code&gt;Module:terminate/2&lt;/code&gt; . Для получения дополнительной информации см. &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54e845975dbb16c88ec10ada23488e780175ae56" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;any&lt;/strong&gt; of the &lt;strong&gt;other&lt;/strong&gt; callback functions crashes (exit, throw or a plain crash) or return an invalid result (if a valid return has been specified), this function is called. The purpose is to allow the user handle this error (for instance to issue an error report).</source>
          <target state="translated">Эта функция вызывается, если &lt;strong&gt;какая-либо&lt;/strong&gt; из &lt;strong&gt;других&lt;/strong&gt; функций обратного вызова дает сбой (выход, выброс или простой сбой) или возвращает недопустимый результат (если был указан допустимый результат). Цель состоит в том, чтобы позволить пользователю обработать эту ошибку (например, выдать отчет об ошибке).</target>
        </trans-unit>
        <trans-unit id="937ff2e79e3364cc35a718607a325fdce946f46d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Если &lt;strong&gt;false&lt;/strong&gt; , сообщения мегако отправляются с помощью функции &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a26b3170e7ada86a34e6bf52ec13abf6a58d809" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Если &lt;strong&gt;false&lt;/strong&gt; , сообщения мегако отправляются с &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; функции send_message .</target>
        </trans-unit>
        <trans-unit id="d618248269dc3ffbf51a67242f81007c8e747d1d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;true&lt;/strong&gt;, megaco message &lt;strong&gt;re-sends&lt;/strong&gt; are made using the &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; function. The initial message send is still done using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Если &lt;strong&gt;true&lt;/strong&gt; , &lt;strong&gt;повторная отправка &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; выполняется с помощью функции Resend_message . Первоначальная отправка сообщения по-прежнему выполняется с &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; функции send_message .</target>
        </trans-unit>
        <trans-unit id="6705ceafbe769b2ce43385b2299973a524847817" translate="yes" xml:space="preserve">
          <source>If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:</source>
          <target state="translated">Если A и B совпадают,но есть сбой в C,то совпадение не отступает в A,а переходит к следующей альтернативе,т.е.D.Однако,если подмасказке,содержащей (*THEN),дана альтернатива,то она ведет себя по-другому:</target>
        </trans-unit>
        <trans-unit id="c0f5376ef787219224d7bfc3d76505fad1f25c03" translate="yes" xml:space="preserve">
          <source>If A is a subset of X, the &lt;strong id=&quot;image&quot;&gt;image&lt;/strong&gt; of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the &lt;strong id=&quot;inverse_image&quot;&gt;inverse image&lt;/strong&gt; of B is the set {x : x R y for some y in B}.</source>
          <target state="translated">Если A - подмножество X, &lt;strong id=&quot;image&quot;&gt;образ&lt;/strong&gt; A под R - это множество {y: x R y для некоторого x в A}. Если B является подмножеством Y, &lt;strong id=&quot;inverse_image&quot;&gt;прообразом&lt;/strong&gt; B является набор {x: x R y для некоторого y в B}.</target>
        </trans-unit>
        <trans-unit id="f6a630d6f8d7caebea5102271394fdcd67b18c9d" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b4fe5ddbf9a00d696a1d76a1917c8c5d2aeb3e" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">Если A является ассоциацией &lt;code&gt;K := V&lt;/code&gt; , то Rep (A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75688e538d64827729b81c8f7409b54e266cd7bd" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930fd81e91ccd105d16e4034de1e01640fca7bc6" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">Если A является ассоциацией &lt;code&gt;K =&amp;gt; V&lt;/code&gt; , то Rep (A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25f2fa0920ecae328194e2e5f0d6947b2fdf2b8f" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e632ebc019048443e5c38c3f2b726fe623c1461" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">Если A - тип ассоциации &lt;code&gt;K := V&lt;/code&gt; , где &lt;code&gt;K&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; - типы, тогда Rep (A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7d66e8b109f42cf2b8b90dae2cc67fe469adfa" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe916dba3dfcc9f9ef483ef2b2560b99a4239b84" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">Если A - тип ассоциации &lt;code&gt;K =&amp;gt; V&lt;/code&gt; , где &lt;code&gt;K&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; - типы, тогда Rep (A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a746c5a2ff985d711d5a7f13e4e14806e0e62f7d" translate="yes" xml:space="preserve">
          <source>If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:</source>
          <target state="translated">Если A совпадает,но B не удается,то обратная ссылка на (*COMMIT)приводит к тому,что полное совпадение не удается.Однако,если A и B совпадают,но C терпят неудачу,обратная дорога к (*THEN)приводит к попытке следующей альтернативы (ABD).Такое поведение является последовательным,но не всегда таким же,как в Perl.Это означает,что если два или более обратных глагола появляются подряд,то последний из них не имеет никакого эффекта.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="5ec09bef075c491da05310ae82ca09d506f563c0" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a144a893fd5d00844284a1c4ab07c469c50d04" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если C - это предложение case &lt;code&gt;P -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;P&lt;/code&gt; - шаблон, а &lt;code&gt;B&lt;/code&gt; - тело, тогда Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5aa4f9266e04e273102dd79f1886cfeae24057" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1982d0d507cac2d94792ff43eb098cbb5c7b07ff" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если C - это предложение &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;P&lt;/code&gt; - шаблон, &lt;code&gt;Gs&lt;/code&gt; - защитная последовательность, а &lt;code&gt;B&lt;/code&gt; - тело, то Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d659eda70c2e50509c30fcc418400a9aab3ac03" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5272c27438c02673801bf9383134101b74af201b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Если C - предложение catch &lt;code&gt;P -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;P&lt;/code&gt; - шаблон, а &lt;code&gt;B&lt;/code&gt; - тело, то Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; , то есть пункт улова с явным исключением класса &lt;code&gt;throw&lt;/code&gt; и с или без явной переменной StackTrace &lt;code&gt;_&lt;/code&gt; нельзя отличить от пункта улова без явного класса исключений и без явной переменной StackTrace.</target>
        </trans-unit>
        <trans-unit id="c311eaf58fab876bdc94780ac91685854b17771c" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66083733733867d178cfdf05fa2ebeeb26e587ba" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Если C является предложением &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; catch, когда Gs -&amp;gt; B , где &lt;code&gt;P&lt;/code&gt; - шаблон, &lt;code&gt;Gs&lt;/code&gt; - защитная последовательность, а &lt;code&gt;B&lt;/code&gt; - тело, тогда Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , то есть пункт улов с явным классом исключения &lt;code&gt;throw&lt;/code&gt; и с или без явной переменной StackTrace &lt;code&gt;_&lt;/code&gt; нельзя отличить от пункта улова без явного класса исключений и без явной переменной stacktrace.</target>
        </trans-unit>
        <trans-unit id="8afa8db8880cd11a80b4f7cecb8f0640f10dde11" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33763f19a17cfabb0fc3a9334e69f568d0598981" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Если C - предложение catch &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;X&lt;/code&gt; - атомарный литерал или шаблон переменной, &lt;code&gt;P&lt;/code&gt; - шаблон, а &lt;code&gt;B&lt;/code&gt; - тело, тогда Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; , то есть предложение catch с явным классом исключения и с явной переменной stacktrace &lt;code&gt;_&lt;/code&gt; нельзя отличить от предложения catch с явным классом исключения и без явная переменная трассировки стека.</target>
        </trans-unit>
        <trans-unit id="43cc8aa87c6f7cf6d65593b565e96a75d05633ea" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e98e1e13987f32a2240be5fce9eca6126a89ed" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если C - это предложение catch &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;X&lt;/code&gt; - атомарный литерал или шаблон переменной, &lt;code&gt;P&lt;/code&gt; - шаблон, &lt;code&gt;S&lt;/code&gt; - переменная, а &lt;code&gt;B&lt;/code&gt; - тело, то Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a262d7341faa65ccb5ac93e7079518e8857e84b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae0f4c55ba607c0c1ac95c07e874e6880664ec9" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если C - это предложение catch, &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;X&lt;/code&gt; - атомарный литерал или шаблон переменной, &lt;code&gt;P&lt;/code&gt; - шаблон, &lt;code&gt;Gs&lt;/code&gt; - защитная последовательность, &lt;code&gt;S&lt;/code&gt; - переменная, а &lt;code&gt;B&lt;/code&gt; - тело, тогда Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e601c916b6ea0d1855c5d5324b1a12d0303cb8" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd09edeb30671bd8912819376a2a0342249cf516" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Если C - это предложение catch &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;X&lt;/code&gt; - атомарный литерал или шаблон переменной, &lt;code&gt;P&lt;/code&gt; - шаблон, &lt;code&gt;Gs&lt;/code&gt; - защитная последовательность, а &lt;code&gt;B&lt;/code&gt; - тело, тогда Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , то есть предложение catch с явным классом исключения и с явной переменной трассировки стека &lt;code&gt;_&lt;/code&gt; нельзя отличить от предложение catch с явным классом исключения и без явной переменной stacktrace.</target>
        </trans-unit>
        <trans-unit id="4016717fdd4d5433989581c68c30070bb76884da" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,ANNO,constraint,[{atom,ANNO,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5fe92f62215d00d030e5a7bada64a7329d2d85" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">Если C - ограничение &lt;code&gt;V :: T&lt;/code&gt; , где &lt;code&gt;V&lt;/code&gt; - переменная типа, а &lt;code&gt;T&lt;/code&gt; - тип, то Rep (C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d2da59f190a64375cc2ab954899e9cace4a77f" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17326d4fa4e4dd923f6996f5fc5f5d27a9e90bfb" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если C - предложение функции &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;Ps&lt;/code&gt; - последовательность шаблонов, а &lt;code&gt;B&lt;/code&gt; - тело, то Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbc0eacd6cf64ab7e1b6a5aa346f15af4ee37ac3" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58b02b2d6778f5c78bfa5c91aec26b39e9b26e2" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если C - это функциональное предложение &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;Ps&lt;/code&gt; - последовательность шаблона, &lt;code&gt;Gs&lt;/code&gt; - защитная последовательность, а &lt;code&gt;B&lt;/code&gt; - тело, то Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b2834d93e535442b365d66608e72b7dd5d9a7b0" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac3b590133c72b3e697e259f15ddfcb5136d5c1" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если C - это условие if &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; , где &lt;code&gt;Gs&lt;/code&gt; - защитная последовательность, а &lt;code&gt;B&lt;/code&gt; - тело, то Rep (C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cbfab94d790c9f8ddb1d5350bddeee9c6d6348c" translate="yes" xml:space="preserve">
          <source>If CPU topology information is unavailable.</source>
          <target state="translated">Если информация о топологии процессора недоступна.</target>
        </trans-unit>
        <trans-unit id="a5c3ae58fb5f8a860fea2ef9b561020e0407c0fd" translate="yes" xml:space="preserve">
          <source>If D is a module declaration consisting of the forms &lt;code&gt;F_1&lt;/code&gt;, ..., &lt;code&gt;F_k&lt;/code&gt;, then Rep(D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt;.</source>
          <target state="translated">Если D - объявление модуля, состоящее из форм &lt;code&gt;F_1&lt;/code&gt; , ..., &lt;code&gt;F_k&lt;/code&gt; , то Rep (D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a30963b62350996a8d59e8d3d4f4343c158ae7a4" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385f7db6a01f80887d7150e7f3e7bdd257de0fb5" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">Если E - понимание битовой строки &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; , где каждый &lt;code&gt;Q_i&lt;/code&gt; является квалификатором, тогда Rep (E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; . Относительно Rep (Q) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="a215b35bfabec03f705356b11df781d76fe9bda6" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58b032de54c4d5d1f61a79ea10904e5176012ef" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Если E - конструктор битовой строки &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , где каждый &lt;code&gt;Size_i&lt;/code&gt; является выражением, а каждый &lt;code&gt;TSL_i&lt;/code&gt; является списком специфичных типов, тогда Rep (E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; , Относительно Rep (TSL) см. Ниже. Опущено &lt;code&gt;Size_i&lt;/code&gt; представлена по &lt;code&gt;default&lt;/code&gt; . Опущено &lt;code&gt;TSL_i&lt;/code&gt; представлена по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def0fd07bd4ff6d50e1223eca9053d3fa095d182" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,ANNO,Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0400ff578820209af4c6bca75270b191887cfe" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Если E - это выражение блока &lt;code&gt;begin B end&lt;/code&gt; , где &lt;code&gt;B&lt;/code&gt; - тело, тогда Rep (E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d8af3f74254d265168f6c22c16d0838a1ea340" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',ANNO,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61d85721a2f8e94ee818ecc0cbe514b22d9b6e5" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если E - это case-выражение &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; , где &lt;code&gt;E_0&lt;/code&gt; - выражение, а каждый &lt;code&gt;Cc_i&lt;/code&gt; - предложение case, тогда Rep (E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="096069597c0301e2331f3c9eeb4ba8c6fe89359b" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',ANNO,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20926c71a541ebeeb5a5ce9236741b97b74ee9ee" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Если E - это выражение &lt;code&gt;catch E_0&lt;/code&gt; , тогда Rep (E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b58d732e6eb44c8650ef6ea1ab56a5738fed639" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,ANNO,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d685232ba5f2805f2661aa4dca2a66de454be03" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">Если E - скелет cons &lt;code&gt;[E_h | E_t]&lt;/code&gt; , тогда Rep (E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd154a4579d9aa67e94aa4c762704930a595e132" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',ANNO,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00326b0fd36dc640e6ce203654ecdb5f5319afc6" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Если E - забавное выражение &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; , где каждый &lt;code&gt;Fc_i&lt;/code&gt; является предложением функции, тогда Rep (E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b930f9fc614875b26b77fcef08cb18fabcffa755" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e7ad524342503c66fff38de3f9fd9620fdced2" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">Если E - забавное выражение &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; , тогда Rep (E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; . (До Erlang / OTP R15: Rep (E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="21dea75946b388b1e954dab71b395d65115fda11" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,ANNO,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508f3673ffdf47d28232744927849cd0723a0e7f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если E - забавное выражение &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; , где &lt;code&gt;Name&lt;/code&gt; - это переменная, а каждый &lt;code&gt;Fc_i&lt;/code&gt; - это функциональное предложение, тогда Rep (E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c48f719d2f5c29bf4ca1a282cd70942bcc783e8f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c55128cd4494aabe3305a25ed372470c6cb1e94" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">Если E - забавное выражение &lt;code&gt;fun Name/Arity&lt;/code&gt; , тогда Rep (E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a222846ccb959514cd088c00700755704ce4b70c" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae431171a9a508e70cab829bfde9130d74f3b08a" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если E - это вызов функции &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; , то Rep (E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b051c7315ab5f877f6f8d1a3fcb5d7352c32d165" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a930c4f44f20684a46e411dc14a24535a2814f3b" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если E - это вызов функции &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; , то Rep (E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad4dbd16a1df7767e8ca6eb37d1f31ac1e007d69" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9ba22f768bf25ed619e9861b8a15d7cd9192c" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">Если E - понимание списка &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; , где каждый &lt;code&gt;Q_i&lt;/code&gt; является квалификатором, тогда Rep (E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; . Относительно Rep (Q) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="e8512e6de961ae7de3dc6cd02be5dfd7477d76f7" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c06772c585b4d5e9af41e11c7fa823e87a3781" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Если E - создание карты &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , где каждый &lt;code&gt;A_i&lt;/code&gt; является ассоциацией &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; , то Rep (E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Относительно Rep (A) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="237f2587bea6e744a08e9b787c8ee8a08e4fc754" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800dae600f3ee86ffec1de1f210ed80d17fd2b9b" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Если E - это обновление карты &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; , где каждый &lt;code&gt;A_i&lt;/code&gt; является ассоциацией &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; или &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; , тогда Rep (E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Относительно Rep (A) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="4f62176ee9725e6dd7a1d357a9791afa6d505171" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,ANNO,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ecb06f9387738ad9c4608934528d6d6501def9" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Если E - выражение оператора сопоставления &lt;code&gt;P = E_0&lt;/code&gt; , где &lt;code&gt;P&lt;/code&gt; - шаблон, тогда Rep (E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="690ad831c8e62316c71be505eb989a5f5da834db" translate="yes" xml:space="preserve">
          <source>If E is a parenthesized expression &lt;code&gt;( E_0 )&lt;/code&gt;, then Rep(E) = &lt;code&gt;Rep(E_0)&lt;/code&gt;, that is, parenthesized expressions cannot be distinguished from their bodies.</source>
          <target state="translated">Если E - это выражение в скобках &lt;code&gt;( E_0 )&lt;/code&gt; , тогда Rep (E) = &lt;code&gt;Rep(E_0)&lt;/code&gt; , то есть выражения в скобках нельзя отличить от их тела.</target>
        </trans-unit>
        <trans-unit id="eb97a9c72be1a3ec039d3b19e59af460c1f9597f" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e50f32be6fa18564dc0f97ac6d17895199c4c5" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">Если E является выражением &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; , где каждый &lt;code&gt;Cc_i&lt;/code&gt; - предложение case, &lt;code&gt;E_0&lt;/code&gt; - выражение, а &lt;code&gt;B_t&lt;/code&gt; - тело, тогда Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62607bd086692a7a4e73a9a4340bedc98933a8ce" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d96409c6d75213915ef6028c674bf71b947761" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если E является выражением &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; , где каждый &lt;code&gt;Cc_i&lt;/code&gt; является предложением case, тогда Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db402d6b9bfaaf27c4221b6ecb8f7a3438ef10d" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769c6455ce5fde46b459e44a8ec3bffa7196d158" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Если E - создание записи &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; , где каждое &lt;code&gt;Field_i&lt;/code&gt; является атомом или &lt;code&gt;_&lt;/code&gt; , тогда Rep (E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b95681bf643b3e4b28c35faa965a19ee4fda5ac" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,ANNO,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571a72b7ca82dcb7bd3dbc0550c43c731464ee91" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Если E - доступ к полю записи &lt;code&gt;E_0#Name.Field&lt;/code&gt; , где &lt;code&gt;Field&lt;/code&gt; - атом, тогда Rep (E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd0016f76592cf4abfa2e2b7e0edf19c3c161d6e" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41585c3fb51f7eca9a3e6945efca3d137bddef8d" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Если E - это индекс поля записи &lt;code&gt;#Name.Field&lt;/code&gt; , где &lt;code&gt;Field&lt;/code&gt; - атом, то Rep (E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0e1680739b87d61cf8de240ccb43c2b9ea6736a" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,ANNO,Rep(E_0),Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c141b24fbc5240a27271026022f8b84cc1c46ec" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Если E - это обновление записи &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; , где каждое &lt;code&gt;Field_i&lt;/code&gt; является атомом, тогда Rep (E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1790d1e53e6feb25e42b2594447e491760461bcd" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5433ba0e7386d18ba29df013a33a3bd71eec1de4" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Если E - это выражение &lt;code&gt;try B after A end&lt;/code&gt; , где &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; - тела, тогда Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66db70f66ec2e1c9cfff251e52d9d4fb44005444" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0c9fd33084b3aa2b6298f495d8933521120111" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Если E - выражение &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; , где &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; - тела, а каждый &lt;code&gt;Tc_i&lt;/code&gt; - предложение catch, тогда Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="527f66fe559f2313ab4c9f07440149b4724a0e36" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0174ae0ac371a20fa8346b5c98865a86bb0973f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">Если E - выражение &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; , где &lt;code&gt;B&lt;/code&gt; - тело, а каждый &lt;code&gt;Tc_i&lt;/code&gt; - предложение catch, тогда Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c97756483607f476bd044cc105daba38c615ff16" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17896fd4f3f657c1acca030c3b7c2477fd7ea070" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Если E - выражение &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; , где &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; - тела, и каждый &lt;code&gt;Cc_i&lt;/code&gt; - предложение case, тогда Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9f5ca2ce8dc840d927013fd593a6e43685c6fc" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8fa527e6b0ee33c16b21df17493bd713be90d3" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Если E - выражение &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; , где &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; - тела, каждый &lt;code&gt;Cc_i&lt;/code&gt; - предложение case, а каждый &lt;code&gt;Tc_j&lt;/code&gt; - предложение catch, тогда Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87716dd0d35ab489a52485d5fff86ee7a86034f5" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32741bd8aaa39a55dc66b9c017671086d64dc49f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">Если E - выражение &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; , где &lt;code&gt;B&lt;/code&gt; - тело, каждый &lt;code&gt;Cc_i&lt;/code&gt; - предложение case, а каждый &lt;code&gt;Tc_j&lt;/code&gt; - предложение catch, тогда Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a7a0dff10ecd15daa7bf8f1e4f2c478633f53be" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,ANNO,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff91a87e5952e2ad6d9b444216166d09d3ca77eb" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если E является каркасом кортежа &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; , то Rep (E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d73c4b24d215a5b14fa705cf6b8fc7f04eaa159" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cebb18271309572b378e6bac693d831da6a5de6" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Если Е является переменной &lt;code&gt;V&lt;/code&gt; , то Группа (Е) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , где представляет собой атом с printname , состоящей из одних и тех же символов , как &lt;code&gt;V&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5399bc470d1e24b61c04135abc6ec1c48ce12a53" translate="yes" xml:space="preserve">
          <source>If E is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(E) = Rep(L).</source>
          <target state="translated">Если E - атомарный литерал &lt;code&gt;L&lt;/code&gt; , то Rep (E) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="704415f6ec0f5288d1cf6770b2ca8548cffab4c3" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',ANNO,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591459a3195bdb1721ecc29118a41cd9ecf5ad76" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если E - это выражение &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; , где каждый &lt;code&gt;Ic_i&lt;/code&gt; является условием if, тогда Rep (E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a540b17ecf127991c06127bf562cd9b622f73fd8" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74042cb0d91ea528b8846bce8407c4c94e7828f3" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">Если E - операторное выражение &lt;code&gt;E_1 Op E_2&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; - бинарный оператор, отличный от оператора сопоставления &lt;code&gt;=&lt;/code&gt; , то Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ae3a7a50482463c878cd3a4535e569c8a10c045" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22209cbc466369d61322ba8f94065874c289f3f5" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Если E - операторное выражение &lt;code&gt;Op E_0&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; - унарный оператор, то Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dd90da6de4013d8fcdf427618cebc1de03b8894" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecc39e30213c6bf99c4212c4aeafe719ce7ed08" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Если E равно нулю, &lt;code&gt;[]&lt;/code&gt; , то Rep (E) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80045470a896b7cf38c6a0866ea3eab2424863f" translate="yes" xml:space="preserve">
          <source>If Erlang is started in long name distributed mode, it needs to get the domain name from somewhere and reads system &lt;code&gt;inet&lt;/code&gt; configuration files for this information. Any hosts and resolver information found is also recorded, but not used as long as Erlang is configured for native lookups. The information becomes useful if the lookup method is changed to &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt;, see below.</source>
          <target state="translated">Если Erlang запущен в распределенном режиме с длинными именами, ему нужно откуда-то получить доменное имя и прочитать системные файлы конфигурации &lt;code&gt;inet&lt;/code&gt; для получения этой информации. Любая найденная информация о хостах и ​​преобразователе также записывается, но не используется, пока Erlang настроен для собственного поиска. Информация становится полезной, если метод поиска изменен на &lt;code&gt;'file'&lt;/code&gt; или &lt;code&gt;'dns'&lt;/code&gt; , см. Ниже.</target>
        </trans-unit>
        <trans-unit id="8ba99b579cb5dc5d83148e021817ebf4a31439e9" translate="yes" xml:space="preserve">
          <source>If Erlang sends, for example, the list &lt;code&gt;[$a,$b,$c]&lt;/code&gt; to the port, the &lt;code&gt;bufflen&lt;/code&gt; variable is &lt;code&gt;3&lt;/code&gt; and the &lt;code&gt;buff&lt;/code&gt; variable contains &lt;code&gt;{'a','b','c'}&lt;/code&gt; (no &lt;code&gt;NULL&lt;/code&gt; termination). Usually the first byte is used as an opcode, which is the case in this driver too (at least when the port is in &lt;code&gt;command&lt;/code&gt; mode). The opcodes are defined as follows:</source>
          <target state="translated">Если Erlang отправляет, например, список &lt;code&gt;[$a,$b,$c]&lt;/code&gt; в порт, переменная &lt;code&gt;bufflen&lt;/code&gt; равна &lt;code&gt;3&lt;/code&gt; , а переменная &lt;code&gt;buff&lt;/code&gt; содержит &lt;code&gt;{'a','b','c'}&lt;/code&gt; (без завершения &lt;code&gt;NULL&lt;/code&gt; ). Обычно первый байт используется в качестве кода операции, что имеет место и в этом драйвере (по крайней мере, когда порт находится в &lt;code&gt;command&lt;/code&gt; режиме). Коды операций определены следующим образом:</target>
        </trans-unit>
        <trans-unit id="d4fecac2cf10df2e039ce3e4f4d5fa9aa6b7bf2b" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,ANNO,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914c013be868be9b46633a3fae8ef36377ee34a1" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если F - объявление функции &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; , где каждый &lt;code&gt;Fc_i&lt;/code&gt; - это предложение функции с последовательностью шаблонов такой же длины &lt;code&gt;Arity&lt;/code&gt; , тогда Rep (F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92b2fdf009166615e68068377c093d1265169847" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839e0427c2712f13a30277505b79b3f3678e27bc" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Если F является спецификацией функции &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; , где &lt;code&gt;Spec&lt;/code&gt; - это либо &lt;code&gt;spec&lt;/code&gt; атома, либо &lt;code&gt;callback&lt;/code&gt; атома , и каждый &lt;code&gt;Ft_i&lt;/code&gt; - это возможно ограниченный тип функции с последовательностью аргументов той же длины &lt;code&gt;Arity&lt;/code&gt; , тогда Rep (F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b133a685e1078d511adc4d4a4c0155cfdea6af" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17271a999b9344b2a590ac6ed7fcd19ea7837c3a" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Если F - спецификация функции &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; , где каждый &lt;code&gt;Ft_i&lt;/code&gt; - это возможно ограниченный тип функции с последовательностью аргументов той же длины &lt;code&gt;Arity&lt;/code&gt; , тогда Rep (F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa68f807198b22105fc44214b7d3c63162ade67" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,ANNO,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd91f9ee512189a9782c72f858106c81c42eb39a" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">Если F является объявлением записи &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; , где каждый &lt;code&gt;V_i&lt;/code&gt; является полем записи, тогда Rep (F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; . Относительно Rep (V) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="25adb05f207dd769bbafb0f578b65f641a0a7794" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,ANNO,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab32c665244fb293fe17fe26c52469e41031dd4" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">Если F - это тип поля записи &lt;code&gt;Name :: Type&lt;/code&gt; , где &lt;code&gt;Type&lt;/code&gt; - это тип, тогда Rep (F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6239a9176ea881407034a190550ff59286863ce7" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a type variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,ANNO,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cc499e6743611a48be1c32ba0e0814b6fa811f" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Если F - это объявление типа &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; , где &lt;code&gt;Type&lt;/code&gt; - это либо &lt;code&gt;type&lt;/code&gt; атома, либо &lt;code&gt;opaque&lt;/code&gt; атом , каждый &lt;code&gt;V_i&lt;/code&gt; - это переменная, а &lt;code&gt;T&lt;/code&gt; - тип, тогда Rep (F ) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b64b9b51dd41ff649ef5c26db0f7f069a7d35d" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,A,T}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81677bfb1fe791cbe449f2226181f612e7d5741" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt;.</source>
          <target state="translated">Если F является диким атрибутом &lt;code&gt;-A(T)&lt;/code&gt; , тогда Rep (F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d2d6dc97c9b7259053b20eb74732ea1141eebd" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c092236a8dd4b964a8de640c01239a90a1e7a1ac" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">Если F является атрибутом &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; , то Rep (F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c034270eafab2ed7bcecacf02af15e5097193b1d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3859e84d13f06a07d526a9d0610934ed80fd58d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">Если F - атрибут &lt;code&gt;-file(File,Line)&lt;/code&gt; , тогда Rep (F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2d15becf26ad2d7caf42380a72b2c27da43c41" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb3ff8ec37dad7da6fb624ff1aa1f2defef3f1c" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">Если F является атрибутом &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; , то Rep (F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3ea6219e1cb69bee47ba7d3c0d07637a4dae6e" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,module,Mod}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740887309045a225d9cb600109651a0966db65e3" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">Если F является атрибутом &lt;code&gt;-module(Mod)&lt;/code&gt; , тогда Rep (F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8b8c5e56eae2112a18d51dd6a9fcb8af749ac2" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,ANNO,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0d9740980dc9bb7d3b497c88ac52e3e4ae32a4" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">Если Ft - это тип функции с ограничениями &lt;code&gt;Ft_1 when Fc&lt;/code&gt; , где &lt;code&gt;Ft_1&lt;/code&gt; - тип функции, а &lt;code&gt;Fc&lt;/code&gt; - ограничение функции, тогда Rep (T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; . Относительно Rep (Fc) см. Ниже.</target>
        </trans-unit>
        <trans-unit id="addf4ad1342821174bcf34191602826b5ec30735" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad272ac4cee50fc07993902e12ff74bb1a162f57" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Если Ft является типом функции &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; , где каждый &lt;code&gt;T_i&lt;/code&gt; является типом, тогда Rep (Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956fa8f47f1bcedade9724b256d1fe2c59b770a8" translate="yes" xml:space="preserve">
          <source>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt;.</source>
          <target state="translated">Если G - ориентированный граф, то вершины и ребра графа G такие же, как вершины и ребра &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02f41904356cb27048a5f981f0ab30233861e22f" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c4c1f8a634a58d8cf6efc770bf44b8e01c62ed" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Если Gt является конструктором битовой строки &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , где каждый &lt;code&gt;Size_i&lt;/code&gt; является защитным тестом, а каждый &lt;code&gt;TSL_i&lt;/code&gt; является списком специфических типов, тогда Rep (Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Относительно Rep (TSL) см. Выше. Опущено &lt;code&gt;Size_i&lt;/code&gt; представлена по &lt;code&gt;default&lt;/code&gt; . Опущено &lt;code&gt;TSL_i&lt;/code&gt; представлена по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd4e2d2654420d08ff75e569801e0f82ea1d8e67" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,ANNO,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84104d736902648592238a7aed481c0fca8a1b02" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">Если Gt является скелетом cons &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; , тогда Rep (Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67aa27e3b255c0b23af7ede9fa213ab9884fe39f" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,ANNO,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c34327c1aac1242765939018d40572e3ece41" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если Gt - это вызов функции &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; , где &lt;code&gt;A&lt;/code&gt; - атом, то Rep (Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b6a664574ec6785fbcee63137675fde7e8ef5d" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe106be5e00c62f004b81ec1a1e00fa0b616f14" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если Gt - это вызов функции &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; , где &lt;code&gt;A_m&lt;/code&gt; - это атом &lt;code&gt;erlang&lt;/code&gt; а &lt;code&gt;A&lt;/code&gt; - атом или оператор, то Rep (Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aef2cea48fdeba80e26c88e7eef4d4b0dc0be26" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3cc863263c90fe7c570740ba4eda5e38a4f773" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Если Gt является созданием карты &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , где каждый &lt;code&gt;A_i&lt;/code&gt; является ассоциацией &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; , тогда Rep (Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Относительно Rep (A) см. Выше.</target>
        </trans-unit>
        <trans-unit id="9d73cdb5044edf8f644c77dc585bc5cd5213ffd6" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b68b45a396309326113e63efb931d56c934f4e8" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Если Gt является обновлением карты &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; , где каждый &lt;code&gt;A_i&lt;/code&gt; является ассоциацией &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; или &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; , тогда Rep (Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Относительно Rep (A) см. Выше.</target>
        </trans-unit>
        <trans-unit id="c71638db3891d8e47094eaea5193942aba235460" translate="yes" xml:space="preserve">
          <source>If Gt is a parenthesized guard test &lt;code&gt;( Gt_0 )&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt;, that is, parenthesized guard tests cannot be distinguished from their bodies.</source>
          <target state="translated">Если Gt заключенный в скобки сторожевой тест &lt;code&gt;( Gt_0 )&lt;/code&gt; , то Rep (Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt; , то есть заключенные в скобки сторожевые тесты нельзя отличить от их тела.</target>
        </trans-unit>
        <trans-unit id="5515e293f7cbca6cd1b4d86301ecc8fcc5ad59f4" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95bc9c3e2bbe4154125f8e83e7d1dec9ccf69c3a" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Если Gt - создание записи &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; , где каждое &lt;code&gt;Field_i&lt;/code&gt; является атомом или &lt;code&gt;_&lt;/code&gt; , тогда Rep (Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d8c3bdf875936951f6be38abd9a234defb4a787" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,ANNO,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5219d21b74d303638f0d998d1a523861cfd8ed" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Если Gt - это поле доступа к записи &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; , где &lt;code&gt;Field&lt;/code&gt; - это атом, то Rep (Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddc523ac11939b47b6ea5667d89b0cf0cbb87da" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a706262c44fbdd9118d527a47e94cc7e8f43cf92" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Если Gt - это индекс поля записи &lt;code&gt;#Name.Field&lt;/code&gt; , где &lt;code&gt;Field&lt;/code&gt; - атом, то Rep (Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91b1ff08bce1f7be5c86e93bf7b896dcee2bcdda" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,ANNO,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f481667ce91658bcad558a1af4b78b60f7692744" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Если Gt является каркасом кортежа &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; , то Rep (Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ba6ce0ad44989a3f9fca3540904be2d98eb9da" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06988b89d180cb11b8982908198902c04bcea42" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Если Гт является переменной модели &lt;code&gt;V&lt;/code&gt; , то Группа (Гт) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , где А представляет собой атом с printname , состоящей из одних и тех же символов , как &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b80b2b10f76759502fc592d77587e295e44b6d5" translate="yes" xml:space="preserve">
          <source>If Gt is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(Gt) = Rep(L).</source>
          <target state="translated">Если Gt - атомарный литерал &lt;code&gt;L&lt;/code&gt; , то Rep (Gt) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="30bbb65a3435cb7a0b644ba508d8ad7e2aebd344" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ecca50d53c2df91c648c581d109d377a56d333" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">Если Gt - это тест &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; оператора Gt_1 Op Gt_2 , где &lt;code&gt;Op&lt;/code&gt; - бинарный оператор, отличный от оператора сопоставления &lt;code&gt;=&lt;/code&gt; , то Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1590398d554a502b9031594d26d2e7f3c303dfca" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59964cf24a3c6e579aace4b47998306937171209" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">Если Gt - это тест защиты оператора &lt;code&gt;Op Gt_0&lt;/code&gt; , где &lt;code&gt;Op&lt;/code&gt; - унарный оператор, то Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bba2b902d7d011a3e4c35fe4e116ae49fd9a8a3" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498668c1ce816a52c1e11cee91561fc3f7281cec" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Если Gt равно нулю, &lt;code&gt;[]&lt;/code&gt; , то Rep (Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb631647ead2cb8b76c4ec1b07f1f0c70bf1b1d6" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d91f44fbe3739ece99b11544ff08c06f7058b62" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Если L - символьный литерал, то Rep (L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="893eb2ba60965c09a51b1e49cb8017e58a360073" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a70af53d75e256462e24f2a854c77741b9fe2a6" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Если L - литерал с плавающей запятой, то Rep (L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b31cf2c573d35c24a7c01f8fb6b6ee646806df21" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,ANNO,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4e7443f3bff9431f378dad125819933dd7b906" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">Если L - строковый литерал, состоящий из символов &lt;code&gt;C_1&lt;/code&gt; , ..., &lt;code&gt;C_k&lt;/code&gt; , то Rep (L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46dc6ddf19639701de194e194ca59776f621ce0b" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c151061397c80cc4494386daf911cd7cd3768421" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Если L - атомный литерал, то Rep (L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9daa1db636bdb57e06f2782f31b76d4535249681" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009d689b146fb6ed54f2471e1d09e781555b973a" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Если L - целочисленный литерал, то Rep (L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84cceee508e21c83ef5e5c68f567b7df3c0d24d4" translate="yes" xml:space="preserve">
          <source>If Mnesia is down on the local node, the function returns those other &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; that for the moment are operational.</source>
          <target state="translated">Если Mnesia не работает на локальном узле, функция возвращает те другие &lt;code&gt;db_nodes&lt;/code&gt; и &lt;code&gt;extra_db_nodes&lt;/code&gt; , которые в данный момент работают.</target>
        </trans-unit>
        <trans-unit id="d2c7cf7bb11840eda288723b23ff4cc867a91195" translate="yes" xml:space="preserve">
          <source>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as &lt;code&gt;running_db_nodes&lt;/code&gt;. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the &lt;code&gt;running_db_nodes&lt;/code&gt; list than all &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; together.</source>
          <target state="translated">Если Mnesia запущена, функция возвращает те узлы, к которым Mnesia на локальном узле полностью подключена. Только те узлы, с которыми Mnesia обменялась информацией о схеме, включены как &lt;code&gt;running_db_nodes&lt;/code&gt; . После объединения схем локальная система Mnesia полностью работоспособна, и приложения могут выполнять доступ к удаленным репликам. До объединения схем Mnesia работает только локально. Иногда в список &lt;code&gt;running_db_nodes&lt;/code&gt; включено больше узлов, чем всех &lt;code&gt;db_nodes&lt;/code&gt; и &lt;code&gt;extra_db_nodes&lt;/code&gt; вместе.</target>
        </trans-unit>
        <trans-unit id="1e5a20f661013e882b9b593b517c8c9ba753d645" translate="yes" xml:space="preserve">
          <source>If Mnesia is used as storage method, Mnesia must be started before the HTTP server. The first time Mnesia is started, the schema and the tables must be created before Mnesia is started. A simple example of a module with two functions that creates and start Mnesia is provided here. Function &lt;code&gt;first_start/0&lt;/code&gt; is to be used the first time. It creates the schema and the tables. &lt;code&gt;start/0&lt;/code&gt; is to be used in consecutive startups. &lt;code&gt;start/0&lt;/code&gt; starts Mnesia and waits for the tables to be initiated. This function must only be used when the schema and the tables are already created.</source>
          <target state="translated">Если Mnesia используется в качестве метода хранения, Mnesia необходимо запустить до HTTP-сервера. При первом запуске Mnesia схема и таблицы должны быть созданы до запуска Mnesia. Здесь представлен простой пример модуля с двумя функциями, который создает и запускает Mnesia. Функция &lt;code&gt;first_start/0&lt;/code&gt; используется в первый раз. Он создает схему и таблицы. &lt;code&gt;start/0&lt;/code&gt; должен использоваться в последовательных запусках. &lt;code&gt;start/0&lt;/code&gt; запускает Mnesia и ожидает инициализации таблиц. Эту функцию следует использовать только в том случае, если схема и таблицы уже созданы.</target>
        </trans-unit>
        <trans-unit id="a0ff6de34e690fd37142329b3d2414f3154795bb" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34211f341486b630397795df16c3df17f3d92d3" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Если P является шаблоном битовой строки &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , где каждый &lt;code&gt;Size_i&lt;/code&gt; является выражением, которое может быть оценено как целое число, а каждый &lt;code&gt;TSL_i&lt;/code&gt; является списком спецификаций типа, тогда Rep (P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Относительно Rep (TSL) см. Ниже. Опущено &lt;code&gt;Size_i&lt;/code&gt; представлена по &lt;code&gt;default&lt;/code&gt; . Опущено &lt;code&gt;TSL_i&lt;/code&gt; представлена по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d37994ece6f75def5d9f7facc328a7886d4a88b5" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,ANNO,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c2a2980c64258557d34be973ca8c30e59cc6bc" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">Если P является составным шаблоном &lt;code&gt;P_1 = P_2&lt;/code&gt; , то Rep (P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6ccb3b7440efc69c50224b64f913af2ed5a932" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,ANNO,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3a96a126f33c33dfd4bad3afe04a55374bef41" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">Если P - шаблон &amp;laquo;против&amp;raquo; &lt;code&gt;[P_h | P_t]&lt;/code&gt; , тогда Rep (P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2c7ec165d91dd1b0c944a7cacc79a36a649770" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5a1996d5cee5775413b66baffcba7cfd424d8b" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Если P - это шаблон карты &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , где каждый &lt;code&gt;A_i&lt;/code&gt; является ассоциацией &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; , тогда Rep (P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Относительно Rep (A) см. Ниже.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
