<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">В случае операции сопоставления между ReferenceID и значением CN из поля &lt;code&gt;Subject&lt;/code&gt; , первый аргумент fun - это извлеченное имя хоста из ReferenceID, а второй аргумент - это кортеж &lt;code&gt;{cn, string()}&lt;/code&gt; взятый из &lt;code&gt;Subject&lt;/code&gt; . поле. Это позволяет иметь отдельные правила сопоставления для представленных идентификаторов из поля &amp;laquo; &lt;code&gt;Subject&lt;/code&gt; и из поля &amp;laquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае ошибки (например, &lt;code&gt;addr_unreachable&lt;/code&gt; ) поле &lt;code&gt;error&lt;/code&gt; предоставляет дополнительную диагностику. В таких случаях событие &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; автоматически преобразуется в термин &lt;code&gt;error&lt;/code&gt; возвращаемый &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; . Значение поля &lt;code&gt;error&lt;/code&gt; можно преобразовать в строку с помощью &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">В случае ошибки все инструментальные функции могут возвращать либо код ошибки SNMPv1, либо код ошибки SNMPv2. Если он возвращает код SNMPv2, он преобразуется в код SNMPv1 перед отправкой менеджеру SNMPv1. Рекомендуется использовать коды ошибок SNMPv2 для всех инструментальных функций, поскольку они предоставляют более подробную информацию. См. &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; для описания преобразования кода ошибки.</target>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">В случае списков используется только процентное кодирование. Однако в двоичных файлах следует рассматривать как двоичное кодирование, так и процентное кодирование. &lt;code&gt;transcode/2&lt;/code&gt; предоставляет средства для преобразования между поддерживаемыми кодировками, он принимает &lt;code&gt;uri_string()&lt;/code&gt; и список параметров, определяющих входящие и исходящие кодировки.</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">В случае загрузки мониторинг может быть запущен &lt;strong&gt;не&lt;/strong&gt; только с помощью опции &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; , но и в особых случаях, когда ошибка загрузки временная. Таким образом, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; должен использоваться практически во &lt;strong&gt;всех&lt;/strong&gt; реальных условиях.</target>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае, когда представленные идентификаторы выбираются из поля сертификата &lt;code&gt;Subject&lt;/code&gt; , имена могут содержать символы подстановки. Функция обрабатывает это, как определено в &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случаях, когда есть выбор между типами string () и binary () для OctetString () и производных типов, представление определяется значением &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">В случаях, когда известно, что строка темы не содержит символов новой строки, стоит установить &lt;code&gt;dotall&lt;/code&gt; для получения этой оптимизации или, альтернативно, использовать ^ для явного указания привязки.</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">В случаях, когда вы хотите перенаправить стандартный ввод и / или стандартный вывод или использовать Erlang в конвейере, &lt;code&gt;werl&lt;/code&gt; не подходит, и вместо него следует использовать программу &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">В некоторых выходных функциях и при выводе возвращаемых значений в оболочке Erlang пытается обнаружить строковые данные в списках и двоичных файлах эвристически.Обычно в такой ситуации вы увидите эвристическое обнаружение:</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">В определенных ситуациях, особенно при перенаправлении стандартного вывода, может быть удобен доступ к серверу ввода-вывода, предназначенному для сообщений об ошибках. Устройство ввода-вывода &lt;code&gt;standard_error&lt;/code&gt; можно использовать для направления вывода на то, что текущая операционная система считает подходящим устройством ввода-вывода для вывода ошибок. Пример в Unix-подобной операционной системе:</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">В сочетании с &lt;code&gt;{locations, true}&lt;/code&gt; этот параметр печатает исходный файл операций блокировки и точки входа с номерами строк, а также статистику для каждой записи.</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">В сочетании с опцией &lt;code&gt;-M&lt;/code&gt; или &lt;code&gt;-MF&lt;/code&gt; добавляет фиктивную цель для каждой зависимости.</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">В сочетании с опцией &lt;code&gt;-M&lt;/code&gt; или &lt;code&gt;-MF&lt;/code&gt; изменяет имя правила, передаваемого в &lt;code&gt;Target&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">В сочетании с опцией &lt;code&gt;-M&lt;/code&gt; или &lt;code&gt;-MF&lt;/code&gt; рассматривает отсутствующие заголовки как сгенерированные файлы и добавляет их в зависимости.</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">В отличие от RPC,многоадресный вызов-это RPC,который посылается одновременно с одного клиента на несколько серверов.Это полезно для сбора информации с набора узлов,или для вызова функции на наборе узлов для достижения некоторых побочных эффектов.С семантической точки зрения это то же самое,что делать серию RPC на всех узлах,но многоадресный вызов происходит быстрее,так как все запросы посылаются одновременно и собираются один за другим,когда они возвращаются.</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства других функций обратного вызова, &lt;code&gt;stop_select&lt;/code&gt; вызывается независимо от любого порта. Нет &lt;code&gt;ErlDrvData&lt;/code&gt; аргумент передается функции. Блокировка драйвера или блокировка порта не гарантируются. Порт, который вызвал &lt;code&gt;driver_select&lt;/code&gt; , может быть даже закрыт во время &lt;code&gt;stop_select&lt;/code&gt; . Но также может быть случай, когда &lt;code&gt;stop_select&lt;/code&gt; вызывается непосредственно &lt;code&gt;erl_driver:driver_select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">Напротив,вызов подпрограммы на пронумерованную подмасштабинку всегда относится к первой подмасштабинке с заданным номером.Следующий образец совпадает с &quot;abcabc&quot; или &quot;defabc&quot;:</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">В дампах падения опускается стек,сообщения и словарь процесса.</target>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">В грязном контексте, то есть &lt;code&gt;sync_dirty&lt;/code&gt; или &lt;code&gt;async_dirty&lt;/code&gt; , измененные записи не сохраняются в локальной копии; вместо этого каждая запись обновляется отдельно. Это создает большой сетевой трафик, если таблица имеет реплику на другом узле и имеет все другие недостатки, присущие грязным операциям. Особенно для команд &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; применяются те же недостатки, что и для &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; , то есть во время итерации запись в таблицу не производится.</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">В каждом &lt;code&gt;Viewer&lt;/code&gt; активен только один фильтр, и все &lt;code&gt;Events&lt;/code&gt; трассировки, которые &lt;code&gt;Viewer&lt;/code&gt; получает от &lt;code&gt;Collector&lt;/code&gt; , проходят через этот фильтр. Написав умные фильтры, можно настроить, как &lt;code&gt;Events&lt;/code&gt; выглядеть в средстве просмотра. Следующий фильтр в &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; заменяет имена &lt;code&gt;mnesia_tm&lt;/code&gt; и &lt;code&gt;mnesia_locker&lt;/code&gt; и оставляет все остальное в записи как было:</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">В каждой итерации первые 8 бит в двоичном файле будут пропущены,а не сопоставлены.</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">В более ранних выпусках Erlang / OTP операции со слишком большими двоичными файлами обычно либо завершались ошибкой, либо давали неверные результаты. В будущих выпусках другие операции, создающие двоичные файлы (например, &lt;code&gt;list_to_binary/1&lt;/code&gt; ), вероятно, также будут применять такое же ограничение.</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">В любом случае агент ничего не сделает, но вернет полученный ManagerEngineID ( дополнительную информацию см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; ) и, возможно, продолжит этап 2 процесса обнаружения.</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">Во встроенном режиме весь код загружается при загрузке системы в соответствии с загрузочным скриптом.(Код также может быть загружен позже,явно поручив это кодовому серверу).</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">Во встроенном режиме сначала загружаются все модули. Затем &lt;code&gt;on_load&lt;/code&gt; все функции on_load . Система прекращает работу, если все функции &lt;code&gt;on_load&lt;/code&gt; не возвращают &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">Во встроенном режиме модули не загружаются автоматически.Попытка использовать не загруженный модуль приводит к ошибке.Этот режим рекомендуется,когда сценарий загрузки загружает все модули,как это обычно делается в релизах OTP.(Код все равно может быть загружен позже,явно поручив это кодовому серверу).</target>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Во встроенных системах с ограниченным объемом оперативной памяти и без виртуальной памяти вы можете захотеть сохранить память, установив &lt;code&gt;Number&lt;/code&gt; равным нулю. (Значение можно установить глобально, см &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">По сути, функция выполняет ту же операцию, что и &lt;code&gt;ei_xreceive_msg&lt;/code&gt; , но вместо использования &lt;code&gt;ei_x_buff&lt;/code&gt; функция ожидает указатель на указатель символа ( &lt;code&gt;mbufp&lt;/code&gt; ), где указатель символа должен указывать на область памяти, выделенную &lt;code&gt;malloc&lt;/code&gt; . Аргумент &lt;code&gt;bufsz&lt;/code&gt; должен быть указателем на целое число, содержащее точный размер (в байтах) области памяти. Функция может перераспределить область памяти и в таких случаях поместит новый размер в &lt;code&gt;*bufsz&lt;/code&gt; и обновит &lt;code&gt;*mbufp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">В каждом каталоге под &lt;code&gt;DocumentRoot&lt;/code&gt; или под &lt;code&gt;Alias&lt;/code&gt; пользователь может разместить файл доступа. Файл доступа - это простой текстовый файл, в котором указываются ограничения, которые необходимо учитывать перед тем, как веб-сервер ответит на запрос. Если на пути к запрошенному активу имеется более одного файла доступа, используются директивы в файле доступа в каталоге, ближайшем к активу.</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">На самом деле,поскольку случайные данные кэшируются,некоторые числа могут быть воспроизведены при попытке,но это непредсказуемо.</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">В удачных случаях несоответствие видно только в таблицах,относящихся к конкретному приложению.Однако если операция по восстановлению схемы восстановлена непоследовательно из-за принудительного решения о восстановлении операции,последствия несоответствия могут быть фатальными.Однако,если более высоким приоритетом является доступность,а не согласованность,это может стоить риска.</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">Как правило, ошибки исправляются только в последнем &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; , а новые функции представлены в следующем выпуске, который находится в стадии разработки. Однако, когда мы по внутренним причинам исправим ошибки в старых выпусках, они также будут доступны и объявлены.</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">Как правило, подшаблоны, которым не было присвоено значение в совпадении, возвращаются как кортеж &lt;code&gt;{-1,0}&lt;/code&gt; , если &lt;code&gt;type&lt;/code&gt; является &lt;code&gt;index&lt;/code&gt; . Неназначенные подшаблоны возвращаются как пустой двоичный файл или список, соответственно, для других типов возвращаемых значений. Рассмотрим следующее регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">В целом,существуют лучшие способы,чем использование тайм-аутов для контроля над частями распределенной системы Erlang.Тайм-ауты обычно подходят для наблюдения за внешними событиями,например,если вы ожидали сообщение от какой-то внешней системы в течение указанного времени.Например,тайм-аут может использоваться для выхода пользователя из системы обмена сообщениями,если он не получал к ней доступа,скажем,в течение десяти минут.</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">Как правило,кортежи используются там,где &quot;записи&quot; или &quot;структуры&quot; используются в других языках.Кроме того,списки используются,когда представляют вещи разного размера,то есть,когда связанные списки используются на других языках.</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">Как правило, версии могут состоять более чем из трех частей. Тогда версии заказываются только частично. Такие версии используются только в исключительных случаях. Когда к номеру версии добавляется дополнительная часть (из трех обычных), создается новая ветвь версий. Новая ветка имеет линейный порядок по сравнению с базовой версией. Однако версии в разных ветвях не имеют порядка, и поэтому можно только сделать вывод, что все они включают то, что входит в их ближайшего общего предка. Если ответвление несколько раз из одной и той же базовой версии, &lt;code&gt;0&lt;/code&gt; частей добавляются между базовой версией и наименее значимого &lt;code&gt;1&lt;/code&gt; части до тех пор , уникальная версия не будет найдена. Версии, имеющие порядок, можно сравнить, как описано в предыдущем абзаце.</target>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">В режиме глобальной трассировки коллектор автоматически начнет трассировку по всем подключенным узлам Эрланга.При подключении узла на этом узле будет запущен трассировщик портов,а на узле коллектора-соответствующий клиент трассировки.</target>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">В интерактивном режиме код динамически загружается при первом обращении.При вызове функции в модуле,когда модуль не загружен,сервер кода ищет путь к коду и загружает модуль в систему.</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">В интерактивном режиме сервер кода поддерживает путь поиска, обычно называемый &lt;strong&gt;путем кода&lt;/strong&gt; , состоящий из списка каталогов, в которых он последовательно выполняет поиск при попытке загрузить модуль.</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">В интерактивном режиме,который по умолчанию является интерактивным,во время запуска системы загружается только некоторый код,в основном модули,необходимые для работы системы.Другой код загружается динамически при первом обращении к нему.Когда происходит вызов функции в определенном модуле,и модуль не загружается,кодовый сервер ищет и пытается загрузить модуль.</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">В простейших формах &lt;code&gt;match_spec&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">В локальном режиме код интерпретируется только на текущем узле.В глобальном режиме код интерпретируется на всех известных узлах.Процессы на других узлах,выполняющие интерпретацию кода,автоматически отображаются в окне Монитор и могут быть подключены к ним,как и к любому другому отлаженному процессу.</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">В системах с низким объемом памяти (особенно без виртуальной памяти) установка значения &lt;code&gt;0&lt;/code&gt; может помочь сэкономить память.</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">Во многих приложениях накладные расходы,связанные с обработкой транзакции,могут привести к потере производительности.Грязные операции-это короткие промежутки времени,которые обходят большую часть обработки и увеличивают скорость транзакции.</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">Во многих системах переходные состояния перегруженных очередей являются нормальным явлением. Хотя эта функция возвращает &lt;code&gt;false&lt;/code&gt; , это не означает, что другой узел гарантированно не отвечает, это может быть временной перегрузкой. Кроме того, возвращаемое значение &lt;code&gt;true&lt;/code&gt; означает только то, что сообщение может быть отправлено по каналу (TCP) без блокировки; сообщение не гарантированно поступит на удаленный узел. Для отключенного неотвечающего узла возвращаемое значение - &lt;code&gt;true&lt;/code&gt; (имитирует поведение оператора &lt;code&gt;!&lt;/code&gt; ). Ожидаемое поведение и действия, которые следует предпринять, когда функция возвращает &lt;code&gt;false&lt;/code&gt; , зависят от приложения и оборудования.</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">При совпадении это значение по умолчанию действует только для последнего элемента.Все остальные битовые строки или двоичные элементы при совпадении должны иметь спецификацию размера.</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">Через микросекунды</target>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">В режиме &lt;code&gt;verify_none&lt;/code&gt; поведение по умолчанию - разрешить все ошибки проверки x509-path. См. Также параметр &lt;code&gt;verify_fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">&lt;code&gt;erlang:hibernate/3&lt;/code&gt; более техническим языком, erlang: hibernate / 3 отбрасывает стек вызовов для процесса, а затем мусор собирает процесс. После этого все живые данные хранятся в одной непрерывной куче. Затем куча сжимается до того же размера, что и текущие данные, которые она хранит (даже если этот размер меньше минимального размера кучи для процесса).</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">В большинстве функций API, где вы можете использовать это семейство адресов, номер порта должен быть &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">В большинстве случаев параметр &lt;code&gt;RootDir&lt;/code&gt; должен быть установлен таким же, как параметр конфигурации &lt;code&gt;root_dir&lt;/code&gt; , используемый при вызове &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (или &lt;code&gt;code:root_dir()&lt;/code&gt; если параметр конфигурации не установлен). В некоторых случаях может быть полезно оценить одну и ту же целевую спецификацию для разных корневых каталогов. Однако это следует использовать с большой осторожностью, поскольку для этого требуются эквивалентные файловые структуры для всех корней.</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">В обычном режиме нажатия клавиш пользователем собираются и интерпретируются &lt;code&gt;tty&lt;/code&gt; . Поддерживается большинство команд редактирования строк &lt;strong&gt;Emacs&lt;/strong&gt; . Ниже приводится полный список поддерживаемых команд редактирования строки.</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">При нормальной работе вызовы &lt;code&gt;et:trace_me/4,5&lt;/code&gt; почти бесплатны. Когда трассировка необходима, вы можете активировать трассировку для этих функций явно. Или вы можете комбинировать использование &lt;code&gt;trace_global&lt;/code&gt; с использованием &lt;code&gt;trace_pattern&lt;/code&gt; . Если установлено, &lt;code&gt;trace_pattern&lt;/code&gt; будет автоматически активирован на всех подключенных узлах.</target>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">Для того,чтобы в реализации в полной мере использовать расширенные коды ошибок SNMPv2,необходимо,чтобы функции приборов всегда возвращали коды ошибок SNMPv2 в случае ошибки.При необходимости они транслируются агентом в соответствующие коды ошибок SNMPv1.</target>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">Чтобы API-интерфейс потока драйвера Erlang мог работать, в системе времени выполнения должна быть включена поддержка потоков. Драйвер Erlang может проверить, включена ли поддержка потоков, используя &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что некоторые функции в API драйвера Erlang являются потокобезопасными только в том случае, если система времени выполнения имеет поддержку SMP, также эту информацию можно получить через &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; . Также обратите внимание, что многие функции в API драйвера Erlang &lt;strong&gt;не&lt;/strong&gt; являются потокобезопасными, независимо от того, включена ли поддержка SMP или нет. Если функция не задокументирована как потокобезопасная, она &lt;strong&gt;не&lt;/strong&gt; является потокобезопасной.</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Для того, чтобы функция прерывания / продолжения работала, &lt;code&gt;Common Test&lt;/code&gt; должен освободить процесс оболочки, управляющий &lt;code&gt;stdin&lt;/code&gt; . Это делается путем установки запуска опции &lt;code&gt;release_shell&lt;/code&gt; к &lt;code&gt;true&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; Руководства пользователя.</target>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Чтобы система времени выполнения могла связывать планировщики, должна быть известна топология ЦП. Если исполняющая система не может автоматически определить топологию ЦП, ее можно определить. Для получения дополнительной информации о том, как определить топологию ЦП, см. Флаг командной строки &lt;code&gt;+sct&lt;/code&gt; в &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">Для того,чтобы это работало правильно,пользователь должен обеспечить выполнение следующих двух требований:</target>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">Для того,чтобы добавить эти данные в конец документа motorcles.xml,необходимо разобрать файл и добавить данные в конец содержимого корневого элемента.</target>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">Чтобы скомпилировать код Erlang, должна быть создана небольшая система начальной загрузки Erlang или система Erlang / OTP того же выпуска, что и создаваемая, должна быть указана в &lt;code&gt;$PATH&lt;/code&gt; . Erlang / OTP для целевой системы будет построен с использованием этой системы Erlang вместе с предоставленными инструментами кросс-компиляции.</target>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">Для того,чтобы полностью понять внутреннюю форму,вы должны получить спецификацию ASN.1 для протокола Megaco/H.248 и применить правила,приведенные выше.Пожалуйста,ознакомьтесь с документацией компилятора ASN.1 в Erlang/OTP для получения более подробной информации о семантике в отображении между ASN.1 и соответствующей внутренней формой.</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">Чтобы еще больше упростить трассировку, вы можете использовать функции &lt;code&gt;et:trace_me/4,5&lt;/code&gt; . Эти функции предназначены для вызова из других приложений, когда в вашем приложении есть интересные &lt;code&gt;Events&lt;/code&gt; , которые необходимо выделить. Функции очень легкие, так как они ничего не делают, кроме возврата атома. Эти функции специально разработаны для отслеживания. Поскольку вызывающий объект явно предоставляет значения для полей &lt;code&gt;Event Record&lt;/code&gt; , &lt;code&gt;Collector Filter&lt;/code&gt; по умолчанию может автоматически предоставлять настроенную &lt;code&gt;Event Record&lt;/code&gt; без каких-либо пользовательских функций фильтрации.</target>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">Для того,чтобы сделать Xref простым в использовании,существуют предопределенные анализы,которые выполняют некоторые общие задачи.Как правило,модуль или релиз могут быть проверены на вызовы к неопределенным функциям.Для более продвинутого пользователя существует небольшой,но достаточно гибкий язык,который может быть использован для выбора частей анализируемой системы и для выполнения некоторого простого анализа графиков выбранных вызовов.</target>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">Для того,чтобы подготовить МП к отправке начального сообщения,надеюсь,запрос на изменение услуги,необходимо выполнить следующие действия:</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">Для того,чтобы подготовить МПК к приему исходного сообщения,надеюсь,запрос на изменение сервиса,необходимо выполнить следующее:</target>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">Для обеспечения решения масштабируемых реализаций MG и MGC,пользователь может быть распределен по нескольким узлам Erlang.Один из узлов Erlang подключен к физическому сетевому интерфейсу,но сообщения могут отправляться с других узлов,а ответы автоматически пересылаются обратно на исходный узел.</target>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">Чтобы просмотреть подробные детали &lt;code&gt;Event&lt;/code&gt; вы можете щелкнуть по &lt;code&gt;Event&lt;/code&gt; , чтобы запустить средство &lt;code&gt;Contents Viewer&lt;/code&gt; для этого &lt;code&gt;Event&lt;/code&gt; . В &lt;code&gt;Contents Viewer&lt;/code&gt; также есть меню фильтров, которое позволяет просматривать &lt;code&gt;Event&lt;/code&gt; из других представлений, кроме того, которое выбрано в средстве просмотра. Щелчок на &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; вызовет &lt;code&gt;Contents Viewer&lt;/code&gt; окно выскочит, показывая &lt;code&gt;Event&lt;/code&gt; в &lt;code&gt;mgr_actors&lt;/code&gt; просмотр:</target>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать систему тегов, необходимо создать файл с именем &lt;code&gt;TAGS&lt;/code&gt; . Файл можно рассматривать как базу данных по всем функциям, записям и макросам во всех файлах проекта. &lt;code&gt;TAGS&lt;/code&gt; файл может быть создан с использованием двух различных методов Erlang. Первая - это стандартная утилита Emacs etags, вторая - с использованием &lt;code&gt;tags&lt;/code&gt; модуля Erlang .</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">В наших измерениях мы увидели,что между ASN.1 BER и компактным текстовым форматом нет значительных различий в размерах сообщений.Немного внимания следует уделить использованию красивого текстового стиля (который используется во всех примерах,включенных в спецификацию протокола,и предпочтительнее во время сеансов отладки),так как в этом случае сообщения могут быть довольно большими.Если размер сообщения действительно является серьезной проблемой,следует использовать наш кодировщик,так как формат ASN.1 PER намного компактнее,чем все другие альтернативы.Его основным недостатком является то,что он не был одобрен в качестве действительной кодировки сообщений Megaco/H.248.</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">На практике наборы объектов обычно объявляются расширяемыми,так что позже в набор можно будет добавить больше объектов.Расширяемость указывается следующим образом:</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">В предыдущих версиях &lt;code&gt;file&lt;/code&gt; режимы указывались как один из атомов &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; или &lt;code&gt;read_write&lt;/code&gt; вместо списка. Это все еще разрешено по причинам обратной совместимости, но не должно использоваться для нового кода. Также обратите внимание, что &lt;code&gt;read_write&lt;/code&gt; не допускается в списке режимов.</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">В принципе, эта функция вызывает функцию &lt;code&gt;process_received_message/4&lt;/code&gt; через &lt;code&gt;spawn&lt;/code&gt; для выполнения фактической обработки.</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">В протоколах, которые поддерживают инициируемое клиентом повторное согласование, стоимость ресурсов для такой операции выше для сервера, чем для клиента. Это может действовать как вектор для атак типа &amp;laquo;отказ в обслуживании&amp;raquo;. Приложение SSL уже принимает меры для противодействия таким попыткам, но инициируемое клиентом повторное согласование можно строго отключить, установив для этого параметра значение &lt;code&gt;false&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;true&lt;/code&gt; . Обратите внимание, что отключение повторного согласования может привести к тому, что долгоживущие соединения станут непригодными для использования из-за ограничений на количество сообщений, которые базовый набор шифров может зашифровать.</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">В редких случаях эта функция может не работать на Unix.Она может произойти,если права на чтение не существует для родительских каталогов текущей директории.</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">В действительности модели данных редко полностью нормализуются. Реалистичной альтернативой нормализованной модели базы данных была бы модель данных, которая даже не находится в первой нормальной форме. &lt;code&gt;Mnesia&lt;/code&gt; подходит для таких приложений, как телекоммуникации, потому что в нем легко организовать данные гибким образом. &lt;code&gt;Mnesia&lt;/code&gt; база данных всегда организована в виде набора таблиц. Каждая таблица заполнена строками, объектами и записями. Что отличает &lt;code&gt;Mnesia&lt;/code&gt; ,так это то, что отдельные поля в записи могут содержать любой тип составных структур данных. Отдельное поле в записи может содержать списки, кортежи, функции и даже код записи.</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">В сценарии 1 процесс тестового примера завершается нормально после того, как &lt;code&gt;case A&lt;/code&gt; завершил выполнение своего тестового кода без обнаружения каких-либо ошибок. Функция тестового примера возвращает значение, а &lt;code&gt;Common Test&lt;/code&gt; регистрирует тестовый пример как успешный.</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">В сценарии 2 во время выполнения тестового &lt;code&gt;case B&lt;/code&gt; обнаруживается ошибка . Это приводит к тому, что функция тестового &lt;code&gt;case B&lt;/code&gt; генерирует исключение, и в результате процесс тестового примера завершается по иной причине, чем нормальная. &lt;code&gt;Common Test&lt;/code&gt; регистрирует это как неудачный (неуспешный) тестовый пример.</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В разделе о мифах был разоблачен следующий миф: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">Короче говоря, &lt;code&gt;DebugType&lt;/code&gt; предназначен только для отладки. Бревна в процессе производства лучше производить на стандартных лесозаготовительных установках Erlang.</target>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">В некоторых приложениях игнорирование ответов из отдельных журналов может быть недопустимым. Альтернативой в таких ситуациях является использование нескольких журналов локального диска вместо одного журнала распределенного диска и реализация распределения без использования модуля &lt;code&gt;disk_log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">В некоторых аспектах компилятор Erlang MIB не следует и не реализует SMI полностью.Вот в чем разница:</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">В некоторых аспектах агент не реализует SNMP полностью.Вот в чем разница:</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">В некоторых случаях правила синтаксиса Эрланга делают невозможным размещение метапеременной непосредственно там,где вам хотелось бы.Например,вы не можете писать:</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">В некоторых случаях операции выбора / сопоставления не требуют сканирования всей таблицы. Например, если часть ключа связана при поиске в таблице &lt;code&gt;ordered_set&lt;/code&gt; , или если это таблица Mnesia и есть вторичный индекс в поле, которое выбрано / сопоставлено. Если ключ полностью привязан, нет смысла делать выбор / сопоставление, если у вас нет таблицы пакетов и вас интересует только подмножество элементов с определенным ключом.</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">В некоторых контекстах допускается только строка или целое число. Например, директива &lt;code&gt;-file(Name, Line)&lt;/code&gt; требует, чтобы &lt;code&gt;Name&lt;/code&gt; был строковым литералом, а &lt;code&gt;Line&lt;/code&gt; - целочисленным литералом:</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;locked&lt;/code&gt; состоянии , когда кнопка нажата, она собирается с последними нажатыми кнопками до длины правильного кода и сравнивается с правильным кодом. В зависимости от результата дверь либо разблокируется, и &lt;code&gt;gen_statem&lt;/code&gt; переходит в состояние &amp;laquo; &lt;code&gt;open&lt;/code&gt; , либо дверь остается в состоянии &amp;laquo; &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;open&lt;/code&gt; состоянии событие кнопки игнорируется, так как остается в том же состоянии. Это также можно сделать, вернув &lt;code&gt;{keep_state, Data}&lt;/code&gt; или, в этом случае, поскольку &lt;code&gt;Data&lt;/code&gt; изменились, даже путем возврата &lt;code&gt;keep_state_and_data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">В системах с большим количеством процессов вычислительные задачи, которые выполняются в течение короткого времени, могут быть перенесены в новый процесс с более высоким минимальным размером кучи. Когда процесс завершен, он отправляет результат вычисления другому процессу и завершается. Если минимальный размер кучи рассчитан правильно, процессу, возможно, вообще не придется выполнять сборку мусора. &lt;strong&gt;Эту оптимизацию нельзя проводить без надлежащих измерений.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">В телекоммуникационных приложениях потребности отличаются от возможностей,предоставляемых традиционными СУБД.Приложения,реализованные в настоящее время в Erlang,нуждаются в сочетании широкого спектра возможностей,которые,как правило,не удовлетворяются традиционными СУБД.Mnesia разработана с учетом следующих требований:</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">В 32-битной реализации Erlang 536 870 911 байт - это самый большой двоичный файл, который может быть создан или сопоставлен с использованием битового синтаксиса. В 64-битной реализации максимальный размер составляет 2 305 843 009 213 693 951 байт. Если предел превышен, построение битового синтаксиса завершается ошибкой с исключением &lt;code&gt;system_limit&lt;/code&gt; , в то время как любая попытка сопоставить слишком большой двоичный файл терпит неудачу. Это ограничение действует начиная с R11B-4.</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">В &lt;code&gt;MatchBody&lt;/code&gt; и &lt;code&gt;MatchCondition&lt;/code&gt; можно использовать только ранее связанные переменные.</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">В &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; не разрешены никакие несвязанные переменные, поэтому &lt;code&gt;'_'&lt;/code&gt; интерпретируется как сам (атом). Переменные могут быть связаны только в части &lt;code&gt;MatchHead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">В &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; интерпретация в некоторой степени отличается. Литералы в этих частях могут быть записаны &amp;laquo;как есть&amp;raquo;, что работает для всех литералов, кроме кортежей, или с использованием специальной формы &lt;code&gt;{const, T}&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - любой терм Эрланга.</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">В части &lt;code&gt;MatchHead&lt;/code&gt; все литералы (кроме переменных выше) интерпретируются &amp;laquo;как есть&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;do_perm&lt;/code&gt; мы выполняем работу, работая со структурой, которая была выделена на &lt;code&gt;output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;ets:fun2ms/1&lt;/code&gt; необходимо включить &lt;code&gt;ms_transform.hrl&lt;/code&gt; в исходный код, так как именно он запускает преобразование синтаксического анализа вызова &lt;code&gt;ets:fun2ms/1&lt;/code&gt; в допустимую спецификацию соответствия. Это также означает, что преобразование выполняется во время компиляции (кроме случаев, когда оно вызывается из оболочки) и поэтому не требует ресурсов во время выполнения. То есть, хотя вы используете более интуитивно понятный забавный синтаксис, он становится таким же эффективным во время выполнения, как и ручное написание спецификаций соответствия.</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">В &lt;code&gt;main&lt;/code&gt; функции программа C должна прослушивать сообщение от Erlang и, в соответствии с выбранной схемой кодирования / декодирования, использовать первый байт, чтобы определить, какую функцию вызывать, и второй байт в качестве аргумента функции. Результат вызова функции должен быть отправлен обратно в Erlang:</target>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">В функции &lt;code&gt;ready_async&lt;/code&gt; вывод отправляется обратно в эмулятор. Мы используем формат термина драйвера вместо &lt;code&gt;ei&lt;/code&gt; . Это единственный способ отправить термины Erlang напрямую драйверу, не имея кода Erlang для вызова &lt;code&gt;binary_to_term/1&lt;/code&gt; . В простом примере это работает хорошо, и нам не нужно использовать &lt;code&gt;ei&lt;/code&gt; для обработки двоичного формата термина.</target>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">В API Megaco пользователь может явно посылать запросы на действия,но генерация идентификаторов транзакций,кодировка и фактическая передача сообщения удаленному пользователю обрабатывается автоматически протокольным движком в соответствии с фактической конфигурацией соединения.Сообщения Megaco не отображаются в API.</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">В системе времени выполнения Erlang объекты выполняются параллельно только при наличии нескольких планировщиков. Поэтому &lt;code&gt;lcnt&lt;/code&gt; будет показывать больше конфликтных точек (и, следовательно, будет более полезен) в системах, использующих множество планировщиков на многих ядрах.</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">В приложении Kernel:</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">В таблицах Мнезии два ключевых столбца хранятся в виде кортежа с двумя элементами.Таким образом,arity таблицы 3.</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">В совместимой с POSIX.2 библиотеке, которая была включена в 4.4BSD Unix, уродливый синтаксис [[: &amp;lt;:]] и [[:&amp;gt;:]] используется для сопоставления &amp;laquo;начала слова&amp;raquo; и &amp;laquo;конца слова&amp;raquo;. PCRE рассматривает эти предметы следующим образом:</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">В PRF (псевдослучайная функция)для генерации кеинга материалов в наборах шифров,не использующих PFS.</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">В приложении SSL в качестве альтернативы можно использовать дополнительный модуль распространения, &lt;code&gt;inet_tls_dist&lt;/code&gt; . Все соединения распределения будут использовать TLS, и все участвующие узлы Erlang в распределенной системе должны использовать этот модуль распределения.</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">В приложении STDLIB:</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">В приведенном выше примере &amp;laquo;pong&amp;raquo; был впервые создан, чтобы иметь возможность идентифицировать &amp;laquo;pong&amp;raquo; при запуске &amp;laquo;ping&amp;raquo;. То есть каким-то образом &amp;laquo;ping&amp;raquo; должен иметь возможность узнать личность &amp;laquo;pong&amp;raquo;, чтобы иметь возможность отправить ему сообщение. Иногда процессы, которым необходимо знать личности друг друга, запускаются независимо друг от друга. Таким образом, Erlang предоставляет механизм для присвоения имен процессам, чтобы эти имена можно было использовать в качестве идентификаторов вместо идентификаторов. Это делается с помощью &lt;code&gt;register&lt;/code&gt; BIF:</target>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">В базовом сценарии каждый пользователь загружает драйвер перед началом его использования и выгружает драйвер по окончании.Счетчик ссылок отслеживает процессы и количество загрузок по каждому процессу.Таким образом,драйвер выгружается только тогда,когда его никто не хочет (у него нет пользователя).Драйвер также отслеживает открытые для него порты.Это позволяет задержать выгрузку до тех пор,пока все порты не будут закрыты,или убить все порты,которые используют драйвер,когда он выгружается.</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">В вышеприведенном случае файл извлекается из того же каталога,что и все остальные файлы в примере мессенджера.(*manual*).</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">В случае обновления &lt;code&gt;OldVsn&lt;/code&gt; будет &lt;code&gt;Vsn&lt;/code&gt; , а в случае &lt;code&gt;OldVsn&lt;/code&gt; на более раннюю версию OldVsn будет &lt;code&gt;{down,Vsn}&lt;/code&gt; . &lt;code&gt;Vsn&lt;/code&gt; определяется атрибутом (ами) &lt;code&gt;vsn&lt;/code&gt; старой версии модуля обратного вызова &lt;code&gt;Module&lt;/code&gt; . Если такой атрибут не определен, версией является контрольная сумма файла BEAM.</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае ответа megaco отменит ответ, и информация об этом будет возвращена пользователю через вызов функции обратного вызова &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае запросов мегако отменит сообщение почти так же, как если бы было &lt;code&gt;megaco:cancel&lt;/code&gt; (после успешной отправки). Информация будет передаваться обратно пользователю по-разному, в зависимости от того, как были &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; запросы: для запросов, отправленных с помощью megaco: call , информация будет доставлена ​​в виде возвращаемого значения. Для запросов, &lt;code&gt;megaco:cast&lt;/code&gt; с использованием megaco: cast, информация будет доставлена ​​через вызов функции обратного вызова &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">В случае, если местом &lt;code&gt;Destination&lt;/code&gt; является &lt;code&gt;File&lt;/code&gt; , печатаемые события трассировки мегако будут напечатаны в файл &lt;code&gt;File&lt;/code&gt; с использованием простого &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">В случае, если &lt;code&gt;Destination&lt;/code&gt; - &lt;code&gt;io&lt;/code&gt; , печатаемые события трассировки мегако будут напечатаны на stdout с использованием простого &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">В случае, когда тип pdu - &lt;code&gt;report&lt;/code&gt; , &lt;code&gt;MsgData&lt;/code&gt; либо в &lt;code&gt;ok&lt;/code&gt; либо &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">Во фрагменте кода в начале этого раздела добавление в &lt;code&gt;Bin&lt;/code&gt; будет дешевым, а добавление в &lt;code&gt;Bin0&lt;/code&gt; вызовет создание нового двоичного &lt;code&gt;Bin0&lt;/code&gt; и копирование содержимого Bin0 .</target>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">В файле спецификации обложки вы также можете указать необходимый вам уровень анализа покрытия кода; &lt;code&gt;details&lt;/code&gt; или &lt;code&gt;overview&lt;/code&gt; . В подробном режиме вы получаете страницу обзора покрытия, показывающую по модулям и общему проценту покрытия. Вы также получаете распечатанный HTML-файл для каждого модуля, включенного в анализ, с точным указанием того, какие части кода были выполнены во время теста. В режиме обзора печатается только страница обзора покрытия кода.</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">В текущей версии &lt;code&gt;Common Test&lt;/code&gt; функция &lt;code&gt;silent_connections&lt;/code&gt; работает только для подключений Telnet и SSH. Поддержка других типов подключения может быть добавлена ​​в будущих версиях &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В текущей реализации привязки Erlang / SCTP это событие внутренне преобразуется в термин &lt;code&gt;error&lt;/code&gt; возвращаемый &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">В текущей реализации каждая операция вставки и поиска объекта приводит к созданию его копии.</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">В текущей версии &lt;code&gt;CurVsn&lt;/code&gt; выпуска каталог приложения &lt;code&gt;myapp&lt;/code&gt; - это &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; . Новая версия &lt;code&gt;NewVsn&lt;/code&gt; распаковывается за пределами обработчика выпуска, и обработчик выпуска информируется об этом с помощью следующего вызова:</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">В каталоге данных &lt;code&gt;data_dir&lt;/code&gt; тестовый модуль имеет свои собственные файлы, необходимые для тестирования. Имя &lt;code&gt;data_dir&lt;/code&gt; - это имя набора тестов, за которым следует &lt;code&gt;&quot;_data&quot;&lt;/code&gt; . Например, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; имеет каталог данных &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; . Используйте этот каталог для переносимости, то есть, чтобы избежать жесткого кодирования имен каталогов в вашем наборе. Поскольку каталог данных хранится в том же каталоге, что и ваш набор тестов, вы можете полагаться на его существование во время выполнения, даже если путь к каталогу вашего набора тестов изменился между реализацией набора тестов и выполнением.</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">В приведенных ниже описаниях перечислена форма,которая используется для изменения значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">В окне подробной информации для узла отображаются все существующие связи и мониторы между процессами на исходном узле и подключенном узле. &lt;strong&gt;Дополнительная информация&lt;/strong&gt; может содержать отладочную информацию (то есть специальную информацию, записанную, если эмулятор компилируется отладкой) или информацию об ошибках.</target>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">В диспетчере &lt;strong&gt;событий&lt;/strong&gt; установлено ноль, один или несколько &lt;strong&gt;обработчиков событий&lt;/strong&gt; . Когда диспетчер событий получает уведомление о событии, событие обрабатывается всеми установленными обработчиками событий. Например, в диспетчере событий для обработки ошибок по умолчанию может быть установлен обработчик, который записывает сообщения об ошибках в терминал. Если сообщения об ошибках в течение определенного периода также должны быть сохранены в файл, пользователь добавляет другой обработчик событий, который делает это. Когда регистрация в файл больше не требуется, этот обработчик событий удаляется.</target>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">В приведенном выше примере допустимыми &lt;code&gt;keys&lt;/code&gt; могут быть &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; и &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; , тогда как &lt;code&gt;&quot;hi&quot;&lt;/code&gt; , &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; и &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; будет недействительным.</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">В примере ниже строки под номерами 2,4,6,8 и 11 являются исполняемыми:</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">В примере из предыдущего раздела &lt;code&gt;gen_server&lt;/code&gt; запускается путем вызова &lt;code&gt;ch3:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">В примере из предыдущего раздела &lt;code&gt;gen_statem&lt;/code&gt; запускается вызовом &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">В примере представлены идентификаторы &lt;code&gt;example.com&lt;/code&gt; , а также имена хостов, соответствующие &lt;code&gt;*.example.com&lt;/code&gt; . Например, &lt;code&gt;foo.example.com&lt;/code&gt; и &lt;code&gt;bar.example.com&lt;/code&gt; совпадают, но не &lt;code&gt;foo.bar.example.com&lt;/code&gt; . Имя &lt;code&gt;erlang.org&lt;/code&gt; не совпадает ни с одним, так как это не CN.</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">В этом примере &lt;code&gt;handle_debug&lt;/code&gt; вызывается для каждого входящего и исходящего сообщения. Функция форматирования &lt;code&gt;Func&lt;/code&gt; - это функция &lt;code&gt;ch4:write_debug/3&lt;/code&gt; , которая печатает сообщение с использованием &lt;code&gt;io:format/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В этом примере выбирается &lt;code&gt;number&lt;/code&gt; компонента первого из закодированных элементов в &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; . Это применимо к спецификации ASN.1 в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">В этом примере оператор &lt;code&gt;==/2&lt;/code&gt; обрабатывается точно так же, как и &lt;code&gt;=:=/2&lt;/code&gt; . Однако, если он не может быть определен во время компиляции , что некоторая константа не содержит целые числа, и таблицу использует &lt;code&gt;=:=/2&lt;/code&gt; при сравнении ключей для равенства (см варианта &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; ), то &lt;code&gt;qlc&lt;/code&gt; модуль не пытается искать постоянный , Причина в том, что в общем случае не существует верхнего предела количества значений ключа, которые могут быть сопоставлены с такой константой; необходимо искать каждую комбинацию целых чисел и чисел с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">В примере используется синхронный запуск. Процесс начинается с вызова &lt;code&gt;ch4:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">В этом примере простое имя узла - &lt;code&gt;c1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">В примере:</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">В примерах вы можете видеть, что оболочка Erlang по умолчанию интерпретирует только символы из диапазона ISO Latin1 как печатные и обнаруживает только списки или двоичные файлы с этими &amp;laquo;печатными&amp;raquo; символами как содержащие строковые данные. Действительный двоичный код UTF-8, содержащий русское слово &amp;laquo;Юникод&amp;raquo;, не печатается в виде строки. При запуске со всеми печатаемыми символами Unicode ( &lt;code&gt;+pc unicode&lt;/code&gt; ) оболочка выводит все, что содержит печатаемые данные Unicode (в двоичных файлах, в кодировке UTF-8 или побайтно) в виде строковых данных.</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">При обмене DH-параметрами в наборах шифров,обеспечивающих неанонимную PFS (совершенную прямую секретность).</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">В первой форме вызовов функций, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; , каждое из &lt;code&gt;ExprM&lt;/code&gt; и &lt;code&gt;ExprF&lt;/code&gt; должно быть атомом или выражением, которое оценивается как атом. Говорят, что функция вызывается с использованием &lt;strong&gt;полного имени функции&lt;/strong&gt; . Это часто называют &lt;strong&gt;удаленным&lt;/strong&gt; или &lt;strong&gt;внешним вызовом функции&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">В первом разделе действия &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; упоминались как часть общей модели конечного автомата. Эти общие действия реализуются с помощью кода, который модуль обратного вызова &lt;code&gt;gen_statem&lt;/code&gt; выполняет в функции обратного вызова обработки событий перед возвратом в механизм &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">В первом слове (4 байта) &lt;code&gt;ID&lt;/code&gt; значимы только 18 бит, остальные должны быть равны 0. В &lt;code&gt;Creation&lt;/code&gt; значимы только два бита, остальные должны быть равны 0.</target>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">В следующих описаниях использование слова &amp;laquo; &lt;strong&gt;Точка&amp;raquo;&lt;/strong&gt; означает: &amp;laquo;Точку можно рассматривать как позицию курсора. Точнее, точка - это позиция между двумя символами, в то время как курсор наведен на символ, следующий за точкой&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">В следующих описаниях &lt;strong&gt;групповой узел&lt;/strong&gt; - это узел, принадлежащий той же глобальной группе, что и локальный узел.</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">В следующих описаниях все функции выходят из строя по причине &lt;code&gt;badarg&lt;/code&gt; , если &lt;code&gt;heart&lt;/code&gt; не запускается.</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">В следующем примере QLC &lt;code&gt;V2&lt;/code&gt; был вставлен, чтобы показать объединенные генераторы и выбранный метод объединения. Для соединения поиска используется соглашение: первый генератор ( &lt;code&gt;G2&lt;/code&gt; ) - это тот, который прошел, второй ( &lt;code&gt;G1&lt;/code&gt; ) - это таблица, в которой ищутся константы.</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">В следующем примере кэшированных результаты слияния перемещаются для каждого значения &lt;code&gt;A&lt;/code&gt; . Обратите внимание , что без опции &lt;code&gt;cache&lt;/code&gt; объединения будет проведено три раза, один раз для каждого значения &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">В следующем примере создаются два процесса,которые посылают сообщения друг другу несколько раз.</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">В следующем примере два простых QLC вставляются только для хранения опции &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">В следующем примере с помощью этой программы узлы запускаются на четырех разных компьютерах.Если в вашей сети не так много машин,вы можете запустить несколько узлов на одной машине.</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">В следующем примере &lt;code&gt;Common Test&lt;/code&gt; находит и выполняет два теста: один для пути от &lt;code&gt;top2&lt;/code&gt; к &lt;code&gt;sub2X2&lt;/code&gt; через &lt;code&gt;sub21&lt;/code&gt; , а &lt;code&gt;top2&lt;/code&gt; от top2 к &lt;code&gt;sub2X2&lt;/code&gt; через &lt;code&gt;sub22&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">В следующем примере &lt;code&gt;{Pid, hello_world}&lt;/code&gt; отправляется зарегистрированному процессу &lt;code&gt;my_server&lt;/code&gt; . Сообщение кодируется &lt;code&gt;erl_send()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">В следующем примере при указании уникального пути &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; только один тест. Второй возможный путь от &lt;code&gt;top2&lt;/code&gt; к &lt;code&gt;sub2X2&lt;/code&gt; (из предыдущего примера) отбрасывается:</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">В следующем примере функция &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; используется как триггер для последовательной трассировки:</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">В следующем примере строки 2,4,6,8 и 11 являются исполняемыми строками:</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">В следующем примере используются модули &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">В следующем примере BIF &lt;code&gt;self()&lt;/code&gt; возвращает pid вызывающего процесса:</target>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">В следующем примере оболочка Erlang является клиентским процессом,который получает ответы по каналу.</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">В следующем примере используется эта спецификация ASN.1:</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">В следующем примере установлены два обработчика событий для теста &lt;code&gt;my_SUITE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">В следующем примере с использованием модуля &lt;code&gt;gb_table&lt;/code&gt; из раздела &amp;laquo; &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; можно найти шесть ключей: &lt;code&gt;{1,a}&lt;/code&gt; , &lt;code&gt;{1,b}&lt;/code&gt; , &lt;code&gt;{1,c}&lt;/code&gt; , &lt;code&gt;{2,a}&lt;/code&gt; , &lt;code&gt;{2,b}&lt;/code&gt; и &lt;code&gt;{2,c}&lt;/code&gt; . Причина в том, что два элемента ключа &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; сравниваются отдельно.</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">В следующих примерах мы используем XML-файл &quot;motorcycles.xml&quot; и соответствующий DTD &quot;motorcycles.dtd.&quot;,как выглядит enginecycles.xml:</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">На следующем рисунке только отмеченный элемент декодируется &lt;code&gt;selected_decode_Window2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">На следующем рисунке в квадратных ящиках изображены руководители,а в кружках-рабочие:</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">В следующем списке флаги инициализации помечены как &amp;laquo;(флаг инициализации)&amp;raquo;. Если не указано иное, все другие флаги являются пользовательскими флагами, значения которых можно получить, вызвав &lt;code&gt;init:get_argument/1&lt;/code&gt; . Обратите внимание, что список пользовательских флагов не является исчерпывающим, может быть больше специфических для приложения флагов, которые вместо этого описаны в соответствующей документации приложения.</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">В следующих разделах описываются эти темы:</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">В следующих разделах мы как можно подробнее описали установку необходимых инструментов.Как только инструменты установлены,построить их довольно просто.Мы также постарались сделать эти инструкции понятными для людей с ограниченным опытом работы с Unix.Cygwin/MSYS/MSYS2-это совершенно новое окружение для некоторых пользователей Windows,почему тщательное объяснение переменных окружения и т.д.казалось бы,было на месте.</target>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">В следующих ситуациях вы можете легко избежать вызовов &lt;code&gt;lists:flatten/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">В следующих таблицах примеров &lt;code&gt;Data&lt;/code&gt; должны быть списком ввода-вывода. Список ввода-вывода - это двоичный или (возможно, глубокий) список двоичных файлов или целых чисел в диапазоне 0..255:</target>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">В функциях,определенных ниже,используются следующие типы:</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">В будущем функция отладки, вероятно, будет интегрирована с API потока драйвера Erlang. Все функции, которые создают объекты, принимают аргумент &lt;code&gt;name&lt;/code&gt; . В настоящее время аргумент &lt;code&gt;name&lt;/code&gt; не используется, но он будет использоваться при реализации функции отладки. Если вы правильно назовете все созданные объекты, функция отладки сможет предоставить вам более точные отчеты об ошибках.</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">В сгенерированном сценарии загрузки все каталоги приложений структурированы как &lt;code&gt;App-Vsn/ebin&lt;/code&gt; . Предполагается, что они находятся в &lt;code&gt;$ROOT/lib&lt;/code&gt; , где &lt;code&gt;$ROOT&lt;/code&gt; - корневой каталог установленной версии. Если указан параметр &lt;code&gt;local&lt;/code&gt; , вместо этого используются фактические каталоги, в которых были найдены приложения. Это полезный способ локально протестировать сгенерированный загрузочный скрипт.</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">В последнем примере модуль для анализа был задан в качестве аргумента для &lt;code&gt;m/1&lt;/code&gt; , а путь кода (неявно) использовался как &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; . В этом примере будет использоваться &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; , который позволяет анализировать приложения и выпуски, а также явно выбирать путь к библиотеке.</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">Обратите внимание, что в последней строке кортеж {256,10, -2} представляет собой действительное число 2,56 в специальной записи, которая кодируется быстрее, чем просто указание числа как &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; . Кортеж арности три - это &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; , то есть Мантисса * Основание ^ Экспонента.</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">В списках, которые разделены на две части для двух направлений (см. &lt;code&gt;cipher&lt;/code&gt; ), можно изменить оба направления одновременно:</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">В списках, которые разделены на две части для двух направлений (см. &lt;code&gt;cipher&lt;/code&gt; ), можно изменить только одно из направлений:</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">В цикле,в котором обрабатываются запросы,теперь могут быть обнаружены таймауты отправки:</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">В примере мессенджера не было сделано никаких предположений о том,что посылаемое сообщение.Это может быть любой действительный термин Эрланга.</target>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">В сообщении монитора &lt;code&gt;MonitorRef&lt;/code&gt; и &lt;code&gt;Type&lt;/code&gt; такие же, как описано ранее, и:</target>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">В нормальном случае версия создается как &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; - наиболее значимая часть.</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">При наличии начальных значений для полей,тип должен быть объявлен после инициализации следующим образом:</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">В предыдущем примере нет указания, какие протоколы ожидаются. Таким образом, у клиента нет информации о том, является ли он веб-сервером, сервером ldap или, возможно, сервером sip, к которому он подключен. В сертификате есть поля, которые могут указать это. Чтобы быть более точным, гк представляет использование в &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; в &lt;code&gt;X509v3 extensions&lt;/code&gt; поля:</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">В предыдущем примере команды &amp;laquo;ping&amp;raquo; и &amp;laquo;pong&amp;raquo; запускались из оболочек двух отдельных узлов Erlang. &lt;code&gt;spawn&lt;/code&gt; также можно использовать для запуска процессов на других узлах.</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">В предыдущем примере, если &lt;code&gt;all/0&lt;/code&gt; возвращает ссылки на названия групп в порядке &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; , порядок функций конфигурации и тестовых примеров становится следующим (обратите внимание, что &lt;code&gt;init_per_testcase/2&lt;/code&gt; и &lt;code&gt;end_per_testcase/2:&lt;/code&gt; также всегда вызываются, но не включены в этот пример для упрощения):</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">В предыдущем примере супервизор запускается вызовом &lt;code&gt;ch_sup:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">В предыдущих примерах, используются новые имена переменных, вместо повторного использования старых: &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;TheRest&lt;/code&gt; , &lt;code&gt;E1&lt;/code&gt; , &lt;code&gt;E2&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; . Причина этого в том, что переменной может быть присвоено значение только один раз в ее контексте (области действия). Подробнее об этом позже.</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">В системе времени выполнения с поддержкой SMP драйверы заблокированы либо на уровне драйвера, либо на уровне порта (уровень экземпляра драйвера). По умолчанию будет использоваться блокировка на уровне драйвера, то есть только один поток эмулятора будет выполнять код в драйвере одновременно. Если используется блокировка на уровне порта, несколько потоков эмулятора могут выполнять код в драйвере одновременно. Однако только один поток одновременно будет вызывать обратные вызовы драйвера, соответствующие одному и тому же порту. Чтобы включить блокировку на уровне порта, установите &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; ERL_DRV_FLAG_USE_PORT_LOCKING в &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; используемом драйвером. Когда используется блокировка на уровне порта, разработчик драйвера отвечает за синхронизацию всех обращений к данным, совместно используемым портами (экземплярами драйверов).</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">Во втором примере мы используем функцию обработчика трассировки по умолчанию. Этот обработчик печатает на tty, отправляя запросы ввода-вывода &lt;code&gt;user&lt;/code&gt; процессу. Когда Erlang запускается в режиме oldshell, процесс оболочки будет иметь &lt;code&gt;user&lt;/code&gt; качестве лидера группы, как и процесс трассировки в этом примере. Поскольку &lt;code&gt;user&lt;/code&gt; вызывает функции в &lt;code&gt;lists&lt;/code&gt; мы попадаем в тупик, как только будет отправлен первый запрос ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">Во второй форме вызовов функций &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; , &lt;code&gt;ExprF&lt;/code&gt; должен быть атомом или оценивать как забаву.</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">На диаграмме последовательности актеры (которые символически выполнили &lt;code&gt;Event&lt;/code&gt; ) показаны в виде вертикальных полос с именами. Порядок действий актеров можно изменить, перетащив (удерживая кнопку мыши 1 нажатой во время операции) тег имени актера в другое место:</target>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">В оболочке, если используется устройство ввода Unicode или в исходном коде, хранящемся в UTF-8, за &lt;code&gt;$&lt;/code&gt; может непосредственно следовать символ Unicode, дающий целое число. В следующем примере выводится кодовая точка кириллицы &lt;code&gt;с&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">В ситуации,когда узел потерял связи с другими узлами своей глобальной группы,но имеет связи с узлами других глобальных групп,запрос от другой глобальной группы может привести к неверному или вводящему в заблуждение результату.Например,изолированный узел может иметь неточную информацию о зарегистрированных именах в своей глобальной группе.</target>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">В целевом каталоге читает файл &lt;code&gt;releases/start_erl.data&lt;/code&gt; чтобы найти версию системы времени выполнения Erlang (&amp;laquo;5.10.4&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">В кодировке текста у исполнителей есть выбор между короткими и длинными ключевыми словами.Также можно добавлять пробелы для улучшения читабельности.Мы используем термин compact для текстовых сообщений с как можно более короткими ключевыми словами и без необязательных пробельных символов,а термин pretty для хорошо отпечатанного текстового формата с использованием длинных ключевых слов и стиля отступов,как в текстовых примерах в спецификации Megaco/H.248).</target>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">В функциях xmerl_xs вы можете предоставить вызов select (String), который является функцией &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; . Для более подробной информации см xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">В этих случаях версия ProtocolVersion по умолчанию получается из конфигурации статического соединения:</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">В этой агентской системе есть два способа динамически устанавливать информацию управления. Самый распространенный способ - загрузить MIB в агент. Другой способ - использовать субагента, который управляется приложением и может регистрироваться и отменять регистрацию. Субагент может зарегистрироваться для управления поддеревом (не путать с &lt;code&gt;erlang:register&lt;/code&gt; ). Поддерево идентифицируется идентификатором объекта. Когда субагент зарегистрирован, он получает все запросы для этого конкретного поддерева и отвечает за них. Также следует отметить, что субагент может быть запущен и остановлен в любой момент.</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">В этом вызове &lt;code&gt;[1, 1]&lt;/code&gt; - это &lt;code&gt;RowIndex&lt;/code&gt; , где ключ 1 имеет значение 1, а ключ 2 имеет значение 1, а &lt;code&gt;[3, 5]&lt;/code&gt; - это список запрошенных столбцов. Теперь функция должна возвращать лексикографически следующие элементы:</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">В этом случае он получил новый компонент &lt;code&gt;b&lt;/code&gt; . Таким образом, входящие сообщения, которые декодируются, могут иметь больше или больше компонентов, чем это.</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">В этом случае оператор &lt;code&gt;ct_hooks&lt;/code&gt; в наборе тестов может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">В этом случае конфигурационный файл должен содержать,по крайней мере,данные:</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">В этом случае фильтр применяется ко всем возможным парам ответов на вопросы &lt;code&gt;QH1&lt;/code&gt; и &lt;code&gt;QH2&lt;/code&gt; , по одному. Если есть M ответов на &lt;code&gt;QH1&lt;/code&gt; и N ответов на &lt;code&gt;QH2&lt;/code&gt; , фильтр запускается M * N раз.</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">В этом случае &lt;code&gt;CTH&lt;/code&gt; может быть либо только именем модуля CTH, либо кортежем с именем модуля и начальными аргументами, а также необязательно приоритетом ловушки CTH. Например, одно из следующих:</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">В этом случае можно использовать параметр компилятора &lt;code&gt;encrypt_debug_info&lt;/code&gt; , см. Compile &lt;code&gt;compile(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">В этом случае все аргументы, кроме первого, игнорируются, и функция просто снова возвращает внутреннее состояние. Этого достаточно, если только код был расширен. Если вместо этого внутреннее состояние изменяется (аналогично примеру в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; ), это делается в этой функции и возвращается &lt;code&gt;{ok,Chs2}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">В этом случае одно или несколько &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; могут быть несвязанными переменными.</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">В этом случае простой замены кода недостаточно. Процесс должен явно преобразовать свое состояние с помощью функции обратного вызова &lt;code&gt;code_change&lt;/code&gt; перед переключением на новую версию модуля обратного вызова. Таким образом, используется синхронизированная замена кода.</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">В этом случае простой замены кода недостаточно.При загрузке новой версии резидентного модуля для специального процесса процесс должен полностью квалифицированно обратиться к своей функции цикла,чтобы переключиться на новый код.Таким образом,должна использоваться синхронизированная замена кода.</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">В этом случае процесс вызова является оболочкой,поэтому будет получен следующий результат:</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">В этом случае функция должна быть экспортирована из данного модуля.</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">В этом случае возвращается ключ &lt;code&gt;Key&lt;/code&gt; , который можно использовать в последующем вызове &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; для получения значения оценки &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; на узле &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">В этом случае новое состояние - это обновленный список доступных каналов &lt;code&gt;Chs2&lt;/code&gt; . &lt;code&gt;gen_server&lt;/code&gt; теперь готов к новым запросам.</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">В этом случае можно использовать платформу обработчика выпуска с автоматической упаковкой и распаковкой пакетов выпуска, автоматическим обновлением пути и т. Д. Без указания файлов &lt;code&gt;.appup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">В этом случае ответ - это выделенный канал &lt;code&gt;Ch&lt;/code&gt; , а новое состояние - это набор оставшихся доступных каналов &lt;code&gt;Chs2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">В этом случае супервайзер не регистрируется. Вместо этого должен использоваться его pid. Имя можно указать, вызвав &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; или &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">В этом случае вы освобождаете два термина независимо друг от друга. Порядок, в котором вы освобождаете термины &lt;code&gt;ep&lt;/code&gt; и &lt;code&gt;ep2&lt;/code&gt; , не важен, потому что библиотека &lt;code&gt;Erl_Interface&lt;/code&gt; использует подсчет ссылок, чтобы определить, когда безопасно удалять объекты.</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">В этом примере рассмотрим ситуацию,когда вы хотите изучить определенные данные в XML-файле.Например,вы хотите проверить,как долго каждый мотоцикл был записан.</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">В данном примере приложение Pea было изменено,как и приложения ERTS,Kernel,STDLIB и SASL.</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">В этом примере числа являются целыми числами, а аргументы функций в коде &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; и &lt;code&gt;Y&lt;/code&gt; называются переменными. Переменные должны начинаться с заглавной буквы (см. &lt;code&gt;Variables&lt;/code&gt; ). Примеры переменных: &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;ShoeSize&lt;/code&gt; и &lt;code&gt;Age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">В этом примере вы просматриваете список, &quot;несущий&quot; значение, в данном случае &lt;code&gt;Result_so_far&lt;/code&gt; . &lt;code&gt;list_max/1&lt;/code&gt; просто предполагает, что максимальное значение списка является &lt;code&gt;list_max/2&lt;/code&gt; списка, и вызывает list_max / 2 с остальной частью списка и значением заголовка списка. В приведенном выше &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; это будет list_max ([2,3,4,5,7,4,3,2,1], 1) . Если вы попытаетесь использовать &lt;code&gt;list_max/1&lt;/code&gt; с пустым списком или попытаетесь использовать его с чем-то, что вообще не является списком, вы вызовете ошибку. Обратите внимание, что философия Erlang заключается не в том, чтобы обрабатывать ошибки этого типа в той функции, которую они вызывают, а в том, чтобы делать это в другом месте. Подробнее об этом позже.</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">В этом примере &lt;code&gt;suite/0&lt;/code&gt; сообщает &lt;code&gt;Common Test&lt;/code&gt; запретить распечатку из соединений Telnet и SSH. Это верно для всех тестовых случаев. Однако &lt;code&gt;my_testcase1/0&lt;/code&gt; указывает, что для этого тестового примера молчать должен только SSH. В результате &lt;code&gt;my_testcase1&lt;/code&gt; получает информацию Telnet (если есть), напечатанную в журнале, но не информацию SSH. &lt;code&gt;my_testcase2&lt;/code&gt; не получает информации ни от одного напечатанного соединения.</target>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">В этом примере получено &lt;code&gt;{Pid, Something}&lt;/code&gt; . Полученный pid затем используется для возврата &lt;code&gt;{goodbye,Pid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">В этом примере от внешнего источника принимается серия байтов, а затем байты декодируются в действительный термин Эрланга. Это было достигнуто с помощью вызова &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; , который вернул значение Erlang типа &lt;code&gt;Person&lt;/code&gt; ASN.1 . Затем был построен и закодирован ответ с использованием &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; , который берет экземпляр определенного типа ASN.1 и преобразует его в двоичный файл в соответствии с правилами кодирования BER или PER.</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">В этом примере модуль трассировки с серверной частью NIF отправляет сообщение для каждого тега трассировки &lt;code&gt;send&lt;/code&gt; содержащего только отправителя и получателя. При использовании этого модуля трассировки используется гораздо более легкий трассировщик сообщений, который записывает только, кто кому отправил сообщения.</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">В этом примере система времени выполнения Erlang запускается с переменной среды &lt;code&gt;DISPLAY&lt;/code&gt; , установленной на &lt;code&gt;gin:0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">В этом примере была сделана попытка вывести одиночный символ 65 с помощью директивы форматирования строки &lt;code&gt;&quot;~s&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">В данном примере любой пользовательский тег,заданный в процессе вызова,будет распространен на I/O-сервер при выполнении вызова в формате io:format.</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">В этом примере,каждая исполнительная система имеет по два планировщика в режиме онлайн,и все планировщики в режиме онлайн будут работать на разных ядрах.Если мы переходим на один планировщик онлайн на одной системе выполнения,и три планировщика онлайн на другом,все планировщики онлайн все равно будет работать на разных ядрах.</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">В этом примере функция &lt;code&gt;terminate/3&lt;/code&gt; блокирует дверь, если она открыта, поэтому мы случайно не оставим дверь открытой, когда дерево надзора завершится:</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">В этом примере, если первый элемент был ключом, гораздо эффективнее сопоставить этот ключ в части &lt;code&gt;MatchHead&lt;/code&gt; , чем в части &lt;code&gt;MatchConditions&lt;/code&gt; . Пространство поиска таблиц ограничено в отношении &lt;code&gt;MatchHead&lt;/code&gt; , поэтому поиск выполняется только по объектам с совпадающим ключом.</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">В этом примере вместо того, чтобы игнорировать события кнопок в &lt;code&gt;open&lt;/code&gt; состоянии, мы можем отложить их, и они будут поставлены в очередь, а затем обработаны в &lt;code&gt;locked&lt;/code&gt; состоянии:</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">В данном примере выполняются следующие действия:</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">В этом примере используется та же спецификация ASN.1, что и в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; . Ниже приведена действительная инструкция выборочного декодирования:</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">В этом примере тестовые термины,определенные в файлах &quot;b.spec&quot; и &quot;c.spec&quot;,объединены с терминами в исходной спецификации &quot;a.spec&quot; (если таковая имеется).Включение спецификаций &quot;d.spec&quot; и &quot;e.spec&quot; приводит к двум отдельным и независимым прогонам тестов (по одному для каждой включенной спецификации).</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">В этом примере мы решили скопировать двоичный контент перед тем, как вставить его в &lt;code&gt;gb_sets:set()&lt;/code&gt; если он ссылается на двоичный файл, размер данных, который мы хотим сохранить, более чем в два раза превышает размер. Конечно, при копировании в разные программы действуют разные правила.</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">В этом примере мы помещаем &amp;laquo;diffie-hellman-group1-sha1&amp;raquo; первым, а также перемещаем &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; в конец списка kex, то есть &lt;code&gt;append&lt;/code&gt; его.</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">В этом примере мы используем оба варианта ( &lt;code&gt;preferred_algorithms&lt;/code&gt; и &lt;code&gt;modify_algorithms&lt;/code&gt; ), а также пытаемся добавить неподдерживаемый алгоритм. Любой неподдерживаемый алгоритм незаметно удаляется.</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">В этих примерах используются определения из следующей спецификации ASN.1:</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">В следующем примере пароль - &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">В этом режиме можно сделать следующее:</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">В этом модуле V может быть пустым. Полученный таким образом уникальный орграф называется &lt;strong id=&quot;empty_digraph&quot;&gt;пустым орграфом&lt;/strong&gt; . И вершины, и ребра представлены уникальными терминами Эрланга.</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">В данном модуле рассматриваются только семейства подмножеств некоторого множества X,далее для таких семейств подмножеств используется слово &quot;семейство&quot;.</target>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">В этом конкретном случае нам не нужно отменять тайм-аут, так как событие тайм-аута является единственной возможной причиной изменения состояния с &lt;code&gt;open&lt;/code&gt; на &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">В этом конкретном случае команда &lt;code&gt;i&lt;/code&gt; (&amp;laquo;прерывание&amp;raquo;) завершает программу цикла, а команда &lt;code&gt;c&lt;/code&gt; снова подключается к оболочке. Поскольку до того, как мы его убили, процесс работал в фоновом режиме, перед отображением сообщения &amp;laquo; &lt;code&gt;** exception exit: killed&lt;/code&gt; завершено&amp;raquo; выполняется больше распечаток .</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">В этом сценарии блокировка, которая защищает ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; , потратила большую часть своего ожидания. Это 1,8 секунды в 60-секундном тесте. Время также распределяется по восьми различным потокам планировщика.</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">В этом разделе поле &lt;code&gt;Domain&lt;/code&gt; является транспортным доменом, то есть одним из &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; или &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; , а поле &lt;code&gt;Addr&lt;/code&gt; - это кортеж &lt;code&gt;{&lt;/code&gt; IpAddr &lt;code&gt;,IpPort}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">В этом разделе поле &lt;code&gt;Address&lt;/code&gt; представляет собой кортеж &lt;code&gt;{Domain, Addr}&lt;/code&gt; где &lt;code&gt;Domain&lt;/code&gt; - это &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; или &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; , а &lt;code&gt;Addr&lt;/code&gt; - это &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; IpAddr &lt;code&gt;,IpPort}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">В этом разделе перечислены все допустимые выражения Erlang.При написании программ на Erlang также разрешается использовать макро-и записывающие выражения.Однако при компиляции эти выражения расширяются и в этом смысле не являются истинными выражениями Erlang.Выражения макросов и записей рассматриваются в отдельных разделах:</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">В этом разделе предполагается, что имя пользователя - &lt;code&gt;otpuser&lt;/code&gt; , а домашний каталог этого пользователя:</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">В этом разделе используется следующая терминология:</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">В этом простом случае первое выражение,вероятно,предпочтительнее с точки зрения читабельности.</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">Таким образом, вы можете соединить все процессы в транзакции вместе с помощью ссылок. Если один из процессов завершается ненормально, все процессы в транзакции прекращаются. Поскольку часто требуется создать процесс и связать с ним одновременно, существует специальный BIF, &lt;code&gt;spawn_link&lt;/code&gt; , который делает то же самое, что и &lt;code&gt;spawn&lt;/code&gt; , но также создает ссылку на порожденный процесс.</target>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">В традиционной терминологии реляционной базы данных эта операция называется выделением,за которым следует проекция.</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">В типе &lt;code&gt;StartMessage&lt;/code&gt; ограничение, следующее за &lt;code&gt;content&lt;/code&gt; поля, сообщает, что в значении типа &lt;code&gt;StartMessage&lt;/code&gt; значение в &lt;code&gt;content&lt;/code&gt; поля должно происходить из того же объекта, который выбран полем &lt;code&gt;msgId&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В версии 3 стандарта megaco был представлен пакет сегментации. Просто этот пакет определяет процедуру сегментирования мегасообщения (ответов транзакций) при использовании транспорта, который не делает этого автоматически (например, UDP). См. Также &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">В какой версии OTP было представлено &lt;code&gt;kernel-3.0&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">В вашей собственной функции обработчика трассировки вызовите &lt;code&gt;erlang:display/1&lt;/code&gt; вместо функции &lt;code&gt;io&lt;/code&gt; или, если &lt;code&gt;user&lt;/code&gt; не используется в качестве лидера группы, напечатайте &lt;code&gt;user&lt;/code&gt; вместо лидера группы по умолчанию. Пример: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">Внутриполосная безопасность-ID AVP</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">Inband-Security-Id AVP (код 299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">Inband-Security-Id по умолчанию равен пустому списку,который эквивалентен списку,содержащему только 0 (NO_INBAND_SECURITY).Если указано 1 (TLS),то TLS выбирается в том случае,если CER/CEA,полученный от коллеги,предлагает его.</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">Входящая двоичная кодировка в двоичных файлах</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">Входящее процентное кодирование в списках и двоичных файлах</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">Между прочим, когда тестовый пример исправлен, действительно должна быть обнаружена ошибка в &lt;code&gt;channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">Включите &lt;code&gt;dir&lt;/code&gt; в путь для Erlang. Это полезно при анализе файлов с директивами &lt;code&gt;-include_lib()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Каталоги Include также можно указать в спецификациях тестов, см. &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">Включить файл</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">Включаемые файлы обычно используются для определений записей и макросов, которые совместно используются несколькими модулями. Для включаемых файлов рекомендуется использовать расширение имени файла &lt;code&gt;.hrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">Включите текст токена в аннотацию к токену.Текст-это часть ввода,соответствующая токену.</target>
        </trans-unit>
        <trans-unit id="1318cfcd94087f09bec8c0a46a0ba00bc818ff6b" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return value(s).</source>
          <target state="translated">Включить предупреждения для вызовов функций,которые игнорируют структурированное возвращаемое значение или не совпадают с одним из многих возможных возвращаемых значений.</target>
        </trans-unit>
        <trans-unit id="787b1e3adc3eb7a1d5a6e75a6a8e36064a54f61d" translate="yes" xml:space="preserve">
          <source>Include warnings for functions that only return by an exception.</source>
          <target state="translated">Включать предупреждения для функций,которые возвращаются только в виде исключения.</target>
        </trans-unit>
        <trans-unit id="c9c702014dc9102936a21eccc903c8d6fd60705b" translate="yes" xml:space="preserve">
          <source>Include warnings for possible race conditions. Notice that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk.</source>
          <target state="translated">Включите предупреждения о возможных гоночных условиях.Обратите внимание,что анализ,который находит гонки,выполняет внутрипроцедурный анализ потока данных и иногда может взорваться вовремя.Включите его на свой страх и риск.</target>
        </trans-unit>
        <trans-unit id="c2da810ae50606f552a617f96c162b1a8a5cbb8d" translate="yes" xml:space="preserve">
          <source>Included test messages</source>
          <target state="translated">Включенные тестовые сообщения</target>
        </trans-unit>
        <trans-unit id="d01cc8205d9d2d88536ce346d12fc476f915ab3e" translate="yes" xml:space="preserve">
          <source>Includes a section containing call statistics for all calls regardless of process, in the analysis.</source>
          <target state="translated">Включает в анализ раздел,содержащий статистику вызовов для всех вызовов,независимо от процесса.</target>
        </trans-unit>
        <trans-unit id="529e9b923d0287eecd76a416e52d97fdc8ea0d45" translate="yes" xml:space="preserve">
          <source>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;.</source>
          <target state="translated">Включает отметку времени во все сообщения трассировки. Отметка времени (Ts) имеет ту же форму, что и возвращаемая &lt;code&gt;erlang:now()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21580f3961c21f1aceb751d4061a09b3a76955d6" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">Включает &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; во все сообщения трассировки. Отметка времени (Ts) имеет тот же формат и значение, что и &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; . Этот флаг переопределяет флаг &lt;code&gt;cpu_timestamp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7123f161553e4dd460e1a837d1a70b743db16fa4" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">Включает метку времени, состоящую из &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; и монотонно увеличивающегося целого числа во все сообщения трассировки. Отметка времени (Ts) имеет тот же формат и значение, что и производные &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; erlang: unique_integer ([monotonic]) &lt;code&gt;}&lt;/code&gt; . Этот флаг переопределяет флаг &lt;code&gt;cpu_timestamp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59a53faa5ece992bf6eb22ad8651276afec5c122" translate="yes" xml:space="preserve">
          <source>Includes custom debug information in the form of a &lt;code&gt;Backend&lt;/code&gt; module with custom &lt;code&gt;Data&lt;/code&gt; in the compiled beam module. The given module must implement a &lt;code&gt;debug_info/4&lt;/code&gt; function and is responsible for generating different code representations, as described in the &lt;code&gt;debug_info&lt;/code&gt; under &lt;code&gt;beam_lib(3)&lt;/code&gt;.</source>
          <target state="translated">Включает настраиваемую отладочную информацию в виде модуля &lt;code&gt;Backend&lt;/code&gt; с настраиваемыми &lt;code&gt;Data&lt;/code&gt; в скомпилированный модуль луча. Данный модуль должен реализовывать функцию &lt;code&gt;debug_info/4&lt;/code&gt; и отвечать за создание различных представлений кода, как описано в &lt;code&gt;debug_info&lt;/code&gt; в разделе &lt;code&gt;beam_lib(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b72745ef15f97e2eed8ddb85c88ed3745778131f" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt;Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">Включает отладочную информацию в форме &lt;code&gt;Erlang Abstract Format&lt;/code&gt; в блок &lt;code&gt;debug_info&lt;/code&gt; скомпилированного модуля луча. Такие инструменты, как Debugger, Xref и Cover, требуют включения отладочной информации.</target>
        </trans-unit>
        <trans-unit id="50ee9bd2b0973e0a8782664b4e20754ea8733fba" translate="yes" xml:space="preserve">
          <source>Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option &lt;code&gt;debug_info&lt;/code&gt; as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code.</source>
          <target state="translated">Включает отладочную информацию, но шифрует ее, поэтому к ней нельзя получить доступ без предоставления ключа. (Предоставление опции &lt;code&gt;debug_info&lt;/code&gt; также разрешено, но не обязательно.) Использование этой опции - хороший способ всегда иметь доступную отладочную информацию во время тестирования, при этом защищая исходный код.</target>
        </trans-unit>
        <trans-unit id="805a2af44ca1e2b71562d035c3b42720d4a88944" translate="yes" xml:space="preserve">
          <source>Includes property &lt;code&gt;{role, client | server}&lt;/code&gt;. Currently this is the only predefined property, there can also be user-defined properties. See also application environment variable &lt;code&gt;session_cb_init_args&lt;/code&gt;.</source>
          <target state="translated">Включает свойство &lt;code&gt;{role, client | server}&lt;/code&gt; . В настоящее время это единственное предопределенное свойство, также могут быть свойства, определяемые пользователем. См. Также переменную среды приложения &lt;code&gt;session_cb_init_args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7705cf570e0db2364f0a8b0f968c2b052243e5be" translate="yes" xml:space="preserve">
          <source>Incoming Connections</source>
          <target state="translated">Входящие соединения</target>
        </trans-unit>
        <trans-unit id="cfffe82b107254cee4127c092afe584c0200b55a" translate="yes" xml:space="preserve">
          <source>Incoming Diameter messages are decoded from binary() before being communicated to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; module for transmission. The functions documented here implement the default encode/decode.</source>
          <target state="translated">Входящие сообщения Diameter декодируются с помощью функции binary () перед передачей в функции обратного вызова Diameter_app &lt;code&gt;diameter_app(3)&lt;/code&gt; . Точно так же исходящие сообщения Diameter кодируются в binary () перед передачей в соответствующий модуль Diameter_transport &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; для передачи. Задокументированные здесь функции реализуют кодирование / декодирование по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c632222fe59d6393835f1d6b41daa8dcbb54dc28" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and normally decoded successfully. But if the decoding failed this function is called in order to decide if the originator should get a reply message (reply) or if the reply silently should be discarded (no_reply).</source>
          <target state="translated">Входящие сообщения доставляются megaco:receive_message/4 и обычно успешно декодируются.Однако,если декодирование прошло неудачно,эта функция вызывается для того,чтобы решить,должен ли отправитель получить ответное сообщение (ответ),или же ответ должен быть беззвучно отменен (no_reply).</target>
        </trans-unit>
        <trans-unit id="bbb9b00cfc07d6474962cea0fb79594d0c7f33f6" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions and this function is invoked for each TransactionRequest in the message.</source>
          <target state="translated">Входящие сообщения доставляются megaco:receive_message/4 и успешно декодируются.Обычно сообщение содержит список транзакций,и эта функция вызывается для каждого TransactionRequest в сообщении.</target>
        </trans-unit>
        <trans-unit id="7d2155d7b153e6ddad7244575ab829476e447287" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions, but it may instead contain an ErrorDescriptor on top level of the message.</source>
          <target state="translated">Входящие сообщения доставляются megaco:receive_message/4 и успешно декодируются.Обычно сообщение содержит список транзакций,но вместо этого может содержать ErrorDescriptor на верхнем уровне сообщения.</target>
        </trans-unit>
        <trans-unit id="793c36e1e4e2e9196eba0419d11fe32cd2342b1a" translate="yes" xml:space="preserve">
          <source>Incompatible changes may occur between releases.</source>
          <target state="translated">Между выпусками могут происходить несовместимые изменения.</target>
        </trans-unit>
        <trans-unit id="f5e211548a14ccbf061765bad659c7e963fece50" translate="yes" xml:space="preserve">
          <source>Inconsistent stream state.</source>
          <target state="translated">Непоследовательное состояние потока.</target>
        </trans-unit>
        <trans-unit id="f91465c3f77f3d3269bf0de89bd0e5136eadf0ec" translate="yes" xml:space="preserve">
          <source>Incorrect UTF encoding.</source>
          <target state="translated">Неправильная кодировка UTF.</target>
        </trans-unit>
        <trans-unit id="1d24ce4d50ea5331d982cda5d863bb706d720600" translate="yes" xml:space="preserve">
          <source>Increases the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</source>
          <target state="translated">Увеличивает счетчик приостановки для процесса, идентифицированного &lt;code&gt;Suspendee&lt;/code&gt; и переводит его в приостановленное состояние, если он еще не находится в этом состоянии. Приостановленный процесс не планируется к выполнению, пока процесс не будет возобновлен.</target>
        </trans-unit>
        <trans-unit id="c1ce75ee57dec21e5d02eb0055b76a4460422603" translate="yes" xml:space="preserve">
          <source>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</source>
          <target state="translated">Увеличивается, когда в систему времени выполнения Erlang вносятся несовместимые с библиотекой NIF изменения. Обычно достаточно перекомпилировать библиотеку NIF при изменении &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; , но в редких случаях это может означать, что библиотеки NIF должны быть немного изменены. Если так, то это, конечно, будет задокументировано.</target>
        </trans-unit>
        <trans-unit id="84678a3e577756daefc285cd45b2bc2e297ad5ec" translate="yes" xml:space="preserve">
          <source>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</source>
          <target state="translated">Увеличивается при добавлении новых функций.Система исполнения использует младшую версию для определения того,какие функции использовать.</target>
        </trans-unit>
        <trans-unit id="57135dbc3bf5f91f10354efacc0f552c2d6e0f14" translate="yes" xml:space="preserve">
          <source>Increments a variable in the MIB with &lt;code&gt;N&lt;/code&gt;, or one if &lt;code&gt;N&lt;/code&gt; is not specified.</source>
          <target state="translated">Увеличивает переменную в MIB на &lt;code&gt;N&lt;/code&gt; или на единицу, если &lt;code&gt;N&lt;/code&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="9c9e63796462f25fa87f2866f5f82ef633d51dee" translate="yes" xml:space="preserve">
          <source>Increments map iterator to point to the next key-value entry.</source>
          <target state="translated">Увеличение итератора карты для указания на следующий ввод значения ключа.</target>
        </trans-unit>
        <trans-unit id="8f239c48f8608dfc7dad0cea2bfd35ef11b36366" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">Увеличивает счетчик ссылок для блокировки данных порта, переданной в качестве аргумента ( &lt;code&gt;pdl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d877566e1bec90ff2d29720de068fd3d3fddd99b" translate="yes" xml:space="preserve">
          <source>Increments the reference count on &lt;code&gt;bin&lt;/code&gt; and returns the reference count reached after the increment.</source>
          <target state="translated">Увеличивает счетчик ссылок в &lt;code&gt;bin&lt;/code&gt; и возвращает счетчик ссылок, достигнутый после увеличения.</target>
        </trans-unit>
        <trans-unit id="6885d93d080432a665a8c21adf295eb79d2e88f7" translate="yes" xml:space="preserve">
          <source>Increments the variable associated with a discarded pdu. This function can be used when the net_if process receives a &lt;code&gt;discarded_pdu&lt;/code&gt; message from the agent.</source>
          <target state="translated">Увеличивает переменную, связанную с отброшенным pdu. Эта функция может быть использована , когда net_if процесс получает &lt;code&gt;discarded_pdu&lt;/code&gt; сообщения от агента.</target>
        </trans-unit>
        <trans-unit id="a1dc8ae1f28e23fc7131a69f785c7a7e4f9ac70d" translate="yes" xml:space="preserve">
          <source>Indents a document a number of character positions to the right. Note that &lt;code&gt;N&lt;/code&gt; may be negative, shifting the text to the left, or zero, in which case &lt;code&gt;D&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">Отступает в документе на несколько позиций вправо. Обратите внимание, что &lt;code&gt;N&lt;/code&gt; может быть отрицательным, сдвигая текст влево, или нулем, и в этом случае &lt;code&gt;D&lt;/code&gt; возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="b03e59c23d6f82c97ce8cf0f7790602979c8e4da" translate="yes" xml:space="preserve">
          <source>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</source>
          <target state="translated">Индексы приходят не бесплатно.Они занимают пространство,пропорциональное размеру таблицы,и заставляют вставки в таблицу выполняться немного медленнее.</target>
        </trans-unit>
        <trans-unit id="66f3ae8a6cbff45c5e61fef46e620b30441f2993" translate="yes" xml:space="preserve">
          <source>Indexes in a table must be objects, not types (deviates from SMIv1 only).</source>
          <target state="translated">Индексы в таблице должны быть объектами,а не типами (отличается только от SMIv1).</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="295bcf395f6ba1c793b51510dd315c49a1cd7e27" translate="yes" xml:space="preserve">
          <source>Indicates a broken link. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes.</source>
          <target state="translated">Указывает на неработающую ссылку. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; и &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; содержат идентификаторы связанных процессов.</target>
        </trans-unit>
        <trans-unit id="6278f3e704c53d6a2b0b2b9ee6bea9f7e00a82d7" translate="yes" xml:space="preserve">
          <source>Indicates a customized prologue file which the user may want to use instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; which is otherwise included at the beginning of the resulting parser file. &lt;strong&gt;N.B.&lt;/strong&gt; The &lt;code&gt;Includefile&lt;/code&gt; is included 'as is' in the parser file, so it must not have a module declaration of its own, and it should not be compiled. It must, however, contain the necessary export declarations. The default is indicated by &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Указывает настроенный файл пролога, который пользователь может захотеть использовать вместо файла по умолчанию &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; , который в противном случае включается в начало результирующего файла анализатора. &lt;strong&gt;NB&lt;/strong&gt; . &lt;code&gt;Includefile&lt;/code&gt; включается в файл анализатора &amp;laquo;как есть&amp;raquo;, поэтому он не должен иметь собственного объявления модуля, и его не следует компилировать. Однако он должен содержать необходимые экспортные декларации. Значение по умолчанию обозначено &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7baca088d4a47e1b532691a75a666d58750c6872" translate="yes" xml:space="preserve">
          <source>Indicates change of the status of the IP address of the peer specified by &lt;code&gt;addr&lt;/code&gt; within association &lt;code&gt;assoc_id&lt;/code&gt;. Possible values of &lt;code&gt;state&lt;/code&gt; (mostly self-explanatory) include:</source>
          <target state="translated">Указывает на изменение статуса IP-адреса однорангового узла, указанного в &lt;code&gt;addr&lt;/code&gt; в ассоциации &lt;code&gt;assoc_id&lt;/code&gt; . Возможные значения &lt;code&gt;state&lt;/code&gt; (в основном не требующие пояснений) включают:</target>
        </trans-unit>
        <trans-unit id="c1e223ab1bee245ce8340356f73b51f2137316ba" translate="yes" xml:space="preserve">
          <source>Indicates character range</source>
          <target state="translated">Показывает диапазон символов</target>
        </trans-unit>
        <trans-unit id="ac69dafa8c067eb5122ac56c8384ac8f712d4875" translate="yes" xml:space="preserve">
          <source>Indicates if all application code paths are to be updated (&lt;code&gt;Bool==true&lt;/code&gt;) or if only code paths for modified applications are to be updated (&lt;code&gt;Bool==false&lt;/code&gt;, default). This option has only effect for other application directories than the default &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt;, that is, application directories specified in argument &lt;code&gt;AppDirs&lt;/code&gt; in a call to &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Указывает, должны ли обновляться все пути кода приложения ( &lt;code&gt;Bool==true&lt;/code&gt; ) или должны обновляться только пути кода для измененных приложений ( &lt;code&gt;Bool==false&lt;/code&gt; , по умолчанию). Этот параметр действует только для других каталогов приложений, кроме каталога по умолчанию &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt; , то есть для каталогов приложений, указанных в аргументе &lt;code&gt;AppDirs&lt;/code&gt; при вызове &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d1928864135bba9ca1e5db7c9ed5c9e48fe306d" translate="yes" xml:space="preserve">
          <source>Indicates if process information is to be collected. If &lt;code&gt;PI = true&lt;/code&gt; (which is default), each process identifier &lt;code&gt;Pid&lt;/code&gt; is replaced by a tuple &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt;, where &lt;code&gt;ProcessInfo&lt;/code&gt; is the registered process name, its globally registered name, or its initial function. To turn off this functionality, set &lt;code&gt;PI = false&lt;/code&gt;.</source>
          <target state="translated">Указывает, нужно ли собирать информацию о процессе. Если &lt;code&gt;PI = true&lt;/code&gt; (по умолчанию), каждый идентификатор процесса &lt;code&gt;Pid&lt;/code&gt; заменяется кортежем &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt; , где &lt;code&gt;ProcessInfo&lt;/code&gt; - это зарегистрированное имя процесса, его глобально зарегистрированное имя или его начальная функция. Чтобы отключить эту функцию, установите &lt;code&gt;PI = false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b164f888f879044385341ec2797d6c82e6c4e946" translate="yes" xml:space="preserve">
          <source>Indicates if the table is compressed.</source>
          <target state="translated">Показывает,что таблица сжата.</target>
        </trans-unit>
        <trans-unit id="04ae54ea063d09f2c3664e4b4c23adf6f54a8c52" translate="yes" xml:space="preserve">
          <source>Indicates if the table is fixed by any process.</source>
          <target state="translated">Показывает,зафиксирована ли таблица каким-либо процессом.</target>
        </trans-unit>
        <trans-unit id="aa89b00792f2ce063403297cd8b1e138fe770604" translate="yes" xml:space="preserve">
          <source>Indicates if the table is named.</source>
          <target state="translated">Указывает,названа ли таблица.</target>
        </trans-unit>
        <trans-unit id="cf35be555e3459fa6b5edfb9108dbeacc82f59eb" translate="yes" xml:space="preserve">
          <source>Indicates in which phase the child terminated from the supervisor's point of view. This can be &lt;code&gt;start_error&lt;/code&gt;, &lt;code&gt;child_terminated&lt;/code&gt;, or &lt;code&gt;shutdown_error&lt;/code&gt;.</source>
          <target state="translated">Указывает, на каком этапе дочерний процесс завершился с точки зрения супервизора. Это может быть &lt;code&gt;start_error&lt;/code&gt; , &lt;code&gt;child_terminated&lt;/code&gt; или &lt;code&gt;shutdown_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe81303e088259aab453750cd52960b57072562a" translate="yes" xml:space="preserve">
          <source>Indicates that all modules that &lt;strong&gt;must&lt;/strong&gt; be loaded &lt;strong&gt;before&lt;/strong&gt; any processes are started are loaded. In interactive mode, all &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; commands interpreted after this command are ignored, and these modules are loaded on demand. In embedded mode, &lt;code&gt;kernel_load_completed&lt;/code&gt; is ignored, and all modules are loaded during system start.</source>
          <target state="translated">Указывает, что загружены все модули, которые &lt;strong&gt;должны&lt;/strong&gt; быть загружены &lt;strong&gt;перед&lt;/strong&gt; запуском каких-либо процессов. В интерактивном режиме все команды &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; , интерпретируемые после этой команды, игнорируются, и эти модули загружаются по запросу. Во встроенном режиме &lt;code&gt;kernel_load_completed&lt;/code&gt; игнорируется, и все модули загружаются во время запуска системы.</target>
        </trans-unit>
        <trans-unit id="1f9048661a24ae25a077ce5abbcac108d3320208" translate="yes" xml:space="preserve">
          <source>Indicates that an ordinary send operation has occurred. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient (the C-node).</source>
          <target state="translated">Указывает, что произошла обычная операция отправки. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; содержит pid получателя (C-узел).</target>
        </trans-unit>
        <trans-unit id="cbcba1ae27045d37f3db86e74369cc4a7aceb7a1" translate="yes" xml:space="preserve">
          <source>Indicates that no more data is to be sent.</source>
          <target state="translated">Указывает на то,что больше не нужно отправлять данные.</target>
        </trans-unit>
        <trans-unit id="8bf849b9fec9e1760cea1c2d5389817b3c0bc05b" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;ssh_client_channel&lt;/code&gt; started for the execution of the command has now been shut down.</source>
          <target state="translated">Указывает, что &lt;code&gt;ssh_client_channel&lt;/code&gt; , запущенный для выполнения команды, теперь отключен.</target>
        </trans-unit>
        <trans-unit id="a5828edbce1099ee1930a44aab4d8fd37ec11d89" translate="yes" xml:space="preserve">
          <source>Indicates that the client is to try to perform Next Protocol Negotiation.</source>
          <target state="translated">Указывает на то,что клиент должен попытаться выполнить Next Protocol Negotiation (Следующее переговоры по протоколу).</target>
        </trans-unit>
        <trans-unit id="1b5dd8bc7ce080d99125903fe8b90315e92ea02c" translate="yes" xml:space="preserve">
          <source>Indicates that the function must return if the Telnet client is idle (that is, if no data is received) for more than &lt;code&gt;IdleTimeout&lt;/code&gt; milliseconds. Default time-out is 10 seconds.</source>
          <target state="translated">Указывает, что функция должна возвращаться, если клиент Telnet бездействует (то есть, если данные не получены) более &lt;code&gt;IdleTimeout&lt;/code&gt; миллисекунд. Тайм-аут по умолчанию составляет 10 секунд.</target>
        </trans-unit>
        <trans-unit id="9e67f2121ae2256f3ebfae7320f2bc6126d35396" translate="yes" xml:space="preserve">
          <source>Indicates that the logs are not to be merged according to time-stamp, but processed one file after another (this can be a bit faster).</source>
          <target state="translated">Указывает,что журналы не нужно объединять по временной метке,а нужно обрабатывать один файл за другим (это может быть немного быстрее).</target>
        </trans-unit>
        <trans-unit id="b9a42fd50ec01a86c14c261f603beda5c60f5a57" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Указывает, что другая сторона больше не отправляет данные. Это событие отправляется в результате вызова &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8b1ea4428cfedc7e1254d4ff25775923613c69" translate="yes" xml:space="preserve">
          <source>Indicates that the trace is to be automatically stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds. &lt;code&gt;StopOpts&lt;/code&gt; are passed to command &lt;code&gt;ttb:stop/2&lt;/code&gt; if specified (default is &lt;code&gt;[]&lt;/code&gt;). Notice that the timing is approximate, as delays related to network communication are always present. The timer starts after &lt;code&gt;ttb:p/2&lt;/code&gt; is issued, so you can set up your trace patterns before.</source>
          <target state="translated">Указывает, что трассировка должна быть автоматически остановлена ​​через &lt;code&gt;MSec&lt;/code&gt; миллисекунд. &lt;code&gt;StopOpts&lt;/code&gt; передаются команде &lt;code&gt;ttb:stop/2&lt;/code&gt; , если указано (по умолчанию &lt;code&gt;[]&lt;/code&gt; ). Обратите внимание, что время является приблизительным, поскольку всегда присутствуют задержки, связанные с сетевым обменом. Таймер запускается после &lt;code&gt;ttb:p/2&lt;/code&gt; , поэтому вы можете настроить шаблоны трассировки раньше.</target>
        </trans-unit>
        <trans-unit id="ad9cf951fb07996703ea5f15911991b7ead2c767" translate="yes" xml:space="preserve">
          <source>Indicates that there is sufficient input data to get a result. &lt;code&gt;Result&lt;/code&gt; is:</source>
          <target state="translated">Указывает, что имеется достаточно входных данных для получения результата. &lt;code&gt;Result&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce31dc16108b768360d358241497a298269b4a82" translate="yes" xml:space="preserve">
          <source>Indicates that this call removed the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; from the driver, but there are still open ports using it. When all ports are closed and no new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have arrived, the driver is reloaded and the name and memory reclaimed.</source>
          <target state="translated">Указывает, что этот вызов удалил последнего &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; из драйвера, но все еще есть открытые порты, использующие его. Когда все порты закрыты и новые &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; не прибыли, драйвер перезагружается, а имя и память освобождаются.</target>
        </trans-unit>
        <trans-unit id="9d25290abdf2e0ca7cc841bfb568813355a0802e" translate="yes" xml:space="preserve">
          <source>Indicates that trace logs are not to be collected after tracing is stopped.</source>
          <target state="translated">Указывает,что журналы трассировки не должны собираться после остановки трассировки.</target>
        </trans-unit>
        <trans-unit id="a7ce5c93e6670b3ab25a70739bf3a2b64bf5289d" translate="yes" xml:space="preserve">
          <source>Indicates that trace messages are to be printed on the console as they are received by the tracing process. This implies trace client &lt;code&gt;{local, File}&lt;/code&gt;. If &lt;code&gt;ShellSpec&lt;/code&gt; is &lt;code&gt;only&lt;/code&gt; (instead of &lt;code&gt;true&lt;/code&gt;), no trace logs are stored.</source>
          <target state="translated">Указывает, что сообщения трассировки должны печататься на консоли по мере их получения процессом трассировки. Это подразумевает клиента трассировки &lt;code&gt;{local, File}&lt;/code&gt; . Если &lt;code&gt;ShellSpec&lt;/code&gt; имеет значение &lt;code&gt;only&lt;/code&gt; (вместо &lt;code&gt;true&lt;/code&gt; ), журналы трассировки не сохраняются.</target>
        </trans-unit>
        <trans-unit id="ca4adbf68227389dc62c330e8e9bac1501e4b85b" translate="yes" xml:space="preserve">
          <source>Indicates the file owner. Ignored for non-Unix file systems.</source>
          <target state="translated">Указывает на владельца файла.Игнорируется для не-униксовых файловых систем.</target>
        </trans-unit>
        <trans-unit id="6c68113f254ba2ea7ffc965f78681100985873d3" translate="yes" xml:space="preserve">
          <source>Indicates the inets version.</source>
          <target state="translated">Указывает на версию inets.</target>
        </trans-unit>
        <trans-unit id="224497035660eaa0bff9029bd6c2cd2438d9b394" translate="yes" xml:space="preserve">
          <source>Indicates the owner of the file. On non-Unix file systems, this field is zero.</source>
          <target state="translated">Указывает владельца файла.На не-униксовых файловых системах это поле равно нулю.</target>
        </trans-unit>
        <trans-unit id="b47cb315e9dabaf8faae72ffb461cea7bba28766" translate="yes" xml:space="preserve">
          <source>Indicates the return value to be &lt;code&gt;{stopped, Dir}&lt;/code&gt; and not just &lt;code&gt;stopped&lt;/code&gt;. This implies &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">Указывает, что возвращаемое значение должно быть &lt;code&gt;{stopped, Dir}&lt;/code&gt; а не просто &lt;code&gt;stopped&lt;/code&gt; . Это подразумевает &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d35b2e4ff0ddad33a5641c5c7f2c271f941aca60" translate="yes" xml:space="preserve">
          <source>Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">Показывает,что сервер будет пытаться выполнить переговоры по протоколу прикладного уровня (ALPN).</target>
        </trans-unit>
        <trans-unit id="f3f315fb532a3b7264bb002ee89acdb0f4afc9e0" translate="yes" xml:space="preserve">
          <source>Indicates the trace logs to be formatted after tracing is stopped. All logs in the fetch directory are merged.</source>
          <target state="translated">Показывает журналы трассы,которые должны быть отформатированы после остановки трассировки.Все журналы в каталоге извлечения объединяются.</target>
        </trans-unit>
        <trans-unit id="3d7885720efb295da36f8958002ab554f813fd40" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;read_concurrency&lt;/code&gt; or not.</source>
          <target state="translated">Указывает, использует ли таблица &lt;code&gt;read_concurrency&lt;/code&gt; или нет.</target>
        </trans-unit>
        <trans-unit id="0f194418909ecb0776bfd3596100881c33eff9da" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;write_concurrency&lt;/code&gt;.</source>
          <target state="translated">Указывает, использует ли таблица &lt;code&gt;write_concurrency&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69bd50ab548b8102cd9a1fe6230c53d33f12b9be" translate="yes" xml:space="preserve">
          <source>Indication of whether or not capabilities exchange has selected inband security using TLS. &lt;code&gt;Ref&lt;/code&gt; is a reference() that must be included in the &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; reply message to the transport's parent process (see below). &lt;code&gt;Type&lt;/code&gt; is either &lt;code&gt;connect&lt;/code&gt; or &lt;code&gt;accept&lt;/code&gt; depending on whether the process has been started for a connecting or listening transport respectively. &lt;code&gt;Bool&lt;/code&gt; is a boolean() indicating whether or not the transport connection should be upgraded to TLS.</source>
          <target state="translated">Индикация того, выбрал ли обмен возможностями внутриполосную безопасность с использованием TLS. &lt;code&gt;Ref&lt;/code&gt; - это ссылка (), которая должна быть включена в ответное сообщение &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; родительскому процессу транспорта (см. Ниже). &lt;code&gt;Type&lt;/code&gt; - это либо &lt;code&gt;connect&lt;/code&gt; либо &lt;code&gt;accept&lt;/code&gt; зависимости от того, был ли запущен процесс для подключения или прослушивания транспорта соответственно. &lt;code&gt;Bool&lt;/code&gt; - это логическое значение (), указывающее, следует ли обновить транспортное соединение до TLS.</target>
        </trans-unit>
        <trans-unit id="05533a98ca1eac044b0fade678b3259891f47860" translate="yes" xml:space="preserve">
          <source>Individual patterns are represented as follows:</source>
          <target state="translated">Индивидуальные шаблоны представлены следующим образом:</target>
        </trans-unit>
        <trans-unit id="62fba71f7f99e1c8a7d2339ef9441f9378f3f692" translate="yes" xml:space="preserve">
          <source>Inferring Session Termination from Origin-State-Id</source>
          <target state="translated">Инфергирующий сеанс Прекращение сеанса с момента его начала и до конца.</target>
        </trans-unit>
        <trans-unit id="68f6c014d38a2a4ded13ed708fa02ce23813c010" translate="yes" xml:space="preserve">
          <source>Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:</source>
          <target state="translated">Бесконечные циклы можно построить,например,следуя подмаскировке,которая не может совпадать ни с одним символом с квантификатором,не имеющим верхней границы:</target>
        </trans-unit>
        <trans-unit id="3da4edd9211b1f0de62eb4b59bb0f4a07f35071f" translate="yes" xml:space="preserve">
          <source>Inform about delivery result.</source>
          <target state="translated">Информируйте о результатах доставки.</target>
        </trans-unit>
        <trans-unit id="2957467750434af57077099e35ef2ac6165d01aa" translate="yes" xml:space="preserve">
          <source>Inform about target addresses.</source>
          <target state="translated">Информируйте о целевых адресах.</target>
        </trans-unit>
        <trans-unit id="90049cac09e82499ae5c45699662d377e2e83121" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=accept&lt;/code&gt; has established a connection with the peer. Not sent if the transport process has &lt;code&gt;Type=connect&lt;/code&gt;.</source>
          <target state="translated">Сообщите родителю, что транспортный процесс с &lt;code&gt;Type=accept&lt;/code&gt; установил соединение с партнером. Не отправляется, если для транспортного процесса задано &lt;code&gt;Type=connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a5e762b03951002c7550ea2ef3353a81e74fc7" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=connect&lt;/code&gt; has established a connection with a peer. Not sent if the transport process has &lt;code&gt;Type=accept&lt;/code&gt;. &lt;code&gt;Remote&lt;/code&gt; is an arbitrary term that uniquely identifies the remote endpoint to which the transport has connected. A &lt;code&gt;LocalAddr&lt;/code&gt; list has the same semantics as one returned from &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сообщите родителю, что транспортный процесс с &lt;code&gt;Type=connect&lt;/code&gt; установил соединение с одноранговым узлом. Не отправляется, если для транспортного процесса указано &lt;code&gt;Type=accept&lt;/code&gt; . &lt;code&gt;Remote&lt;/code&gt; - это произвольный термин, который однозначно определяет удаленную конечную точку, к которой подключен транспорт. Список &lt;code&gt;LocalAddr&lt;/code&gt; имеет ту же семантику, что и список, возвращаемый из &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2447fae055d21e07237d4cd9806f0d1e44fef23" translate="yes" xml:space="preserve">
          <source>Informally, an I/O list is a deep list of characters and binaries that can be sent to an Erlang port. In BNF, an I/O list is formally defined as follows:</source>
          <target state="translated">Информально,список ввода/вывода-это глубокий список символов и двоичных файлов,которые могут быть отправлены в порт Erlang.В BNF список ввода/вывода формально определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="625b4ee43825e1d7dccb243cb5097290a139ac08" translate="yes" xml:space="preserve">
          <source>Information Object Classes, Information Objects, and Information Object Sets (in the following called classes, objects, and object sets, respectively) are defined in the standard definition X.681. Only a brief explanation is given here.</source>
          <target state="translated">Классы информационных объектов,информационные объекты и наборы информационных объектов (в следующих названных ниже классах,объектах и наборах объектов соответственно)определены в стандартном определении X.681.Здесь приводится только краткое объяснение.</target>
        </trans-unit>
        <trans-unit id="a82aa8be7390c90d1ca31ddb9f26374aa32e3de7" translate="yes" xml:space="preserve">
          <source>Information about all debugged processes, that is, all processes that have been or are executing code in interpreted modules</source>
          <target state="translated">Информация обо всех отлаженных процессах,то есть обо всех процессах,которые выполняли или выполняют код в интерпретируемых модулях</target>
        </trans-unit>
        <trans-unit id="7b5fbcbe4f33b24be7f7dade0473f9e3fd15c849" translate="yes" xml:space="preserve">
          <source>Information about applications is fetched from the script when an upgrade or downgrade is performed.</source>
          <target state="translated">Информация о приложениях извлекается из скрипта при обновлении или понижении рейтинга.</target>
        </trans-unit>
        <trans-unit id="727a296b0edd7e6903cb4f17c45d2edcf89ed311" translate="yes" xml:space="preserve">
          <source>Information about implementation of Erlang can, for example, be found, in the following:</source>
          <target state="translated">Информацию о реализации Erlang можно,например,найти в следующем разделе:</target>
        </trans-unit>
        <trans-unit id="7c573cb4e686c6d4351b362e3e317ae0cec7f7b7" translate="yes" xml:space="preserve">
          <source>Information about processes that are linked to the crashing process and do not trap exits. These processes are the neighbours that terminate because of this process crash. The information gathered is the same as the information for Crasher, described in the previous item.</source>
          <target state="translated">Информация о процессах,которые связаны с завершающимся процессом и не ловят выходы.Эти процессы являются соседями,которые прекращают свою работу из-за сбоя этого процесса.Собранная информация аналогична информации о Crasher,описанной в предыдущем пункте.</target>
        </trans-unit>
        <trans-unit id="3d412b1b20ea796db2817fa903c28c18a18ab90f" translate="yes" xml:space="preserve">
          <source>Information about the crashing process, such as initial function call, exit reason, and message queue.</source>
          <target state="translated">Информация о процессе выхода из строя,такая как начальный вызов функции,причина выхода из строя и очередь сообщений.</target>
        </trans-unit>
        <trans-unit id="aed31395b72e3d4a3ffcf65b21d202b748042b7c" translate="yes" xml:space="preserve">
          <source>Information can be added to an existing PLT using option &lt;code&gt;--add_to_plt&lt;/code&gt;. If you also want to include the Erlang compiler in the PLT and place it in a new PLT, then use the following command:</source>
          <target state="translated">Информация может быть добавлена ​​к существующему PLT с помощью опции &lt;code&gt;--add_to_plt&lt;/code&gt; . Если вы также хотите включить компилятор Erlang в PLT и поместить его в новый PLT, используйте следующую команду:</target>
        </trans-unit>
        <trans-unit id="badb50beadce8a2fedabb18c2c3e47e220d098c1" translate="yes" xml:space="preserve">
          <source>Information function that returns a list of test case properties. (Optional)</source>
          <target state="translated">Информационная функция,которая возвращает список свойств тестового случая.(необязательно)</target>
        </trans-unit>
        <trans-unit id="a3358e99a156706a4b02a438de13cfba6a39cfde" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for a test case group. (Optional)</source>
          <target state="translated">Информационная функция,используемая для возврата свойств для группы тестов.(необязательно)</target>
        </trans-unit>
        <trans-unit id="b7b69d6b9f543c0eaac78b09bddfd720500262fd" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for the suite. (Optional)</source>
          <target state="translated">Информационная функция,используемая для возврата свойств пакета.(опционально)</target>
        </trans-unit>
        <trans-unit id="275d164cb628d42311ae4ac3f05e29648d313888" translate="yes" xml:space="preserve">
          <source>Information functions can also be used for functions &lt;code&gt;init_per_suite&lt;/code&gt;, &lt;code&gt;end_per_suite&lt;/code&gt;, &lt;code&gt;init_per_group&lt;/code&gt;, and &lt;code&gt;end_per_group&lt;/code&gt;, and they work the same way as with the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;. This is useful, for example, for setting timetraps and requiring external configuration data relevant only for the configuration function in question (without affecting properties set for groups and test cases in the suite).</source>
          <target state="translated">Информационные функции также могут использоваться для функций &lt;code&gt;init_per_suite&lt;/code&gt; , &lt;code&gt;end_per_suite&lt;/code&gt; , &lt;code&gt;init_per_group&lt;/code&gt; и &lt;code&gt;end_per_group&lt;/code&gt; , и они работают так же, как с &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; . Это полезно, например, для установки временных ловушек и требования внешних данных конфигурации, относящихся только к рассматриваемой функции конфигурации (без влияния на свойства, установленные для групп и тестовых примеров в наборе).</target>
        </trans-unit>
        <trans-unit id="a4cf2090c576759071b1e7653127fe15f6adfbf5" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the callback function &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt;.</source>
          <target state="translated">Информация доставляется получателю через вызовы функции обратного вызова &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dca988e4a05ad3fbc98691395293e6bd4182b54" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the provided fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt;.</source>
          <target state="translated">Информация доставляется получателю посредством звонков на предоставленный забавный &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cec5dea1f15eeea2c3e84d3e4ca8bca5a2733527" translate="yes" xml:space="preserve">
          <source>Information on the current primary peer address (see below for the format of &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt;)</source>
          <target state="translated">Информация о текущем адресе основного однорангового узла (см. Ниже формат &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="943263da051924df889852b7d374aa63740830a1" translate="yes" xml:space="preserve">
          <source>Information passed as &lt;code&gt;Allowed&lt;/code&gt; to &lt;code&gt;accept_connection/5&lt;/code&gt;. This field is only mandatory when the remote node initiated the connection. That is, when the connection is set up via &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Информация передается как &lt;code&gt;Allowed&lt;/code&gt; к &lt;code&gt;accept_connection/5&lt;/code&gt; . Это поле является обязательным, только если удаленный узел инициировал соединение. То есть, когда соединение установлено через &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ade170506ce24c2adf11de9da3bbb7eb70a58a29" translate="yes" xml:space="preserve">
          <source>Information to the trace information file by can be added by calling &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;ValueList&lt;/code&gt; always is a list, and if you call &lt;code&gt;write_trace_info/2&lt;/code&gt; many times with the same &lt;code&gt;Key&lt;/code&gt;, the &lt;code&gt;ValueList&lt;/code&gt; is extended with a new value each time.</source>
          <target state="translated">Информацию в файл информации трассировки можно добавить, вызвав &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что &lt;code&gt;ValueList&lt;/code&gt; всегда является списком, и если вы вызываете &lt;code&gt;write_trace_info/2&lt;/code&gt; много раз с одним и тем же &lt;code&gt;Key&lt;/code&gt; , &lt;code&gt;ValueList&lt;/code&gt; каждый раз расширяется новым значением.</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="fde8a0e7f8bd0a412204912650f8bc070489e1ef" translate="yes" xml:space="preserve">
          <source>Informative References</source>
          <target state="translated">Информационные ссылки</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="e10de46302bedac991ba7ad1e088a618722e8fd6" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case</source>
          <target state="translated">Функция входа/выхода из конфигурации для тестового случая</target>
        </trans-unit>
        <trans-unit id="d015c9ace3c20434d0041ce0cff6ccab9781d84e" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case group</source>
          <target state="translated">Функция конфигурирования входа/выхода из группы тестовых примеров</target>
        </trans-unit>
        <trans-unit id="58ae4fa4e4c45a4042a21249a079524cbdf1fa72" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for the test suite</source>
          <target state="translated">Функция входа/выхода из комплекта тестирования</target>
        </trans-unit>
        <trans-unit id="04b4f9e33823c16aab76a0d934f32d38d4e5908c" translate="yes" xml:space="preserve">
          <source>Initial actions can be started and performed automatically on test target nodes using test specification term &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">Начальные действия могут быть запущены и выполнены автоматически на тестовых целевых узлах, используя термин &lt;code&gt;init&lt;/code&gt; спецификации теста .</target>
        </trans-unit>
        <trans-unit id="d2e68d0686900d050b8e51048d38b591ec44cadd" translate="yes" xml:space="preserve">
          <source>Initial callback state. The prevailing state is passed to some &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks, which can then return a new state. Defaults to the value of the &lt;code&gt;alias&lt;/code&gt; option.</source>
          <target state="translated">Начальное состояние обратного вызова. Преобладающее состояние передается некоторым обратным вызовам Diameter_app &lt;code&gt;diameter_app(3)&lt;/code&gt; , которые затем могут возвращать новое состояние. По умолчанию используется значение параметра &lt;code&gt;alias&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11127aa4503fb4c327cb52eefbc283b5b904478b" translate="yes" xml:space="preserve">
          <source>Initial configuration of a user</source>
          <target state="translated">Первоначальная конфигурация пользователя</target>
        </trans-unit>
        <trans-unit id="f63e2a1458a3165eba761814a98cccd7a36796bc" translate="yes" xml:space="preserve">
          <source>Initial configuring of the benchmark is done. It is time to profile the actual benchmark and Mnesia</source>
          <target state="translated">Проведена начальная настройка бенчмарка.Пришло время профилировать фактический бенчмарк и Мнезию.</target>
        </trans-unit>
        <trans-unit id="fd67134d209d3929a18fd22b2bf93061d0a6fcc9" translate="yes" xml:space="preserve">
          <source>Initial punctuation</source>
          <target state="translated">Первоначальная пунктуация</target>
        </trans-unit>
        <trans-unit id="7b1e85e5bbe04989425e3d15621533a5999e3cbf" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Структура инициализации читается &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f237c69a9e859db2237946c5d7c0d276ae06c1c" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;Config&lt;/code&gt; for property testing.</source>
          <target state="translated">Инициализирует &lt;code&gt;Config&lt;/code&gt; для тестирования свойств.</target>
        </trans-unit>
        <trans-unit id="ab1eb197ba5ebd342dc2ee475284fc7e5bf38b6a" translate="yes" xml:space="preserve">
          <source>Initializes a decompression session on zlib stream.</source>
          <target state="translated">Инициализирует сеанс декомпрессии в потоке zlib.</target>
        </trans-unit>
        <trans-unit id="71cf011a78329c432562646be985f8bd2d74719c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for compression.</source>
          <target state="translated">Инициализирует поток zlib для сжатия.</target>
        </trans-unit>
        <trans-unit id="3b0787c54b4aa93c99e4db7e0aa8440f3e95865c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for decompression.</source>
          <target state="translated">Инициализирует поток zlib для декомпрессии.</target>
        </trans-unit>
        <trans-unit id="f2ef76634443e1b1606ba6eb2d97778abbd5fbc8" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; variable at &lt;code&gt;*pid&lt;/code&gt; to represent the calling process.</source>
          <target state="translated">Инициализирует переменную &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;*pid&lt;/code&gt; для представления вызывающего процесса.</target>
        </trans-unit>
        <trans-unit id="3d111765b0e759f11aeb197d3230fefefbab898e" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;ec&lt;/code&gt; structure, to identify the node name and cookie of the server. One of them must be called before other functions that works on the &lt;code&gt;ei_cnode&lt;/code&gt; type or a file descriptor associated with a connection to another node is used.</source>
          <target state="translated">Инициализирует структуру &lt;code&gt;ec&lt;/code&gt; для идентификации имени узла и cookie сервера. Одна из них должна быть вызвана перед использованием других функций, работающих с типом &lt;code&gt;ei_cnode&lt;/code&gt; или файлового дескриптора, связанного с подключением к другому узлу.</target>
        </trans-unit>
        <trans-unit id="27ee5ce539b908b2f9afc72b6ece61043b8b3a2b" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;erl_connect&lt;/code&gt; module. In particular, these functions are used to identify the name of the C-node from which they are called. One of these functions must be called before any of the other functions in the &lt;code&gt;erl_connect&lt;/code&gt; module are used.</source>
          <target state="translated">Инициализирует модуль &lt;code&gt;erl_connect&lt;/code&gt; . В частности, эти функции используются для идентификации имени C-узла, из которого они вызываются. Одна из этих функций должна быть вызвана перед использованием любой из других функций в модуле &lt;code&gt;erl_connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fff4647fcca281983f6aa36bc54f3d489503d92" translate="yes" xml:space="preserve">
          <source>Initializes the compression dictionary from the specified byte sequence without producing any compressed output.</source>
          <target state="translated">Инициализирует словарь сжатия из заданной последовательности байтов,не производя никакого сжатого вывода.</target>
        </trans-unit>
        <trans-unit id="cecdcace992350d4b41d9351d096bb6f4340a901" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming HMAC operations. &lt;code&gt;Type&lt;/code&gt; determines which hash function to use in the HMAC operation. &lt;code&gt;Key&lt;/code&gt; is the authentication key. The key can be any length.</source>
          <target state="translated">Инициализирует контекст для потоковой передачи операций HMAC. &lt;code&gt;Type&lt;/code&gt; определяет, какую хеш-функцию использовать в операции HMAC. &lt;code&gt;Key&lt;/code&gt; - это ключ аутентификации. Ключ может быть любой длины.</target>
        </trans-unit>
        <trans-unit id="58ee8f0d598b1ace76a798b4bc4357923d380ca5" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming hash operations. &lt;code&gt;Type&lt;/code&gt; determines which digest to use. The returned context should be used as argument to &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Инициализирует контекст для потоковых хэш-операций. &lt;code&gt;Type&lt;/code&gt; определяет, какой дайджест использовать. &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt; контекст должен использоваться как аргумент для hash_update .</target>
        </trans-unit>
        <trans-unit id="25148288204f1c00d73668550121311425efb10f" translate="yes" xml:space="preserve">
          <source>Initializes the decompression dictionary from the specified uncompressed byte sequence. This function must be called as a response to an inflate operation (eg. &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt;) returning &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; or in the case of deprecated functions, throwing an &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; exception.</source>
          <target state="translated">Инициализирует словарь декомпрессии из указанной несжатой последовательности байтов. Эта функция должна быть вызвана как ответ на операцию &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; (например, safeInflate / 2 ), возвращающую &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; или, в случае устаревших функций, &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; исключение.</target>
        </trans-unit>
        <trans-unit id="ac2bef434e9feaa5de169d2c6afbadd5a7c8908f" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in RC4 stream encryption &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Инициализирует состояние для использования в шифровании потока RC4 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5663fa60784f6a9095ca4a82fdf76aac4aedd36a" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in streaming AES encryption using Counter mode (CTR). &lt;code&gt;Key&lt;/code&gt; is the AES key and must be either 128, 192, or 256 bits long. &lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Инициализирует состояние для использования в потоковом шифровании AES с использованием режима счетчика (CTR). &lt;code&gt;Key&lt;/code&gt; - это ключ AES, который должен иметь длину 128, 192 или 256 бит. &lt;code&gt;IVec&lt;/code&gt; - произвольный инициализирующий вектор длиной 128 бит (16 байтов). Это состояние предназначено для использования с &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a25db95ace1f2c927c73f5809d432ed6899752c5" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with a continuous buffer with the same byte content as &lt;code&gt;iolist&lt;/code&gt;. As with &lt;code&gt;inspect_binary&lt;/code&gt;, the data pointed to by &lt;code&gt;bin&lt;/code&gt; is transient and does not need to be released.</source>
          <target state="translated">Инициализирует структуру, на которую указывает &lt;code&gt;bin&lt;/code&gt; , непрерывным буфером с тем же байтовым содержимым, что и &lt;code&gt;iolist&lt;/code&gt; . Как и в случае с &lt;code&gt;inspect_binary&lt;/code&gt; , данные, на которые указывает &lt;code&gt;bin&lt;/code&gt; , являются временными и их не нужно выпускать.</target>
        </trans-unit>
        <trans-unit id="53971700cd909eeea0c14864c58051e869c0d933" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with information about binary term &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">Инициализирует структуру, на которую указывает &lt;code&gt;bin&lt;/code&gt; , информацией о двоичном термине &lt;code&gt;bin_term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1914215cd23f1ae665e3e4aa9c43e473915c1e" translate="yes" xml:space="preserve">
          <source>Initializing &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">Инициализация &lt;code&gt;Erl_Interface&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="095ce38697e0ac705466cb7422f064715a0a7be2" translate="yes" xml:space="preserve">
          <source>Initializing a database</source>
          <target state="translated">Инициализация базы данных</target>
        </trans-unit>
        <trans-unit id="142639d39cd6ad6faf1f4a1c6ffbfff03a3e72a6" translate="yes" xml:space="preserve">
          <source>Initializing a new database schema with an attribute that specifies on which node, or nodes, that database is to operate.</source>
          <target state="translated">Инициализируя новую схему БД атрибутом,который определяет,на каком узле или узлах должна работать эта БД.</target>
        </trans-unit>
        <trans-unit id="8af85a22a580244a2da7187be7bcbcb5ef240447" translate="yes" xml:space="preserve">
          <source>Initially 768 words + the size of each element (6 words + the size of Erlang data). The table grows when necessary.</source>
          <target state="translated">Изначально 768 слов+размер каждого элемента (6 слов+размер данных Эрланга).При необходимости таблица растет.</target>
        </trans-unit>
        <trans-unit id="0c0e4c0739e6fa2df487aed1a38bae60d5b44dca" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all Erlang object code directories under library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt;, where &lt;code&gt;$OTPROOT&lt;/code&gt; is the installation directory of Erlang/OTP, &lt;code&gt;code:root_dir()&lt;/code&gt;. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt; and the code server, by default, chooses the directory with the highest version number among those having the same &lt;code&gt;Name&lt;/code&gt;. Suffix &lt;code&gt;-Vsn&lt;/code&gt; is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under &lt;code&gt;Name[-Vsn]&lt;/code&gt;, this directory is added to the code path.</source>
          <target state="translated">Первоначально путь кода состоит из текущего рабочего каталога и всех каталогов объектного кода Erlang в каталоге библиотеки &lt;code&gt;$OTPROOT/lib&lt;/code&gt; , где &lt;code&gt;$OTPROOT&lt;/code&gt; - это каталог установки Erlang / OTP, &lt;code&gt;code:root_dir()&lt;/code&gt; . Каталогам можно присвоить &lt;code&gt;Name[-Vsn]&lt;/code&gt; и сервер кода по умолчанию выбирает каталог с наивысшим номером версии среди тех, которые имеют такое же &lt;code&gt;Name&lt;/code&gt; . Суффикс &lt;code&gt;-Vsn&lt;/code&gt; не обязателен. Если каталог &lt;code&gt;ebin&lt;/code&gt; существует под &lt;code&gt;Name[-Vsn]&lt;/code&gt; , этот каталог добавляется к пути кода.</target>
        </trans-unit>
        <trans-unit id="1ef73203a7358f8c0665ad7be5a157f1e4b9f4a0" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all object code directories under &lt;code&gt;ROOT/lib&lt;/code&gt;, where &lt;code&gt;ROOT&lt;/code&gt; is the installation directory of Erlang/OTP. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt;. The code server, by default, chooses the directory with the highest version number among those which have the same &lt;code&gt;Name&lt;/code&gt;. The &lt;code&gt;-Vsn&lt;/code&gt; suffix is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under the &lt;code&gt;Name[-Vsn]&lt;/code&gt; directory, this directory is added to the code path.</source>
          <target state="translated">Первоначально путь кода состоит из текущего рабочего каталога и всех каталогов объектного кода в &lt;code&gt;ROOT/lib&lt;/code&gt; , где &lt;code&gt;ROOT&lt;/code&gt; - это каталог установки Erlang / OTP. Каталогам можно присвоить &lt;code&gt;Name[-Vsn]&lt;/code&gt; . Сервер кода по умолчанию выбирает каталог с наивысшим номером версии среди тех, которые имеют то же &lt;code&gt;Name&lt;/code&gt; . &lt;code&gt;-Vsn&lt;/code&gt; суффикс является необязательным. Если каталог &lt;code&gt;ebin&lt;/code&gt; существует в каталоге &lt;code&gt;Name[-Vsn]&lt;/code&gt; , этот каталог добавляется к пути кода.</target>
        </trans-unit>
        <trans-unit id="73e156d278bb294a1d36b0f1e8eeb76af35c2cea" translate="yes" xml:space="preserve">
          <source>Initiate the discovery process with the manager identified by &lt;code&gt;TargetName&lt;/code&gt; using the notification &lt;code&gt;Notification&lt;/code&gt;.</source>
          <target state="translated">Начните процесс обнаружения с менеджером, идентифицированным &lt;code&gt;TargetName&lt;/code&gt; , с помощью уведомления &lt;code&gt;Notification&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7e89fc3067a91d9dc22af26a15ef53fe7faa29" translate="yes" xml:space="preserve">
          <source>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</source>
          <target state="translated">Запустите транспортную службу и предоставьте ей ручку получения,полученную от megaco:user_info/2.</target>
        </trans-unit>
        <trans-unit id="d124310299080eb087672c20f460f474dd7a228b" translate="yes" xml:space="preserve">
          <source>Initiates a new association for socket &lt;code&gt;Socket&lt;/code&gt;, with the peer (SCTP server socket) specified by &lt;code&gt;Addr&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">Инициирует новую связь для сокета &lt;code&gt;Socket&lt;/code&gt; с одноранговым узлом (сокет сервера SCTP), указанным в &lt;code&gt;Addr&lt;/code&gt; и &lt;code&gt;Port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbce06bee52bd534bac0f1fd879f556b081eb91b" translate="yes" xml:space="preserve">
          <source>Initiates a new handshake. A notable return value is &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; indicating that the peer refused to go through with the renegotiation, but the connection is still active using the previously negotiated session.</source>
          <target state="translated">Инициирует новое рукопожатие. Примечательным возвращаемым значением является &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; указывающее, что одноранговый узел отказался пройти повторное согласование, но соединение все еще активно, используя ранее согласованный сеанс.</target>
        </trans-unit>
        <trans-unit id="5c1ebc3443b604685c9bbd2239beafaabb442116" translate="yes" xml:space="preserve">
          <source>Initiates a zlib stream for compression.</source>
          <target state="translated">Инициирует поток zlib для сжатия.</target>
        </trans-unit>
        <trans-unit id="1829936800429f27b95a3900650dc47d80c4529b" translate="yes" xml:space="preserve">
          <source>Initiates heartbeat immediately</source>
          <target state="translated">Немедленно начинает биение сердца</target>
        </trans-unit>
        <trans-unit id="a7b905a30abe8561cdf350ab8f4be5235485bbee" translate="yes" xml:space="preserve">
          <source>Initiates the event handler. Returns &lt;code&gt;Args&lt;/code&gt;, which is to be used in a call to &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt;.</source>
          <target state="translated">Инициирует обработчик событий. Возвращает &lt;code&gt;Args&lt;/code&gt; , которые должны использоваться при вызове &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3f35312b4615bd360925cee6cb1cda3648d9e7" translate="yes" xml:space="preserve">
          <source>Initiating discovery towards a manager is done by calling the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;EngineId&lt;/code&gt; field of the target (manager) entry in the &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; file has to have the value &lt;code&gt;discovery&lt;/code&gt;. Note that if the manager does not respond, the &lt;code&gt;Timeout&lt;/code&gt; and &lt;code&gt;RetryCount&lt;/code&gt; fields decide how long the function will hang before it returns.</source>
          <target state="translated">Инициирование обнаружения для менеджера выполняется путем вызова функции &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; . Поле &lt;code&gt;EngineId&lt;/code&gt; записи target (manager) в файле &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; должно иметь значение &lt;code&gt;discovery&lt;/code&gt; . Обратите внимание, что если менеджер не отвечает, поля &lt;code&gt;Timeout&lt;/code&gt; и &lt;code&gt;RetryCount&lt;/code&gt; определяют, как долго функция будет зависать перед возвратом.</target>
        </trans-unit>
        <trans-unit id="46e460ee323eec031b508ab0863b81f298c0e181" translate="yes" xml:space="preserve">
          <source>Initiation of the system tracer. This is automatically done when a trace port is started with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запуск системного трассировщика. Это происходит автоматически, когда порт трассировки запускается с &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1e4de183a1e55e20092fbfffb06a3ca6dabef2e" translate="yes" xml:space="preserve">
          <source>Inlining does not necessarily improve running time. For example, inlining can increase Beam stack use, which probably is detrimental to performance for recursive functions.</source>
          <target state="translated">Построение не обязательно улучшает время работы.Например,инкрустация может увеличить использование стека лучей,что,вероятно,отрицательно сказывается на производительности рекурсивных функций.</target>
        </trans-unit>
        <trans-unit id="b63d2fcb1c0298d4382222c2fee85ab11fe71d42" translate="yes" xml:space="preserve">
          <source>Inlining is never default. It must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">Встраивание никогда не выполняется по умолчанию. Он должен быть явно включен с помощью параметра компилятора или &lt;code&gt;-compile()&lt;/code&gt; в исходном модуле.</target>
        </trans-unit>
        <trans-unit id="9684f8c1b7785c7f3b7b0c7da13c9d237117432e" translate="yes" xml:space="preserve">
          <source>Input is the &lt;code&gt;modify_algs_list()&lt;/code&gt; and a set of algorithms &lt;code&gt;A&lt;/code&gt; obtained from the &lt;code&gt;preferred_algorithms&lt;/code&gt; option if existing, or else from the &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Входные данные - это &lt;code&gt;modify_algs_list()&lt;/code&gt; и набор алгоритмов &lt;code&gt;A&lt;/code&gt; , полученных из опции &lt;code&gt;preferred_algorithms&lt;/code&gt; если она существует, или из &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="23d75e61604fece9c7dbc8a44250dba16a34606c" translate="yes" xml:space="preserve">
          <source>Insert CRLs into the ssl applications local cache.</source>
          <target state="translated">Вставьте CRL в локальный кэш ssl приложений.</target>
        </trans-unit>
        <trans-unit id="cd5094189bd5cfd6365f179313ffd178fdf639f3" translate="yes" xml:space="preserve">
          <source>Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers.</source>
          <target state="translated">Вставьте словарную статью и отправьте кортеж {et,{dict_insert,Key,Val}}всем зарегистрированным абонентам.</target>
        </trans-unit>
        <trans-unit id="e4cd78fd267862c838a3ab52eeab4765922d4166" translate="yes" xml:space="preserve">
          <source>Insert and lookup times in tables of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; are constant, regardless of the table size. For the &lt;code&gt;ordered_set&lt;/code&gt; datatype, time is proportional to the (binary) logarithm of the number of objects.</source>
          <target state="translated">Время вставки и поиска в таблицах типов &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; и &lt;code&gt;duplicate_bag&lt;/code&gt; постоянно, независимо от размера таблицы. Для &lt;code&gt;ordered_set&lt;/code&gt; данных order_set время пропорционально (двоичному) логарифму количества объектов.</target>
        </trans-unit>
        <trans-unit id="8d23e9df496d5b5f549fd584b36ee77d8c95cf96" translate="yes" xml:space="preserve">
          <source>Insert previously killed text</source>
          <target state="translated">Вставить ранее убитый текст</target>
        </trans-unit>
        <trans-unit id="3bc9ebf4c62f530cbb1f2b55cfa61617e0d53ff4" translate="yes" xml:space="preserve">
          <source>Insert some data</source>
          <target state="translated">Вставить некоторые данные</target>
        </trans-unit>
        <trans-unit id="640a4aeeec0f1ba39ab23368bd04d29b5d8e1a0c" translate="yes" xml:space="preserve">
          <source>Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; to force processing an inserted event before others.</source>
          <target state="translated">Вставка события заменяет уловку с вызовом ваших собственных функций обработки состояния, к которым вам часто придется прибегать, например, в &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; , чтобы принудительно обработать вставленное событие раньше других.</target>
        </trans-unit>
        <trans-unit id="fd8d30baff70186f2f7aad20b4678282d4900c5d" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees</source>
          <target state="translated">Вставка комментариев в абстрактные синтаксические деревья Эрланга</target>
        </trans-unit>
        <trans-unit id="341885c8dc77554a3ac76126d852595374756f74" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees.</source>
          <target state="translated">Вставка комментариев в абстрактные синтаксические деревья Эрланга.</target>
        </trans-unit>
        <trans-unit id="a3d2a2e2f845d7b7a7ee869ede57ddf6daa0a066" translate="yes" xml:space="preserve">
          <source>Insertions and deletions are inefficient for large tables.</source>
          <target state="translated">Вставки и удаления неэффективны для больших таблиц.</target>
        </trans-unit>
        <trans-unit id="4bb765df879b9e1259d0b71afc9c95a90dee1bad" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; as the tail item of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;Item&lt;/code&gt; в качестве конечного элемента очереди &lt;code&gt;Q1&lt;/code&gt; . Возвращает новую очередь &lt;code&gt;Q2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb0ec71eee2375facccac9dd350eb3632385a27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the front of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;Item&lt;/code&gt; в начало очереди &lt;code&gt;Q1&lt;/code&gt; . Возвращает получившуюся очередь &lt;code&gt;Q2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bff09ae949ed6c5d82000889e64ff74881a86a81" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the head of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;Item&lt;/code&gt; в начало очереди &lt;code&gt;Q1&lt;/code&gt; . Возвращает новую очередь &lt;code&gt;Q2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb8be9c95d38e2c2c62d2277f37e3d777ea4428a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the rear of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;Item&lt;/code&gt; в конец очереди &lt;code&gt;Q1&lt;/code&gt; . Возвращает получившуюся очередь &lt;code&gt;Q2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f86a04b36f84c1791d73ad2f91028f7ab17de69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.</source>
          <target state="translated">Вставляет &lt;code&gt;Key&lt;/code&gt; со значением &lt;code&gt;Value&lt;/code&gt; в &lt;code&gt;Tree1&lt;/code&gt; и возвращает новое дерево. Предполагает, что ключа нет в дереве, иначе произойдет сбой.</target>
        </trans-unit>
        <trans-unit id="b0b72cb6b3b7b94bac6237d6384f911cba7c3b63" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; if the key is not present in the tree, otherwise updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt;. Returns the new tree.</source>
          <target state="translated">Вставляет &lt;code&gt;Key&lt;/code&gt; со значением &lt;code&gt;Value&lt;/code&gt; в &lt;code&gt;Tree1&lt;/code&gt; , если ключ отсутствует в дереве, в противном случае обновляет &lt;code&gt;Key&lt;/code&gt; до значения &lt;code&gt;Value&lt;/code&gt; в &lt;code&gt;Tree1&lt;/code&gt; . Возвращает новое дерево.</target>
        </trans-unit>
        <trans-unit id="8e70edfd3b0237725cfb5a40acf9c3b7b150a1b7" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Sep&lt;/code&gt; between each element in &lt;code&gt;List1&lt;/code&gt;. Has no effect on the empty list and on a singleton list. For example:</source>
          <target state="translated">Вставляет &lt;code&gt;Sep&lt;/code&gt; между каждым элементом в &lt;code&gt;List1&lt;/code&gt; . Не влияет на пустой список и одноэлементный список. Например:</target>
        </trans-unit>
        <trans-unit id="a325e6f446aeb80024c65275457065a8938c1716" translate="yes" xml:space="preserve">
          <source>Inserts a new key value tuple into the index structure. If an item with the same key already exists, the new &lt;code&gt;Value&lt;/code&gt; overwrites the old value.</source>
          <target state="translated">Вставляет новый кортеж значений ключа в структуру индекса. Если элемент с таким же ключом уже существует, новое &lt;code&gt;Value&lt;/code&gt; перезаписывает старое значение.</target>
        </trans-unit>
        <trans-unit id="dd7d42875749ae25962aac0a68ced0a0cdaac6c5" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data, including the rows with StorageType &lt;code&gt;nonVolatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">Вставляет все данные из файлов конфигурации в базу данных и удаляет все старые данные, включая строки с StorageType &lt;code&gt;nonVolatile&lt;/code&gt; . Строки, созданные из файла конфигурации, будут иметь StorageType &lt;code&gt;nonVolatile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2674f03b5ae49062060d17f947dd901cec545e2" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data.</source>
          <target state="translated">Вставляет все данные в конфигурационные файлы в базу данных и уничтожает все старые данные.</target>
        </trans-unit>
        <trans-unit id="81d473e42a2389c80ba7b8bd8eaae2b9ad9818bb" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old rows with StorageType &lt;code&gt;volatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">Вставляет все данные из файлов конфигурации в базу данных и удаляет все старые строки с помощью StorageType &lt;code&gt;volatile&lt;/code&gt; . Строки, созданные из файла конфигурации, будут иметь StorageType &lt;code&gt;nonVolatile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e4c6bfec305d402baf1f6154ff407e6c91aee57" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into table &lt;code&gt;Name&lt;/code&gt;. If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and &lt;code&gt;false&lt;/code&gt; is returned. Otherwise the objects are inserted and &lt;code&gt;true&lt;/code&gt; returned.</source>
          <target state="translated">Вставляет один или несколько объектов в таблицу &lt;code&gt;Name&lt;/code&gt; . Если уже существует объект с ключом, совпадающим с ключом любого из указанных объектов, таблица не обновляется и возвращается &lt;code&gt;false&lt;/code&gt; . В противном случае объекты вставляются и возвращается &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1739eb862c4f44f0c8b8666aa94b12c3c5873c60" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into the table &lt;code&gt;Name&lt;/code&gt;. If there already exists an object with a key matching the key of some of the given objects and the table type is &lt;code&gt;set&lt;/code&gt;, the old object will be replaced.</source>
          <target state="translated">Вставляет один или несколько объектов в &lt;code&gt;Name&lt;/code&gt; таблицы . Если уже существует объект с ключом , соответствующим ключом некоторых из указанных объектов и типа таблицы будет &lt;code&gt;set&lt;/code&gt; , старый объект будет заменен.</target>
        </trans-unit>
        <trans-unit id="876fd5ef2edcb097ef23ce7a73b8560c457972a7" translate="yes" xml:space="preserve">
          <source>Inserts the object or all of the objects in list &lt;code&gt;ObjectOrObjects&lt;/code&gt; into table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">Вставляет объект или все объекты из списка &lt;code&gt;ObjectOrObjects&lt;/code&gt; в таблицу &lt;code&gt;Tab&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae27be6880fa3f4c4317e7fa32cf164938b23b5f" translate="yes" xml:space="preserve">
          <source>Inserts the objects of the Dets table &lt;code&gt;Name&lt;/code&gt; into the ETS table &lt;code&gt;EtsTab&lt;/code&gt;. The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten.</source>
          <target state="translated">Вставляет объекты &lt;code&gt;Name&lt;/code&gt; таблицы &lt;code&gt;EtsTab&lt;/code&gt; таблицу EtsTab ETS . Порядок вставки объектов не указан. Существующие объекты таблицы ETS сохраняются до перезаписи.</target>
        </trans-unit>
        <trans-unit id="b4bdee8f5d016433edb2959501b5ea73fcb10ffd" translate="yes" xml:space="preserve">
          <source>Inside a character class, \b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \B matches the letter B).</source>
          <target state="translated">Внутри класса символов \b имеет другое значение;он соответствует символу обратного пробела.Если любое из этих утверждений появляется в символьном классе,то по умолчанию оно соответствует соответствующему буквенному символу (например,\B соответствует букве B).</target>
        </trans-unit>
        <trans-unit id="6629b1052ba09388c69c25e3887de5fe2387123b" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number following \ is &amp;gt; 7 and there have not been that many capturing subpatterns, PCRE handles \8 and \9 as the literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">Внутри класса символов, или если десятичное число, следующее за \,&amp;gt; 7 и не было так много захватывающих подшаблонов, PCRE обрабатывает \ 8 и \ 9 как буквальные символы &amp;laquo;8&amp;raquo; и &amp;laquo;9&amp;raquo;, а в противном случае повторно считывает до трех восьмеричных цифр, следующих за обратной косой чертой, и использовать их для создания символа данных. Любые последующие цифры означают сами себя. Например:</target>
        </trans-unit>
        <trans-unit id="772561da756f5538f076f086e95fd9bb72f9c7ca" translate="yes" xml:space="preserve">
          <source>Inspection of options and the collection of information about tables. As a result, qualifiers are modified during the optimization phase.</source>
          <target state="translated">Проверка опций и сбор информации о таблицах.В результате на этапе оптимизации модифицируются классификаторы.</target>
        </trans-unit>
        <trans-unit id="ed15bc5bc33649cbd97c75a190935b6fc664a985" translate="yes" xml:space="preserve">
          <source>Inspects the message queue of the process. The queue is displayed in the Evaluator area.</source>
          <target state="translated">Проверяет очередь сообщений процесса.Очередь отображается в области &quot;Оценщик&quot;.</target>
        </trans-unit>
        <trans-unit id="c41908611056183491b965384931dc36fcce9650" translate="yes" xml:space="preserve">
          <source>Inspects the next function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">Проверяет следующий вызов функции на стеке,показывая расположение и переменные связки.</target>
        </trans-unit>
        <trans-unit id="99dd332d9a6b322e273f2bf083bbb69e0124148d" translate="yes" xml:space="preserve">
          <source>Inspects the previous function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">Проверяет предыдущий вызов функции на стеке,показывая расположение и переменные связки.</target>
        </trans-unit>
        <trans-unit id="e0e3ac66ea23824a0888a07102b587536d02e2eb" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;Common Test Hooks&lt;/code&gt; (similar to &lt;code&gt;ct_run -ch_hooks&lt;/code&gt;).</source>
          <target state="translated">Установите &lt;code&gt;Common Test Hooks&lt;/code&gt; (аналогично &lt;code&gt;ct_run -ch_hooks&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f5eb1e91b4143e0bbdfbeefb2ba46df0c77182c0" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;event_handler&lt;/code&gt; plugins (similar to &lt;code&gt;ct_run -event_handler&lt;/code&gt;).</source>
          <target state="translated">Установите плагины &lt;code&gt;event_handler&lt;/code&gt; (аналогично &lt;code&gt;ct_run -event_handler&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="15c10e0edbffd8d75bb304a5e91c935e1d915d30" translate="yes" xml:space="preserve">
          <source>Install Microsofts Windows SDK 8.1</source>
          <target state="translated">Установить микрософты Windows SDK 8.1</target>
        </trans-unit>
        <trans-unit id="33d5b3ab81816b854714f8f217754d3d00d7f871" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 12.0 (2013)</source>
          <target state="translated">Установить Visual Studio 12.0 (2013)</target>
        </trans-unit>
        <trans-unit id="922606362e642350b80d6e7820e8b5540da61e4b" translate="yes" xml:space="preserve">
          <source>Install a created target system</source>
          <target state="translated">Установить созданную целевую систему</target>
        </trans-unit>
        <trans-unit id="784778ecb391c0bb8180f39379167dc61078581c" translate="yes" xml:space="preserve">
          <source>Install or unpack it to the pgm folder: Cygwin: &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS: &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2: &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</source>
          <target state="translated">Установите или распакуйте его в папку pgm: Cygwin: &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS: &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2: &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5895bd8f7070b66bf6ef0fbd6cb29198cf6422c6" translate="yes" xml:space="preserve">
          <source>Install the lot, especially the modern user interface components, as it's definitely needed. Put &lt;code&gt;makensis&lt;/code&gt; in your path, in my case:</source>
          <target state="translated">Установите все, особенно современные компоненты пользовательского интерфейса, так как это определенно необходимо. Поместите &lt;code&gt;makensis&lt;/code&gt; на своем пути, в моем случае:</target>
        </trans-unit>
        <trans-unit id="dcb4dffdf7e0a85f3c664c1c7c53716ab6be43e4" translate="yes" xml:space="preserve">
          <source>Install using the &lt;code&gt;release&lt;/code&gt; target. Instead of doing &lt;code&gt;make install&lt;/code&gt; you can create the installation in whatever directory you like using the &lt;code&gt;release&lt;/code&gt; target and run the &lt;code&gt;Install&lt;/code&gt; script yourself. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; is used for specifying the directory where the installation should be created. This is what by default ends up under &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; if you do the install using &lt;code&gt;make install&lt;/code&gt;. All installation paths provided in the &lt;code&gt;configure&lt;/code&gt; phase are ignored, as well as &lt;code&gt;DESTDIR&lt;/code&gt;, and &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. If you want links from a specific &lt;code&gt;bin&lt;/code&gt; directory to the installation you have to set those up yourself. An example where Erlang/OTP should be located at &lt;code&gt;/home/me/OTP&lt;/code&gt;:</source>
          <target state="translated">Установите, используя цель &lt;code&gt;release&lt;/code&gt; . Вместо того, &lt;code&gt;make install&lt;/code&gt; делать make install, вы можете создать установку в любом каталоге, который вам нравится, используя цель &lt;code&gt;release&lt;/code&gt; и самостоятельно запустить сценарий &lt;code&gt;Install&lt;/code&gt; . &lt;code&gt;RELEASE_ROOT&lt;/code&gt; используется для указания каталога, в котором должна быть создана установка. Это то, что по умолчанию попадает в &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; , если вы выполняете установку с помощью &lt;code&gt;make install&lt;/code&gt; . Все пути установки, указанные на этапе &lt;code&gt;configure&lt;/code&gt; , игнорируются, а также &lt;code&gt;DESTDIR&lt;/code&gt; и &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; . Если вам нужны ссылки из определенной &lt;code&gt;bin&lt;/code&gt; каталог установки, вы должны настроить их самостоятельно. Пример, где Erlang / OTP должен располагаться в &lt;code&gt;/home/me/OTP&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="ae2c551e6a734627f9bb26b99844fa20be2bf09e" translate="yes" xml:space="preserve">
          <source>Installing Manually</source>
          <target state="translated">Установка вручную</target>
        </trans-unit>
        <trans-unit id="75e25ed448b223fc53dd0af23c71cf6acd70383c" translate="yes" xml:space="preserve">
          <source>Installing Using Paths Determined by configure</source>
          <target state="translated">Установка с использованием траекторий Определяется настройкой</target>
        </trans-unit>
        <trans-unit id="37e8b615530d3eddfdf35ea03fe9f1d1df10701f" translate="yes" xml:space="preserve">
          <source>Installing a fallback is a distributed operation, which is &lt;strong&gt;only&lt;/strong&gt; performed on all &lt;code&gt;db_nodes&lt;/code&gt;. The fallback restores the database the next time the system is started. If a &lt;code&gt;Mnesia&lt;/code&gt; node with a fallback installed detects that &lt;code&gt;Mnesia&lt;/code&gt; on another node has died, it unconditionally terminates itself.</source>
          <target state="translated">Установка резервной копии - это распределенная операция, которая выполняется &lt;strong&gt;только&lt;/strong&gt; на всех &lt;code&gt;db_nodes&lt;/code&gt; . Резервный вариант восстанавливает базу данных при следующем запуске системы. Если узел &lt;code&gt;Mnesia&lt;/code&gt; с установленным резервным вариантом обнаруживает, что &lt;code&gt;Mnesia&lt;/code&gt; на другом узле умер, он безоговорочно завершает работу.</target>
        </trans-unit>
        <trans-unit id="bf8d05868ee0f453c0775974d588edfe5e97fc4f" translate="yes" xml:space="preserve">
          <source>Installing a new release can be time consuming if there are many processes in the system. The reason is that each process must be checked for references to old code before a module can be purged. This check can lead to garbage collections and copying of data.</source>
          <target state="translated">Установка нового релиза может занять много времени,если в системе много процессов.Причина в том,что перед очисткой модуля каждый процесс должен быть проверен на наличие ссылок на старый код.Эта проверка может привести к сбору мусора и копированию данных.</target>
        </trans-unit>
        <trans-unit id="65c9d6735d0aa5d00aafa4b2d57376ac26a57083" translate="yes" xml:space="preserve">
          <source>Installing an embedded system</source>
          <target state="translated">Установка встраиваемой системы</target>
        </trans-unit>
        <trans-unit id="f249b05e1f990b98f6f7c2fa7204014037a42f4b" translate="yes" xml:space="preserve">
          <source>Installing module os_sup in application os_mon</source>
          <target state="translated">Установка модуля os_sup в приложении os_mon</target>
        </trans-unit>
        <trans-unit id="0d6b51117865caef3500da1315942ae925f5b512" translate="yes" xml:space="preserve">
          <source>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</source>
          <target state="translated">Устанавливает резервную копию как запасной вариант.Резервное копирование используется для восстановления базы данных при следующем запуске.Установка резервных копий требует,чтобы Erlang работал на всех задействованных узлах,но не имеет значения,запущен ли Mnesia или нет.Установка резервного копирования будет неудачной,если локальный узел не является одним из узлов-резидентов диска в резервной копии.</target>
        </trans-unit>
        <trans-unit id="80bbef4d77254070ebc618b29a62e45e28b022f6" translate="yes" xml:space="preserve">
          <source>Installs a release-dependent file in the release structure. The release-dependent file must be in the release structure when a new release is installed: &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;relup&lt;/code&gt;, and &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">Устанавливает файл, зависящий от выпуска, в структуре выпуска. При установке нового выпуска файл, зависящий от выпуска, должен находиться в структуре выпуска: &lt;code&gt;start.boot&lt;/code&gt; , &lt;code&gt;relup&lt;/code&gt; и &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc17758134c369293b8376cf241e90d4ab3c9cf" translate="yes" xml:space="preserve">
          <source>Installs configuration files and event handlers.</source>
          <target state="translated">Устанавливает файлы конфигурации и обработчики событий.</target>
        </trans-unit>
        <trans-unit id="cd266c6ba0dabab762b2f84c06c3f60e46cbc0a9" translate="yes" xml:space="preserve">
          <source>Installs the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release. Looks first for a &lt;code&gt;relup&lt;/code&gt; file for &lt;code&gt;Vsn&lt;/code&gt; and a script &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; in this file for upgrading from the current version. If not found, the function looks for a &lt;code&gt;relup&lt;/code&gt; file for the current version and a script &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; in this file for downgrading to &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">Устанавливает указанную версию &lt;code&gt;Vsn&lt;/code&gt; релиза. Сначала &lt;code&gt;relup&lt;/code&gt; файл повторной установки для &lt;code&gt;Vsn&lt;/code&gt; и сценарий &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; в этом файле для обновления с текущей версии. Если не найден, функция ищет файл &lt;code&gt;relup&lt;/code&gt; для текущей версии и скрипт &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; в этом файле для &lt;code&gt;Vsn&lt;/code&gt; на Vsn .</target>
        </trans-unit>
        <trans-unit id="894c05ee140b1e5c4a2d166f027270a4786a5715" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt;, it is recommended to use &lt;code&gt;information object class&lt;/code&gt;, &lt;code&gt;table constraints&lt;/code&gt;, and &lt;code&gt;parameterization&lt;/code&gt;. In particular the construct &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; accomplish the same as the deprecated &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">Вместо &lt;code&gt;ANY&lt;/code&gt; и &lt;code&gt;ANY DEFINED BY&lt;/code&gt; рекомендуется использовать &lt;code&gt;information object class&lt;/code&gt; , &lt;code&gt;table constraints&lt;/code&gt; и &lt;code&gt;parameterization&lt;/code&gt; . В частности, конструкция &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; выполняет то же самое, что и устаревшая &lt;code&gt;ANY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc7e20b59d61598b6e28276f64b45fa785f43095" translate="yes" xml:space="preserve">
          <source>Instead of bothering with when to cancel a time-out, a late time-out event can be handled by ignoring it if it arrives in a state where it is known to be late.</source>
          <target state="translated">Вместо того,чтобы беспокоиться о том,когда отменить тайм-аут,событие с опозданием может быть обработано путем игнорирования,если оно прибывает в состояние,в котором известно,что оно опаздывает.</target>
        </trans-unit>
        <trans-unit id="1ac5e371533e8b9b9bddff06d20eea879128e69a" translate="yes" xml:space="preserve">
          <source>Instead of extracting to a directory, this option gives the result as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of the file named &lt;code&gt;Filename&lt;/code&gt; in the tar file.</source>
          <target state="translated">Вместо извлечения в каталог этот параметр дает результат в виде списка кортежей &lt;code&gt;{Filename, Binary}&lt;/code&gt; , где &lt;code&gt;Binary&lt;/code&gt; - это двоичный файл, содержащий извлеченные данные файла с именем &lt;code&gt;Filename&lt;/code&gt; в файле tar.</target>
        </trans-unit>
        <trans-unit id="4784466e0218483e747807ddebabf7681aeccce8" translate="yes" xml:space="preserve">
          <source>Instead of extracting to the current directory, the result is given as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of file &lt;code&gt;Filename&lt;/code&gt; in the zip archive.</source>
          <target state="translated">Вместо извлечения в текущий каталог результат выдается в виде списка кортежей &lt;code&gt;{Filename, Binary}&lt;/code&gt; , где &lt;code&gt;Binary&lt;/code&gt; - это двоичный файл, содержащий извлеченные данные файла &lt;code&gt;Filename&lt;/code&gt; в zip-архиве.</target>
        </trans-unit>
        <trans-unit id="b7a7e21b3061206a522b83d82bc15d0c88d5c34c" translate="yes" xml:space="preserve">
          <source>Instead of inventing an encoding/decoding scheme, the &lt;code&gt;term_to_binary/1&lt;/code&gt; and &lt;code&gt;binary_to_term/1&lt;/code&gt; BIFs are to be used.</source>
          <target state="translated">Вместо изобретения схемы кодирования / декодирования должны использоваться BIF-файлы &lt;code&gt;term_to_binary/1&lt;/code&gt; и &lt;code&gt;binary_to_term/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="957a44da07f45a291c340d2351a1716bd46e06c0" translate="yes" xml:space="preserve">
          <source>Instead of keeping the events after writing them to file, it is possible to remove all stored events after they have successfully written to file (clear).</source>
          <target state="translated">Вместо того,чтобы хранить события после их записи в файл,можно удалить все сохраненные события после их успешной записи в файл (очистить).</target>
        </trans-unit>
        <trans-unit id="d6b6ced692332e6827f1ab9c6981a8b233a0df36" translate="yes" xml:space="preserve">
          <source>Instead of making two &lt;strong&gt;complete decodes&lt;/strong&gt; (the normal case of decode), one in the server and one in the addressee, it is only necessary to make one &lt;strong&gt;specialized decode&lt;/strong&gt;(in the server) and another complete decode(in the addressee). This section describes the following two specialized decodes, which support to solve this and similar problems:</source>
          <target state="translated">Вместо выполнения двух &lt;strong&gt;полных декодирований&lt;/strong&gt; (обычный случай декодирования), одного на сервере и одного у адресата, необходимо только одно &lt;strong&gt;специализированное декодирование&lt;/strong&gt; (на сервере) и другое полное декодирование (в адресате). В этом разделе описываются следующие два специализированных декодирования, которые помогают решить эту и подобные проблемы:</target>
        </trans-unit>
        <trans-unit id="91c6a0b15ffa9e153241283e847138f73993d2de" translate="yes" xml:space="preserve">
          <source>Instead of passing data between test cases, it is recommended that the test cases read the state from the SUT and perform assertions (that is, let the test case run if the state is as expected, otherwise reset or fail). It is also recommended to use the state to set variables necessary for the test case to execute properly. Common actions can often be implemented as library functions for test cases to call to set the SUT in a required state. (Such common actions can also be separately tested, if necessary, to ensure that they work as expected). It is sometimes also possible, but not always desirable, to group tests together in one test case, that is, let a test case perform a &quot;scenario&quot; test (a test consisting of subtests).</source>
          <target state="translated">Вместо передачи данных между тестовыми случаями рекомендуется,чтобы тестовые случаи считывали состояние из SUT и выполняли утверждения (т.е.позволяли запустить тестовый случай,если состояние соответствует ожидаемому,в противном случае сброс или сбой).Также рекомендуется использовать состояние для установки переменных,необходимых для корректного выполнения тестового случая.Обычные действия часто могут быть реализованы в виде библиотечных функций для вызова тестового случая,чтобы установить SUT в требуемое состояние.(Такие общие действия также могут быть отдельно протестированы при необходимости,чтобы убедиться,что они работают так,как ожидалось).Иногда также возможно,но не всегда желательно,сгруппировать тесты в одном тестовом случае,то есть позволить тестовому случаю выполнить &quot;сценарный&quot; тест (тест,состоящий из подтестов).</target>
        </trans-unit>
        <trans-unit id="12e2746f238f1ef6d97ef5382070198c881467b2" translate="yes" xml:space="preserve">
          <source>Instead of sending and receiving messages, there are also a number of BIFs that can be used:</source>
          <target state="translated">Вместо того,чтобы отправлять и получать сообщения,существует также ряд BIF-файлов,которые можно использовать:</target>
        </trans-unit>
        <trans-unit id="b7e7103489360f3cee70f09abebe4add0bd2f172" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; to retrieve the call stack back-trace, use the following syntax:</source>
          <target state="translated">Вместо использования &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; для получения обратной трассировки стека вызовов используйте следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="ee1209a66a0d33f9394aa6222d618b5c852bc2f2" translate="yes" xml:space="preserve">
          <source>Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y.</source>
          <target state="translated">Вместо того,чтобы писать (x,y)в F или x F y,мы пишем F(x)=y,когда F является функцией,и говорим,что F отображает x на y,или что значение F в x равно y.</target>
        </trans-unit>
        <trans-unit id="a36e0c64e3f3fa49d084296cc4e8951b3a27ede3" translate="yes" xml:space="preserve">
          <source>Instead use the &lt;code&gt;ordsets&lt;/code&gt; module in STDLIB:</source>
          <target state="translated">Вместо того, чтобы использовать &lt;code&gt;ordsets&lt;/code&gt; модуль в STDLIB:</target>
        </trans-unit>
        <trans-unit id="8284bfaef1136f8c3023ca2dd6044b337e83ed3a" translate="yes" xml:space="preserve">
          <source>Instead, a correct &lt;code&gt;relup&lt;/code&gt; file can be created manually, either from scratch or by editing the generated version. The instructions for starting/stopping &lt;code&gt;ch_app&lt;/code&gt; are replaced by instructions for loading/unloading the application:</source>
          <target state="translated">Вместо этого правильный файл &lt;code&gt;relup&lt;/code&gt; можно создать вручную, либо с нуля, либо путем редактирования сгенерированной версии. Инструкции по запуску / остановке &lt;code&gt;ch_app&lt;/code&gt; заменены инструкциями по загрузке / выгрузке приложения:</target>
        </trans-unit>
        <trans-unit id="ba07e35226d0f31a98d4cafeb0c6278cbf810675" translate="yes" xml:space="preserve">
          <source>Instead, write as follows:</source>
          <target state="translated">Вместо этого напишите следующее:</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="9fc643b23198428cdd06035331b0190f9cb1cf31" translate="yes" xml:space="preserve">
          <source>Instruct the network interface process to send the response (acknowledgment) to an inform-request.</source>
          <target state="translated">Проинструктируйте процесс сетевого интерфейса для отправки ответа (подтверждения)на информационный запрос.</target>
        </trans-unit>
        <trans-unit id="950c248b2e82115897c90fa4bea94141b0b4cd0f" translate="yes" xml:space="preserve">
          <source>Instructions for this are added to the &lt;code&gt;relup&lt;/code&gt; file in the above order. Instructions for upgrading or downgrading between application versions are fetched from the relevant application upgrade files &lt;code&gt;App.appup&lt;/code&gt;, sorted in the same order as when generating a boot script, see &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt;. High-level instructions are translated into low-level instructions and the result is printed to the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">Инструкции для этого добавляются в файл &lt;code&gt;relup&lt;/code&gt; в указанном выше порядке. Инструкции по обновлению или &lt;code&gt;App.appup&lt;/code&gt; версию приложения берутся из соответствующих файлов обновления приложения App.appup , отсортированных в том же порядке, что и при создании сценария загрузки, см. &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt; . Инструкции высокого уровня переводятся в инструкции низкого уровня, а результат печатается в файле &lt;code&gt;relup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15a574978b985fb36f19dcd27a57e275c9779736" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to search for include files in the &lt;code&gt;Directory&lt;/code&gt;. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">Указывает компилятору искать включаемые файлы в &lt;code&gt;Directory&lt;/code&gt; . При обнаружении директивы &lt;code&gt;-include&lt;/code&gt; или &lt;code&gt;-include_lib&lt;/code&gt; компилятор ищет файлы заголовков в следующих каталогах:</target>
        </trans-unit>
        <trans-unit id="090b6773e54bc64eab02dc4333eb95623d3030be" translate="yes" xml:space="preserve">
          <source>Instructs the server whether to use persistent connections when the client claims to be HTTP/1.1 compliant. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Указывает серверу, следует ли использовать постоянные соединения, когда клиент утверждает, что он совместим с HTTP / 1.1. По умолчанию &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e97bdfc8fc290d16010ddf7b419664bce4b9617" translate="yes" xml:space="preserve">
          <source>Instrumentation Flags</source>
          <target state="translated">Флаги приборостроения</target>
        </trans-unit>
        <trans-unit id="7e107f318ea5b4287f70d2ec329ab60cf318fcd6" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-COMMUNITY-MIB</source>
          <target state="translated">Приборостроительные функции для SNMP-COMMUNITY-MIB</target>
        </trans-unit>
        <trans-unit id="b5ea15149e34607b8a589fb5bf1d1b743d875810" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-FRAMEWORK-MIB</source>
          <target state="translated">Приборостроительные функции для SNMP-FRAMEWORK-MIB</target>
        </trans-unit>
        <trans-unit id="6b4f14b977fdbe201544748c402fba9645dfd2c0" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-NOTIFICATION-MIB</source>
          <target state="translated">Приборостроительные функции для SNMP-NOTIFICATION-MIB</target>
        </trans-unit>
        <trans-unit id="6b69550b40cf6b05f4832bfe56c28495ecf7fe30" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-TARGET-MIB</source>
          <target state="translated">Приборостроительные функции для SNMP-TARGET-MIB</target>
        </trans-unit>
        <trans-unit id="f65fddfd52fcea283103e339d1c60b0f5ba6c122" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</source>
          <target state="translated">Приборостроительные функции для SNMP-USER-BASED-SM-MIB</target>
        </trans-unit>
        <trans-unit id="d49a7cc7da280cbfd346949bb2a603ee48e8fb05" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</source>
          <target state="translated">Приборостроительные функции для SNMP-VIEW-BASED-ACM-MIB</target>
        </trans-unit>
        <trans-unit id="d7f6a4f444ab301e6d5e54f70415dd52f590fae1" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</source>
          <target state="translated">Приборостроительные функции для STANDARD-MIB и SNMPv2-MIB</target>
        </trans-unit>
        <trans-unit id="e47c5f3c57120b008bbaac0ca750237faa5971be" translate="yes" xml:space="preserve">
          <source>Instrumentation can use Distributed Erlang to communicate with an application.</source>
          <target state="translated">Приборостроение может использовать распределенный Erlang для связи с приложением.</target>
        </trans-unit>
        <trans-unit id="d8e54e2e240bbb19f14b4c55bc3b487003ec8395" translate="yes" xml:space="preserve">
          <source>Instrumentation functions must be written for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; for scalar variables and tables, and for &lt;code&gt;get-next&lt;/code&gt; for tables only. The &lt;code&gt;get-bulk&lt;/code&gt; operation is translated into a series of calls to &lt;code&gt;get-next&lt;/code&gt;.</source>
          <target state="translated">Инструментальные функции должны быть написаны для &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;set&lt;/code&gt; для скалярных переменных и таблиц, а для &lt;code&gt;get-next&lt;/code&gt; - только для таблиц. Операция &lt;code&gt;get-bulk&lt;/code&gt; транслируется в серию вызовов &lt;code&gt;get-next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f47cc59656d4c025462d150f89cebf98c56ae3f" translate="yes" xml:space="preserve">
          <source>Insufficient storage space in system [452].</source>
          <target state="translated">Недостаточное пространство в системе [452].</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="bab8970ab6c1e2445db3a30cda08c3f08c7ba8ce" translate="yes" xml:space="preserve">
          <source>Integer (24 bits unsigned). Used to limit the size of valid TLS handshake packets to avoid DoS attacks. Defaults to 256*1024.</source>
          <target state="translated">Целое (24 бита без знака).Используется для ограничения размера действительных TLS квитирующих пакетов во избежание DoS-атак.По умолчанию 256*1024.</target>
        </trans-unit>
        <trans-unit id="cd1200dfbc2522df40f5135712d5fcc5350dab3d" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received message that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="translated">Целое число &lt;code&gt;PreviousSerial&lt;/code&gt; обозначает счетчик последовательного порта, переданный в последнем полученном сообщении, содержащем токен трассировки. Если процесс является первым в новой последовательной трассировке, &lt;code&gt;PreviousSerial&lt;/code&gt; устанавливается равным значению внутренних &amp;laquo;часов трассировки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fd0e21bf741b765fbb25882622616e5016575de7" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;ThisSerial&lt;/code&gt; is the serial counter that a process sets on outgoing messages. It is based on the process internal &quot;trace clock&quot;, which is incremented by one before it is attached to the trace token in the message.</source>
          <target state="translated">Integer &lt;code&gt;ThisSerial&lt;/code&gt; - это серийный счетчик, который процесс устанавливает для исходящих сообщений. Он основан на внутренних &amp;laquo;часах трассировки&amp;raquo; процесса, которые увеличиваются на единицу перед присоединением к токену трассировки в сообщении.</target>
        </trans-unit>
        <trans-unit id="70d648e65d494f28a7240688bec60fdcef36d372" translate="yes" xml:space="preserve">
          <source>Integer division</source>
          <target state="translated">Целостное подразделение</target>
        </trans-unit>
        <trans-unit id="ae4df4a5ccd3fc7872ad572de0cb764f4a758558" translate="yes" xml:space="preserve">
          <source>Integer remainder of X/Y</source>
          <target state="translated">Целочисленный остаток X/Y</target>
        </trans-unit>
        <trans-unit id="d2bea1d11037eb2c7d3d25da5484514181294970" translate="yes" xml:space="preserve">
          <source>Integer representing valid unicode codepoint.</source>
          <target state="translated">Целое число,представляющее действительную кодовую точку юникода.</target>
        </trans-unit>
        <trans-unit id="845b1adfda3fcd43e837ece8fd1075b9fd016964" translate="yes" xml:space="preserve">
          <source>Integer values, for example in the &lt;code&gt;SIZE&lt;/code&gt; expression must be entered in decimal syntax, not in hex or bit syntax.</source>
          <target state="translated">Целочисленные значения, например, в выражении &lt;code&gt;SIZE&lt;/code&gt; , должны вводиться в десятичном синтаксисе, а не в шестнадцатеричном или битовом синтаксисе.</target>
        </trans-unit>
        <trans-unit id="a84d8938ca4e58573de3fba8872fd63ef8c7c19d" translate="yes" xml:space="preserve">
          <source>Integer with the base &lt;strong&gt;&lt;code&gt;base&lt;/code&gt;&lt;/strong&gt;, that must be an integer in the range 2..36.</source>
          <target state="translated">Целое число с базовым &lt;strong&gt; &lt;code&gt;base&lt;/code&gt; &lt;/strong&gt; , которое должно быть целым числом в диапазоне 2..36.</target>
        </trans-unit>
        <trans-unit id="61e3decdf5d6115018a9e34ce42bf8006f9593cd" translate="yes" xml:space="preserve">
          <source>Integers must be in microseconds, meaning that the offset &lt;code&gt;7200000000&lt;/code&gt; is equivalent to &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt;.</source>
          <target state="translated">Целые числа должны быть в микросекундах, что означает, что смещение &lt;code&gt;7200000000&lt;/code&gt; эквивалентно &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c69ae2cd9192c2c796400efe2ac35c22e2e2ca5" translate="yes" xml:space="preserve">
          <source>Integers out of range.</source>
          <target state="translated">Интеграторы вне досягаемости.</target>
        </trans-unit>
        <trans-unit id="07e05e6c552c53b1a227c82d017e7aac90837347" translate="yes" xml:space="preserve">
          <source>Integers starting with 909, for example &lt;code&gt;9091&lt;/code&gt; or &lt;code&gt;909123&lt;/code&gt;</source>
          <target state="translated">Целые числа, начинающиеся с 909, например &lt;code&gt;9091&lt;/code&gt; или &lt;code&gt;909123&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60073de1e4b76eca2577f27a28edb01f36540075" translate="yes" xml:space="preserve">
          <source>Intended to facilitate testing.</source>
          <target state="translated">Предназначен для облегчения тестирования.</target>
        </trans-unit>
        <trans-unit id="9801faf88c32829ebf6c941dbb638428950801bd" translate="yes" xml:space="preserve">
          <source>Intended when ERTS, Kernel, STDLIB, or SASL is upgraded. It is automatically added when the &lt;code&gt;relup&lt;/code&gt; file is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. It is executed before all other upgrade instructions. For more information about this instruction, see restart_new_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Предназначен при обновлении ERTS, ядра, STDLIB или SASL. Он автоматически добавляется при &lt;code&gt;relup&lt;/code&gt; файла &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; помощью systools: make_relup / 3,4 . Он выполняется перед всеми остальными инструкциями по обновлению. Дополнительные сведения об этой инструкции см. В разделе restart_new_emulator (низкоуровневый) в &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="047073e3b4116ee04b74c0c1cc448bd79da99506" translate="yes" xml:space="preserve">
          <source>Intentionally left undocumented.</source>
          <target state="translated">Умышленно оставлены без документов.</target>
        </trans-unit>
        <trans-unit id="e997f694b62e9d0577171e2f7dc26f17597ee566" translate="yes" xml:space="preserve">
          <source>Inter Call Graph Edges (*).</source>
          <target state="translated">График Inter Call Graphges (*).</target>
        </trans-unit>
        <trans-unit id="eddaa29b2e62f4b03003dfe22bc83c780028fc16" translate="yes" xml:space="preserve">
          <source>Interaction data enforces module dependencies and is to be avoided if possible. This means that the order of modules in the modules property is significant.</source>
          <target state="translated">Взаимодействие данных приводит в исполнение зависимости от модуля,и его следует по возможности избегать.Это означает,что порядок расположения модулей в свойстве модулей является существенным.</target>
        </trans-unit>
        <trans-unit id="0a9935f358aacf056c71d573e766697caf72716e" translate="yes" xml:space="preserve">
          <source>Interface Functions for Secure Socket Layer</source>
          <target state="translated">Функции интерфейса для слоя защищенных сокетов</target>
        </trans-unit>
        <trans-unit id="b75e70d6d70b916e116f37e9c717c016fbc0e51b" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit MIB compiler</source>
          <target state="translated">Функции интерфейса к инструментарию SNMP компилятор MIB</target>
        </trans-unit>
        <trans-unit id="6f6bbd90e92a57397bbeedbddd3fab27ffbb44a4" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit agent</source>
          <target state="translated">Функции интерфейса к агенту набора инструментов SNMP</target>
        </trans-unit>
        <trans-unit id="8423a1ea8308683d2b47e96337afebc61ea2820a" translate="yes" xml:space="preserve">
          <source>Interface definitions between the client and the messenger</source>
          <target state="translated">Определения интерфейса между клиентом и мессенджером</target>
        </trans-unit>
        <trans-unit id="323c54cb50a9e3d1f4d686a59d1de38461683cb5" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit</source>
          <target state="translated">Функции интерфейса к инструментарию SNMP</target>
        </trans-unit>
        <trans-unit id="d20fd70153a1269fbf41940e196fc270f187a23c" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit manager</source>
          <target state="translated">Функции интерфейса к менеджеру инструментария SNMP</target>
        </trans-unit>
        <trans-unit id="ce6831520571e37fee954cd1b34f9e1abf7d82ff" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation.</source>
          <target state="translated">Интерфейсный модуль для проверки XML-схемы.</target>
        </trans-unit>
        <trans-unit id="050237493439e212d4bc538dddbf1f1eda8b5092" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation. It handles the W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; of XML Schema second edition 28 october 2004. For an introduction to XML Schema study &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; An XML structure is validated by xmerl_xsd:validate/[2,3].</source>
          <target state="translated">Модуль интерфейса для проверки XML-схемы. Он обрабатывает &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; W3.org второй редакции схемы XML от 28 октября 2004 г. Для введения в изучение схемы XML, &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; Структура XML проверяется с помощью xmerl_xsd: validate / [2,3].</target>
        </trans-unit>
        <trans-unit id="6e2ae4a4e371583e84ad62568aeaef5ba4469dae" translate="yes" xml:space="preserve">
          <source>Interface module for the &lt;code&gt;tftp&lt;/code&gt; application.</source>
          <target state="translated">Модуль интерфейса для приложения &lt;code&gt;tftp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca876b1a699869a57f784174cba40d788c67ea64" translate="yes" xml:space="preserve">
          <source>Interface module for the Event Trace (ET) application</source>
          <target state="translated">Интерфейсный модуль для приложения Event Trace (ET)</target>
        </trans-unit>
        <trans-unit id="45f7c5e26612823c7e6731913f85b1300e9ae4ce" translate="yes" xml:space="preserve">
          <source>Interface module for the Megaco application</source>
          <target state="translated">Интерфейсный модуль для приложения Megaco</target>
        </trans-unit>
        <trans-unit id="c936eb6df938f4d258995b26947dcddb7458ae2b" translate="yes" xml:space="preserve">
          <source>Interface module to TPKT transport protocol for Megaco/H.248.</source>
          <target state="translated">Интерфейсный модуль к транспортному протоколу TPKT для Megaco/H.248.</target>
        </trans-unit>
        <trans-unit id="27468964adda1f4dd990691916ff4a4d446a2e7d" translate="yes" xml:space="preserve">
          <source>Interface module to UDP transport protocol for Megaco/H.248.</source>
          <target state="translated">Интерфейсный модуль к транспортному протоколу UDP для Megaco/H.248.</target>
        </trans-unit>
        <trans-unit id="6d75c5c7c8f11fcc10b56585e807ce50cb617d4f" translate="yes" xml:space="preserve">
          <source>Interface module to the flex scanner linked in driver.</source>
          <target state="translated">Интерфейсный модуль к гибкому сканеру,связанный с драйвером.</target>
        </trans-unit>
        <trans-unit id="aacb400767c682f7416831e0737ea9f733b0c6c0" translate="yes" xml:space="preserve">
          <source>Interface to OS System Messages</source>
          <target state="translated">Интерфейс к системным сообщениям ОС</target>
        </trans-unit>
        <trans-unit id="2a76ee81e739df0dc00918ece6fa79aa9518edfe" translate="yes" xml:space="preserve">
          <source>Interface to TCP/IP sockets.</source>
          <target state="translated">Интерфейс к TCP/IP сокетам.</target>
        </trans-unit>
        <trans-unit id="cc16cc1cca26b8e2731cb9be496453c8f68c2df9" translate="yes" xml:space="preserve">
          <source>Interface to UDP sockets.</source>
          <target state="translated">Интерфейс к UDP-розеткам.</target>
        </trans-unit>
        <trans-unit id="96f6013ec56594333c06a3834e9c2473d15a18de" translate="yes" xml:space="preserve">
          <source>Interface to Windows Event Log</source>
          <target state="translated">Интерфейс к журналу регистрации событий Windows</target>
        </trans-unit>
        <trans-unit id="d4457db8b0de1c4d4686f8d6b2a56e3e9ab8095b" translate="yes" xml:space="preserve">
          <source>Interface to dynamic tracing</source>
          <target state="translated">Интерфейс динамического трассирования</target>
        </trans-unit>
        <trans-unit id="0716ba0b63e064bb3cb187f55a890a904447d9e9" translate="yes" xml:space="preserve">
          <source>Interface to standard Erlang I/O servers</source>
          <target state="translated">Интерфейс к стандартным серверам ввода/вывода Erlang</target>
        </trans-unit>
        <trans-unit id="43768b10820f3bcc951b6981b78de3c2c85818c7" translate="yes" xml:space="preserve">
          <source>Interface to the Erlang built-in term storage BIFs</source>
          <target state="translated">Интерфейс к встроенному срочному хранению BIF-файлов Erlang</target>
        </trans-unit>
        <trans-unit id="f672e9ac51285d0fd0e7e4843c6946df35242ba0" translate="yes" xml:space="preserve">
          <source>Internal Erlang definitions.</source>
          <target state="translated">Внутренние определения Эрланга.</target>
        </trans-unit>
        <trans-unit id="c43136ea5f7b358debf82f26c7522eae622f4bc8" translate="yes" xml:space="preserve">
          <source>Internal id for set of locks, not always unique. This could be table name for ets tables (db_tab), port id for ports, integer identifiers for allocators, etc.</source>
          <target state="translated">Внутренний идентификатор для набора замков,не всегда уникальный.Это может быть имя таблицы для таблиц ets (db_tab),идентификатор порта для портов,целочисленные идентификаторы для аллокаторов и др.</target>
        </trans-unit>
        <trans-unit id="341fa1e0f35c53a05146fef56f0f0dcefb3384e9" translate="yes" xml:space="preserve">
          <source>Internal server errors are recorded in the error log file. The format of this file is a more unplanned format than the logs using Common Logfile Format, but conforms to the following syntax:</source>
          <target state="translated">Ошибки внутреннего сервера записываются в файл журнала ошибок.Формат этого файла является более незапланированным по сравнению с журналами,использующими Общий формат журнала,но соответствует следующему синтаксису:</target>
        </trans-unit>
        <trans-unit id="3d37510d25e4b581b66d9a9103bd0c6f31ee62ee" translate="yes" xml:space="preserve">
          <source>Internal state of the channel.</source>
          <target state="translated">Внутреннее состояние канала.</target>
        </trans-unit>
        <trans-unit id="badfae6bbc42b495ad12bdff0f4b098f913dcb9a" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;Mnesia&lt;/code&gt; uses several commit protocols. The selected protocol depends on which table that has been updated in the transaction. If all the involved tables are symmetrically replicated (that is, they all have the same &lt;code&gt;ram_nodes&lt;/code&gt;, &lt;code&gt;disc_nodes&lt;/code&gt;, and &lt;code&gt;disc_only_nodes&lt;/code&gt; currently accessible from the coordinator node), a lightweight transaction commit protocol is used.</source>
          <target state="translated">Внутри &lt;code&gt;Mnesia&lt;/code&gt; использует несколько протоколов фиксации. Выбранный протокол зависит от того, какая таблица была обновлена ​​в транзакции. Если все задействованные таблицы симметрично реплицируются (то есть все они имеют одинаковые &lt;code&gt;ram_nodes&lt;/code&gt; , &lt;code&gt;disc_nodes&lt;/code&gt; и &lt;code&gt;disc_only_nodes&lt;/code&gt; , доступные в настоящее время из узла-координатора), используется упрощенный протокол фиксации транзакции.</target>
        </trans-unit>
        <trans-unit id="4be7390306e27edeab5e110ad71f96da0daba7a4" translate="yes" xml:space="preserve">
          <source>Internally a framework called &lt;code&gt;alloc_util&lt;/code&gt; is used for implementing allocators. &lt;code&gt;sys_alloc&lt;/code&gt; and &lt;code&gt;mseg_alloc&lt;/code&gt; do not use this framework, so the following does &lt;strong&gt;not&lt;/strong&gt; apply to them.</source>
          <target state="translated">Внутренне структура под названием &lt;code&gt;alloc_util&lt;/code&gt; используется для реализации распределителей. &lt;code&gt;sys_alloc&lt;/code&gt; и &lt;code&gt;mseg_alloc&lt;/code&gt; не используют эту структуру, поэтому следующее к ним &lt;strong&gt;не&lt;/strong&gt; относится.</target>
        </trans-unit>
        <trans-unit id="c426ea5b2618f0f6ae7be49919b9b54e05abea42" translate="yes" xml:space="preserve">
          <source>Internally in each priority level, processes are scheduled in a round robin fashion.</source>
          <target state="translated">Внутри каждого уровня приоритета процессы планируются круглосуточно.</target>
        </trans-unit>
        <trans-unit id="c41284ece411489ae5985686dd33bb0cf82727eb" translate="yes" xml:space="preserve">
          <source>Internally in the Erlang runtime system locks are used to protect resources from being updated from multiple threads in a fatal way. Locks are necessary to ensure that the runtime system works properly but it also introduces a couple of limitations. Lock contention and locking overhead.</source>
          <target state="translated">Внутренние системные блокировки во время выполнения Erlang используются для защиты ресурсов от фатального обновления из нескольких потоков.Блокировки необходимы для обеспечения корректной работы системы времени выполнения,но они также накладывают некоторые ограничения.Блокировка и накладные блокировки.</target>
        </trans-unit>
        <trans-unit id="7d74971bacf5510c7ab75585168e740293be593d" translate="yes" xml:space="preserve">
          <source>Internally in the runtime system, Erlang monotonic time is the &quot;time engine&quot; that is used for more or less everything that has anything to do with time. All timers, regardless of it is a &lt;code&gt;receive ... after&lt;/code&gt; timer, BIF timer, or a timer in the &lt;code&gt;timer(3)&lt;/code&gt; module, are triggered relative Erlang monotonic time. Even &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; is based on Erlang monotonic time. By adding current Erlang monotonic time with current time offset, you get current Erlang system time.</source>
          <target state="translated">Внутри исполняющей системы монотонное время Erlang является &amp;laquo;машиной времени&amp;raquo;, которая используется более или менее для всего, что имеет какое-либо отношение ко времени. Все таймеры, независимо от того, является ли это таймер &lt;code&gt;receive ... after&lt;/code&gt; таймер BIF или таймер в модуле &lt;code&gt;timer(3)&lt;/code&gt; , запускаются относительно монотонного времени Эрланга. Даже &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; основано на монотонном времени Эрланга. Добавляя текущее монотонное время Erlang к текущему смещению времени, вы получаете текущее системное время Erlang.</target>
        </trans-unit>
        <trans-unit id="a059bcd00d503bcbdc0046cbcdb9ce42b54025ec" translate="yes" xml:space="preserve">
          <source>Internally, binaries and bitstrings are implemented in the same way. In this section, they are called &lt;strong&gt;binaries&lt;/strong&gt; because that is what they are called in the emulator source code.</source>
          <target state="translated">Внутренне двоичные файлы и битовые строки реализуются одинаково. В этом разделе они называются &lt;strong&gt;двоичными файлами,&lt;/strong&gt; потому что именно так они называются в исходном коде эмулятора.</target>
        </trans-unit>
        <trans-unit id="f6f3359a916a2a0d142f95745652bdd812cac3df" translate="yes" xml:space="preserve">
          <source>Internally, records are represented using tagged tuples:</source>
          <target state="translated">Внутренние записи представлены с помощью кортежей с метками:</target>
        </trans-unit>
        <trans-unit id="dd2c83c9c4fac498df04ee4596255b013c52c14a" translate="yes" xml:space="preserve">
          <source>Internally, the supervisor also keeps track of the pid &lt;code&gt;Child&lt;/code&gt; of the child process, or &lt;code&gt;undefined&lt;/code&gt; if no pid exists.</source>
          <target state="translated">Внутри супервизор также отслеживает pid &lt;code&gt;Child&lt;/code&gt; дочернего процесса или &lt;code&gt;undefined&lt;/code&gt; , если pid не существует.</target>
        </trans-unit>
        <trans-unit id="3623dcb4995df517dc1119f9c1eac79892d03149" translate="yes" xml:space="preserve">
          <source>Internationalized domain names are not supported.</source>
          <target state="translated">Интернационализированные доменные имена не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="e68d66b86c5b372f203a16d7698b8bcac56dc8f3" translate="yes" xml:space="preserve">
          <source>Interpretable modules are modules for which a &lt;code&gt;.beam&lt;/code&gt; file, compiled with option &lt;code&gt;debug_info&lt;/code&gt; set, is located in the same directory as the source code, or in an &lt;code&gt;ebin&lt;/code&gt; directory next to it.</source>
          <target state="translated">Интерпретируемые модули - это модули, для которых файл &lt;code&gt;.beam&lt;/code&gt; , скомпилированный с установленной опцией &lt;code&gt;debug_info&lt;/code&gt; , находится в том же каталоге, что и исходный код, или в каталоге &lt;code&gt;ebin&lt;/code&gt; рядом с ним.</target>
        </trans-unit>
        <trans-unit id="11c3c6c74af70de4fbc0724c5fe96be415a45a08" translate="yes" xml:space="preserve">
          <source>Interpreter Interface.</source>
          <target state="translated">Интерфейс переводчика.</target>
        </trans-unit>
        <trans-unit id="d0145d7b897252f435c3a2f9b80c340bcaeb2cbd" translate="yes" xml:space="preserve">
          <source>Interprets it as universal time.</source>
          <target state="translated">интерпретирует его как универсальное время.</target>
        </trans-unit>
        <trans-unit id="ccdccf92f6f4b9eea51ade2820a3421f89b938c1" translate="yes" xml:space="preserve">
          <source>Interprets the escript regardless of the value of the mode attribute.</source>
          <target state="translated">Интерпретирует эскрипт независимо от значения атрибута режима.</target>
        </trans-unit>
        <trans-unit id="d062a6aaa1321b4fbe61ff2e8174819990ef6080" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;i/1&lt;/code&gt; interprets the module only at the current node. &lt;code&gt;ni/1&lt;/code&gt; interprets the module at all known nodes.</source>
          <target state="translated">Интерпретирует указанный модуль (модули). &lt;code&gt;i/1&lt;/code&gt; интерпретирует модуль только в текущем узле. &lt;code&gt;ni/1&lt;/code&gt; интерпретирует модуль на всех известных узлах.</target>
        </trans-unit>
        <trans-unit id="8f875d6a6ca694f0b14cea8f5848e9d0ba0a21ef" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;ii/1&lt;/code&gt; interprets the module(s) only at the current node, see &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ini/1&lt;/code&gt; interprets the module(s) at all known nodes, see &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует указанный модуль (модули). &lt;code&gt;ii/1&lt;/code&gt; интерпретирует модуль (модули) только на текущем узле, см. &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ini/1&lt;/code&gt; интерпретирует модуль (модули) на всех известных узлах, см. &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3729c738460ce5f6a85bafb8d5ebc52b2170ffc7" translate="yes" xml:space="preserve">
          <source>Interprets the time set as local.</source>
          <target state="translated">Интерпретирует установленное время как местное.</target>
        </trans-unit>
        <trans-unit id="a6a03664ff2ef589fe34431565963c09a8035a81" translate="yes" xml:space="preserve">
          <source>Intersecting an empty family exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">Пересечение пустого семейства завершает процесс с сообщением &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b56d0e04c45c4c2d5526cfbb776e3ab6ea16e89" translate="yes" xml:space="preserve">
          <source>Intersecting an empty set of sets exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">Пересечение пустого набора наборов завершает процесс с сообщением &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3aecd4f7ca9b10ba6eefdc3b3982ee51acbee86" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</source>
          <target state="translated">Введено в ERTS 8.1.2 (Erlang/OTP 19.2).</target>
        </trans-unit>
        <trans-unit id="e4185202e789e006e8d46cab5bb0f1344a5a2825" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</source>
          <target state="translated">Введено в ERTS 8.3 (Erlang/OTP 19.3)</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1e7228f13f302f91d97086fd99b6f4023b94b4ab" translate="yes" xml:space="preserve">
          <source>Invalid Subject Alternative Name extension.</source>
          <target state="translated">Недействительный Тема Альтернативное расширение имени.</target>
        </trans-unit>
        <trans-unit id="6dd22909406f536945b3651891eae0a11394eec6" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called &quot;surrogate&quot; codepoints), and 0xffef.</source>
          <target state="translated">Недействительными кодовыми точками Юникода являются кодовые точки в диапазоне от 0xd800 до 0xdfff (так называемые &quot;суррогатные&quot; кодовые точки)и 0xffef.</target>
        </trans-unit>
        <trans-unit id="970e02af50aef8057777e1e719234daf9ac3bd81" translate="yes" xml:space="preserve">
          <source>Invalid argument: &lt;code&gt;to&lt;/code&gt; is not a valid Erlang pid.</source>
          <target state="translated">Недопустимый аргумент: &lt;code&gt;to&lt;/code&gt; не является допустимым идентификатором Erlang.</target>
        </trans-unit>
        <trans-unit id="0cc909be0f2da4ba1a41bb22abd333ee5d822722" translate="yes" xml:space="preserve">
          <source>Invalid username or password.</source>
          <target state="translated">Неверное имя пользователя или пароль.</target>
        </trans-unit>
        <trans-unit id="e8f7b9edf2ca5bb757072a798bd0acfa87861234" translate="yes" xml:space="preserve">
          <source>Invalidate the mib server cache.</source>
          <target state="translated">Недействительность кэша сервера &quot;Миб&quot;.</target>
        </trans-unit>
        <trans-unit id="9759cc5e347da705fdd81203cf52cec5eb5adf6e" translate="yes" xml:space="preserve">
          <source>Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a &lt;code&gt;(?U)&lt;/code&gt; option setting within the pattern.</source>
          <target state="translated">Инвертирует &quot;жадность&quot; квантификаторов, чтобы они не были жадными по умолчанию, но становились жадными, если за ними стоит знак &quot;?&quot;. Он не совместим с Perl. Его также можно установить с помощью параметра &lt;code&gt;(?U)&lt;/code&gt; в шаблоне.</target>
        </trans-unit>
        <trans-unit id="6ce3b1ae867572c714bd282ce9e483e01b357834" translate="yes" xml:space="preserve">
          <source>Invoked for each transaction request</source>
          <target state="translated">Призван для каждого запроса транзакции</target>
        </trans-unit>
        <trans-unit id="3d01902a8b40974a69e9ea306fbe52a7b7185b83" translate="yes" xml:space="preserve">
          <source>Invoked when a connection is teared down</source>
          <target state="translated">Вызвано при разрыве соединения</target>
        </trans-unit>
        <trans-unit id="39559513e0fdc0d1c43b0c8be77af3afaf11b089" translate="yes" xml:space="preserve">
          <source>Invoked when a new connection is established</source>
          <target state="translated">Вызовется при установлении нового соединения</target>
        </trans-unit>
        <trans-unit id="aad6f32ab5334acc03c0b23cd1d9febffce28f41" translate="yes" xml:space="preserve">
          <source>Invoked when a received message had syntax errors</source>
          <target state="translated">Запрашивается,когда полученное сообщение содержит синтаксические ошибки.</target>
        </trans-unit>
        <trans-unit id="d768e80023291d60266531cb13740e0ce1f447c2" translate="yes" xml:space="preserve">
          <source>Invoked when a received message just contains an error instead of a list of transactions.</source>
          <target state="translated">Запрашивается,когда полученное сообщение просто содержит ошибку,а не список транзакций.</target>
        </trans-unit>
        <trans-unit id="f77eaeba46fb85e4b28b68f94f4e359f9e2851ee" translate="yes" xml:space="preserve">
          <source>Invoked when a transaction request has been aborted</source>
          <target state="translated">Призван,когда запрос на транзакцию отменен.</target>
        </trans-unit>
        <trans-unit id="cc89cd28b56040ba5e6a38dfd9e4d4df5cc8c73b" translate="yes" xml:space="preserve">
          <source>Invoked when a unexpected message is received</source>
          <target state="translated">Вызов при получении неожиданного сообщения.</target>
        </trans-unit>
        <trans-unit id="0af975defd697440d1ee7d6af73916790ab9bbc3" translate="yes" xml:space="preserve">
          <source>Invoked when the file transfer is aborted.</source>
          <target state="translated">Запрашивается при прерывании передачи файла.</target>
        </trans-unit>
        <trans-unit id="0427692fb99ce605340c28aa25be48c6566c62f3" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;et:trace_me/5&lt;/code&gt; with both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; set to &lt;code&gt;FromTo&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;et:trace_me/5&lt;/code&gt; , когда для &lt;code&gt;From&lt;/code&gt; и &lt;code&gt;To&lt;/code&gt; установлено значение &lt;code&gt;FromTo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d83df673697f3918f082f79e1172314cb5c6089b" translate="yes" xml:space="preserve">
          <source>Invokes a memory check and returns the resulting, system dependent, data as a list of tagged tuples, where &lt;code&gt;Tag&lt;/code&gt; can be one of the following:</source>
          <target state="translated">Вызывает проверку памяти и возвращает результирующие, зависящие от системы данные в виде списка помеченных кортежей, где &lt;code&gt;Tag&lt;/code&gt; может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="1100bbe70f71111dfc5fac73d1ff0bdf78d63a7b" translate="yes" xml:space="preserve">
          <source>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell can still be used.</source>
          <target state="translated">Вызывает старую оболочку Erlang из Erlang/OTP 3.3.Старая оболочка все еще может быть использована.</target>
        </trans-unit>
        <trans-unit id="36a3a3daec3816a0a8d74afe681df212e4a06b79" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; might fail, silently produce suboptimal code, or silently produce erroneous code.</source>
          <target state="translated">Вызов &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; может привести к сбою, тихо создать неоптимальный код или тихо создать ошибочный код.</target>
        </trans-unit>
        <trans-unit id="9b08f920d3a33d8317baaf4578d92c7eb8654fd5" translate="yes" xml:space="preserve">
          <source>IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</source>
          <target state="translated">IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="216b4a0c9222fc30988b436b2d5c7b661431663a" translate="yes" xml:space="preserve">
          <source>Irrelevant</source>
          <target state="translated">Irrelevant</target>
        </trans-unit>
        <trans-unit id="9d4e3fd7167bf46822004ff30d54f3257b464f0a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;0&lt;/code&gt; for a regular NIF (and so its value can be omitted for statically initialized &lt;code&gt;ErlNifFunc&lt;/code&gt; instances).</source>
          <target state="translated">Является &lt;code&gt;0&lt;/code&gt; для обычного NIF (и поэтому его значение может быть опущено для статически инициализируются &lt;code&gt;ErlNifFunc&lt;/code&gt; экземпляров).</target>
        </trans-unit>
        <trans-unit id="5b115b1ae7fa7943e2604056f2ecd826dceada9e" translate="yes" xml:space="preserve">
          <source>Is a list of column numbers in the case of a &lt;code&gt;get&lt;/code&gt; operation, and a list of column numbers and values in the case of a &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">Список номеров столбцов в случае операции &lt;code&gt;get&lt;/code&gt; и список номеров столбцов и значений в случае операции &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58f4eb42bb30362fe7878dc6d1c4495841ad13d1" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the meas.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">Лучше всего запускать,модифицируя скелетный скрипт meas.sh.skel,предоставляемый инструментом.</target>
        </trans-unit>
        <trans-unit id="c23fe05a88d02257549454dd15123c24fa32ea77" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the mstone1.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">Лучше всего запускается путем модификации скелетного скрипта mstone1.sh.skel,предоставляемого инструментом.</target>
        </trans-unit>
        <trans-unit id="87198e2f1c7806f1ad60ae76ac1d595598bf98a2" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;height&lt;/code&gt; is defined.</source>
          <target state="translated">Не учитывается, если задана &lt;code&gt;height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="269a41e3fe559c0e05b304e7b6c27b5566c39389" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;width&lt;/code&gt; is defined.</source>
          <target state="translated">Не учитывается, если задана &lt;code&gt;width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffe57a12bbaf259c034632c80ca23397143420b7" translate="yes" xml:space="preserve">
          <source>Is it possible to reduce the number of times the function is called?</source>
          <target state="translated">Можно ли уменьшить количество вызовов функции?</target>
        </trans-unit>
        <trans-unit id="e288cb6c9e74155297a40b276058aa6236c59a1c" translate="yes" xml:space="preserve">
          <source>Is the actual protocol version. In most cases the protocol version is retrieved from the processed message, but there are exceptions:</source>
          <target state="translated">Это фактическая версия протокола.В большинстве случаев версия протокола извлекается из обработанного сообщения,но есть исключения:</target>
        </trans-unit>
        <trans-unit id="b0588901bedfe37cbeecafd41fb2d74795460658" translate="yes" xml:space="preserve">
          <source>Is the flex scanner reentrant or not.</source>
          <target state="translated">Гибкий сканер возвращается или нет.</target>
        </trans-unit>
        <trans-unit id="1e9df40deeb13aac31ab4026e6e08e1f63bbae21" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt; же, что и файл (File, [verbose, report_errors, report_warnings]) .</target>
        </trans-unit>
        <trans-unit id="119f8a66ca64a5694cc3478ae4de46bcaf1a9423" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt; же, что и формы (Forms, [verbose, report_errors, report_warnings]) .</target>
        </trans-unit>
        <trans-unit id="fa3bd9e6b2f2c505e7347d749868eb9820f223c7" translate="yes" xml:space="preserve">
          <source>Is to be called by a client channel process to request that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end.</source>
          <target state="translated">Должен быть вызван клиентским канальным процессом,чтобы запросить,чтобы пользовательская оболочка по умолчанию (обычно определяемая в /etc/passwd в Unix-системах)была выполнена на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="7ceeac9a5465ffa310db9af05a50178436138dfb" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process for requesting to execute a predefined subsystem on the server.</source>
          <target state="translated">Вызывается клиентским каналом для запроса на выполнение предопределенной подсистемы на сервере.</target>
        </trans-unit>
        <trans-unit id="c26f3b86fc0054ade9e50cca18683944d8b10a73" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process to request that the server starts executing the given command. The result is several messages according to the following pattern. The last message is a channel close message, as the &lt;code&gt;exec&lt;/code&gt; request is a one-time execution that closes the channel when it is done.</source>
          <target state="translated">Вызывается процессом клиентского канала, чтобы запросить, чтобы сервер начал выполнение данной команды. В результате получается несколько сообщений по следующему шаблону. Последнее сообщение - это сообщение о закрытии канала, так как запрос &lt;code&gt;exec&lt;/code&gt; является однократным выполнением, которое закрывает канал, когда оно выполнено.</target>
        </trans-unit>
        <trans-unit id="0f5f5d78eb634db530f821ffb8bb8f751e62bff8" translate="yes" xml:space="preserve">
          <source>Is to be called by a server-channel process to send the exit status of a command to the client.</source>
          <target state="translated">Должен быть вызван процессом сервер-канал для отправки клиенту статуса выхода команды.</target>
        </trans-unit>
        <trans-unit id="d48b86257b47b5c4e3321d39134c0623cc1ea274" translate="yes" xml:space="preserve">
          <source>Is to be called by client- and server-channel processes to send data to each other.</source>
          <target state="translated">Должны быть вызваны клиентскими и серверными процессами для передачи данных друг другу.</target>
        </trans-unit>
        <trans-unit id="58c7c3af31214a2559fd6c1a8a5a15f560200d51" translate="yes" xml:space="preserve">
          <source>Is to be used as argument to &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;     Will be the return value of &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Используется как аргумент для &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; Будет возвращаемым значением &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="797fbc2978e0717dd29a9c7b419f35b1add8ae5d" translate="yes" xml:space="preserve">
          <source>Is to be used together with &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt;</source>
          <target state="translated">Используется вместе с &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cad8c95e87d4c8212862db03444550588eb9575a" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get next&lt;/code&gt; request.</source>
          <target state="translated">Выдает синхронный запрос на &lt;code&gt;get next&lt;/code&gt; протокола SNMP .</target>
        </trans-unit>
        <trans-unit id="341f83a51a550d204d993e9fdbc3e49fbf2fc850" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get&lt;/code&gt; request.</source>
          <target state="translated">Выдает синхронный запрос на &lt;code&gt;get&lt;/code&gt; SNMP .</target>
        </trans-unit>
        <trans-unit id="8c7f616c91a41fcdcd984c210b1ad39f21a4abe5" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;set&lt;/code&gt; request.</source>
          <target state="translated">Выдает синхронный запрос на &lt;code&gt;set&lt;/code&gt; SNMP .</target>
        </trans-unit>
        <trans-unit id="0768892d2762d9ec323c2e61d80bb2d335f194dd" translate="yes" xml:space="preserve">
          <source>Issuing this command starts the timer for this trace if option &lt;code&gt;timer&lt;/code&gt; is specified with &lt;code&gt;tracer/2&lt;/code&gt;.</source>
          <target state="translated">Выполнение этой команды запускает таймер для этой трассировки, если параметр &lt;code&gt;timer&lt;/code&gt; указан с помощью &lt;code&gt;tracer/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="527b024e0f1be9518973bad0f8b1a28cfc553cd1" translate="yes" xml:space="preserve">
          <source>It F is a family, it holds that F is a subset of &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt;. Equality holds if &lt;code&gt;union_of_family(F)&lt;/code&gt; is a subset of &lt;code&gt;domain(F)&lt;/code&gt;.</source>
          <target state="translated">Если F - семейство, то F является подмножеством &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt; . Равенство выполняется, если &lt;code&gt;union_of_family(F)&lt;/code&gt; является подмножеством &lt;code&gt;domain(F)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="348ecbd21ed63b96be9eb151353dced54f040940" translate="yes" xml:space="preserve">
          <source>It allows other tables to be replicated to this node.</source>
          <target state="translated">Это позволяет реплицировать на этот узел другие таблицы.</target>
        </trans-unit>
        <trans-unit id="502cbb23b6da4d09ac652d118086581df05059bf" translate="yes" xml:space="preserve">
          <source>It also initializes some SNMP counters.</source>
          <target state="translated">Он также инициализирует некоторые счетчики SNMP.</target>
        </trans-unit>
        <trans-unit id="0d3f428d2936ea84cb0649cae0490ba763c4555f" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;run_erl&lt;/code&gt;, which sets up things so the operator can attach to the system.</source>
          <target state="translated">Он вызывает &lt;code&gt;run_erl&lt;/code&gt; , который настраивает все, чтобы оператор мог подключиться к системе.</target>
        </trans-unit>
        <trans-unit id="6560322fa3ad293d5b242b322f5dac4de01df8c8" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;start_erl&lt;/code&gt;, which calls the correct version of &lt;code&gt;erlexec&lt;/code&gt; (which is located in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt;) with the correct &lt;code&gt;boot&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; files.</source>
          <target state="translated">Он вызывает &lt;code&gt;start_erl&lt;/code&gt; , который вызывает правильную версию &lt;code&gt;erlexec&lt;/code&gt; (которая находится в &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt; ) с правильными файлами &lt;code&gt;boot&lt;/code&gt; и &lt;code&gt;config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c0fc93fb15a2633f7d6c853cf154a0edd87bf6a" translate="yes" xml:space="preserve">
          <source>It can also be used from inside an Erlang program. If this ASN.1 code is defined in ASN.1 module &lt;code&gt;Values&lt;/code&gt;, the ASN.1 value &lt;code&gt;tt&lt;/code&gt; can be reached from Erlang as a function call to &lt;code&gt;'Values':tt()&lt;/code&gt; as in the following example:</source>
          <target state="translated">Его также можно использовать изнутри программы на Erlang. Если этот код ASN.1 определен в модуле &lt;code&gt;Values&lt;/code&gt; ASN.1, значение &lt;code&gt;tt&lt;/code&gt; ASN.1 может быть получено из Erlang как вызов функции для &lt;code&gt;'Values':tt()&lt;/code&gt; как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="cab601fee61bbc23a1da1dd5afb684daa2673400" translate="yes" xml:space="preserve">
          <source>It can be accessed as follows:</source>
          <target state="translated">К нему можно получить доступ следующим образом:</target>
        </trans-unit>
        <trans-unit id="c77546f4819cb51bf45faf9651c89e8f35e71626" translate="yes" xml:space="preserve">
          <source>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</source>
          <target state="translated">Может быть выгодно создавать реплики таблиц для распределенного приложения,которое часто читает данные,но редко записывает данные,для достижения операций быстрого чтения на локальном узле.Основным недостатком репликации является увеличение времени записи данных.Если таблица имеет две реплики,то каждая операция записи должна иметь доступ к обеим репликам таблицы.Поскольку одна из этих операций записи должна быть сетевой операцией,выполнение операции записи в реплицируемую таблицу значительно дороже,чем в не реплицируемую таблицу.</target>
        </trans-unit>
        <trans-unit id="3ecec720b0256b562180425a889c57f1514a840b" translate="yes" xml:space="preserve">
          <source>It can be appropriate to calculate the message digest before calling &lt;code&gt;sign&lt;/code&gt; or &lt;code&gt;verify&lt;/code&gt;, and then use &lt;code&gt;none&lt;/code&gt; as second argument:</source>
          <target state="translated">Это может быть целесообразно , чтобы вычислить дайджест сообщения перед вызовом &lt;code&gt;sign&lt;/code&gt; или &lt;code&gt;verify&lt;/code&gt; , а затем использовать &lt;code&gt;none&lt;/code&gt; в качестве второго аргумента:</target>
        </trans-unit>
        <trans-unit id="429a02b10011f23201ea705082a6734a13afe1dd" translate="yes" xml:space="preserve">
          <source>It can be required that your code must run on a variety of OTP installations of different OTP releases. If so, you cannot use the new API out of the box, as it will not be available on releases before OTP 18. The solution is &lt;strong&gt;not&lt;/strong&gt; to avoid using the new API, as your code would then not benefit from the scalability and accuracy improvements made. Instead, use the new API when available, and fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable.</source>
          <target state="translated">Может потребоваться, чтобы ваш код работал на различных установках OTP различных выпусков OTP. Если это так, вы не можете использовать новый API из коробки, так как он не будет доступен в выпусках до OTP 18. Решение состоит в &lt;strong&gt;том,&lt;/strong&gt; чтобы &lt;strong&gt;не&lt;/strong&gt; избегать использования нового API, так как ваш код не получит преимуществ от улучшений масштабируемости и точности. сделали. Вместо этого используйте новый API, когда он доступен, и вернитесь к &lt;code&gt;erlang:now/0&lt;/code&gt; , когда новый API недоступен.</target>
        </trans-unit>
        <trans-unit id="bfb69fb6c9632871f7941143462a0957b50d8dd0" translate="yes" xml:space="preserve">
          <source>It can be seen that the DBMS was initiated from a regular text file.</source>
          <target state="translated">Видно,что СУБД была инициирована из обычного текстового файла.</target>
        </trans-unit>
        <trans-unit id="e75e6728c619228a8a187725396b17bac62286a9" translate="yes" xml:space="preserve">
          <source>It can be useful to find the maximum and minimum temperature in lists like this. Before extending the program to do this, let us look at functions for finding the maximum value of the elements in a list:</source>
          <target state="translated">Полезно найти максимальную и минимальную температуру в таких списках.Перед расширением программы для этого рассмотрим функции поиска максимального значения элементов в списке:</target>
        </trans-unit>
        <trans-unit id="a8817b3a522907eb1d028eaf50da33a71ee687b3" translate="yes" xml:space="preserve">
          <source>It can be verified that sharing will be lost if the data is inserted into an Ets table:</source>
          <target state="translated">Можно проверить,что обмен будет потерян,если данные будут вставлены в таблицу Ets:</target>
        </trans-unit>
        <trans-unit id="27f936533cc1f942a4c17074d1665c908f8eec35" translate="yes" xml:space="preserve">
          <source>It can be:</source>
          <target state="translated">Может быть:</target>
        </trans-unit>
        <trans-unit id="16e18e41dba30df6f2a27da6db7356bd2d51bd66" translate="yes" xml:space="preserve">
          <source>It can optionally also export some, or all, of the following:</source>
          <target state="translated">По желанию он может также экспортировать некоторые или все из нижеперечисленных:</target>
        </trans-unit>
        <trans-unit id="8d39574d1fe984a33b1d8417902ff2e4fa04c224" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="translated">Иногда может быть полезно иметь возможность генерировать события для вашего собственного конечного автомата. Это можно сделать с помощью &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0df60d291abc2f1c1b6553af06070513493b119c" translate="yes" xml:space="preserve">
          <source>It can sometimes be helpful to enable trace for a specified period of time (for example, to monitor a system for 24 hours or half a second). This can be done with option &lt;code&gt;{timer, TimerSpec}&lt;/code&gt;. If &lt;code&gt;TimerSpec&lt;/code&gt; has the form of &lt;code&gt;MSec&lt;/code&gt;, the trace is stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds using &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt;. If more options are provided (&lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; is called instead with &lt;code&gt;Opts&lt;/code&gt; as argument.</source>
          <target state="translated">Иногда может быть полезно включить трассировку в течение определенного периода времени (например, для мониторинга системы в течение 24 часов или полсекунды). Это можно сделать с помощью опции &lt;code&gt;{timer, TimerSpec}&lt;/code&gt; . Если &lt;code&gt;TimerSpec&lt;/code&gt; имеет форму &lt;code&gt;MSec&lt;/code&gt; , трассировка останавливается после &lt;code&gt;MSec&lt;/code&gt; миллисекунд с использованием &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt; . Если предоставлены дополнительные параметры ( &lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt; ), вместо этого &lt;code&gt;Opts&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; с аргументом Opts .</target>
        </trans-unit>
        <trans-unit id="1166234dedafbc9026660c1e71ce391bf682d71c" translate="yes" xml:space="preserve">
          <source>It can vary from case to case which combination of selective/complete decode or exclusive/part decode is the fastest.</source>
          <target state="translated">В зависимости от случая,какая комбинация селективного/полного декодирования или эксклюзивного/частичного декодирования является самой быстрой.</target>
        </trans-unit>
        <trans-unit id="b21d9b21f8fd67733cf908cf5de319a682227acf" translate="yes" xml:space="preserve">
          <source>It cannot retrieve external entities on the Internet by a URL reference, only resources in the local file system.</source>
          <target state="translated">Он не может получить внешние сущности в Интернете по ссылке URL,только ресурсы в локальной файловой системе.</target>
        </trans-unit>
        <trans-unit id="16ad56b9e963d65cee1d6e784ab67ae9a7a2c796" translate="yes" xml:space="preserve">
          <source>It causes &lt;code&gt;Mnesia&lt;/code&gt; to try to contact the node at startup of disc-full nodes.</source>
          <target state="translated">Это заставляет &lt;code&gt;Mnesia&lt;/code&gt; пытаться связаться с узлом при запуске узлов, заполненных диском.</target>
        </trans-unit>
        <trans-unit id="f72ebd5459698111bb78002fb36494deb48145f4" translate="yes" xml:space="preserve">
          <source>It could also be a late reply to a synchronous request.</source>
          <target state="translated">Это также может быть поздним ответом на синхронный запрос.</target>
        </trans-unit>
        <trans-unit id="c3698cc734ccb5f61d3ae21369086bfe0bd5a1e8" translate="yes" xml:space="preserve">
          <source>It does not really implement any management capabilities by itself. That is up to the &lt;strong&gt;user&lt;/strong&gt;.</source>
          <target state="translated">Сам по себе он не реализует никаких возможностей управления. Это зависит от &lt;strong&gt;пользователя&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2f06f024f140f97af334f2f96d37458dba2e893a" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Он не устанавливает никаких &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; а вместо этого отвечает вызывающему абоненту, ожидающему ответа в &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;From&lt;/code&gt; должен быть термином from аргумент &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; в вызове &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7017aa44c3506907262780fe0caea30cac852593" translate="yes" xml:space="preserve">
          <source>It has been implemented on top of the User Datagram protocol (UDP) so it may be used to move files between machines on different networks implementing UDP. It is designed to be small and easy to implement. Therefore, it lacks most of the features of a regular FTP. The only thing it can do is read and write files (or mail) from/to a remote server. It cannot list directories, and currently has no provisions for user authentication.</source>
          <target state="translated">Он был реализован поверх протокола пользовательской датаграммы (UDP),поэтому его можно использовать для перемещения файлов между компьютерами в различных сетях,реализующих UDP.Он спроектирован таким образом,чтобы быть небольшим и простым в реализации.Поэтому ему не хватает большинства функций обычного FTP.Единственное,что он может делать-это читать и записывать файлы (или почту)с/на удаленный сервер.Он не может перечислять каталоги,и в настоящее время не имеет положений для аутентификации пользователей.</target>
        </trans-unit>
        <trans-unit id="3f8d75bfb90a8936251b79f719fa6e9b6f94c3d3" translate="yes" xml:space="preserve">
          <source>It has previously been shown that each table has a number of system attributes, such as &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Ранее было показано, что каждая таблица имеет ряд системных атрибутов, таких как &lt;code&gt;index&lt;/code&gt; и &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbd5032f06df0ef2f2a99e589085d981c5bc3619" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;true&lt;/code&gt; if the predicate applied to all elements in the list is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Это &lt;code&gt;true&lt;/code&gt; , если предикат применяется ко всем элементам в списке &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0472f06f57f61fb910d5f2746c6db12d6bf0beef" translate="yes" xml:space="preserve">
          <source>It is a channel callback module that implements a shell and command execution. The shell's read-eval-print loop can be customized, using the option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt;. This means less work than implementing an own CLI channel. If &lt;code&gt;ssh_cli&lt;/code&gt; is set to &lt;code&gt;no_cli&lt;/code&gt;, the CLI channels like &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are disabled and only subsystem channels are allowed.</source>
          <target state="translated">Это модуль обратного вызова канала, который реализует оболочку и выполнение команд. Цикл оболочки чтение-оценка-печать может быть настроен с помощью опции &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; . Это означает меньше работы, чем реализация собственного канала CLI. Если &lt;code&gt;ssh_cli&lt;/code&gt; установлен в &lt;code&gt;no_cli&lt;/code&gt; , каналы CLI, такие как &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , отключены, и разрешены только каналы подсистемы.</target>
        </trans-unit>
        <trans-unit id="9cfea932baea2333d069d06996afd05ae69495a2" translate="yes" xml:space="preserve">
          <source>It is a dump from an old OTP release in which this item was not written.</source>
          <target state="translated">Это дамп из старого OTP-релиза,в котором этот пункт не был написан.</target>
        </trans-unit>
        <trans-unit id="e3c2eb9542657da53e8c70e8a085ab3bd63983e1" translate="yes" xml:space="preserve">
          <source>It is advised for compilers to remove all non-deterministic information if the &lt;code&gt;deterministic&lt;/code&gt; option is supported and it was supplied by the user.</source>
          <target state="translated">Компиляторам рекомендуется удалить всю недетерминированную информацию, если &lt;code&gt;deterministic&lt;/code&gt; опция поддерживается и была предоставлена ​​пользователем.</target>
        </trans-unit>
        <trans-unit id="bdc959811bb36191808503a6fa15bf4c4b73e490" translate="yes" xml:space="preserve">
          <source>It is allowed to omit &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Stacktrace&lt;/code&gt;. An omitted &lt;code&gt;Class&lt;/code&gt; is shorthand for &lt;code&gt;throw&lt;/code&gt;:</source>
          <target state="translated">Допускается опускать &lt;code&gt;Class&lt;/code&gt; и &lt;code&gt;Stacktrace&lt;/code&gt; . Пропущенный &lt;code&gt;Class&lt;/code&gt; - это сокращение от &lt;code&gt;throw&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="abf6d7124954bad38d134fedee149371dc306be5" translate="yes" xml:space="preserve">
          <source>It is also assumed that in the home directory of &lt;code&gt;otpuser&lt;/code&gt;, there is a directory named &lt;code&gt;otp&lt;/code&gt;, the full path of which is:</source>
          <target state="translated">Также предполагается, что в домашнем каталоге &lt;code&gt;otpuser&lt;/code&gt; есть каталог с именем &lt;code&gt;otp&lt;/code&gt; , полный путь к которому:</target>
        </trans-unit>
        <trans-unit id="9c70f3b40e4a761a37740b02e2f452d7fdd283c0" translate="yes" xml:space="preserve">
          <source>It is also necessary to take care of the types &lt;code&gt;ERL_ERROR&lt;/code&gt; (an error occurred) and &lt;code&gt;ERL_TICK&lt;/code&gt; (alive check from other node, is to be ignored). Other possible types indicate process events such as link, unlink, and exit:</source>
          <target state="translated">Также необходимо позаботиться о типах &lt;code&gt;ERL_ERROR&lt;/code&gt; (произошла ошибка) и &lt;code&gt;ERL_TICK&lt;/code&gt; (проверка работоспособности с другого узла, игнорируется). Другие возможные типы указывают на события процесса, такие как связь, разъединение и выход:</target>
        </trans-unit>
        <trans-unit id="c5a50cd1bdb197fcc39af462f4c2f62a0631dfb0" translate="yes" xml:space="preserve">
          <source>It is also of interest to know the relation is between a complete decode, an exclusive decode followed by &lt;code&gt;decode_part&lt;/code&gt; of the excluded parts, and a selective decode followed by a complete decode. Some situations can be compared to this simulation, for example, inspect a subvalue and later inspect the entire value. The following table shows figures from this test. The number of loops and the time unit are the same as in the previous test.</source>
          <target state="translated">Также интересно знать, что существует связь между полным декодированием, исключительным декодированием, за которым следует &lt;code&gt;decode_part&lt;/code&gt; исключенных частей, и выборочным декодированием, за которым следует полное декодирование. Некоторые ситуации можно сравнить с этой симуляцией, например, проверить подзначение, а затем проверить все значение. В следующей таблице показаны цифры этого теста. Количество петель и единица времени такие же, как в предыдущем тесте.</target>
        </trans-unit>
        <trans-unit id="430745d1b00721c91adf6b7795f4d85575fbbdfd" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; directly from the normal Erlang shell prompt:</source>
          <target state="translated">Также можно вызвать &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; непосредственно из обычного приглашения оболочки Erlang:</target>
        </trans-unit>
        <trans-unit id="b17c759d73ecb8e47a8732d667bdc184b493889c" translate="yes" xml:space="preserve">
          <source>It is also possible to dig deeper and, for example, perform pattern matching on the various reasons for skipped or failed. Notice that &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; tuples are translated into &lt;code&gt;{error,Reason}&lt;/code&gt;. Notice also that if a &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; result is received, the test case was successful, but &lt;code&gt;end_per_testcase&lt;/code&gt; for the case failed.</source>
          <target state="translated">Также можно копнуть глубже и, например, выполнить сопоставление с образцом по различным причинам пропуска или сбоя. Обратите внимание, что кортежи &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; переводятся в &lt;code&gt;{error,Reason}&lt;/code&gt; . Также обратите внимание, что если &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; результат {failed, {Suite, end_per_testcase, FailInfo} , тестовый пример был успешным, но &lt;code&gt;end_per_testcase&lt;/code&gt; для этого случая не прошел.</target>
        </trans-unit>
        <trans-unit id="f8151f1eae3c7a350004aaaa46abaeee77adbcc2" translate="yes" xml:space="preserve">
          <source>It is also possible to do further processing of parsed XML with xmerl. If you want to change format of the XML document to for instance HTML, text or other XML format you can transform it. There is support for such transformations in xmerl.</source>
          <target state="translated">Можно также делать дальнейшую обработку разобранного XML с помощью xmerl.Если вы хотите изменить формат XML документа,например,на HTML,текст или другой формат XML,вы можете преобразовать его.В xmerl существует поддержка таких преобразований.</target>
        </trans-unit>
        <trans-unit id="14975a2ed99f645727531a93c1fa136da016d57c" translate="yes" xml:space="preserve">
          <source>It is also possible to import MIBs from OTP applications in an &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; like fashion with the &lt;code&gt;il&lt;/code&gt; option. Example:</source>
          <target state="translated">Также можно импортировать MIB из приложений OTP в стиле &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; с опцией &lt;code&gt;il&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="9aa704896d79235d85aad0da0fabd9cf784e3fd6" translate="yes" xml:space="preserve">
          <source>It is also possible to make the parser ask for more input tokens when needed if the following call format is used:</source>
          <target state="translated">Также при необходимости можно заставить парсер запросить дополнительные маркеры ввода,если используется следующий формат вызова:</target>
        </trans-unit>
        <trans-unit id="0c383d15045b8504152e045fd9c571fda9d5f908" translate="yes" xml:space="preserve">
          <source>It is also possible to perform live tracing of a running system by making use of the built-in trace support in the Erlang emulator. These Erlang traces can be directed to files or to ports. See the reference manual for &lt;code&gt;erlang:trace/4&lt;/code&gt;, &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;, &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;ttb&lt;/code&gt; for more info.</source>
          <target state="translated">Также возможно выполнить трассировку работающей системы в реальном времени, используя встроенную поддержку трассировки в эмуляторе Erlang. Эти трассировки Erlang могут быть направлены в файлы или в порты. См. Справочное руководство для &lt;code&gt;erlang:trace/4&lt;/code&gt; , &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; , &lt;code&gt;dbg&lt;/code&gt; и &lt;code&gt;ttb&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="41ebfd44811c7419cd9574f7d7d60c6961c05cc8" translate="yes" xml:space="preserve">
          <source>It is also possible to push back characters into the input characters with the following returns:</source>
          <target state="translated">Также возможно вставить обратно символы во входные символы со следующими возвратами:</target>
        </trans-unit>
        <trans-unit id="05fa2dcff8f4128cd8ba172c0c2e9803bd23c257" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to a function defined in a different module, with the following syntax:</source>
          <target state="translated">Можно также сослаться на функцию,определенную в другом модуле,со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="20722acbae34522cf86f97ada05f47778507e40b" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section.</source>
          <target state="translated">Можно также обратиться к более поздним открытым скобкам,написав ссылки типа (?+2).Однако они не могут быть рекурсивными,так как ссылка не заключена в круглые скобки,на которые сделана ссылка.Они всегда являются не рекурсивными вызовами подпрограмм,как описано в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="1bc8e55a741fd982875922535be0a290d5e493ac" translate="yes" xml:space="preserve">
          <source>It is also possible to specify names and values for extra variables that should be sent in the notification, but were not defined in the notification specification.</source>
          <target state="translated">Также можно указать имена и значения дополнительных переменных,которые должны быть отправлены в уведомлении,но не были определены в спецификации уведомления.</target>
        </trans-unit>
        <trans-unit id="e96afe727ef3a6cdba9249f88e9858694c628d45" translate="yes" xml:space="preserve">
          <source>It is also possible to trace immediately into the profiling process that creates the raw profile data, that is to short circuit the tracing and profiling steps so that the filesystem is not used.</source>
          <target state="translated">Можно также немедленно проследить процесс профилирования,который создает необработанные данные профиля,т.е.замыкает этапы трассировки и профилирования,чтобы файловая система не использовалась.</target>
        </trans-unit>
        <trans-unit id="38d9bdad443276567d85de0b3d4b695aa8af5458" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process and this section describes how to do that.</source>
          <target state="translated">Также можно написать свою собственную сеть,если это необходимо,и в этом разделе описано,как это сделать.</target>
        </trans-unit>
        <trans-unit id="0443424fb9ad4a6013fc87f7edd777ad9e3ed640" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process. The default Net if process is implemented in the module &lt;code&gt;snmpa_net_if&lt;/code&gt; and it uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;.</source>
          <target state="translated">Также возможно написать свой собственный Net if process. По умолчанию процесс Net if реализован в модуле &lt;code&gt;snmpa_net_if&lt;/code&gt; и использует UDP в качестве транспортного протокола, то есть транспортные домены &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; и / или &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38b9346e442ee7340bad67270cc18e9b0d13905f" translate="yes" xml:space="preserve">
          <source>It is also possible, in &lt;code&gt;end_per_group/2&lt;/code&gt;, to check the status of a subgroup (maybe to determine what status the current group is to return). This is as simple as illustrated in the previous example, only the group name is stored in a tuple &lt;code&gt;{group_result,GroupName}&lt;/code&gt;, which can be searched for in the status lists.</source>
          <target state="translated">Также можно в &lt;code&gt;end_per_group/2&lt;/code&gt; проверить статус подгруппы (возможно, чтобы определить, какой статус должна вернуть текущая группа). Это очень просто, как показано в предыдущем примере, только имя группы сохраняется в кортеже &lt;code&gt;{group_result,GroupName}&lt;/code&gt; , который можно искать в списках состояний.</target>
        </trans-unit>
        <trans-unit id="ef03b90d92e28fc57662f95ab1cf5a610f370745" translate="yes" xml:space="preserve">
          <source>It is also recommended that the &lt;code&gt;ct.hrl&lt;/code&gt; header file is included in all test suite modules.</source>
          <target state="translated">Также рекомендуется, чтобы &lt;code&gt;ct.hrl&lt;/code&gt; заголовка ct.hrl был включен во все модули набора тестов.</target>
        </trans-unit>
        <trans-unit id="313a7e4451fc081efeaa2c6bb4fb1dfc6f14d0a1" translate="yes" xml:space="preserve">
          <source>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function &lt;code&gt;raise(Name, Amount)&lt;/code&gt;, which adds &lt;code&gt;Amount&lt;/code&gt; to the salary field of a person, is to be implemented as follows:</source>
          <target state="translated">Также полезно обновлять базу данных внутри транзакции, если несколько процессов одновременно обновляют одни и те же записи. Например, функция &lt;code&gt;raise(Name, Amount)&lt;/code&gt; , которая добавляет &lt;code&gt;Amount&lt;/code&gt; в поле зарплаты человека, должна быть реализована следующим образом:</target>
        </trans-unit>
        <trans-unit id="4b6eccdabde840ecd1e02e1dfcae25d7936cafd7" translate="yes" xml:space="preserve">
          <source>It is also worth to keep in mind that programs with timers can behave differently when debugged. This is especially true when stopping the execution of a process (for example, at a breakpoint). Time-outs can then occur in other processes that continue execution as normal.</source>
          <target state="translated">Стоит также помнить,что программы с таймерами могут вести себя по-разному при отладке.Это особенно актуально при остановке выполнения процесса (например,в точке останова).Тайм-ауты могут затем возникать в других процессах,которые продолжают выполняться как обычно.</target>
        </trans-unit>
        <trans-unit id="de21ba3a5d42796cea74d79d5a22659949031529" translate="yes" xml:space="preserve">
          <source>It is an error if not all of the characters in &lt;code&gt;String&lt;/code&gt; are consumed.</source>
          <target state="translated">Это ошибка, если не все символы в &lt;code&gt;String&lt;/code&gt; используются.</target>
        </trans-unit>
        <trans-unit id="1169d92cb2cd8a5d121fb5cf87770320a1885975" translate="yes" xml:space="preserve">
          <source>It is assigned a value in Erlang as follows:</source>
          <target state="translated">Ему присваивается значение в Erlang следующим образом:</target>
        </trans-unit>
        <trans-unit id="4b026425ce0c7a9d0f11df724a1d98610d0783ee" translate="yes" xml:space="preserve">
          <source>It is assumed that drivers do not access other drivers. If drivers access each other, they must provide their own mechanism for thread-safe synchronization. Such &quot;inter-driver communication&quot; is strongly discouraged.</source>
          <target state="translated">Предполагается,что драйверы не имеют доступа к другим драйверам.Если драйверы обращаются друг к другу,они должны предоставить свой собственный механизм потокобезопасной синхронизации.Такая &quot;межпотоковая связь&quot; настоятельно не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="00523370ed1fef973a609af025d17f8d7fd78abb" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader has done some programming and is familiar with concepts such as data types and programming language syntax.</source>
          <target state="translated">Предполагается,что читатель выполнил некоторое программирование и знаком с такими понятиями,как типы данных и синтаксис языка программирования.</target>
        </trans-unit>
        <trans-unit id="539ca4643ea98ae299a95a5eae96dbefe42276e2" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language and has a basic understanding of the concepts of using public-keys and digital certificates.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang и имеет базовое понимание концепций использования публичных ключей и цифровых сертификатов.</target>
        </trans-unit>
        <trans-unit id="a6052ded16f1143a2540c6e38a39ca5ce2ceee2c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of &lt;strong&gt;OTP&lt;/strong&gt;, and has a basic understanding of &lt;strong&gt;public keys&lt;/strong&gt;.</source>
          <target state="translated">Предполагается, что читатель знаком с языком программирования Erlang, концепциями &lt;strong&gt;OTP&lt;/strong&gt; и имеет базовые представления об &lt;strong&gt;открытых ключах&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="243320d766e4df468a34184aedf16e004fb9c770" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic knowledge of SNMP.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,понятиями OTP и имеет базовые знания о SNMP.</target>
        </trans-unit>
        <trans-unit id="367f5b39b966ad211fd31d9fe4e051b0012e6562" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic understanding of relational databases and SQL.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,понятиями OTP и имеет базовые знания о реляционных базах данных и SQL.</target>
        </trans-unit>
        <trans-unit id="c531f58d242ffa0ef29281ed62ced9b43c4c5836" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of and HTTP protocol.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,понятиями OTP,имеет базовое понимание и протокол HTTP.</target>
        </trans-unit>
        <trans-unit id="226cdb7652f0e63605e771f89f0979cf6a181d4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the FTP protocol.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,понятиями OTP и имеет базовое понимание протокола FTP.</target>
        </trans-unit>
        <trans-unit id="ffe91dc03e0f170b97f84ca7d684803118d71efd" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the TFTP protocol.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,понятиями OTP и имеет базовое понимание протокола TFTP.</target>
        </trans-unit>
        <trans-unit id="6ad11381560d09325d3341cb53cee49377ce9e91" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and is familiar with the ASN.1 notation. The ASN.1 notation is documented in the standard definition X.680, which is the primary text. It can also be helpful, but not necessary, to read the standard definitions X.681, X.682, X.683, X.690, and X.691.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,концепциями OTP и знаком с нотацией ASN.1.Нотация ASN.1 документируется в стандартном определении X.680,который является основным текстом.Также может быть полезно,но не обязательно,прочитать стандартные определения X.681,X.682,X.683,X.690 и X.691.</target>
        </trans-unit>
        <trans-unit id="f994e3d36186bc56a3b0c41d4317147ad16d939f" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, system development principles, and database management systems.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,принципами разработки систем и системами управления базами данных.</target>
        </trans-unit>
        <trans-unit id="c80c2b6f4e39beead5852bafd919144c58cd0f95" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of SSL/TLS/DTLS.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang,понятиями OTP и имеет базовое понимание SSL/TLS/DTLS.</target>
        </trans-unit>
        <trans-unit id="196722391e42a0afccee28b3efb0c6e7a2974b84" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language.</source>
          <target state="translated">Предполагается,что читатель знаком с языком программирования Erlang.</target>
        </trans-unit>
        <trans-unit id="b881451c83c7ede35a49713311b8b3c77d21da3f" translate="yes" xml:space="preserve">
          <source>It is assumed that tracing has already been enabled (see &lt;code&gt;enable_trace&lt;/code&gt; above).</source>
          <target state="translated">Предполагается, что трассировка уже включена (см. &lt;code&gt;enable_trace&lt;/code&gt; выше).</target>
        </trans-unit>
        <trans-unit id="fbce7d0b5c1d3d362c2e0e3170d2a81ddcc3cae0" translate="yes" xml:space="preserve">
          <source>It is assumed that you are a skilled Erlang programmer, familiar with concepts such as Erlang data types, processes, messages, and error handling.</source>
          <target state="translated">Предполагается,что вы опытный программист Erlang,знакомый с такими концепциями,как типы данных,процессы,сообщения и обработка ошибок Erlang.</target>
        </trans-unit>
        <trans-unit id="46d05879b990c1b42f80173e3ce33f9af16334ea" translate="yes" xml:space="preserve">
          <source>It is assumed that you are familiar with the Erlang programming language and the OTP concepts.</source>
          <target state="translated">Предполагается,что вы знакомы с языком программирования Erlang и концепциями OTP.</target>
        </trans-unit>
        <trans-unit id="c59fc60f5301a42fa897f9e86ad129262fbe9775" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a good understanding of drivers.</source>
          <target state="translated">Предполагается,что вы хорошо разбираетесь в водителях.</target>
        </trans-unit>
        <trans-unit id="57d587d7dcd33bf268c53e8c295b7bbd98dd5a25" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a working Erlang/OTP system structured according to the OTP design principles.</source>
          <target state="translated">Предполагается,что у вас есть работающая система Erlang/OTP,структурированная в соответствии с принципами проектирования OTP.</target>
        </trans-unit>
        <trans-unit id="65b8a74dc8b2985b7d8ff2f06c5800ab5b031e0b" translate="yes" xml:space="preserve">
          <source>It is called before scheme string gets converted into scheme atom and thus possible atom leak could be prevented</source>
          <target state="translated">Она вызывается до того,как строка схемы преобразуется в атом схемы,и таким образом можно предотвратить возможную утечку атома.</target>
        </trans-unit>
        <trans-unit id="9008c50a0a551cbb25d9ec24896b64ea9a564251" translate="yes" xml:space="preserve">
          <source>It is common that ASN.1 modules import defined types, values, and other entities from another ASN.1 module.</source>
          <target state="translated">Обычно модули ASN.1 импортируют определенные типы,значения и другие сущности из другого модуля ASN.1.</target>
        </trans-unit>
        <trans-unit id="84117e18953c312000f68fd2f9a76688512ad635" translate="yes" xml:space="preserve">
          <source>It is easy to design applications that use SNMP to manipulate and control the system. &lt;code&gt;Mnesia&lt;/code&gt; provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a &lt;code&gt;Mnesia&lt;/code&gt; table. The default value is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Легко создавать приложения, использующие SNMP для управления системой. &lt;code&gt;Mnesia&lt;/code&gt; обеспечивает прямое соответствие между логическими таблицами, составляющими приложение управления SNMP, и физическими данными, составляющими таблицу &lt;code&gt;Mnesia&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cce76fb9ee4c72d8c84f9435e857ad958e3bb420" translate="yes" xml:space="preserve">
          <source>It is easy to make mistakes when registering sub-agents and this activity should be done carefully. For example, a strange behaviour would result from the following configuration:</source>
          <target state="translated">Ошибки при регистрации субагентов легко допускаются,и эта работа должна выполняться с особой тщательностью.Например,странное поведение может быть вызвано следующей конфигурацией:</target>
        </trans-unit>
        <trans-unit id="b4c9710b1e208fb15c3da52130d4225c07e26a51" translate="yes" xml:space="preserve">
          <source>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function &lt;code&gt;get_emps/2&lt;/code&gt; is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</source>
          <target state="translated">Легко показать примеры кода, который выполняется быстрее, если используется ненормализованная модель данных вместо нормализованной модели. Основная причина в том, что требуется меньше таблиц. Таким образом, данные из разных таблиц можно легче объединить в операциях соединения. В предыдущем примере функция &lt;code&gt;get_emps/2&lt;/code&gt; преобразуется из операции соединения в простой запрос, который состоит из выбора и проекции на одну единственную таблицу.</target>
        </trans-unit>
        <trans-unit id="da800d6ee148efa5e9b76c02de805a669c995873" translate="yes" xml:space="preserve">
          <source>It is encouraged to omit empty directories.</source>
          <target state="translated">Рекомендуется опустить пустые каталоги.</target>
        </trans-unit>
        <trans-unit id="f598ee38e63f95f13ae4c91139c94c9acddbba8b" translate="yes" xml:space="preserve">
          <source>It is enough to initialize &lt;code&gt;myKey&lt;/code&gt; once for each driver instance.</source>
          <target state="translated">Достаточно &lt;code&gt;myKey&lt;/code&gt; раз инициализировать myKey для каждого экземпляра драйвера.</target>
        </trans-unit>
        <trans-unit id="09d13ede3ec03425733048bb49466428e4cde9a4" translate="yes" xml:space="preserve">
          <source>It is expected that the type language described in this section supersedes and replaces the purely comment-based &lt;code&gt;@type&lt;/code&gt; and &lt;code&gt;@spec&lt;/code&gt; declarations used by EDoc.</source>
          <target state="translated">Ожидается, что язык типов, описанный в этом разделе, заменяет и заменяет исключительно основанные на &lt;code&gt;@spec&lt;/code&gt; объявления &lt;code&gt;@type&lt;/code&gt; и @spec, используемые EDoc.</target>
        </trans-unit>
        <trans-unit id="bd88b807c9b8b49f6a04c0814a09c4643a76b579" translate="yes" xml:space="preserve">
          <source>It is fairly easy to write a generator which, each time it is called, either produces an empty list if it is done, or otherwise produces a list containing a single test case plus a new generator which will produce the rest of the tests. This demonstrates the basic pattern:</source>
          <target state="translated">Довольно легко написать генератор,который при каждом вызове либо формирует пустой список,если это сделано,либо иным образом формирует список,содержащий один тестовый случай плюс новый генератор,который будет производить остальные тесты.Это демонстрирует основной шаблон:</target>
        </trans-unit>
        <trans-unit id="216d3558427ea98e53bf41b5f47e9b9d46bf1da8" translate="yes" xml:space="preserve">
          <source>It is good programming practice, but not mandatory, to ensure that a macro definition is a valid Erlang syntactic form.</source>
          <target state="translated">Хорошей практикой программирования,но не обязательной,является обеспечение того,что определение макроса является действительной синтаксической формой Erlang.</target>
        </trans-unit>
        <trans-unit id="658c926a7a3ff092c88e185ba8a44d03268b9b65" translate="yes" xml:space="preserve">
          <source>It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when &lt;code&gt;init_table/2&lt;/code&gt; returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the &lt;code&gt;open_file/2&lt;/code&gt; option &lt;code&gt;min_no_slots&lt;/code&gt; and returned by the &lt;code&gt;info/2&lt;/code&gt; item &lt;code&gt;no_slots&lt;/code&gt;. See also option &lt;code&gt;min_no_slots&lt;/code&gt; below.</source>
          <target state="translated">Важно, чтобы на столе было достаточное количество слотов для предметов. В противном случае список хэшей начинает расти, когда возвращается &lt;code&gt;init_table/2&lt;/code&gt; , что значительно замедляет доступ к таблице на некоторое время. Минимальное количество слотов устанавливаются в &lt;code&gt;open_file/2&lt;/code&gt; опционных &lt;code&gt;min_no_slots&lt;/code&gt; и возвращенная &lt;code&gt;info/2&lt;/code&gt; пункта &lt;code&gt;no_slots&lt;/code&gt; . См. Также опцию &lt;code&gt;min_no_slots&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="cc58fdeef579f98fae78bf5fe0d5883ad2b7f7a5" translate="yes" xml:space="preserve">
          <source>It is important though that the returned data is of the correct type depending on the options set. We therefore convert the lists to binaries in the correct encoding &lt;strong&gt;if possible&lt;/strong&gt; before returning. The function supplied in the &lt;code&gt;get_until&lt;/code&gt; request tuple can, as its final result return anything, so only functions returning lists can get them converted to binaries. If the request contains encoding tag &lt;code&gt;unicode&lt;/code&gt;, the lists can contain all Unicode code points and the binaries are to be in UTF-8. If the encoding tag is &lt;code&gt;latin1&lt;/code&gt;, the client is only to get characters in the range &lt;code&gt;0..255&lt;/code&gt;. Function &lt;code&gt;check/2&lt;/code&gt; takes care of not returning arbitrary Unicode code points in lists if the encoding was specified as &lt;code&gt;latin1&lt;/code&gt;. If the function does not return a list, the check cannot be performed and the result is that of the supplied function untouched.</source>
          <target state="translated">Однако важно, чтобы возвращаемые данные были правильного типа в зависимости от установленных параметров. Поэтому перед возвратом мы преобразуем списки в двоичные файлы в правильной кодировке, &lt;strong&gt;если это возможно&lt;/strong&gt; . Функция, представленная в &lt;code&gt;get_until&lt;/code&gt; запроса get_until, может в качестве своего окончательного результата вернуть что угодно, поэтому только функции, возвращающие списки, могут преобразовать их в двоичные файлы. Если запрос содержит тег кодировки &lt;code&gt;unicode&lt;/code&gt; , списки могут содержать все кодовые точки Unicode, а двоичные файлы должны быть в UTF-8. Если тег кодирования - &lt;code&gt;latin1&lt;/code&gt; , клиент должен получать символы только в диапазоне &lt;code&gt;0..255&lt;/code&gt; . Функциональная &lt;code&gt;check/2&lt;/code&gt; заботится о том, чтобы в списках не возвращались произвольные кодовые точки Unicode, если кодировка была указана как &lt;code&gt;latin1&lt;/code&gt; . Если функция не возвращает список, проверка не может быть выполнена, и результат остается неизменным для предоставленной функции.</target>
        </trans-unit>
        <trans-unit id="9f482f1f05e993d08f85fc64a1e60725affe0355" translate="yes" xml:space="preserve">
          <source>It is important to classify the dirty job correct. An I/O bound job should be classified as such, and a CPU bound job should be classified as such. If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are expected to either block waiting for I/O, and/or spend a limited amount of time moving data.</source>
          <target state="translated">Важно правильно классифицировать грязную работу.Работа,связанная с вводом/выводом,должна быть классифицирована как таковая,а работа,связанная с процессором,должна быть классифицирована как таковая.Если вы должны классифицировать задания,связанные с процессором,как задания,связанные с вводом/выводом,то грязные планировщики ввода/вывода могут стать голодными для обычных планировщиков.Предполагается,что задания,связанные с вводом/выводом,будут либо блокировать ожидание ввода/вывода,либо тратить ограниченное количество времени на перемещение данных.</target>
        </trans-unit>
        <trans-unit id="d9976dd4908ba58e6dd50ae2770854ad93d01862" translate="yes" xml:space="preserve">
          <source>It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</source>
          <target state="translated">Важно понимать,что то,что называется &quot;рекурсией&quot; при ограничении совпадений,не является рекурсией на С-стеке машины Erlang или на стеке процесса Erlang.Версия PCRE,скомпилированная в ВМ Эрланга,использует &quot;кучу&quot; памяти машины для хранения значений,которые должны храниться поверх рекурсии в совпадениях регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="5fc84b5054a683e27bd285de83b2269e24832caa" translate="yes" xml:space="preserve">
          <source>It is legal to use a &lt;code&gt;receive..after&lt;/code&gt; expression with no branches:</source>
          <target state="translated">&lt;code&gt;receive..after&lt;/code&gt; использовать выражение receive..after без ветвей:</target>
        </trans-unit>
        <trans-unit id="44e50f37a24e3efe1e7a14657ed0c069786f809c" translate="yes" xml:space="preserve">
          <source>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</source>
          <target state="translated">Более эффективно выполнять обобщенный поиск в нормализованной базе данных.Некоторые операции проще выполнять и на нормализованной модели данных.Например,один проект можно легко удалить,как показано на следующем примере:</target>
        </trans-unit>
        <trans-unit id="7a62a914f23c7f077c19bf0735e258c81935d769" translate="yes" xml:space="preserve">
          <source>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</source>
          <target state="translated">Более эффективно установить локальный замок,чем сетевой.Следовательно,блокировка по сети может быть полезна приложению,использующему реплицированную таблицу и выполняющему большую часть работы только на одном из узлов.</target>
        </trans-unit>
        <trans-unit id="266a8a540d53489e054ee8e53285fcaa3022a860" translate="yes" xml:space="preserve">
          <source>It is much more efficient.</source>
          <target state="translated">Это намного эффективнее.</target>
        </trans-unit>
        <trans-unit id="f70ad1b7b9db40203db93fc2a60726affaeebaca" translate="yes" xml:space="preserve">
          <source>It is nice to be able to do formatted output in examples, so the next example shows a simple way to use the &lt;code&gt;io:format&lt;/code&gt; function. Like all other exported functions, you can test the &lt;code&gt;io:format&lt;/code&gt; function in the shell:</source>
          <target state="translated">Приятно иметь возможность выполнять форматированный вывод в примерах, поэтому в следующем примере показан простой способ использования функции &lt;code&gt;io:format&lt;/code&gt; . Как и все другие экспортируемые функции, вы можете протестировать функцию &lt;code&gt;io:format&lt;/code&gt; в оболочке:</target>
        </trans-unit>
        <trans-unit id="44d490184e49da4da8de81362df926c0ada310f4" translate="yes" xml:space="preserve">
          <source>It is not a good idea to use a global variable as the port driver can be spawned by multiple Erlang processes. This driver-structure is to be instantiated multiple times:</source>
          <target state="translated">Не очень хорошая идея использовать глобальную переменную,так как драйвер порта может быть порожден несколькими процессами Erlang.Эта структура драйвера должна быть инстанциирована несколько раз:</target>
        </trans-unit>
        <trans-unit id="6daf413f50e26bb393a9adb93de8ca6d96ea4c43" translate="yes" xml:space="preserve">
          <source>It is not allowed to call any functions in the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;stop_select&lt;/code&gt;. This strict limitation is because the volatile context that &lt;code&gt;stop_select&lt;/code&gt; can be called.</source>
          <target state="translated">&lt;code&gt;stop_select&lt;/code&gt; вызывать какие-либо функции в &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; из stop_select . Это строгое ограничение связано с тем, что можно вызвать изменчивый контекст, в &lt;code&gt;stop_select&lt;/code&gt; может быть вызван stop_select .</target>
        </trans-unit>
        <trans-unit id="019cb18d2dc1083bf927207eb128dc99a14ce1cb" translate="yes" xml:space="preserve">
          <source>It is not allowed to change trace details (with &lt;code&gt;ttb:p&lt;/code&gt; and &lt;code&gt;ttb:tp/tpl...&lt;/code&gt;) once overload protection is activated in one of the traced nodes. This is to avoid trace setup being inconsistent between nodes.</source>
          <target state="translated">Не разрешается изменять детали трассировки (с помощью &lt;code&gt;ttb:p&lt;/code&gt; и &lt;code&gt;ttb:tp/tpl...&lt;/code&gt; ) после активации защиты от перегрузки на одном из отслеживаемых узлов. Это сделано во избежание несогласованности настроек трассировки между узлами.</target>
        </trans-unit>
        <trans-unit id="7e8776419aaae9b828a3d1b448f27e629b87f9db" translate="yes" xml:space="preserve">
          <source>It is not allowed to load multiple drivers with the same name but with different &lt;code&gt;Path&lt;/code&gt; parameters.</source>
          <target state="translated">Не допускается загрузка нескольких драйверов с одним и тем же именем, но с разными параметрами &lt;code&gt;Path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="267a6935a47a3d4aa60125e0028f69bd27f1ad69" translate="yes" xml:space="preserve">
          <source>It is not allowed to refer to types that are not declared as exported.</source>
          <target state="translated">Не разрешается ссылаться на типы,которые не декларируются как экспортируемые.</target>
        </trans-unit>
        <trans-unit id="52ca1d72ceed7a04c50a67b9f4c3b637fc684ff0" translate="yes" xml:space="preserve">
          <source>It is not allowed to use the atoms &lt;code&gt;asn1_VALUE&lt;/code&gt; and &lt;code&gt;asn1_DEFAULT&lt;/code&gt; with maps.</source>
          <target state="translated">Не разрешается использовать атомы &lt;code&gt;asn1_VALUE&lt;/code&gt; и &lt;code&gt;asn1_DEFAULT&lt;/code&gt; с картами.</target>
        </trans-unit>
        <trans-unit id="be6106b5316f8ae8651f28932170f500e7f32a70" translate="yes" xml:space="preserve">
          <source>It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the following pattern, the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2:</source>
          <target state="translated">Не всегда полезно,чтобы простые скобки выполняли две функции.Часто требуется группирующая подмаска,не требующая захвата.Если за открывающей круглой скобкой следует вопросительный знак и двоеточие,то подмаска не выполняет захвата и не учитывается при вычислении числа последующих захватывающих подмаскадок.Например,если строка &quot;белая королева&quot; сопоставлена со следующим шаблоном,то захватываемые подстроки-это &quot;белая королева&quot; и &quot;королева&quot;,и они пронумерованы 1 и 2:</target>
        </trans-unit>
        <trans-unit id="172ef3e2b0d7516e4d00a976dfcc654e15ef5e2e" translate="yes" xml:space="preserve">
          <source>It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.</source>
          <target state="translated">Добавление транспорта в службу,которая еще не была настроена,не является ошибкой:служба может быть запущена после настройки ее транспорта.</target>
        </trans-unit>
        <trans-unit id="714ec40d84015427dbe106f387df1a398ce13922" translate="yes" xml:space="preserve">
          <source>It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.</source>
          <target state="translated">Подписка на события от сервиса,который еще не существует,не является ошибкой.Это необходимо сделать до добавления транспорта,чтобы гарантировать получение всех событий,связанных с транспортом.</target>
        </trans-unit>
        <trans-unit id="6506688cea3e9daf57ae35e48e1e48f518b6ed35" translate="yes" xml:space="preserve">
          <source>It is not checked that the forms conform to the abstract format indicated by &lt;code&gt;AbstVersion&lt;/code&gt;. &lt;code&gt;no_abstract_code&lt;/code&gt; means that chunk &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; is present, but empty.</source>
          <target state="translated">Не проверяется соответствие форм абстрактному формату, указанному в &lt;code&gt;AbstVersion&lt;/code&gt; . &lt;code&gt;no_abstract_code&lt;/code&gt; означает, что блок &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; присутствует, но пуст.</target>
        </trans-unit>
        <trans-unit id="adff89968dc05df945ea7914de5055f731976098" translate="yes" xml:space="preserve">
          <source>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</source>
          <target state="translated">Он не предназначен для прямого вызова приложением,а используется через систему i/o,где его обычно можно вызвать приложением:</target>
        </trans-unit>
        <trans-unit id="48dac80b8a2417f47d829c8b695667c7b727c326" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that all log files of a distributed disk log contain the same log items. No attempt is made to synchronize the contents of the files. However, as long as at least one of the involved nodes is alive at each time, all items are logged. When logging items to a distributed log, or otherwise trying to change the log, the replies from individual logs are ignored. If all nodes are down, the disk log functions reply with a &lt;code&gt;nonode&lt;/code&gt; error.</source>
          <target state="translated">Не гарантируется, что все файлы журналов распределенного дискового журнала содержат одни и те же элементы журнала. Попытки синхронизировать содержимое файлов не предпринимаются. Однако, пока хотя бы один из задействованных узлов активен каждый раз, все элементы регистрируются. При записи элементов в распределенный журнал или иным образом при попытке изменить журнал ответы из отдельных журналов игнорируются. Если все узлы отключены, функции журнала диска отвечают &lt;code&gt;nonode&lt;/code&gt; ошибкой.</target>
        </trans-unit>
        <trans-unit id="6c08a59c0ce53162ab6636309433afb0420a7157" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that calls to &lt;code&gt;first/1&lt;/code&gt;, &lt;code&gt;next/2&lt;/code&gt;, or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table.</source>
          <target state="translated">Не гарантируется, что вызовы функций &lt;code&gt;first/1&lt;/code&gt; , &lt;code&gt;next/2&lt;/code&gt; или select и match работают должным образом, даже если таблица зафиксирована; Ограниченная поддержка параллелизма, предоставляемая модулем &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; еще не предоставляется Dets. Исправление таблицы в настоящее время отключает изменение размера только хеш-списка таблицы.</target>
        </trans-unit>
        <trans-unit id="d1b5a702c4f1e3b1b3222bf3f6b4f026b94f149e" translate="yes" xml:space="preserve">
          <source>It is not hard to guess that this program doubles the value of numbers. The first two lines of the code are described later. Let us compile the program. This can be done in an Erlang shell as follows, where &lt;code&gt;c&lt;/code&gt; means compile:</source>
          <target state="translated">Нетрудно догадаться, что эта программа удваивает значение чисел. Первые две строки кода описаны позже. Скомпилируем программу. Это можно сделать в оболочке Erlang следующим образом, где &lt;code&gt;c&lt;/code&gt; означает компиляцию:</target>
        </trans-unit>
        <trans-unit id="6599e0f052b83133353329a627f4fcc452a99c7e" translate="yes" xml:space="preserve">
          <source>It is not mandatory to implement a &lt;code&gt;Module:format_status/2&lt;/code&gt; function. If you do not, a default implementation is used that does the same as this example function without filtering the &lt;code&gt;Data&lt;/code&gt; term, that is, &lt;code&gt;StateData = {State,Data}&lt;/code&gt;, in this example containing sensitive information.</source>
          <target state="translated">Реализовывать функцию &lt;code&gt;Module:format_status/2&lt;/code&gt; не обязательно . Если вы этого не сделаете, используется реализация по умолчанию, которая выполняет то же самое, что и функция в этом примере, без фильтрации термина &lt;code&gt;Data&lt;/code&gt; , то есть &lt;code&gt;StateData = {State,Data}&lt;/code&gt; , в этом примере содержится конфиденциальная информация.</target>
        </trans-unit>
        <trans-unit id="b0b1f733cc068108abc1dfb8d6bfeb68f2238a31" translate="yes" xml:space="preserve">
          <source>It is not necessary to export the function. It is called in a freshly spawned process (which terminates as soon as the function returns).</source>
          <target state="translated">Экспорт функции не требуется.Она вызывается в свежем процессе (который завершается,как только функция возвращается).</target>
        </trans-unit>
        <trans-unit id="93f0d950414352a5d4ade5d65e2ed5c99e6d63a5" translate="yes" xml:space="preserve">
          <source>It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes.</source>
          <target state="translated">Нет необходимости явно задавать поля заголовка в исходящих сообщениях,так как диаметр сам по себе будет задавать соответствующие значения.Установка неподходящих значений может быть полезна в тестовых целях.</target>
        </trans-unit>
        <trans-unit id="a88f320b00286fede41d92ef08aebc45a1de0c25" translate="yes" xml:space="preserve">
          <source>It is not needed to link the start script to a standard directory like &lt;code&gt;/usr/local/bin&lt;/code&gt;.</source>
          <target state="translated">Связывать стартовый скрипт со стандартным каталогом, например &lt;code&gt;/usr/local/bin&lt;/code&gt; ,необязательно .</target>
        </trans-unit>
        <trans-unit id="67e4d152ebcc05f491b81e0ec203229252d7a205" translate="yes" xml:space="preserve">
          <source>It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern whose number is 10 or more using this syntax, as a sequence such as \50 is interpreted as a character defined in octal. For more details of the handling of digits following a backslash, see section &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; earlier. There is no such problem when named parentheses are used. A back reference to any subpattern is possible using named parentheses (see below).</source>
          <target state="translated">Невозможно иметь числовую &amp;laquo;прямую обратную ссылку&amp;raquo; на подшаблон, номер которого 10 или более, используя этот синтаксис, поскольку последовательность, такая как \ 50, интерпретируется как символ, определенный в восьмеричном формате. Для получения дополнительных сведений об обработке цифр после обратной косой черты см. Раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; ранее. При использовании именных скобок такой проблемы не возникает. Обратная ссылка на любой подшаблон возможна с использованием именованных скобок (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="c8c3861d369958e8f50d803ddee527f70da5bdd2" translate="yes" xml:space="preserve">
          <source>It is not possible to have hook functions for unknown forms at other places than expressions.</source>
          <target state="translated">Невозможно иметь функции перехвата для неизвестных форм в других местах,кроме выражений.</target>
        </trans-unit>
        <trans-unit id="bf5dc4b3da52b6319903eca1d8e499b4252bc392" translate="yes" xml:space="preserve">
          <source>It is not possible to prove that a program is correct by testing. On the contrary, it has been formally proven that it is impossible to prove programs in general by testing. Theoretical program proofs or plain examination of code can be viable options for those wishing to certify that a program is correct. The test server, as it is based on testing, cannot be used for certification. Its intended use is instead to (cost effectively) &lt;strong&gt;find bugs&lt;/strong&gt;. A successful test suite is one that reveals a bug. If a test suite results in OK, then we know very little that we did not know before.</source>
          <target state="translated">Невозможно доказать правильность программы путем тестирования. Напротив, формально доказано, что тестирование программ в целом невозможно. Теоретические доказательства программы или простая проверка кода могут быть жизнеспособными вариантами для тех, кто желает удостовериться в правильности программы. Тестовый сервер, поскольку он основан на тестировании, не может использоваться для сертификации. Вместо этого он предназначен для (экономичного) &lt;strong&gt;поиска ошибок&lt;/strong&gt; . Успешный набор тестов - это тот, который выявляет ошибку. Если набор тестов дает результат &amp;laquo;ОК&amp;raquo;, значит, мы знаем очень мало того, чего не знали раньше.</target>
        </trans-unit>
        <trans-unit id="f090c83c0abe9549e98a789664a0923d4db3b914" translate="yes" xml:space="preserve">
          <source>It is not uncommon that a state diagram does not specify how to handle events that are not illustrated in a particular state in the diagram. Hopefully this is described in an associated text or from the context.</source>
          <target state="translated">Нередко в диаграмме состояния не указывается,как обрабатывать события,которые не проиллюстрированы в определенном состоянии на диаграмме.Надеюсь,это описано в соответствующем тексте или из контекста.</target>
        </trans-unit>
        <trans-unit id="1b4b52b46f007701d86e5cbc9fd97f24e3345085" translate="yes" xml:space="preserve">
          <source>It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification.</source>
          <target state="translated">Недопустимо указывать время начала позже, чем текущее время. Если &lt;code&gt;StartTime&lt;/code&gt; указан раньше, чем может поддерживать журнал, воспроизведение начинается с самого раннего доступного уведомления.</target>
        </trans-unit>
        <trans-unit id="5d718859968289028b6154d936e134179997eaef" translate="yes" xml:space="preserve">
          <source>It is now easy to check the release for calls to undefined functions:</source>
          <target state="translated">Теперь можно легко проверить доступность вызова неопределенных функций:</target>
        </trans-unit>
        <trans-unit id="faf994c17800a7abaab6ecd7abe5ad72813bee4c" translate="yes" xml:space="preserve">
          <source>It is of course pointless to set this value to &lt;strong&gt;true&lt;/strong&gt; unless the &lt;code&gt;long_request_timer&lt;/code&gt; (see above) is also set to an incremental timer (&lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;).</source>
          <target state="translated">Конечно, бессмысленно устанавливать это значение на &lt;strong&gt;true,&lt;/strong&gt; если &lt;code&gt;long_request_timer&lt;/code&gt; (см. Выше) также не установлен на инкрементный таймер ( &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79ffc30d77639dd371cff25e8830713b8384b424" translate="yes" xml:space="preserve">
          <source>It is of course possible to change more than one list:</source>
          <target state="translated">Конечно,можно изменить несколько списков:</target>
        </trans-unit>
        <trans-unit id="8bfa4ac8d028ee74a965d7390ff456df5b066f34" translate="yes" xml:space="preserve">
          <source>It is of course questionable why anyone would like to use the both these options together, but it is possible if an unforeseen need should arise.</source>
          <target state="translated">Конечно,сомнительно,почему кто-то хочет использовать оба этих варианта вместе,но это возможно,если возникнет непредвиденная необходимость.</target>
        </trans-unit>
        <trans-unit id="bf27b2f7999b2a0f376e32c255c57172849d6995" translate="yes" xml:space="preserve">
          <source>It is of vital importance that this operation does not block the caller for a long time. This since it is called from the connection supervisor.</source>
          <target state="translated">Крайне важно,чтобы эта операция не блокировала вызывающего абонента в течение длительного времени.Это связано с тем,что она вызывается из диспетчера соединений.</target>
        </trans-unit>
        <trans-unit id="e5e8d870189d92edc558c16a26f0bf8ab0c4cb2b" translate="yes" xml:space="preserve">
          <source>It is often clarifying to mark the variables of a query in such a circle. This is illustrated in the picture below for some of the predefined analyses. Note that local functions used by local functions only are not marked in the &lt;code&gt;locals_not_used&lt;/code&gt; circle.</source>
          <target state="translated">Часто бывает полезно пометить переменные запроса в таком кружке. Это проиллюстрировано на рисунке ниже для некоторых из предварительно определенных анализов. Обратите внимание, что локальные функции, используемые только локальными функциями, не отмечены кружком &lt;code&gt;locals_not_used&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f00cf0fbfe0fde80503545d404b005925d1059f" translate="yes" xml:space="preserve">
          <source>It is often necessary to take some specific action when a table is modified. This is accomplished with an instrumentation function. It executes some specific code when the table is set, and passes all other requests down to the pre-defined function.</source>
          <target state="translated">Часто при внесении изменений в таблицу необходимо предпринять какие-то конкретные действия.Это выполняется с помощью приборостроительной функции.Она выполняет некоторый специфический код,когда таблица установлена,и передает все остальные запросы в предопределенную функцию.</target>
        </trans-unit>
        <trans-unit id="669d240c984f988928dcb3d02f7640e88b19a775" translate="yes" xml:space="preserve">
          <source>It is often not desirable to use an Erlang/OTP system as is. A developer can create new Erlang/OTP-compliant applications for a particular purpose, and several original Erlang/OTP applications can be irrelevant for the purpose in question. Thus, there is a need to be able to create a new system based on a given Erlang/OTP system, where dispensable applications are removed and new applications are included. Documentation and source code is irrelevant and is therefore not included in the new system.</source>
          <target state="translated">Часто не желательно использовать систему Erlang/OTP как таковую.Разработчик может создавать новые Erlang/OTP-совместимые приложения для определенных целей,и несколько оригинальных Erlang/OTP-приложений могут быть неактуальны для данной цели.Таким образом,необходимо иметь возможность создавать новую систему,основанную на данной Erlang/OTP-системе,в которой удаляются несущественные приложения и включаются новые.Документация и исходный код не имеют значения и поэтому не включаются в новую систему.</target>
        </trans-unit>
        <trans-unit id="9d21d755bf6ee35af46a7e0f26952debc88310ea" translate="yes" xml:space="preserve">
          <source>It is often very convenient to have a header in the escript, especially on Unix platforms. However, the header is optional, so you directly can &quot;execute&quot; an Erlang module, Beam file, or archive file without adding any header to them. But then you have to invoke the script as follows:</source>
          <target state="translated">Часто очень удобно иметь заголовок в скрипте,особенно на Unix-платформах.Однако,заголовок является необязательным,так что вы можете напрямую &quot;выполнить&quot; модуль Erlang,Beam-файл или архивный файл без добавления к ним заголовка.Но затем вы должны вызвать скрипт следующим образом:</target>
        </trans-unit>
        <trans-unit id="4b82a26416eee8b8a22c361320edebe40a30f41c" translate="yes" xml:space="preserve">
          <source>It is only possible to use &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; and &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; for authentication and privacy respectively in FIPS mode. The snmp application however won't restrict selecting disabled protocols in any way, and using them would result in run time crashes.</source>
          <target state="translated">Только в режиме FIPS можно использовать &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; и &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; для аутентификации и конфиденциальности соответственно. Однако приложение snmp никоим образом не ограничивает выбор отключенных протоколов, и их использование приведет к сбоям во время выполнения.</target>
        </trans-unit>
        <trans-unit id="fd21c404d1e97d6cd83c5aba66d139ae4da23bac" translate="yes" xml:space="preserve">
          <source>It is ordered by the state transition action &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="translated">Он упорядочивается действием перехода состояния &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt; или просто целым числом &lt;code&gt;Time&lt;/code&gt; , даже без включающего списка действий (последний является формой, унаследованной от &lt;code&gt;gen_fsm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f5f5edc97bf67285e58ab928b4aa2d01b87a09" translate="yes" xml:space="preserve">
          <source>It is possible by this option to provide a state with process information from an earlier validation.</source>
          <target state="translated">С помощью этой опции можно предоставить государству информацию о процессе,полученную в результате более ранней проверки.</target>
        </trans-unit>
        <trans-unit id="3fc2da2a53482855bb7753488df5c4c401558486" translate="yes" xml:space="preserve">
          <source>It is possible for Emacs to use colors when displaying a buffer. By &quot;syntax highlighting&quot;, we mean that syntactic components, for example keywords and function names, will be colored.</source>
          <target state="translated">Emacs может использовать цвета при отображении буфера.Под &quot;подсветкой синтаксиса&quot; мы подразумеваем,что синтаксические компоненты,например,ключевые слова и имена функций,будут окрашены.</target>
        </trans-unit>
        <trans-unit id="983ca3396eb1c79021585a9487782ad0ed7b06d7" translate="yes" xml:space="preserve">
          <source>It is possible that a handler, even if it can successfully manage peaks of high load without crashing, can build up a large message queue, or use a large amount of memory. The overload protection mechanism includes an automatic termination and restart feature for the purpose of guaranteeing that a handler does not grow out of bounds. The feature is configured with the following parameters:</source>
          <target state="translated">Возможно,что обработчик,даже если он успешно справится с пиковыми нагрузками без сбоев,может построить большую очередь сообщений или использовать большой объем памяти.Механизм защиты от перегрузки включает в себя функцию автоматического завершения и перезапуска,чтобы гарантировать,что обработчик не вырастет за пределы своих возможностей.Функция настраивается со следующими параметрами:</target>
        </trans-unit>
        <trans-unit id="89c49ffbfde542066361889dbf3e0036988b041f" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;strong&gt;notification filters&lt;/strong&gt; to an agent. These filters will be called when a notification is to be sent. Their purpose is to allow modification, suppression or other type of actions.</source>
          <target state="translated">К агенту можно добавить &lt;strong&gt;фильтры уведомлений&lt;/strong&gt; . Эти фильтры будут вызываться при отправке уведомления. Их цель - разрешить изменение, подавление или другие действия.</target>
        </trans-unit>
        <trans-unit id="611a47c1b5a7ffc5aabe01662e2b7fd7dc2dfd2f" translate="yes" xml:space="preserve">
          <source>It is possible to attach to interpreted processes by giving the corresponding process identity only. By default, an attachment window is displayed. Processes at other Erlang nodes can be attached manually or automatically.</source>
          <target state="translated">К интерпретируемым процессам можно прикрепить только идентификацию соответствующего процесса.По умолчанию отображается окно прикрепления.Процессы на других узлах Erlang могут быть прикреплены вручную или автоматически.</target>
        </trans-unit>
        <trans-unit id="68a33746b01c4222471af2ab90b1fda17ae37276" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the scripts original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="translated">Можно связать &lt;code&gt;escript&lt;/code&gt; с системой времени выполнения Erlang, чтобы сделать ее самодостаточной и перемещаемой. В такой автономной системе &lt;code&gt;escript&lt;/code&gt; (-ы) должен быть расположен в верхнем каталоге &lt;code&gt;bin&lt;/code&gt; автономной системы и &lt;code&gt;.escript&lt;/code&gt; расширение .escript в качестве расширения файла. Далее (встроенную) программу &lt;code&gt;escript&lt;/code&gt; следует скопировать в тот же каталог и &lt;code&gt;.escript&lt;/code&gt; исходное имя сценария (без расширения .escript ). Это позволит использовать встроенную систему времени выполнения Erlang.</target>
        </trans-unit>
        <trans-unit id="1a74ec992e2736a1ad60efb4b66cf6169016243f" translate="yes" xml:space="preserve">
          <source>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern:</source>
          <target state="translated">Возможно условное подчинение процесса сопоставления подмаски или выбор между двумя альтернативными подмаскадами,в зависимости от результата утверждения,или от того,была ли уже сопоставлена конкретная захватывающая подмаска.Ниже приведены две возможные формы условной подмаски:</target>
        </trans-unit>
        <trans-unit id="ab76d6d5170404d3b2cda7f8cfb409928e7f4eef" translate="yes" xml:space="preserve">
          <source>It is possible to configure a 3588 dictionary in order to get 3588 semantics, where the differ from 6733.</source>
          <target state="translated">Можно настроить словарь 3588,чтобы получить 3588 семантику,где она отличается от 6733.</target>
        </trans-unit>
        <trans-unit id="9c37c6dc0aa07be6c37e5deaa81d5f4c9f52e7cd" translate="yes" xml:space="preserve">
          <source>It is possible to debug every (non-supervisor) process of the application (both agent and manager), possibly with the exception of the net_if module(s), which could be supplied by a user of the application). This is done by calling the &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; and &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; function(s) and/or using &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;. The verbosity itself has several &lt;strong&gt;levels&lt;/strong&gt;: &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt;. For the lowest verbosity &lt;code&gt;silence&lt;/code&gt;, nothing is printed. The higher the verbosity, the more is printed. Default value is always &lt;code&gt;silence&lt;/code&gt;.</source>
          <target state="translated">Можно отлаживать каждый (не являющийся супервизором) процесс приложения (как агента, так и менеджера), возможно, за исключением модуля (модулей) net_if, который может быть предоставлен пользователем приложения). Это делается путем вызова &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; и &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; и / или с использованием &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; . Сама многословность имеет несколько &lt;strong&gt;уровней&lt;/strong&gt; : &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt; . Для &lt;code&gt;silence&lt;/code&gt; с самым низким уровнем детализации ничего не печатается. Чем выше уровень детализации, тем больше печатается. Значение по умолчанию - всегда &lt;code&gt;silence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d39bbc803211df1332cc5dc8dcf83a0f92e55b1" translate="yes" xml:space="preserve">
          <source>It is possible to generate an &lt;code&gt;.hrl&lt;/code&gt; file which contains definitions of Erlang constants from a compiled MIB file. This file can then be included in Erlang source code. The file will contain constants for:</source>
          <target state="translated">Можно создать файл &lt;code&gt;.hrl&lt;/code&gt; , который содержит определения констант Erlang из скомпилированного файла MIB. Затем этот файл можно включить в исходный код Erlang. Файл будет содержать константы для:</target>
        </trans-unit>
        <trans-unit id="51fafe686c4a07e4e02f5d76d9dd1d3e7268cfbe" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node and another type on another node. Default is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Возможно иметь реплицированную таблицу типа &lt;code&gt;disc_copies&lt;/code&gt; на одном узле и другого типа на другом узле. По умолчанию &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="176cd0b1dd2d9962820987b7f9b12d3696c77d8c" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node, and the same table stored as a different type on another node. Default is &lt;code&gt;[]&lt;/code&gt;. This arrangement is desirable if the following operational characteristics are required:</source>
          <target state="translated">Возможно иметь реплицированную таблицу типа &lt;code&gt;disc_copies&lt;/code&gt; на одном узле и ту же таблицу, сохраненную как другой тип на другом узле. По умолчанию &lt;code&gt;[]&lt;/code&gt; . Такое расположение желательно, если требуются следующие рабочие характеристики:</target>
        </trans-unit>
        <trans-unit id="1fe6b795938737aa56b18e0286b7c12c53710c77" translate="yes" xml:space="preserve">
          <source>It is possible to have the following ASN.1 type definitions:</source>
          <target state="translated">Возможно наличие следующих определений типа ASN.1:</target>
        </trans-unit>
        <trans-unit id="caeed91f5fcecb317cae9ea39c892cb575858fba" translate="yes" xml:space="preserve">
          <source>It is possible to load mibs into the manager, but this is not necessary for normal operation, and not recommended.</source>
          <target state="translated">Можно загружать мибры в менеджера,но это не обязательно для нормальной работы,и не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="8ed112d6a70cb9d06cfb65b8258e9018e32dab8e" translate="yes" xml:space="preserve">
          <source>It is possible to modify the default behaviour of a process so that it does not get killed when it receives abnormal exit signals. Instead, all signals are turned into normal messages on the format &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; and added to the end of the receiving process' message queue. This behaviour is set by:</source>
          <target state="translated">Можно изменить поведение процесса по умолчанию, чтобы его не убивали при получении аномальных сигналов выхода. Вместо этого все сигналы превращаются в обычные сообщения в формате &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; и добавляются в конец очереди сообщений принимающего процесса. Это поведение задается:</target>
        </trans-unit>
        <trans-unit id="2b2147478740459290ffe9c88424b73275de9908" translate="yes" xml:space="preserve">
          <source>It is possible to overload macros, except for predefined macros. An overloaded macro has more than one definition, each with a different number of arguments.</source>
          <target state="translated">Возможна перегрузка макросов,за исключением предопределенных макросов.Перегруженный макрос имеет более одного определения,каждое из которых имеет разное количество аргументов.</target>
        </trans-unit>
        <trans-unit id="2f1689c7a1afca7921fba43503d5e442362a2a71" translate="yes" xml:space="preserve">
          <source>It is possible to override the default behavior and control what types of files that are to be compressed by using options &lt;code&gt;{compress, What}&lt;/code&gt; and &lt;code&gt;{uncompress, What}&lt;/code&gt;. It is also possible to use many &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; options.</source>
          <target state="translated">Можно переопределить поведение по умолчанию и контролировать, какие типы файлов должны быть сжаты, используя параметры &lt;code&gt;{compress, What}&lt;/code&gt; и &lt;code&gt;{uncompress, What}&lt;/code&gt; . Также можно использовать множество опций &lt;code&gt;compress&lt;/code&gt; и &lt;code&gt;uncompress&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a56a8c28e6ccfea7e044e017bea02d64d0c26d0" translate="yes" xml:space="preserve">
          <source>It is possible to perform some limited manipulations of the graph. Nodes can be moved, selected, locked or deleted. Move a single node or the entire graph by moving the mouse while the left mouse button is pressed. A node can be locked into a fix position by holding down the shift button when the left mouse button is released. Select several nodes by moving the mouse while the control key and the left mouse button are pressed. Selected nodes can be locked, unlocked or deleted by clicking on a suitable button.</source>
          <target state="translated">Возможно выполнение некоторых ограниченных манипуляций с графиком.Узлы можно перемещать,выбирать,блокировать или удалять.Перемещение одного узла или всего графика осуществляется перемещением мыши при нажатой левой кнопке мыши.Узел может быть заблокирован в фиксированное положение,удерживая нажатой кнопку перемещения при отпускании левой кнопки мыши.Выделите несколько узлов,перемещая мышь при нажатой клавише управления и левой кнопке мыши.Выбранные узлы можно заблокировать,разблокировать или удалить,нажав соответствующую кнопку.</target>
        </trans-unit>
        <trans-unit id="2fed4e0762f6fb12f483f3a5c7bb640cb225b33e" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Можно предотвратить завершение процесса из-за ошибок времени выполнения и других исключений, используя &lt;code&gt;catch&lt;/code&gt; или &lt;code&gt;try&lt;/code&gt; , см. &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; о &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3df4ebaf240f63cbe2516bd7eacc27e64f5b97f0" translate="yes" xml:space="preserve">
          <source>It is possible to print more specific types of statistics by first manipulating the &lt;code&gt;DataOrStats&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. For instance if you want to print the percentage of run-time for each thread you can do:</source>
          <target state="translated">Можно распечатать более конкретные типы статистики, сначала обработав &lt;code&gt;DataOrStats&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; . Например, если вы хотите распечатать процент времени выполнения для каждого потока, вы можете сделать:</target>
        </trans-unit>
        <trans-unit id="edfc81400b7354fb02a37d8d3cbdc6435db75f99" translate="yes" xml:space="preserve">
          <source>It is possible to specify that the module is the callback module for a &lt;strong&gt;behaviour&lt;/strong&gt;:</source>
          <target state="translated">Можно указать, что модуль является модулем обратного вызова для &lt;strong&gt;поведения&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="64a48f3eede047c4b7880e6db7738b3c1b6b35fc" translate="yes" xml:space="preserve">
          <source>It is possible to use SSL/TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="translated">Можно использовать распространение SSL / TLS по IPv6 вместо IPv4. Для этого передайте параметр &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; вместо &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; при запуске Erlang, либо в командной строке, либо в переменной среды &lt;code&gt;ERL_FLAGS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2f7a787a6e395f6a23bb42d34f2d7a43e1c7c1a" translate="yes" xml:space="preserve">
          <source>It is possible to write a driver in C according to certain principles and dynamically link it to the Erlang runtime system. The linked-in driver looks like a port from the Erlang programmer's point of view and is called a &lt;strong&gt;port driver&lt;/strong&gt;.</source>
          <target state="translated">Можно написать драйвер на C в соответствии с определенными принципами и динамически связать его с системой времени выполнения Erlang. Подключенный драйвер выглядит как порт с точки зрения программиста Erlang и называется &lt;strong&gt;драйвером порта&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3235ff3a1f208b096772a81fe4cb496997e0cde6" translate="yes" xml:space="preserve">
          <source>It is possible, but definitely not recommended, to start Debugger in global mode on more than one node in a network, as the nodes interfere with each other, leading to inconsistent behavior.</source>
          <target state="translated">Можно,но определенно не рекомендуется запускать отладчик в глобальном режиме более чем на одном узле в сети,так как узлы мешают друг другу,что приводит к непоследовательному поведению.</target>
        </trans-unit>
        <trans-unit id="4bd608e2122cf39b6241e7c0694b05508a158bb5" translate="yes" xml:space="preserve">
          <source>It is primarily intended to be used in &lt;code&gt;ets:match/2&lt;/code&gt; and &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, to set record fields to the atom &lt;code&gt;'_'&lt;/code&gt;. (This is a wildcard in &lt;code&gt;ets:match/2&lt;/code&gt;.)</source>
          <target state="translated">В первую очередь он предназначен для использования в &lt;code&gt;ets:match/2&lt;/code&gt; и &lt;code&gt;mnesia:match_object/3&lt;/code&gt; , чтобы установить в полях записи атом &lt;code&gt;'_'&lt;/code&gt; . (Это подстановочный знак в &lt;code&gt;ets:match/2&lt;/code&gt; . )</target>
        </trans-unit>
        <trans-unit id="46e7fe56fdedc189f7070c8d58b82badd56c82e5" translate="yes" xml:space="preserve">
          <source>It is probably a good idea to do both wall-clock measurements and CPU time measurements.</source>
          <target state="translated">Вероятно,это хорошая идея,чтобы сделать как настенные часы измерения,так и измерения процессорного времени.</target>
        </trans-unit>
        <trans-unit id="5a14f6ab8271ce6a90e3ad46573c990914b8aa87" translate="yes" xml:space="preserve">
          <source>It is rather costly to hibernate a process; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;. It is not something you want to do after every event.</source>
          <target state="translated">Перевести процесс в спящий режим - довольно дорого; см. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; . Это не то, чем вы хотите заниматься после каждого мероприятия.</target>
        </trans-unit>
        <trans-unit id="3e4b9ac2fc75211bbe9ad50f5e40bfade9c76213" translate="yes" xml:space="preserve">
          <source>It is recommended by the SSH Connection Protocol to send this message, but that is not always the case.</source>
          <target state="translated">Рекомендуется протокол соединения SSH для отправки этого сообщения,но это не всегда так.</target>
        </trans-unit>
        <trans-unit id="3538339fde2ffca2f48c0ebf690413d3c9455c7f" translate="yes" xml:space="preserve">
          <source>It is recommended not to specify &lt;code&gt;LogFileOpts&lt;/code&gt; unless absolutely necessary. The default options used by the handler to open a file for logging are &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;, and &lt;code&gt;delayed_write&lt;/code&gt;. Notice that the standard handler does not have support for circular logging. Use the disk_log handler, &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, for this.</source>
          <target state="translated">Не рекомендуется указывать &lt;code&gt;LogFileOpts&lt;/code&gt; без крайней необходимости. Параметры по умолчанию, используемые обработчиком для открытия файла для ведения журнала, - это &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;append&lt;/code&gt; и &lt;code&gt;delayed_write&lt;/code&gt; . Обратите внимание, что стандартный обработчик не поддерживает циклическое ведение журнала. Для этого используйте обработчик &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; , logger_disk_log_h .</target>
        </trans-unit>
        <trans-unit id="84dcefe80a30322b20b7d6bec52f8ca9cf6c5179" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Рекомендуется, чтобы &lt;code&gt;Report&lt;/code&gt; имел ту же структуру, что и &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b386ae81313b705ebb70b487e37aefb55d196b01" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Рекомендуется, чтобы &lt;code&gt;Report&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt; ту же структуру, что и для info_report / 1 .</target>
        </trans-unit>
        <trans-unit id="ec7525c85fc1b0fc6b283c95390bdef2f3056b13" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Рекомендуется, чтобы &lt;code&gt;Report&lt;/code&gt; имел ту же структуру, что и &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="783c04e3a082ab2be9d7c29f034cc09bfb7018db" translate="yes" xml:space="preserve">
          <source>It is recommended that application directories are named as the application, possibly followed by a dash and the version number. For example &lt;code&gt;myapp&lt;/code&gt; or &lt;code&gt;myapp-1.1&lt;/code&gt;.</source>
          <target state="translated">Рекомендуется, чтобы каталоги приложений были названы как приложения, возможно, с дефисом и номером версии. Например, &lt;code&gt;myapp&lt;/code&gt; или &lt;code&gt;myapp-1.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d33efddc769eac5ce590e1e5ad80c9fa01a0ec69" translate="yes" xml:space="preserve">
          <source>It is recommended that the data files are not tampered with while &lt;code&gt;Mnesia&lt;/code&gt; is running. While not prohibited, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is unpredictable.</source>
          <target state="translated">Рекомендуется не изменять файлы данных во время работы &lt;code&gt;Mnesia&lt;/code&gt; . Хотя это и не запрещено, поведение &lt;code&gt;Mnesia&lt;/code&gt; непредсказуемо.</target>
        </trans-unit>
        <trans-unit id="a92359abef578e025508dcaa89e3308762079839" translate="yes" xml:space="preserve">
          <source>It is recommended that the embedded environment is run by an ordinary user, that is, a user who does not have super user privileges.</source>
          <target state="translated">Рекомендуется,чтобы встроенная среда запускалась обычным пользователем,то есть пользователем,который не имеет привилегий суперпользователя.</target>
        </trans-unit>
        <trans-unit id="762df308b5cada2cb63ce0582b14513833afec03" translate="yes" xml:space="preserve">
          <source>It is recommended to add these lines to avoid a clash. The clash can make it impossible to boot the system.</source>
          <target state="translated">Рекомендуется добавлять эти строки,чтобы избежать столкновения.Конфликт может сделать невозможной загрузку системы.</target>
        </trans-unit>
        <trans-unit id="6fd8b3ea5927d76b7682f8c2f4ad291b5b58b77d" translate="yes" xml:space="preserve">
          <source>It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets.</source>
          <target state="translated">Рекомендуется использовать внешние кодировки только для связи с внешними объектами,где это необходимо.При работе внутри среды Erlang/OTP рекомендуется сохранять двоичные файлы в кодировке UTF-8 при представлении символов Юникода.ISO кодировка Latin-1 поддерживается как для обратной совместимости,так и для связи с внешними сущностями,не поддерживающими наборы символов Юникода.</target>
        </trans-unit>
        <trans-unit id="a86763d26205898122a82befc3a8840b014abd3a" translate="yes" xml:space="preserve">
          <source>It is recommended to set this parameter to &lt;code&gt;false&lt;/code&gt; on systems with many concurrent processes, as each process memory check makes a traversal of the entire list of processes.</source>
          <target state="translated">Рекомендуется установить для этого параметра значение &lt;code&gt;false&lt;/code&gt; в системах с множеством параллельных процессов, так как при каждой проверке памяти процесса выполняется обход всего списка процессов.</target>
        </trans-unit>
        <trans-unit id="24e3dbfb80fbfa8e8fdafd6d93a77c0b3d9621a5" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;code&gt;ei_xreceive_msg&lt;/code&gt; instead when possible, for the sake of readability. However, the function will be retained in the interface for compatibility and will &lt;strong&gt;not&lt;/strong&gt; be removed in future releases without prior notice.</source>
          <target state="translated">По возможности рекомендуется использовать &lt;code&gt;ei_xreceive_msg&lt;/code&gt; для удобства чтения. Однако функция будет сохранена в интерфейсе для совместимости и &lt;strong&gt;не&lt;/strong&gt; будет удалена в будущих выпусках без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="68b150299a170408a969148f799267c01b2b3057" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;.hrl&lt;/code&gt; files created by the Erlang/OTP MIB compiler to define the Object Identifiers (OIDs). For example, to get the Erlang node name from &lt;code&gt;erlNodeTable&lt;/code&gt; in the OTP-MIB:</source>
          <target state="translated">Для определения идентификаторов объектов (OID) рекомендуется использовать файлы &lt;code&gt;.hrl&lt;/code&gt; , созданные компилятором Erlang / OTP MIB. Например, чтобы получить имя узла Erlang из &lt;code&gt;erlNodeTable&lt;/code&gt; в OTP-MIB:</target>
        </trans-unit>
        <trans-unit id="beb6f25876d5f5f2b17dc06907c6e940b602048d" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;record_info/2&lt;/code&gt; notation, as it becomes easier to maintain the program and the program becomes more robust with regards to future record changes.</source>
          <target state="translated">Рекомендуется использовать нотацию &lt;code&gt;record_info/2&lt;/code&gt; , так как становится проще поддерживать программу, и программа становится более устойчивой к будущим изменениям записей.</target>
        </trans-unit>
        <trans-unit id="8b76629f18d77250860872328b4b08636aca42ee" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Иногда бывает полезно или необходимо создать пользовательский сценарий загрузки. Это верно, особенно при запуске Erlang во встроенном режиме, см. &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4428a0f8ea035e8ff8c49bdbc215a36fc422f39f" translate="yes" xml:space="preserve">
          <source>It is strongly recommend to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="translated">Настоятельно рекомендуется использовать эту функцию и избегать нестандартных отступов от линий.Некоторые мотивы:</target>
        </trans-unit>
        <trans-unit id="dce8043b4ef69a730f0893b68fe47eb9a7d53719" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array afterwards. It has been allocated by the function with a single call to &lt;code&gt;malloc()&lt;/code&gt;, so a single &lt;code&gt;free()&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">После этого освобождение массива является обязанностью вызывающей стороны. Он был выделен функцией одним вызовом &lt;code&gt;malloc()&lt;/code&gt; , поэтому достаточно одного &lt;code&gt;free()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="995f9fe18801008a7413cb59742eae29d2846eb4" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;erl_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">Вызывающая сторона обязана освободить массив. &lt;code&gt;erl_global_names&lt;/code&gt; выделяет массив и все строки с помощью одного вызова &lt;code&gt;malloc()&lt;/code&gt; , поэтому &lt;code&gt;free(names)&lt;/code&gt; - это все, что необходимо.</target>
        </trans-unit>
        <trans-unit id="72318ea3ee2cb4c60a442793c66f568591fae3fc" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the returned &lt;code&gt;ETERM&lt;/code&gt; structure and the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;.</source>
          <target state="translated">Вызывающий &lt;code&gt;ETERM&lt;/code&gt; несет ответственность за освобождение возвращенной структуры ETERM и памяти, на которую &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; и &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90281b55dfbea943300fc790e2a254ba4758b5f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;, &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;, and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;.</source>
          <target state="translated">Вызывающий абонент обязан освободить память, на которую &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; , &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; и &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffcb8bff0a2bc31b48d23416b425fa41cd4102ea" translate="yes" xml:space="preserve">
          <source>It is then possible to assign values as follows:</source>
          <target state="translated">Затем можно назначить значения следующим образом:</target>
        </trans-unit>
        <trans-unit id="32dd295574a144656b5cc3828c87c43e206ba562" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="translated">Поэтому важно, чтобы код внутри Fun, предоставленного &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; , был чистым. Некоторые странные результаты могут возникнуть, если, например, сообщения отправляются транзакцией Fun. Следующий пример иллюстрирует эту ситуацию:</target>
        </trans-unit>
        <trans-unit id="52f4a38196075ad4a5127fd5f3778f1a63bfca93" translate="yes" xml:space="preserve">
          <source>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</source>
          <target state="translated">Поэтому рекомендуется менять код как можно меньшими шагами и всегда поддерживать обратную совместимость.</target>
        </trans-unit>
        <trans-unit id="d9ec68e380c2aeaf1e726fe77035c867ce201c19" translate="yes" xml:space="preserve">
          <source>It is to be (or result in) a call to any of the following:</source>
          <target state="translated">Это должен быть (или привести к)вызов на любое из нижеперечисленных:</target>
        </trans-unit>
        <trans-unit id="2f56ccb8476fcf4652fb1a09b059f74067c2b7dc" translate="yes" xml:space="preserve">
          <source>It is usually more efficient to split a binary using matching instead of calling the &lt;code&gt;split_binary/2&lt;/code&gt; function. Furthermore, mixing bit syntax matching and &lt;code&gt;split_binary/2&lt;/code&gt; can prevent some optimizations of bit syntax matching.</source>
          <target state="translated">Обычно более эффективно разделить двоичный файл с помощью сопоставления вместо вызова функции &lt;code&gt;split_binary/2&lt;/code&gt; . Более того, смешивание соответствия битового синтаксиса и &lt;code&gt;split_binary/2&lt;/code&gt; может предотвратить некоторые оптимизации сопоставления битового синтаксиса.</target>
        </trans-unit>
        <trans-unit id="d40f0e2b9bfde282c6fadde5330a44421ff3e0a0" translate="yes" xml:space="preserve">
          <source>It is very easy to build a working OpenSSL FIPS Object Module and library from the source. However it &lt;strong&gt;does not&lt;/strong&gt; qualify as FIPS 140-2 validated if the numerous restrictions in the Security Policy are not properly followed.</source>
          <target state="translated">Очень легко создать работающий объектный модуль и библиотеку OpenSSL FIPS из исходного кода. Однако он &lt;strong&gt;не&lt;/strong&gt; считается проверенным FIPS 140-2, если не соблюдаются должным образом многочисленные ограничения в политике безопасности.</target>
        </trans-unit>
        <trans-unit id="62c48e1d02aa5042a563d9cdc46a5c1f705ab388" translate="yes" xml:space="preserve">
          <source>It is vital to understand the difference between encodings and Unicode characters. Unicode characters are code points according to the Unicode standard, while the encodings are ways to represent such code points. An encoding is only a standard for representation. UTF-8 can, for example, be used to represent a very limited part of the Unicode character set (for example ISO-Latin-1) or the full Unicode range. It is only an encoding format.</source>
          <target state="translated">Крайне важно понять разницу между кодировками и символами Юникода.Символы Юникода-это точки кода в соответствии со стандартом Юникод,а кодировки-это способы представления таких точек кода.Кодировка-это только стандарт для представления.UTF-8 может,например,использоваться для представления очень ограниченной части набора символов Юникода (например,ISO-Latin-1)или всего диапазона кодов Юникода.Это только формат кодировки.</target>
        </trans-unit>
        <trans-unit id="0b9d2d00c773da9822d8e2592e3080b84694726c" translate="yes" xml:space="preserve">
          <source>It localizes a set of alternatives. For example, the following pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;:</source>
          <target state="translated">Локализует набор альтернатив.Например,следующий образец соответствует &quot;катаракте&quot;,&quot;гусенице&quot; или &quot;кошке&quot;:</target>
        </trans-unit>
        <trans-unit id="36ff8f13092a39bd2ba61c1ed0f713f6c5f51ed0" translate="yes" xml:space="preserve">
          <source>It makes debugging difficult (as a fault can be the result of a problem in a different test case than the one failing).</source>
          <target state="translated">Это усложняет отладку (так как неисправность может быть результатом проблемы в другом тестовом случае,чем неисправность).</target>
        </trans-unit>
        <trans-unit id="71e868c4d221d1f6e3b2db5cf4b3d7a681d61288" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases in a different order.</source>
          <target state="translated">Это делает невозможным проведение тестов в другом порядке.</target>
        </trans-unit>
        <trans-unit id="607d901de681a7b70bb610e89380efa89701b1d6" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases individually.</source>
          <target state="translated">Это делает невозможным проведение тестов по отдельности.</target>
        </trans-unit>
        <trans-unit id="c4d9bde63bab462d455aa3cb421fb8522231409c" translate="yes" xml:space="preserve">
          <source>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization.</source>
          <target state="translated">Это совпадает с &quot;ab&quot; в теме &quot;aab&quot;.Использование управляющих глаголов обратного отсчета (*PRUNE)и (*SKIP)также отключает эту оптимизацию.</target>
        </trans-unit>
        <trans-unit id="19d42ec8f2740a3cd0c2abd5afb5c44bd8a74c60" translate="yes" xml:space="preserve">
          <source>It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">Она также может бросать ноутсуп исключения в случае отсутствия поддержки движка в базовой реализации OpenSSL.</target>
        </trans-unit>
        <trans-unit id="9ae8d33567c40fce809d17bd5e11afa0ce732fac" translate="yes" xml:space="preserve">
          <source>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Notice that the list &lt;code&gt;[a, b, c]&lt;/code&gt; can be written as &lt;code&gt;[a | [b | [c]]]&lt;/code&gt;. Using this, a list can be written as conses.</source>
          <target state="translated">Может показаться, что невозможно создать список, не зная заранее количество элементов. Но выход действительно есть. Обратите внимание, что список &lt;code&gt;[a, b, c]&lt;/code&gt; можно записать как &lt;code&gt;[a | [b | [c]]]&lt;/code&gt; . Используя это, список может быть записан в виде conses.</target>
        </trans-unit>
        <trans-unit id="5c879b18f150b020c56c6dce149540d933f7ca26" translate="yes" xml:space="preserve">
          <source>It might be necessary to introduce incompatible changes in order to solve a security issue. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">Для решения вопроса безопасности может потребоваться внесение несовместимых изменений.Подобная несовместимость может произойти в заплатке.</target>
        </trans-unit>
        <trans-unit id="f6df38f1f74cd5ca73948bc650a636f7e7345d28" translate="yes" xml:space="preserve">
          <source>It might seem strange to do a two-step upgrade instead of just restarting the emulator with the new version of all applications. The reason for this design decision is to allow &lt;code&gt;code_change&lt;/code&gt; functions to have side effects, for example, changing data on disk. It also guarantees that the upgrade mechanism for non-core applications does not differ depending on whether or not core applications are changed at the same time.</source>
          <target state="translated">Может показаться странным выполнить двухэтапное обновление вместо того, чтобы просто перезапустить эмулятор с новой версией всех приложений. Причина этого дизайнерского решения - позволить функциям &lt;code&gt;code_change&lt;/code&gt; иметь побочные эффекты, например, изменение данных на диске. Это также гарантирует, что механизм обновления для неосновных приложений не будет отличаться в зависимости от того, изменяются ли основные приложения одновременно.</target>
        </trans-unit>
        <trans-unit id="1c34c71fa77eb63943ded2490f8fbc60c0d144da" translate="yes" xml:space="preserve">
          <source>It no longer matters (from a performance point of view) whether you write:</source>
          <target state="translated">Больше не имеет значения (с точки зрения производительности),пишете ли вы:</target>
        </trans-unit>
        <trans-unit id="7c0489d666e1d6a42d00584a53dc773e8c02317f" translate="yes" xml:space="preserve">
          <source>It performs the following:</source>
          <target state="translated">Он выполняет следующее:</target>
        </trans-unit>
        <trans-unit id="4fc1e9aa2fcfb01c3fccf6fff85e215c7e86dd75" translate="yes" xml:space="preserve">
          <source>It requires the following entry in the configuration file:</source>
          <target state="translated">Для этого требуется следующая запись в файле конфигурации:</target>
        </trans-unit>
        <trans-unit id="4aee747e0c3b08a2000058880942c33ddee8f0ee" translate="yes" xml:space="preserve">
          <source>It returns the list obtained by applying the function to every argument in the list.</source>
          <target state="translated">Он возвращает список,полученный путем применения функции к каждому аргументу в списке.</target>
        </trans-unit>
        <trans-unit id="f32ea958d1b1b586fa5414a3a7ed52f8eb465554" translate="yes" xml:space="preserve">
          <source>It returns the value of &lt;code&gt;Exprs&lt;/code&gt; (a sequence of expressions &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt;) unless an exception occurs during the evaluation. In that case the exception is caught and the patterns &lt;code&gt;ExceptionPattern&lt;/code&gt; with the right exception class &lt;code&gt;Class&lt;/code&gt; are sequentially matched against the caught exception. If a match succeeds and the optional guard sequence &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;ExceptionBody&lt;/code&gt; is evaluated to become the return value.</source>
          <target state="translated">Он возвращает значение &lt;code&gt;Exprs&lt;/code&gt; (последовательность выражений &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt; ), если во время оценки не возникает исключение. В этом случае исключение перехватываются и узоры &lt;code&gt;ExceptionPattern&lt;/code&gt; с правом класса исключения &lt;code&gt;Class&lt;/code&gt; последовательно сравниваются с пойманным исключением. Если совпадение выполнено успешно и необязательная защитная последовательность &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; имеет значение true, соответствующее &lt;code&gt;ExceptionBody&lt;/code&gt; оценивается как возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="f85990d4de42826fd89466e5ce7eebe1a15edc61" translate="yes" xml:space="preserve">
          <source>It sends the &lt;code&gt;io_reply&lt;/code&gt; tuple back to the client, providing element &lt;code&gt;ReplyAs&lt;/code&gt; received in the request along with the result of the request, as described earlier.</source>
          <target state="translated">Он отправляет кортеж &lt;code&gt;io_reply&lt;/code&gt; обратно клиенту, предоставляя элемент &lt;code&gt;ReplyAs&lt;/code&gt; , полученный в запросе, вместе с результатом запроса, как описано ранее.</target>
        </trans-unit>
        <trans-unit id="6b6a1da626faadda605a267c6b1500e6d3d0ae88" translate="yes" xml:space="preserve">
          <source>It sets up the subpattern as a capturing subpattern. That is, when the complete pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller through the return value of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Он устанавливает подшаблон как захватывающий подшаблон. То есть, когда полный шаблон совпадает, та часть строки темы, которая соответствует подшаблону, передается обратно вызывающей стороне через возвращаемое значение &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49a082c6d89e819754d3f9153b8a7dfa0e39813e" translate="yes" xml:space="preserve">
          <source>It starts a tracer server and then sets the proper match spec (according to &lt;code&gt;Level&lt;/code&gt;).</source>
          <target state="translated">Он запускает сервер трассировки и затем устанавливает правильную спецификацию соответствия (в соответствии с &lt;code&gt;Level&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="53405be9e406cd843e6767fd23eee426b478f794" translate="yes" xml:space="preserve">
          <source>It takes 32-bit salt values and generates hashes within &lt;code&gt;0..2^32-1&lt;/code&gt;.</source>
          <target state="translated">Он принимает 32-битные значения соли и генерирует хеши в пределах &lt;code&gt;0..2^32-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b133d4d9bba6fcd143fa7778c2fc2dec25c3c1b" translate="yes" xml:space="preserve">
          <source>It uses only numeric or bitwise operators.</source>
          <target state="translated">Он использует только числовые или битовые операторы.</target>
        </trans-unit>
        <trans-unit id="823797789dab9b16b0bc93679f0645c51a5106e7" translate="yes" xml:space="preserve">
          <source>It writes &quot;Ping received pong&quot; when this reply arrives, after which &quot;ping&quot; calls the &lt;code&gt;ping&lt;/code&gt; function again.</source>
          <target state="translated">Когда приходит этот ответ, он пишет &amp;laquo;Ping got pong&amp;raquo;, после чего &amp;laquo;ping&amp;raquo; снова вызывает функцию &lt;code&gt;ping&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67225ea18531ad9a06624765739ff0f49809146c" translate="yes" xml:space="preserve">
          <source>It's assumed that the reader is familiar with &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt;. To be able to patch an application, the following must exist:</source>
          <target state="translated">Предполагается, что читатель знаком со &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt; . Чтобы иметь возможность исправлять приложение, должно существовать следующее:</target>
        </trans-unit>
        <trans-unit id="c5929da3898f0513dfeb23acbd712fe856694c82" translate="yes" xml:space="preserve">
          <source>It, however, uses a native implementation that does not build garbage on the heap and with slightly better performance.</source>
          <target state="translated">Тем не менее,она использует нативную реализацию,которая не собирает мусор на куче и с немного лучшей производительностью.</target>
        </trans-unit>
        <trans-unit id="a06554ccb7c2d93d192c3296f349c54998105ca2" translate="yes" xml:space="preserve">
          <source>Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears.</source>
          <target state="translated">Элемент (?p{...})интерполирует Perl-код во время выполнения,и в данном случае рекурсивно ссылается на паттерн,в котором он появляется.</target>
        </trans-unit>
        <trans-unit id="f9de605e9ca977eaf604ed29c15fb02f2b60a6a8" translate="yes" xml:space="preserve">
          <source>Items can be logged &lt;strong&gt;synchronously&lt;/strong&gt; by using functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt;. For each of these functions, the caller is put on hold until the items are logged (but not necessarily written, use &lt;code&gt;sync/1&lt;/code&gt; to ensure that). By adding an &lt;code&gt;a&lt;/code&gt; to each of the mentioned function names, we get functions that log items &lt;strong&gt;asynchronously&lt;/strong&gt;. Asynchronous functions do not wait for the disk log process to write the items to the file, but return the control to the caller more or less immediately.</source>
          <target state="translated">Элементы могут регистрироваться &lt;strong&gt;синхронно&lt;/strong&gt; с помощью функций &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt; . Для каждой из этих функций вызывающий объект удерживается до тех пор, пока элементы не будут зарегистрированы (но не обязательно записаны, используйте &lt;code&gt;sync/1&lt;/code&gt; , чтобы убедиться в этом). Добавляя &lt;code&gt;a&lt;/code&gt; к каждому из упомянутых имен функций, мы получаем функции, которые регистрируют элементы &lt;strong&gt;асинхронно&lt;/strong&gt; . Асинхронные функции не ждут, пока процесс журнала диска запишет элементы в файл, а более или менее немедленно возвращают управление вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="71d4607a768e8062fc1b15efd7c3e9e68a5b3118" translate="yes" xml:space="preserve">
          <source>Iterate over the currently stored events.</source>
          <target state="translated">Итерриториальные по отношению к хранящимся в настоящее время событиям.</target>
        </trans-unit>
        <trans-unit id="fcc26dcea46a8c4cabfbf0c36c28de8e261927eb" translate="yes" xml:space="preserve">
          <source>Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</source>
          <target state="translated">Итерируется по резервной копии,либо преобразовывает ее в новую,либо читает ее.Аргументы кратко объясняются здесь.Подробности см.в Руководстве пользователя.</target>
        </trans-unit>
        <trans-unit id="f75cc851edeeaf3491a906e7e439b3b971925d8d" translate="yes" xml:space="preserve">
          <source>Iterates over the currently stored events and applies a function for each event. The iteration may be performed forwards or backwards and may be limited to a maximum number of events (abs(Limit)).</source>
          <target state="translated">Перемещает текущие сохраненные события и применяет функцию для каждого события.Итерация может быть выполнена вперед или назад и может быть ограничена максимальным количеством событий (abs(Limit)).</target>
        </trans-unit>
        <trans-unit id="a06d957ebec629d0f972194da6df852ad0d09740" translate="yes" xml:space="preserve">
          <source>Iterates over the table &lt;code&gt;Table&lt;/code&gt; and calls &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; for each &lt;code&gt;Record&lt;/code&gt; in the table. The term returned from &lt;code&gt;Function&lt;/code&gt; is used as the second argument in the next call to &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">Обходит таблицу &lt;code&gt;Table&lt;/code&gt; и вызывает &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; для каждой &lt;code&gt;Record&lt;/code&gt; в таблице. Термин, возвращаемый &lt;code&gt;Function&lt;/code&gt; , используется в качестве второго аргумента при следующем вызове &lt;code&gt;Function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="5786bb0f4dccffae9058c126884fe6758b70bd8a" translate="yes" xml:space="preserve">
          <source>Its syntax is as follows:</source>
          <target state="translated">Его синтаксис следующий:</target>
        </trans-unit>
        <trans-unit id="0165af04c080f487130b22dea529e0f95b8d85ca" translate="yes" xml:space="preserve">
          <source>Its value can be evaluated to a constant when complied.</source>
          <target state="translated">Его значение может быть оценено до константы,если оно соблюдается.</target>
        </trans-unit>
        <trans-unit id="56d1de825316e64de255f931e870a2d3e72a7f4f" translate="yes" xml:space="preserve">
          <source>James logs on at c2@kosken:</source>
          <target state="translated">Джеймс заходит на сайт c2@kosken:</target>
        </trans-unit>
        <trans-unit id="c42ecc8a80467df93a2c87a03b9343afff3e3487" translate="yes" xml:space="preserve">
          <source>James now tries to send a message to Fred:</source>
          <target state="translated">Джеймс теперь пытается послать сообщение Фреду:</target>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="985f31fc009e0eb1ee596f08399982c19f072dde" translate="yes" xml:space="preserve">
          <source>Jive - Removed from Erlang/OTP R7B.</source>
          <target state="translated">Jive-Удалено из Erlang/OTP R7B.</target>
        </trans-unit>
        <trans-unit id="f404bac0df97acac197f63ffb414c0a51f6641b9" translate="yes" xml:space="preserve">
          <source>Jive provided a simple interface between an Erlang program and a Java program.</source>
          <target state="translated">Jive обеспечил простой интерфейс между программой Erlang и программой Java.</target>
        </trans-unit>
        <trans-unit id="d4aaf0c42e0ce9df5b69e24e3360c3fccba4e12c" translate="yes" xml:space="preserve">
          <source>Job Control Mode, &lt;code&gt;JCL&lt;/code&gt;, in which jobs can be started, killed, detached, and connected</source>
          <target state="translated">Режим управления &lt;code&gt;JCL&lt;/code&gt; , JCL , в котором задания могут быть запущены, уничтожены, отсоединены и подключены</target>
        </trans-unit>
        <trans-unit id="60fcc4fbeee80db53471e4e665b7867b155491ca" translate="yes" xml:space="preserve">
          <source>Joined specifications share common configuration settings, such as the list of &lt;code&gt;config&lt;/code&gt; files or &lt;code&gt;include&lt;/code&gt; directories. For configurations that cannot be combined, such as settings for &lt;code&gt;logdir&lt;/code&gt; or &lt;code&gt;verbosity&lt;/code&gt;, it is up to the user to ensure there are no clashes when the test specifications are joined. Specifications included with option &lt;code&gt;separate&lt;/code&gt; do not share configuration settings with the source specification. This is useful, for example, if there are clashing configuration settings in included specifications, making it them impossible to join.</source>
          <target state="translated">Объединенные спецификации имеют общие параметры конфигурации, такие как список файлов &lt;code&gt;config&lt;/code&gt; или &lt;code&gt;include&lt;/code&gt; каталоги. Для конфигураций, которые не могут быть объединены, таких как настройки для &lt;code&gt;logdir&lt;/code&gt; или &lt;code&gt;verbosity&lt;/code&gt; , пользователь должен гарантировать отсутствие конфликтов при объединении спецификаций теста. Спецификации, включенные в &lt;code&gt;separate&lt;/code&gt; опцию , не разделяют настройки конфигурации с исходной спецификацией. Это полезно, например, если есть конфликтующие параметры конфигурации во включенных спецификациях, что делает невозможным их присоединение.</target>
        </trans-unit>
        <trans-unit id="09836e547b774a1e0d6ccac306d02bc552ce1707" translate="yes" xml:space="preserve">
          <source>Joining a number of specifications, or running them separately, can also be accomplished with (and can be combined with) test specification file inclusion.</source>
          <target state="translated">Объединение ряда спецификаций или их запуск по отдельности также может быть осуществлен с включением (и может быть совмещен с включением)файла тестовой спецификации.</target>
        </trans-unit>
        <trans-unit id="bd8fa532a1f183308b75829983ef5286dd43f6ae" translate="yes" xml:space="preserve">
          <source>Joins a list of filename &lt;code&gt;Components&lt;/code&gt; with directory separators. If one of the elements of &lt;code&gt;Components&lt;/code&gt; includes an absolute path, such as &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt;, the preceding elements, if any, are removed from the result.</source>
          <target state="translated">Присоединяет список имен файлов &lt;code&gt;Components&lt;/code&gt; с разделителями каталогов. Если один из элементов &lt;code&gt;Components&lt;/code&gt; включает абсолютный путь, такой как &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt; , предыдущие элементы, если таковые имеются, удаляются из результата.</target>
        </trans-unit>
        <trans-unit id="767d4fa36d9593f6ccc09a43de0901229900dc82" translate="yes" xml:space="preserve">
          <source>Joins a multicast group.</source>
          <target state="translated">Присоединяется к многоадресной группе.</target>
        </trans-unit>
        <trans-unit id="f18e485822fa69f055b28a9bb0d0a99a002c6e43" translate="yes" xml:space="preserve">
          <source>Joins an absolute directory with a relative filename. Similar to &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in &lt;code&gt;Filename&lt;/code&gt; are matched against trailing directory components in &lt;code&gt;Dir&lt;/code&gt; so they can be removed from the result - minimizing its length.</source>
          <target state="translated">Присоединяется к абсолютному каталогу с относительным именем файла. Подобно &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; , но на платформах с жесткими ограничениями на длину исходного файла и без поддержки символических ссылок (читай: VxWorks), ведущие компоненты родительского каталога в имени &lt;code&gt;Filename&lt;/code&gt; сопоставляются с компонентами конечного каталога в &lt;code&gt;Dir&lt;/code&gt; , поэтому их можно удалить из результата. - минимизация его длины.</target>
        </trans-unit>
        <trans-unit id="b01e92d8e16fef4b631125f5e97915c826988378" translate="yes" xml:space="preserve">
          <source>Joins individual comment lines into multi-line comments. The input is a list of entries representing individual comment lines, &lt;strong&gt;in order of decreasing line-numbers&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; for details. The result is a list of entries representing &lt;strong&gt;multi-line&lt;/strong&gt; comments, &lt;strong&gt;still listed in order of decreasing line-numbers&lt;/strong&gt;, but where for each entry, &lt;code&gt;Text&lt;/code&gt; is a list of consecutive comment lines in order of &lt;strong&gt;increasing&lt;/strong&gt; line-numbers (i.e., top-down).</source>
          <target state="translated">Объединяет отдельные строки комментариев в многострочные комментарии. Входные данные - это список записей, представляющих отдельные строки комментариев, &lt;strong&gt;в порядке убывания номеров строк&lt;/strong&gt; ; подробнее см. &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; . Результатом является список записей, представляющих &lt;strong&gt;многострочные&lt;/strong&gt; комментарии, &lt;strong&gt;все еще перечисленные в порядке убывания номеров строк&lt;/strong&gt; , но где для каждой записи &lt;code&gt;Text&lt;/code&gt; представляет собой список последовательных строк комментариев в порядке &lt;strong&gt;увеличения&lt;/strong&gt; номеров строк (т. Е. Сверху вниз ).</target>
        </trans-unit>
        <trans-unit id="a0528c50bacb4e35cb285f0ed3e8896f71709c3e" translate="yes" xml:space="preserve">
          <source>Joins the calling thread with another thread, that is, the calling thread is blocked until the thread identified by &lt;code&gt;tid&lt;/code&gt; has terminated.</source>
          <target state="translated">Присоединяется к вызывающему потоку с другим потоком, то есть вызывающий поток блокируется до тех пор, пока поток, идентифицированный &lt;code&gt;tid&lt;/code&gt; , не завершится.</target>
        </trans-unit>
        <trans-unit id="ed124b10c968f3ba56bc00750777640854ffbb45" translate="yes" xml:space="preserve">
          <source>Joins the process &lt;code&gt;Pid&lt;/code&gt; to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="translated">Присоединяется к процессу &lt;code&gt;Pid&lt;/code&gt; к группе &lt;code&gt;Name&lt;/code&gt; . Процесс может присоединяться к группе много раз, а затем должен выходить из группы такое же количество раз.</target>
        </trans-unit>
        <trans-unit id="a725b3a9aec37eb16b991bfa7ac62728bda90c3f" translate="yes" xml:space="preserve">
          <source>Joins two filename components with directory separators. Equivalent to &lt;code&gt;join([Name1, Name2])&lt;/code&gt;.</source>
          <target state="translated">Объединяет два компонента имени файла с разделителями каталогов. Эквивалентно &lt;code&gt;join([Name1, Name2])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c209b4f5dd5eec8921277cc06b858d506fcc16" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^512 calls</source>
          <target state="translated">Прыжковая функция:эквивалент 2^512 вызовов</target>
        </trans-unit>
        <trans-unit id="e9519676df51c9a760d29ebd09d2737821522add" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^64 calls</source>
          <target state="translated">Прыжковая функция:эквивалентно 2^64 вызовам</target>
        </trans-unit>
        <trans-unit id="993f27123cfb967c548d6417f96dc64d01aeac7a" translate="yes" xml:space="preserve">
          <source>Just add the &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; option to your command when you run the &lt;code&gt;configure&lt;/code&gt; script. If you are using systemtap, the configure option is &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</source>
          <target state="translated">Просто добавьте параметр &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; в свою команду при запуске сценария &lt;code&gt;configure&lt;/code&gt; . Если вы используете systemtap, параметр конфигурации &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="954a229b3c7d24932c013089be8a60de0b28ba48" translate="yes" xml:space="preserve">
          <source>Just prints a marker showing the current file and line number. Note that this is an argument-less macro. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">Просто печатает маркер, показывающий текущий файл и номер строки. Обратите внимание, что это макрос без аргументов. Результат всегда в &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="25abdae1d9ca507dc9eba57c2eaf4112edb57019" translate="yes" xml:space="preserve">
          <source>Keep alive (sends NOP to the server every 8 sec if connection is idle) = &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Сохранять активность (отправляет NOP на сервер каждые 8 ​​секунд, если соединение неактивно) = &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ddeccd73131648e86aeb841d4eb296569a6a514" translate="yes" xml:space="preserve">
          <source>Keep in mind that external commands are highly dependent on the operating system. You can use the standard library function &lt;code&gt;os:type()&lt;/code&gt; in test generator functions, to produce different sets of tests depending on the current operating system.</source>
          <target state="translated">Имейте в виду, что внешние команды сильно зависят от операционной системы. Вы можете использовать стандартную библиотечную функцию &lt;code&gt;os:type()&lt;/code&gt; в функциях генератора тестов для создания различных наборов тестов в зависимости от текущей операционной системы.</target>
        </trans-unit>
        <trans-unit id="af2e28b7a1b7099319eee33d2a3b8c97b2e40baf" translate="yes" xml:space="preserve">
          <source>Keep the monitoring process neat and do not set the system monitor limits too tight.</source>
          <target state="translated">Следите за тем,чтобы процесс мониторинга проходил аккуратно и не устанавливайте слишком жесткие границы системного мониторинга.</target>
        </trans-unit>
        <trans-unit id="500721d2cc2f16b61805dc2d3a9d1060f70c2830" translate="yes" xml:space="preserve">
          <source>Keeping an index table introduces some overhead when inserting records in the table. The number of operations gained from the table must therefore be compared against the number of operations inserting objects in the table. However, notice that the gain is significant when the key can be used to lookup elements.</source>
          <target state="translated">Ведение индексной таблицы вносит некоторые накладные расходы при вставке записей в таблицу.Поэтому количество операций,полученных из таблицы,должно сравниваться с количеством операций по вставке объектов в таблицу.Однако обратите внимание,что выигрыш является существенным,когда ключ может быть использован для поиска элементов.</target>
        </trans-unit>
        <trans-unit id="77d353f60b778f61763e54fe995206afd07d38e7" translate="yes" xml:space="preserve">
          <source>Kernel - Functionality necessary to run Erlang</source>
          <target state="translated">Ядро-Функциональность,необходимая для работы Erlang</target>
        </trans-unit>
        <trans-unit id="d94461d9eb74a4bd391db53e61a81a60c815b678" translate="yes" xml:space="preserve">
          <source>Key &lt;code&gt;mod&lt;/code&gt; is necessary for an application implemented as a supervision tree, otherwise the application controller does not know how to start it. &lt;code&gt;mod&lt;/code&gt; can be omitted for applications without processes, typically code libraries, for example, STDLIB.</source>
          <target state="translated">Ключевой &lt;code&gt;mod&lt;/code&gt; необходим для приложения, реализованного в виде дерева наблюдения, иначе контроллер приложения не знает, как его запустить. &lt;code&gt;mod&lt;/code&gt; можно опустить для приложений без процессов, обычно библиотек кода, например STDLIB.</target>
        </trans-unit>
        <trans-unit id="ca5a9efe453be1a8fb90eb103db6529be3cedecc" translate="yes" xml:space="preserve">
          <source>Key exchange.</source>
          <target state="translated">Обмен ключами.</target>
        </trans-unit>
        <trans-unit id="ef9462cf7acc58f9332c44f3d35c8156471e2d59" translate="yes" xml:space="preserve">
          <source>Key length is 128, 192 or 256 bits</source>
          <target state="translated">Длина ключа 128,192 или 256 бит.</target>
        </trans-unit>
        <trans-unit id="8e49238278cd15e4058ff109458f7ab64787d062" translate="yes" xml:space="preserve">
          <source>Key length is 64 bits (in CBC mode only 8 bits are used)</source>
          <target state="translated">Длина ключа 64 бита (в режиме CBC используется только 8 бит).</target>
        </trans-unit>
        <trans-unit id="a8eda14ae757b93056cfd42c03aa35572e0dfbf4" translate="yes" xml:space="preserve">
          <source>Key that thread-specific data can be associated with.</source>
          <target state="translated">Ключ,с которым можно связать потоковые данные.</target>
        </trans-unit>
        <trans-unit id="54bec160f0ff07cdaa698765d9e3b701a9206120" translate="yes" xml:space="preserve">
          <source>Key-value dictionary as ordered list.</source>
          <target state="translated">Словарь ключевых значений в виде упорядоченного списка.</target>
        </trans-unit>
        <trans-unit id="03548558e8e95e2c9e4473346b7862a221a3449a" translate="yes" xml:space="preserve">
          <source>Key-value dictionary.</source>
          <target state="translated">Словарь ключевых значений.</target>
        </trans-unit>
        <trans-unit id="64a1a6e2ae2f7e426d8c76fa00ed13e339774927" translate="yes" xml:space="preserve">
          <source>Keys and values are separated by the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow and associations are separated by a comma &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">Ключи и значения отделяются друг от друга &lt;code&gt;=&amp;gt;&lt;/code&gt; стрелки и объединения отделены друг от друга запятой &lt;code&gt;,&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ef25fb2e036bb0a08a44baf61c0ca27e1477ef" translate="yes" xml:space="preserve">
          <source>Keys are strings, that is, &lt;code&gt;NULL&lt;/code&gt;-terminated arrays of characters, and values are arbitrary objects. Although integers and floating point numbers are treated specially by the registry, you can store strings or binary objects of any type as pointers.</source>
          <target state="translated">Ключи - это строки, то есть массивы символов с окончанием &lt;code&gt;NULL&lt;/code&gt; , а значения - произвольные объекты. Хотя целые числа и числа с плавающей запятой обрабатываются реестром особым образом, вы можете хранить строки или двоичные объекты любого типа в качестве указателей.</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="ae06f314c491ae0e878d4c91501cd37217955650" translate="yes" xml:space="preserve">
          <source>Khojki</source>
          <target state="translated">Khojki</target>
        </trans-unit>
        <trans-unit id="0aff8b4bceea8e19c584f9aea3e91bc8fa365436" translate="yes" xml:space="preserve">
          <source>Khudawadi</source>
          <target state="translated">Khudawadi</target>
        </trans-unit>
        <trans-unit id="1d5d5869cb0eedafcc8a41f33ab897f070f4fb42" translate="yes" xml:space="preserve">
          <source>Kill line</source>
          <target state="translated">линия убийств</target>
        </trans-unit>
        <trans-unit id="f454e1ed16b6541108a62b0e0fc74e1cd5b5843d" translate="yes" xml:space="preserve">
          <source>Kill or suspend the current shell</source>
          <target state="translated">Убить или приостановить текущую оболочку</target>
        </trans-unit>
        <trans-unit id="880f10ee37e48d0c630a2a5789a5d88a3169af1e" translate="yes" xml:space="preserve">
          <source>Kill the receiving process.</source>
          <target state="translated">Убейте процесс приема.</target>
        </trans-unit>
        <trans-unit id="5bfcbaee6e0f4c10a8cefbf0071cff67b1bf2828" translate="yes" xml:space="preserve">
          <source>Killing the running &lt;code&gt;epmd&lt;/code&gt; is only allowed if &lt;code&gt;epmd -names&lt;/code&gt; shows an empty database or if &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified when the running instance of &lt;code&gt;epmd&lt;/code&gt; was started.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; работы запущенного epmd разрешено только в том случае, если &lt;code&gt;epmd -names&lt;/code&gt; показывает пустую базу данных или если &lt;code&gt;-relaxed_command_check&lt;/code&gt; была указана при запуске запущенного экземпляра &lt;code&gt;epmd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b4606adf1d6fece03ee95344c970518fc47aef2" translate="yes" xml:space="preserve">
          <source>Kills job number &lt;code&gt;nn&lt;/code&gt; or the current job. All spawned processes in the job are killed, provided they have not evaluated the &lt;code&gt;group_leader/1&lt;/code&gt; BIF and are located on the local machine. Processes spawned on remote nodes are not killed.</source>
          <target state="translated">Убивает задание номер &lt;code&gt;nn&lt;/code&gt; или текущее задание. Все порожденные процессы в задании уничтожаются при условии, что они не оценили &lt;code&gt;group_leader/1&lt;/code&gt; BIF и расположены на локальном компьютере. Процессы, созданные на удаленных узлах, не уничтожаются.</target>
        </trans-unit>
        <trans-unit id="cc10a5d2feb24085bc1cb119b2435586c453c952" translate="yes" xml:space="preserve">
          <source>Kills the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">Убивает запущенный в данный момент &lt;code&gt;epmd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d84b2a4d9545512a2d7f125ae79d81a8e5c0761" translate="yes" xml:space="preserve">
          <source>Known hosts - OpenSSH format looks as follows:</source>
          <target state="translated">Известные хосты-Формат OpenSSH выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="0a39eb519037dfb6d76d299ba4999c6ffc80181b" translate="yes" xml:space="preserve">
          <source>Known issue: When a node is restarted multiple times with the same node name, references created on a newer node can be mistaken for a reference created on an older node with the same node name.</source>
          <target state="translated">Известная проблема:При многократном перезапуске узла с одним и тем же именем,ссылки,созданные на более новом узле,могут быть ошибочно приняты за ссылки,созданные на более старом узле с одним и тем же именем.</target>
        </trans-unit>
        <trans-unit id="cf67592c20c9144029824037c9c62ac2e394e9f6" translate="yes" xml:space="preserve">
          <source>Known nodes</source>
          <target state="translated">Известные узлы</target>
        </trans-unit>
        <trans-unit id="ed13795fff22b6ce7eef6295ec8759f5887cc8c1" translate="yes" xml:space="preserve">
          <source>LALR-1 Parser Generator</source>
          <target state="translated">Генератор парсеров LALR-1</target>
        </trans-unit>
        <trans-unit id="8c1317978bcd30e222ba66c242f8123e43c7856b" translate="yes" xml:space="preserve">
          <source>LDAP Client</source>
          <target state="translated">LDAP-клиент</target>
        </trans-unit>
        <trans-unit id="51eb7d6d9c204fdf12fe469c25a3f66ed762d7c2" translate="yes" xml:space="preserve">
          <source>LTTng-UST: user space tracing library.</source>
          <target state="translated">LTTng-UST:библиотека трассировки пространства пользователя.</target>
        </trans-unit>
        <trans-unit id="1a3e364b61f5b7002da39483efb6f5c6e878f8ed" translate="yes" xml:space="preserve">
          <source>LTTng-tools: a command line interface to control tracing sessions.</source>
          <target state="translated">LTTng-инструменты:интерфейс командной строки для управления сеансами трассировки.</target>
        </trans-unit>
        <trans-unit id="835d9d02d574ee591fe276efb1ca4a509eeac77d" translate="yes" xml:space="preserve">
          <source>Label (type) of the event.</source>
          <target state="translated">Метка (тип)события.</target>
        </trans-unit>
        <trans-unit id="da8c0bd743f4d20bdd7803e99770281ada2c9a3c" translate="yes" xml:space="preserve">
          <source>Label intended to provide a brief event summary.</source>
          <target state="translated">Этикетка предназначена для предоставления краткого резюме мероприятия.</target>
        </trans-unit>
        <trans-unit id="569411a8a6e7229622b5dc0e1261f3311e3e9ca4" translate="yes" xml:space="preserve">
          <source>Label the test run (similar to &lt;code&gt;ct_run -label&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ct_run -label&lt;/code&gt; тестовый прогон (аналогично ct_run -label ).</target>
        </trans-unit>
        <trans-unit id="8a2ceed634c06e53fd54795bf2ad3a353a944142" translate="yes" xml:space="preserve">
          <source>Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token will be silenty dropped if it crosses over to a node that does not support the label.</source>
          <target state="translated">Ярлыки были ограничены небольшими целыми числами с подписями (28 бит)до OTP 21.Трассировочная лексема будет заглушена,если она перейдет в узел,который не поддерживает метку.</target>
        </trans-unit>
        <trans-unit id="8ca0beae5821435b0fbc549f128dd2d696efd3c9" translate="yes" xml:space="preserve">
          <source>Lack of support. Such as loading NIF library for a HiPE compiled module.</source>
          <target state="translated">Отсутствие поддержки.Например,загрузка библиотеки NIF для скомпилированного модуля HiPE.</target>
        </trans-unit>
        <trans-unit id="bf9167c4d0a9ea5934fd36027e2b85a918a6fffd" translate="yes" xml:space="preserve">
          <source>Language constructions such as &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;catch&lt;/code&gt; that are not present in match specifications are not allowed.</source>
          <target state="translated">Языковые конструкции, такие как &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;catch&lt;/code&gt; , которых нет в спецификациях соответствия, не допускаются.</target>
        </trans-unit>
        <trans-unit id="074e87167a892ed75f793d4be4f6837d502c8b01" translate="yes" xml:space="preserve">
          <source>Language or locale specific handling of input is not considered in any function.</source>
          <target state="translated">Языковая или локальная обработка входа не учитывается ни в одной из функций.</target>
        </trans-unit>
        <trans-unit id="04eb4ab3dd59acb8c8766875365c70ae815f2eeb" translate="yes" xml:space="preserve">
          <source>Languages with no concept of upper case (or lower case).</source>
          <target state="translated">Языки без понятия &quot;верхний регистр&quot; (или &quot;нижний регистр&quot;).</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="738fd1d2452fc31a236c5ad511bfcc46b324365e" translate="yes" xml:space="preserve">
          <source>Large</source>
          <target state="translated">Large</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">Поддержка больших файлов</target>
        </trans-unit>
        <trans-unit id="a438bdcc6fdd98852d15b24d8295882a73c68552" translate="yes" xml:space="preserve">
          <source>Large Map (&amp;gt; 32 keys)</source>
          <target state="translated">Большая карта (&amp;gt; 32 ключа)</target>
        </trans-unit>
        <trans-unit id="09edce0ea90a1c7861091688fe21ce083d692315" translate="yes" xml:space="preserve">
          <source>Large bursts of log events - many events received by the handler under a short period of time - can potentially cause problems, such as:</source>
          <target state="translated">Большие всплески событий лога-многие события,получаемые обработчиком за короткий промежуток времени,-потенциально могут вызвать проблемы,например:</target>
        </trans-unit>
        <trans-unit id="54100e7e3068c1ca218d4f103c9eb3344bef2359" translate="yes" xml:space="preserve">
          <source>Large integer</source>
          <target state="translated">Большое целое число</target>
        </trans-unit>
        <trans-unit id="d84176d4d4e07b609ddf89b910ffa92d9b205afb" translate="yes" xml:space="preserve">
          <source>Large-scale automated testing requires running multiple independent test sessions in parallel. This is accomplished by running some &lt;code&gt;Common Test&lt;/code&gt; nodes on one or more hosts, testing different target systems. Configuring, starting, and controlling the test nodes independently can be a cumbersome operation. To aid this kind of automated large-scale testing, &lt;code&gt;Common Test&lt;/code&gt; offers a master test node component, &lt;code&gt;Common Test&lt;/code&gt; Master, which handles central configuration and control in a system of distributed &lt;code&gt;Common Test&lt;/code&gt; nodes.</source>
          <target state="translated">Для крупномасштабного автоматизированного тестирования требуется параллельное выполнение нескольких независимых тестовых сессий. Это достигается путем запуска нескольких узлов &lt;code&gt;Common Test&lt;/code&gt; на одном или нескольких хостах, тестирования различных целевых систем. Независимая настройка, запуск и управление тестовыми узлами могут быть обременительной операцией. Чтобы помочь в этом виде автоматизированного крупномасштабного тестирования, &lt;code&gt;Common Test&lt;/code&gt; предлагает компонент главного тестового узла, &lt;code&gt;Common Test&lt;/code&gt; Master, который выполняет централизованную настройку и управление в системе распределенных узлов &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44df0948d1567d9036374aa410e4c8a2be0c9c10" translate="yes" xml:space="preserve">
          <source>Larger programs are usually written as a collection of files with a well-defined interface between the various parts.</source>
          <target state="translated">Более крупные программы обычно пишутся как набор файлов с четко определенным интерфейсом между различными частями.</target>
        </trans-unit>
        <trans-unit id="693744ef4c03b347c7a1a709150a100f34f5dd75" translate="yes" xml:space="preserve">
          <source>Larger test cases make it harder to tell what went wrong if it fails. Also, large portions of test code risk being skipped when errors occur.</source>
          <target state="translated">Большие тестовые случаи затрудняют определение того,что пошло не так,если не получится.Кроме того,большая часть тестового кода рискует быть пропущена при возникновении ошибок.</target>
        </trans-unit>
        <trans-unit id="8908c45e62de1705042c387b70533568d70c9293" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 128 MB.</source>
          <target state="translated">Наибольший ( &lt;code&gt;mseg_alloc&lt;/code&gt; ) размер мультиблочного носителя (в килобайтах). См. Описание того, как определяются размеры для мультиблочных несущих &lt;code&gt;mseg_alloc&lt;/code&gt; , в разделе &amp;laquo; &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt; . В 32-битных ОС в стиле Unix этот предел не может быть&amp;gt; 128 МБ.</target>
        </trans-unit>
        <trans-unit id="7c3af79a814ee249e319b2aca0ff91587147fc1f" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">Последний аргумент для &lt;code&gt;start_link/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff3ac5eb04bb6845c35e02907378511f958744f" translate="yes" xml:space="preserve">
          <source>Last trans id.</source>
          <target state="translated">Последний трансид.</target>
        </trans-unit>
        <trans-unit id="92691b5a6cdf3c7e69cbf1e0e1a0775e6d6241e3" translate="yes" xml:space="preserve">
          <source>Last, the application master terminates. Notice that all processes with the application master as group leader, that is, processes spawned from a process belonging to the application, are also terminated.</source>
          <target state="translated">Наконец,мастер приложения прекращает работу.Заметьте,что все процессы,в которых ведущим является аппликационный мастер,т.е.процессы,порожденные из процесса,принадлежащего аппликационному мастеру,также завершаются.</target>
        </trans-unit>
        <trans-unit id="e67316d545772b35f3ccfda079c9a6451806f0ad" translate="yes" xml:space="preserve">
          <source>Later, when you have fixed a bug in your application my_app, you want to update the PLT so that it becomes fresh the next time you run Dialyzer. In this case, run the following command:</source>
          <target state="translated">Позже,когда вы исправите ошибку в своем приложении my_app,вы захотите обновить PLT так,чтобы он стал свежим при следующем запуске Dialyzer.В этом случае выполните следующую команду:</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="0870ce81860445392cddd5a3e67af112160f7b41" translate="yes" xml:space="preserve">
          <source>Leading slashes in tar member names will be removed before writing the file. That is, absolute paths will be turned into relative paths. There will be an info message written to the error logger when paths are changed in this way.</source>
          <target state="translated">Ведущие косые черты в именах членов tar будут удалены перед записью файла.То есть абсолютные пути будут преобразованы в относительные.При таком изменении путей в журнал ошибок будет записано информационное сообщение.</target>
        </trans-unit>
        <trans-unit id="0eb1f77fb19c9a09977d5bd220a6012ba74f0842" translate="yes" xml:space="preserve">
          <source>Leaves a multicast group.</source>
          <target state="translated">Оставляет многоадресную группу.</target>
        </trans-unit>
        <trans-unit id="46ca3dd951cfb863abc35ba1a75861a27f06846b" translate="yes" xml:space="preserve">
          <source>Leaves it up to the user to read and interpret the logged data. The &lt;code&gt;disk_log&lt;/code&gt; module cannot repair externally formatted logs.</source>
          <target state="translated">Предоставляет пользователю право читать и интерпретировать зарегистрированные данные. Модуль &lt;code&gt;disk_log&lt;/code&gt; не может восстанавливать журналы внешнего формата.</target>
        </trans-unit>
        <trans-unit id="b3210120e1c6a9da2f06b35919f757a581401639" translate="yes" xml:space="preserve">
          <source>Leex will add the extension &lt;code&gt;.hrl&lt;/code&gt; to the &lt;code&gt;Includefile&lt;/code&gt; name and the extension &lt;code&gt;.erl&lt;/code&gt; to the &lt;code&gt;Scannerfile&lt;/code&gt; name, unless the extension is already there.</source>
          <target state="translated">Leex добавит расширение &lt;code&gt;.hrl&lt;/code&gt; к имени &lt;code&gt;Includefile&lt;/code&gt; и расширение &lt;code&gt;.erl&lt;/code&gt; к имени &lt;code&gt;Scannerfile&lt;/code&gt; , если расширение уже не существует.</target>
        </trans-unit>
        <trans-unit id="1ac95874a8d20e24893ff29b459f57b2ffdf6541" translate="yes" xml:space="preserve">
          <source>Left associative</source>
          <target state="translated">Левая ассоциативная</target>
        </trans-unit>
        <trans-unit id="8565991e36224ecb55a79ffde16fa430f01d691e" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;process_msg/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">Устаревшая функция API &lt;code&gt;process_msg/7&lt;/code&gt; , имеющая отдельные аргументы &lt;code&gt;IpAddr&lt;/code&gt; и &lt;code&gt;PortNumber&lt;/code&gt; ,по- прежнему работает, как и раньше, по причинам обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="0f4bbc3721d99d879f2d29eca510835d82ca11bd" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;send_pdu/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">Устаревшая функция API &lt;code&gt;send_pdu/7&lt;/code&gt; , имеющая отдельные аргументы &lt;code&gt;IpAddr&lt;/code&gt; и &lt;code&gt;PortNumber&lt;/code&gt; ,по- прежнему работает, как и раньше, из соображений обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="a868752c2e0e19bf0913ba9d30f9f18839603e09" translate="yes" xml:space="preserve">
          <source>Legacy API functions &lt;code&gt;add_addr/10&lt;/code&gt; that does not specify transport domain, and &lt;code&gt;add_addr/11&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still work as before for backwards compatibility reasons.</source>
          <target state="translated">Устаревшие функции API &lt;code&gt;add_addr/10&lt;/code&gt; , в которых не указан транспортный домен, и &lt;code&gt;add_addr/11&lt;/code&gt; , у которого есть отдельные аргументы &lt;code&gt;IpAddr&lt;/code&gt; и &lt;code&gt;PortNumber&lt;/code&gt; ,по- прежнему работают по-прежнему из соображений обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="4486c03db98a7fec674973adef6214fc73ffdd8c" translate="yes" xml:space="preserve">
          <source>Legacy configurations using tuples without &lt;code&gt;Domain&lt;/code&gt; element, as well as with all &lt;code&gt;TDomain&lt;/code&gt;, &lt;code&gt;Ip&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; elements still work.</source>
          <target state="translated">Устаревшие конфигурации с использованием кортежей без элемента &lt;code&gt;Domain&lt;/code&gt; , а также со всеми &lt;code&gt;TDomain&lt;/code&gt; , &lt;code&gt;Ip&lt;/code&gt; и &lt;code&gt;Port&lt;/code&gt; по- прежнему работают.</target>
        </trans-unit>
        <trans-unit id="71367be8ed058ebcc73246ba1f97385975bee2e8" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP agent is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">Устаревшие модули фильтрации сетевого интерфейса использовали аргументы в форме &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; вместо &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; , и если агент SNMP запускается без изменения конфигурации для использования транспортных доменов, фильтр сетевого интерфейса будет по-прежнему получать старые аргументы и работать как раньше.</target>
        </trans-unit>
        <trans-unit id="0c7683d8adcfcd8643203d0f2de9c1dd2d464605" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP manager is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">Устаревшие модули фильтрации сетевого интерфейса использовали аргументы в форме &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; вместо &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; , и если диспетчер SNMP запускается без изменения конфигурации для использования транспортных доменов, фильтр сетевого интерфейса будет по-прежнему получать старые аргументы и работать как раньше.</target>
        </trans-unit>
        <trans-unit id="e898fde08048c9f9f4cb5920c5ef464a7652e35b" translate="yes" xml:space="preserve">
          <source>Legacy notification delivery information receiver modules used a target argument on the form &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; instead of &lt;code&gt;{Domain, Addr}&lt;/code&gt;, and if the SNMP Agent is run without changing the configuration to use transport domains the notification delivery information receiver will still get the old arguments and work as before.</source>
          <target state="translated">&lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; модули приемника информации о доставке уведомлений использовали целевой аргумент в форме {IpAddr, PortNumber} вместо &lt;code&gt;{Domain, Addr}&lt;/code&gt; , и если агент SNMP запускается без изменения конфигурации для использования транспортных доменов, получатель информации о доставке уведомлений все равно получит старые аргументы и работают как раньше.</target>
        </trans-unit>
        <trans-unit id="018b204a37dd2a9505f340e2927d8d648c29228b" translate="yes" xml:space="preserve">
          <source>Legacy solutions may eventually need to be removed. In such cases, they will be phased out on a long enough time period to give users the time to adapt. Before removal of functionality it will be deprecated at least during one release with an explicit announcement about the upcoming removal. A new deprecation will at least be announced in a release note and the documentation.</source>
          <target state="translated">В конечном итоге,возможно,потребуется удалить устаревшие решения.В таких случаях они будут постепенно сворачиваться в течение достаточно длительного периода времени,чтобы дать пользователям время адаптироваться.Перед удалением функциональности они будут удалены,по крайней мере,в течение одного релиза с явным объявлением о предстоящем удалении.Новое удаление будет объявлено,по крайней мере,в примечании к релизу и документации.</target>
        </trans-unit>
        <trans-unit id="1773bd5f1b30eddc0d699c8591ba090a7523c655" translate="yes" xml:space="preserve">
          <source>Legacy string used in CGI, just ignore.</source>
          <target state="translated">Наследственная строка,используемая в CGI,просто игнорируйте.</target>
        </trans-unit>
        <trans-unit id="625b83df9b71ae174e6f9e5f483d636b4e85f3a9" translate="yes" xml:space="preserve">
          <source>Len</source>
          <target state="translated">Len</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="169c8a5cbd42e1499cc493ecd3316ae82374f224" translate="yes" xml:space="preserve">
          <source>Length of a node name</source>
          <target state="translated">Длина имени узла</target>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">Менее чем</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">Меньше или равно</target>
        </trans-unit>
        <trans-unit id="d39f560b8c87e0c4b3a30cf39bb72967048838d1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;SetOfSets&lt;/code&gt; be a set of sets and &lt;code&gt;BinRel&lt;/code&gt; a binary relation. The function that maps each element &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;SetOfSets&lt;/code&gt; onto the &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; under &lt;code&gt;BinRel&lt;/code&gt; is returned by the following function:</source>
          <target state="translated">Пусть &lt;code&gt;SetOfSets&lt;/code&gt; будет набором наборов, а &lt;code&gt;BinRel&lt;/code&gt; - бинарным отношением. Функция , которая отображает каждый элемент &lt;code&gt;Set&lt;/code&gt; из &lt;code&gt;SetOfSets&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;Set&lt;/code&gt; под &lt;code&gt;BinRel&lt;/code&gt; возвращается по следующей функции:</target>
        </trans-unit>
        <trans-unit id="aeac5d618aebeec528fc023b1fd7a175e4c5012b" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created. The counters are updated at the following occasions:</source>
          <target state="translated">Пусть у каждого процесса есть два счетчика, &lt;code&gt;prev_cnt&lt;/code&gt; и &lt;code&gt;curr_cnt&lt;/code&gt; , оба устанавливаются в &lt;code&gt;0&lt;/code&gt; при создании процесса. Счетчики обновляются в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="d42e517ccaad48e6627d644a84fd1a33bb06509e" translate="yes" xml:space="preserve">
          <source>Let the Megaco stack start the flex scanner (load the driver).</source>
          <target state="translated">Пусть стопка Megaco запустит гибкий сканер (загрузит драйвер).</target>
        </trans-unit>
        <trans-unit id="604be9425d1bfef18f4166b2d117691ea3dd6d24" translate="yes" xml:space="preserve">
          <source>Let the serial of the trace token be &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt;.</source>
          <target state="translated">Пусть серийный номер токена трассировки будет &lt;code&gt;tprev&lt;/code&gt; и &lt;code&gt;tcurr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="666a11ac8c95c51bf7258a4bd007f2a9fa01440e" translate="yes" xml:space="preserve">
          <source>Let this process start the flex scanner by calling the &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; function.</source>
          <target state="translated">Пусть этот процесс запустит сканер гибкости, вызвав &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def84ff207439fffb76419aef627ce0d25f81d91" translate="yes" xml:space="preserve">
          <source>Let us (again) print the temperatures in a list of cities:</source>
          <target state="translated">Давайте (еще раз)распечатаем температуру в списке городов:</target>
        </trans-unit>
        <trans-unit id="c56d0e103691130e00273549b1e131c9fced0666" translate="yes" xml:space="preserve">
          <source>Let us assume there are two computers called gollum and kosken. First a node is started on kosken, called ping, and then a node on gollum, called pong.</source>
          <target state="translated">Предположим,что есть два компьютера под названием &quot;Голлум&quot; и &quot;Коскен&quot;.Сначала запускается узел на kosken,называемый ping,а затем узел на gollum,называемый pong.</target>
        </trans-unit>
        <trans-unit id="d58ae25061d9ff7638fc2f52191b818f3f601803" translate="yes" xml:space="preserve">
          <source>Let us continue down the printout to find:</source>
          <target state="translated">Давайте продолжим поиск по распечатке:</target>
        </trans-unit>
        <trans-unit id="3dcdf9690d199e15a9324121e54d91e81837cbbc" translate="yes" xml:space="preserve">
          <source>Let us find the &lt;code&gt;suspend&lt;/code&gt; entry:</source>
          <target state="translated">Найдем &lt;code&gt;suspend&lt;/code&gt; запись:</target>
        </trans-unit>
        <trans-unit id="433bff1804e5bc582b9ad4a588bc980044f6d5b1" translate="yes" xml:space="preserve">
          <source>Let us first see how it is not to be done:</source>
          <target state="translated">Давайте сначала посмотрим,как это не делается:</target>
        </trans-unit>
        <trans-unit id="03868b7cc3939225f08fe8a6f0bab813a22248bc" translate="yes" xml:space="preserve">
          <source>Let us have a look at the printout after running:</source>
          <target state="translated">Давайте посмотрим на распечатку после пробежки:</target>
        </trans-unit>
        <trans-unit id="b4247fbb47d2025ec5fd1d6f1ed8b2a618036da1" translate="yes" xml:space="preserve">
          <source>Let us jump straight into the deep end with an example using some interesting features.</source>
          <target state="translated">Давайте перейдем прямо к концу на примере использования некоторых интересных возможностей.</target>
        </trans-unit>
        <trans-unit id="9d72140b7996b3301a9ebd333821b758ccc810f1" translate="yes" xml:space="preserve">
          <source>Let us now call:</source>
          <target state="translated">А теперь давайте позвоним:</target>
        </trans-unit>
        <trans-unit id="340ab2a12c84a5de30c58279a2989702bffad374" translate="yes" xml:space="preserve">
          <source>Let us now define a fun that can be used to go through a list of cities and temperatures and transform them all to Celsius.</source>
          <target state="translated">Давайте теперь определимся с весельем,которое можно использовать,чтобы пройтись по списку городов и температур и преобразовать их все в Цельсию.</target>
        </trans-unit>
        <trans-unit id="64e5a143553594b38ecae6c7e33437d3a26bcb5c" translate="yes" xml:space="preserve">
          <source>Let us now get back to the test code:</source>
          <target state="translated">Давайте вернемся к тестовому коду:</target>
        </trans-unit>
        <trans-unit id="20fe5b908a76e9dd39847042c3de63708340328e" translate="yes" xml:space="preserve">
          <source>Let us now rewrite the ping pong example using this and give the name &lt;code&gt;pong&lt;/code&gt; to the &quot;pong&quot; process:</source>
          <target state="translated">Давайте теперь перепишем пример пинг-понга, используя это, и дадим название &lt;code&gt;pong&lt;/code&gt; процессу &amp;laquo;понг&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="85102cda9dfe19553fd35b6be3f95a64812d0b22" translate="yes" xml:space="preserve">
          <source>Let us return to the messenger program and add changes to make it more robust:</source>
          <target state="translated">Давайте вернемся к программе мессенджера и добавим изменения,чтобы сделать ее более надежной:</target>
        </trans-unit>
        <trans-unit id="1c6ef58bef398273a5e57030e28034688fd26a8c" translate="yes" xml:space="preserve">
          <source>Let us revisit the example in the beginning of the previous section:</source>
          <target state="translated">Вернемся к примеру в начале предыдущего раздела:</target>
        </trans-unit>
        <trans-unit id="8f258f141fde08f96558f8c38c9f4c0b345debcf" translate="yes" xml:space="preserve">
          <source>Let us rewrite the ping pong program with &quot;ping&quot; and &quot;pong&quot; on different computers. First a few things are needed to set up to get this to work. The distributed Erlang implementation provides a very basic authentication mechanism to prevent unintentional access to an Erlang system on another computer. Erlang systems which talk to each other must have the same &lt;strong&gt;magic cookie&lt;/strong&gt;. The easiest way to achieve this is by having a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in your home directory on all machines on which you are going to run Erlang systems communicating with each other:</source>
          <target state="translated">Перепишем программу для пинг-понга с &amp;laquo;пингом&amp;raquo; и &amp;laquo;понгом&amp;raquo; на разных компьютерах. Для начала необходимо настроить несколько вещей, чтобы это работало. Распределенная реализация Erlang предоставляет очень простой механизм аутентификации для предотвращения непреднамеренного доступа к системе Erlang на другом компьютере. Системы Erlang, которые взаимодействуют друг с другом, должны иметь один и тот же &lt;strong&gt;волшебный файл cookie&lt;/strong&gt; . Самый простой способ добиться этого - разместить файл с именем &lt;code&gt;.erlang.cookie&lt;/code&gt; в вашем домашнем каталоге на всех машинах, на которых вы собираетесь запускать системы Erlang, взаимодействующие друг с другом:</target>
        </trans-unit>
        <trans-unit id="cb9d01b09a7ede47f5da9307c84cc0ef18e349a1" translate="yes" xml:space="preserve">
          <source>Let us see what happens if something other than &lt;code&gt;centimeter&lt;/code&gt; or &lt;code&gt;inch&lt;/code&gt; is entered in the &lt;code&gt;convert&lt;/code&gt; function:</source>
          <target state="translated">Давайте посмотрим, что произойдет, если в функцию &lt;code&gt;convert&lt;/code&gt; ввести что-то, кроме &lt;code&gt;centimeter&lt;/code&gt; или &lt;code&gt;inch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="825a5c292a02028fb1b75a606eb848534357aed7" translate="yes" xml:space="preserve">
          <source>Let us use the example database &lt;code&gt;Company&lt;/code&gt;, described in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; to illustrate how to run a database on two separate nodes, called &lt;code&gt;a@gin&lt;/code&gt; and &lt;code&gt;b@skeppet&lt;/code&gt;. Each of these nodes must have a &lt;code&gt;Mnesia&lt;/code&gt; directory and an initialized schema before &lt;code&gt;Mnesia&lt;/code&gt; can be started. There are two ways to specify the &lt;code&gt;Mnesia&lt;/code&gt; directory to be used:</source>
          <target state="translated">Давайте воспользуемся примером базы данных &lt;code&gt;Company&lt;/code&gt; , описанной в &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; чтобы проиллюстрировать, как запустить базу данных на двух отдельных узлах, называемых &lt;code&gt;a@gin&lt;/code&gt; и &lt;code&gt;b@skeppet&lt;/code&gt; . Каждый из этих узлов должен иметь каталог &lt;code&gt;Mnesia&lt;/code&gt; и инициализированную схему, прежде чем &lt;code&gt;Mnesia&lt;/code&gt; можно будет запустить. Есть два способа указать используемый каталог &lt;code&gt;Mnesia&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d2e8bd71594ad75aa0208dcced0f635100f9212f" translate="yes" xml:space="preserve">
          <source>Let warnings about unknown functions and types affect the exit status of the command-line version. The default is to ignore warnings about unknown functions and types when setting the exit status. When using Dialyzer from Erlang, warnings about unknown functions and types are returned; the default is not to return these warnings.</source>
          <target state="translated">Пусть предупреждения о неизвестных функциях и типах влияют на состояние выхода из командной строки.По умолчанию при установке статуса выхода игнорируются предупреждения о неизвестных функциях и типах.При использовании Dialyzer из Erlang возвращаются предупреждения о неизвестных функциях и типах,по умолчанию эти предупреждения не возвращаются.</target>
        </trans-unit>
        <trans-unit id="220abf90cd3cccafcb4011dbe84fa8ca749e8bcc" translate="yes" xml:space="preserve">
          <source>Lets all processes created by the traced process inherit the trace flags of the traced process.</source>
          <target state="translated">Позволяет всем процессам,созданным трассируемым процессом,наследовать флаги трассировки трассируемого процесса.</target>
        </trans-unit>
        <trans-unit id="d1d1fb9c4122f3954940623a46a59b2d039be292" translate="yes" xml:space="preserve">
          <source>Lets another process, &lt;code&gt;P2&lt;/code&gt;, inherit the trace flags of the traced process whenever the traced process links to &lt;code&gt;P2&lt;/code&gt;.</source>
          <target state="translated">Позволяет другому процессу, &lt;code&gt;P2&lt;/code&gt; , наследовать флаги трассировки отслеживаемого процесса всякий раз, когда отслеживаемый процесс связывается с &lt;code&gt;P2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e218df5f51ddbb889cff43b1c4f13125f2c057d" translate="yes" xml:space="preserve">
          <source>Lets get into more detail:</source>
          <target state="translated">Давайте вдадимся в подробности:</target>
        </trans-unit>
        <trans-unit id="186c274226920125ed827b7634dba82da7689d77" translate="yes" xml:space="preserve">
          <source>Lets go then! We&amp;rsquo;ll start with a short version of the setup procedure, followed by some FAQ, and then we&amp;rsquo;ll go into more details of the setup.</source>
          <target state="translated">Давайте тогда! Мы начнем с краткой версии процедуры установки, за которой последуют некоторые часто задаваемые вопросы, а затем мы перейдем к более подробной информации о настройке.</target>
        </trans-unit>
        <trans-unit id="342dcf4caa3515593e70e5d37c040a7631a835d2" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen only on the comma-separated list of IP addresses and on the loopback address (which is implicitly added to the list if it has not been specified). This can also be set using environment variable &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Позволяет этому экземпляру &lt;code&gt;epmd&lt;/code&gt; прослушивать только список IP-адресов, разделенных запятыми, и адрес обратной связи (который неявно добавляется в список, если он не был указан). Это также можно установить с помощью переменной среды &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt; ; см. раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe550a3140cf30c4543bf73300c3aa1bcbc8deb8" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen to another TCP port than default 4369. This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Позволяет этому экземпляру &lt;code&gt;epmd&lt;/code&gt; прослушивать другой порт TCP, отличный от порта по умолчанию 4369. Это также можно установить с помощью переменной среды &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; ; см. раздел &amp;laquo; &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="da5c93dba30bae6a81789ea350754c7db18d45fd" translate="yes" xml:space="preserve">
          <source>Letter number</source>
          <target state="translated">Номер письма</target>
        </trans-unit>
        <trans-unit id="6a37a6819c4ca3f372deb6f18b6c9a7263df9d68" translate="yes" xml:space="preserve">
          <source>Letters</source>
          <target state="translated">Letters</target>
        </trans-unit>
        <trans-unit id="8478fe30056611129de10e1dcb67a3cb5751c687" translate="yes" xml:space="preserve">
          <source>Letters and digits</source>
          <target state="translated">Буквы и цифры</target>
        </trans-unit>
        <trans-unit id="5baaea6842aeb9d7041a377fa41f4a3c4ca67e64" translate="yes" xml:space="preserve">
          <source>Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option &lt;code&gt;/i&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?i)&lt;/code&gt; option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</source>
          <target state="translated">Буквы в шаблоне соответствуют как прописным, так и строчным буквам. Он эквивалентен параметру &lt;code&gt;/i&lt;/code&gt; в Perl и может быть изменен в шаблоне с помощью параметра &lt;code&gt;(?i)&lt;/code&gt; . Прописные и строчные буквы определяются как в наборе символов ISO 8859-1.</target>
        </trans-unit>
        <trans-unit id="9f098a06328a86780258bc88ff74fbf46806b289" translate="yes" xml:space="preserve">
          <source>Level 1: Function headers, reserved words, comments, strings, quoted atoms, and character constants will be colored.</source>
          <target state="translated">Уровень 1:будут окрашены заголовки функций,зарезервированные слова,комментарии,строки,кавычки атомов и символьные константы.</target>
        </trans-unit>
        <trans-unit id="f28c43e4d336432c51e7d6f7ae8f272e7480311b" translate="yes" xml:space="preserve">
          <source>Level 2: The above, attributes, Erlang bif:s, guards, and words in comments enclosed in single quotes will be colored.</source>
          <target state="translated">Уровень 2:Выше,атрибуты,Erlang bif:s,охрана и слова в комментариях,заключенные в одинарные кавычки будут окрашены.</target>
        </trans-unit>
        <trans-unit id="765716d33c6ea85319738caae1b33005b2662242" translate="yes" xml:space="preserve">
          <source>Level 3: The above, variables, records, and macros will be colored. (This level is also known as the Christmas tree level.)</source>
          <target state="translated">Уровень 3:Вышеперечисленные переменные,записи и макросы будут окрашены.(Этот уровень также известен как елочный уровень).</target>
        </trans-unit>
        <trans-unit id="2bf81bf1cb8b7d9b8d3236953ea28aa39a5a5e01" translate="yes" xml:space="preserve">
          <source>Lexical analyzer generator for Erlang</source>
          <target state="translated">Генератор лексического анализатора для Эрланга</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="b82b017d183339186ab0d2b0c5a5bfec8823103f" translate="yes" xml:space="preserve">
          <source>Library directories can be added, edited or deleted. This is done by selecting the line where the path to a library directory is displayed and clicking the right mouse button. Choose add, edit or delete in the menu that pops up. New library directories can also be added by selecting the line &lt;code&gt;Library directories&lt;/code&gt; and clicking the right mouse button. Choose add in the menu that pops up.</source>
          <target state="translated">Каталоги библиотеки можно добавлять, редактировать или удалять. Это делается путем выбора строки, в которой отображается путь к каталогу библиотеки, и щелчка правой кнопкой мыши. Во всплывающем меню выберите добавить, изменить или удалить. Новые каталоги библиотек также можно добавить, выбрав строку &lt;code&gt;Library directories&lt;/code&gt; и щелкнув правой кнопкой мыши. Выберите добавить во всплывающем меню.</target>
        </trans-unit>
        <trans-unit id="2978f0a9a49c8c42789bf952364d24d1a5dbe46b" translate="yes" xml:space="preserve">
          <source>Library for handling binary data</source>
          <target state="translated">Библиотека для работы с бинарными данными</target>
        </trans-unit>
        <trans-unit id="52399314911c08c3e5bf65cd9f9343b51490ef6c" translate="yes" xml:space="preserve">
          <source>Library for handling binary data.</source>
          <target state="translated">Библиотека для работы с бинарными данными.</target>
        </trans-unit>
        <trans-unit id="89d3a3ca0e1508a43064d7c5bc51385a80966d5e" translate="yes" xml:space="preserve">
          <source>Library module - skeleton for a module that does not implement a process.</source>
          <target state="translated">Модуль библиотеки-скелет для модуля,который не реализует процесс.</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Лицензия Apache,версия 2.0.</target>
        </trans-unit>
        <trans-unit id="63a3f94f87240d18e2608ac8e3fea63c89e207c2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;#&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">Как &lt;code&gt;#&lt;/code&gt; , но печатает строчные буквы.</target>
        </trans-unit>
        <trans-unit id="cc569b0959c426468676c9f9e2878439fb241769" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;, but the list is traversed from right to left.</source>
          <target state="translated">Аналогично &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; , но список перемещается справа налево.</target>
        </trans-unit>
        <trans-unit id="51f15f4f7ca9cb7875094377777336299eb89bba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; , но распаковывает не больше данных, чем поместится в буфере, настроенном с помощью &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt; . Это полезно при распаковке потока с высокой степенью сжатия, так что небольшой объем сжатых входных данных может расширяться до 1000 раз.</target>
        </trans-unit>
        <trans-unit id="72ba4cf8d1bc4075b239ef3e59d00ec710769e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but returns once it has expanded beyond a small implementation-defined threshold. It's useful when decompressing untrusted input which could have been maliciously crafted to expand until the system runs out of memory.</source>
          <target state="translated">Аналогичен &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; , но возвращается, когда выходит за пределы небольшого порогового значения, определенного реализацией. Это полезно при распаковке ненадежных входных данных, которые могли быть злонамеренно созданы для расширения до тех пор, пока в системе не закончится память.</target>
        </trans-unit>
        <trans-unit id="daf13adcbfffff9ed7affc2828dc952bc760e47b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt;, but only inserts top-level comments. Comments within function definitions or declarations (&quot;forms&quot;) are simply ignored.</source>
          <target state="translated">То же, что и &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt; , но вставляет только комментарии верхнего уровня. Комментарии в определениях или объявлениях функций (&amp;laquo;формы&amp;raquo;) просто игнорируются.</target>
        </trans-unit>
        <trans-unit id="ef3750efd41bd9e594039bac37ecfb9248994272" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;@custom_types&lt;/code&gt; but requires the specified module to export &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; rather than &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;@custom_types&lt;/code&gt; но требует указанный модуль для экспорта &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; , а не &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea99210fbf7c6bed65f860ca599cb796325b2c8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">Как &lt;code&gt;B&lt;/code&gt; , но печатает строчные буквы.</target>
        </trans-unit>
        <trans-unit id="86bbc734cf44d78a7649fa34a75e3f3c896f4e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints the number with an Erlang style &lt;code&gt;#&lt;/code&gt;-separated base prefix. Example:</source>
          <target state="translated">Подобно &lt;code&gt;B&lt;/code&gt; , но выводит число с помощью базового префикса, разделенного &lt;code&gt;#&lt;/code&gt; в стиле Эрланга . Пример:</target>
        </trans-unit>
        <trans-unit id="f477e728585a752129db4fe6acfe44591222b305" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any.</source>
          <target state="translated">Как &lt;code&gt;B&lt;/code&gt; , но принимает дополнительный аргумент - префикс для вставки перед числом, но после начального тире, если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="acd1912727bbe585b5be18af1470d511bb1bbc67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;X&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">Как &lt;code&gt;X&lt;/code&gt; , но печатает строчные буквы.</target>
        </trans-unit>
        <trans-unit id="966ec3b06ee878fd6f57e5784bed91178bcad7fe" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;any&lt;/code&gt;, but stops at the first filter for which there are matches, which can be much more efficient when there are many peers. For example, the following filter causes only peers best matching both the host and realm filters to be presented.</source>
          <target state="translated">Как и &lt;code&gt;any&lt;/code&gt; , но останавливается на первом фильтре, для которого есть совпадения, что может быть гораздо более эффективным, когда есть много одноранговых узлов. Например, следующий фильтр приводит к отображению только одноранговых узлов, наилучшим образом соответствующих фильтрам хоста и области.</target>
        </trans-unit>
        <trans-unit id="d6e3635c0afce60dac176c677944b2628acbcc53" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;debugVal(Expr)&lt;/code&gt;, but prints terms truncated to the given depth.</source>
          <target state="translated">Подобно &lt;code&gt;debugVal(Expr)&lt;/code&gt; , но выводит термины, усеченные до заданной глубины.</target>
        </trans-unit>
        <trans-unit id="63ad390555fcf8137ccbbb94972b3652ab59df2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:foldl/3&lt;/code&gt;, but over a list of lists.</source>
          <target state="translated">Как &lt;code&gt;lists:foldl/3&lt;/code&gt; , но над списком списков.</target>
        </trans-unit>
        <trans-unit id="00d879ac0be1e80dff2fcb522c1f308589442773" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:mapfoldl/3&lt;/code&gt;, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</source>
          <target state="translated">Как &lt;code&gt;lists:mapfoldl/3&lt;/code&gt; , но над списком списков. Список списков в результате имеет ту же структуру, что и данный список списков.</target>
        </trans-unit>
        <trans-unit id="ab237642580896dc26c686d01f6e5d1e47eb40a7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/1&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">Подобно &lt;code&gt;new_variable_name/1&lt;/code&gt; , но генерирует список из &lt;code&gt;N&lt;/code&gt; новых имен.</target>
        </trans-unit>
        <trans-unit id="faf0ff6789ba28d95ff3dae1292daf1cffb72f1a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/2&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">Подобно &lt;code&gt;new_variable_name/2&lt;/code&gt; , но генерирует список из &lt;code&gt;N&lt;/code&gt; новых имен.</target>
        </trans-unit>
        <trans-unit id="2dd37c4c8489c1b03eaf8a9be802ae7519cf2c9e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;notempty&lt;/code&gt;, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \K.</source>
          <target state="translated">Подобно &lt;code&gt;notempty&lt;/code&gt; , за исключением того, что разрешено совпадение пустой строки, которое не находится в начале темы. Если шаблон привязан, такое совпадение может произойти, только если шаблон содержит \ K.</target>
        </trans-unit>
        <trans-unit id="ea19d16016f4ba065add2108a05c41562006761a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{inparallel, Tests}&lt;/code&gt;, but running no more than &lt;code&gt;N&lt;/code&gt; subtests simultaneously.</source>
          <target state="translated">Аналогично &lt;code&gt;{inparallel, Tests}&lt;/code&gt; , но одновременно выполняется не более &lt;code&gt;N&lt;/code&gt; подтестов.</target>
        </trans-unit>
        <trans-unit id="86d23c0727a7f28841a9680a28cb323bba5bd6b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{spawn, Tests}&lt;/code&gt;, but runs the specified tests on the given Erlang node.</source>
          <target state="translated">Подобно &lt;code&gt;{spawn, Tests}&lt;/code&gt; , но запускает указанные тесты на данном узле Erlang.</target>
        </trans-unit>
        <trans-unit id="28c07f5f1815e2f3156834cae0b135871e7deefe" translate="yes" xml:space="preserve">
          <source>Like a port program, the port communicates with an Erlang process. All communication goes through one Erlang process that is the &lt;strong&gt;connected process&lt;/strong&gt; of the port driver. Terminating this process closes the port driver.</source>
          <target state="translated">Как и программа порта, порт взаимодействует с процессом Erlang. Все коммуникации проходят через один процесс Erlang, который является &lt;strong&gt;подключенным процессом&lt;/strong&gt; драйвера порта. Завершение этого процесса закрывает драйвер порта.</target>
        </trans-unit>
        <trans-unit id="fb6947e8ac5f224ed9054599317fddd5d554df94" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviors, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behavior is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="translated">Как и большинство &lt;code&gt;gen_&lt;/code&gt; поведения gen_ , &lt;code&gt;gen_statem&lt;/code&gt; хранит &lt;code&gt;Data&lt;/code&gt; сервера помимо состояния. Из-за этого и поскольку нет ограничений на количество состояний (при условии, что имеется достаточно памяти виртуальной машины) или на количество отдельных входных событий, конечный автомат, реализованный с таким поведением, фактически является завершенным по Тьюрингу. Но в основном это похоже на машину Мили, управляемую событиями.</target>
        </trans-unit>
        <trans-unit id="2d2a1cf01f82cc870ddfbc6074784aafada5af53" translate="yes" xml:space="preserve">
          <source>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</source>
          <target state="translated">Как subst/2,но не конвертирует результат из шаблона обратно в дерево.Полезно,если вы хотите сделать несколько отдельных замен.</target>
        </trans-unit>
        <trans-unit id="9fb2ece1519e605cddcd4c31f14bfc8330a5db16" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; macro, but generates an exception unless the returned status value is &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; макро, но генерирует исключение , если возвращаемое значение статуса не является &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b09308bcf178ae8be921fdbc2b93c7b533bf2b3a" translate="yes" xml:space="preserve">
          <source>Like the above, if you must remain USTAR compatible, you must also ensure than paths for symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.</source>
          <target state="translated">Как и выше,если вы должны оставаться USTAR-совместимыми,вы также должны убедиться,что пути для символических/жестких ссылок не превышают 100 байт,в противном случае будут использоваться PAX-заголовки.</target>
        </trans-unit>
        <trans-unit id="b7ca39f6a507f719e0c2ad1d78b58767ce4db68c" translate="yes" xml:space="preserve">
          <source>Likewise, a registry can be restored from a &lt;code&gt;Mnesia&lt;/code&gt; table:</source>
          <target state="translated">Точно так же реестр можно восстановить из таблицы &lt;code&gt;Mnesia&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="78dc3a4fccf65f244492a69b7620630ce0e9464d" translate="yes" xml:space="preserve">
          <source>Limitations: Command string &lt;code&gt;Cmd&lt;/code&gt; is sent to the &lt;code&gt;heart&lt;/code&gt; program as an ISO Latin-1 or UTF-8 encoded binary, depending on the filename encoding mode of the emulator (see &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;). The size of the encoded binary must be less than 2047 bytes.</source>
          <target state="translated">Ограничения: Командная строка &lt;code&gt;Cmd&lt;/code&gt; отправляется программе &lt;code&gt;heart&lt;/code&gt; как двоичный код в кодировке ISO Latin-1 или UTF-8, в зависимости от режима кодирования имени файла эмулятора (см. &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; ). Размер закодированного двоичного файла не должен превышать 2047 байт.</target>
        </trans-unit>
        <trans-unit id="a5b6119a0e42de01e03b6e7576246105dd031f3e" translate="yes" xml:space="preserve">
          <source>Limits &lt;code&gt;run/3&lt;/code&gt; to matching at the first matching position. If a pattern was compiled with &lt;code&gt;anchored&lt;/code&gt;, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no &lt;code&gt;unanchored&lt;/code&gt; option.</source>
          <target state="translated">Ограничивает &lt;code&gt;run/3&lt;/code&gt; соответствием первой совпадающей позиции. Если шаблон был скомпилирован с &lt;code&gt;anchored&lt;/code&gt; или оказалось, что он закреплен в силу своего содержимого, его нельзя сделать незакрепленным во время сопоставления, следовательно, нет опции без &lt;code&gt;unanchored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53fd0a56aa60d6229d9774fb5d18054514021f8a" translate="yes" xml:space="preserve">
          <source>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in &lt;code&gt;Tree&lt;/code&gt; at the given &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Depth&lt;/code&gt; is negative, the result is always &lt;code&gt;Node&lt;/code&gt;, even if &lt;code&gt;Tree&lt;/code&gt; has no subtrees.</source>
          <target state="translated">Ограничивает синтаксическое дерево определенной глубиной. Заменяет все поддерева без листьев в &lt;code&gt;Tree&lt;/code&gt; в данных &lt;code&gt;Depth&lt;/code&gt; по &lt;code&gt;Node&lt;/code&gt; . Если &lt;code&gt;Depth&lt;/code&gt; отрицательна, результатом всегда будет &lt;code&gt;Node&lt;/code&gt; , даже если у &lt;code&gt;Tree&lt;/code&gt; нет поддеревьев.</target>
        </trans-unit>
        <trans-unit id="0f3cee9699c8974707e0009cafd9488a7e87e54c" translate="yes" xml:space="preserve">
          <source>Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to &lt;code&gt;match_limit&lt;/code&gt;. It is described as follows by the PCRE documentation:</source>
          <target state="translated">Ограничивает время выполнения и потребление памяти для соответствия в &lt;code&gt;match_limit&lt;/code&gt; от реализации, очень похоже на match_limit . Это описано в документации PCRE:</target>
        </trans-unit>
        <trans-unit id="57e9ccbfc052c9f575272edd40f6b4a2a0bc74b7" translate="yes" xml:space="preserve">
          <source>Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</source>
          <target state="translated">Ограничивает время выполнения матча в зависимости от реализации.Это описывается следующим образом в документации PCRE:</target>
        </trans-unit>
        <trans-unit id="ebcb72346cc3142860ab9dce9c83e330a9b27032" translate="yes" xml:space="preserve">
          <source>Limits the number of reader groups used by read/write locks optimized for read operations in the Erlang runtime system. By default the reader groups limit is 64.</source>
          <target state="translated">Ограничивает количество групп читателей,используемых блокировками чтения/записи,оптимизированными для операций чтения в системе Erlang runtime.По умолчанию лимит на количество групп читателей составляет 64.</target>
        </trans-unit>
        <trans-unit id="1aaddcb6d1d303241ab23ee03c9e955d5813903a" translate="yes" xml:space="preserve">
          <source>Limits the number of simultaneous requests that can be supported. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">Ограничивает количество одновременных запросов, которые могут поддерживаться. По умолчанию &lt;code&gt;150&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac5a291f0f9cb7077ef57a417ad04c2cde809e26" translate="yes" xml:space="preserve">
          <source>Limits the size of the HTTP request URI. Default is no limit.</source>
          <target state="translated">Ограничивает размер URI HTTP запроса.По умолчанию не ограничено.</target>
        </trans-unit>
        <trans-unit id="01a54436655ccd4292a34867e24b94c649a6a7ef" translate="yes" xml:space="preserve">
          <source>Limits the size of the message body of an HTTP request. Default is no limit.</source>
          <target state="translated">Ограничивает размер тела сообщения HTTP-запроса.По умолчанию не ограничено.</target>
        </trans-unit>
        <trans-unit id="f796a3375835935727b47e015cbce66aad2dfb2d" translate="yes" xml:space="preserve">
          <source>Limits the size of the message header of an HTTP request. Default is &lt;code&gt;10240&lt;/code&gt;.</source>
          <target state="translated">Ограничивает размер заголовка сообщения HTTP-запроса. По умолчанию &lt;code&gt;10240&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e89b80d9719e747b2760364410364b02949de43" translate="yes" xml:space="preserve">
          <source>Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; where &lt;code&gt;MaxClient&lt;/code&gt; and &lt;code&gt;MinClient&lt;/code&gt; are the values proposed by a connecting client.</source>
          <target state="translated">Ограничивает то, что клиент может попросить в diffie-hellman-group-exchange. Пределы будут такими: &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; где &lt;code&gt;MaxClient&lt;/code&gt; и &lt;code&gt;MinClient&lt;/code&gt; - значения, предложенные подключающимся клиентом.</target>
        </trans-unit>
        <trans-unit id="d606cdf694a134035f6374a74898f3c5d7314e3c" translate="yes" xml:space="preserve">
          <source>Line 1 (marked with the &lt;code&gt;%% 1&lt;/code&gt; comment), assigns a &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;Bin0&lt;/code&gt; variable.</source>
          <target state="translated">Линия 1 (помеченный &lt;code&gt;%% 1&lt;/code&gt; комментарий), назначает &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; к &lt;code&gt;Bin0&lt;/code&gt; переменным.</target>
        </trans-unit>
        <trans-unit id="3a12079f3d22a373811b1791c48232229546d37f" translate="yes" xml:space="preserve">
          <source>Line 2 is an append operation. As &lt;code&gt;Bin0&lt;/code&gt; has not been involved in an append operation, a new &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; is created and the contents of &lt;code&gt;Bin0&lt;/code&gt; is copied into it. The &lt;strong&gt;ProcBin&lt;/strong&gt; part of the refc binary has its size set to the size of the data stored in the binary, while the binary object has extra space allocated. The size of the binary object is either twice the size of &lt;code&gt;Bin1&lt;/code&gt; or 256, whichever is larger. In this case it is 256.</source>
          <target state="translated">Строка 2 - это операция добавления. Поскольку &lt;code&gt;Bin0&lt;/code&gt; не участвует в операции добавления, создается новый &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; и содержимое &lt;code&gt;Bin0&lt;/code&gt; копируется в него. &lt;strong&gt;ProcBin&lt;/strong&gt; часть refc двоичном имеет свой набор размера к размеру данных , хранящихся в двоичном виде , в то время как двоичный объект выделено дополнительное пространство. Размер двоичного объекта либо вдвое больше, чем размер &lt;code&gt;Bin1&lt;/code&gt; , либо 256, в зависимости от того, что больше. В данном случае это 256.</target>
        </trans-unit>
        <trans-unit id="78a9183f7481a61745aa9568c7ccc4c6a4279b91" translate="yes" xml:space="preserve">
          <source>Line 3 is more interesting. &lt;code&gt;Bin1&lt;/code&gt;&lt;strong&gt;has&lt;/strong&gt; been used in an append operation, and it has 252 bytes of unused storage at the end, so the 3 new bytes are stored there.</source>
          <target state="translated">Строка 3 более интересна. &lt;code&gt;Bin1&lt;/code&gt; &lt;strong&gt;была&lt;/strong&gt; использована в операции дописывания, и он имеет 252 байт неиспользованной памяти в конце, так что 3 новых байты хранятся там.</target>
        </trans-unit>
        <trans-unit id="606f836f0aef9364290324174a1660f8412d88a6" translate="yes" xml:space="preserve">
          <source>Line 4. The same applies here. There are 249 bytes left, so there is no problem storing another 3 bytes.</source>
          <target state="translated">Четвёртая линия.То же самое касается и здесь.Осталось 249 байт,так что нет проблем с хранением еще 3 байт.</target>
        </trans-unit>
        <trans-unit id="a181978e790a24533adac43665a7c3bfc9494742" translate="yes" xml:space="preserve">
          <source>Line 5. Here, something &lt;strong&gt;interesting&lt;/strong&gt; happens. Notice that the result is not appended to the previous result in &lt;code&gt;Bin3&lt;/code&gt;, but to &lt;code&gt;Bin1&lt;/code&gt;. It is expected that &lt;code&gt;Bin4&lt;/code&gt; will be assigned the value &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt;. It is also expected that &lt;code&gt;Bin3&lt;/code&gt; will retain its value (&lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;). Clearly, the runtime system cannot write byte &lt;code&gt;17&lt;/code&gt; into the binary, because that would change the value of &lt;code&gt;Bin3&lt;/code&gt; to &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Строка 5. Здесь происходит кое-что &lt;strong&gt;интересное&lt;/strong&gt; . Обратите внимание, что результат добавляется не к предыдущему результату в &lt;code&gt;Bin3&lt;/code&gt; , а в &lt;code&gt;Bin1&lt;/code&gt; . Ожидается, что &lt;code&gt;Bin4&lt;/code&gt; будет присвоено значение &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt; . Также ожидается, что &lt;code&gt;Bin3&lt;/code&gt; сохранит свое значение ( &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; ). Ясно, что система времени выполнения не может записать байт &lt;code&gt;17&lt;/code&gt; в двоичный файл, потому что это изменит значение &lt;code&gt;Bin3&lt;/code&gt; на &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f23e2d073d67acea8f123b42f84af035e27248d" translate="yes" xml:space="preserve">
          <source>Line feed</source>
          <target state="translated">Подача на линию</target>
        </trans-unit>
        <trans-unit id="d6baf0500add79d50ac3b7f3a8db7d105c624d52" translate="yes" xml:space="preserve">
          <source>Line feed (LF)</source>
          <target state="translated">Линейная подача (LF)</target>
        </trans-unit>
        <trans-unit id="6e6281f3f812eba8375c5e757b0a8cfcb28090b9" translate="yes" xml:space="preserve">
          <source>Line feed (hex 0A)</source>
          <target state="translated">Линейная подача (гекс 0А)</target>
        </trans-unit>
        <trans-unit id="815507f47a2606910a0fd0cc8b7e5b87462f8246" translate="yes" xml:space="preserve">
          <source>Line separator</source>
          <target state="translated">Линейный сепаратор</target>
        </trans-unit>
        <trans-unit id="2af7c8c92e94fc7eb6a6c63fb1ff0bce5d9c019f" translate="yes" xml:space="preserve">
          <source>LineOp ::= &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</source>
          <target state="translated">LineOp :: = &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96dcf318665fa36d70418026a3b6579ba1d37485" translate="yes" xml:space="preserve">
          <source>Linear_A</source>
          <target state="translated">Linear_A</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="d6c98026fbce4e93112774eec40362b0a7aed1ad" translate="yes" xml:space="preserve">
          <source>Lines containing comment are indented differently depending on the number of %-characters used:</source>
          <target state="translated">Строки,содержащие комментарий,имеют различные отступы в зависимости от количества используемых %-символов:</target>
        </trans-unit>
        <trans-unit id="6020dbe4b85aaddb67863706a7bfa44b4279c255" translate="yes" xml:space="preserve">
          <source>Lines with one %-character is indented to the right of the code. The column is specified by the variable &lt;code&gt;comment-column&lt;/code&gt;, by default column 48 is used.</source>
          <target state="translated">Строки с одним символом% смещаются справа от кода. Столбец определяется переменной &lt;code&gt;comment-column&lt;/code&gt; , по умолчанию используется 48 столбец.</target>
        </trans-unit>
        <trans-unit id="09bc4e361a8d125ebf0a75e49099df74d6c93932" translate="yes" xml:space="preserve">
          <source>Lines with three of more %-characters are indented to the left margin.</source>
          <target state="translated">Строки,содержащие еще три %-символа,снабжены отступом слева.</target>
        </trans-unit>
        <trans-unit id="23c934b9a137cdcf80996b7f149382ca3a18710d" translate="yes" xml:space="preserve">
          <source>Lines with two %-characters will be indented to the same depth as code would have been in the same situation.</source>
          <target state="translated">Строки с двумя %-символами будут смещены на ту же глубину,что и код,который был бы в той же ситуации.</target>
        </trans-unit>
        <trans-unit id="9e5bc846e2abf74c493c5775ca18f25f00253f12" translate="yes" xml:space="preserve">
          <source>Linked-in drivers involves writing certain call-back functions in C. This requires very good skills as the code is linked to the Erlang runtime system.</source>
          <target state="translated">Связанные драйверы подразумевают написание определенных функций обратного вызова на C.Это требует очень хороших навыков,так как код связан с системой исполнения Erlang.</target>
        </trans-unit>
        <trans-unit id="4767dee426c55691e7ec704688dd7011fdf6e6c1" translate="yes" xml:space="preserve">
          <source>Linking the code:</source>
          <target state="translated">Связываю код:</target>
        </trans-unit>
        <trans-unit id="c84c983e1eb5366ff7155483ba08d2cf18181d6f" translate="yes" xml:space="preserve">
          <source>Links are bidirectional and there can only be one link between two processes. Repeated calls to &lt;code&gt;link(Pid)&lt;/code&gt; have no effect.</source>
          <target state="translated">Ссылки являются двунаправленными, и между двумя процессами может быть только одна ссылка. Повторные вызовы &lt;code&gt;link(Pid)&lt;/code&gt; не действуют.</target>
        </trans-unit>
        <trans-unit id="536671c5d8157a4198a59e5ae3d1dd5548fd13ad" translate="yes" xml:space="preserve">
          <source>Links are used to monitor the behaviour of other processes, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ссылки используются для отслеживания поведения других процессов, см. &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7503c78763ebecf671434c7b303123b1f56805aa" translate="yes" xml:space="preserve">
          <source>Linux (Aurora) is supported.</source>
          <target state="translated">Поддерживается Linux (Aurora).</target>
        </trans-unit>
        <trans-unit id="f49aab8507d2b62fb91db21f8494a181f98c1d79" translate="yes" xml:space="preserve">
          <source>Linux (Yellow Dog) and OS X 10.4 are supported.</source>
          <target state="translated">Поддерживаются Linux (Yellow Dog)и OS X 10.4.</target>
        </trans-unit>
        <trans-unit id="38b6fdccab18afaaac184982069e00fd7f3ffef8" translate="yes" xml:space="preserve">
          <source>Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed)</source>
          <target state="translated">Linux Fedora Core 5.0 (необходимо ядро 2.6.15-2054 или более поздняя версия)</target>
        </trans-unit>
        <trans-unit id="7271c5381dda56086abe9358b1d2d1ac80324586" translate="yes" xml:space="preserve">
          <source>Linux Kernel with UTRACE support</source>
          <target state="translated">Ядро Linux с поддержкой UTRACE</target>
        </trans-unit>
        <trans-unit id="36cc9cbbe6cb1dce3453740ebc4bf86e8ca4eccd" translate="yes" xml:space="preserve">
          <source>Linux is supported.</source>
          <target state="translated">Поддерживается Linux.</target>
        </trans-unit>
        <trans-unit id="0b07d1c551ea1b1430dbe7348f1abb043df15a81" translate="yes" xml:space="preserve">
          <source>Linux via SystemTap compatibility. Please see &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">Linux через совместимость с SystemTap. Пожалуйста, смотрите &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="bc9111a94c72d771e7a92b8e98a4dad72cd10a62" translate="yes" xml:space="preserve">
          <source>Linux: Fedora Core is supported. Both 32-bit and 64-bit modes are supported.</source>
          <target state="translated">Linux:Поддерживается Fedora Core.Поддерживаются как 32-битные,так и 64-битные режимы.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
