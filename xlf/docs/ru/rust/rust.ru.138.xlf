<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="translated">Мы намекнули, что этот пример не компилируется. А теперь выясним почему!</target>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="translated">Мы реализовали &lt;code&gt;Iterator&lt;/code&gt; , определив &lt;code&gt;next&lt;/code&gt; метод, поэтому теперь мы можем использовать любую реализацию &lt;code&gt;Iterator&lt;/code&gt; трейта Iterator по умолчанию, как определено в стандартной библиотеке, потому что все они используют функциональность &lt;code&gt;next&lt;/code&gt; метода.</target>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="translated">Мы только что создали проект с помощью &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt; &lt;code&gt;cargo build&lt;/code&gt; и запустили его с помощью ./target/debug/hello_cargo , но мы также можем использовать Cargo &lt;code&gt;cargo run&lt;/code&gt; для компиляции кода, а затем запустить полученный исполняемый файл одной командой:</target>
        </trans-unit>
        <trans-unit id="a56bd0b36b29e10cce98f9d35be1f611e5d93adf" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;add&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">Мы сохраняем утверждение, что &lt;code&gt;mid&lt;/code&gt; индекс находится внутри среза. Затем мы &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; к небезопасному коду: функция slice :: from_raw_parts_mut принимает необработанный указатель и длину и создает срез. Мы используем эту функцию для создания фрагмента, который начинается с &lt;code&gt;ptr&lt;/code&gt; и имеет длину в &lt;code&gt;mid&lt;/code&gt; . Затем мы вызываем метод &lt;code&gt;offset&lt;/code&gt; для &lt;code&gt;ptr&lt;/code&gt; с &lt;code&gt;mid&lt;/code&gt; в качестве аргумента, чтобы получить необработанный указатель, который начинается с &lt;code&gt;mid&lt;/code&gt; , и мы создаем срез, используя этот указатель и оставшееся количество элементов после &lt;code&gt;mid&lt;/code&gt; в качестве длины.</target>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="translated">Мы знаем, что хотим определить метод, поэтому он будет внутри блока &lt;code&gt;impl Rectangle&lt;/code&gt; . Имя метода будет &lt;code&gt;can_hold&lt;/code&gt; , и он будет принимать неизменяемое заимствование другого &lt;code&gt;Rectangle&lt;/code&gt; в качестве параметра. Мы можем сказать, какой будет тип параметра, посмотрев на код, который вызывает метод: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; передает &lt;code&gt;&amp;amp;rect2&lt;/code&gt; , который является неизменным заимствованием для &lt;code&gt;rect2&lt;/code&gt; , экземпляра &lt;code&gt;Rectangle&lt;/code&gt; . Это имеет смысл, потому что нам нужно только читать &lt;code&gt;rect2&lt;/code&gt; (а не писать, что означало бы, что нам понадобится изменяемое заимствование), и мы хотим, чтобы &lt;code&gt;main&lt;/code&gt; сохранил право собственности на &lt;code&gt;rect2&lt;/code&gt; поэтому мы можем использовать его снова после вызова метода &lt;code&gt;can_hold&lt;/code&gt; . Возвращаемое значение &lt;code&gt;can_hold&lt;/code&gt; будет логическим, и реализация проверит, больше ли ширина и высота &lt;code&gt;self&lt;/code&gt; , чем ширина и высота другого &lt;code&gt;Rectangle&lt;/code&gt; , соответственно. Давайте добавим новый &lt;code&gt;can_hold&lt;/code&gt; метод к &lt;code&gt;impl&lt;/code&gt; блока из листинга 5-13, как показано в листинге 5-15.</target>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="translated">Мы оставляем поля &lt;code&gt;list&lt;/code&gt; и &lt;code&gt;average&lt;/code&gt; закрытыми, поэтому внешний код не может напрямую добавлять или удалять элементы в поле &lt;code&gt;list&lt;/code&gt; ; в противном случае &lt;code&gt;average&lt;/code&gt; поле может перестать синхронизироваться при изменении &lt;code&gt;list&lt;/code&gt; . Метод &lt;code&gt;average&lt;/code&gt; возвращает значение в поле &lt;code&gt;average&lt;/code&gt; , позволяя внешнему коду считывать &lt;code&gt;average&lt;/code&gt; но не изменять его.</target>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="translated">Мы оставили комментарий в цикле &lt;code&gt;for&lt;/code&gt; в листинге 20-14, касающийся создания потоков. Здесь мы посмотрим, как мы на самом деле создаем потоки. Стандартная библиотека предоставляет &lt;code&gt;thread::spawn&lt;/code&gt; как способ создания потоков, а &lt;code&gt;thread::spawn&lt;/code&gt; ожидает получить некоторый код, который поток должен запустить, как только поток будет создан. Однако в нашем случае мы хотим создать потоки и заставить их &lt;em&gt;ждать&lt;/em&gt; кода, который мы отправим позже. Реализация потоков в стандартной библиотеке не позволяет этого сделать; мы должны реализовать это вручную.</target>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="translated">Перечислит &lt;code&gt;x&lt;/code&gt; значение , а затем просто включить &lt;code&gt;..&lt;/code&gt; рисунок. Это быстрее, чем перечислять &lt;code&gt;y: _&lt;/code&gt; и &lt;code&gt;z: _&lt;/code&gt; , особенно когда мы работаем со структурами, которые имеют много полей в ситуациях, когда релевантны только одно или два поля.</target>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="translated">Мы делаем два потока и меняем имена переменных, используемых во втором потоке, на &lt;code&gt;handle2&lt;/code&gt; и &lt;code&gt;num2&lt;/code&gt; . Когда мы запускаем код на этот раз, компиляция дает нам следующее:</target>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="translated">Мы можем захотеть записать байты в &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; в нашем производственном коде, но использовать буфер в памяти в наших тестах. Мы можем сделать это с помощью &lt;code&gt;Cursor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Мы модифицируем &lt;code&gt;a&lt;/code&gt; так, чтобы он указывал на &lt;code&gt;b&lt;/code&gt; вместо &lt;code&gt;Nil&lt;/code&gt; , создавая цикл. Мы делаем это, используя метод &lt;code&gt;tail&lt;/code&gt; , чтобы получить ссылку на &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; , который мы помещаем в &lt;code&gt;link&lt;/code&gt; на переменную . Затем мы используем метод &lt;code&gt;borrow_mut&lt;/code&gt; в &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; чтобы изменить значение внутри с &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; который содержит значение &lt;code&gt;Nil&lt;/code&gt; , на &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="translated">Мы должны вызывать &lt;code&gt;dangerous&lt;/code&gt; функцию в отдельном &lt;code&gt;unsafe&lt;/code&gt; блоке. Если мы попытаемся вызвать &lt;code&gt;dangerous&lt;/code&gt; без блока &lt;code&gt;unsafe&lt;/code&gt; , мы получим ошибку:</target>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="translated">Нам нужен фиктивный объект, который вместо отправки электронного письма или текстового сообщения при вызове &lt;code&gt;send&lt;/code&gt; будет отслеживать только сообщения, которые ему велено отправить. Мы можем создать новый экземпляр фиктивного объекта, создать &lt;code&gt;LimitTracker&lt;/code&gt; , который использует фиктивный объект, вызовите &lt;code&gt;set_value&lt;/code&gt; метод на &lt;code&gt;LimitTracker&lt;/code&gt; , а затем проверить , что фиктивный объект имеет сообщение , как мы ожидаем. В листинге 15-21 показана попытка реализовать фиктивный объект для этого, но программа проверки заимствований не позволяет этого:</target>
        </trans-unit>
        <trans-unit id="a110963ca04d0182f8c4f733a600767ec4a8c414" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the allocator when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Нам нужен способ вернуть эту память в операционную систему, когда мы закончим с нашей &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="translated">Нам нужно добавить оператор &lt;code&gt;use&lt;/code&gt; чтобы включить &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; в область видимости, потому что его нет в прелюдии. В &lt;code&gt;main&lt;/code&gt; мы создаем список, содержащий 5 и 10, и сохраняем его в новом &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; . Затем, когда мы создаем &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , мы вызываем функцию &lt;code&gt;Rc::clone&lt;/code&gt; и передаем ссылку на &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="translated">Нам нужно добавить в код в листинге 9-3, чтобы выполнять различные действия в зависимости от возвращаемого значения &lt;code&gt;File::open&lt;/code&gt; . В листинге 9-4 показан один из способов для обработки &lt;code&gt;Result&lt;/code&gt; с использованием основного инструмента, &lt;code&gt;match&lt;/code&gt; выражения , что мы обсуждали в главе 6.</target>
        </trans-unit>
        <trans-unit id="1a52300a363f54affc64d905b97b32aef73e0083" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="translated">Нам нужно настроить канал для использования значений типа &lt;code&gt;Message&lt;/code&gt; , а не типа &lt;code&gt;Job&lt;/code&gt; , как показано в листинге 20-24.</target>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="translated">Нам нужно объявить ящик &lt;code&gt;hello_macro_derive&lt;/code&gt; как ящик процедурных макросов. Нам также понадобятся функциональные возможности ящиков &lt;code&gt;syn&lt;/code&gt; и &lt;code&gt;quote&lt;/code&gt; , как вы скоро увидите, поэтому нам нужно добавить их в качестве зависимостей. Добавьте следующий к &lt;em&gt;Cargo.toml&lt;/em&gt; файл для &lt;code&gt;hello_macro_derive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="translated">Нам нужно установить &lt;code&gt;state&lt;/code&gt; на &lt;code&gt;None&lt;/code&gt; временно , а не устанавливать его непосредственно с кодом , как &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; получить в собственность &lt;code&gt;state&lt;/code&gt; ценность. Это гарантирует, что &lt;code&gt;Post&lt;/code&gt; не сможет использовать старое значение &lt;code&gt;state&lt;/code&gt; после того, как мы преобразовали его в новое состояние.</target>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="translated">Здесь нам понадобился &lt;code&gt;clone&lt;/code&gt; потому что у нас есть фрагмент с элементами &lt;code&gt;String&lt;/code&gt; в параметре &lt;code&gt;args&lt;/code&gt; , но &lt;code&gt;new&lt;/code&gt; функция не владеет &lt;code&gt;args&lt;/code&gt; . Чтобы вернуть право собственности на экземпляр &lt;code&gt;Config&lt;/code&gt; , нам пришлось клонировать значения из полей &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; в &lt;code&gt;Config&lt;/code&gt; , чтобы экземпляр &lt;code&gt;Config&lt;/code&gt; мог владеть своими значениями.</target>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="translated">Теперь у нас есть простой API, который намного сложнее испортить, потому что компилятор гарантирует, что ссылки в &lt;code&gt;String&lt;/code&gt; остаются действительными. Помните ошибку в программе в листинге 4-8, когда мы получили индекс до конца первого слова, но затем очистили строку, так что наш индекс был недействительным? Этот код был логически неверным, но не обнаруживал немедленных ошибок. Проблемы проявятся позже, если мы будем продолжать попытки использовать индекс первого слова с пустой строкой. Срезы делают эту ошибку невозможной и дают нам знать, что у нас возникла проблема с нашим кодом намного раньше. Использование &lt;code&gt;first_word&lt;/code&gt; версии first_word вызовет ошибку времени компиляции:</target>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="translated">Теперь у нас есть способ узнать индекс конца первого слова в строке, но возникает проблема. Мы возвращаем значение &lt;code&gt;usize&lt;/code&gt; само по себе, но это только значимое число в контексте &lt;code&gt;&amp;amp;String&lt;/code&gt; . Другими словами, поскольку это отдельное значение от &lt;code&gt;String&lt;/code&gt; , нет гарантии, что оно будет действительным в будущем. Рассмотрим программу в листинге 4-8, в которой используется функция &lt;code&gt;first_word&lt;/code&gt; из листинга 4-7.</target>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="translated">Теперь нам нужно, чтобы псевдоним типа &lt;code&gt;Job&lt;/code&gt; был &lt;code&gt;Box&lt;/code&gt; всего, что реализует наш новый &lt;code&gt;FnBox&lt;/code&gt; . Это позволит нам использовать &lt;code&gt;call_box&lt;/code&gt; в &lt;code&gt;Worker&lt;/code&gt; , когда мы получаем значение &lt;code&gt;Job&lt;/code&gt; , вместо прямого вызова закрытия. Реализация трейта &lt;code&gt;FnBox&lt;/code&gt; для любого &lt;code&gt;FnOnce()&lt;/code&gt; означает, что нам не нужно ничего менять в фактических значениях, которые мы отправляем по каналу. Теперь Rust может понять, что то, что мы хотим делать, нормально.</target>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="translated">Мы передаем значение переменной &lt;code&gt;case_sensitive&lt;/code&gt; экземпляру &lt;code&gt;Config&lt;/code&gt; , чтобы функция &lt;code&gt;run&lt;/code&gt; могла прочитать это значение и решить, вызывать ли &lt;code&gt;search&lt;/code&gt; или &lt;code&gt;search_case_insensitive&lt;/code&gt; , как мы реализовали в листинге 12-22.</target>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="translated">Мы &lt;code&gt;#[should_panic]&lt;/code&gt; атрибут # [should_panic] после атрибута &lt;code&gt;#[test]&lt;/code&gt; и перед тестовой функцией, к которой он применяется. Посмотрим на результат, когда этот тест пройдет:</target>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="translated">Мы запустили тест, загрузив все содержание &lt;em&gt;&amp;laquo;Приключений Шерлока Холмса&lt;/em&gt; &amp;raquo; сэра Артура Конан Дойля в &lt;code&gt;String&lt;/code&gt; и выполнив поиск слова &lt;em&gt;the&lt;/em&gt; в содержимом. Вот результаты теста для версии &lt;code&gt;search&lt;/code&gt; с использованием цикла &lt;code&gt;for&lt;/code&gt; и версии с итераторами:</target>
        </trans-unit>
        <trans-unit id="3cb4438c8408ae587f40f74c3ab4a85a10a319c0" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a reference to a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Мы читаем это определение: функции по &lt;code&gt;largest&lt;/code&gt; является родовым по некоторому типу &lt;code&gt;T&lt;/code&gt; . Эта функция имеет один параметр с именем &lt;code&gt;list&lt;/code&gt; , который представляет собой срез значений типа &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;largest&lt;/code&gt; функция возвращает значение того же типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="translated">Мы получаем следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="translated">Мы устанавливаем связанный тип &lt;code&gt;Item&lt;/code&gt; для нашего итератора на &lt;code&gt;u32&lt;/code&gt; , то есть итератор будет возвращать значения &lt;code&gt;u32&lt;/code&gt; . Опять же, пока не беспокойтесь о связанных типах, мы рассмотрим их в главе 19.</target>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="translated">Мы устанавливаем количество тестовых потоков равным &lt;code&gt;1&lt;/code&gt; , указывая программе не использовать параллелизм. Выполнение тестов с использованием одного потока займет больше времени, чем их параллельное выполнение, но тесты не будут мешать друг другу, если они совместно используют состояние.</target>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="translated">У нас должны появиться строки, содержащие &amp;laquo;до&amp;raquo;, в котором могут быть заглавные буквы:</target>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="translated">Мы по-прежнему позволяем создавать новые сообщения в состоянии черновика, используя &lt;code&gt;Post::new&lt;/code&gt; и возможность добавлять текст к содержимому сообщения. Но вместо того, чтобы иметь метод &lt;code&gt;content&lt;/code&gt; в черновике сообщения, который возвращает пустую строку, мы сделаем так, чтобы черновики сообщений вообще не имели метода &lt;code&gt;content&lt;/code&gt; . Таким образом, если мы попытаемся получить черновик содержимого публикации, мы получим ошибку компилятора, сообщающую нам, что метода не существует. В результате мы не сможем случайно отобразить черновик содержимого публикации в продакшене, потому что этот код даже не будет компилироваться. В листинге 17-19 показано определение структуры &lt;code&gt;Post&lt;/code&gt; и структуры &lt;code&gt;DraftPost&lt;/code&gt; , а также методы для каждой из них:</target>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="translated">У нас по-прежнему есть функция &lt;code&gt;Post::new&lt;/code&gt; , но вместо возврата экземпляра &lt;code&gt;Post&lt;/code&gt; она возвращает экземпляр &lt;code&gt;DraftPost&lt;/code&gt; . Поскольку &lt;code&gt;content&lt;/code&gt; является частным и нет никаких функций, возвращающих &lt;code&gt;Post&lt;/code&gt; , сейчас невозможно создать экземпляр &lt;code&gt;Post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">Мы по-прежнему используем &lt;code&gt;()&lt;/code&gt; после &lt;code&gt;FnOnce&lt;/code&gt; , потому что этот &lt;code&gt;FnOnce&lt;/code&gt; представляет собой замыкание, которое не принимает параметров и не возвращает значение. Как и в определениях функций, возвращаемый тип может быть опущен в сигнатуре, но даже если у нас нет параметров, нам все равно нужны круглые скобки.</target>
        </trans-unit>
        <trans-unit id="fb6760fff74f1d2184578db32de57a1297acba15" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and returns the unit type &lt;code&gt;()&lt;/code&gt;. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e44b48751025b1860e023a6de0b5d66e3d099ea" translate="yes" xml:space="preserve">
          <source>We still want to have our program stop running if the unimplemented methods are reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="translated">Мы говорили о струнах в главе 4, но сейчас рассмотрим их более подробно. Новые Rustaceans обычно застревают в строках по трем причинам: склонность Rust к выявлению возможных ошибок, строки, являющиеся более сложной структурой данных, чем многие программисты приписывают им, и UTF-8. Сочетание этих факторов может показаться сложным, если вы переходите с других языков программирования.</target>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="translated">Мы временно распечатываем значения этих переменных, чтобы доказать, что код работает так, как мы предполагали. Давайте снова запустим эту программу с аргументами &lt;code&gt;test&lt;/code&gt; и &lt;code&gt;sample.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="translated">Затем мы вызываем метод &lt;code&gt;unwrap&lt;/code&gt; , который, как мы знаем, никогда не вызовет паники, потому что мы знаем, что методы в &lt;code&gt;Post&lt;/code&gt; гарантируют, что &lt;code&gt;state&lt;/code&gt; всегда будет содержать значение &lt;code&gt;Some&lt;/code&gt; , когда эти методы будут выполнены. Это один из случаев, о которых мы говорили в разделе &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;laquo;Случаи, когда у вас больше информации, чем у компилятора&amp;raquo;&lt;/a&gt; главы 9, когда мы знаем, что значение &lt;code&gt;None&lt;/code&gt; невозможно, даже если компилятор не может этого понять.</target>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="translated">Затем мы начинаем определение макроса с &lt;code&gt;macro_rules!&lt;/code&gt; и имя определяемого макроса &lt;em&gt;без&lt;/em&gt; восклицательного знака. За именем, в данном случае &lt;code&gt;vec&lt;/code&gt; , следуют фигурные скобки, обозначающие тело определения макроса.</target>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="translated">Мы используем &lt;code&gt;ThreadPool::new&lt;/code&gt; для создания нового пула потоков с настраиваемым количеством потоков, в данном случае четырьмя. Затем, в цикле &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;pool.execute&lt;/code&gt; имеет интерфейс, аналогичный &lt;code&gt;thread::spawn&lt;/code&gt; в том, что требуется закрытие, которое пул должен запускать для каждого потока. Нам нужно реализовать &lt;code&gt;pool.execute&lt;/code&gt; , чтобы он выполнял закрытие и передавал его потоку в пуле для выполнения. Этот код еще не компилируется, но мы постараемся, чтобы компилятор помог нам исправить это.</target>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="translated">Мы используем &lt;code&gt;expect&lt;/code&gt; так же, как и &lt;code&gt;unwrap&lt;/code&gt; : чтобы вернуть дескриптор файла или вызвать &lt;code&gt;panic!&lt;/code&gt; макрос. Сообщение об ошибке, используемое &lt;code&gt;expect&lt;/code&gt; в вызове &lt;code&gt;panic!&lt;/code&gt; будет параметром, который мы передаем, чтобы &lt;code&gt;expect&lt;/code&gt; , а не &lt;code&gt;panic!&lt;/code&gt; по умолчанию ! сообщение, которое использует &lt;code&gt;unwrap&lt;/code&gt; . Вот как это выглядит:</target>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Мы используем &lt;code&gt;if let&lt;/code&gt; , а не &lt;code&gt;unwrap_or_else&lt;/code&gt; , чтобы проверить, возвращает ли &lt;code&gt;run&lt;/code&gt; значение &lt;code&gt;Err&lt;/code&gt; , и вызвать &lt;code&gt;process::exit(1)&lt;/code&gt; если это так. Функция &lt;code&gt;run&lt;/code&gt; не возвращает значение, которое мы хотим &lt;code&gt;unwrap&lt;/code&gt; же, как &lt;code&gt;Config::new&lt;/code&gt; возвращает экземпляр &lt;code&gt;Config&lt;/code&gt; . Поскольку &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; в случае успеха, мы заботимся только об обнаружении ошибки, поэтому нам не нужно &lt;code&gt;unwrap_or_else&lt;/code&gt; для возврата развернутого значения, потому что это будет только &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="translated">Мы используем структуры для добавления смысла путем маркировки данных. Мы можем преобразовать кортеж, который мы используем, в тип данных с именем для всего, а также с именами для частей, как показано в листинге 5-10.</target>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="translated">Мы используем тип &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; когда мы хотим выделить некоторые данные в куче для нескольких частей нашей программы для чтения, и мы не можем определить во время компиляции, какая часть завершит использование данных последней. Если бы мы знали, какая часть завершится последней, мы могли бы просто сделать эту часть владельцем данных, и обычные правила владения, применяемые во время компиляции, вступили бы в силу.</target>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">Мы используем метод &lt;code&gt;enumerate&lt;/code&gt; , чтобы адаптировать итератор для создания значения и индекса этого значения в итераторе, помещенном в кортеж. Первый вызов &lt;code&gt;enumerate&lt;/code&gt; производит кортеж &lt;code&gt;(0, 'a')&lt;/code&gt; . Когда это значение совпадает с шаблоном &lt;code&gt;(index, value)&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; будет &lt;code&gt;0&lt;/code&gt; , а &lt;code&gt;value&lt;/code&gt; будет &lt;code&gt;'a'&lt;/code&gt; , печатается первая строка вывода.</target>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="translated">Мы используем сокращение ANYTOKEN для обозначения набора всех токенов (включая простые NT).Например,если любой токен является легальным после матчера M,то FOLLOW(M)=ANYTOKEN.</target>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="translated">Мы использовали заголовок &lt;code&gt;# Examples&lt;/code&gt; Markdown в Листинге 14-1 для создания раздела в HTML с заголовком &amp;laquo;Примеры&amp;raquo;. Вот еще несколько разделов, которые авторы ящиков обычно используют в своей документации:</target>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="translated">Мы хотим, чтобы &lt;code&gt;Cacher&lt;/code&gt; управлял значениями полей структуры, а не позволял вызывающему коду потенциально изменять значения в этих полях напрямую, поэтому эти поля являются частными.</target>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Мы хотим, чтобы &lt;code&gt;Node&lt;/code&gt; владел своими дочерними элементами, и мы хотим разделить это владение с переменными, чтобы мы могли напрямую обращаться к каждому &lt;code&gt;Node&lt;/code&gt; в дереве. Для этого мы определяем элементы &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; как значения типа &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; . Мы также хотим изменить, какие узлы являются &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; по отношению к другому узлу, поэтому у нас есть RefCell &amp;lt;T&amp;gt; в &lt;code&gt;children&lt;/code&gt; элементах вокруг &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe26c37f1d8e8931b2a537169f33a14c01a5d00" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 5, &lt;code&gt;next&lt;/code&gt; will increment &lt;code&gt;count&lt;/code&gt; and return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;. Once &lt;code&gt;count&lt;/code&gt; is 5, our iterator will stop incrementing &lt;code&gt;count&lt;/code&gt; and always return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Мы хотим, чтобы наш итератор прибавил 1 к текущему состоянию, поэтому мы инициализировали &lt;code&gt;count&lt;/code&gt; до 0, чтобы он сначала вернул 1. Если значение &lt;code&gt;count&lt;/code&gt; меньше 6, &lt;code&gt;next&lt;/code&gt; вернет текущее значение, заключенное в &lt;code&gt;Some&lt;/code&gt; , но если &lt;code&gt;count&lt;/code&gt; равно 6 или выше, наш итератор вернет &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="translated">Мы хотим, чтобы наш процедурный макрос генерировал реализацию нашей черты &lt;code&gt;HelloMacro&lt;/code&gt; для типа, аннотированного пользователем, что мы можем получить, используя &lt;code&gt;#name&lt;/code&gt; . Реализация признака имеет одну функцию, &lt;code&gt;hello_macro&lt;/code&gt; , тело которой содержит функции, которые мы хотим предоставить: печать &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; а затем имя аннотированного типа.</target>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="translated">Мы хотим, чтобы наш пул потоков работал аналогичным, знакомым образом, поэтому переключение с потоков на пул потоков не требует значительных изменений в коде, который использует наш API. В листинге 20-12 показан гипотетический интерфейс для структуры &lt;code&gt;ThreadPool&lt;/code&gt; ,которую мы хотим использовать вместо &lt;code&gt;thread::spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="translated">Нам нужны структуры &lt;code&gt;Worker&lt;/code&gt; , которые мы только что создали, для выборки кода для запуска из очереди, содержащейся в &lt;code&gt;ThreadPool&lt;/code&gt; , и отправки этого кода в свой поток для выполнения.</target>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="translated">Мы хотим добавить новую функцию &lt;code&gt;search_case_insensitive&lt;/code&gt; , которую мы будем вызывать, когда переменная среды включена . Мы продолжим следовать процессу TDD, поэтому первым шагом будет написание неудачного теста. Мы добавим новый тест для новой функции &lt;code&gt;search_case_insensitive&lt;/code&gt; и переименуем наш старый тест с &lt;code&gt;one_result&lt;/code&gt; на &lt;code&gt;case_sensitive&lt;/code&gt; , чтобы прояснить различия между двумя тестами, как показано в листинге 12-20.</target>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="translated">Мы хотим позволить пользователю создавать новый черновик сообщения в блоге с помощью &lt;code&gt;Post::new&lt;/code&gt; . Затем мы хотим разрешить добавление текста в сообщение блога, пока оно находится в состоянии черновика. Если мы попытаемся получить содержание сообщения немедленно, до утверждения, ничего не должно произойти, потому что сообщение все еще является черновиком. Мы добавили &lt;code&gt;assert_eq!&lt;/code&gt; в коде для демонстрационных целей. Отличным модульным тестом для этого было бы утверждение, что черновик сообщения в блоге возвращает пустую строку из метода &lt;code&gt;content&lt;/code&gt; , но мы не собираемся писать тесты для этого примера.</target>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="translated">Мы хотим определить код в одном месте нашей программы, но &lt;em&gt;выполнять&lt;/em&gt; этот код только там , где нам действительно нужен результат. Это вариант использования закрытий!</target>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="translated">Мы хотим что-то сделать с совпадением &lt;code&gt;Some(3)&lt;/code&gt; но ничего не делаем с любым другим значением &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; или значением &lt;code&gt;None&lt;/code&gt; . Для удовлетворения &lt;code&gt;match&lt;/code&gt; выражения, мы должны добавить &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; после обработки только один вариант, который много шаблонного кода для добавления.</target>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">Мы хотим выразить ограничение, согласно которому Foo не должен переживать &lt;code&gt;'a&lt;/code&gt; , потому что данные, на которые указывает &lt;code&gt;T&lt;/code&gt; , действительны только для этого времени жизни. Проблема в том, что здесь нет фактического использования &lt;code&gt;'a&lt;/code&gt; . Это можно обойти, добавив в структуру тип PhantomData, используя его, чтобы сообщить компилятору действовать так, как если бы структура содержала заимствованную ссылку &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8096aefade4c17845a6c208281a849237f1210fa" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; for 'MyStruct', but for some reason it only makes sense to implement the &lt;code&gt;bar()&lt;/code&gt; function. &lt;code&gt;baz()&lt;/code&gt; and &lt;code&gt;qux()&lt;/code&gt; will still need to be defined in our implementation of &lt;code&gt;Foo&lt;/code&gt;, but we can use &lt;code&gt;unimplemented!&lt;/code&gt; in their definitions to allow our code to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="translated">Мы хотим реализовать &lt;code&gt;Foo&lt;/code&gt; для одного из наших типов, но мы также хотим сначала поработать только с &lt;code&gt;bar()&lt;/code&gt; . Чтобы наш код компилировался, нам нужно реализовать &lt;code&gt;baz()&lt;/code&gt; , поэтому мы можем использовать &lt;code&gt;todo!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="translated">Мы хотим реализовать &lt;code&gt;Foo&lt;/code&gt; для одного из наших типов, но мы также хотим сначала поработать только с &lt;code&gt;bar()&lt;/code&gt; . Чтобы наш код компилировался, нам нужно реализовать &lt;code&gt;baz()&lt;/code&gt; , поэтому мы можем использовать &lt;code&gt;unimplemented!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="translated">Мы хотим создать библиотеку агрегатора мультимедиа, которая может отображать сводку данных, которые могут храниться в экземпляре &lt;code&gt;NewsArticle&lt;/code&gt; или &lt;code&gt;Tweet&lt;/code&gt; . Для этого нам нужна сводка для каждого типа, и нам нужно запросить эту сводку, вызвав метод &lt;code&gt;summarize&lt;/code&gt; для экземпляра. В листинге 10-12 показано определение трейта &lt;code&gt;Summary&lt;/code&gt; , который выражает это поведение.</target>
        </trans-unit>
        <trans-unit id="c43cd68edbbfd1b8e1512d94b1171eea5afef79e" translate="yes" xml:space="preserve">
          <source>We want to require that types of consts used in pattern matches have the attribute &lt;code&gt;#[derive(PartialEq, Eq)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="translated">Мы приветствуем всевозможный вклад.</target>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="translated">Будем стремиться использовать переменную &quot;M&quot; для обозначения матчера,переменные &quot;t&quot; и &quot;u&quot; для произвольных отдельных лексем,а переменные &quot;tt&quot; и &quot;uu&quot; для произвольных деревьев лексем.(Использование &quot;tt&quot; действительно представляет потенциальную неоднозначность с его дополнительной ролью спецификатора фрагмента;но из контекста будет понятно,под какой интерпретацией подразумевается данная интерпретация).</target>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="translated">Мы не будем реализовывать полноценную библиотеку графического интерфейса для этого примера, но покажем, как части будут сочетаться друг с другом. На момент написания библиотеки мы не могли знать и определять все типы, которые могут захотеть создать другие программисты. Но мы знаем, что &lt;code&gt;gui&lt;/code&gt; должен отслеживать множество значений разных типов, и ему необходимо вызывать метод &lt;code&gt;draw&lt;/code&gt; для каждого из этих значений с разными типами . Не нужно точно знать, что произойдет, когда мы вызовем метод &lt;code&gt;draw&lt;/code&gt; , просто значение будет иметь этот метод, доступный для нас.</target>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="translated">Мы не увидим вывода в терминал, а &lt;em&gt;output.txt&lt;/em&gt; будет содержать наши результаты:</target>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="translated">Мы получим эту ошибку:</target>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="translated">Мы оборачиваем список &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; поэтому, когда мы создаем списки &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , они оба могут ссылаться на &lt;code&gt;a&lt;/code&gt; , что мы и сделали в листинге 15-18.</target>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="translated">Мы также кратко представим замыкания, итераторы и трейт-объекты, которые подробно рассматриваются в главах &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; и &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="translated">Мы изменим начало &lt;code&gt;main&lt;/code&gt; функции, представленной в листинге 12-24, на код из листинга 13-25. Это не будет компилироваться, пока мы также не обновим &lt;code&gt;Config::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="translated">Мы проверим ошибки и обработаем их, используя технику, аналогичную той, которую мы использовали с &lt;code&gt;Config::new&lt;/code&gt; в листинге 12-10, но с небольшой разницей:</target>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Вернемся к &lt;code&gt;panic!&lt;/code&gt; и когда мы должны и не должны использовать &lt;code&gt;panic!&lt;/code&gt; для обработки условий ошибки в &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;laquo; &lt;code&gt;panic!&lt;/code&gt; или не &lt;code&gt;panic!&lt;/code&gt; &amp;raquo;&lt;/a&gt; Далее в этой главе. Далее мы рассмотрим, как исправить ошибку с помощью &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">Мы будем продолжать получать предупреждения , потому что мы ничего не делаем с параметрами на &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;execute&lt;/code&gt; . Давайте реализуем тела этих функций с желаемым поведением. Для начала подумаем о &lt;code&gt;new&lt;/code&gt; . Ранее мы выбрали тип без знака для параметра &lt;code&gt;size&lt;/code&gt; , потому что пул с отрицательным числом потоков не имеет смысла. Однако пул с нулевым &lt;code&gt;usize&lt;/code&gt; также не имеет смысла, но ноль - вполне допустимое использование . Мы добавим код для проверки того, что &lt;code&gt;size&lt;/code&gt; больше нуля, прежде чем мы вернем экземпляр &lt;code&gt;ThreadPool&lt;/code&gt; и вызовем панику программы, если она получит ноль, используя &lt;code&gt;assert!&lt;/code&gt; макрос, как показано в листинге 20-13.</target>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="translated">Мы создадим новую структуру &lt;code&gt;Job&lt;/code&gt; , которая будет содержать закрытие, которое мы хотим отправить по каналу.</target>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="translated">Мы создадим список &lt;code&gt;a&lt;/code&gt; , содержащие 5 , а затем 10. Тогда мы сделаем еще два списка: &lt;code&gt;b&lt;/code&gt; , что начинается с 3 и &lt;code&gt;c&lt;/code&gt; , что начинается с 4. Оба &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; списки будут затем продолжить на первом &lt;code&gt;a&lt;/code&gt; список , содержащий 5 и 10. Другими словами, оба списка будут использовать первый список, содержащий 5 и 10.</target>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="translated">Мы определим метод &lt;code&gt;execute&lt;/code&gt; в &lt;code&gt;ThreadPool&lt;/code&gt; , чтобы принимать закрытие в качестве параметра. Напомним , из &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;laquo;заготовления Closures Использование общих параметров и &lt;code&gt;Fn&lt;/code&gt; Черты характера&amp;raquo;&lt;/a&gt; раздел в главе 13, мы можем взять в качестве параметров замыкания с тремя различными чертами: &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; и &lt;code&gt;FnOnce&lt;/code&gt; . Нам нужно решить, какое закрытие здесь использовать. Мы знаем, что в конечном итоге сделаем что-то похожее на реализацию стандартной библиотеки &lt;code&gt;thread::spawn&lt;/code&gt; , поэтому мы можем посмотреть, что ограничивает сигнатуру &lt;code&gt;thread::spawn&lt;/code&gt; для своего параметра. Документация показывает нам следующее:</target>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="translated">Мы продемонстрируем первую ситуацию в разделе &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;laquo;Включение рекурсивных типов с помощью ящиков&amp;raquo;&lt;/a&gt; . Во втором случае передача права собственности на большой объем данных может занять много времени, потому что данные копируются в стеке. Чтобы повысить производительность в этой ситуации, мы можем хранить большой объем данных в куче в коробке. Затем в стек копируется только небольшой объем данных указателя, а данные, на которые он ссылается, остаются в одном месте в куче. Третий случай известен как &lt;em&gt;объект-признак&lt;/em&gt; , и в главе 17 целиком посвящен раздел &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;laquo;Использование объектов-признаков, допускающих значения разных типов&amp;raquo;&lt;/a&gt; именно этой теме. То, что вы узнаете здесь, вы снова примените в главе 17!</target>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="translated">Мы обсудим, как создавать и обновлять векторы, строки и хэш-карты, а также что делает каждую особенность.</target>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="translated">Мы обсудим итераторы более подробно в главе 13. А пока знайте, что &lt;code&gt;iter&lt;/code&gt; - это метод, который возвращает каждый элемент в коллекции, а &lt;code&gt;enumerate&lt;/code&gt; обертывает результат &lt;code&gt;iter&lt;/code&gt; и вместо этого возвращает каждый элемент как часть кортежа. Первый элемент кортежа, возвращаемого из &lt;code&gt;enumerate&lt;/code&gt; , является индексом, а второй элемент - ссылкой на элемент. Это немного удобнее, чем рассчитывать индекс самостоятельно.</target>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="translated">Мы исследуем некоторые аспекты работы тестов, поэкспериментируя с созданным для нас шаблоном теста, фактически не тестируя какой-либо код. Затем мы напишем несколько реальных тестов, которые вызывают некоторый написанный нами код и утверждают, что его поведение правильное.</target>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="translated">Мы будем извлекать функциональность для разбора аргументов в функции, &lt;code&gt;main&lt;/code&gt; будет вызов , чтобы подготовить для перемещения командной строки синтаксического анализа логики в &lt;em&gt;SRC / lib.rs&lt;/em&gt; . Листинг 12-5 показывает новое начало &lt;code&gt;main&lt;/code&gt; , что вызывает новую функцию &lt;code&gt;parse_config&lt;/code&gt; , которую мы будем определять в &lt;em&gt;SRC / main.rs&lt;/em&gt; на данный момент.</target>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="translated">Сначала мы определим, что мы подразумеваем под термином &amp;laquo; &lt;em&gt;строка&amp;raquo;&lt;/em&gt; . В базовом языке Rust есть только один строковый тип, а именно строковый фрагмент &lt;code&gt;str&lt;/code&gt; , который обычно встречается в заимствованной форме &lt;code&gt;&amp;amp;str&lt;/code&gt; . В главе 4 мы говорили о &lt;em&gt;строковых срезах&lt;/em&gt; , которые представляют собой ссылки на некоторые строковые данные в кодировке UTF-8, хранящиеся в другом месте. Например, строковые литералы хранятся в двоичном коде программы и поэтому являются строковыми фрагментами.</target>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="translated">Мы получим эту ошибку, потому что &lt;code&gt;String&lt;/code&gt; не реализует &lt;code&gt;Draw&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="translated">В этом разделе мы рассмотрим базовый API хэш-карт, но многие другие полезности скрываются в функциях, определенных в &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; стандартной библиотекой. Как всегда, дополнительную информацию можно найти в документации стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="translated">У нас будет больше примеров закрытия &lt;code&gt;move&lt;/code&gt; в главе 16, когда мы будем говорить о параллелизме. А пока вот код из листинга 13-12 с ключевым словом &lt;code&gt;move&lt;/code&gt; , добавленным к определению замыкания, и с использованием векторов вместо целых чисел, потому что целые числа можно копировать, а не перемещать; обратите внимание, что этот код еще не компилируется.</target>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="translated">Мы будем внедрять рабочий процесс публикации в блоге поэтапно. Окончательная функциональность блога будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="translated">Мы реализуем классическую задачу программирования для начинающих: игру в угадывание. Вот как это работает: программа сгенерирует случайное целое число от 1 до 100. Затем она предложит игроку ввести предположение. После ввода предположения программа укажет, является ли оно слишком низким или слишком высоким. Если догадка верна, игра напечатает поздравительное сообщение и выйдет.</target>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="translated">Мы реализуем это поведение, введя новую структуру данных между &lt;code&gt;ThreadPool&lt;/code&gt; и потоками, которые будут управлять этим новым поведением. Мы будем называть эту структуру данных &lt;code&gt;Worker&lt;/code&gt; , что является общим термином в реализациях объединения. Подумайте о людях, работающих на кухне в ресторане: рабочие ждут, пока поступят заказы от клиентов, а затем они несут ответственность за их принятие и выполнение.</target>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="translated">Мы улучшим &lt;code&gt;minigrep&lt;/code&gt; , добавив дополнительную функцию: возможность поиска без учета регистра, которую пользователь может включить с помощью переменной среды. Мы могли бы сделать эту функцию параметром командной строки и требовать, чтобы пользователи вводили ее каждый раз, когда они хотят, чтобы она применялась, но вместо этого мы будем использовать переменную среды. Это позволяет нашим пользователям один раз установить переменную среды и сделать все их поисковые запросы нечувствительными к регистру в этом сеансе терминала.</target>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="translated">Мы оставим метод &lt;code&gt;content&lt;/code&gt; в &lt;code&gt;Post&lt;/code&gt; как есть, возвращая пустой фрагмент строки. Теперь у нас может быть &lt;code&gt;Post&lt;/code&gt; в состоянии &lt;code&gt;PendingReview&lt;/code&gt; , а также в состоянии &lt;code&gt;Draft&lt;/code&gt; , но нам нужно такое же поведение в состоянии &lt;code&gt;PendingReview&lt;/code&gt; . Листинг 17-11 работает до строки 10!</target>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="translated">Мы ограничим количество потоков в пуле небольшим числом, чтобы защитить себя от атак типа &amp;laquo;отказ в обслуживании&amp;raquo; (DoS); Если бы наша программа создавала новый поток для каждого запроса по мере его поступления, кто-то, делающий 10 миллионов запросов к нашему серверу, мог бы создать хаос, израсходовав все ресурсы нашего сервера и остановив обработку запросов.</target>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="translated">Мы рассмотрим, как медленно обрабатываемый запрос может повлиять на другие запросы, сделанные к нашей текущей реализации сервера. В листинге 20-10 реализована обработка запроса на &lt;em&gt;/ sleep&lt;/em&gt; с имитацией медленного ответа, который заставит сервер засыпать на 5 секунд перед ответом.</target>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Мы получим ошибку, потому что значение &lt;code&gt;s&lt;/code&gt; по- прежнему будет перемещено в &lt;code&gt;_s&lt;/code&gt; , что не позволяет нам снова использовать &lt;code&gt;s&lt;/code&gt; . Однако использование подчеркивания само по себе никогда не привязывается к значению. Листинг 18-22 будет компилироваться без ошибок, потому что &lt;code&gt;s&lt;/code&gt; не перемещается в &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="translated">Мы завершим эту главу, поговорив о чертах &lt;code&gt;Send&lt;/code&gt; и &lt;code&gt;Sync&lt;/code&gt; и о том, как мы можем использовать их с пользовательскими типами.</target>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="translated">Мы покажем вам, как переосмыслить шаблон состояния, чтобы получить другой набор компромиссов. Вместо того, чтобы полностью инкапсулировать состояния и переходы, чтобы внешний код не знал о них, мы закодируем состояния в разные типы. Следовательно, система проверки типов Rust предотвратит попытки использовать черновики сообщений, в которых разрешены только опубликованные сообщения, путем выдачи ошибки компилятора.</target>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="translated">Мы смоделируем вызов этого гипотетического алгоритма с помощью функции &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; показанной в листинге 13-1, которая будет &lt;code&gt;calculating slowly...&lt;/code&gt; печатать вычисления ... , ждать две секунды, а затем возвращать любое число, которое мы передали.</target>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="translated">Начнем с работы однопоточного веб-сервера. Прежде чем мы начнем, давайте кратко рассмотрим протоколы, используемые при создании веб-серверов. Подробности этих протоколов выходят за рамки этой книги, но краткий обзор предоставит вам необходимую информацию.</target>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="translated">Мы поговорим о каждом из них по очереди, но сначала давайте посмотрим, зачем нам вообще нужны макросы, если у нас уже есть функции.</target>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="translated">Мы протестируем реализацию функциональности, которая фактически будет выполнять поиск строки запроса в содержимом файла и создавать список строк, соответствующих запросу. Мы добавим эту функцию в функцию под названием &lt;code&gt;search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">Мы будем использовать &lt;code&gt;String&lt;/code&gt; в качестве примера здесь и сконцентрируемся на частях &lt;code&gt;String&lt;/code&gt; , которые относятся к владению. Эти аспекты также применимы к другим сложным типам данных, предоставляемым стандартной библиотекой и создаваемым вами. Мы обсудим &lt;code&gt;String&lt;/code&gt; более подробно в главе 8.</target>
        </trans-unit>
        <trans-unit id="5f26df7e74655da28655e14a9fc6315701535f09" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="translated">Мы будем использовать код из Листинга 12-24, чтобы изменить способ вывода сообщений об ошибках. Из-за проведенного ранее в этой главе рефакторинга весь код, выводящий сообщения об ошибках, находится в одной функции - &lt;code&gt;main&lt;/code&gt; . Стандартная библиотека предоставляет команду &lt;code&gt;eprintln!&lt;/code&gt; макрос, который печатает в стандартный поток ошибок, поэтому давайте изменим два места, которые мы &lt;code&gt;println!&lt;/code&gt; чтобы распечатать ошибки, используйте &lt;code&gt;eprintln!&lt;/code&gt; вместо.</target>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="translated">Нам разрешено изменять значение, с которым связывает &lt;code&gt;x&lt;/code&gt; , с &lt;code&gt;5&lt;/code&gt; на &lt;code&gt;6&lt;/code&gt; при использовании &lt;code&gt;mut&lt;/code&gt; . В некоторых случаях вы захотите сделать переменную изменяемой, потому что это делает код более удобным для написания, чем если бы в нем были только неизменяемые переменные.</target>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="translated">Мы создаем экземпляр &lt;code&gt;IpAddr&lt;/code&gt; , анализируя жестко запрограммированную строку. Мы видим, что &lt;code&gt;127.0.0.1&lt;/code&gt; - действительный IP-адрес, поэтому здесь можно использовать &lt;code&gt;unwrap&lt;/code&gt; . Однако наличие жестко запрограммированной допустимой строки не меняет тип возвращаемого значения метода &lt;code&gt;parse&lt;/code&gt; : мы по-прежнему получаем значение &lt;code&gt;Result&lt;/code&gt; , и компилятор по-прежнему заставляет нас обрабатывать &lt;code&gt;Result&lt;/code&gt; как если бы вариант &lt;code&gt;Err&lt;/code&gt; возможен, потому что компилятор не t достаточно умен, чтобы видеть, что эта строка всегда является действительным IP-адресом. Если строка IP-адреса пришла от пользователя, а не была жестко закодирована в программе и, следовательно &lt;em&gt;,&lt;/em&gt; имела возможность сбоя, мы определенно хотели бы обработать &lt;code&gt;Result&lt;/code&gt; более надежным способом вместо этого.</target>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="translated">Мы переходим к более сложным программам, в которых операции могут завершаться сбоем, поэтому сейчас самое время обсудить обработку ошибок. Мы сделаем это дальше!</target>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="translated">Мы еще не закончили с этой строкой кода. Хотя то, что мы обсуждали до сих пор, представляет собой одну строку текста, это только первая часть одной логической строки кода. Вторая часть - это метод:</target>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="translated">Теперь мы дважды перебираем рабочих процессов: один раз для отправки одного сообщения &lt;code&gt;Terminate&lt;/code&gt; для каждого рабочего и один раз для вызова &lt;code&gt;join&lt;/code&gt; для каждого рабочего потока. Если мы попытаемся отправить сообщение и немедленно &lt;code&gt;join&lt;/code&gt; к одному и тому же циклу, мы не сможем гарантировать, что рабочий в текущей итерации будет тем, кто получит сообщение из канала.</target>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="translated">Мы предоставляем Rust аннотацию типа в угловых скобках, которая указывает, что мы хотим вызвать метод &lt;code&gt;baby_name&lt;/code&gt; из трейта &lt;code&gt;Animal&lt;/code&gt; , реализованного в &lt;code&gt;Dog&lt;/code&gt; , говоря, что мы хотим рассматривать тип &lt;code&gt;Dog&lt;/code&gt; как &lt;code&gt;Animal&lt;/code&gt; для этого вызова функции. Теперь этот код напечатает то, что мы хотим:</target>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">Сейчас мы получаем только предупреждения, а это значит, что он компилируется! Но обратите внимание, что если вы попробуете &lt;code&gt;cargo run&lt;/code&gt; и сделать запрос в браузере, вы увидите ошибки в браузере, которые мы видели в начале главы. Наша библиотека на самом деле еще не вызывает переданное закрытие на &lt;code&gt;execute&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="translated">Мы по-прежнему собираем аргументы командной строки в вектор, но вместо присвоения значения аргумента с индексом 1 &lt;code&gt;query&lt;/code&gt; переменной и значения аргумента с индексом 2 имени &lt;code&gt;filename&lt;/code&gt; переменной в &lt;code&gt;main&lt;/code&gt; функции, мы передаем весь вектор объекту функция &lt;code&gt;parse_config&lt;/code&gt; . Затем функция &lt;code&gt;parse_config&lt;/code&gt; содержит логику, которая определяет, какой аргумент входит в какую переменную, и передает значения обратно в &lt;code&gt;main&lt;/code&gt; . Мы по-прежнему создаем переменные &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt; , но &lt;code&gt;main&lt;/code&gt; больше не несет ответственности за определение соответствия аргументов и переменных командной строки.</target>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="translated">Мы все еще используем цикл &lt;code&gt;for&lt;/code&gt; для возврата каждой строки из &lt;code&gt;search&lt;/code&gt; и ее печати.</target>
        </trans-unit>
        <trans-unit id="704d6708be51c898fd0ee7c005925dabd11417ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still working on this line of code. Although we&amp;rsquo;re now discussing a third line of text, it&amp;rsquo;s still part of a single logical line of code. The next part is this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="translated">Мы используем другой вариант определения &lt;code&gt;List&lt;/code&gt; из листинга 15-5. Вторым элементом в варианте &lt;code&gt;Cons&lt;/code&gt; теперь является &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; , что означает, что вместо того, чтобы иметь возможность изменять значение &lt;code&gt;i32&lt;/code&gt; , как мы делали в Листинге 15-24, мы хотим изменить, на какое значение &lt;code&gt;List&lt;/code&gt; указывает вариант &lt;code&gt;Cons&lt;/code&gt; . к. Мы также добавляем &lt;code&gt;tail&lt;/code&gt; метод, чтобы нам было удобно получить доступ ко второму элементу, если у нас есть вариант &lt;code&gt;Cons&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Мы используем метод &lt;code&gt;is_err&lt;/code&gt; для &lt;code&gt;Result&lt;/code&gt; , чтобы проверить, является ли он ошибкой и, следовательно, не установлен, что означает, что он &lt;em&gt;должен&lt;/em&gt; выполнять поиск с учетом регистра. Если для переменной среды &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; установлено &lt;code&gt;is_err&lt;/code&gt; , is_err вернет false, и программа выполнит поиск без учета регистра. Нас не волнует &lt;em&gt;значение&lt;/em&gt; переменной окружения, независимо от того, установлено оно или нет, поэтому мы проверяем &lt;code&gt;is_err&lt;/code&gt; вместо использования &lt;code&gt;unwrap&lt;/code&gt; , &lt;code&gt;expect&lt;/code&gt; или любых других методов, которые мы видели в &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="translated">Фактически мы уже использовали утверждения и выражения. &lt;em&gt;Операторы&lt;/em&gt; - это инструкции, которые выполняют какое-либо действие и не возвращают значение. &lt;em&gt;Выражения&lt;/em&gt; вычисляют результирующее значение. Давайте посмотрим на несколько примеров.</target>
        </trans-unit>
        <trans-unit id="d8fc6748175101658632d95f9debdd96c25d44d2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each file in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">Мы добавили &lt;code&gt;use adder&lt;/code&gt; в верхней части кода, который нам не понадобился в модульных тестах. Причина в том, что каждый тест в каталоге &lt;code&gt;tests&lt;/code&gt; представляет собой отдельный ящик, поэтому нам нужно поместить нашу библиотеку в область видимости каждого контейнера тестов.</target>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="translated">Мы добавили строку вверху, чтобы включить в область видимости модуль файловой системы стандартной библиотеки. Код для чтения содержимого файла в строку должен выглядеть знакомо; мы использовали его в главе 12, когда читали содержимое файла для нашего проекта ввода-вывода в листинге 12-4.</target>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="translated">Мы добавили новую строку &lt;code&gt;use&lt;/code&gt; чтобы перенести &lt;code&gt;process&lt;/code&gt; из стандартной библиотеки в область видимости. Код в закрытии, который будет запускаться в случае ошибки, состоит всего из двух строк: мы печатаем значение &lt;code&gt;err&lt;/code&gt; , а затем вызываем &lt;code&gt;process::exit&lt;/code&gt; . Функция &lt;code&gt;process::exit&lt;/code&gt; немедленно остановит программу и вернет число, которое было передано в качестве кода статуса выхода. Это похоже на &lt;code&gt;panic!&lt;/code&gt; Обработка на основе, которую мы использовали в листинге 12-8, но мы больше не получаем весь дополнительный вывод. Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Мы добавили структуру с именем &lt;code&gt;Config&lt;/code&gt; ,в которой определены поля с именами &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; . Подпись &lt;code&gt;parse_config&lt;/code&gt; теперь указывает, что он возвращает значение &lt;code&gt;Config&lt;/code&gt; . В теле &lt;code&gt;parse_config&lt;/code&gt; , где мы раньше возвращали срезы строк, которые ссылаются на &lt;code&gt;String&lt;/code&gt; значения в &lt;code&gt;args&lt;/code&gt; , мы теперь определяем &lt;code&gt;Config&lt;/code&gt; для содержания собственных &lt;code&gt;String&lt;/code&gt; значений. &lt;code&gt;args&lt;/code&gt; переменный в &lt;code&gt;main&lt;/code&gt; является владельцем значений аргументов и только позволив &lt;code&gt;parse_config&lt;/code&gt; функцию заимствовать их, что означает , что мы бы нарушить правила по заемной Ржавчине, если &lt;code&gt;Config&lt;/code&gt; пытался стать владельцем значений в &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="translated">Мы добавили некоторую документацию для нашего &lt;code&gt;ThreadPool&lt;/code&gt; с комментариями документа. Обратите внимание, что мы следовали хорошей практике документирования, добавив раздел, который вызывает ситуации, в которых наша функция может &lt;code&gt;cargo doc --open&lt;/code&gt; панику, как описано в главе 14. Попробуйте запустить Cargo doc --open и щелкнуть структуру &lt;code&gt;ThreadPool&lt;/code&gt; , чтобы увидеть, какие сгенерированные документы для &lt;code&gt;new&lt;/code&gt; вида лайк!</target>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="translated">Мы добавили метод &lt;code&gt;request_review&lt;/code&gt; к трейту &lt;code&gt;State&lt;/code&gt; ; все типы, реализующие эту черту, теперь должны будут реализовать метод &lt;code&gt;request_review&lt;/code&gt; . Обратите внимание, что вместо &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self&lt;/code&gt; или &lt;code&gt;&amp;amp;mut self&lt;/code&gt; в качестве первого параметра метода у нас есть &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; . Этот синтаксис означает, что метод действителен только при вызове &lt;code&gt;Box&lt;/code&gt; , содержащего тип. Этот синтаксис становится владельцем &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; , делая старое состояние недействительным, поэтому значение состояния &lt;code&gt;Post&lt;/code&gt; может преобразоваться в новое состояние.</target>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="translated">Мы уже встречали несколько интеллектуальных указателей в этой книге, например &lt;code&gt;String&lt;/code&gt; и &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; в главе 8, хотя в то время мы не называли их интеллектуальными указателями. Оба этих типа считаются интеллектуальными указателями, потому что они владеют некоторой памятью и позволяют управлять ею. У них также есть метаданные (например, их емкость) и дополнительные возможности или гарантии (например, &lt;code&gt;String&lt;/code&gt; , гарантирующий, что его данные всегда будут действительными UTF-8).</target>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="translated">Мы уже видели строковые литералы, где строковое значение жестко закодировано в нашей программе. Строковые литералы удобны, но не подходят для каждой ситуации, в которой мы можем захотеть использовать текст. Одна из причин в том, что они неизменны. Другой заключается в том, что не каждое строковое значение может быть известно, когда мы пишем наш код: например, что, если мы хотим принимать вводимые пользователем данные и сохранять их? Для таких ситуаций в Rust есть второй строковый тип &lt;code&gt;String&lt;/code&gt; . Этот тип размещается в куче и, как таковой, может хранить объем текста, который нам неизвестен во время компиляции. Вы можете создать &lt;code&gt;String&lt;/code&gt; из строкового литерала, используя функцию &lt;code&gt;from&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">Мы добавили &lt;code&gt;std::thread&lt;/code&gt; в область видимости в контейнере библиотеки, потому что мы используем &lt;code&gt;thread::JoinHandle&lt;/code&gt; в качестве типа элементов вектора в &lt;code&gt;ThreadPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">Мы изменили имя поля на &lt;code&gt;ThreadPool&lt;/code&gt; от &lt;code&gt;threads&lt;/code&gt; для &lt;code&gt;workers&lt;/code&gt; , потому что теперь держат &lt;code&gt;Worker&lt;/code&gt; экземпляров вместо &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; экземпляров. Мы используем счетчик в цикле &lt;code&gt;for&lt;/code&gt; в качестве аргумента &lt;code&gt;Worker::new&lt;/code&gt; , и мы сохраняем каждый новый &lt;code&gt;Worker&lt;/code&gt; в векторе с именем &lt;code&gt;workers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="translated">Мы выбрали &lt;code&gt;&amp;amp;self&lt;/code&gt; по той же причине, по которой мы использовали &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; в версии функции: мы не хотим брать на себя ответственность, и мы просто хотим читать данные в структуре, а не записывать в нее. Если бы мы хотели изменить экземпляр, для которого мы вызвали метод, как часть того, что делает метод, мы бы использовали &lt;code&gt;&amp;amp;mut self&lt;/code&gt; в качестве первого параметра. Редко иметь метод, который берет на себя ответственность за экземпляр, используя только &lt;code&gt;self&lt;/code&gt; в качестве первого параметра; этот метод обычно используется, когда метод преобразует &lt;code&gt;self&lt;/code&gt; во что-то еще, и вы хотите запретить вызывающему объекту использовать исходный экземпляр после преобразования.</target>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="translated">Мы создали необработанные указатели, используя &lt;code&gt;as&lt;/code&gt; для приведения неизменяемой и изменяемой ссылки к их соответствующим типам необработанных указателей. Поскольку мы создали их непосредственно из ссылок, которые гарантированно действительны, мы знаем, что эти конкретные необработанные указатели действительны, но мы не можем сделать это предположение относительно любого необработанного указателя.</target>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="translated">Мы определили макрос, который может принимать любое количество аргументов любого типа и может генерировать код для создания вектора, содержащего указанные элементы.</target>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="translated">В этой главе мы описали большинство дополнительных функций как редко используемые. Связанные типы находятся где-то посередине: они используются реже, чем функции, описанные в остальной части книги, но чаще, чем многие другие функции, обсуждаемые в этой главе.</target>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="translated">Мы деструктурировали перечисления ранее в этой книге, например, когда мы деструктурировали &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; в листинге 6-5 в главе 6. Одна деталь, которую мы не упомянули явно, заключается в том, что шаблон для деструктуризации перечисления должен соответствовать способу данные, хранящиеся в перечислении, определены. В качестве примера, в листинге 18-15 мы используем перечисление &lt;code&gt;Message&lt;/code&gt; из листинга 6-2 и записываем &lt;code&gt;match&lt;/code&gt; с шаблонами, которые деструктурируют каждое внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="translated">Мы выпустили код! Этот код абсолютно верен, хотя он означает, что мы не можем использовать неопровержимый шаблон без получения ошибки. Если мы дадим &lt;code&gt;if let&lt;/code&gt; шаблон, который всегда будет совпадать, например &lt;code&gt;x&lt;/code&gt; , как показано в листинге 18-10, он не будет компилироваться.</target>
        </trans-unit>
        <trans-unit id="78dee02791985c19ffc271569fd60c5a8fc8dade" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, the compiler will give a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="translated">Мы жестко запрограммировали переменную &lt;code&gt;simulated_user_specified_value&lt;/code&gt; как 10 и переменную &lt;code&gt;simulated_random_number&lt;/code&gt; как 7 для простоты; в реальной программе, мы получим число интенсивности от приложения внешнего интерфейса, и мы будем использовать &lt;code&gt;rand&lt;/code&gt; клеть , чтобы сгенерировать случайное число, как мы это делали в примере угадайки в главе 2. &lt;code&gt;main&lt;/code&gt; функция называет &lt;code&gt;generate_workout&lt;/code&gt; функции с смоделированными входными значениями.</target>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="translated">Мы представили три новых ящика: &lt;code&gt;proc_macro&lt;/code&gt; , &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;proc_macro&lt;/code&gt; клеть приходит с Руст, так что нам не нужно добавить , что зависимостям в &lt;em&gt;Cargo.toml&lt;/em&gt; . &lt;code&gt;proc_macro&lt;/code&gt; клеть является API компилятора , который позволяет читать и манипулировать Rust код из нашего кода.</target>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="translated">Мы широко использовали ключевое слово &lt;code&gt;pub&lt;/code&gt; : в &lt;code&gt;Config&lt;/code&gt; , в его полях и его &lt;code&gt;new&lt;/code&gt; методе, а также в функции &lt;code&gt;run&lt;/code&gt; . Теперь у нас есть ящик библиотеки с общедоступным API, который мы можем протестировать!</target>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="translated">Мы внесли несколько небольших и простых изменений: мы передаем принимающий конец канала в &lt;code&gt;Worker::new&lt;/code&gt; , а затем используем его внутри замыкания.</target>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="translated">Мы внесли здесь три значительных изменения. Сначала мы изменили тип возвращаемого значения функции &lt;code&gt;run&lt;/code&gt; на &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt; . Эта функция ранее возвращала тип модуля &lt;code&gt;()&lt;/code&gt; , и мы сохраняем его как значение, возвращаемое в случае &lt;code&gt;Ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="translated">В теле &lt;code&gt;new&lt;/code&gt; функции мы внесли два изменения : вместо вызова &lt;code&gt;panic!&lt;/code&gt; когда пользователь не передает достаточно аргументов, мы теперь возвращаем значение &lt;code&gt;Err&lt;/code&gt; , а возвращаемое значение &lt;code&gt;Config&lt;/code&gt; заключили в &lt;code&gt;Ok&lt;/code&gt; . Эти изменения заставляют функцию соответствовать ее сигнатуре нового типа.</target>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="translated">Мы упоминали, что в Rust мы воздерживаемся от вызова структур и перечислений &amp;laquo;объектов&amp;raquo;, чтобы отличать их от объектов других языков. В структуре или перечислении данные в полях структуры и поведение в блоках &lt;code&gt;impl&lt;/code&gt; разделены, тогда как в других языках данные и поведение, объединенные в одну концепцию, часто обозначаются как объект. Тем не менее, Trait объектов &lt;em&gt;являются&lt;/em&gt; более подобными объектами на других языках , в том смысле , что они сочетают в себе данные и поведение. Но объекты признаков отличаются от традиционных объектов тем, что мы не можем добавлять данные в объект признаков. Объекты-черты обычно не так полезны, как объекты на других языках: их конкретная цель - позволить абстракцию в рамках общего поведения.</target>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="translated">Мы переместили создание новой &lt;code&gt;String&lt;/code&gt; в &lt;code&gt;s&lt;/code&gt; в начало функции; эта часть не изменилась. Вместо создания переменной &lt;code&gt;f&lt;/code&gt; мы &lt;code&gt;read_to_string&lt;/code&gt; вызов read_to_string непосредственно к результату &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt; . У нас еще есть &lt;code&gt;?&lt;/code&gt; в конце вызова &lt;code&gt;read_to_string&lt;/code&gt; , и мы по-прежнему возвращаем значение &lt;code&gt;Ok&lt;/code&gt; , содержащее имя пользователя в &lt;code&gt;s&lt;/code&gt; , когда оба &lt;code&gt;File::open&lt;/code&gt; и &lt;code&gt;read_to_string&lt;/code&gt; завершаются успешно, а не возвращают ошибки. Функциональность снова такая же, как в листингах 9-6 и 9-7; это просто другой, более эргономичный способ его написания.</target>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="translated">Мы назвали наш тест &lt;code&gt;larger_can_hold_smaller&lt;/code&gt; и создали два экземпляра &lt;code&gt;Rectangle&lt;/code&gt; , которые нам нужны. Затем мы вызвали &lt;code&gt;assert!&lt;/code&gt; макрос и передал ему результат вызова &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt; . Это выражение должно возвращать &lt;code&gt;true&lt;/code&gt; , поэтому наш тест должен пройти. Давайте разберемся!</target>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="translated">Теперь мы рассмотрели, как использовать перечисления для создания настраиваемых типов, которые могут быть одним из набора перечисляемых значений. Мы показали, как тип &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; стандартной библиотеки помогает вам использовать систему типов для предотвращения ошибок. Когда значения перечисления содержат данные внутри, вы можете использовать &lt;code&gt;match&lt;/code&gt; или &lt;code&gt;if let&lt;/code&gt; для извлечения и использования этих значений, в зависимости от того, сколько случаев вам нужно обработать.</target>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="translated">Мы видели, что, хотя Rust может реализовывать объектно-ориентированные шаблоны проектирования, другие шаблоны, такие как кодирование состояния в систему типов, также доступны в Rust. У этих паттернов есть разные компромиссы. Хотя вы, возможно, хорошо знакомы с объектно-ориентированными шаблонами, переосмысление проблемы для использования преимуществ функций Rust может дать такие преимущества, как предотвращение некоторых ошибок во время компиляции. Объектно-ориентированные шаблоны не всегда будут лучшим решением в Rust из-за определенных функций, таких как право собственности, которых нет в объектно-ориентированных языках.</target>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="translated">Мы показали несколько различных способов определения структур данных для хранения IP-адресов версий 4 и 6. Однако, как оказалось, желание хранить IP-адреса и кодировать их тип настолько распространено, что &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;в стандартной библиотеке есть определение, которое мы можем использовать!&lt;/a&gt; Давайте посмотрим, как стандартная библиотека определяет &lt;code&gt;IpAddr&lt;/code&gt; : у нее есть точное перечисление и варианты, которые мы определили и использовали, но он встраивает данные адреса внутри вариантов в виде двух разных структур, которые определяются по-разному для каждого варианта:</target>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="translated">Мы показали, что Rust может реализовать объектно-ориентированный шаблон состояния, чтобы инкапсулировать различные типы поведения, которые публикация должна иметь в каждом состоянии. Методы &lt;code&gt;Post&lt;/code&gt; ничего не знают о различном поведении. Как мы организовали код, мы должны искать только в одном месте, чтобы знать, как может вести себя опубликованный пост: реализация признака &lt;code&gt;State&lt;/code&gt; в структуре &lt;code&gt;Published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="translated">Мы показали, что вы можете создать итератор, вызвав &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;into_iter&lt;/code&gt; или &lt;code&gt;iter_mut&lt;/code&gt; для вектора. Вы можете создавать итераторы из других типов коллекций в стандартной библиотеке, таких как хэш-карта. Вы также можете создавать итераторы, которые делают все, что захотите, реализуя черту &lt;code&gt;Iterator&lt;/code&gt; для ваших собственных типов. Как упоминалось ранее, единственный метод, для которого требуется дать определение, - это &lt;code&gt;next&lt;/code&gt; метод. Как только вы это сделаете, вы сможете использовать все другие методы, реализация которых по умолчанию обеспечивается &lt;code&gt;Iterator&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="translated">Мы говорили о том, как передавать закрытие в функции; вы также можете передавать в функции обычные функции! Этот метод полезен, когда вы хотите передать функцию, которую вы уже определили, а не определять новое замыкание. Выполнение этого с помощью указателей функций позволит вам использовать функции в качестве аргументов для других функций. Функции приводятся к типу &lt;code&gt;fn&lt;/code&gt; (со строчной буквой f), не путать с признаком закрытия &lt;code&gt;Fn&lt;/code&gt; . Тип &lt;code&gt;fn&lt;/code&gt; называется &lt;em&gt;указателем&lt;/em&gt; на &lt;em&gt;функцию&lt;/em&gt; . Синтаксис определения того, что параметр является указателем на функцию, аналогичен синтаксису замыканий, как показано в листинге 19-27.</target>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="translated">Мы обновили &lt;code&gt;main&lt;/code&gt; , так что он помещает экземпляр &lt;code&gt;Config&lt;/code&gt; , возвращенный &lt;code&gt;parse_config&lt;/code&gt; , в переменную с именем &lt;code&gt;config&lt;/code&gt; , и мы обновили код, который ранее использовал отдельные переменные &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; так что теперь вместо него используются поля в структуре &lt;code&gt;Config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="translated">Мы обновили &lt;code&gt;main&lt;/code&gt; , где мы &lt;code&gt;parse_config&lt;/code&gt; чтобы вместо этого вызывать &lt;code&gt;Config::new&lt;/code&gt; . Мы изменили имя &lt;code&gt;parse_config&lt;/code&gt; на &lt;code&gt;new&lt;/code&gt; и переместили его в блок &lt;code&gt;impl&lt;/code&gt; , который связывает &lt;code&gt;new&lt;/code&gt; функцию с &lt;code&gt;Config&lt;/code&gt; . Попробуйте снова скомпилировать этот код, чтобы убедиться, что он работает.</target>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="translated">В этом примере мы использовали &lt;code&gt;recv&lt;/code&gt; для простоты; у нас нет другой работы для основного потока, кроме ожидания сообщений, поэтому блокировка основного потока уместна.</target>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="translated">Мы использовали такие макросы, как &lt;code&gt;println!&lt;/code&gt; на протяжении всей книги, но мы не полностью исследовали, что такое макрос и как он работает. Термин &lt;em&gt;макрос&lt;/em&gt; относится к семейству функций в Rust: &lt;em&gt;декларативные&lt;/em&gt; макросы с &lt;code&gt;macro_rules!&lt;/code&gt; и три вида &lt;em&gt;процедурных&lt;/em&gt; макросов:</target>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="translated">Мы использовали пакеты из &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; как зависимости от нашего проекта, но вы также можете поделиться своим кодом с другими людьми, опубликовав свои собственные пакеты. Реестр crate на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; распространяет исходный код ваших пакетов, поэтому в нем в основном размещается код с открытым исходным кодом.</target>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="translated">Мы использовали подчеркивание ( &lt;code&gt;_&lt;/code&gt; ) как шаблон подстановки, который будет соответствовать любому значению, но не привязан к значению. Хотя подчеркивание &lt;code&gt;_&lt;/code&gt; картина особенно полезна в качестве последнего плеча в &lt;code&gt;match&lt;/code&gt; выражении, мы можем использовать его в любой модели, в том числе параметров функции, как показано в листинге 18-17.</target>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="translated">Мы рассмотрели пример программы на Rust уже в главе 2. Теперь, когда мы миновали базовый синтаксис, мы не будем включать в примеры весь код &lt;code&gt;fn main() {&lt;/code&gt; , поэтому, если вы следуете за ним, вы Придется вручную поместить следующие примеры в &lt;code&gt;main&lt;/code&gt; функцию. В результате наши примеры будут немного более краткими, что позволит нам сосредоточиться на фактических деталях, а не на стандартном коде.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="translated">Слабые ключевые слова</target>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">Добро пожаловать в книгу &quot; &lt;em&gt;Язык программирования Rust&quot;&lt;/em&gt; ! В этой версии текста предполагается, что вы используете Rust 1.31.0 или новее с &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; в &lt;em&gt;Cargo.toml&lt;/em&gt; всех проектов, чтобы использовать идиомы Rust 2018 Edition. См. Раздел &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;laquo;Установка&amp;raquo; главы 1,&lt;/a&gt; чтобы установить или обновить Rust, и см. Новое &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Приложение E&lt;/a&gt; для получения информации о том, какие выпуски Rust есть.</target>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">Добро пожаловать в книгу &quot; &lt;em&gt;Язык программирования Rust&quot;&lt;/em&gt; ! В этой версии текста предполагается, что вы используете Rust 1.31.0 или новее с &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; в &lt;em&gt;Cargo.toml&lt;/em&gt; всех проектов, чтобы использовать идиомы Rust 2018 Edition. См. Раздел &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;laquo;Установка&amp;raquo; главы 1,&lt;/a&gt; чтобы установить или обновить Rust, и см. Новое &lt;a href=&quot;appendix-05-editions&quot;&gt;Приложение E&lt;/a&gt; для получения информации о том, какие выпуски Rust есть.</target>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="translated">Добро пожаловать в &lt;em&gt;The Rust Programming Language&lt;/em&gt; , вводную книгу о Rust. Язык программирования Rust помогает писать более быстрое и надежное программное обеспечение. Эргономика высокого уровня и управление на низком уровне часто противоречат друг другу при разработке языков программирования; Rust бросает вызов этому конфликту. Благодаря уравновешиванию мощных технических возможностей и отличного опыта разработчика, Rust дает вам возможность управлять низкоуровневыми деталями (такими как использование памяти) без всех хлопот, традиционно связанных с таким контролем.</target>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="translated">Отлично сработано! Вы дочитали книгу до конца! Мы хотим поблагодарить вас за то, что вы присоединились к нам в этом туре по Rust. Теперь вы готовы реализовывать свои собственные проекты на Rust и помогать в проектах других людей. Имейте в виду, что есть приветливое сообщество других Rustaceans, которые будут рады помочь вам с любыми проблемами, с которыми вы столкнетесь на вашем пути к Rust.</target>
        </trans-unit>
        <trans-unit id="e51a9120a6d90f0f111fa29f2fe00c6bb7da9412" translate="yes" xml:space="preserve">
          <source>What &lt;em id=&quot;what-the-reference-is-not&quot;&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">Чем не является &lt;em&gt;ссылка&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="translated">Что такое собственность?</target>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="translated">Что такое струна?</target>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="translated">Что мне делать?</target>
        </trans-unit>
        <trans-unit id="b31d036160b82937b3f747c02baff101759a7996" translate="yes" xml:space="preserve">
          <source>What expression to evaluate when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition evaluates to &lt;a href=&quot;keyword.false&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="translated">Что произошло? Добавление ключевого слова &lt;code&gt;pub&lt;/code&gt; перед &lt;code&gt;mod hosting&lt;/code&gt; делает модуль общедоступным. С этим изменением, если мы сможем получить доступ к &lt;code&gt;front_of_house&lt;/code&gt; , мы сможем получить доступ к &lt;code&gt;hosting&lt;/code&gt; . Но &lt;em&gt;содержание&lt;/em&gt; на &lt;code&gt;hosting&lt;/code&gt; до сих пор частные; публикация модуля не делает его содержимое открытым. &lt;code&gt;pub&lt;/code&gt; ключевое слово в модуле позволяет только код в своих предках модулей относятся к нему.</target>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="translated">Что произойдет,если вы попытаетесь получить доступ к элементу массива,который находится за концом массива? Допустим,вы измените пример на следующий код,который при запуске скомпилируется,но выйдет с ошибкой:</target>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="translated">То,что реализация черты обозначает тип</target>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">Что такое &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="translated">Что содержится в стандартной библиотечной документации?</target>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="translated">Что такое защита от ветра?</target>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="translated">Какие операторы и методы,выведенные из этой черты,будут позволять</target>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;З&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;З&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="translated">Какой должна быть ценность &lt;code&gt;answer&lt;/code&gt; ? Это должна быть &lt;code&gt;З&lt;/code&gt; , первая буква? Когда закодированы в UTF-8, первый байт &lt;code&gt;З&lt;/code&gt; является &lt;code&gt;208&lt;/code&gt; и второй &lt;code&gt;151&lt;/code&gt; , так что &lt;code&gt;answer&lt;/code&gt; должен быть на самом деле &lt;code&gt;208&lt;/code&gt; , но &lt;code&gt;208&lt;/code&gt; не является допустимым символом в одиночку. Вероятно, возврат &lt;code&gt;208&lt;/code&gt; - это не то, что хотел бы пользователь, если бы он попросил первую букву этой строки; однако это единственные данные, которые Rust имеет с байтовым индексом 0. Обычно пользователи не хотят возвращать байтовое значение, даже если строка содержит только латинские буквы: если &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; был допустимым кодом, который вернул байтовое значение , он вернет &lt;code&gt;104&lt;/code&gt; , а не &lt;code&gt;h&lt;/code&gt; . Чтобы избежать возврата неожиданного значения и возникновения ошибок, которые могут быть обнаружены не сразу, Rust вообще не компилирует этот код и предотвращает недоразумения на ранних этапах процесса разработки.</target>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="translated">Что делает реализация трейта, предоставленного &lt;code&gt;derive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Это означает, что любой тип аргумента, реализующий черту &lt;a href=&quot;trait.binary&quot;&gt; &lt;code&gt;fmt::Binary&lt;/code&gt; &lt;/a&gt; может быть отформатирован с помощью &lt;code&gt;{:b}&lt;/code&gt; . Стандартные библиотеки также предоставляют реализации этих черт для ряда примитивных типов. Если формат не указан (как в &lt;code&gt;{}&lt;/code&gt; или &lt;code&gt;{:6}&lt;/code&gt; ), то используемая характеристика формата - это характеристика &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="translated">Что делать, &lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; условие if не выполняется.</target>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="translated">Что мы не видим в этом примере, так это то, что когда &lt;code&gt;b&lt;/code&gt; , а затем &lt;code&gt;a&lt;/code&gt; выходят из области видимости в конце &lt;code&gt;main&lt;/code&gt; , тогда счетчик равен 0, и &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; полностью очищается в этой точке. Использование &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; позволяет одному значению иметь несколько владельцев, а счетчик гарантирует, что значение остается действительным, пока существует какой-либо из владельцев.</target>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="translated">Как бы выглядело общение с помощью общей памяти? Кроме того,почему энтузиасты,передающие сообщения,не используют ее,а делают наоборот?</target>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="translated">Что бы произошло, если бы мы использовали &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt; ? Ответ: Rust запаниковал бы во время выполнения точно так же, как если бы в векторе был открыт неверный индекс:</target>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="translated">Что произойдет с кодом в листинге 16-4, в котором основной поток называется &lt;code&gt;drop&lt;/code&gt; , если мы воспользуемся закрытием &lt;code&gt;move&lt;/code&gt; ? Может &lt;code&gt;move&lt;/code&gt; исправить это дело? К сожалению нет; мы получили бы другую ошибку, потому что то, что пытается сделать в листинге 16-4, запрещено по другой причине. Если бы мы добавили &lt;code&gt;move&lt;/code&gt; к замыканию, мы переместим &lt;code&gt;v&lt;/code&gt; в среду замыкания, и мы больше не сможем вызывать &lt;code&gt;drop&lt;/code&gt; для него в основном потоке. Вместо этого мы получим эту ошибку компилятора:</target>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">В чем разница между &lt;code&gt;Copy&lt;/code&gt; и &lt;code&gt;Clone&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="c8dcd460b2b3eb060b9c3f227627cad77273bd6e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; is omitted from &lt;code&gt;FunctionQualifiers&lt;/code&gt; in function items, the ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; is assigned. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="translated">Когда &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; создают значение больше максимального или меньше минимального значения, которое может быть сохранено. Сюда входит и унарный &lt;code&gt;-&lt;/code&gt; для наименьшего значения любого целочисленного типа со знаком.</target>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="translated">Когда &lt;code&gt;Trait2&lt;/code&gt; является вычитанием из &lt;code&gt;Trait1&lt;/code&gt; (например, когда &lt;code&gt;Trait2&lt;/code&gt; имеет определение как &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt; ), не разрешается реализовывать &lt;code&gt;Trait1&lt;/code&gt; для &lt;code&gt;Trait2&lt;/code&gt; . Это связано с тем, что &lt;code&gt;Trait2&lt;/code&gt; уже реализует &lt;code&gt;Trait1&lt;/code&gt; по определению, поэтому делать это бесполезно.</target>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="translated">Когда &lt;code&gt;Trait&lt;/code&gt; обрабатывается как тип, тип не реализует специальную черту &lt;code&gt;Sized&lt;/code&gt; , потому что тип не имеет известного размера во время компиляции и может быть доступен только через указатель. Таким образом, если у нас есть такая черта, как следующая:</target>
        </trans-unit>
        <trans-unit id="f4fcd22fdc939d17d3b6f99c714199ea75ee05bf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bar&lt;/code&gt; is the name of a function, then the expression &lt;code&gt;bar&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function &lt;code&gt;bar&lt;/code&gt;. The value is zero-sized because the type already identifies the function. This has the advantage that &quot;calling&quot; the value (it implements the &lt;code&gt;Fn*&lt;/code&gt; traits) does not require dynamic dispatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="translated">При обнаружении &lt;code&gt;break&lt;/code&gt; выполнение связанного тела цикла немедленно прекращается, например:</target>
        </trans-unit>
        <trans-unit id="b790b4f62a35aeedd4f3d63c2da173a7ec837ca2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c791d46f518801c28641842a73515ec8d559a2ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration is terminated, returning control to the loop head, typically continuing with the next iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="translated">Когда &lt;code&gt;continue&lt;/code&gt; встречаются, текущая итерация ассоциированного тела цикла немедленно завершается, возвращая управление в контуре &lt;em&gt;голову&lt;/em&gt; . В случае в &lt;code&gt;while&lt;/code&gt; цикла, голова условное выражение контроля цикла. В случае цикла &lt;code&gt;for&lt;/code&gt; голова - это выражение вызова, управляющее циклом.</target>
        </trans-unit>
        <trans-unit id="95185630ceafb190a6bbaa449dad38f0bceaa3df" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called by another attributed function &lt;code&gt;g&lt;/code&gt; which is in turn called by &lt;code&gt;calls_g&lt;/code&gt;, code in both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; observes &lt;code&gt;g&lt;/code&gt;'s callsite within &lt;code&gt;calls_g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3d8142d10bdab6df8f2b960ed3b5f595f6be33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called directly by &lt;code&gt;calls_f&lt;/code&gt;, code in &lt;code&gt;f&lt;/code&gt; observes its callsite within &lt;code&gt;calls_f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b714a909447f7628d7a5c65a1ec2d8d650053b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;g&lt;/code&gt; is called by another attributed function &lt;code&gt;h&lt;/code&gt; which is in turn called by &lt;code&gt;calls_h&lt;/code&gt;, all code in &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; observes &lt;code&gt;h&lt;/code&gt;'s callsite within &lt;code&gt;calls_h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;outer&lt;/code&gt; выходит за пределы области видимости, сначала &lt;code&gt;drop&lt;/code&gt; метод drop для &lt;code&gt;Outer&lt;/code&gt; , а затем для &lt;code&gt;Inner&lt;/code&gt; . Поэтому &lt;code&gt;main&lt;/code&gt; принты &lt;code&gt;Dropping Outer!&lt;/code&gt; а затем &lt;code&gt;Dropping Inner!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="translated">Когда &lt;code&gt;s&lt;/code&gt; входит &lt;em&gt;в область видимости&lt;/em&gt; , это действительно так.</target>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;security_qos_flags&lt;/code&gt; не установлен, вредоносная программа может получить повышенные привилегии привилегированного процесса Rust, если она позволяет открывать указанные пользователем пути, обманом открыв именованный канал. Так что, возможно, &lt;code&gt;security_qos_flags&lt;/code&gt; также должен быть установлен при открытии произвольных путей. Однако биты могут конфликтовать с другими флагами, в частности с &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6050c0d5bfa7ba1d59f28a5f8ace3a1e46fb76d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set, a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">Когда мой тип &lt;em&gt;не может&lt;/em&gt; быть &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">Когда мой шрифт &lt;em&gt;должен&lt;/em&gt; быть &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="translated">Когда Rust компилирует этот код, он выполняет мономорфизацию. Во время этого процесса компилятор считывает значения, которые использовались в экземплярах &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; и определяет два типа &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; : один - &lt;code&gt;i32&lt;/code&gt; , а другой - &lt;code&gt;f64&lt;/code&gt; . Таким образом, он расширяет универсальное определение &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; на &lt;code&gt;Option_i32&lt;/code&gt; и &lt;code&gt;Option_f64&lt;/code&gt; , тем самым заменяя общее определение конкретными.</target>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="translated">Когда следует использовать какую коллекцию?</target>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="translated">Когда замыкание получает значение из своего окружения, оно использует память для хранения значений для использования в теле замыкания. Такое использование памяти является накладными расходами, которые мы не хотим оплачивать в более распространенных случаях, когда мы хотим выполнить код, который не захватывает его среду. Поскольку функциям никогда не разрешается захватывать свое окружение, определение и использование функций никогда не повлечет за собой эти накладные расходы.</target>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="translated">Когда функция требует правильного выравнивания, она делает это, даже если доступ имеет размер 0, т.е. даже если память фактически не задействована. В таких случаях &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling&lt;/code&gt; &lt;/a&gt; использовании NonNull :: dangling .</target>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="translated">Когда функция возвращает &lt;code&gt;Pending&lt;/code&gt; , функция также &lt;em&gt;должна&lt;/em&gt; гарантировать, что текущая задача запланирована на пробуждение, когда может быть достигнут прогресс.</target>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="translated">Когда будущее еще не готово, &lt;code&gt;poll&lt;/code&gt; возвращает &lt;code&gt;Poll::Pending&lt;/code&gt; и сохраняет клон &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; ,&lt;/a&gt; скопированный из текущего &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; . Затем этот &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; будит, когда будущее может прогрессировать. Например, будущее, ожидающее, когда сокет станет доступным для чтения, вызовет &lt;code&gt;.clone()&lt;/code&gt; в &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; и сохранит его. Когда в другое место приходит сигнал, указывающий, что сокет доступен для чтения, вызывается &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt; &lt;code&gt;Waker::wake&lt;/code&gt; &lt;/a&gt; и пробуждается задача будущего сокета. После того, как задача была разбужена, она должна снова попытаться &lt;code&gt;poll&lt;/code&gt; будущее, что может дать или не дать окончательное значение.</target>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="translated">Когда делается ссылка на универсальную функцию, ее тип создается в зависимости от контекста ссылки. Например, вызов функции &lt;code&gt;foo&lt;/code&gt; здесь:</target>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="translated">При экспорте макроса к &lt;code&gt;#[macro_export]&lt;/code&gt; можно &lt;code&gt;local_inner_macros&lt;/code&gt; ключевое слово local_inner_macros для автоматического префикса всех содержащихся в нем вызовов макросов с помощью &lt;code&gt;$crate::&lt;/code&gt; . Это предназначено в первую очередь как инструмент для переноса кода, написанного до того, как &lt;code&gt;$crate&lt;/code&gt; был добавлен в язык для работы с импортом макросов на основе путей в Rust 2018. В новом коде не рекомендуется его использование.</target>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="translated">Когда макрос вызывается по неквалифицированному идентификатору (не являющемуся частью многокомпонентного пути),он сначала просматривается в текстовой области видимости.Если это не приводит к каким-либо результатам,то макрос просматривается в области видимости по пути.Если имя макроса квалифицируется с помощью пути,то он просматривается только в области видимости на основе пути.</target>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="translated">При вызове макроса модуль расширения макросов ищет вызовы макроса по имени и пробует каждое правило макроса по очереди. Он расшифровывает первое успешное совпадение; если это приводит к ошибке, то дальнейшие совпадения не пробуются. При сопоставлении просмотр вперед не выполняется; если компилятор не может однозначно определить, как анализировать вызов макроса по одному токену за раз, то это ошибка. В следующем примере компилятор не смотрит вперед за идентификатором, чтобы увидеть, является ли следующий токен a &lt;code&gt;)&lt;/code&gt; , даже если это позволило бы ему однозначно проанализировать вызов:</target>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="translated">Когда выражение места оценивается в контексте выражения значения или связано значением в шаблоне, оно обозначает значение, хранящееся &lt;em&gt;в&lt;/em&gt; этой ячейке памяти. Если тип этого значения реализует &lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , то значение будет скопировано. В остальных ситуациях, если этот тип имеет &lt;a href=&quot;special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; , тогда можно будет переместить значение. Только следующие выражения места могут быть перемещены из:</target>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="translated">Когда программист достаточно уверен, что последовательность потенциально небезопасных операций действительно безопасна, он может инкапсулировать эту последовательность (взятую в целом) в &lt;code&gt;unsafe&lt;/code&gt; блок. Компилятор будет считать использование такого кода безопасным в окружающем контексте.</target>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="translated">При выходе из стека все его локальные распределения освобождаются,а ссылки на боксы сбрасываются.</target>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="translated">Однако, когда создается выражение временного значения, которое назначается &lt;a href=&quot;statements#let-statements&quot;&gt;объявлению &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; , временное создается с временем жизни включающего блока, поскольку использование включающего &lt;a href=&quot;statements#let-statements&quot;&gt;объявления &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; будет гарантированной ошибкой (поскольку указатель на временное значение будет будут сохранены в переменной, но временное будет освобождено до того, как переменную можно будет использовать). Компилятор использует простые синтаксические правила, чтобы решить, какие значения присваиваются привязке &lt;code&gt;let&lt;/code&gt; и, следовательно, заслуживают более длительного временного времени жизни.</target>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="translated">Если инструмент не используется,атрибуты инструмента принимаются без предупреждения.Когда инструмент используется,он отвечает за обработку и интерпретацию своих атрибутов.</target>
        </trans-unit>
        <trans-unit id="57dd9a0351b44496fecb16d4596f4a8247328e39" translate="yes" xml:space="preserve">
          <source>When a trait object is used as a type argument of a generic type, Rust will try to infer its lifetime if unspecified. However, this isn't possible when the containing type has more than one lifetime bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed6434b244126fa9e52f60dea8a8d6ab8918d34" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; does not take any argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746134148fbdc4bec37479d1ea67a6352b384088" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt; as argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa395a4e08ef9a2a05a0ac466a281cf522ff2172" translate="yes" xml:space="preserve">
          <source>When a union is dropped, it cannot know which of its fields needs to be dropped. For this reason, all union fields must either be of a &lt;code&gt;Copy&lt;/code&gt; type or of the shape &lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/a&gt;. This ensures that a union does not need to drop anything when it goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="translated">Когда пользователь вызывает &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt; , карта будет искать ключ, а затем выдает вариант перечисления &lt;code&gt;Entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="translated">Когда значение выходит за пределы области видимости, у него &lt;code&gt;drop&lt;/code&gt; метод drop, если его тип реализует &lt;code&gt;Drop&lt;/code&gt; . Тогда любые поля, содержащиеся в значении, также будут рекурсивно отброшены.</target>
        </trans-unit>
        <trans-unit id="d7ba61b38031de6106df804542ee455b8b72fed7" translate="yes" xml:space="preserve">
          <source>When a value is no longer needed, Rust will run a &quot;destructor&quot; on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we're going to focus on scope for the examples here. To learn about some of those other cases, please see &lt;a href=&quot;../../reference/destructors&quot;&gt;the reference&lt;/a&gt; section on destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="translated">Когда переменная неизменна, после привязки значения к имени вы не можете изменить это значение. Чтобы проиллюстрировать это, давайте сгенерируем новый проект под названием &lt;em&gt;переменные&lt;/em&gt; в каталоге ваших &lt;em&gt;проектов&lt;/em&gt; , используя &lt;code&gt;cargo new variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">Когда &lt;a href=&quot;glossary#initialized&quot;&gt;инициализированная &lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;переменная&lt;/a&gt; в Rust выходит за пределы области видимости или &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;временная &lt;/a&gt;переменная больше не нужна , запускается ее &lt;em&gt;деструктор&lt;/em&gt; . &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Присваивание&lt;/a&gt; также запускает деструктор своего левого операнда, если это не инициализированная переменная. Если переменная &lt;a href=&quot;types/struct&quot;&gt;структуры&lt;/a&gt; была частично инициализирована, удаляются только ее инициализированные поля.</target>
        </trans-unit>
        <trans-unit id="a5a59a643bd12cd60c0f839e9c5140aa3d6d2e23" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; or &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt; goes out of &lt;a href=&quot;#drop-scopes&quot;&gt;scope&lt;/a&gt; its &lt;em&gt;destructor&lt;/em&gt; is run, or it is &lt;em&gt;dropped&lt;/em&gt;. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, if it's initialized. If a variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">Когда экземпляр &lt;code&gt;ChildStderr&lt;/code&gt; будет &lt;a href=&quot;../ops/trait.drop&quot;&gt;упал&lt;/a&gt; , в &lt;code&gt;ChildStderr&lt;/code&gt; базовый дескриптор ФАЙЛА будет закрыт.</target>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="translated">Когда экземпляр &lt;code&gt;ChildStdin&lt;/code&gt; будет &lt;a href=&quot;../ops/trait.drop&quot;&gt;упал&lt;/a&gt; , в &lt;code&gt;ChildStdin&lt;/code&gt; базовый дескриптор ФАЙЛА будет закрыт. Если дочерний процесс был заблокирован при вводе до того, как был отброшен, он станет разблокированным после удаления.</target>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">Когда экземпляр &lt;code&gt;ChildStdout&lt;/code&gt; будет &lt;a href=&quot;../ops/trait.drop&quot;&gt;упал&lt;/a&gt; , в &lt;code&gt;ChildStdout&lt;/code&gt; базовый дескриптор ФАЙЛА будет закрыт.</target>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="translated">При аннотировании срока службы в функциях аннотации идут в сигнатуре функции,а не в теле функции.Ржавчина может анализировать код внутри функции без всякой помощи.Однако,когда функция имеет ссылки на код или из кода вне этой функции,для Руста становится практически невозможным самостоятельно вычислить время жизни параметров или вернуть значения.Сроки жизни могут отличаться каждый раз при вызове функции.Поэтому необходимо аннотировать время жизни вручную.</target>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="translated">В ожидании большого притока элементов можно использовать &lt;code&gt;reserve&lt;/code&gt; семейство методов, чтобы указать коллекции, сколько места она должна оставить для следующих элементов. Как и &lt;code&gt;with_capacity&lt;/code&gt; , точное поведение этих методов будет зависеть от интересующей коллекции.</target>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда это применимо, предпочтительнее нестабильная сортировка, поскольку она обычно быстрее, чем стабильная сортировка, и не выделяет вспомогательную память. См. &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда это применимо, предпочтительнее нестабильная сортировка, поскольку она обычно быстрее, чем стабильная сортировка, и не выделяет вспомогательную память. См. &lt;a href=&quot;#method.sort_unstable_by&quot;&gt; &lt;code&gt;sort_unstable_by&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда это применимо, предпочтительнее нестабильная сортировка, поскольку она обычно быстрее, чем стабильная сортировка, и не выделяет вспомогательную память. См. &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt; &lt;code&gt;sort_unstable_by_key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9457ac5b05fa1acc97622737a2e6a54db8e47e30" translate="yes" xml:space="preserve">
          <source>When applied to a function in an &lt;code&gt;extern&lt;/code&gt; block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an &lt;code&gt;extern&lt;/code&gt; block, the declaration in the &lt;code&gt;extern&lt;/code&gt; block must also have the attribute, otherwise undefined behavior results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">При применении к значениям типа &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; он распространяет &lt;code&gt;None&lt;/code&gt; s. Если значение равно &lt;code&gt;None&lt;/code&gt; , оно вернет &lt;code&gt;None&lt;/code&gt; . Если применить к &lt;code&gt;Some(x)&lt;/code&gt; , то значение будет развернуто для вычисления &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">При применении к значениям типа &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; он распространяет ошибки. Если значение равно &lt;code&gt;Err(e)&lt;/code&gt; , то оно вернет &lt;code&gt;Err(From::from(e))&lt;/code&gt; из включающей функции или замыкания. Если применить к &lt;code&gt;Ok(x)&lt;/code&gt; , то значение будет развернуто для вычисления &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="translated">При применении внутри ящика последующие пользователи ящика должны будут использовать шаблон &lt;code&gt;_&lt;/code&gt; при сопоставлении перечислений и использовать шаблон &lt;code&gt;..&lt;/code&gt; при сопоставлении структур. Нижние ящики не могут соответствовать неполным вариантам перечисления.</target>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="translated">Когда эти предупреждения превратятся в ошибки?</target>
        </trans-unit>
        <trans-unit id="93dc9e73dc6c00708f0214c1f73e691c8c3e8698" translate="yes" xml:space="preserve">
          <source>When associated with &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop. This is only valid with &lt;code&gt;loop&lt;/code&gt; and not with any other type of loop. If no value is specified, &lt;code&gt;break;&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt;. Every &lt;code&gt;break&lt;/code&gt; within a loop must return the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="translated">Когда оно связано с &lt;code&gt;loop&lt;/code&gt; , выражение прерывания может использоваться для возврата значения из этого цикла через одну из форм &lt;code&gt;break EXPR&lt;/code&gt; или &lt;code&gt;break 'label EXPR&lt;/code&gt; , где &lt;code&gt;EXPR&lt;/code&gt; - это выражение, результат которого возвращается из &lt;code&gt;loop&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="4a763dfd452f118669800efdde464c1dbe786ee4" translate="yes" xml:space="preserve">
          <source>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">При вызове &lt;code&gt;product()&lt;/code&gt; и возвращении примитивного целочисленного типа метод вызовет панику, если вычисление переполнится и будут включены утверждения отладки.</target>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">Когда вызывается &lt;code&gt;sum()&lt;/code&gt; и возвращается примитивный целочисленный тип, этот метод вызывает панику, если вычисление переполняется и отладочные утверждения включены.</target>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="translated">При вызове методов с одинаковыми именами вам необходимо указать Rust, какой из них вы хотите использовать. Рассмотрим код в листинге 19-16, где мы определили две черты, &lt;code&gt;Pilot&lt;/code&gt; и &lt;code&gt;Wizard&lt;/code&gt; , у которых есть метод &lt;code&gt;fly&lt;/code&gt; . Затем мы реализуем обе черты для типа &lt;code&gt;Human&lt;/code&gt; , для которого уже реализован метод с именем &lt;code&gt;fly&lt;/code&gt; . Каждый метод &lt;code&gt;fly&lt;/code&gt; делает что-то свое.</target>
        </trans-unit>
        <trans-unit id="09c7e5de85184f1e292948f95737d163821f3f97" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that &lt;em&gt;either&lt;/em&gt; the pointer is NULL &lt;em&gt;or&lt;/em&gt; all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5922155f29f105357a025f039108b9a7d5336187" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">При вызове этого метода, вы должны убедиться , что , если указатель не NULL, то он правильно выровнены, разыменовываемыми (для всего размера &lt;code&gt;T&lt;/code&gt; ) и указывает на инициализированную экземпляр &lt;code&gt;T&lt;/code&gt; . Это применимо, даже если результат этого метода не используется! (Часть инициализации еще не окончательно решена, но пока это единственный безопасный подход - убедиться, что они действительно инициализированы.)</target>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">При вызове этого метода, вы должны убедиться , что , если указатель не NULL, то он правильно выровнены, разыменовываемыми (для всего размера &lt;code&gt;T&lt;/code&gt; ) и указывает на инициализированную экземпляр &lt;code&gt;T&lt;/code&gt; . Это применимо, даже если результат этого метода не используется! (Часть, касающаяся инициализации, еще не решена полностью, но пока это не произойдет, единственный безопасный подход - убедиться, что они действительно инициализированы.)</target>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">Когда мой шрифт можно будет &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="translated">При розыгрыше учитывайте,что только примитивные типы могут быть вложены друг в друга.Пример:</target>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="translated">При сравнении указателей они сравниваются по их адресу, а не по тому, на что они указывают. При сравнении указателей с &lt;a href=&quot;../dynamically-sized-types&quot;&gt;типами&lt;/a&gt; с динамическим размером они также сравнивают свои дополнительные данные.</target>
        </trans-unit>
        <trans-unit id="f2f745dfedc8e3dcf7cd93386db2954df66d81dc" translate="yes" xml:space="preserve">
          <source>When comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their additional data compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="translated">Когда сравнение невозможно:</target>
        </trans-unit>
        <trans-unit id="09f829ddc19ecb8dff523da8b6aa0bd5c5c69a9a" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">В сочетании с загрузкой, если загруженное значение было записано операцией сохранения с упорядочением &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; (или более сильным), то все последующие операции упорядочиваются после этого сохранения. В частности, все последующие загрузки будут видеть данные, записанные до сохранения.</target>
        </trans-unit>
        <trans-unit id="c91753b6ff7ee275cf69a5dce0e73e0bd2e33946" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">В сочетании с магазином все предыдущие операции становятся упорядоченными до любой загрузки этого значения с упорядочением &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (или более сильным). В частности, все предыдущие записи становятся видимыми для всех потоков, выполняющих загрузку &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (или более сильную) этого значения.</target>
        </trans-unit>
        <trans-unit id="c5257416252adc45097a1b4beca1249797335afe" translate="yes" xml:space="preserve">
          <source>When created, cursors start at the front of the list, or the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="translated">При создании неизменяемых и изменяемых ссылок мы используем синтаксис &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;&amp;amp;mut&lt;/code&gt; соответственно. В &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; мы используем методы &lt;code&gt;borrow&lt;/code&gt; и &lt;code&gt;borrow_mut&lt;/code&gt; , которые являются частью безопасного API, принадлежащего &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . Метод &lt;code&gt;borrow&lt;/code&gt; возвращает тип умного указателя &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; , а &lt;code&gt;borrow_mut&lt;/code&gt; возвращает тип умного указателя &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; . Оба типа реализуют &lt;code&gt;Deref&lt;/code&gt; , поэтому мы можем рассматривать их как обычные ссылки.</target>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="translated">При создании процедурных макросов определения должны находиться в отдельном ящике со специальным типом ящика. Это вызвано сложными техническими причинами, которые мы надеемся устранить в будущем. Использование процедурных макросов похоже на код в Листинге 19-29, где &lt;code&gt;some_attribute&lt;/code&gt; является заполнителем для использования определенного макроса.</target>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="translated">При определении функции,использующей дженерики,мы помещаем дженерики в сигнатуру функции,где обычно указываем типы данных параметров и возвращаемое значение.Это делает наш код более гибким и предоставляет больше функциональности вызывателям нашей функции,предотвращая при этом дублирование кода.</target>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">При определении рекурсивной структуры или перечисления любое использование типа, определяемого внутри определения, должно происходить за указателем (например, &lt;code&gt;Box&lt;/code&gt; или &lt;code&gt;&amp;amp;&lt;/code&gt; ). Это связано с тем, что структуры и перечисления должны иметь четко определенный размер, а без указателя размер типа должен быть неограниченным.</target>
        </trans-unit>
        <trans-unit id="54e2930486f06054c79b2d368c2769ebefeaab63" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="translated">При получении от структур &lt;code&gt;PartialOrd&lt;/code&gt; сравнивает два экземпляра, сравнивая значение в каждом поле в том порядке, в котором поля появляются в определении структуры. При получении из перечислений варианты перечисления, объявленные ранее в определении перечисления, считаются меньшими, чем варианты, перечисленные позже.</target>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="translated">Когда этот разъем включен,он может отправлять пакеты на широковещательный адрес.</target>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="translated">При оценке блочного выражения каждый оператор,за исключением операторов объявления элементов,выполняется последовательно.Затем выполняется последнее выражение,если оно задано.</target>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="translated">При пересылке совпадающего фрагмента в другой макрос по примеру сопоставители во втором макросе увидят непрозрачный AST типа фрагмента. Второй макрос не может использовать буквальные токены для сопоставления фрагментов в сопоставлении, только спецификатор фрагмента того же типа. В &lt;code&gt;ident&lt;/code&gt; , &lt;code&gt;lifetime&lt;/code&gt; , и &lt;code&gt;tt&lt;/code&gt; типа фрагмента является исключением, и &lt;em&gt;может&lt;/em&gt; быть сопоставлен с помощью литералов маркеров. Следующее иллюстрирует это ограничение:</target>
        </trans-unit>
        <trans-unit id="9aca28029ce8b3b95a609b5e4ca6542143135bed" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="translated">При реализации комбинатора &lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; обычно требуется структурное закрепление вложенных фьючерсов, так как вам нужно получить закрепленные ссылки на них для вызова &lt;code&gt;poll&lt;/code&gt; . Но если ваш комбинатор содержит какие-либо другие данные, которые не нужно закреплять, вы можете сделать эти поля не структурными и, следовательно, свободно обращаться к ним с изменяемой ссылкой, даже если у вас просто &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (например, в вашей собственной реализации &lt;code&gt;poll&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3023d431ee0ca325e5e6237d2618e2a98462263f" translate="yes" xml:space="preserve">
          <source>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="translated">При реализации черты формата для своего типа,необходимо будет реализовать метод подписи:</target>
        </trans-unit>
        <trans-unit id="f71a495d94aa8ee98863b069031787f4cf122fc5" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">При реализации &lt;code&gt;ExactSizeIterator&lt;/code&gt; необходимо также реализовать &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . При этом реализация &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;&lt;em&gt; должна&lt;/em&gt; возвращать точный размер итератора.</target>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="translated">При реализации &lt;code&gt;Hash&lt;/code&gt; и &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; важно, чтобы выполнялось следующее свойство:</target>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="translated">При реализации этого трейта для &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; нам нужно выбрать тип для &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . И поскольку преобразование строки в строку никогда не приведет к ошибке, подходящий тип - &lt;code&gt;!&lt;/code&gt; . (В настоящее время фактически используется тип перечисления без вариантов, хотя это только потому, что &lt;code&gt;!&lt;/code&gt; Был добавлен в Rust позже и может измениться в будущем.) С типом &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; &lt;code&gt;!&lt;/code&gt; , если по какой-то причине нам нужно вызвать &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;String::from_str&lt;/code&gt; &lt;/a&gt; результатом будет &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt; &lt;/a&gt; который мы можем распаковать следующим образом:</target>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="translated">При инициализации &lt;code&gt;Slice&lt;/code&gt; вы просто &lt;code&gt;PhantomData&lt;/code&gt; значение PhantomData для &lt;code&gt;phantom&lt;/code&gt; поля :</target>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="translated">При инициализации структуры данных (struct, enum, union) с именованными (но не пронумерованными) полями разрешается писать &lt;code&gt;fieldname&lt;/code&gt; как сокращение для &lt;code&gt;fieldname: fieldname&lt;/code&gt; . Это позволяет использовать компактный синтаксис с меньшим количеством дублирования. Например:</target>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="translated">При вызове замыканий или других реализаций признаков функции &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; или &lt;code&gt;FnOnce&lt;/code&gt; с использованием нотации вызова количество параметров, переданных функции, должно соответствовать ее определению.</target>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="translated">При поиске реализации для признака компилятор находит как &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; где T - все типы, так и &lt;code&gt;impl MyTrait for Foo&lt;/code&gt; . Так как признак не может быть реализован несколько раз, это ошибка. Итак, когда вы пишете:</target>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="translated">При поиске вызова метода,приемник может быть автоматически разыменован или заимствован для вызова метода.Это требует более сложного процесса поиска,чем для других функций,так как может быть несколько возможных методов для вызова.Используется следующая процедура:</target>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="translated">При совпадении с диапазоном компилятор проверяет,что диапазон не пуст.Шаблоны диапазона включают обе конечные точки,поэтому это эквивалентно требованию,чтобы начало диапазона было меньше или равно концу диапазона.</target>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="translated">При совпадении с эксклюзивным диапазоном компилятор проверяет,что диапазон не пуст.Шаблоны эксклюзивного диапазона включают в себя начальную точку,но не конечную точку,поэтому это эквивалентно требованию,чтобы начало диапазона было меньше конца диапазона.</target>
        </trans-unit>
        <trans-unit id="b0e0c88f0138777df9f95477c6fa805a498782e3" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="translated">При совпадении по переменной она не может быть мутирована в матчевых сторожах,так как это может привести к тому,что матч будет неисчерпывающим:</target>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="translated">При названии ящиков Rust дефисы запрещены. Однако грузовые пакеты могут их использовать. В таком случае, когда &lt;code&gt;Cargo.toml&lt;/code&gt; не указывает имя ящика, Cargo прозрачно заменяет &lt;code&gt;-&lt;/code&gt; на &lt;code&gt;_&lt;/code&gt; ( более подробную информацию см. В &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="translated">Когда задействован только один поток, результаты ожидаемые: печатается строка &lt;code&gt;7 4 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">При работе в консоли Windows реализация этого потока не поддерживает неUTF-8 байтовых последовательностей.Попытка чтения недействительных байтов UTF-8 вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">При работе в консоли Windows реализация этого потока не поддерживает неUTF-8 байтовых последовательностей.Попытка записи недействительных байтов UTF-8 вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="translated">При разборе пути происходит небольшая нормализация:</target>
        </trans-unit>
        <trans-unit id="de65f313906013336610f9ce397839cdfeef65dc" translate="yes" xml:space="preserve">
          <source>When pattern matching on a non-exhaustive &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;, matching on a variant does not contribute towards the exhaustiveness of the arms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9f5f5346d0d53afbe7e6c96b99054e854e83d4" translate="yes" xml:space="preserve">
          <source>When pattern matching on a non-exhaustive variant (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; variant&lt;/a&gt;), a &lt;a href=&quot;../patterns#struct-patterns&quot;&gt;&lt;em&gt;StructPattern&lt;/em&gt;&lt;/a&gt; must be used which must include a &lt;code&gt;..&lt;/code&gt;. Tuple variant constructor visibility is lowered to &lt;code&gt;min($vis, pub(crate))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="translated">При реэкспорте частного элемента можно подумать,что он допускает короткое замыкание &quot;цепочки конфиденциальности&quot; через реэкспорт вместо того,чтобы проходить через иерархию пространств имён,как это обычно бывает.</target>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="translated">При упоминании ими, &lt;em&gt;функция&lt;/em&gt; дает первоклассного &lt;em&gt;значение&lt;/em&gt; соответствующего нулевого размера &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;типа функции элемента&lt;/em&gt;&lt;/a&gt; , который при вызове принимает значение непосредственного вызова функции.</target>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="translated">При обращении к функциональному элементу или конструктору кортежной структуры или варианта перечисления возвращается значение нулевого размера для своего &lt;em&gt;типа функционального элемента&lt;/em&gt; . Этот тип явно идентифицирует функцию - ее имя, ее аргументы типа и ее аргументы времени жизни с ранней привязкой (но не аргументы времени жизни с поздней привязкой, которые назначаются только при вызове функции), поэтому значение не обязательно должно содержать фактический указатель на функцию, и при вызове функции косвенное обращение не требуется.</target>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="translated">Когда речь идет о повторах,то правила применяются к каждому возможному количеству расширений с учетом разделителей.Это означает:</target>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="translated">Запрашивая отформатировать аргумент определенным типом, вы фактически запрашиваете, чтобы аргумент приписывался определенной характеристике. Это позволяет форматировать несколько фактических типов через &lt;code&gt;{:x}&lt;/code&gt; (как &lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; ,&lt;/a&gt; так и &lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; ). Текущее отображение типов в черты:</target>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="translated">Когда возвращаемое значение переполняется (например, &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; для типа &lt;code&gt;uN&lt;/code&gt; ), происходит паника в режиме отладки, а возвращаемое значение обертывается в 0 в режиме выпуска (единственная ситуация, в которой метод может возвращать 0) .</target>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="translated">Когда возвращаемое значение переполняется (например, &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; для типа &lt;code&gt;uN&lt;/code&gt; ), переполняется до &lt;code&gt;2^N = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="translated">При возврате ссылки из функции параметр времени жизни для возвращаемого типа должен соответствовать параметру времени жизни одного из параметров. Если возвращаемая ссылка &lt;em&gt;не&lt;/em&gt; относится к одному из параметров, она должна относиться к значению, созданному в этой функции, которая будет висящей ссылкой, поскольку значение выйдет за пределы области видимости в конце функции. Рассмотрим эту попытку реализации самой &lt;code&gt;longest&lt;/code&gt; функции, которая не компилируется:</target>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="translated">При запуске кода в Листинге 16-10 между каждой строкой должен отображаться следующий вывод с паузой в 1 секунду:</target>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="translated">Однако при поиске значения на карте необходимость предоставления ссылки на &lt;code&gt;K&lt;/code&gt; в качестве ключа для поиска потребует всегда создавать такое собственное значение. Для строковых ключей, это означало бы &lt;code&gt;String&lt;/code&gt; значение должно быть создано только для поиска тех случаев , когда только &lt;code&gt;str&lt;/code&gt; доступно.</target>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="translated">Когда следует использовать &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="translated">Если начинать с фрагмента,а не с массива,можно использовать неаккуратные API преобразования:</target>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="translated">Когда такая строка &lt;code&gt;monospace&lt;/code&gt; шрифтом встречается внутри грамматики, это неявная ссылка на один член такой продукции таблицы строк. См. &lt;a href=&quot;tokens&quot;&gt;Токены&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="a52c1f9d28a81019545579685f71cebe8cd39993" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; on the same stream can cause data loss. Reading from the underlying reader after unwrapping the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt;&lt;code&gt;BufReader::into_inner&lt;/code&gt;&lt;/a&gt; can also cause data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="translated">Когда &lt;code&gt;BufReader&lt;/code&gt; отбрасывается, содержимое его буфера удаляется. Создание нескольких экземпляров &lt;code&gt;BufReader&lt;/code&gt; в одном потоке может привести к потере данных.</target>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="translated">Когда &lt;code&gt;BufWriter&lt;/code&gt; отбрасывается, содержимое его буфера будет записано. Однако любые ошибки, возникающие в процессе очистки буфера при отбрасывании модуля записи, игнорируются. Код, который хочет обрабатывать такие ошибки, должен вручную вызвать &lt;a href=&quot;#method.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; до того, как модуль записи будет удален.</target>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="translated">Когда свойство &lt;code&gt;Deref&lt;/code&gt; определено для задействованных типов, Rust проанализирует типы и использует &lt;code&gt;Deref::deref&lt;/code&gt; столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра. Количество раз, &lt;code&gt;Deref::deref&lt;/code&gt; необходимо вставить Deref :: deref, определяется во время компиляции, поэтому нет никаких штрафов во время выполнения за использование преимущества принуждения deref!</target>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="translated">Когда методу &lt;code&gt;get&lt;/code&gt; передается индекс, который находится за пределами вектора, он без паники возвращает &lt;code&gt;None&lt;/code&gt; . Вы могли бы использовать этот метод, если доступ к элементу за пределами диапазона вектора происходит иногда при нормальных обстоятельствах. Тогда ваш код будет иметь логику для обработки наличия &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; или &lt;code&gt;None&lt;/code&gt; , как обсуждалось в главе 6. Например, индекс может исходить от человека, вводящего число. Если они случайно введут слишком большое число, и программа получит значение &amp;laquo; &lt;code&gt;None&lt;/code&gt; , вы можете сообщить пользователю, сколько элементов находится в текущем векторе, и дать ему еще один шанс ввести допустимое значение. Это было бы удобнее, чем сбой программы из-за опечатки!</target>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="translated">Когда &lt;code&gt;match&lt;/code&gt; выражение выполняет, он сравнивает полученное значение с шаблоном каждой руки, в порядке. Если шаблон соответствует значению, выполняется код, связанный с этим шаблоном. Если этот шаблон не соответствует значению, выполнение продолжается до следующего плеча, как в машине для сортировки монет. У нас может быть столько рук, сколько нам нужно: в листинге 6-3 у нашего &lt;code&gt;match&lt;/code&gt; четыре руки.</target>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;match&lt;/code&gt; выражение будет сделано, его концы области видимости, и так же объем внутреннего &lt;code&gt;y&lt;/code&gt; . Последний &lt;code&gt;println!&lt;/code&gt; производит &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="translated">Когда связанная функция объявляется в трейте, функция также может быть вызвана с &lt;a href=&quot;../paths&quot;&gt;путем,&lt;/a&gt; который представляет собой путь к трейту, добавленному именем трейта. Когда это происходит, он заменяется на &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="translated">Когда вызывающему коду требуется результат оценки закрытия, вместо прямого вызова закрытия он вызовет метод &lt;code&gt;value&lt;/code&gt; . Этот метод проверяет, есть ли у нас уже полученное значение в &lt;code&gt;self.value&lt;/code&gt; в &lt;code&gt;Some&lt;/code&gt; ; если мы это сделаем, он вернет значение в &lt;code&gt;Some&lt;/code&gt; , не выполняя повторное закрытие.</target>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">Когда командная строка синтаксический логика начинает получать сложно, извлечь его из &lt;em&gt;main.rs&lt;/em&gt; и переместить его в &lt;em&gt;lib.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="translated">Когда предикат конфигурации истинен, этот атрибут расширяется до атрибутов, перечисленных после предиката. Например, следующий модуль будет найден в &lt;code&gt;linux.rs&lt;/code&gt; или &lt;code&gt;windows.rs&lt;/code&gt; в зависимости от цели.</target>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="translated">Когда проект готов,испрашивается пересмотр должности.</target>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="translated">Когда пустая строка используется в качестве разделителя,она разделяет каждый символ в строке вместе с началом и концом строки.</target>
        </trans-unit>
        <trans-unit id="8391463b3513744ada63d41c0e15df2b575fc578" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;../fs/struct.file#method.open&quot;&gt;&lt;code&gt;fs::File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt;&lt;code&gt;fs::OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b88e35933dd499afe9dc518b98a0ae7b4608c2" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="translated">Когда внутренняя область видимости заканчивается, &lt;code&gt;branch&lt;/code&gt; выходит за пределы области видимости, и строгий счетчик &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; уменьшается до 0, поэтому его &lt;code&gt;Node&lt;/code&gt; удаляется. Слабый счет 1 из &lt;code&gt;leaf.parent&lt;/code&gt; не влияет на то, будет ли &lt;code&gt;Node&lt;/code&gt; удален , поэтому мы не получаем никаких утечек памяти!</target>
        </trans-unit>
        <trans-unit id="92e09a21380ea98a48f9618974476f27f710a28e" translate="yes" xml:space="preserve">
          <source>When the iterator &lt;strong&gt;is&lt;/strong&gt; dropped, all elements in the range are removed from the vector, even if the iterator was not fully consumed. If the iterator &lt;strong&gt;is not&lt;/strong&gt; dropped (with &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; for example), it is unspecified how many elements are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="translated">Когда логика, которая должна выполняться для значения, более сложна, мы можем просто использовать API &lt;code&gt;entry&lt;/code&gt; чтобы гарантировать, что значение инициализировано, и выполнить логику впоследствии.</target>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="translated">Когда основной поток программы Rust завершает свою работу,вся программа выключается,даже если другие потоки все еще выполняются.Тем не менее,этот модуль предоставляет удобные возможности для автоматического ожидания завершения работы дочернего потока (т.е.присоединения).</target>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="translated">Когда владелец выходит из-под контроля,значение опускается.</target>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="translated">Когда шаблон не совпадает:</target>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="translated">Когда шаблон соответствует успешно, выражение защиты шаблона выполняется. Если выражение истинно, образец успешно сопоставлен. В противном случае следующий шаблон, включая другие совпадения с &lt;code&gt;|&lt;/code&gt; оператор в той же руке, проходит тестирование.</target>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="translated">Когда должность одобряется,она публикуется.</target>
        </trans-unit>
        <trans-unit id="41bc650167a3c0cb28cbdf2fe35163fe7bda095c" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work if we also try to refer to that element later in the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="translated">Когда в программе есть действительная ссылка, средство проверки заимствований применяет правила владения и заимствования (описанные в главе 4), чтобы гарантировать, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, согласно которому у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило применяется в листинге 8-7, где мы храним неизменяемую ссылку на первый элемент вектора и пытаемся добавить элемент в конец, что не сработает.</target>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="translated">Когда программист включил &lt;code&gt;debug_assert!&lt;/code&gt; утверждения (например, путем включения неоптимизированной сборки), реализации должны вставлять динамические проверки, которые &lt;code&gt;panic&lt;/code&gt; при переполнении. Другие виды сборок могут привести к &lt;code&gt;panics&lt;/code&gt; или скрытым значениям при переполнении, на усмотрение реализации.</target>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="translated">Когда выражение scrutinee является выражением &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;места&lt;/a&gt; , совпадение не выделяет временное местоположение; однако привязка по значению может копировать или перемещаться из области памяти. По возможности предпочтительнее сопоставлять выражения места, поскольку время жизни этих совпадений наследует время жизни выражения места, а не ограничивается внутренней частью сопоставления.</target>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="translated">Когда ломтик линзы делится не равномерно по размеру куска,последним кусочком итерации будет оставшийся кусочек.</target>
        </trans-unit>
        <trans-unit id="28062354592a563db8e797c18e0e70b8ef604bb5" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.arraychunks#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0fda08da1d4cf85762ce95953612e1248e0072" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.arraychunksmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">Если длина фрагмента не делится поровну по размеру фрагмента, последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены, но могут быть получены из функции &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; от итератора.</target>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">Когда длина фрагмента не делится поровну по размеру фрагмента, последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены, но могут быть извлечены функцией &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt; из итератора.</target>
        </trans-unit>
        <trans-unit id="c18714384f2b643a8c87f83e941ef77f216c1e30" translate="yes" xml:space="preserve">
          <source>When the source is an owning iterator struct (commonly called &lt;code&gt;IntoIter&lt;/code&gt;) then this can be useful for specializing &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; implementations or recovering the remaining elements after an iterator has been partially exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Если конечная точка с запятой опущена, результатом должен быть type &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="translated">Когда вектор удаляется, все его содержимое также удаляется, что означает, что целые числа, которые он содержит, будут очищены. Это может показаться очевидным, но может стать немного сложнее, когда вы начнете вводить ссылки на элементы вектора. Давайте займемся этим дальше!</target>
        </trans-unit>
        <trans-unit id="d759cfed67550956f3c467a9677f59d40c90a085" translate="yes" xml:space="preserve">
          <source>When there isn't a &lt;code&gt;Self: Sized&lt;/code&gt; bound on a method, the type of a method receiver must be one of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="translated">Когда это закрытие выполняется,такие аспекты,как дескрипторы stdio файлов и рабочая директория были успешно изменены,поэтому вывод в эти места может не появиться там,где это было задумано.</target>
        </trans-unit>
        <trans-unit id="ad7769a3800701a3a043ec20084e499702706111" translate="yes" xml:space="preserve">
          <source>When this function is used during const evaluation, it may return &lt;code&gt;false&lt;/code&gt; for pointers that turn out to be null at runtime. Specifically, when a pointer to some memory is offset beyond its bounds in such a way that the resulting pointer is null, the function will still return &lt;code&gt;false&lt;/code&gt;. There is no way for CTFE to know the absolute position of that memory, so we cannot tell if the pointer is null or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="translated">Когда эта функция возвращается,гарантируется,что некоторая инициализация выполнена и завершена (это может быть не указанное закрытие).Гарантируется также,что любая запись в память,осуществленная при закрытии,может быть надежно замечена другими потоками в этот момент (существует существовавшая до этого связь между закрытием и кодом,выполняющимся после возврата).</target>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="translated">Когда этот метод был вызван, &lt;code&gt;self&lt;/code&gt; еще не был освобожден. Это происходит только после завершения метода. Если бы это было не так, &lt;code&gt;self&lt;/code&gt; был бы висящей ссылкой.</target>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="translated">Когда эта программа выполняется, она по очереди проверяет каждое выражение &lt;code&gt;if&lt;/code&gt; и выполняет первое тело, для которого выполняется условие. Обратите внимание, что хотя 6 делится на 2, мы не видим, что выходное &lt;code&gt;number is divisible by 2&lt;/code&gt; , и мы не видим, что &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; текста из блока &lt;code&gt;else&lt;/code&gt; . Это потому, что Rust выполняет блок только для первого истинного условия, и как только он его находит, он даже не проверяет остальные.</target>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="translated">Когда использовать Небезопасный код</target>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="translated">Когда выбирать интерьерную мутацию</target>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="translated">При попытке заставить какой-либо тип реализовывать черту &lt;code&gt;Foo&lt;/code&gt; , вы должны, как минимум, предоставить реализации для всех требуемых методов &lt;code&gt;Foo&lt;/code&gt; (то есть методов, которые не имеют реализации по умолчанию), а также любых необходимых элементов черт, таких как связанные типы или константы. Пример:</target>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">При использовании в качестве &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;индекса нарезки&lt;/a&gt; , &lt;code&gt;RangeTo&lt;/code&gt; производит срез всех элементов массива до того , как индекс указанного &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">При использовании в качестве &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;индекса нарезки&lt;/a&gt; , &lt;code&gt;RangeToInclusive&lt;/code&gt; производит срез всех элементов массива вплоть до индекса , указанного &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="translated">При использовании в качестве элемента или оператора форма &lt;em&gt;MacroInvocationSemi&lt;/em&gt; используется, где точка с запятой требуется в конце, если не используются фигурные скобки. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Квалификаторы видимости&lt;/a&gt; никогда не допускаются до вызова макроса или определения &lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;macro_rules&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="translated">При использовании на &lt;a href=&quot;../items/traits&quot;&gt;декларацию признака&lt;/a&gt; , в &lt;a href=&quot;../expressions/call-expr&quot;&gt;выражении вызова&lt;/a&gt; в качестве &lt;a href=&quot;../statements#expression-statements&quot;&gt;выражения заявления&lt;/a&gt; к функции , которая возвращает &lt;a href=&quot;../types/impl-trait&quot;&gt;осущий черт&lt;/a&gt; этого признака нарушает &lt;code&gt;unused_must_use&lt;/code&gt; ворс.</target>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="translated">При использовании на функции в объявлении трейта поведение также применяется,когда выражение вызова является функцией из реализации трейта.</target>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="translated">При использовании на функции в реализации признака,атрибут ничего не делает.</target>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">При использовании в функции, если &lt;a href=&quot;../expressions&quot;&gt;выражение&lt;/a&gt; оператора &lt;a href=&quot;../statements#expression-statements&quot;&gt;выражения&lt;/a&gt; является &lt;a href=&quot;../expressions/call-expr&quot;&gt;выражением вызова&lt;/a&gt; этой функции, то lint &lt;code&gt;unused_must_use&lt;/code&gt; нарушается.</target>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">При использовании в определяемых пользователем составных типах, если &lt;a href=&quot;../expressions&quot;&gt;выражение&lt;/a&gt; оператора &lt;a href=&quot;../statements#expression-statements&quot;&gt;выражения&lt;/a&gt; имеет этот тип, lint &lt;code&gt;unused_must_use&lt;/code&gt; нарушается.</target>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="translated">При использовании с описателем альтернативного формата &lt;code&gt;#?&lt;/code&gt; , вывод выглядит красиво.</target>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="translated">При использовании &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; может случиться так, что некоторые из закрытых переменных небезопасны для размотки. Например, если захватывается &lt;code&gt;&amp;amp;mut T&lt;/code&gt; , компилятор выдаст предупреждение, указывающее, что это небезопасно для размотки. Однако может быть и не так, что это на самом деле проблема из-за конкретного использования &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; ,&lt;/a&gt; если специально учитывается безопасность размотки. Эта структура-оболочка полезна для быстрого и легкого аннотации, что переменная действительно безопасна для распаковки.</target>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="translated">При использовании future вы, как правило, не вызываете &lt;code&gt;poll&lt;/code&gt; напрямую, а вместо этого &lt;code&gt;.await&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="translated">При использовании в типе времени жизни, такого как &lt;code&gt;'a&lt;/code&gt; a, его необходимо объявить перед использованием.</target>
        </trans-unit>
        <trans-unit id="68d4836a866e67a5b4af384a8eb471ccacc77a13" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt; to a &lt;code&gt;static&lt;/code&gt;. The &lt;a href=&quot;destructors#drop-scopes&quot;&gt;drop scope&lt;/a&gt; of the temporary is usually the end of the enclosing statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="translated">При использовании выражения значения в большинстве контекстов выражения места создается временная безымянная ячейка памяти, инициализированная этим значением, и вместо этого выражение вычисляется в этом месте, за исключением случаев, когда повышается до &lt;code&gt;'static&lt;/code&gt; . Продвижение выражения значения в &lt;code&gt;'static&lt;/code&gt; слота происходит тогда , когда выражение может быть записано в виде константы, заимствованные и разыменование, одалживающей где выражение первоначально было написано, без изменения поведения во время выполнения. То есть продвинутое выражение может быть оценено во время компиляции, и результирующее значение не содержит &lt;a href=&quot;interior-mutability&quot;&gt;внутренней изменчивости&lt;/a&gt; или &lt;a href=&quot;destructors&quot;&gt;деструкторов&lt;/a&gt; (эти свойства определяются на основе значения, где это возможно, например, &lt;code&gt;&amp;amp;None&lt;/code&gt; всегда имеет тип &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt; , так как не содержит ничего запрещенного). В противном случае время жизни временных значений обычно составляет</target>
        </trans-unit>
        <trans-unit id="7387e6f07d50e4b94b03c5027eaa0a1074379c4f" translate="yes" xml:space="preserve">
          <source>When using an alias over a function type, you cannot e.g. denote a parameter as being mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">При использовании включающего диапазона для итерации значения &lt;a href=&quot;#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;end()&lt;/code&gt; указываются после завершения итерации. Чтобы определить, пуст ли включающий диапазон, используйте метод &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; вместо сравнения &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a518969d6cf8add6a83ea03a0b5649d4f43920f2" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">При использовании включающего диапазона для итерации значения &lt;code&gt;start()&lt;/code&gt; и &lt;a href=&quot;#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; указываются после завершения итерации. Чтобы определить, пуст ли включающий диапазон, используйте метод &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; вместо сравнения &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb0c63c5182e2af20d41eccf36aeeeb95780341" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="translated">При использовании генераторов (или асинхронных)все переменные типа должны быть привязаны таким образом,чтобы можно было построить генератор.</target>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="translated">При использовании итераторов вы часто объединяете несколько из них. Во время работы над таким кодом вы можете захотеть проверить, что происходит в различных частях конвейера. Для этого вставьте вызов &lt;code&gt;inspect()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="translated">При использовании атрибута &lt;code&gt;#[simd]&lt;/code&gt; в структуре кортежа все компоненты структуры кортежа должны быть конкретного, неуниверсального типа, чтобы компилятор мог решить, как использовать с ними SIMD. Эта ошибка возникает, если типы являются универсальными.</target>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="translated">При использовании атрибута &lt;code&gt;#[simd]&lt;/code&gt; в структуре кортежа элементы в кортеже должны быть машинного типа, чтобы к ним можно было применять операции SIMD.</target>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="translated">При использовании атрибута &lt;code&gt;#[simd]&lt;/code&gt; для автоматического использования операций SIMD в структуре кортежей все типы в структуре должны быть одного типа, иначе компилятор вызовет эту ошибку.</target>
        </trans-unit>
        <trans-unit id="8dd63b3b5f84a11f65877d582b3cb17771f94809" translate="yes" xml:space="preserve">
          <source>When using/declaring an item with generic arguments, you must provide the exact same number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="translated">Когда мы назначаем &lt;code&gt;s1&lt;/code&gt; на &lt;code&gt;s2&lt;/code&gt; , данные &lt;code&gt;String&lt;/code&gt; копируются, то есть мы копируем указатель, длину и емкость, которые находятся в стеке. Мы не копируем данные в кучу, на которую ссылается указатель. Другими словами, представление данных в памяти выглядит так, как показано на рисунке 4-2.</target>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="translated">Когда мы вводим имя в область видимости с &lt;code&gt;use&lt;/code&gt; ключевого слова use , имя, доступное в новой области, становится частным. Чтобы код, который вызывает наш код, мог ссылаться на это имя, как если бы оно было определено в области действия этого кода, мы можем объединить &lt;code&gt;pub&lt;/code&gt; и &lt;code&gt;use&lt;/code&gt; . Этот метод называется &lt;em&gt;реэкспортом,&lt;/em&gt; потому что мы переносим элемент в область видимости, но также делаем этот элемент доступным для других, чтобы они могли включить его в свою область действия.</target>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="translated">Когда мы вызываем &lt;code&gt;fly&lt;/code&gt; для экземпляра &lt;code&gt;Human&lt;/code&gt; , компилятор по умолчанию вызывает метод, который непосредственно реализован для этого типа, как показано в листинге 19-17.</target>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Когда мы вызываем этот макрос с помощью &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; , шаблон &lt;code&gt;$x&lt;/code&gt; трижды совпадает с тремя выражениями &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7bba3d9da7852f6359cc6e672864f837a98a14" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get an error with this core message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="translated">Когда мы компилируем этот код,мы получаем следующее сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="translated">Когда мы компилируем этот код,мы получаем эту ошибку:</target>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="translated">Когда мы компилируем этот пример,мы получаем эту ошибку:</target>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Когда мы создаем новую &lt;code&gt;Post&lt;/code&gt; , мы устанавливаем для ее поля &lt;code&gt;state&lt;/code&gt; значение &lt;code&gt;Some&lt;/code&gt; , которое содержит &lt;code&gt;Box&lt;/code&gt; . Этот &lt;code&gt;Box&lt;/code&gt; указывает на новый экземпляр структуры &lt;code&gt;Draft&lt;/code&gt; . Это гарантирует, что всякий раз, когда мы создаем новый экземпляр &lt;code&gt;Post&lt;/code&gt; , он запускается как черновик. Поскольку &lt;code&gt;state&lt;/code&gt; поле &lt;code&gt;Post&lt;/code&gt; является частным, нет никакого способа , чтобы создать &lt;code&gt;Post&lt;/code&gt; в любом другом государстве! В функции &lt;code&gt;Post::new&lt;/code&gt; мы устанавливаем в поле &lt;code&gt;content&lt;/code&gt; новую пустую &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="translated">Когда мы создаем узел &lt;code&gt;branch&lt;/code&gt; , он также будет иметь новую ссылку &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; в &lt;code&gt;parent&lt;/code&gt; поле, потому что &lt;code&gt;branch&lt;/code&gt; не имеет родительского узла. У нас все еще есть &lt;code&gt;leaf&lt;/code&gt; как один из дочерних элементов &lt;code&gt;branch&lt;/code&gt; . Когда у нас есть экземпляр &lt;code&gt;Node&lt;/code&gt; в &lt;code&gt;branch&lt;/code&gt; , мы можем изменить &lt;code&gt;leaf&lt;/code&gt; чтобы дать ему &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ссылку &amp;lt;Node&amp;gt; на его родителя. Мы используем &lt;code&gt;borrow_mut&lt;/code&gt; метод на &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; в &lt;code&gt;parent&lt;/code&gt; поле &lt;code&gt;leaf&lt;/code&gt; , а затем мы используем &lt;code&gt;Rc::downgrade&lt;/code&gt; функцию , чтобы создать &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ссылка на &amp;lt;Node&amp;gt; для &lt;code&gt;branch&lt;/code&gt; от &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="translated">Когда мы ввели &lt;code&gt;*y&lt;/code&gt; в листинге 15-9, за кулисами Rust фактически запустил этот код:</target>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="translated">Когда мы ввели команду, Cargo создал файл &lt;em&gt;Cargo.toml&lt;/em&gt; , предоставив нам пакет. При просмотре содержимого &lt;em&gt;Cargo.toml&lt;/em&gt; здесь нет упоминания &lt;em&gt;src / main.rs,&lt;/em&gt; потому что Cargo следует соглашению, согласно которому &lt;em&gt;src / main.rs&lt;/em&gt; является корнем бинарного контейнера с тем же именем, что и пакет. Точно так же Cargo знает, что если каталог пакета содержит &lt;em&gt;src / lib.rs&lt;/em&gt; , пакет содержит ящик библиотеки с тем же именем, что и пакет, а &lt;em&gt;src / lib.rs&lt;/em&gt; - его корень &lt;em&gt;контейнера&lt;/em&gt; . Cargo передает корневые файлы ящика в &lt;code&gt;rustc&lt;/code&gt; для сборки библиотеки или двоичного файла .</target>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="translated">Когда у нас есть значение &lt;code&gt;Some&lt;/code&gt; , мы знаем, что значение присутствует, а значение удерживается внутри &lt;code&gt;Some&lt;/code&gt; . Когда у нас есть значение &lt;code&gt;None&lt;/code&gt; , в некотором смысле это означает то же самое, что и null: у нас нет действительного значения. Так почему же &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; лучше, чем null?</target>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="translated">Когда мы реализуем методы в структуре с временем жизни, мы используем тот же синтаксис, что и параметры универсального типа, показанные в листинге 10-11. То, где мы объявляем и используем параметры времени жизни, зависит от того, связаны ли они с полями структуры или параметрами метода и возвращаемыми значениями.</target>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">Когда мы реализовали &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; , мы использовали значение по умолчанию для &lt;code&gt;RHS&lt;/code&gt; , потому что мы хотели добавить два экземпляра &lt;code&gt;Point&lt;/code&gt; . Давайте посмотрим на пример реализации трейта &lt;code&gt;Add&lt;/code&gt; ,в котором мы хотим настроить тип &lt;code&gt;RHS&lt;/code&gt; , а не использовать значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bbeae0b47ec877c608d0d21b1b80a717b1578283" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;Rhs&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;Rhs&lt;/code&gt; type rather than using the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="translated">Когда мы снова посмотрим на &lt;em&gt;src / main.rs&lt;/em&gt; , мы увидим, что &lt;code&gt;cargo fix&lt;/code&gt; изменило код:</target>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="translated">Когда мы создаем новый проект библиотеки с Cargo, для нас автоматически создается тестовый модуль с функцией тестирования. Этот модуль помогает вам начать писать тесты, поэтому вам не нужно искать точную структуру и синтаксис тестовых функций каждый раз, когда вы начинаете новый проект. Вы можете добавить столько дополнительных тестовых функций и столько тестовых модулей, сколько захотите!</target>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Когда мы передаем конкретные ссылки на &lt;code&gt;longest&lt;/code&gt; , конкретное время жизни, которое заменяется на &lt;code&gt;'a&lt;/code&gt; , является частью области действия &lt;code&gt;x&lt;/code&gt; , которая перекрывается областью действия &lt;code&gt;y&lt;/code&gt; . Другими словами, общее время жизни &lt;code&gt;'a&lt;/code&gt; получит конкретное время жизни, которое равно меньшему из времен жизни &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Поскольку мы аннотировали возвращаемую ссылку с тем же параметром времени жизни &lt;code&gt;'a&lt;/code&gt; , возвращенная ссылка также будет действительна для длины меньшего из значений времени жизни &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="translated">Когда мы печатаем &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , мы видим, что все они имеют измененное значение 15, а не 5:</target>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="translated">Когда мы снова печатаем родительский элемент &lt;code&gt;leaf&lt;/code&gt; , на этот раз мы получим &lt;code&gt;branch&lt;/code&gt; содержащую &lt;code&gt;Some&lt;/code&gt; вариант : теперь &lt;code&gt;leaf&lt;/code&gt; может получить доступ к своему родительскому элементу! Когда мы печатаем &lt;code&gt;leaf&lt;/code&gt; , мы также избегаем цикла, который в конечном итоге закончился переполнением стека, как в листинге 15-26; на &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ссылки печатаются &lt;code&gt;(Weak)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="translated">Когда мы запускаем &lt;code&gt;cargo doc --open&lt;/code&gt; , эти комментарии будут отображаться на первой странице документации для &lt;code&gt;my_crate&lt;/code&gt; над списком общедоступных элементов в ящике, как показано на рисунке 14-2:</target>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="translated">Когда мы запустим код из Листинга 16-8, мы увидим значение, напечатанное из основного потока:</target>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="translated">Когда мы запустим программу сейчас,мы получим это:</target>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="translated">Когда мы проведем тест в Листинге 11-8,он провалится:</target>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="translated">Когда мы снова запустим тесты, мы увидим новый раздел в выходных данных теста для файла &lt;em&gt;common.rs&lt;/em&gt; , хотя этот файл не содержит никаких тестовых функций, и мы не вызывали функцию &lt;code&gt;setup&lt;/code&gt; из любого места:</target>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">Когда мы снова запускаем тесты из Листинга 11-10 с флагом &lt;code&gt;--nocapture&lt;/code&gt; , мы видим следующий результат:</target>
        </trans-unit>
        <trans-unit id="35bd5db3d4e7561ab5f23e824a5b461601f0023a" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--show-output&lt;/code&gt; flag, we see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Когда мы запустим эти тесты с &lt;code&gt;cargo test&lt;/code&gt; , мы увидим следующий результат:</target>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="translated">Когда мы запустим этот код с функцией &lt;code&gt;main&lt;/code&gt; из Листинга 5-14, мы получим желаемый результат. Методы могут принимать несколько параметров, которые мы добавляем в подпись после параметра &lt;code&gt;self&lt;/code&gt; , и эти параметры работают так же, как параметры в функциях.</target>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="translated">Когда мы запускаем этот код, сохраняя последний &lt;code&gt;println!&lt;/code&gt; закомментировано на данный момент, мы получим этот вывод:</target>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="translated">Когда мы запускаем этот код, метод first &lt;code&gt;[]&lt;/code&gt; вызовет панику программы, потому что он ссылается на несуществующий элемент. Этот метод лучше всего использовать, когда вы хотите, чтобы ваша программа аварийно завершила работу при попытке доступа к элементу за концом вектора.</target>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="translated">Когда мы запускаем этот код,мы получаем ошибку с этим основным сообщением:</target>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="translated">Когда мы запустим этот код, мы увидим тот же результат, что и в листинге 3-4. Что еще более важно, теперь мы повысили безопасность кода и устранили вероятность ошибок, которые могут возникнуть из-за выхода за пределы массива или недостаточного захода и пропуска некоторых элементов.</target>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="translated">Когда запустим эту программу, посмотрим еще &lt;code&gt;again!&lt;/code&gt; печатать снова и снова, пока мы не остановим программу вручную. Большинство терминалов поддерживают сочетание клавиш ctrl-c для прерывания программы, застрявшей в непрерывном цикле. Попробуйте:</target>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Когда мы запустим эту программу, мы увидим следующий вывод:</target>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="translated">Когда мы пытаемся проверить этот код,мы получаем эту ошибку:</target>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="translated">Когда мы попытаемся скомпилировать код из Листинга 19-5, мы получим ошибку.</target>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="translated">Когда мы попытаемся скомпилировать этот код, мы получим ошибку. &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; оружие имеют типы значений, которые несовместимы, и Руст точно указывает , где искать проблему в программе:</target>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Когда мы попытаемся скомпилировать этот код, мы получим такую ​​ошибку:</target>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="translated">Когда мы используем параметр в теле функции, мы должны объявить имя параметра в подписи, чтобы компилятор знал, что это имя означает. Точно так же, когда мы используем имя параметра типа в сигнатуре функции, мы должны объявить имя параметра типа перед его использованием. Чтобы определить общую &lt;code&gt;largest&lt;/code&gt; функцию, поместите объявления имени типа в угловые скобки &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; между именем функции и списком параметров, например:</target>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="translated">Когда мы используем параметры универсального типа, мы можем указать конкретный тип по умолчанию для универсального типа. Это избавляет разработчиков трейта от необходимости указывать конкретный тип, если тип по умолчанию работает. Синтаксис для указания типа по умолчанию для универсального типа - &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; при объявлении универсального типа.</target>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="translated">Когда мы используем трейт-объекты, Rust должен использовать динамическую отправку. Компилятор не знает всех типов, которые могут использоваться с кодом, использующим типажные объекты, поэтому он не знает, какой метод реализован для какого типа вызывать. Вместо этого во время выполнения Rust использует указатели внутри объекта трейта, чтобы знать, какой метод вызвать. Когда этот поиск происходит, это требует затрат времени выполнения, чего не происходит при статической отправке. Динамическая отправка также предотвращает выбор компилятором встраивания кода метода, что, в свою очередь, предотвращает некоторые оптимизации. Однако мы получили дополнительную гибкость в коде, который мы написали в листинге 17-5 и смогли поддержать в листинге 17-9, так что это компромисс, который следует учитывать.</target>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="translated">Когда мы писали библиотеку, мы не знали, что кто-то может добавить тип &lt;code&gt;SelectBox&lt;/code&gt; , но наша реализация &lt;code&gt;Screen&lt;/code&gt; могла работать с новым типом и рисовать его, потому что &lt;code&gt;SelectBox&lt;/code&gt; реализует трейт &lt;code&gt;Draw&lt;/code&gt; , что означает, что он реализует метод &lt;code&gt;draw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="translated">Когда мы определяем эту функцию, мы не знаем конкретных значений, которые будут переданы в эту функцию, поэтому мы не знаем, будет ли выполняться случай &lt;code&gt;if&lt;/code&gt; или случай &lt;code&gt;else&lt;/code&gt; . Мы также не знаем конкретного времени жизни ссылок, которые будут переданы, поэтому мы не можем посмотреть на области действия, как в листингах 10-18 и 10-19, чтобы определить, всегда ли будет действительна возвращаемая ссылка. . Средство проверки заимствований тоже не может определить это, поскольку не знает, как время жизни &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; соотносится со временем жизни возвращаемого значения. Чтобы исправить эту ошибку, мы добавим общие параметры времени жизни, которые определяют взаимосвязь между ссылками, чтобы средство проверки заимствований могло выполнить свой анализ.</target>
        </trans-unit>
        <trans-unit id="2b0ee241a22dde4f8299858560fbc384d292c571" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">При работе с закрепленными структурами возникает вопрос, как получить доступ к полям этой структуры в методе, который принимает только &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; . Обычный подход заключается в написании вспомогательных методов (так называемых &lt;em&gt;проекций&lt;/em&gt; ), которые превращают &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; в ссылку на поле, но какой тип должна иметь эта ссылка? Это &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ? Тот же вопрос возникает с полями &lt;code&gt;enum&lt;/code&gt; , а также при рассмотрении типов контейнеров / оболочек, таких как &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;. (Этот вопрос относится как к изменяемым, так и к совместно используемым ссылкам, мы просто используем более распространенный случай изменяемых ссылок здесь для иллюстрации.)</target>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="translated">При записи после конца файла файл соответствующим образом расширяется,а промежуточные байты инициализируются значением 0.</target>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="translated">При записи после конца файла файл соответствующим образом расширяется,а промежуточные байты остаются неинициализированными.</target>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">При написании кода, вызывающего множество функций, возвращающих тип &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; , обработка ошибок может быть утомительной. Оператор вопросительного знака &lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;, скрывает некоторые шаблоны распространения ошибок вверх по стеку вызовов.</target>
        </trans-unit>
        <trans-unit id="fd3f2291c33fd3018ecb6b461f1a771659ef7d7e" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="translated">При написании модульных тестов для модуля часто принято иметь непосредственный дочерний элемент тестируемого модуля с именем &lt;code&gt;mod test&lt;/code&gt; . Этот модуль может получить доступ к любым элементам родительского модуля через второй случай, а это означает, что детали внутренней реализации также могут быть легко протестированы из дочернего модуля.</target>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">При написании собственных черт &lt;code&gt;!&lt;/code&gt; должен иметь &lt;code&gt;impl&lt;/code&gt; когда есть очевидный &lt;code&gt;impl&lt;/code&gt; который не вызывает &lt;code&gt;panic!&lt;/code&gt; . Как оказалось, большинство черты могут иметь &lt;code&gt;impl&lt;/code&gt; для &lt;code&gt;!&lt;/code&gt; . Возьмем, к примеру, &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b06c46c776108f6df59bce40c78afdd8aa807784" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. The reason is that functions returning an &lt;code&gt;impl Trait&lt;/code&gt; where &lt;code&gt;!&lt;/code&gt; does not have an &lt;code&gt;impl&lt;/code&gt; of &lt;code&gt;Trait&lt;/code&gt; cannot diverge as their only possible code path. In other words, they can't return &lt;code&gt;!&lt;/code&gt; from every code path. As an example, this code doesn't compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">Если вы &lt;em&gt;действительно&lt;/em&gt; хотите обновить ящик, Cargo предоставляет другую команду, &lt;code&gt;update&lt;/code&gt; , которая игнорирует файл &lt;em&gt;Cargo.lock&lt;/em&gt; и определяет все последние версии, которые соответствуют вашим спецификациям в &lt;em&gt;Cargo.toml&lt;/em&gt; . Если это сработает, Cargo запишет эти версии в файл &lt;em&gt;Cargo.lock&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="translated">Когда вы вызываете метод с синтаксисом &lt;code&gt;.foo()&lt;/code&gt; , часто бывает целесообразно ввести новую строку и другие пробелы, чтобы помочь разбить длинные строки. Мы могли бы написать этот код как:</target>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Когда вы создаете замыкание, Rust определяет, какой трейт использовать, основываясь на том, как замыкание использует значения из окружения. Все замыкания реализуют &lt;code&gt;FnOnce&lt;/code&gt; , потому что все они могут быть вызваны хотя бы один раз. Замыкания, которые не перемещают захваченные переменные, также реализуют &lt;code&gt;FnMut&lt;/code&gt; , а замыкания, которым не требуется изменяемый доступ к захваченным переменным, также реализуют &lt;code&gt;Fn&lt;/code&gt; . В листинге 13-12 замыкание &lt;code&gt;equal_to_x&lt;/code&gt; неизменяемо заимствует &lt;code&gt;x&lt;/code&gt; (так что &lt;code&gt;equal_to_x&lt;/code&gt; имеет черту &lt;code&gt;Fn&lt;/code&gt; ), потому что тело замыкания должно только читать значение в &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="translated">Если у вас большой объем данных и вы хотите передать право собственности, но убедитесь, что данные не будут скопированы, когда вы это сделаете</target>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="translated">Если у вас есть тип, размер которого не может быть известен во время компиляции, и вы хотите использовать значение этого типа в контексте, требующем точного размера</target>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="translated">Когда вы распознаете в своем коде ситуации с множественными определениями структур или перечислений,которые отличаются только типами значений,которые они содержат,вы можете избежать дублирования,используя вместо этого общие типы.</target>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="translated">Когда вы снова запустите &lt;code&gt;cargo check&lt;/code&gt; , вы получите еще несколько предупреждений, но все должно пройти успешно.</target>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="translated">Когда вы запустите его, вы не получите путь к исходному исполняемому файлу, вы получите путь жесткой ссылки:</target>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="translated">Когда вы запускаете несколько тестов, по умолчанию они выполняются параллельно с использованием потоков. Это означает, что тесты завершатся быстрее, и вы сможете быстрее получить обратную связь о том, работает ли ваш код. Поскольку тесты выполняются одновременно, убедитесь, что ваши тесты не зависят друг от друга или от какого-либо общего состояния, включая общую среду, такую ​​как текущий рабочий каталог или переменные среды.</target>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="translated">Когда вы запускаете код,ваш вывод должен выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="translated">Когда вы запустите программу, вы увидите что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="translated">Когда вы запустите этот код,он скомпилируется,но выдаст предупреждение:</target>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="translated">Когда вы запустите эту программу, вы получите следующее сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="translated">Когда вы видите вызов &lt;code&gt;clone&lt;/code&gt; , вы знаете, что выполняется произвольный код, и этот код может быть дорогостоящим. Это визуальный индикатор того, что происходит нечто иное.</target>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="translated">Когда вы поймете, что такое право собственности, у вас будет прочная основа для понимания функций, которые делают Rust уникальным. В этой главе вы узнаете о праве собственности, рассмотрев несколько примеров, посвященных очень распространенной структуре данных: строкам.</target>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="translated">Если вы хотите,чтобы функция имела несколько параметров,разделите объявления параметров запятыми,например,так:</target>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="translated">Когда вы хотите владеть значением и заботитесь только о том, что это тип, реализующий определенную черту, а не принадлежащий к определенному типу</target>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда вы компилируете в режиме выпуска с флагом &lt;code&gt;--release&lt;/code&gt; , Rust &lt;em&gt;не&lt;/em&gt; включает проверки целочисленного переполнения, вызывающие панику. Вместо этого, если происходит переполнение, Rust выполняет &lt;em&gt;перенос до двух дополнений&lt;/em&gt; . Короче говоря, значения, превышающие максимальное значение, которое может удерживать тип, &amp;laquo;оборачиваются&amp;raquo; до минимума значений, которые тип может содержать. В случае &lt;code&gt;u8&lt;/code&gt; 256 становится 0, 257 становится 1 и так далее. Программа не паникует, но переменная будет иметь значение, которое, вероятно, не то, что вы ожидали. Полагаться на поведение переноса целочисленного переполнения считается ошибкой. Если вы хотите явно обернуть, вы можете использовать стандартный библиотечный тип &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt; &lt;code&gt;Wrapping&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="translated">Когда вы закончите с данными, которые охраняет мьютекс, вы должны разблокировать данные, чтобы другие потоки могли получить блокировку.</target>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="translated">Когда вы будете готовы двигаться дальше, мы поговорим о концепции в Rust, &lt;em&gt;которая&lt;/em&gt; обычно &lt;em&gt;не&lt;/em&gt; существует в других языках программирования: владение.</target>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="translated">Когда вы пишете функцию, реализация которой вызывает что-то, что может привести к сбою, вместо обработки ошибки в этой функции вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что делать. Это называется &lt;em&gt;распространением&lt;/em&gt; ошибки и дает больше контроля вызывающему коду, где может быть больше информации или логики, определяющей способ обработки ошибки, чем то, что доступно в контексте вашего кода.</target>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="translated">Когда вы пишете программу, если вы не знаете исчерпывающий набор типов, которые программа получит во время выполнения для сохранения в векторе, метод enum не сработает. Вместо этого вы можете использовать объект-признак, который мы рассмотрим в главе 17.</target>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="translated">Когда вы пишете пример для иллюстрации некоторой концепции, наличие надежного кода обработки ошибок в примере также может сделать пример менее понятным. В примерах понимается, что вызов такого метода, как &lt;code&gt;unwrap&lt;/code&gt; , который может вызвать панику, предназначен в качестве заполнителя того, как ваше приложение должно обрабатывать ошибки, которые могут отличаться в зависимости от того, что делает остальная часть вашего кода.</target>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="translated">Когда вы внесли изменения в свой ящик и готовы выпустить новую версию, вы измените значение &lt;code&gt;version&lt;/code&gt; указанное в вашем файле &lt;em&gt;Cargo.toml,&lt;/em&gt; и &lt;em&gt;повторно опубликуете&lt;/em&gt; . Используйте &lt;a href=&quot;http://semver.org/&quot;&gt;правила семантического управления версиями,&lt;/a&gt; чтобы решить, какой номер следующей версии будет соответствовать типу внесенных вами изменений. Затем запустите &lt;code&gt;cargo publish&lt;/code&gt; чтобы загрузить новую версию.</target>
        </trans-unit>
        <trans-unit id="a63fa0940baafe694284e32babae3f74d6ff198c" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a2affd429f9e55f7202252260760e859abffb5" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="translated">Когда ваш код вызывает функцию, значения, переданные в функцию (включая, возможно, указатели на данные в куче), и локальные переменные функции помещаются в стек. Когда функция завершается, эти значения удаляются из стека.</target>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="translated">Когда ваш код выполняет операции со значениями, ваш код должен сначала проверить значения, допустимые, и паниковать, если значения недействительны. Это в основном из соображений безопасности: попытка работы с недопустимыми данными может подвергнуть ваш код уязвимостям. Это основная причина, по которой стандартная библиотека вызовет &lt;code&gt;panic!&lt;/code&gt; если вы пытаетесь получить доступ к памяти вне пределов: попытка получить доступ к памяти, которая не принадлежит текущей структуре данных, является распространенной проблемой безопасности. У функций часто есть &lt;em&gt;контракты&lt;/em&gt;: их поведение гарантируется только в том случае, если входные данные соответствуют определенным требованиям. Паника при нарушении контракта имеет смысл, потому что нарушение контракта всегда указывает на ошибку на стороне вызывающего абонента, и это не та ошибка, которую вызывающий код должен обрабатывать явным образом. На самом деле нет разумного способа вызвать код для восстановления; вызывающим &lt;em&gt;программистам&lt;/em&gt; нужно исправить код. Контракты для функции, особенно когда нарушение вызовет панику, следует объяснять в документации API для функции.</target>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="translated">Когда ваш проект, наконец, будет готов к выпуску, вы можете использовать &lt;code&gt;cargo build --release&lt;/code&gt; чтобы скомпилировать его с оптимизацией. Эта команда создаст исполняемый файл в &lt;em&gt;target / release&lt;/em&gt; вместо &lt;em&gt;target / debug&lt;/em&gt; . Оптимизация заставляет ваш код Rust работать быстрее, но их включение увеличивает время, необходимое вашей программе для компиляции. Вот почему существует два разных профиля: один для разработки, когда вы хотите быстро и часто перестраивать, а другой для создания окончательной программы, которую вы дадите пользователю, которая не будет повторно собираться повторно и будет работать так быстро, как возможно. Если вы &lt;code&gt;cargo build --release&lt;/code&gt; время работы своего кода, обязательно запустите Cargo build --release и выполните тест с исполняемым файлом в &lt;em&gt;target / release&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="translated">Всякий раз, когда создается временный объект, он автоматически удаляется (освобождается) в соответствии с установленными правилами. Обычно временное значение удаляется в конце заключительного оператора - в данном случае после &lt;code&gt;let&lt;/code&gt; . Это проиллюстрировано в приведенном выше примере, показывая, что &lt;code&gt;tmp&lt;/code&gt; будет освобожден, когда мы выйдем из блока.</target>
        </trans-unit>
        <trans-unit id="0d66101f5b82c22f64225217f832b8e7af03aba9" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3c7f91ce843a180fc6f430d195fed72f860109" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">По возможности, вместо этого предпочтительно использовать &lt;a href=&quot;#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; , что предотвращает дублирование содержимого &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="translated">Где условия</target>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="translated">Где оператор &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="translated">Оценивать или не оценивать подвыражения при вычислении выражения</target>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="translated">Ух! Теперь у вас есть некоторые функции Rust в вашем наборе инструментов, которые вы не будете часто использовать, но вы будете знать, что они доступны в очень определенных обстоятельствах. Мы представили несколько сложных тем, чтобы вы могли распознать эти концепции и синтаксис, когда вы столкнетесь с ними в предложениях сообщений об ошибках или в коде других людей. Используйте эту главу как справочник, который поможет вам найти решения.</target>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="translated">Ух! Это было много работы, но мы настроили себя на успех в будущем. Теперь обрабатывать ошибки стало намного проще, и мы сделали код более модульным. Почти все наши работы будет осуществляться в &lt;em&gt;SRC / lib.rs&lt;/em&gt; отсюда на.</target>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="translated">Ух! У нас &lt;em&gt;также&lt;/em&gt; не может быть изменяемой ссылки, пока у нас есть неизменяемая. Пользователи неизменной ссылки не ожидают, что значения внезапно изменятся из-под них! Однако несколько неизменяемых ссылок - это нормально, потому что никто, кто просто читает данные, не имеет возможности повлиять на чтение данных кем-либо другим.</target>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="translated">Какие параметры конфигурации устанавливаются, определяется статически при компиляции ящика. Определенные параметры устанавливаются &lt;em&gt;компилятором&lt;/em&gt; на основе данных о компиляции. Другие параметры устанавливаются &lt;em&gt;произвольно&lt;/em&gt; , на основе ввода, переданного компилятору вне кода. Невозможно установить параметр конфигурации из исходного кода компилируемого ящика.</target>
        </trans-unit>
        <trans-unit id="aec19e71f7245e5468afe6ba28062c55126000f9" translate="yes" xml:space="preserve">
          <source>Which kind of future are we turning this into?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e64a82a5b16af1f23a177677675bfbfea39f34c" translate="yes" xml:space="preserve">
          <source>Which kind of iterator are we turning this into?</source>
          <target state="translated">В какой итератор мы это превращаем?</target>
        </trans-unit>
        <trans-unit id="0807125208cee959762c24f1a5a66bea0dc3bb1c" translate="yes" xml:space="preserve">
          <source>Which method works best depends on what kind of situation you're in.</source>
          <target state="translated">Какой метод работает лучше всего,зависит от того,в какой ситуации вы находитесь.</target>
        </trans-unit>
        <trans-unit id="f77bbb1b800fe27a58f9b1a9edd741074b14ca16" translate="yes" xml:space="preserve">
          <source>Which of our two &lt;code&gt;HasDrop&lt;/code&gt; drops first, though? For structs, it's the same order that they're declared: first &lt;code&gt;one&lt;/code&gt;, then &lt;code&gt;two&lt;/code&gt;. If you'd like to try this yourself, you can modify &lt;code&gt;HasDrop&lt;/code&gt; above to contain some data, like an integer, and then use it in the &lt;code&gt;println!&lt;/code&gt; inside of &lt;code&gt;Drop&lt;/code&gt;. This behavior is guaranteed by the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381bdae639e5c41f0066a4ced8cdfc3fa580e603" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; is very useful for removing errors, &lt;code&gt;!&lt;/code&gt; can also be used to remove successes as well. If we think of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; as &quot;if this function returns, it has not errored,&quot; we get a very intuitive idea of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; as well: if the function returns, it &lt;em&gt;has&lt;/em&gt; errored.</source>
          <target state="translated">Хотя &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; Очень полезен для удаления ошибок &lt;code&gt;!&lt;/code&gt; также можно использовать для удаления успехов. Если мы думаем о &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; , Как &amp;laquo;если эта функция возвращает, это не ошибочный,&amp;raquo; мы получаем очень интуитивное представление о &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; а: если функция возвращает, она &lt;em&gt;имеет&lt;/em&gt; ошибочный.</target>
        </trans-unit>
        <trans-unit id="040144073c8f0dfdb2720a3a96450c0f97978b7d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;MaybeUninit&lt;/code&gt; is &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (indicating it guarantees the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;), this does &lt;em&gt;not&lt;/em&gt; change any of the previous caveats. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; may still have different sizes, and types containing a field of type &lt;code&gt;T&lt;/code&gt; may be laid out (and sized) differently than if that field were &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MaybeUninit&lt;/code&gt; is a union type, and &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions is unstable (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;the tracking issue&lt;/a&gt;). Over time, the exact guarantees of &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions may evolve, and &lt;code&gt;MaybeUninit&lt;/code&gt; may or may not remain &lt;code&gt;#[repr(transparent)]&lt;/code&gt;. That said, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; guarantee that it has the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;; it's just that the way &lt;code&gt;MaybeUninit&lt;/code&gt; implements that guarantee may evolve.</source>
          <target state="translated">Хотя &lt;code&gt;MaybeUninit&lt;/code&gt; имеет значение &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (что означает, что он гарантирует тот же размер, выравнивание и ABI, что и &lt;code&gt;T&lt;/code&gt; ), это &lt;em&gt;не&lt;/em&gt; меняет ни одного из предыдущих предупреждений. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; могут по-прежнему иметь разные размеры, а типы, содержащие поле типа &lt;code&gt;T&lt;/code&gt; , могут располагаться (и иметь размер) иначе, чем если бы это поле было &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;MaybeUninit&lt;/code&gt; - это тип объединения, а &lt;code&gt;#[repr(transparent)]&lt;/code&gt; для объединений нестабильно (см. Проблему &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;отслеживания&lt;/a&gt; ). Со временем точные гарантии &lt;code&gt;#[repr(transparent)]&lt;/code&gt; для профсоюзов могут измениться, и &lt;code&gt;MaybeUninit&lt;/code&gt; может оставаться, а может и не оставаться &lt;code&gt;#[repr(transparent)]&lt;/code&gt; . Тем не менее, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; будет &lt;em&gt;всегда&lt;/em&gt; гарантировать , что он имеет такой же размер, выравнивание и ABI как &lt;code&gt;T&lt;/code&gt; ; просто способ, которым &lt;code&gt;MaybeUninit&lt;/code&gt; реализует эту гарантию, может развиваться.</target>
        </trans-unit>
        <trans-unit id="b5f05e101ccc42742a41d22d19ff794b2f1ec6bc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TypeId&lt;/code&gt; implements &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;, it is worth noting that the hashes and ordering will vary between Rust releases. Beware of relying on them inside of your code!</source>
          <target state="translated">Хотя &lt;code&gt;TypeId&lt;/code&gt; реализует &lt;code&gt;Hash&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; и &lt;code&gt;Ord&lt;/code&gt; , стоит отметить, что хеши и порядок их выполнения будут различаться в зависимости от выпуска Rust. Остерегайтесь полагаться на них внутри вашего кода!</target>
        </trans-unit>
        <trans-unit id="6d4c0b858b921a1aa9b09d6f6ffff138728f277d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;mem::forget&lt;/code&gt; can also be used to transfer &lt;em&gt;memory&lt;/em&gt; ownership, doing so is error-prone. &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; should be used instead. Consider, for example, this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef43e2f499fb4e7ebf44c6c96560fe3863b368a0" translate="yes" xml:space="preserve">
          <source>While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.</source>
          <target state="translated">В то время как строки Rust могут содержать нулевые байты посередине,строки C не могут,так как этот байт фактически усекает строку.</target>
        </trans-unit>
        <trans-unit id="9b96c7bdcb6a7fde4fa090bcc724c51dcf154ff7" translate="yes" xml:space="preserve">
          <source>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be &quot;bridging&quot; some Windows APIs together, just passing &lt;code&gt;WCHAR&lt;/code&gt; strings among those APIs without ever really looking into the strings.</source>
          <target state="translated">Хотя не всегда возможно преобразовать такую ​​строку без потерь в действительную строку UTF-16 (или даже UTF-8), часто желательно иметь возможность передавать такую ​​строку туда и обратно без потерь из Windows API. Например, некоторый код Rust может &amp;laquo;связывать&amp;raquo; некоторые API-интерфейсы Windows вместе, просто передавая строки &lt;code&gt;WCHAR&lt;/code&gt; между этими API-интерфейсами, даже не заглядывая в строки.</target>
        </trans-unit>
        <trans-unit id="94ebb9d6a417c21d0e98155c75c39327ba03733c" translate="yes" xml:space="preserve">
          <source>While it might seem strange to have a function that just returns back the input, there are some interesting uses.</source>
          <target state="translated">Хотя может показаться странным иметь функцию,которая просто возвращает входные данные,есть некоторые интересные применения.</target>
        </trans-unit>
        <trans-unit id="97e4502df2c17c97ddd6625eabaef88cae532a3d" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2427b468d47a7420d460c3c9434666519bb67a" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Во время итерации возвращенный итератор запаникует, если какой-либо ключ или значение в среде недействителен unicode. Если это нежелательно, рассмотрите возможность использования функции &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88abee318504f329611b88069221a80488cf9999" translate="yes" xml:space="preserve">
          <source>While performing error handling it is often useful to implement &lt;code&gt;From&lt;/code&gt; for your own error type. By converting underlying error types to our own custom error type that encapsulates the underlying error type, we can return a single error type without losing information on the underlying cause. The '?' operator automatically converts the underlying error type to our custom error type by calling &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; which is automatically provided when implementing &lt;code&gt;From&lt;/code&gt;. The compiler then infers which implementation of &lt;code&gt;Into&lt;/code&gt; should be used.</source>
          <target state="translated">При выполнении обработки ошибок часто бывает полезно реализовать &lt;code&gt;From&lt;/code&gt; для вашего собственного типа ошибки. Преобразуя базовые типы ошибок в наш собственный настраиваемый тип ошибки, который инкапсулирует базовый тип ошибки, мы можем вернуть один тип ошибки без потери информации об основной причине. '?' Оператор автоматически преобразует базовый тип ошибки в наш настраиваемый тип ошибки, вызывая &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; который автоматически предоставляется при реализации &lt;code&gt;From&lt;/code&gt; . Затем компилятор определяет, какую реализацию &lt;code&gt;Into&lt;/code&gt; следует использовать.</target>
        </trans-unit>
        <trans-unit id="21a3472b42943360038c378154c72aeef876d83b" translate="yes" xml:space="preserve">
          <source>While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are &lt;a href=&quot;#primitives&quot;&gt;documented in the section on primitives&lt;/a&gt;.</source>
          <target state="translated">Хотя примитивы реализуются компилятором, стандартная библиотека реализует методы непосредственно для примитивных типов (и это единственная библиотека, которая это делает), которые &lt;a href=&quot;#primitives&quot;&gt;описаны в разделе, посвященном примитивам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2a8167e66f949c278500fe8a0d882045622dfbf" translate="yes" xml:space="preserve">
          <source>While the following example is sound, there is a memory leak since the inner vectors were not freed prior to the &lt;code&gt;set_len&lt;/code&gt; call:</source>
          <target state="translated">Хотя следующий пример &lt;code&gt;set_len&lt;/code&gt; , есть утечка памяти, поскольку внутренние векторы не были освобождены до вызова set_len :</target>
        </trans-unit>
        <trans-unit id="c01f6f794efd0c185cdbd0acdeb3770eddfc8772" translate="yes" xml:space="preserve">
          <source>While there could be a more fine-grained scheme in the future that allows mutable references if they are not &quot;leaked&quot; to the final value, a more conservative approach was chosen for now. &lt;code&gt;const fn&lt;/code&gt; do not have this problem, as the borrow checker will prevent the &lt;code&gt;const fn&lt;/code&gt; from returning new mutable references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce58c9d13deabade9d0031e57b5c561b8bbc9a7" translate="yes" xml:space="preserve">
          <source>While these:</source>
          <target state="translated">Пока это:</target>
        </trans-unit>
        <trans-unit id="5d891980461c7894b78072e4c40fd8f0ee9d4fc4" translate="yes" xml:space="preserve">
          <source>While this means the &lt;code&gt;String&lt;/code&gt; will have a length of zero, it does not touch its capacity.</source>
          <target state="translated">Хотя это означает, что &lt;code&gt;String&lt;/code&gt; будет иметь нулевую длину, она не касается ее емкости.</target>
        </trans-unit>
        <trans-unit id="1461d256887a81f77bef33d763313b5547fde61d" translate="yes" xml:space="preserve">
          <source>While this method and its mutable counterpart are useful for null-safety, it is important to note that this is still an unsafe operation because the returned value could be pointing to invalid memory.</source>
          <target state="translated">Хотя этот метод и его мутируемый аналог полезны для нулевой безопасности,важно отметить,что это все равно небезопасная операция,так как возвращаемое значение может указывать на некорректную память.</target>
        </trans-unit>
        <trans-unit id="ee1ba6c8d8e736d86285c52e19961693ec306982" translate="yes" xml:space="preserve">
          <source>While this trait is unstable, the methods are stable. &lt;code&gt;SliceConcatExt&lt;/code&gt; is included in the &lt;a href=&quot;../prelude/index&quot;&gt;standard library prelude&lt;/a&gt;, so you can use &lt;a href=&quot;#tymethod.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; as if they existed on &lt;code&gt;[T]&lt;/code&gt; itself.</source>
          <target state="translated">Хотя эта черта нестабильна, методы стабильны. &lt;code&gt;SliceConcatExt&lt;/code&gt; включен в &lt;a href=&quot;../prelude/index&quot;&gt;стандартную библиотеку prelude&lt;/a&gt; , поэтому вы можете использовать &lt;a href=&quot;#tymethod.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#tymethod.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt; как если бы они существовали на самом &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5f26a246fb02c7cc6b4b29c460a0d1e8dc7640" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the &lt;a href=&quot;../prelude/index&quot;&gt;prelude&lt;/a&gt;'s import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3f0c0f2ca43b389646c40f7923cc632b8f8da" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the prelude's import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В то время как обычный стиль Rust заключается в прямом импорте типов, псевдонимы &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; часто не импортируются , чтобы их было легче различать. &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; , как правило , предполагается, что &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; , и поэтому пользователи этого псевдонима обычно используют &lt;code&gt;io::Result&lt;/code&gt; вместо слежки импорта прелюдии по &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba71bc00b481e82beeb9921c07aacd0590f6bd1" translate="yes" xml:space="preserve">
          <source>While you are looking at that &lt;code&gt;[-]&lt;/code&gt; button also notice the &lt;code&gt;[src]&lt;/code&gt; button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.</source>
          <target state="translated">Когда вы смотрите на эту кнопку &lt;code&gt;[-]&lt;/code&gt; , обратите внимание на кнопку &lt;code&gt;[src]&lt;/code&gt; . Документация по API Rust поставляется с исходным кодом, и вам предлагается прочитать его. Стандартный исходный код библиотеки, как правило, высокого качества, и взгляд за кулисы часто поучителен.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5bd6985bffedbe45212e5ed4b8d7b10e4e8bfe85" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;a href=&quot;https://www.unicode.org/reports/tr31/&quot;&gt;&lt;code&gt;Pattern_White_Space&lt;/code&gt;&lt;/a&gt; Unicode property, namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff785990fe44822be8ffd4354e290cef0c34c873" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode property, namely:</source>
          <target state="translated">Пробел - это любая непустая строка, содержащая только символы, которые имеют &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode Pattern_White_Space , а именно:</target>
        </trans-unit>
        <trans-unit id="9831741f3701cd2501051eea04df81e500fcac28" translate="yes" xml:space="preserve">
          <source>Who Rust Is For</source>
          <target state="translated">Кто такой Ржавчина?</target>
        </trans-unit>
        <trans-unit id="73012c2e29394e650b32f0b4934e8028ea0802a0" translate="yes" xml:space="preserve">
          <source>Who This Book Is For</source>
          <target state="translated">Для кого эта книга</target>
        </trans-unit>
        <trans-unit id="43d9a912852b85357d25bd06b5c4e243076f38d3" translate="yes" xml:space="preserve">
          <source>Who implements &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">Кто внедряет &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e36799f202c4d0ce55f224011110c6d687f10837" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;filter_map&lt;/code&gt; and not just &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;? The key is in this part:</source>
          <target state="translated">Почему &lt;code&gt;filter_map&lt;/code&gt; , а не просто &lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; ? Ключ в этой части:</target>
        </trans-unit>
        <trans-unit id="f5b054d5badd7795d72a342651abfb7fc1f4dad9" translate="yes" xml:space="preserve">
          <source>Why do I get this message with code that doesn't involve borrowing?</source>
          <target state="translated">Почему я получаю это сообщение с кодом,который не включает в себя заимствование?</target>
        </trans-unit>
        <trans-unit id="996dd8b0e5f1405cbf0cea853468ae25180b7c3c" translate="yes" xml:space="preserve">
          <source>Why would you not want an executable? Often, &lt;code&gt;cargo check&lt;/code&gt; is much faster than &lt;code&gt;cargo build&lt;/code&gt;, because it skips the step of producing an executable. If you&amp;rsquo;re continually checking your work while writing the code, using &lt;code&gt;cargo check&lt;/code&gt; will speed up the process! As such, many Rustaceans run &lt;code&gt;cargo check&lt;/code&gt; periodically as they write their program to make sure it compiles. Then they run &lt;code&gt;cargo build&lt;/code&gt; when they&amp;rsquo;re ready to use the executable.</source>
          <target state="translated">Почему вам не нужен исполняемый файл? Часто &lt;code&gt;cargo check&lt;/code&gt; выполняется намного быстрее, чем &lt;code&gt;cargo build&lt;/code&gt; , поскольку при этом пропускается этап создания исполняемого файла. Если вы постоянно проверяете свою работу при написании кода, использование функции &lt;code&gt;cargo check&lt;/code&gt; ускорит процесс! Таким образом, многие Rustaceans периодически запускают &lt;code&gt;cargo check&lt;/code&gt; при написании своей программы, чтобы убедиться, что она компилируется. Затем они запускают &lt;code&gt;cargo build&lt;/code&gt; когда будут готовы использовать исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="a81276e6dfb0c035da01e2595ee9fa04fdc86e1e" translate="yes" xml:space="preserve">
          <source>Wildcard pattern</source>
          <target state="translated">Wildcard узор</target>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="dd04e2ae06e0c22d6b8a5c4141451a441cf23045" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0843bf815a9dab90b0636f270db8d304e5915a96" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">Всегда будет возвращать тот же &lt;code&gt;&amp;amp;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74ce1cb06587f571c24b39c88c3261da8e964077" translate="yes" xml:space="preserve">
          <source>Will handle the pattern &lt;code&gt;&quot;&quot;&lt;/code&gt; as returning empty matches at each character boundary.</source>
          <target state="translated">Будет обрабатывать шаблон &lt;code&gt;&quot;&quot;&lt;/code&gt; как возвращающие пустые совпадения на каждой границе символа.</target>
        </trans-unit>
        <trans-unit id="f2a58ab6d8aaaf56805d5dcc5d08104ca8722e51" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;../str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cfca1876affe8c210a04c4805938a5cb452282" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="translated">Вернется &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; , если это не представляется возможным , чтобы разобрать эту строку ломоть в нужный тип.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="17aebcc3873693512f66ff2029c56928afebc898" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf1c1efc2e097b96e98657a8262127bc226f8f4" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Префиксы пути Windows, например &lt;code&gt;C:&lt;/code&gt; или &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b25b9078d1c6b5cf7d0c03d87923967058f5d7a" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f64162f505580122671f38419aea6835f8c68d" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="translated">Windows использует различные стили префиксов пути, включая ссылки на тома дисков (например, &lt;code&gt;C:&lt;/code&gt; , общие сетевые папки (например, &lt;code&gt;\server\share&lt;/code&gt; ) и другие. Кроме того, некоторые пути префиксы &amp;laquo;дословно&amp;raquo; (то есть, с префиксом &lt;code&gt;\?\&lt;/code&gt; ), В этом случае &lt;code&gt;/&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; рассматривается как разделитель и , по существу , никакой нормализации не выполняется.</target>
        </trans-unit>
        <trans-unit id="7b773809bbe5f3adf18d472bfb1e18eaa3a7d486" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions for the primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">Специфичные для Windows расширения для примитивов в модуле &lt;code&gt;std::fs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965b862fd7707ea01407f5bde9d76c4b33887700" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="315ae7857105e3f47dabe009d9742ce6b255f1de" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширения &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; для Windows .</target>
        </trans-unit>
        <trans-unit id="e64c5541c43eacfdb85ccf07942595f788d2cb90" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения &lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a739bab05e923c90296481bb09cc25239dd40e0" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;fs::File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00024f75ddf677c52ec0b6d2810b742570a31c11" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширения для Windows для &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c379abe31315129f29960307cac5c5a9ebe73ce4" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;fs::FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ae56a0a615ce91192a5ee5e6f95bfb7ba258a6" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45de75b6c03804d7df1abb9816158b688e268757" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94d3d733eec0453c12d54d6f46b9364d74ffa234" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6631cb576a83d66476aa6a96c888a47fea46888b" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to general I/O primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd50699b2495e189ba2c74247886850721ca3204" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">Специфичные для Windows расширения &lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72c2a1cf40aca0e7999edbbce4beb69846664076" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">Специфичные для Windows расширения примитивов в модуле &lt;code&gt;std::ffi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a36d28de36794d012a45ca83704dfdf241f6fac" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives</source>
          <target state="translated">Оконные примитивы</target>
        </trans-unit>
        <trans-unit id="a29244317dd706a76b2545e981c947b9fe3e3b2c" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faf80579510e395a13fd315a37c59f2f038321b" translate="yes" xml:space="preserve">
          <source>Windows::all</source>
          <target state="translated">Windows::all</target>
        </trans-unit>
        <trans-unit id="6716af8ef731d4cbf5689fbdfb93409bf05643fa" translate="yes" xml:space="preserve">
          <source>Windows::any</source>
          <target state="translated">Windows::any</target>
        </trans-unit>
        <trans-unit id="700457e5baeb9db95e547cef9c74633bc4d41f0d" translate="yes" xml:space="preserve">
          <source>Windows::borrow</source>
          <target state="translated">Windows::borrow</target>
        </trans-unit>
        <trans-unit id="17164b9bb020d976e93adc4baa902877434e8dcf" translate="yes" xml:space="preserve">
          <source>Windows::borrow_mut</source>
          <target state="translated">Windows::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31908ffdddda768740e732a89602628774aabf19" translate="yes" xml:space="preserve">
          <source>Windows::by_ref</source>
          <target state="translated">Windows::by_ref</target>
        </trans-unit>
        <trans-unit id="f3d0e279ef4b7617f62329eac02e5ee30b537a4a" translate="yes" xml:space="preserve">
          <source>Windows::chain</source>
          <target state="translated">Windows::chain</target>
        </trans-unit>
        <trans-unit id="dc2580c31dfca64d3e4362d3193516de3088323f" translate="yes" xml:space="preserve">
          <source>Windows::clone</source>
          <target state="translated">Windows::clone</target>
        </trans-unit>
        <trans-unit id="a98bb41ccc08f765218084e917668531933467aa" translate="yes" xml:space="preserve">
          <source>Windows::clone_from</source>
          <target state="translated">Windows::clone_from</target>
        </trans-unit>
        <trans-unit id="561b1708f321b704fa9eba574176baec35025d94" translate="yes" xml:space="preserve">
          <source>Windows::clone_into</source>
          <target state="translated">Windows::clone_into</target>
        </trans-unit>
        <trans-unit id="9c9f0c0979265913d55cdfc2ebb0045f5a724bb0" translate="yes" xml:space="preserve">
          <source>Windows::cloned</source>
          <target state="translated">Windows::cloned</target>
        </trans-unit>
        <trans-unit id="a5b46f7f7dbd448b7a57c4223d0c87d1f200d2c6" translate="yes" xml:space="preserve">
          <source>Windows::cmp</source>
          <target state="translated">Windows::cmp</target>
        </trans-unit>
        <trans-unit id="fbb6b9c622af98d5a66bbf1cfbc26795253b7489" translate="yes" xml:space="preserve">
          <source>Windows::collect</source>
          <target state="translated">Windows::collect</target>
        </trans-unit>
        <trans-unit id="b4ad49bdadeff7d300af28e5eb3fa8051a92ccee" translate="yes" xml:space="preserve">
          <source>Windows::copied</source>
          <target state="translated">Windows::copied</target>
        </trans-unit>
        <trans-unit id="bd6d8af2e6984890043a2ffcecf64303ee4d2b67" translate="yes" xml:space="preserve">
          <source>Windows::count</source>
          <target state="translated">Windows::count</target>
        </trans-unit>
        <trans-unit id="a46aabac6f5fb33e90e0fa67da1b1c957391a4ba" translate="yes" xml:space="preserve">
          <source>Windows::cycle</source>
          <target state="translated">Windows::cycle</target>
        </trans-unit>
        <trans-unit id="54d929ec5d55c2868b2694194d22d67c995476cd" translate="yes" xml:space="preserve">
          <source>Windows::enumerate</source>
          <target state="translated">Windows::enumerate</target>
        </trans-unit>
        <trans-unit id="974003d8cd6730c68f798fb5852a1b8f66b8fc07" translate="yes" xml:space="preserve">
          <source>Windows::eq</source>
          <target state="translated">Windows::eq</target>
        </trans-unit>
        <trans-unit id="fcdcd8564c22f0d208d5887dca20b15981ed7eda" translate="yes" xml:space="preserve">
          <source>Windows::filter</source>
          <target state="translated">Windows::filter</target>
        </trans-unit>
        <trans-unit id="072316ad208e9676ec686940b97aee272075037a" translate="yes" xml:space="preserve">
          <source>Windows::filter_map</source>
          <target state="translated">Windows::filter_map</target>
        </trans-unit>
        <trans-unit id="c74c15ca962f2f3a44811fa2285bb43e26958f3d" translate="yes" xml:space="preserve">
          <source>Windows::find</source>
          <target state="translated">Windows::find</target>
        </trans-unit>
        <trans-unit id="786d8bedc7c35f14926b40554c0038bfc1b31ca1" translate="yes" xml:space="preserve">
          <source>Windows::find_map</source>
          <target state="translated">Windows::find_map</target>
        </trans-unit>
        <trans-unit id="643130ad01d792200f3136ea8c6e080f0365707e" translate="yes" xml:space="preserve">
          <source>Windows::flat_map</source>
          <target state="translated">Windows::flat_map</target>
        </trans-unit>
        <trans-unit id="f4d8fa17f7d4e22990b8c1303515ad7b41c0e51e" translate="yes" xml:space="preserve">
          <source>Windows::flatten</source>
          <target state="translated">Windows::flatten</target>
        </trans-unit>
        <trans-unit id="d2eb04619a69bf18cec3a67a06b479df0576a42c" translate="yes" xml:space="preserve">
          <source>Windows::fmt</source>
          <target state="translated">Windows::fmt</target>
        </trans-unit>
        <trans-unit id="d8a195c51acf16c6aadba984188c415f5441b6c3" translate="yes" xml:space="preserve">
          <source>Windows::fold</source>
          <target state="translated">Windows::fold</target>
        </trans-unit>
        <trans-unit id="01cdc502497ab9b03d2f83fa2d0871f8abb0994a" translate="yes" xml:space="preserve">
          <source>Windows::for_each</source>
          <target state="translated">Windows::for_each</target>
        </trans-unit>
        <trans-unit id="6108a137a74f4bd608fc702807fd0e17b7abd278" translate="yes" xml:space="preserve">
          <source>Windows::from</source>
          <target state="translated">Windows::from</target>
        </trans-unit>
        <trans-unit id="8f30f87a1c9a02e1fb27ac6fe719069f8e122330" translate="yes" xml:space="preserve">
          <source>Windows::fuse</source>
          <target state="translated">Windows::fuse</target>
        </trans-unit>
        <trans-unit id="67db02e23e968fbc8c51336185b95b9b96aec0fb" translate="yes" xml:space="preserve">
          <source>Windows::ge</source>
          <target state="translated">Windows::ge</target>
        </trans-unit>
        <trans-unit id="1b08a3c2211d2e64ecaa8d094412c20af26d6951" translate="yes" xml:space="preserve">
          <source>Windows::gt</source>
          <target state="translated">Windows::gt</target>
        </trans-unit>
        <trans-unit id="6a49da6e96f3901cd2e3f2a458b5df67e32fc1ac" translate="yes" xml:space="preserve">
          <source>Windows::inspect</source>
          <target state="translated">Windows::inspect</target>
        </trans-unit>
        <trans-unit id="dc89660cc21103f886ff9b7d6b842aa6ebb6eea2" translate="yes" xml:space="preserve">
          <source>Windows::into</source>
          <target state="translated">Windows::into</target>
        </trans-unit>
        <trans-unit id="7dc827a9516a85386bc0443ac7acf8dbdc207267" translate="yes" xml:space="preserve">
          <source>Windows::into_iter</source>
          <target state="translated">Windows::into_iter</target>
        </trans-unit>
        <trans-unit id="3bf9a277de1f84adeaec35fb62966d1d7c35ff91" translate="yes" xml:space="preserve">
          <source>Windows::is_empty</source>
          <target state="translated">Windows::is_empty</target>
        </trans-unit>
        <trans-unit id="0f4e75134f8d11b4a570702cb97bdd5515869f82" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted</source>
          <target state="translated">Windows::is_sorted</target>
        </trans-unit>
        <trans-unit id="e74da52cc5b534ed59329d25635be3609f0336ec" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by</source>
          <target state="translated">Windows::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="396da8bc74081a0a8716a03e2ec0b64081b2263f" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by_key</source>
          <target state="translated">Windows::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8bbf67cd900972eb007b6f354b425cc5682d90e0" translate="yes" xml:space="preserve">
          <source>Windows::last</source>
          <target state="translated">Windows::last</target>
        </trans-unit>
        <trans-unit id="edfebb32722bfb5c8d9922b27c21e2ad57bf0c3b" translate="yes" xml:space="preserve">
          <source>Windows::le</source>
          <target state="translated">Windows::le</target>
        </trans-unit>
        <trans-unit id="5b0f7e7a7b44222bd3e3f54b200e29b7293b2aa2" translate="yes" xml:space="preserve">
          <source>Windows::len</source>
          <target state="translated">Windows::len</target>
        </trans-unit>
        <trans-unit id="f84b680a03923cb8668b70cb3d48a10366b725cb" translate="yes" xml:space="preserve">
          <source>Windows::lt</source>
          <target state="translated">Windows::lt</target>
        </trans-unit>
        <trans-unit id="211653c7638da6256828c029f6bdbbd39290d614" translate="yes" xml:space="preserve">
          <source>Windows::map</source>
          <target state="translated">Windows::map</target>
        </trans-unit>
        <trans-unit id="da3645101a0d749919ba6caacb64cbf6bb5ab932" translate="yes" xml:space="preserve">
          <source>Windows::max</source>
          <target state="translated">Windows::max</target>
        </trans-unit>
        <trans-unit id="6faf7c5f10fa19e5856c7c741e0f6e00ec43ac89" translate="yes" xml:space="preserve">
          <source>Windows::max_by</source>
          <target state="translated">Windows::max_by</target>
        </trans-unit>
        <trans-unit id="a97eb7a3a210c7918ea8d0750c43c0be36a4f490" translate="yes" xml:space="preserve">
          <source>Windows::max_by_key</source>
          <target state="translated">Windows::max_by_key</target>
        </trans-unit>
        <trans-unit id="85afd294e1c8b3ac152c12583d70b807752d21c5" translate="yes" xml:space="preserve">
          <source>Windows::min</source>
          <target state="translated">Windows::min</target>
        </trans-unit>
        <trans-unit id="9851ad95c0803c7379f60e880e611d24b73dd771" translate="yes" xml:space="preserve">
          <source>Windows::min_by</source>
          <target state="translated">Windows::min_by</target>
        </trans-unit>
        <trans-unit id="d2ffacc1b47b99ed28eab58435af4f27856f1432" translate="yes" xml:space="preserve">
          <source>Windows::min_by_key</source>
          <target state="translated">Windows::min_by_key</target>
        </trans-unit>
        <trans-unit id="bd27f7b2dd977463e705864279f5215a8693dcf1" translate="yes" xml:space="preserve">
          <source>Windows::ne</source>
          <target state="translated">Windows::ne</target>
        </trans-unit>
        <trans-unit id="07ea4a2a4bc2affb3d5f44891b5f320bb57788cf" translate="yes" xml:space="preserve">
          <source>Windows::next</source>
          <target state="translated">Windows::next</target>
        </trans-unit>
        <trans-unit id="5df573867c1237a7c0cadeeaaef6362ce41599cb" translate="yes" xml:space="preserve">
          <source>Windows::next_back</source>
          <target state="translated">Windows::next_back</target>
        </trans-unit>
        <trans-unit id="884d14d5f8a19f0db064d5b33b9b17b75a3d8a57" translate="yes" xml:space="preserve">
          <source>Windows::nth</source>
          <target state="translated">Windows::nth</target>
        </trans-unit>
        <trans-unit id="d9ece61aa05f950e8c21d253603cec8c4927666f" translate="yes" xml:space="preserve">
          <source>Windows::nth_back</source>
          <target state="translated">Windows::nth_back</target>
        </trans-unit>
        <trans-unit id="e2337e7096b09ea74ce36d188b9ca860a5770051" translate="yes" xml:space="preserve">
          <source>Windows::partial_cmp</source>
          <target state="translated">Windows::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b234418f227a17c704174f2bef5739ac92992b03" translate="yes" xml:space="preserve">
          <source>Windows::partition</source>
          <target state="translated">Windows::partition</target>
        </trans-unit>
        <trans-unit id="9be20298e80cbaffa477f416ccc86f737f3f8d78" translate="yes" xml:space="preserve">
          <source>Windows::peekable</source>
          <target state="translated">Windows::peekable</target>
        </trans-unit>
        <trans-unit id="45529696a341be706214708f3fbab21c7d0b23fd" translate="yes" xml:space="preserve">
          <source>Windows::position</source>
          <target state="translated">Windows::position</target>
        </trans-unit>
        <trans-unit id="59fc20664973429ad195ba2d8aed0ddf546bb2a2" translate="yes" xml:space="preserve">
          <source>Windows::product</source>
          <target state="translated">Windows::product</target>
        </trans-unit>
        <trans-unit id="50734bb415bc20fe6568bfd1dd1f63f6b93fe949" translate="yes" xml:space="preserve">
          <source>Windows::rev</source>
          <target state="translated">Windows::rev</target>
        </trans-unit>
        <trans-unit id="530fe46767d842dcb4f66462626de45b73ad15f2" translate="yes" xml:space="preserve">
          <source>Windows::rfind</source>
          <target state="translated">Windows::rfind</target>
        </trans-unit>
        <trans-unit id="a36a85b42116649c6a0ad782c4af43ce9da0a6d2" translate="yes" xml:space="preserve">
          <source>Windows::rfold</source>
          <target state="translated">Windows::rfold</target>
        </trans-unit>
        <trans-unit id="6b46a39965804836e499e246c032f1e49efe2b08" translate="yes" xml:space="preserve">
          <source>Windows::rposition</source>
          <target state="translated">Windows::rposition</target>
        </trans-unit>
        <trans-unit id="3085a5deaa7e492e694960ff9a8bb11a44fea77b" translate="yes" xml:space="preserve">
          <source>Windows::scan</source>
          <target state="translated">Windows::scan</target>
        </trans-unit>
        <trans-unit id="600168ee422d0b4058643289d6f5f44a0cc41069" translate="yes" xml:space="preserve">
          <source>Windows::size_hint</source>
          <target state="translated">Windows::size_hint</target>
        </trans-unit>
        <trans-unit id="60a31deba53a9144f8f111c1a535404922718781" translate="yes" xml:space="preserve">
          <source>Windows::skip</source>
          <target state="translated">Windows::skip</target>
        </trans-unit>
        <trans-unit id="f0c88d1e74fd2619b821ca5f9314adc478f85906" translate="yes" xml:space="preserve">
          <source>Windows::skip_while</source>
          <target state="translated">Windows::skip_while</target>
        </trans-unit>
        <trans-unit id="43319d488bcd123c09eddf08cef6849d9980eba7" translate="yes" xml:space="preserve">
          <source>Windows::step_by</source>
          <target state="translated">Windows::step_by</target>
        </trans-unit>
        <trans-unit id="9672bcfc100f3ac44dec88d4d85716df442fe940" translate="yes" xml:space="preserve">
          <source>Windows::sum</source>
          <target state="translated">Windows::sum</target>
        </trans-unit>
        <trans-unit id="7df17ff1135505a96dab1d9f8ef57748282788e2" translate="yes" xml:space="preserve">
          <source>Windows::take</source>
          <target state="translated">Windows::take</target>
        </trans-unit>
        <trans-unit id="1e57647d418ad6082e9d4ee5291c1745f789d2e8" translate="yes" xml:space="preserve">
          <source>Windows::take_while</source>
          <target state="translated">Windows::take_while</target>
        </trans-unit>
        <trans-unit id="8f55f6ef559f032eb73be76c2b09a5737e416d5c" translate="yes" xml:space="preserve">
          <source>Windows::to_owned</source>
          <target state="translated">Windows::to_owned</target>
        </trans-unit>
        <trans-unit id="81cbe418ab3685420d683bda86fea704938b8a31" translate="yes" xml:space="preserve">
          <source>Windows::try_fold</source>
          <target state="translated">Windows::try_fold</target>
        </trans-unit>
        <trans-unit id="b4c27872e29ca09f92a33f4478a1eff0aea539bb" translate="yes" xml:space="preserve">
          <source>Windows::try_for_each</source>
          <target state="translated">Windows::try_for_each</target>
        </trans-unit>
        <trans-unit id="171fea351be781be4e02e711fd24294e453b5b91" translate="yes" xml:space="preserve">
          <source>Windows::try_from</source>
          <target state="translated">Windows::try_from</target>
        </trans-unit>
        <trans-unit id="9220c38d1fb3ec5be1fd9df5b83c243f1caa3ba1" translate="yes" xml:space="preserve">
          <source>Windows::try_into</source>
          <target state="translated">Windows::try_into</target>
        </trans-unit>
        <trans-unit id="92ba387998e4a086247665261fda5122f9f9029e" translate="yes" xml:space="preserve">
          <source>Windows::try_rfold</source>
          <target state="translated">Windows::try_rfold</target>
        </trans-unit>
        <trans-unit id="ff8171358582a1c7e6fe713b6c5031c85fcf7da9" translate="yes" xml:space="preserve">
          <source>Windows::type_id</source>
          <target state="translated">Windows::type_id</target>
        </trans-unit>
        <trans-unit id="ef934a80a8453f69945f5830a3ed61e3b0c17061" translate="yes" xml:space="preserve">
          <source>Windows::unzip</source>
          <target state="translated">Windows::unzip</target>
        </trans-unit>
        <trans-unit id="fc3d2052b8855f4dd5b69c5898112a4724165849" translate="yes" xml:space="preserve">
          <source>Windows::zip</source>
          <target state="translated">Windows::zip</target>
        </trans-unit>
        <trans-unit id="38dc69622ed00aee21cdcf0fd074e253d0cf7005" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">С &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;эти макросы предоставляют разработчикам отладочную информацию о местоположении в источнике.</target>
        </trans-unit>
        <trans-unit id="0ec53663cefb4388138a07773bc9d9c40923307a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">С &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;эти макросы предоставляют разработчикам отладочную информацию о местоположении в источнике.</target>
        </trans-unit>
        <trans-unit id="815b1bf6287da2f53b57957c1e78d170fa30a354" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">С &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;эти макросы предоставляют разработчикам отладочную информацию о местоположении в источнике.</target>
        </trans-unit>
        <trans-unit id="04eb7504cabe503a97d0c1acdec5be3b9053e741" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Infallible&lt;/code&gt; being an enum, this code is valid. However when &lt;code&gt;Infallible&lt;/code&gt; becomes an alias for the never type, the two &lt;code&gt;impl&lt;/code&gt;s will start to overlap and therefore will be disallowed by the language&amp;rsquo;s trait coherence rules.</source>
          <target state="translated">Если &lt;code&gt;Infallible&lt;/code&gt; является перечислением, этот код действителен. Однако, когда &lt;code&gt;Infallible&lt;/code&gt; становится псевдонимом для типа never, два &lt;code&gt;impl&lt;/code&gt; начнут перекрываться и, следовательно, будут запрещены правилами согласованности характеристик языка.</target>
        </trans-unit>
        <trans-unit id="0eafffeebea0c3842266dddbb6f397a2037dca13" translate="yes" xml:space="preserve">
          <source>With CMD on Windows, you would enter the following:</source>
          <target state="translated">При использовании CMD в Windows вы вводите следующее:</target>
        </trans-unit>
        <trans-unit id="c67b427f4a43407481fdbe0434a6fd74d6c08115" translate="yes" xml:space="preserve">
          <source>With Rust&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; range syntax, if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:</source>
          <target state="translated">При использовании синтаксиса Rust &lt;code&gt;..&lt;/code&gt; range, если вы хотите начать с первого индекса (нуля), вы можете отбросить значение до двух точек. Другими словами, они равны:</target>
        </trans-unit>
        <trans-unit id="e6848246eb0a467aba8b63d5b96e2ddd94bde183" translate="yes" xml:space="preserve">
          <source>With a basic understanding of threads and the thread API, let&amp;rsquo;s look at what we can &lt;em&gt;do&lt;/em&gt; with threads.</source>
          <target state="translated">Имея базовое представление о потоках и API потоков, давайте посмотрим, что мы можем &lt;em&gt;делать&lt;/em&gt; с потоками.</target>
        </trans-unit>
        <trans-unit id="b24837e9bbb4a3f319a132114baf06eda4b2e88c" translate="yes" xml:space="preserve">
          <source>With a method call:</source>
          <target state="translated">С помощью вызова метода:</target>
        </trans-unit>
        <trans-unit id="5ec0502a02d896b78bc96b2798e0767135b5c8c9" translate="yes" xml:space="preserve">
          <source>With a pathname:</source>
          <target state="translated">С отчеком:</target>
        </trans-unit>
        <trans-unit id="f37d3365310acb52cb4a4d469a50deacc72ef16e" translate="yes" xml:space="preserve">
          <source>With a unique name, the version, the author details that &lt;code&gt;cargo new&lt;/code&gt; added when you created the crate, your description, and a license added, the &lt;em&gt;Cargo.toml&lt;/em&gt; file for a project that is ready to publish might look like this:</source>
          <target state="translated">С уникальным именем, версией, детали автора , что &lt;code&gt;cargo new&lt;/code&gt; добавляемые при создании клети, ваше описания и лицензии добавлена, &lt;em&gt;Cargo.toml&lt;/em&gt; файл для проекта , который готов опубликовать может выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="33d3ef8879647cae82afb7b344de4fdc8e49a8b3" translate="yes" xml:space="preserve">
          <source>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you&amp;rsquo;ll see in the next section, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;Calling an Unsafe Function or Method.&amp;rdquo;&lt;/a&gt; Another case is when building up safe abstractions that the borrow checker doesn&amp;rsquo;t understand. We&amp;rsquo;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</source>
          <target state="translated">Зачем при всех этих опасностях использовать необработанные указатели? Одним из основных вариантов использования является взаимодействие с кодом C, как вы увидите в следующем разделе &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;laquo;Вызов небезопасной функции или метода&amp;raquo;. &lt;/a&gt;Другой случай - создание безопасных абстракций, которые программа проверки заимствований не понимает. Мы представим небезопасные функции, а затем рассмотрим пример безопасной абстракции, использующей небезопасный код.</target>
        </trans-unit>
        <trans-unit id="a402171e60da25e2d20aa541a5e736d082a2894a" translate="yes" xml:space="preserve">
          <source>With all the changes we&amp;rsquo;ve made, our code compiles without any warnings. But the bad news is this code doesn&amp;rsquo;t function the way we want it to yet. The key is the logic in the closures run by the threads of the &lt;code&gt;Worker&lt;/code&gt; instances: at the moment, we call &lt;code&gt;join&lt;/code&gt;, but that won&amp;rsquo;t shut down the threads because they &lt;code&gt;loop&lt;/code&gt; forever looking for jobs. If we try to drop our &lt;code&gt;ThreadPool&lt;/code&gt; with our current implementation of &lt;code&gt;drop&lt;/code&gt;, the main thread will block forever waiting for the first thread to finish.</source>
          <target state="translated">Со всеми внесенными нами изменениями наш код компилируется без каких-либо предупреждений. Но плохая новость в том, что этот код еще не работает так, как нам хотелось бы. Ключ - это логика замыканий, выполняемых потоками экземпляров &lt;code&gt;Worker&lt;/code&gt; : на данный момент мы вызываем &lt;code&gt;join&lt;/code&gt; , но это не остановит потоки, потому что они постоянно &lt;code&gt;loop&lt;/code&gt; поиске заданий. Если мы попытаемся отбросить &lt;code&gt;ThreadPool&lt;/code&gt; с помощью нашей текущей реализации &lt;code&gt;drop&lt;/code&gt; , основной поток навсегда заблокируется, ожидая завершения первого потока.</target>
        </trans-unit>
        <trans-unit id="3e478a9c9aaa53e1f24932c1bf11ee27b2b756f9" translate="yes" xml:space="preserve">
          <source>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the &lt;code&gt;rlib&lt;/code&gt; format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</source>
          <target state="translated">При всех этих различных видах выходных данных, если ящик A зависит от контейнера B, компилятор может найти B в различных формах по всей системе. Однако компилятор &lt;code&gt;rlib&lt;/code&gt; только формы rlib и динамические библиотеки. С этими двумя вариантами для зависимой библиотеки компилятор должен в какой-то момент сделать выбор между этими двумя форматами. Имея это в виду, компилятор следует этим правилам при определении того, какой формат зависимостей будет использоваться:</target>
        </trans-unit>
        <trans-unit id="1b779befcd3540151b782d4543ae930ae53755ec" translate="yes" xml:space="preserve">
          <source>With all this information in mind, let&amp;rsquo;s rewrite &lt;code&gt;first_word&lt;/code&gt; to return a slice. The type that signifies &amp;ldquo;string slice&amp;rdquo; is written as &lt;code&gt;&amp;amp;str&lt;/code&gt;:</source>
          <target state="translated">Имея в виду всю эту информацию, давайте перепишем &lt;code&gt;first_word&lt;/code&gt; , чтобы вернуть срез. Тип, обозначающий &amp;laquo;строковый фрагмент&amp;raquo;, записывается как &lt;code&gt;&amp;amp;str&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb10c6677d4a9c4ac3a69e9072ac5b7bbbfc8ab3" translate="yes" xml:space="preserve">
          <source>With an associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e91fb00c7adb5b470a7e84f143a4420eb3479d" translate="yes" xml:space="preserve">
          <source>With associated types, we don&amp;rsquo;t need to annotate types because we can&amp;rsquo;t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of &lt;code&gt;Item&lt;/code&gt; will be once, because there can only be one &lt;code&gt;impl Iterator for Counter&lt;/code&gt;. We don&amp;rsquo;t have to specify that we want an iterator of &lt;code&gt;u32&lt;/code&gt; values everywhere that we call &lt;code&gt;next&lt;/code&gt; on &lt;code&gt;Counter&lt;/code&gt;.</source>
          <target state="translated">Со связанными типами нам не нужно аннотировать типы, потому что мы не можем реализовать признак для типа несколько раз. В листинге 19-12 с определением, использующим связанные типы, мы можем выбрать только один тип &lt;code&gt;Item&lt;/code&gt; , потому что &lt;code&gt;impl Iterator for Counter&lt;/code&gt; может быть только один impl Iterator . Нам не нужно указывать, что нам нужен итератор значений &lt;code&gt;u32&lt;/code&gt; везде, где мы вызываем &lt;code&gt;next&lt;/code&gt; в &lt;code&gt;Counter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a53dfae04bc081765c66dac442860f331c44aeb" translate="yes" xml:space="preserve">
          <source>With mutable data that is globally accessible, it&amp;rsquo;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it&amp;rsquo;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</source>
          <target state="translated">С изменяемыми данными, которые доступны глобально, трудно гарантировать отсутствие гонок данных, поэтому Rust считает изменяемые статические переменные небезопасными. Там, где это возможно, предпочтительно использовать методы параллелизма и потокобезопасные интеллектуальные указатели, которые мы обсуждали в главе 16, чтобы компилятор проверял безопасность данных, доступ к которым осуществляется из разных потоков.</target>
        </trans-unit>
        <trans-unit id="ef733904e440fafdfd6f6cff1f3753a02bb10342" translate="yes" xml:space="preserve">
          <source>With our new knowledge about iterators, we can change the &lt;code&gt;new&lt;/code&gt; function to take ownership of an iterator as its argument instead of borrowing a slice. We&amp;rsquo;ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the &lt;code&gt;Config::new&lt;/code&gt; function is doing because the iterator will access the values.</source>
          <target state="translated">Обладая новыми знаниями об итераторах, мы можем изменить &lt;code&gt;new&lt;/code&gt; функцию, чтобы взять на себя итератор в качестве аргумента вместо заимствования фрагмента. Мы будем использовать функцию итератора вместо кода, который проверяет длину фрагмента и индексирует его в определенных местах. Это прояснит, что делает функция &lt;code&gt;Config::new&lt;/code&gt; , потому что итератор будет обращаться к значениям.</target>
        </trans-unit>
        <trans-unit id="813d416dedfb40190d58c273de8f8eb75ea3340b" translate="yes" xml:space="preserve">
          <source>With real world traits these numbers can grow drastically.</source>
          <target state="translated">В реальном мире эти цифры могут резко вырасти.</target>
        </trans-unit>
        <trans-unit id="b72f5cb005021c9be16f1dc058fb74107683aac5" translate="yes" xml:space="preserve">
          <source>With references and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, the borrowing rules&amp;rsquo; invariants are enforced at compile time. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, these invariants are enforced &lt;em&gt;at runtime&lt;/em&gt;. With references, if you break these rules, you&amp;rsquo;ll get a compiler error. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, if you break these rules, your program will panic and exit.</source>
          <target state="translated">С помощью ссылок и &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; инварианты правил заимствования применяются во время компиляции. С &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; эти инварианты применяются &lt;em&gt;во время выполнения&lt;/em&gt; . Со ссылками, если вы нарушите эти правила, вы получите ошибку компилятора. При использовании &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , если вы нарушите эти правила, ваша программа выйдет из строя.</target>
        </trans-unit>
        <trans-unit id="9baf0229e3e9e6c893294479bb6fe3668b3a0c0e" translate="yes" xml:space="preserve">
          <source>With simple projects, Cargo doesn&amp;rsquo;t provide a lot of value over just using &lt;code&gt;rustc&lt;/code&gt;, but it will prove its worth as your programs become more intricate. With complex projects composed of multiple crates, it&amp;rsquo;s much easier to let Cargo coordinate the build.</source>
          <target state="translated">В простых проектах Cargo не представляет &lt;code&gt;rustc&lt;/code&gt; ценности по сравнению с простым использованием rustc , но он докажет свою ценность, когда ваши программы станут более сложными. В сложных проектах, состоящих из нескольких ящиков, гораздо проще позволить Cargo координировать сборку.</target>
        </trans-unit>
        <trans-unit id="498cc75c7709fdab78e1cc82cb0379d4fbbfc2cc" translate="yes" xml:space="preserve">
          <source>With stdin:</source>
          <target state="translated">Со вторым:</target>
        </trans-unit>
        <trans-unit id="06224dc60392a0fce212359437fb5cee57ac9f42" translate="yes" xml:space="preserve">
          <source>With stdout:</source>
          <target state="translated">С вчерашним днём:</target>
        </trans-unit>
        <trans-unit id="93ea5ac4258ad8d0735b4be8347a757702850e37" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;String&lt;/code&gt; type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</source>
          <target state="translated">Для типа &lt;code&gt;String&lt;/code&gt; , чтобы поддерживать изменяемый, растущий фрагмент текста, нам необходимо выделить в куче объем памяти, неизвестный во время компиляции, для хранения содержимого. Это означает:</target>
        </trans-unit>
        <trans-unit id="e41ed52cf940fa02215dfc776f98dffa8f13fd94" translate="yes" xml:space="preserve">
          <source>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</source>
          <target state="translated">С помощью приведенной выше спецификации мы можем представить аргументы в пользу того,почему определенные матчи являются законными,а другие-нет.</target>
        </trans-unit>
        <trans-unit id="9c5fab965ba18f74e15ee6e594f51c165aae934a" translate="yes" xml:space="preserve">
          <source>With the closure defined, we can change the code in the &lt;code&gt;if&lt;/code&gt; blocks to call the closure to execute the code and get the resulting value. We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</source>
          <target state="translated">Определив замыкание, мы можем изменить код в блоках &lt;code&gt;if&lt;/code&gt; , чтобы вызвать замыкание для выполнения кода и получения результирующего значения. Мы вызываем замыкание, как функцию: мы указываем имя переменной, которая содержит определение замыкания, и следуем за ним круглыми скобками, содержащими значения аргументов, которые мы хотим использовать, как показано в листинге 13-6.</target>
        </trans-unit>
        <trans-unit id="01c46a1d067cb86c80a793fada3c4bf6ccb8375e" translate="yes" xml:space="preserve">
          <source>With the implementation of this trick, our thread pool is in a working state! Give it a &lt;code&gt;cargo run&lt;/code&gt; and make some requests:</source>
          <target state="translated">После реализации этого трюка наш пул потоков находится в рабочем состоянии! Дайте ему &lt;code&gt;cargo run&lt;/code&gt; и сделайте несколько запросов:</target>
        </trans-unit>
        <trans-unit id="24a7fa0675f3c1ff0574c22a8d3081db443c0de4" translate="yes" xml:space="preserve">
          <source>With the notion of an item being either public or private, Rust allows item accesses in two cases:</source>
          <target state="translated">Учитывая,что объект является либо общественным,либо частным,Rust разрешает доступ к нему в двух случаях:</target>
        </trans-unit>
        <trans-unit id="bc6738ca71c4d0da46b8887fed6bda41f9aa0556" translate="yes" xml:space="preserve">
          <source>With the remaining program logic separated into the &lt;code&gt;run&lt;/code&gt; function, we can improve the error handling, as we did with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-9. Instead of allowing the program to panic by calling &lt;code&gt;expect&lt;/code&gt;, the &lt;code&gt;run&lt;/code&gt; function will return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; when something goes wrong. This will let us further consolidate into &lt;code&gt;main&lt;/code&gt; the logic around handling errors in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">Разделив оставшуюся программную логику на функцию &lt;code&gt;run&lt;/code&gt; , мы можем улучшить обработку ошибок, как мы это сделали с &lt;code&gt;Config::new&lt;/code&gt; в листинге 12-9. Вместо того, чтобы позволить программе паниковать, вызывая &lt;code&gt;expect&lt;/code&gt; , функция &lt;code&gt;run&lt;/code&gt; вернет &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; когда что-то пойдет не так. Это позволит нам в дальнейшем объединить в &lt;code&gt;main&lt;/code&gt; логику обработки ошибок удобным для пользователя способом. В листинге 12-12 показаны изменения, которые нам нужно внести в подпись и тело &lt;code&gt;run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34d45efbbc694df1116b7475884bd1d2fd47f1c6" translate="yes" xml:space="preserve">
          <source>With the state pattern, the &lt;code&gt;Post&lt;/code&gt; methods and the places we use &lt;code&gt;Post&lt;/code&gt; don&amp;rsquo;t need &lt;code&gt;match&lt;/code&gt; expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</source>
          <target state="translated">С государственной формой, то &lt;code&gt;Post&lt;/code&gt; метода и место , которые мы используем &lt;code&gt;Post&lt;/code&gt; не обязательно &lt;code&gt;match&lt;/code&gt; выражения, а также добавить новое состояние, мы должны были бы только добавить новую структуру и реализовать методы на этой черт реальных одной структуру.</target>
        </trans-unit>
        <trans-unit id="83ff23e8afd931a2cd544c6885efa1601bab61bb" translate="yes" xml:space="preserve">
          <source>With the text in place, edit &lt;em&gt;src/main.rs&lt;/em&gt; and add code to read the file, as shown in Listing 12-4.</source>
          <target state="translated">&lt;em&gt;Поместив&lt;/em&gt; текст на место, отредактируйте &lt;em&gt;src / main.rs&lt;/em&gt; и добавьте код для чтения файла, как показано в листинге 12-4.</target>
        </trans-unit>
        <trans-unit id="e0b0d0d55bb8949af2866594443ea68c01592e9d" translate="yes" xml:space="preserve">
          <source>With the two trait bounds specified, the body of &lt;code&gt;notify&lt;/code&gt; can call &lt;code&gt;summarize&lt;/code&gt; and use &lt;code&gt;{}&lt;/code&gt; to format &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">Если указаны две границы признака, тело &lt;code&gt;notify&lt;/code&gt; может вызывать &lt;code&gt;summarize&lt;/code&gt; и использовать &lt;code&gt;{}&lt;/code&gt; для форматирования &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7deae3df9bc9dd91ed2ed3e73a23c867198988dd" translate="yes" xml:space="preserve">
          <source>With these changes, let&amp;rsquo;s run our code and make a request. We&amp;rsquo;re no longer printing any data to the terminal, so we won&amp;rsquo;t see any output other than the output from Cargo. When you load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser, you should get a blank page instead of an error. You&amp;rsquo;ve just hand-coded an HTTP request and response!</source>
          <target state="translated">С этими изменениями давайте запустим наш код и сделаем запрос. Мы больше не печатаем данные в терминал, поэтому мы не увидим никаких выходных данных, кроме выходных данных Cargo. Когда вы загружаете &lt;em&gt;127.0.0.1:7878&lt;/em&gt; в веб-браузере, вы должны получить пустую страницу вместо ошибки. Вы только что вручную написали HTTP-запрос и ответ!</target>
        </trans-unit>
        <trans-unit id="2b8a9662a9a062dbd858ec248c6bcfe6e17a1e8d" translate="yes" xml:space="preserve">
          <source>With these changes, run your server again. Requesting &lt;em&gt;127.0.0.1:7878&lt;/em&gt; should return the contents of &lt;em&gt;hello.html&lt;/em&gt;, and any other request, like &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;, should return the error HTML from &lt;em&gt;404.html&lt;/em&gt;.</source>
          <target state="translated">С этими изменениями снова запустите свой сервер. Запрос &lt;em&gt;127.0.0.1:7878&lt;/em&gt; должен возвращать содержимое &lt;em&gt;hello.html&lt;/em&gt; , а любой другой запрос, например &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt; , должен возвращать HTML- &lt;em&gt;код&lt;/em&gt; ошибки из &lt;em&gt;404.html&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ea5830e4d89ce20b87325d5feaac7885edd633" translate="yes" xml:space="preserve">
          <source>With these changes, the code compiles! We&amp;rsquo;re getting there!</source>
          <target state="translated">С этими изменениями код компилируется! Мы приближаемся!</target>
        </trans-unit>
        <trans-unit id="64e9859cf60a37b6fd6185bea427eb35dd3442b4" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-20. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa98175f3edbe33adc271e61ac4777981eaf67" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-25.</source>
          <target state="translated">С этими изменениями код будет компилироваться и продолжать работать так же, как и после Листинга 20-21. Но мы получим предупреждение, потому что мы не создаем никаких сообщений типа &lt;code&gt;Terminate&lt;/code&gt; . Давайте исправим это предупреждение, изменив нашу реализацию &lt;code&gt;Drop&lt;/code&gt; , чтобы она выглядела как Листинг 20-25.</target>
        </trans-unit>
        <trans-unit id="86aa3b5dba5f873b63c48b4c86a229ed1fbfd4e1" translate="yes" xml:space="preserve">
          <source>With these extra few lines of code in &lt;code&gt;new&lt;/code&gt;, let&amp;rsquo;s run the program without any arguments again to see what the error looks like now:</source>
          <target state="translated">С этими дополнительными несколькими строками кода в &lt;code&gt;new&lt;/code&gt; , давайте снова запустим программу без каких-либо аргументов, чтобы увидеть, как теперь выглядит ошибка:</target>
        </trans-unit>
        <trans-unit id="96fe782e8597a2f8b432d3a608914c807144f829" translate="yes" xml:space="preserve">
          <source>With this added &lt;code&gt;content&lt;/code&gt; method, everything in Listing 17-11 up to line 7 works as intended.</source>
          <target state="translated">С этим добавленным методом &lt;code&gt;content&lt;/code&gt; все в листинге 17-11 до строки 7 работает как задумано.</target>
        </trans-unit>
        <trans-unit id="6a69a998d97d76e52647bdd19719b61356e441e9" translate="yes" xml:space="preserve">
          <source>With this approach, x and y share ownership of the data via the &lt;code&gt;Rc&lt;/code&gt; (reference count type). &lt;code&gt;RefCell&lt;/code&gt; essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</source>
          <target state="translated">При таком подходе x и y разделяют владение данными через &lt;code&gt;Rc&lt;/code&gt; (тип счетчика ссылок). &lt;code&gt;RefCell&lt;/code&gt; ,по сути, выполняет проверку заимствования во время выполнения: гарантируя, что не более одного модуля записи или нескольких считывателей могут получить доступ к данным одновременно.</target>
        </trans-unit>
        <trans-unit id="e0294acc426b53e8eefb85526ce41c8bfef32085" translate="yes" xml:space="preserve">
          <source>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let&amp;rsquo;s look at how iterators can improve our implementation of the &lt;code&gt;Config::new&lt;/code&gt; function and the &lt;code&gt;search&lt;/code&gt; function.</source>
          <target state="translated">Обладая этими новыми знаниями об итераторах, мы можем улучшить проект ввода-вывода в главе 12, используя итераторы, чтобы сделать места в коде более ясными и краткими. Давайте посмотрим, как итераторы могут улучшить нашу реализацию функции &lt;code&gt;Config::new&lt;/code&gt; функции &lt;code&gt;search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2fb8bb90dda22d23945c9584750688009a769c8" translate="yes" xml:space="preserve">
          <source>With this:</source>
          <target state="translated">С этим:</target>
        </trans-unit>
        <trans-unit id="f92b2fe5b7dcaebe110b80babf1c63cd9fdd43ef" translate="yes" xml:space="preserve">
          <source>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We&amp;rsquo;ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</source>
          <target state="translated">С добавлением аннотаций типов синтаксис замыканий больше похож на синтаксис функций. Ниже приведено вертикальное сравнение синтаксиса определения функции, которая добавляет 1 к своему параметру, и замыкания, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, насколько синтаксис закрытия похож на синтаксис функции, за исключением использования каналов и количества синтаксиса, который является необязательным:</target>
        </trans-unit>
        <trans-unit id="e12bdc1ee24b9c9117113f7fd06a681041f0f8ca" translate="yes" xml:space="preserve">
          <source>With values that have many parts, we can use the &lt;code&gt;..&lt;/code&gt; syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. The &lt;code&gt;..&lt;/code&gt; pattern ignores any parts of a value that we haven&amp;rsquo;t explicitly matched in the rest of the pattern. In Listing 18-23, we have a &lt;code&gt;Point&lt;/code&gt; struct that holds a coordinate in three-dimensional space. In the &lt;code&gt;match&lt;/code&gt; expression, we want to operate only on the &lt;code&gt;x&lt;/code&gt; coordinate and ignore the values in the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; fields.</source>
          <target state="translated">Для значений, состоящих из многих частей, мы можем использовать синтаксис &lt;code&gt;..&lt;/code&gt; , чтобы использовать только несколько частей и игнорировать остальные, избегая необходимости перечислять символы подчеркивания для каждого игнорируемого значения. &lt;code&gt;..&lt;/code&gt; модель игнорирует любые части значения , что мы явно не совпавшие в остальной части шаблона. В листинге 18-23 у нас есть структура &lt;code&gt;Point&lt;/code&gt; , которая содержит координату в трехмерном пространстве. В &lt;code&gt;match&lt;/code&gt; выражения, мы хотим работать только на &lt;code&gt;x&lt;/code&gt; координат и игнорировать значения в &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; полей.</target>
        </trans-unit>
        <trans-unit id="3392b1d08169948bc18f560cc78f42601ac7de77" translate="yes" xml:space="preserve">
          <source>Within a type definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bf9a3332dbb1aae191337d7acb72ccf285dc36" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, we list the names and signatures of external functions from another language we want to call. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; part defines which &lt;em&gt;application binary interface (ABI)&lt;/em&gt; the external function uses: the ABI defines how to call the function at the assembly level. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI is the most common and follows the C programming language&amp;rsquo;s ABI.</source>
          <target state="translated">Внутри блока &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; мы перечисляем имена и сигнатуры внешних функций из другого языка, который мы хотим вызвать. Часть &lt;code&gt;&quot;C&quot;&lt;/code&gt; определяет, какой &lt;em&gt;двоичный интерфейс приложения (ABI)&lt;/em&gt; использует внешняя функция: ABI определяет, как вызывать функцию на уровне сборки. &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI является наиболее распространенным и следует программирования C ABI языка.</target>
        </trans-unit>
        <trans-unit id="a3840b923c5773a4355bfcefff4121f0878713eb" translate="yes" xml:space="preserve">
          <source>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</source>
          <target state="translated">В теле элемента,имеющего объявления параметров типа,имена его параметров типа являются типами:</target>
        </trans-unit>
        <trans-unit id="3507a3f4edcb8828e19d61809f6ad4863c52a9ce" translate="yes" xml:space="preserve">
          <source>Within the defining crate, &lt;code&gt;non_exhaustive&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cad0f75b24acc004189d1ad1ae2454225184aa" translate="yes" xml:space="preserve">
          <source>Within this documentation's grammar, &quot;simple&quot; tokens are given in &lt;a href=&quot;notation#string-table-productions&quot;&gt;string table production&lt;/a&gt; form, and appear in &lt;code&gt;monospace&lt;/code&gt; font.</source>
          <target state="translated">В грамматике этой документации &amp;laquo;простые&amp;raquo; токены даются в виде &lt;a href=&quot;notation#string-table-productions&quot;&gt;таблицы строк&lt;/a&gt; и отображаются &lt;code&gt;monospace&lt;/code&gt; шрифтом.</target>
        </trans-unit>
        <trans-unit id="e7f884881293efc9c1f179ad8b3973e698991d41" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;compiler_fence&lt;/code&gt;, the &lt;code&gt;assert_eq!&lt;/code&gt; in following code is &lt;em&gt;not&lt;/em&gt; guaranteed to succeed, despite everything happening in a single thread. To see why, remember that the compiler is free to swap the stores to &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; and &lt;code&gt;IS_READ&lt;/code&gt; since they are both &lt;code&gt;Ordering::Relaxed&lt;/code&gt;. If it does, and the signal handler is invoked right after &lt;code&gt;IS_READY&lt;/code&gt; is updated, then the signal handler will see &lt;code&gt;IS_READY=1&lt;/code&gt;, but &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt;. Using a &lt;code&gt;compiler_fence&lt;/code&gt; remedies this situation.</source>
          <target state="translated">Без &lt;code&gt;compiler_fence&lt;/code&gt; , то &lt;code&gt;assert_eq!&lt;/code&gt; в следующем коде &lt;em&gt;не&lt;/em&gt; гарантируется успех, несмотря на то, что все происходит в одном потоке. Чтобы понять , почему, помните , что компилятор волен переставить магазины в &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; и &lt;code&gt;IS_READ&lt;/code&gt; , так как они оба &lt;code&gt;Ordering::Relaxed&lt;/code&gt; . Если это так, и обработчик сигнала вызывается сразу после обновления &lt;code&gt;IS_READY&lt;/code&gt; , тогда обработчик сигнала увидит &lt;code&gt;IS_READY=1&lt;/code&gt; , но IMPORTANT_VARIABLE &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt; . Использование &lt;code&gt;compiler_fence&lt;/code&gt; исправляет эту ситуацию.</target>
        </trans-unit>
        <trans-unit id="6823be3ffd83b17bd9d63c393e81d5a41ffc52cc" translate="yes" xml:space="preserve">
          <source>Without a loop to break out of or continue in, no sensible action can be taken. Please verify that you are using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; only in loops. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2efdc6add8e970dc1865be96d1f867d6e1b60c" translate="yes" xml:space="preserve">
          <source>Without a pathname:</source>
          <target state="translated">Без отчества:</target>
        </trans-unit>
        <trans-unit id="90c928ad5c0a871061baee534c7a9a3eec8a4645" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;Deref&lt;/code&gt; trait, the compiler can only dereference &lt;code&gt;&amp;amp;&lt;/code&gt; references. The &lt;code&gt;deref&lt;/code&gt; method gives the compiler the ability to take a value of any type that implements &lt;code&gt;Deref&lt;/code&gt; and call the &lt;code&gt;deref&lt;/code&gt; method to get a &lt;code&gt;&amp;amp;&lt;/code&gt; reference that it knows how to dereference.</source>
          <target state="translated">Без трейта &lt;code&gt;Deref&lt;/code&gt; компилятор может только разыменовать &lt;code&gt;&amp;amp;&lt;/code&gt; ссылаться. Метод &lt;code&gt;deref&lt;/code&gt; дает компилятору возможность принимать значение любого типа, реализующего &lt;code&gt;Deref&lt;/code&gt; , и вызывать метод &lt;code&gt;deref&lt;/code&gt; , чтобы получить ссылку &lt;code&gt;&amp;amp;&lt;/code&gt; , которую он знает, как разыменовать.</target>
        </trans-unit>
        <trans-unit id="87160e17882870214c0775aca97bd35e735c34ab" translate="yes" xml:space="preserve">
          <source>Working with Environment Variables</source>
          <target state="translated">Работа с переменными окружающей среды</target>
        </trans-unit>
        <trans-unit id="90e474d6c66232279cbf06723c1f38f471687b09" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</source>
          <target state="translated">Работа с сырыми указателями в ржавчине встречается редко,обычно ограничивается несколькими шаблонами.</target>
        </trans-unit>
        <trans-unit id="9a40e384f7f263637185bd19da70cd3d69e259e7" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns. Raw pointers can be unaligned or &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. However, when a raw pointer is dereferenced (using the &lt;code&gt;*&lt;/code&gt; operator), it must be non-null and aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727515b132b28daa88eb87eebc62a62072364288" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here are some important parts to focus on: the first inline error says &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The reason for this is in the next important part to focus on, the error message. The distilled error message says &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="translated">Вау, это сообщение об ошибке очень многословно! Вот несколько важных моментов, на которых следует сосредоточиться: первая встроенная ошибка говорит, что &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt; . Причина этого кроется в следующей важной части, на которой нужно сосредоточиться, - в сообщении об ошибке. В сообщении об ошибке говорится, &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt; . Мы поговорим о &lt;code&gt;Send&lt;/code&gt; в следующем разделе: это одна из черт, которая гарантирует, что типы, которые мы используем с потоками, предназначены для использования в параллельных ситуациях.</target>
        </trans-unit>
        <trans-unit id="71aebd97d81f1f2a97e5f18bfd8c471204fa376d" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here&amp;rsquo;s the important part to focus on: &lt;code&gt;`Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The compiler is also telling us the reason why: &lt;code&gt;the trait `Send` is not implemented for `Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` &lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130acb06cdbaff87c403e521823abb94f422c9e0" translate="yes" xml:space="preserve">
          <source>Wrap a value to be manually dropped.</source>
          <target state="translated">Оберните значение,которое нужно сбросить вручную.</target>
        </trans-unit>
        <trans-unit id="744e431b88ea1a0035f05b8fb26571f5315f1927" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">Оберните значение ОК, чтобы построить составной результат. Например, &lt;code&gt;Result::Ok(x)&lt;/code&gt; и &lt;code&gt;Result::from_ok(x)&lt;/code&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="a120e7e89eaa3b758fd2407bf284e593ba7d4ab0" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Оберните значение ОК, чтобы построить составной результат. Например, &lt;code&gt;Result::Ok(x)&lt;/code&gt; и &lt;code&gt;Result::from_ok(x)&lt;/code&gt; эквивалентны. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ba39a168910f0f4c9c0f953e5989879aa499399" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8c3f0758b57991ee8d44e4f6a9dc360915c844" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">Оберните значение ошибки, чтобы построить составной результат. Например, &lt;code&gt;Result::Err(x)&lt;/code&gt; и &lt;code&gt;Result::from_error(x)&lt;/code&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="b038d6e7a645f366cbf4e437083304bafb6bb808" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Оберните значение ошибки, чтобы построить составной результат. Например, &lt;code&gt;Result::Err(x)&lt;/code&gt; и &lt;code&gt;Result::from_error(x)&lt;/code&gt; эквивалентны. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="350a348893132c0e8f86200072eaac4fe18f553d" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="743cdade02c9bf9e30517f2de055980f9f8a86fb" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) absolute value. Computes &lt;code&gt;self.abs()&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Абсолютная величина упаковки (модульной). Вычисляет &lt;code&gt;self.abs()&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="f4efecec7c636af1ead7e0409272bc8b700c5382" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Упаковочное (модульное) дополнение. Вычисляет &lt;code&gt;self + rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="8112829180296558677473f537db1e33a076f93c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Оберточное (модульное) деление. Вычисляет &lt;code&gt;self / rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="3f6391833e153cf10bdb32314ca04ce9ce43dbdd" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">Оберточное (модульное) деление. Вычисляет &lt;code&gt;self / rhs&lt;/code&gt; . Обернутое деление на беззнаковые типы - это просто нормальное деление. Заворачивание никогда не могло произойти. Эта функция существует, поэтому все операции учитываются в операциях упаковки.</target>
        </trans-unit>
        <trans-unit id="d6bb89dd7e6026b10f235fa3863c6339f2fb774c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) exponentiation. Computes &lt;code&gt;self.pow(exp)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертывание (модульное) возведение в степень. Вычисляет &lt;code&gt;self.pow(exp)&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="e6b77bd3d8c54b47f23891885173c42858312a14" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Оберточное (модульное) умножение. Вычисляет &lt;code&gt;self * rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="2ad719d382b4d16912e1a91a3a59d2c050db5a30" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) negation. Computes &lt;code&gt;-self&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертка (модульное) отрицание. Вычисляет &lt;code&gt;-self&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="88feadfab016809fcd2984cfd9226aba00462cae" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Упаковка (модульная) остаток. Вычисляет &lt;code&gt;self % rhs&lt;/code&gt; , завершая границу типа.</target>
        </trans-unit>
        <trans-unit id="bab7a7fcc721ce6448649830e7166d7008062fd3" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">Упаковка (модульная) остаток. Вычисляет &lt;code&gt;self % rhs&lt;/code&gt; . Вычисление обернутого остатка для беззнаковых типов - это просто вычисление обычного остатка. Заворачивание никогда не могло произойти. Эта функция существует, поэтому все операции учитываются в операциях упаковки.</target>
        </trans-unit>
        <trans-unit id="0547792119ca778e4ded115060f8e8198122f4ee" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертывание (модульное) вычитание. Вычисляет &lt;code&gt;self - rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="9c70c48db93cbf30305f6f367392a85a748eb0d9" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Завершение евклидова деления. Вычисляет &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="0c397d89ed28af23471d1300df82f2628a5cc9eb" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt;.</source>
          <target state="translated">Завершение евклидова деления. Вычисляет &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; . Обернутое деление на беззнаковые типы - это просто нормальное деление. Заворачивание невозможно. Эта функция существует, поэтому все операции учитываются в операциях упаковки. Поскольку для положительных целых чисел все общие определения деления равны, это в точности равно &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a6d61ea92522854260430b74b8667bece5c095" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean modulo. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;. Wrapped modulo calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt;.</source>
          <target state="translated">Обертывание евклидова по модулю. Вычисляет &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; . Вычисление с оберткой по модулю для беззнаковых типов - это просто обычное вычисление остатка. Заворачивание никогда не могло произойти. Эта функция существует, поэтому все операции учитываются в операциях упаковки. Поскольку для положительных целых чисел все общие определения деления равны, это в точности равно &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c3f54557cafd34a10c40361aa84b7aedc96050" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean remainder. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертывание евклидова остатка. Вычисляет &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="c113027998f084fc650feeb5a7a7db8e8206e9c9" translate="yes" xml:space="preserve">
          <source>Wrapping arithmetic can be achieved either through methods like &lt;code&gt;wrapping_add&lt;/code&gt;, or through the &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</source>
          <target state="translated">Арифметика &lt;code&gt;wrapping_add&lt;/code&gt; может быть достигнута либо с помощью таких методов, как wrapping_add , либо с помощью типа &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; , который говорит о том, что все стандартные арифметические операции с базовым значением предназначены для использования семантики упаковки.</target>
        </trans-unit>
        <trans-unit id="67accd5f5a259bdba5036a1931f5ae6a264b08ff" translate="yes" xml:space="preserve">
          <source>Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe. This has the downside that if new captures are added in the future, they will also be considered unwind safe. Therefore, you may prefer to just wrap individual captures, as shown below. This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.</source>
          <target state="translated">Обертывание всего закрытия равнозначно общему утверждению о том,что все захваченные переменные безопасно разматываются.Недостатком этого является то,что если в будущем будут добавляться новые захваты,то они также будут считаться безопасными для размотки.Поэтому вы можете предпочесть просто обернуть отдельные захваты,как показано ниже.Это больше примечание,но оно гарантирует,что если будет добавлен новый захват,который не является безопасным для размотки,вы получите ошибку компиляции в тот момент,что позволит вам рассмотреть,действительно ли этот новый захват представляет собой ошибку или нет.</target>
        </trans-unit>
        <trans-unit id="3012f027dfde83895278c2a37775ef7453b5a48e" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN % -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). In this case, this method returns 0.</source>
          <target state="translated">Перенос будет происходить только в &lt;code&gt;MIN % -1&lt;/code&gt; для подписанного типа (где &lt;code&gt;MIN&lt;/code&gt; - отрицательное минимальное значение для типа). В этом случае этот метод возвращает 0.</target>
        </trans-unit>
        <trans-unit id="5d2a82c1ae568c2138fb6d4aab53c9ab79d15385" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). This is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In this case, this method returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">Перенос будет происходить только в &lt;code&gt;MIN / -1&lt;/code&gt; для подписанного типа (где &lt;code&gt;MIN&lt;/code&gt; - отрицательное минимальное значение для типа). Это эквивалентно &lt;code&gt;-MIN&lt;/code&gt; , положительному значению, которое слишком велико для представления в типе. В этом случае этот метод сам возвращает &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44bf3ad335738a5732c68d1f5196155da8fafc7b" translate="yes" xml:space="preserve">
          <source>Wrapping::abs</source>
          <target state="translated">Wrapping::abs</target>
        </trans-unit>
        <trans-unit id="fc3cfb30e84b8ebe6925ae0fbbf5f0d863e96948" translate="yes" xml:space="preserve">
          <source>Wrapping::add</source>
          <target state="translated">Wrapping::add</target>
        </trans-unit>
        <trans-unit id="e4708fa03c855319c8e70d77b4d353eb63d863a1" translate="yes" xml:space="preserve">
          <source>Wrapping::add_assign</source>
          <target state="translated">Wrapping::add_assign</target>
        </trans-unit>
        <trans-unit id="6227b7b51ca5d41b66a8bd3e6ec7e706422dcd02" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand</source>
          <target state="translated">Wrapping::bitand</target>
        </trans-unit>
        <trans-unit id="50986c3cc68dd80bb41b112f5357a4b5cb0ac2fc" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand_assign</source>
          <target state="translated">Wrapping::bitand_assign</target>
        </trans-unit>
        <trans-unit id="b7da20cfd17d521397a2d0c4d7318400486ff1e3" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor</source>
          <target state="translated">Wrapping::bitor</target>
        </trans-unit>
        <trans-unit id="b1f50a490018b194e6eb7c8804a9e9492ca0ae9b" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor_assign</source>
          <target state="translated">Wrapping::bitor_assign</target>
        </trans-unit>
        <trans-unit id="fd32619eaf11a02453eca2921b2682dcb9909981" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor</source>
          <target state="translated">Wrapping::bitxor</target>
        </trans-unit>
        <trans-unit id="4ee45c7807828640fae4c2e2cbbd932b27eab127" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor_assign</source>
          <target state="translated">Wrapping::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="453a622aaaf4b4b2bd85589c0f8774be95ac4938" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow</source>
          <target state="translated">Wrapping::borrow</target>
        </trans-unit>
        <trans-unit id="7842f835a5fa6d18893907fa71602942c78be04d" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow_mut</source>
          <target state="translated">Wrapping::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4251a19204a74bbc8ead142e79f328751693afa6" translate="yes" xml:space="preserve">
          <source>Wrapping::clamp</source>
          <target state="translated">Wrapping::clamp</target>
        </trans-unit>
        <trans-unit id="cf1afade198e332fd9d6aa7668a3bb32f2401d0b" translate="yes" xml:space="preserve">
          <source>Wrapping::clone</source>
          <target state="translated">Wrapping::clone</target>
        </trans-unit>
        <trans-unit id="54ff9aff38c7f4f514610503b3e487387eb07e58" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_from</source>
          <target state="translated">Wrapping::clone_from</target>
        </trans-unit>
        <trans-unit id="f68c352e73999ff6e48da1e988a3a084b81becdc" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_into</source>
          <target state="translated">Wrapping::clone_into</target>
        </trans-unit>
        <trans-unit id="32813d8440ead76b1def56d4e5d7fd137f1714b5" translate="yes" xml:space="preserve">
          <source>Wrapping::cmp</source>
          <target state="translated">Wrapping::cmp</target>
        </trans-unit>
        <trans-unit id="4fecc3db0f0b1e9deb5da5a1f039d7c88813a6bc" translate="yes" xml:space="preserve">
          <source>Wrapping::count_ones</source>
          <target state="translated">Wrapping::count_ones</target>
        </trans-unit>
        <trans-unit id="0707d6a5c3931efbf437f387bfdbb1a8025b4865" translate="yes" xml:space="preserve">
          <source>Wrapping::count_zeros</source>
          <target state="translated">Wrapping::count_zeros</target>
        </trans-unit>
        <trans-unit id="a236a50222c3eb097eb11ec3a8bd688ac72247f5" translate="yes" xml:space="preserve">
          <source>Wrapping::default</source>
          <target state="translated">Wrapping::default</target>
        </trans-unit>
        <trans-unit id="7606cc1196464916bcf7fa22b931dbc498ed2d35" translate="yes" xml:space="preserve">
          <source>Wrapping::div</source>
          <target state="translated">Wrapping::div</target>
        </trans-unit>
        <trans-unit id="b2ae04a0a7ac3514cff2c427720f641e1e13a105" translate="yes" xml:space="preserve">
          <source>Wrapping::div_assign</source>
          <target state="translated">Wrapping::div_assign</target>
        </trans-unit>
        <trans-unit id="818aac7baf3ade93847ccd4565c9412270bfd765" translate="yes" xml:space="preserve">
          <source>Wrapping::eq</source>
          <target state="translated">Wrapping::eq</target>
        </trans-unit>
        <trans-unit id="edf1a00ab01443e1c22b37d5320b28146f8fae8f" translate="yes" xml:space="preserve">
          <source>Wrapping::fmt</source>
          <target state="translated">Wrapping::fmt</target>
        </trans-unit>
        <trans-unit id="da29af44683c629d1953591b5af876af1284f165" translate="yes" xml:space="preserve">
          <source>Wrapping::from</source>
          <target state="translated">Wrapping::from</target>
        </trans-unit>
        <trans-unit id="bb4414a5497b8f006614444c61fdfbf7e351c1e1" translate="yes" xml:space="preserve">
          <source>Wrapping::from_be</source>
          <target state="translated">Wrapping::from_be</target>
        </trans-unit>
        <trans-unit id="8327aab74dc84b766db6b768bb5f0b4fbae51d60" translate="yes" xml:space="preserve">
          <source>Wrapping::from_le</source>
          <target state="translated">Wrapping::from_le</target>
        </trans-unit>
        <trans-unit id="2e5b33409882b1e267e6cfbfc31a1f3c8c97affd" translate="yes" xml:space="preserve">
          <source>Wrapping::ge</source>
          <target state="translated">Wrapping::ge</target>
        </trans-unit>
        <trans-unit id="763baba99ef1af7752d4c399fd9e4f56ca95cae4" translate="yes" xml:space="preserve">
          <source>Wrapping::gt</source>
          <target state="translated">Wrapping::gt</target>
        </trans-unit>
        <trans-unit id="7f52b5e60bdf5a8b75a6f1bee019e4223125b7ea" translate="yes" xml:space="preserve">
          <source>Wrapping::hash</source>
          <target state="translated">Wrapping::hash</target>
        </trans-unit>
        <trans-unit id="439b5d8bd3660d315ca5a58573799ca1f8b650bd" translate="yes" xml:space="preserve">
          <source>Wrapping::hash_slice</source>
          <target state="translated">Wrapping::hash_slice</target>
        </trans-unit>
        <trans-unit id="e6b9c5af34e5d2c6b6aa7479d3ac5762be077d3b" translate="yes" xml:space="preserve">
          <source>Wrapping::into</source>
          <target state="translated">Wrapping::into</target>
        </trans-unit>
        <trans-unit id="8f7f5f2dd4156c437b4278d979eb99568352829c" translate="yes" xml:space="preserve">
          <source>Wrapping::is_negative</source>
          <target state="translated">Wrapping::is_negative</target>
        </trans-unit>
        <trans-unit id="981b618861d8b57a9acf7fd2996a6466724aea1b" translate="yes" xml:space="preserve">
          <source>Wrapping::is_positive</source>
          <target state="translated">Wrapping::is_positive</target>
        </trans-unit>
        <trans-unit id="3e0d9c814180240ed5988fdbca65c34038e05ba2" translate="yes" xml:space="preserve">
          <source>Wrapping::is_power_of_two</source>
          <target state="translated">Wrapping::is_power_of_two</target>
        </trans-unit>
        <trans-unit id="7eee9ab399dbfec97ad14d12d84dd02ef4c06ce3" translate="yes" xml:space="preserve">
          <source>Wrapping::le</source>
          <target state="translated">Wrapping::le</target>
        </trans-unit>
        <trans-unit id="e5ed947e23bd18f2e1dec6dc53205a1c2b9565b1" translate="yes" xml:space="preserve">
          <source>Wrapping::leading_zeros</source>
          <target state="translated">Wrapping::leading_zeros</target>
        </trans-unit>
        <trans-unit id="863ef48643c8bc709efcb07670e6f74b1ce8d7db" translate="yes" xml:space="preserve">
          <source>Wrapping::lt</source>
          <target state="translated">Wrapping::lt</target>
        </trans-unit>
        <trans-unit id="f8c4ed77b17c6dd866e77c6844acb16e3570ccb0" translate="yes" xml:space="preserve">
          <source>Wrapping::max</source>
          <target state="translated">Wrapping::max</target>
        </trans-unit>
        <trans-unit id="b8977c5e6f634623ea3525b2d454af899f6eb091" translate="yes" xml:space="preserve">
          <source>Wrapping::max_value</source>
          <target state="translated">Wrapping::max_value</target>
        </trans-unit>
        <trans-unit id="0450be54fef79761132d1aef7686c837c2fb7d59" translate="yes" xml:space="preserve">
          <source>Wrapping::min</source>
          <target state="translated">Wrapping::min</target>
        </trans-unit>
        <trans-unit id="8e1254c79d384f9bb2963a56f9a7834418921b24" translate="yes" xml:space="preserve">
          <source>Wrapping::min_value</source>
          <target state="translated">Wrapping::min_value</target>
        </trans-unit>
        <trans-unit id="3dbf2ab4711da3ee943c8515466f305c3d067dd6" translate="yes" xml:space="preserve">
          <source>Wrapping::mul</source>
          <target state="translated">Wrapping::mul</target>
        </trans-unit>
        <trans-unit id="193429091dcbc7d316a04f0dc154b88272a65f08" translate="yes" xml:space="preserve">
          <source>Wrapping::mul_assign</source>
          <target state="translated">Wrapping::mul_assign</target>
        </trans-unit>
        <trans-unit id="0210502668266ded14b09843d193035a2b624a28" translate="yes" xml:space="preserve">
          <source>Wrapping::ne</source>
          <target state="translated">Wrapping::ne</target>
        </trans-unit>
        <trans-unit id="d08218c355fb4c595823228061d8f6285a384c7e" translate="yes" xml:space="preserve">
          <source>Wrapping::neg</source>
          <target state="translated">Wrapping::neg</target>
        </trans-unit>
        <trans-unit id="b68d44f8dc9b7bccaa5f89c2580778d3f5c481ca" translate="yes" xml:space="preserve">
          <source>Wrapping::next_power_of_two</source>
          <target state="translated">Wrapping::next_power_of_two</target>
        </trans-unit>
        <trans-unit id="dc08d2689104cf14575e073facb8aec83dc9a31a" translate="yes" xml:space="preserve">
          <source>Wrapping::not</source>
          <target state="translated">Wrapping::not</target>
        </trans-unit>
        <trans-unit id="e5d2695179201fbe97915617ae577e6a74b5df38" translate="yes" xml:space="preserve">
          <source>Wrapping::partial_cmp</source>
          <target state="translated">Wrapping::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fdaf45498033a636d7d91789f724fabd68edb8d" translate="yes" xml:space="preserve">
          <source>Wrapping::pow</source>
          <target state="translated">Wrapping::pow</target>
        </trans-unit>
        <trans-unit id="df24d6f31eef97d8356983a2855db9da91e53388" translate="yes" xml:space="preserve">
          <source>Wrapping::product</source>
          <target state="translated">Wrapping::product</target>
        </trans-unit>
        <trans-unit id="a8d7bbb8b06894e60316bfa8896f3a9ac47a6d64" translate="yes" xml:space="preserve">
          <source>Wrapping::rem</source>
          <target state="translated">Wrapping::rem</target>
        </trans-unit>
        <trans-unit id="da3a26e48c553a9ebd7ad42e38d4c13f4cbb4bde" translate="yes" xml:space="preserve">
          <source>Wrapping::rem_assign</source>
          <target state="translated">Wrapping::rem_assign</target>
        </trans-unit>
        <trans-unit id="307c0e40471bf0ca34f880f97766b03909622b22" translate="yes" xml:space="preserve">
          <source>Wrapping::reverse_bits</source>
          <target state="translated">Wrapping::reverse_bits</target>
        </trans-unit>
        <trans-unit id="133f98b61cd2fc743ea3ab9ab7d24b004d38769b" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_left</source>
          <target state="translated">Wrapping::rotate_left</target>
        </trans-unit>
        <trans-unit id="3ce34aaff81a8cb1b00504a6d7ba0307a0954a44" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_right</source>
          <target state="translated">Wrapping::rotate_right</target>
        </trans-unit>
        <trans-unit id="6fea873396e78fa80dc5b81a4b24f5731984d1b4" translate="yes" xml:space="preserve">
          <source>Wrapping::shl</source>
          <target state="translated">Wrapping::shl</target>
        </trans-unit>
        <trans-unit id="9edfd053f58c6dc953850af5f23fe9791136e673" translate="yes" xml:space="preserve">
          <source>Wrapping::shl_assign</source>
          <target state="translated">Wrapping::shl_assign</target>
        </trans-unit>
        <trans-unit id="727c36c7aba1df8a46aafc2245377be316466083" translate="yes" xml:space="preserve">
          <source>Wrapping::shr</source>
          <target state="translated">Wrapping::shr</target>
        </trans-unit>
        <trans-unit id="a459ea5ad750d76affd0bb2928733c2196d44926" translate="yes" xml:space="preserve">
          <source>Wrapping::shr_assign</source>
          <target state="translated">Wrapping::shr_assign</target>
        </trans-unit>
        <trans-unit id="f5b4f5594c248eaa052551544a5613e890f44805" translate="yes" xml:space="preserve">
          <source>Wrapping::signum</source>
          <target state="translated">Wrapping::signum</target>
        </trans-unit>
        <trans-unit id="5421f7a3c097f4803cab58bff1cb7ebfbe6a61cd" translate="yes" xml:space="preserve">
          <source>Wrapping::sub</source>
          <target state="translated">Wrapping::sub</target>
        </trans-unit>
        <trans-unit id="fe50fe98bf767916368abf1c925e7ac3e037c08c" translate="yes" xml:space="preserve">
          <source>Wrapping::sub_assign</source>
          <target state="translated">Wrapping::sub_assign</target>
        </trans-unit>
        <trans-unit id="f72d77e1d30187c514a849ed36c97ad216978037" translate="yes" xml:space="preserve">
          <source>Wrapping::sum</source>
          <target state="translated">Wrapping::sum</target>
        </trans-unit>
        <trans-unit id="3886fc89ccb5cf7ab1ce69c7013954aa90ca533e" translate="yes" xml:space="preserve">
          <source>Wrapping::swap_bytes</source>
          <target state="translated">Wrapping::swap_bytes</target>
        </trans-unit>
        <trans-unit id="bd4ae9e508fe128f587726b34b639594de73a5f6" translate="yes" xml:space="preserve">
          <source>Wrapping::to_be</source>
          <target state="translated">Wrapping::to_be</target>
        </trans-unit>
        <trans-unit id="7885b2e75fcb436776b4e307af4f9e623074994c" translate="yes" xml:space="preserve">
          <source>Wrapping::to_le</source>
          <target state="translated">Wrapping::to_le</target>
        </trans-unit>
        <trans-unit id="28db626412c7da571e95eec9a8ad5fa799e67614" translate="yes" xml:space="preserve">
          <source>Wrapping::to_owned</source>
          <target state="translated">Wrapping::to_owned</target>
        </trans-unit>
        <trans-unit id="73aa20bad1867d0ff4c2d24f0721a5a8eef6a4d8" translate="yes" xml:space="preserve">
          <source>Wrapping::to_string</source>
          <target state="translated">Wrapping::to_string</target>
        </trans-unit>
        <trans-unit id="04d5020a03ae412567480d9d468c0ac47bbeb27e" translate="yes" xml:space="preserve">
          <source>Wrapping::trailing_zeros</source>
          <target state="translated">Wrapping::trailing_zeros</target>
        </trans-unit>
        <trans-unit id="346c87924a2dddfb76d03753bd7557d01a46d89f" translate="yes" xml:space="preserve">
          <source>Wrapping::try_from</source>
          <target state="translated">Wrapping::try_from</target>
        </trans-unit>
        <trans-unit id="d6a7a2b803d2c4bf9add1e2055e52b0b8af45d11" translate="yes" xml:space="preserve">
          <source>Wrapping::try_into</source>
          <target state="translated">Wrapping::try_into</target>
        </trans-unit>
        <trans-unit id="527e0a06e98efe05731d34b8495de7a9c0796355" translate="yes" xml:space="preserve">
          <source>Wrapping::type_id</source>
          <target state="translated">Wrapping::type_id</target>
        </trans-unit>
        <trans-unit id="d8fe6dbee08984aea95f13fc56e0174b6cc4af39" translate="yes" xml:space="preserve">
          <source>Wraps a borrowed reference to a value in a &lt;code&gt;RefCell&lt;/code&gt; box. A wrapper type for an immutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Оборачивает заимствованную ссылку на значение в поле &lt;code&gt;RefCell&lt;/code&gt; . Тип оболочки для неизменяемого значения, заимствованного из &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14edef43e7df9f66193cba2f15582361d72b01a1" translate="yes" xml:space="preserve">
          <source>Wraps a raw C string with a safe C string wrapper.</source>
          <target state="translated">Обертывает сырую C-строку безопасной C-строкой.</target>
        </trans-unit>
        <trans-unit id="cc416cf90ebff133d69706f1e45c9ea10f251fd4" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers its output.</source>
          <target state="translated">Упаковывает писателя и буферизует его выход.</target>
        </trans-unit>
        <trans-unit id="8835b45a5ce8372fc5b7a9379d43ba01d8c84d89" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers output to it, flushing whenever a newline (&lt;code&gt;0x0a&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;) is detected.</source>
          <target state="translated">Оборачивает писатель и буферизует вывод в него, &lt;code&gt;0x0a&lt;/code&gt; при обнаружении новой строки ( 0x0a , &lt;code&gt;'\n'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="422b221e3621326874b9013f07f6893cefb36793" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written.</source>
          <target state="translated">Запишите буфер в этот пишущий инструмент,возвращая,сколько байт было записано.</target>
        </trans-unit>
        <trans-unit id="ae542cbc15e88f2bf807f8d29fc312d51c4f9344" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Запишите буфер в этот писатель, вернув, сколько байтов было записано. &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e588991feee7d28024ae797d8cc74c94c42f1fc" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Запишите буфер в этот писатель, вернув, сколько байтов было записано. &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad7b7826de9694bab5fc487da2a9381a00705795" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Запишите буфер в этот писатель, вернув, сколько байтов было записано. &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42d55a3c5a475b3858d14de608fc86cc1e27fad6" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Запишите буфер в этот писатель, вернув, сколько байтов было записано. &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f289e0fc842fa4a0a0c757a23aec01849b63cc" translate="yes" xml:space="preserve">
          <source>Write a slice as the entire contents of a file.</source>
          <target state="translated">Запишите кусочек как все содержимое файла.</target>
        </trans-unit>
        <trans-unit id="fd14b03d8c7f6b0eec5d8071e36c0b064da74395" translate="yes" xml:space="preserve">
          <source>Write a test that fails and run it to make sure it fails for the reason you expect.</source>
          <target state="translated">Напишите тест,который провалился,и запустите его,чтобы убедиться,что он провалился по той причине,которую вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="4792f2eef0440e6afee1219df6ba659746474535" translate="yes" xml:space="preserve">
          <source>Write an Ipv6Addr, conforming to the canonical style described by &lt;a href=&quot;https://tools.ietf.org/html/rfc5952&quot;&gt;RFC 5952&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbf60c6c756d06c22970e5f8f55fad03ee1e678" translate="yes" xml:space="preserve">
          <source>Write an usize value to a byte buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a183b868e8fdfdd4779773f0a41b1402c75eb8" translate="yes" xml:space="preserve">
          <source>Write and run a &amp;ldquo;Hello, world!&amp;rdquo; program using &lt;code&gt;rustc&lt;/code&gt; directly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bcd0015d2edce502b72162bafb8ff8f006ae23" translate="yes" xml:space="preserve">
          <source>Write and run a Hello, world! program using &lt;code&gt;rustc&lt;/code&gt; directly</source>
          <target state="translated">Напишите и запустите Hello, world! программа с использованием &lt;code&gt;rustc&lt;/code&gt; напрямую</target>
        </trans-unit>
        <trans-unit id="ffab6af2de782f874c56ecf608ce2d84de7c2b88" translate="yes" xml:space="preserve">
          <source>Write formatted data into a buffer, with a newline appended.</source>
          <target state="translated">Запись отформатированных данных в буфер с добавлением новой строки.</target>
        </trans-unit>
        <trans-unit id="fcbfbac0d9c49bc3cad2d435296a9ffe56032aaa" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; by copying into the slice, overwriting its data.</source>
          <target state="translated">Запись реализована для &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; путем копирования в слайс и перезаписи его данных.</target>
        </trans-unit>
        <trans-unit id="565edb809a298ba756dfab19911a1af435d39eef" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; by appending to the vector. The vector will grow as needed.</source>
          <target state="translated">Запись реализована для &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; путем добавления к вектору. Вектор будет расти по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="ba9c763eec2480149fd9cd47639418928770f449" translate="yes" xml:space="preserve">
          <source>Write or modify just enough code to make the new test pass.</source>
          <target state="translated">Напишите или модифицируйте достаточно кода,чтобы новый тест прошел.</target>
        </trans-unit>
        <trans-unit id="25725f1f38f240f2a77af039a57e73d792f138b4" translate="yes" xml:space="preserve">
          <source>Write::by_ref</source>
          <target state="translated">Write::by_ref</target>
        </trans-unit>
        <trans-unit id="b18d29c2778fcf294a1af5583a58fde2428d05bc" translate="yes" xml:space="preserve">
          <source>Write::flush</source>
          <target state="translated">Write::flush</target>
        </trans-unit>
        <trans-unit id="2ad8047081c1571209c8de21b5d8ef496c875bcb" translate="yes" xml:space="preserve">
          <source>Write::write</source>
          <target state="translated">Write::write</target>
        </trans-unit>
        <trans-unit id="7f21bb462deedb47e98867332781d5a55ac1f33c" translate="yes" xml:space="preserve">
          <source>Write::write_all</source>
          <target state="translated">Write::write_all</target>
        </trans-unit>
        <trans-unit id="59885a3e77b05a624ab69e3e736291d1ac54574b" translate="yes" xml:space="preserve">
          <source>Write::write_char</source>
          <target state="translated">Write::write_char</target>
        </trans-unit>
        <trans-unit id="869124fb10adcbc1f8e39c2d520b04d4a2bb69e1" translate="yes" xml:space="preserve">
          <source>Write::write_fmt</source>
          <target state="translated">Write::write_fmt</target>
        </trans-unit>
        <trans-unit id="3bed1d79d195792e3683c2bc152331ab7dd62609" translate="yes" xml:space="preserve">
          <source>Write::write_str</source>
          <target state="translated">Write::write_str</target>
        </trans-unit>
        <trans-unit id="141b04d7eaaf0c8ba6b520a1addb5de1176dd5e6" translate="yes" xml:space="preserve">
          <source>Write::write_vectored</source>
          <target state="translated">Write::write_vectored</target>
        </trans-unit>
        <trans-unit id="791cf1c7de23e0f236576b53f40de7030db55060" translate="yes" xml:space="preserve">
          <source>Writers are defined by two required methods, &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Писатели определяются двумя обязательными методами, &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="066642e038ad8d099b61091156c44bbd264c7655" translate="yes" xml:space="preserve">
          <source>Writers are defined by two required methods, &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d019e37d31448a1c36b68f61dbbcb935ed4575" translate="yes" xml:space="preserve">
          <source>Writers are intended to be composable with one another. Many implementors throughout &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; take and provide types which implement the &lt;code&gt;Write&lt;/code&gt; trait.</source>
          <target state="translated">Писатели предназначены для совмещения друг с другом. Многие разработчики &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt; берут и предоставляют типы, реализующие черту &lt;code&gt;Write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a718c79c131f76156d3a6b0d5a5556c990d2570b" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded.</source>
          <target state="translated">Записывает в этот писатель &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , возвращая, была ли запись успешна.</target>
        </trans-unit>
        <trans-unit id="dcbe05c646a15714bf69547e05d3cd91b7425533" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645bfe779599abf2ba4f8f6c08447416d5474b43" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4305f6b237e9832ff95454c9f34aa579f1dc813" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9272508b2e41aaf20afc1194eb5b0b6d2dfdc6c9" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает [ &lt;code&gt;char&lt;/code&gt; ] в этот модуль записи, возвращая, была ли запись успешной. &lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="344bd2db5bc9ba178016d1881285c5afaddc4598" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает [ &lt;code&gt;char&lt;/code&gt; ] в этот модуль записи, возвращая, была ли запись успешной. &lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d63a032a19b4234e192d3e267b268acd649fd1b" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает [ &lt;code&gt;char&lt;/code&gt; ] в этот модуль записи, возвращая, была ли запись успешной. &lt;a href=&quot;trait.write#method.write_char&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95220c41379acdd46bdc780a7a0f1e80e449feff" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered.</source>
          <target state="translated">Записывает отформатированную строку в этот пишущий инструмент,возвращая обнаруженную ошибку.</target>
        </trans-unit>
        <trans-unit id="ecd98e7e5a4ec62ace4f960c01001be172e4925a" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../../../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает отформатированную строку в этот модуль записи, возвращая любую обнаруженную ошибку. &lt;a href=&quot;../../../io/trait.write#method.write_fmt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5543389626d86c8e31553df92af2bde941d2a65" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает отформатированную строку в этот модуль записи, возвращая любую обнаруженную ошибку. &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de5e6f1aafa20fef122dbeed5a71a42b9aa2cae7" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает отформатированную строку в этот модуль записи, возвращая любую обнаруженную ошибку. &lt;a href=&quot;io/trait.write#method.write_fmt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c76861292606f0bb18321f85e96258836dd2770e" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает отформатированную строку в этот модуль записи, возвращая любую обнаруженную ошибку. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ba303c199b9fe4bf1985b876faca69be2aaf9cf" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset.</source>
          <target state="translated">Записывает количество байтов,начиная с заданного смещения.</target>
        </trans-unit>
        <trans-unit id="934343889f7324a6e5af2ff1400d9536dbb167e4" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#tymethod.write_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает количество байтов, начиная с заданного смещения. &lt;a href=&quot;../os/unix/fs/trait.fileext#tymethod.write_at&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45af1e55309b26785973c6185f7a9e763b1c820c" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i128&lt;/code&gt; into this hasher.</source>
          <target state="translated">Пишет один &lt;code&gt;i128&lt;/code&gt; в этом Hasher.</target>
        </trans-unit>
        <trans-unit id="6bdae3ffbfb54cc26470f2ec7abd8a54cb058931" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i16&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает один &lt;code&gt;i16&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="1e459398c36e231b3d36e4260518d1366491f1f6" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i32&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает один &lt;code&gt;i32&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="e6d8da557fcf2c2f0d524d8144d83e2c8862ca13" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i64&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает один &lt;code&gt;i64&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="53db12ba27efb40f7499916f3539839440705b87" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i8&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает один &lt;code&gt;i8&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="330e06c59d6bdbee17d36d76f63e12553c4d97da" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;isize&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает единственный &lt;code&gt;isize&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="45e49a31d6e7c2d2a651050c305491ca7804f21e" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u128&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает один &lt;code&gt;u128&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="aa85ed84476923b1cc5d6b7dfba41874a5d706a0" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u16&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает один &lt;code&gt;u16&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="d68ef120a557f4627660db1da5fdfbcac01eb533" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u32&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает единственный &lt;code&gt;u32&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="a14997eaf51c4e7602b5505b9d66837490a2a9fe" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u64&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает один &lt;code&gt;u64&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="40743e36f9b775608cfba8e00eb78b804913d33f" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u8&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает единственный &lt;code&gt;u8&lt;/code&gt; в этот хешер.</target>
        </trans-unit>
        <trans-unit id="d83f8161e61d59972914ffd1989afe5538474dbc" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;usize&lt;/code&gt; into this hasher.</source>
          <target state="translated">Записывает в этот хешер одно &lt;code&gt;usize&lt;/code&gt; usize.</target>
        </trans-unit>
        <trans-unit id="75c98aad5800d7465070b778412dd48f81ecbabf" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded.</source>
          <target state="translated">Пишет кусочек байта в этот писатель,возвращаясь,удалось ли написать.</target>
        </trans-unit>
        <trans-unit id="589037d6e27cf4636e5142d1239dc9ad31b05dda" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает часть байтов в этот модуль записи, возвращая, была ли запись успешна. &lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fddaf179154fa846c54d2edd52d74504db1eece" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает часть байтов в этот модуль записи, возвращая, была ли запись успешна. &lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8235073da555c5bd3bf719f2ab4a2cc258a3445a" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает часть байтов в этот модуль записи, возвращая, была ли запись успешна. &lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="660e25a3eb306b3311d28442f6e6208ae58a5791" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b1b14666b506662fd683fe6bca2d5d9e8bcd1f" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a15db8ef2c352ca0cb66f490148cb6670e5f327" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe30ae81a283cdbac3d9b2f4e474cbc6a9a2dcd" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e50e6072cf8d9643cbbf27cb278e15b00644e8" translate="yes" xml:space="preserve">
          <source>Writes formatted data into a buffer.</source>
          <target state="translated">Записывает отформатированные данные в буфер.</target>
        </trans-unit>
        <trans-unit id="b133e539f22c56a49e3bc9bfe584753136fdfcd5" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;.</source>
          <target state="translated">Записывает некоторые данные в этот &lt;code&gt;Hasher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d56d2da40c1790d440e6f30eedb76e01abcaec37" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает некоторые данные в этот &lt;code&gt;Hasher&lt;/code&gt; . &lt;a href=&quot;../../hash/trait.hasher#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="664b4eecc8d27414cb11c8ab606f3786a94fd297" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает некоторые данные в этот &lt;code&gt;Hasher&lt;/code&gt; . &lt;a href=&quot;../hash/trait.hasher#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ca27f9b6840a29f38a33b35b6a75dbc6f57703f" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает некоторые данные в этот &lt;code&gt;Hasher&lt;/code&gt; . &lt;a href=&quot;hash/trait.hasher#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b8a4f8c89b109d74c610b85abf9468d80196ad2" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Записывает некоторые данные в этот &lt;code&gt;Hasher&lt;/code&gt; . &lt;a href=&quot;trait.hasher#tymethod.write&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a2b61198cabc344eec293cea3eb21151c358cad" translate="yes" xml:space="preserve">
          <source>Writes some data to the underlying buffer contained within this formatter.</source>
          <target state="translated">Записывает некоторые данные в буфер,находящийся внутри этого формирователя.</target>
        </trans-unit>
        <trans-unit id="b05105a6d198b6efd15010fe5b3a83555f844ec8" translate="yes" xml:space="preserve">
          <source>Writes some formatted information into this instance.</source>
          <target state="translated">Записывает в этот экземпляр некоторую форматированную информацию.</target>
        </trans-unit>
        <trans-unit id="73e796ac178d17656628057ad4de2c3715ecb31f" translate="yes" xml:space="preserve">
          <source>Writes to &lt;code&gt;Copy&lt;/code&gt; union fields do not require reads for running destructors, so these writes don't have to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks</source>
          <target state="translated">Записи для &lt;code&gt;Copy&lt;/code&gt; полей объединения не требуют чтения для запуска деструкторов, поэтому эти записи не нужно помещать в &lt;code&gt;unsafe&lt;/code&gt; блоки</target>
        </trans-unit>
        <trans-unit id="7a04ade11270a59b7a8d9a38b3f59d450099f209" translate="yes" xml:space="preserve">
          <source>Writing Automated Tests</source>
          <target state="translated">Написание автоматических тестов</target>
        </trans-unit>
        <trans-unit id="8d9de7655ad92afdb381750f5cb6b0b9d4630db5" translate="yes" xml:space="preserve">
          <source>Writing Code to Pass the Test</source>
          <target state="translated">Пишущий код для прохождения теста</target>
        </trans-unit>
        <trans-unit id="c7ec99d9ff26178393f163143686d9bc7fb6a3d1" translate="yes" xml:space="preserve">
          <source>Writing Error Messages to Standard Error Instead of Standard Output</source>
          <target state="translated">Запись сообщений об ошибках в стандартный вывод вместо стандартного вывода</target>
        </trans-unit>
        <trans-unit id="b4a721e4aa8c7261bfa68a1535b4fe4e84e2f28e" translate="yes" xml:space="preserve">
          <source>Writing a Failing Test</source>
          <target state="translated">Написание теста на неудачу</target>
        </trans-unit>
        <trans-unit id="83ca9b1b9c2e5fb239421cfb23f5c54c22d603eb" translate="yes" xml:space="preserve">
          <source>Writing a Failing Test for the Case-Insensitive &lt;code id=&quot;writing-a-failing-test-for-the-case-insensitive-search-function&quot;&gt;search&lt;/code&gt; Function</source>
          <target state="translated">Написание неудачного теста для функции &lt;code id=&quot;writing-a-failing-test-for-the-case-insensitive-search-function&quot;&gt;search&lt;/code&gt; учета регистра</target>
        </trans-unit>
        <trans-unit id="993bd3ebaf1e78a4791f69f6f8988c0b5b0d3ae3" translate="yes" xml:space="preserve">
          <source>Writing a Response</source>
          <target state="translated">Написание ответа</target>
        </trans-unit>
        <trans-unit id="97d3ede6e5b435ad6b9a77ec03a83113afdfb3a5" translate="yes" xml:space="preserve">
          <source>Writing a program that prints &lt;code&gt;Hello, world!&lt;/code&gt;</source>
          <target state="translated">Написание программы, которая печатает &lt;code&gt;Hello, world!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="785a0c70580d26564b61ec7b2da0b61477b68b43" translate="yes" xml:space="preserve">
          <source>Writing an array&amp;rsquo;s type this way looks similar to an alternative syntax for initializing an array: if you want to create an array that contains the same value for each element, you can specify the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:</source>
          <target state="translated">Такой способ записи типа массива похож на альтернативный синтаксис для инициализации массива: если вы хотите создать массив, содержащий одно и то же значение для каждого элемента, вы можете указать начальное значение, за которым следует точка с запятой, а затем длина массив в квадратных скобках, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="f560bd46db71699beed1dbcf4f543ef55a25efce" translate="yes" xml:space="preserve">
          <source>Writing and Running a Rust Program</source>
          <target state="translated">Написание и запуск программы по борьбе с ржавчиной</target>
        </trans-unit>
        <trans-unit id="6c156da0c5e2570a035c5e8bd4f021c50ffb20da" translate="yes" xml:space="preserve">
          <source>Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.</source>
          <target state="translated">Написание обоих видов тестов важно для того,чтобы части вашей библиотеки делали то,что вы ожидаете от них,по отдельности и вместе.</target>
        </trans-unit>
        <trans-unit id="796c30002159ff15a3a7e4eeec8cf17afe766c5f" translate="yes" xml:space="preserve">
          <source>Writing tests (&lt;a href=&quot;ch11-00-testing&quot;&gt;Chapter 11&lt;/a&gt;)</source>
          <target state="translated">Написание тестов ( &lt;a href=&quot;ch11-00-testing&quot;&gt;Глава 11&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="450f15de86c3b61b38fb7579e1f10bd319432ea8" translate="yes" xml:space="preserve">
          <source>Writing tests so they return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an &lt;code&gt;Err&lt;/code&gt; variant.</source>
          <target state="translated">Написание тестов таким образом, чтобы они возвращали &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; позволяет использовать оператор вопросительного знака в теле тестов, что может быть удобным способом написания тестов, которые должны завершиться ошибкой, если какая-либо операция в них вернет вариант &lt;code&gt;Err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07bc23942d416a7fef04bbcf5fc194f37c766951" translate="yes" xml:space="preserve">
          <source>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. Imagine having a project full of code like that in Listing 19-24.</source>
          <target state="translated">Написание этого длинного типа в сигнатурах функций и в виде типовых аннотаций по всему коду может быть утомительным и предрасположенным к ошибкам.Представьте себе проект,полный такого кода в Листинге 19-24.</target>
        </trans-unit>
        <trans-unit id="07e47a0416a28679b7085ffdf5344062b5fcdd36" translate="yes" xml:space="preserve">
          <source>Yanking a version prevents new projects from starting to depend on that version while allowing all existing projects that depend on it to continue to download and depend on that version. Essentially, a yank means that all projects with a &lt;em&gt;Cargo.lock&lt;/em&gt; will not break, and any future &lt;em&gt;Cargo.lock&lt;/em&gt; files generated will not use the yanked version.</source>
          <target state="translated">Сохранение версии предотвращает зависимость новых проектов от этой версии, в то же время позволяя всем существующим проектам, которые зависят от нее, продолжать загрузку и зависеть от этой версии. По сути, восстановление означает, что все проекты с &lt;em&gt;Cargo.lock&lt;/em&gt; не будут &lt;em&gt;сломаны&lt;/em&gt; , и любые будущие файлы &lt;em&gt;Cargo.lock&lt;/em&gt; не будут использовать восстановленную версию.</target>
        </trans-unit>
        <trans-unit id="f8e5799899abe435ee29b5e571cca4a4951b4912" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;CStr&lt;/code&gt; contains valid UTF-8.</source>
          <target state="translated">Выдает фрагмент &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;CStr&lt;/code&gt; содержит допустимый UTF-8.</target>
        </trans-unit>
        <trans-unit id="3c7c3595b258ab56decf488e64eb0d24960bf485" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;OsStr&lt;/code&gt; is valid Unicode.</source>
          <target state="translated">Возвращающее &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; кусочек , если &lt;code&gt;OsStr&lt;/code&gt; действительна Unicode.</target>
        </trans-unit>
        <trans-unit id="195279f44b198c67c27101e6d1db95ba38fd584e" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;Path&lt;/code&gt; is valid unicode.</source>
          <target state="translated">Выдает фрагмент &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;Path&lt;/code&gt; является допустимым Unicode.</target>
        </trans-unit>
        <trans-unit id="758c4d0f690a6c543ad0cd5b04420b3087ad8f1b" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;CStr&lt;/code&gt; contains valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86217a19209be5bc5617ae5f4db30f4c9578c5e5" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;OsStr&lt;/code&gt; is valid Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0b7dbdf4f40a5f0fc3157e3dd92701d432da4" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;Path&lt;/code&gt; is valid unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413679a903a004b3c5c40da67ab627b0db5926d2" translate="yes" xml:space="preserve">
          <source>Yields a &lt;code&gt;Result&amp;lt;bool, ParseBoolError&amp;gt;&lt;/code&gt;, because &lt;code&gt;s&lt;/code&gt; may or may not actually be parseable.</source>
          <target state="translated">Выдает &lt;code&gt;Result&amp;lt;bool, ParseBoolError&amp;gt;&lt;/code&gt; , потому что &lt;code&gt;s&lt;/code&gt; может быть, а может и не быть анализируемым.</target>
        </trans-unit>
        <trans-unit id="e9230c9fc9c21a74b44c14778be86dfe99887de8" translate="yes" xml:space="preserve">
          <source>Yields the underlying &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice.</source>
          <target state="translated">&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; базовый срез OsStr .</target>
        </trans-unit>
        <trans-unit id="0c744c88f234909706712417b746da8f001876e3" translate="yes" xml:space="preserve">
          <source>Yields the underlying byte vector of this &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Выдает базовый байтовый вектор этой &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45e614c97fadbe28622649b26e90d5c12092a4a5" translate="yes" xml:space="preserve">
          <source>Yields the underlying byte vector of this &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827f632b1eb13c813d90204287d7a305ab25fbc3" translate="yes" xml:space="preserve">
          <source>Yields the underlying byte vector of this [&lt;code&gt;OsString&lt;/code&gt;]. &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Выдает базовый байтовый вектор этого [ &lt;code&gt;OsString&lt;/code&gt; ]. &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65ae03a65393d6ce8a756fcd3bce6d5e0e587d92" translate="yes" xml:space="preserve">
          <source>You also don&amp;rsquo;t have to worry about problems resulting from accidentally cleaning up values still in use: the ownership system that makes sure references are always valid also ensures that &lt;code&gt;drop&lt;/code&gt; gets called only once when the value is no longer being used.</source>
          <target state="translated">Вам также не нужно беспокоиться о проблемах, возникающих в результате случайной очистки значений, которые все еще используются: система владения, которая гарантирует, что ссылки всегда действительны, также гарантирует, что &lt;code&gt;drop&lt;/code&gt; вызывается только один раз, когда значение больше не используется.</target>
        </trans-unit>
        <trans-unit id="ec9b139e5d307ab87a8084c13822b6acd8da7805" translate="yes" xml:space="preserve">
          <source>You are &lt;em&gt;absolutely&lt;/em&gt; certain you &lt;em&gt;really&lt;/em&gt;, &lt;em&gt;truly&lt;/em&gt;, want a doubly linked list.</source>
          <target state="translated">Вы &lt;em&gt;абсолютно&lt;/em&gt; уверены , что вы на &lt;em&gt;самом деле&lt;/em&gt; , &lt;em&gt;действительно&lt;/em&gt; , хотите дважды связанный список.</target>
        </trans-unit>
        <trans-unit id="7df51c21931f3ba8153011ff31ac3df483e2b6f2" translate="yes" xml:space="preserve">
          <source>You are trying to use an identifier that is either undefined or not a struct. Erroneous code example:</source>
          <target state="translated">Вы пытаетесь использовать идентификатор,который либо не определен,либо не является структурой.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="72a4cd7a33eb16fdb9f37ef196e2dcb7606d5372" translate="yes" xml:space="preserve">
          <source>You attempted to use multiple types as bounds for a closure or trait object. Rust does not currently support this. A simple example that causes this error:</source>
          <target state="translated">Вы пытались использовать несколько типов в качестве границ для объекта закрытия или черты.В настоящее время ржавчина не поддерживает это.Простой пример,который вызывает эту ошибку:</target>
        </trans-unit>
        <trans-unit id="1f01714756be32bd3190176ff6c1f442b832a1d6" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;struct.vec#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; values onto the end of a vector (which will grow the vector as needed):</source>
          <target state="translated">Вы можете &lt;a href=&quot;struct.vec#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; значения в конец вектора (который будет увеличивать вектор по мере необходимости):</target>
        </trans-unit>
        <trans-unit id="0d2a0e1493249f355c1cfdfc3bac39d75c54ff72" translate="yes" xml:space="preserve">
          <source>You can also add a custom message to be printed with the failure message as optional arguments to the &lt;code&gt;assert!&lt;/code&gt;, &lt;code&gt;assert_eq!&lt;/code&gt;, and &lt;code&gt;assert_ne!&lt;/code&gt; macros. Any arguments specified after the one required argument to &lt;code&gt;assert!&lt;/code&gt; or the two required arguments to &lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; are passed along to the &lt;code&gt;format!&lt;/code&gt; macro (discussed in Chapter 8 in the &lt;a href=&quot;ch08-02-strings#concatenation-with-the--operator-or-the-format-macro&quot;&gt;&amp;ldquo;Concatenation with the &lt;code&gt;+&lt;/code&gt; Operator or the &lt;code&gt;format!&lt;/code&gt; Macro&amp;rdquo;&lt;/a&gt; section), so you can pass a format string that contains &lt;code&gt;{}&lt;/code&gt; placeholders and values to go in those placeholders. Custom messages are useful to document what an assertion means; when a test fails, you&amp;rsquo;ll have a better idea of what the problem is with the code.</source>
          <target state="translated">Вы также можете добавить настраиваемое сообщение, которое будет напечатано с сообщением об ошибке в качестве дополнительных аргументов в &lt;code&gt;assert!&lt;/code&gt; , &lt;code&gt;assert_eq!&lt;/code&gt; , и &lt;code&gt;assert_ne!&lt;/code&gt; макросы. Любые аргументы, указанные после одного обязательного аргумента для &lt;code&gt;assert!&lt;/code&gt; или два обязательных аргумента &lt;code&gt;assert_eq!&lt;/code&gt; и &lt;code&gt;assert_ne!&lt;/code&gt; передаются в &lt;code&gt;format!&lt;/code&gt; макрос (обсуждается в главе 8 в разделе &lt;a href=&quot;ch08-02-strings#concatenation-with-the--operator-or-the-format-macro&quot;&gt;&amp;laquo;Объединение с оператором &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; макросом формата! &amp;raquo; ), поэтому вы можете передать строку формата, содержащую &lt;code&gt;{}&lt;/code&gt; заполнители и значения, которые нужно вставить в эти заполнители. Пользовательские сообщения полезны для документирования того, что означает утверждение; когда тест не проходит, вы лучше понимаете, в чем проблема с кодом.</target>
        </trans-unit>
        <trans-unit id="59d30fe12340d329f73be7515fd4175c752f146f" translate="yes" xml:space="preserve">
          <source>You can also bring an item into scope with &lt;code&gt;use&lt;/code&gt; and a relative path. Listing 7-12 shows how to specify a relative path to get the same behavior as in Listing 7-11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6933a535082bef416b84d186746e29a92d0ca26" translate="yes" xml:space="preserve">
          <source>You can also combine these implementations to let the &lt;code&gt;==&lt;/code&gt; operator work with two different types:</source>
          <target state="translated">Вы также можете комбинировать эти реализации, чтобы оператор &lt;code&gt;==&lt;/code&gt; работал с двумя разными типами:</target>
        </trans-unit>
        <trans-unit id="99c9da3c8943fcee498c0ed8b484f227e63545a2" translate="yes" xml:space="preserve">
          <source>You can also define structs that don&amp;rsquo;t have any fields! These are called &lt;em&gt;unit-like structs&lt;/em&gt; because they behave similarly to &lt;code&gt;()&lt;/code&gt;, the unit type. Unit-like structs can be useful in situations in which you need to implement a trait on some type but don&amp;rsquo;t have any data that you want to store in the type itself. We&amp;rsquo;ll discuss traits in Chapter 10.</source>
          <target state="translated">Вы также можете определять структуры, у которых нет полей! Они называются &lt;em&gt;модульными структурами,&lt;/em&gt; поскольку ведут себя аналогично &lt;code&gt;()&lt;/code&gt; , типу unit. Единичные структуры могут быть полезны в ситуациях, когда вам нужно реализовать трейт для некоторого типа, но у вас нет данных, которые вы хотите сохранить в самом типе. Мы обсудим черты характера в главе 10.</target>
        </trans-unit>
        <trans-unit id="85102a822bf46f84c9e28f5552de9b8522a4dbde" translate="yes" xml:space="preserve">
          <source>You can also define structs that look similar to tuples, called &lt;em&gt;tuple structs&lt;/em&gt;. Tuple structs have the added meaning the struct name provides but don&amp;rsquo;t have names associated with their fields; rather, they just have the types of the fields. Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type from other tuples, and naming each field as in a regular struct would be verbose or redundant.</source>
          <target state="translated">Вы также можете определять структуры, похожие на кортежи, называемые &lt;em&gt;структурами кортежей&lt;/em&gt; . Структуры кортежей имеют дополнительное значение, которое предоставляет имя структуры, но не имеют имен, связанных с их полями; скорее, у них просто есть типы полей. Структуры кортежей полезны, когда вы хотите дать всему кортежу имя и сделать кортеж другим типом, чем другие кортежи, а наименование каждого поля, как в обычной структуре, будет подробным или избыточным.</target>
        </trans-unit>
        <trans-unit id="478834b4ebadfb970a4e8408c36d21f8f75d5297" translate="yes" xml:space="preserve">
          <source>You can also define your own wrapper around &lt;code&gt;System&lt;/code&gt; if you'd like, such as keeping track of the number of all bytes allocated:</source>
          <target state="translated">Вы также можете определить свою собственную оболочку вокруг &lt;code&gt;System&lt;/code&gt; , если хотите, например, для отслеживания количества всех выделенных байтов:</target>
        </trans-unit>
        <trans-unit id="f2ec90a0a184fc0a34f0ffbecbdb3577a9642216" translate="yes" xml:space="preserve">
          <source>You can also drop both values to take a slice of the entire string. So these are equal:</source>
          <target state="translated">Вы также можете сбросить оба значения,чтобы взять кусочек всей строки.Так что они равны:</target>
        </trans-unit>
        <trans-unit id="07fd7e0ceaeb6effa3bef1f17d2c79141e988f86" translate="yes" xml:space="preserve">
          <source>You can also have this error while using a cell type:</source>
          <target state="translated">Эту ошибку можно допустить и при использовании типа ячейки:</target>
        </trans-unit>
        <trans-unit id="2abcc436137e02d2d460f9bb29cc2de726a9488d" translate="yes" xml:space="preserve">
          <source>You can also implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; manually:</source>
          <target state="translated">Вы также можете реализовать &lt;code&gt;Copy&lt;/code&gt; и &lt;code&gt;Clone&lt;/code&gt; вручную:</target>
        </trans-unit>
        <trans-unit id="77d0a855671805dfc5fdffb0de5601ad968fb03d" translate="yes" xml:space="preserve">
          <source>You can also omit the parameter name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0eb8e7e0853f72a4740501ba25eded7eda4cc9" translate="yes" xml:space="preserve">
          <source>You can also rewrite this in terms of &lt;a href=&quot;#method.flat_map&quot;&gt;&lt;code&gt;flat_map()&lt;/code&gt;&lt;/a&gt;, which is preferable in this case since it conveys intent more clearly:</source>
          <target state="translated">Вы также можете переписать это в терминах &lt;a href=&quot;#method.flat_map&quot;&gt; &lt;code&gt;flat_map()&lt;/code&gt; &lt;/a&gt; , что в данном случае предпочтительнее, так как оно более четко передает намерение:</target>
        </trans-unit>
        <trans-unit id="31c83cc061e340443a0779b3d7127df9d6c7ce68" translate="yes" xml:space="preserve">
          <source>You can also rewrite this in terms of &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;flat_map()&lt;/code&gt;&lt;/a&gt;, which is preferable in this case since it conveys intent more clearly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15da995ef7945b8770639a97784385a172b200d0" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;dbg!()&lt;/code&gt; without a value to just print the file and line whenever it's reached.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;dbg!()&lt;/code&gt; Без значения, чтобы просто распечатать файл и строку при их достижении.</target>
        </trans-unit>
        <trans-unit id="9efcd998a1aef5d563a086721600c461fc2c254c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;cargo fix&lt;/code&gt; command to transition your code between different Rust editions. Editions are covered in Appendix E.</source>
          <target state="translated">Вы также можете использовать команду &lt;code&gt;cargo fix&lt;/code&gt; для перехода вашего кода между различными редакциями Rust. Редакции описаны в Приложении E.</target>
        </trans-unit>
        <trans-unit id="9e76ec17ba63844ca8928afd80bf3131846fedf2" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;em&gt;or&lt;/em&gt; operator &lt;code&gt;|&lt;/code&gt; in a match guard to specify multiple patterns; the match guard condition will apply to all the patterns. Listing 18-28 shows the precedence of combining a match guard with a pattern that uses &lt;code&gt;|&lt;/code&gt;. The important part of this example is that the &lt;code&gt;if y&lt;/code&gt; match guard applies to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;em&gt;and&lt;/em&gt;&lt;code&gt;6&lt;/code&gt;, even though it might look like &lt;code&gt;if y&lt;/code&gt; only applies to &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">Вы также можете использовать оператор &lt;em&gt;или &lt;/em&gt; &lt;code&gt;|&lt;/code&gt; в защитнике совпадений для указания нескольких шаблонов; условие защиты совпадения будет применяться ко всем шаблонам. Перечисление 18-28 показывает приоритет комбинирования защиты совпадения с шаблоном, который использует &lt;code&gt;|&lt;/code&gt; . Важной частью этого примера является то , что &lt;code&gt;if y&lt;/code&gt; караул матч относится к &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;5&lt;/code&gt; , &lt;em&gt;и &lt;/em&gt; &lt;code&gt;6&lt;/code&gt; , хотя это может выглядеть , &lt;code&gt;if y&lt;/code&gt; относится только к &lt;code&gt;6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109e7f6c3d07299c54983d31980eeb18d57c214f" translate="yes" xml:space="preserve">
          <source>You can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ecf9c07343c46c1d60f065ded4b4f2eb0ea645" translate="yes" xml:space="preserve">
          <source>You can also work with partially initialized arrays, which could be found in low-level datastructures.</source>
          <target state="translated">Вы также можете работать с частично инициализированными массивами,которые можно найти в низкоуровневых структурах данных.</target>
        </trans-unit>
        <trans-unit id="b6c603fa73cf57e512f35e947ee6f15111e430a7" translate="yes" xml:space="preserve">
          <source>You can append a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and append a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">Вы можете добавить &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; к &lt;code&gt;String&lt;/code&gt; с &lt;a href=&quot;#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; метода push и добавить &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt; метода push_str :</target>
        </trans-unit>
        <trans-unit id="59ee6d5b203d9d5c9909fd86ebe91daa1ede20d7" translate="yes" xml:space="preserve">
          <source>You can append a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;struct.string#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and append a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d11f2c97c83c2645f12b9ebc6ac85c5458f4e32" translate="yes" xml:space="preserve">
          <source>You can build a free-standing crate by adding &lt;code&gt;#![no_std]&lt;/code&gt; to the crate attributes:</source>
          <target state="translated">Вы можете построить отдельно стоящий ящик, добавив &lt;code&gt;#![no_std]&lt;/code&gt; к атрибутам ящика:</target>
        </trans-unit>
        <trans-unit id="b809a385993bf02c8d1206070cc3301b18c3b78c" translate="yes" xml:space="preserve">
          <source>You can contribute to this book by opening an issue or sending a pull request to &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/&quot;&gt;the Rust Reference repository&lt;/a&gt;. If this book does not answer your question, and you think its answer is in scope of it, please do not hesitate to file an issue or ask about it in the &lt;code&gt;#docs&lt;/code&gt; channels on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;Discord&lt;/a&gt;. Knowing what people use this book for the most helps direct our attention to making those sections the best that they can be.</source>
          <target state="translated">Вы можете внести свой вклад в эту книгу, открыв вопрос или отправив запрос &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/&quot;&gt;на перенос в репозиторий Rust Reference&lt;/a&gt; . Если эта книга не отвечает на ваш вопрос, и вы думаете, что ответ входит в его рамки, не стесняйтесь &lt;code&gt;#docs&lt;/code&gt; о проблеме или спрашивать о ней в каналах #docs на &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;Discord&lt;/a&gt; . Знание того, для чего люди используют эту книгу чаще всего, помогает направить наше внимание на то, чтобы сделать эти разделы как можно лучше.</target>
        </trans-unit>
        <trans-unit id="b47151976fa0c19d6bbd8b86018adedad5599a36" translate="yes" xml:space="preserve">
          <source>You can contribute to this book by opening an issue or sending a pull request to &lt;a href=&quot;https://github.com/rust-lang/reference/&quot;&gt;the Rust Reference repository&lt;/a&gt;. If this book does not answer your question, and you think its answer is in scope of it, please do not hesitate to file an issue or ask about it in the &lt;code&gt;#docs&lt;/code&gt; channels on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;Discord&lt;/a&gt;. Knowing what people use this book for the most helps direct our attention to making those sections the best that they can be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45652675628aa0520caadf107ccf92529cef48c4" translate="yes" xml:space="preserve">
          <source>You can create &lt;code&gt;Path&lt;/code&gt;s from &lt;code&gt;String&lt;/code&gt;s, or even other &lt;code&gt;Path&lt;/code&gt;s:</source>
          <target state="translated">Вы можете создать &lt;code&gt;Path&lt;/code&gt; s из &lt;code&gt;String&lt;/code&gt; s или даже другого &lt;code&gt;Path&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="d7926aaf53927823e4081b71fa3d55e1e7d5547f" translate="yes" xml:space="preserve">
          <source>You can create a &lt;code&gt;String&lt;/code&gt; from &lt;a href=&quot;../primitive.str&quot;&gt;a literal string&lt;/a&gt; with &lt;a href=&quot;../convert/trait.from#tymethod.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab7261ff093b68aeb80217fb17838c264ba793f" translate="yes" xml:space="preserve">
          <source>You can create a &lt;code&gt;String&lt;/code&gt; from a literal string with &lt;a href=&quot;#method.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вы можете создать &lt;code&gt;String&lt;/code&gt; из буквальной строки с помощью &lt;a href=&quot;#method.from&quot;&gt; &lt;code&gt;String::from&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9e907952e713a332ea657810a208121675e84c04" translate="yes" xml:space="preserve">
          <source>You can create a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; from an existing one by concatenating with &lt;code&gt;+&lt;/code&gt;:</source>
          <target state="translated">Вы можете создать новую &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; из существующей, объединив ее с &lt;code&gt;+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2cc5912ade8e0031b95579911c3cbaa63e5424d5" translate="yes" xml:space="preserve">
          <source>You can create an empty hash map with &lt;code&gt;new&lt;/code&gt; and add elements with &lt;code&gt;insert&lt;/code&gt;. In Listing 8-20, we&amp;rsquo;re keeping track of the scores of two teams whose names are Blue and Yellow. The Blue team starts with 10 points, and the Yellow team starts with 50.</source>
          <target state="translated">Вы можете создать пустую хеш-карту с &lt;code&gt;new&lt;/code&gt; и добавить элементы с помощью &lt;code&gt;insert&lt;/code&gt; . В листинге 8-20 мы отслеживаем результаты двух команд с синими и желтыми названиями. Синяя команда начинает с 10 очков, а желтая команда начинает с 50.</target>
        </trans-unit>
        <trans-unit id="0d3270ed21cd27a14044769666f4247cb1a76136" translate="yes" xml:space="preserve">
          <source>You can customize the error message by passing a string as the second parameter:</source>
          <target state="translated">Вы можете настроить сообщение об ошибке,передав строку в качестве второго параметра:</target>
        </trans-unit>
        <trans-unit id="f50b50da715d70f8535907a48cb0e96ef9c58565" translate="yes" xml:space="preserve">
          <source>You can derive &lt;code&gt;Copy&lt;/code&gt; on any type whose parts all implement &lt;code&gt;Copy&lt;/code&gt;. You can only apply the &lt;code&gt;Copy&lt;/code&gt; trait to types that also implement &lt;code&gt;Clone&lt;/code&gt;, because a type that implements &lt;code&gt;Copy&lt;/code&gt; has a trivial implementation of &lt;code&gt;Clone&lt;/code&gt; that performs the same task as &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">Вы можете получить &lt;code&gt;Copy&lt;/code&gt; для любого типа, все части которого реализуют &lt;code&gt;Copy&lt;/code&gt; . Свойство &lt;code&gt;Copy&lt;/code&gt; можно применять только к типам, которые также реализуют &lt;code&gt;Clone&lt;/code&gt; , потому что тип, реализующий &lt;code&gt;Copy&lt;/code&gt; , имеет тривиальную реализацию &lt;code&gt;Clone&lt;/code&gt; , которая выполняет ту же задачу, что и &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83e158e3d2e5e26c76384dd26a124614ad844a55" translate="yes" xml:space="preserve">
          <source>You can derive &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(Hash)]&lt;/code&gt; if all fields implement &lt;code&gt;Hash&lt;/code&gt;. The resulting hash will be the combination of the values from calling &lt;a href=&quot;#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">Вы можете получить &lt;code&gt;Hash&lt;/code&gt; с помощью &lt;code&gt;#[derive(Hash)]&lt;/code&gt; если все поля реализуют &lt;code&gt;Hash&lt;/code&gt; . Результирующий хэш будет представлять собой комбинацию значений из вызывающего &lt;a href=&quot;#tymethod.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; для каждого поля.</target>
        </trans-unit>
        <trans-unit id="35be33ced6f0cfe471c698377e1d225ec13de67d" translate="yes" xml:space="preserve">
          <source>You can derive &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(Hash)]&lt;/code&gt; if all fields implement &lt;code&gt;Hash&lt;/code&gt;. The resulting hash will be the combination of the values from calling &lt;a href=&quot;trait.hash#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f5ee2dba48ae74f01f68800a38cc65446beed5" translate="yes" xml:space="preserve">
          <source>You can disambiguate a single-element tuple from a value in parentheses with a comma:</source>
          <target state="translated">Одноэлементный кортеж можно разделить на кортеж из значения в круглых скобках запятой:</target>
        </trans-unit>
        <trans-unit id="858139efb135decf30543ab94bffe38f904b8030" translate="yes" xml:space="preserve">
          <source>You can even implement the &lt;code&gt;trait&lt;/code&gt; on the returned &lt;code&gt;enum&lt;/code&gt; so the callers &lt;em&gt;don't&lt;/em&gt; have to match on the returned value to invoke the associated items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835ac5995b1f731428fb2c278267c23aa6ba7d51" translate="yes" xml:space="preserve">
          <source>You can explicitly create a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вы можете явно создать &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; с помощью &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="460f3695c8c0bbab00464940a8f28d49f754cce3" translate="yes" xml:space="preserve">
          <source>You can explicitly create a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513e665187e52659901e2d139a691e98738bef9a" translate="yes" xml:space="preserve">
          <source>You can find more information about &lt;code&gt;derive&lt;/code&gt; in the &lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6b12bc4089e8eb8b5751f247a7b9589c2fe1f2" translate="yes" xml:space="preserve">
          <source>You can find more information about borrowing in the rust-book: http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</source>
          <target state="translated">Более подробную информацию о заимствовании можно найти в ржавчине:http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.</target>
        </trans-unit>
        <trans-unit id="beb47d198b944a0ce4280dc360af7ef8ab346311" translate="yes" xml:space="preserve">
          <source>You can find more information about it in the &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/ffi-pure.html&quot;&gt;unstable Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2e5c62e0b55ad5028e27c25a79c338ab8a55a6" translate="yes" xml:space="preserve">
          <source>You can fix this error by finishing using the borrow before the next use of the value:</source>
          <target state="translated">Вы можете исправить эту ошибку,закончив использование заимствования до следующего использования стоимости:</target>
        </trans-unit>
        <trans-unit id="d8dd34acfc3bee0c9d744f723edecbf71221b97f" translate="yes" xml:space="preserve">
          <source>You can get more information about it in the &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html&quot;&gt;unstable Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aedd4a29ecef931e15839bd3008e9ac572d334a" translate="yes" xml:space="preserve">
          <source>You can have multiple conditions by combining &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; in an &lt;code&gt;else if&lt;/code&gt; expression. For example:</source>
          <target state="translated">Вы можете создать несколько условий, объединив &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; в выражении &lt;code&gt;else if&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b3c9603849c73d33443ee6a87ea7d3f7ea9f8eb7" translate="yes" xml:space="preserve">
          <source>You can implement &lt;code&gt;derive&lt;/code&gt; for your own traits through &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;procedural macros&lt;/a&gt;.</source>
          <target state="translated">Вы можете реализовать &lt;code&gt;derive&lt;/code&gt; для своих черт с помощью &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;процедурных макросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87090e61475fabac741ebc244ff59fd41b674b51" translate="yes" xml:space="preserve">
          <source>You can instead use a single name for the argument:</source>
          <target state="translated">Вместо этого вы можете использовать одно имя для аргумента:</target>
        </trans-unit>
        <trans-unit id="b4e59a25eef48510bd25baeb9f2b6823ad86530a" translate="yes" xml:space="preserve">
          <source>You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">Вы можете посмотреть на них с помощью &lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="93493631ee602e503ac1e5a81f1088e2a4d7a4c8" translate="yes" xml:space="preserve">
          <source>You can look at these with the &lt;a href=&quot;../primitive.str#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.string#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.string#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae6e1835d66f2c10d701af8aff316c93ab9ceb1" translate="yes" xml:space="preserve">
          <source>You can move elements out of an array with a &lt;a href=&quot;../reference/patterns#slice-patterns&quot;&gt;slice pattern&lt;/a&gt;. If you want one element, see &lt;a href=&quot;mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f474815df87597604ccec4f0ca97d0a759dc6f35" translate="yes" xml:space="preserve">
          <source>You can move elements out of an array with a slice pattern. If you want one element, see &lt;a href=&quot;mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вы можете перемещать элементы из массива с помощью шаблона среза. Если вам нужен один элемент, см. &lt;a href=&quot;mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5486362126d64ce78e34e75e353c7473a5182e9a" translate="yes" xml:space="preserve">
          <source>You can only define an inherent implementation for a type in the same crate where the type was defined. For example, an &lt;code&gt;impl&lt;/code&gt; block as above is not allowed since &lt;code&gt;Vec&lt;/code&gt; is defined in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c186f63e5510473d9dc9b0dc2a5406c5f9eb96" translate="yes" xml:space="preserve">
          <source>You can only define an inherent implementation for a type in the same crate where the type was defined. For example, an &lt;code&gt;impl&lt;/code&gt; block as below is not allowed since &lt;code&gt;Vec&lt;/code&gt; is defined in the standard library:</source>
          <target state="translated">Вы можете определить внутреннюю реализацию для типа только в том же ящике, где был определен тип. Например, блок &lt;code&gt;impl&lt;/code&gt; , как показано ниже, не разрешен, поскольку &lt;code&gt;Vec&lt;/code&gt; определен в стандартной библиотеке:</target>
        </trans-unit>
        <trans-unit id="b467f8c108bab6da931f53e1d1208fd735b37f94" translate="yes" xml:space="preserve">
          <source>You can only implement &lt;code&gt;Copy&lt;/code&gt; for a struct or an enum. Both of the previous examples will fail, because neither &lt;code&gt;[u8; 256]&lt;/code&gt; nor &lt;code&gt;&amp;amp;'static mut Bar&lt;/code&gt; (mutable reference to &lt;code&gt;Bar&lt;/code&gt;) is a struct or enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c813be92d22e2d7b242da8356e7fcb13fc363191" translate="yes" xml:space="preserve">
          <source>You can only implement &lt;code&gt;Copy&lt;/code&gt; for a struct or enum. Both of the following examples will fail, because neither &lt;code&gt;[u8; 256]&lt;/code&gt; nor &lt;code&gt;&amp;amp;'static mut Bar&lt;/code&gt; (mutable reference to &lt;code&gt;Bar&lt;/code&gt;) is a struct or enum:</source>
          <target state="translated">Вы можете реализовать &lt;code&gt;Copy&lt;/code&gt; только для структуры или перечисления. Оба следующих примера завершатся ошибкой, потому что ни один &lt;code&gt;[u8; 256]&lt;/code&gt; или &lt;code&gt;&amp;amp;'static mut Bar&lt;/code&gt; (изменяемая ссылка на &lt;code&gt;Bar&lt;/code&gt; ) не является структурой или перечислением:</target>
        </trans-unit>
        <trans-unit id="21f8b607f72c57127cd998f4d58d658ea39f8468" translate="yes" xml:space="preserve">
          <source>You can only make &lt;em&gt;object-safe&lt;/em&gt; traits into trait objects. Some complex rules govern all the properties that make a trait object safe, but in practice, only two rules are relevant. A trait is object safe if all the methods defined in the trait have the following properties:</source>
          <target state="translated">Вы можете превращать &lt;em&gt;объектно-безопасные&lt;/em&gt; черты в свойства-объекты. Некоторые сложные правила управляют всеми свойствами, которые делают объект-признак безопасным, но на практике важны только два правила. Признак является объектно-безопасным, если все методы, определенные в нем, имеют следующие свойства:</target>
        </trans-unit>
        <trans-unit id="d710b72f224f5678a735cd21bec78fffa991073c" translate="yes" xml:space="preserve">
          <source>You can override any default setting by adding a different value for it in &lt;em&gt;Cargo.toml&lt;/em&gt;. For example, if we want to use optimization level 1 in the development profile, we can add these two lines to our project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file:</source>
          <target state="translated">Вы можете изменить любую настройку по умолчанию, добавив для нее другое значение в &lt;em&gt;Cargo.toml&lt;/em&gt; . Например, если мы хотим использовать уровень оптимизации 1 в профиле разработки, мы можем добавить эти две строки в файл &lt;em&gt;Cargo.toml&lt;/em&gt; нашего проекта :</target>
        </trans-unit>
        <trans-unit id="1a0d0b5c07f4a3701b975bfae52379a7cc4a0a95" translate="yes" xml:space="preserve">
          <source>You can read more about cell types in the API documentation:</source>
          <target state="translated">Подробнее о типах ячеек можно прочитать в документации по API:</target>
        </trans-unit>
        <trans-unit id="49f14d85beebdc2ce97fddebb0687041307b1cc2" translate="yes" xml:space="preserve">
          <source>You can read more about trait objects in the &lt;a href=&quot;reference/types#trait-objects&quot;&gt;Trait Objects&lt;/a&gt; section of the Reference.</source>
          <target state="translated">Вы можете прочитать больше об объектах признаков в разделе &amp;laquo; &lt;a href=&quot;reference/types#trait-objects&quot;&gt;Объекты признаков&lt;/a&gt; &amp;raquo; справочника.</target>
        </trans-unit>
        <trans-unit id="9712625e55ae109f55059c67a65fb7d3fbaccdbb" translate="yes" xml:space="preserve">
          <source>You can read more in the API documentation for &lt;a href=&quot;std/cell/index&quot;&gt;Cell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d319729d74877014e187c2ba127457ae956cdc" translate="yes" xml:space="preserve">
          <source>You can run the example one of two ways:</source>
          <target state="translated">Вы можете запустить пример одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="63366b6e44f5163c78736c2914a78fd15427bd3a" translate="yes" xml:space="preserve">
          <source>You can see all of the &lt;em&gt;toolchains&lt;/em&gt; (releases of Rust and associated components) you have installed with &lt;code&gt;rustup&lt;/code&gt; as well. Here&amp;rsquo;s an example on one of your authors&amp;rsquo; Windows computer:</source>
          <target state="translated">Вы также можете увидеть все &lt;em&gt;наборы инструментов&lt;/em&gt; (выпуски Rust и связанных компонентов), которые вы установили с помощью &lt;code&gt;rustup&lt;/code&gt; . Вот пример на компьютере с Windows одного из ваших авторов:</target>
        </trans-unit>
        <trans-unit id="9ad8bdb0d1d5a61388700f692f73fc4d634ea4d8" translate="yes" xml:space="preserve">
          <source>You can see how primitive our server is: real libraries would handle the recognition of multiple requests in a much less verbose way!</source>
          <target state="translated">Вы видите,насколько примитивен наш сервер:настоящие библиотеки справились бы с распознаванием множества запросов гораздо менее многословно!</target>
        </trans-unit>
        <trans-unit id="ef181677ddc6f3265ea6a87f49632fa9f1210138" translate="yes" xml:space="preserve">
          <source>You can see that &lt;code&gt;if let&lt;/code&gt; can also introduce shadowed variables in the same way that &lt;code&gt;match&lt;/code&gt; arms can: the line &lt;code&gt;if let Ok(age) = age&lt;/code&gt; introduces a new shadowed &lt;code&gt;age&lt;/code&gt; variable that contains the value inside the &lt;code&gt;Ok&lt;/code&gt; variant. This means we need to place the &lt;code&gt;if age &amp;gt; 30&lt;/code&gt; condition within that block: we can&amp;rsquo;t combine these two conditions into &lt;code&gt;if let Ok(age) = age &amp;amp;&amp;amp; age &amp;gt; 30&lt;/code&gt;. The shadowed &lt;code&gt;age&lt;/code&gt; we want to compare to 30 isn&amp;rsquo;t valid until the new scope starts with the curly bracket.</source>
          <target state="translated">Вы можете видеть, что &lt;code&gt;if let&lt;/code&gt; может также вводить теневые переменные так же, как и &lt;code&gt;match&lt;/code&gt; arm: строка &lt;code&gt;if let Ok(age) = age&lt;/code&gt; вводит новую теневую переменную &lt;code&gt;age&lt;/code&gt; которая содержит значение внутри варианта &lt;code&gt;Ok&lt;/code&gt; . Это означает, что нам нужно поместить в этот блок условие &lt;code&gt;if age &amp;gt; 30&lt;/code&gt; : мы не можем объединить эти два условия в &lt;code&gt;if let Ok(age) = age &amp;amp;&amp;amp; age &amp;gt; 30&lt;/code&gt; . Затененный &lt;code&gt;age&lt;/code&gt; мы хотим сравнить с 30, недействителен до тех пор, пока новая область не начинается с фигурной скобки.</target>
        </trans-unit>
        <trans-unit id="6dac8a60a46917dc69183323e9ca6b9442311d9e" translate="yes" xml:space="preserve">
          <source>You can see that the second rule doesn&amp;rsquo;t apply because there is more than one input lifetime. The third rule doesn&amp;rsquo;t apply either, because &lt;code&gt;longest&lt;/code&gt; is a function rather than a method, so none of the parameters are &lt;code&gt;self&lt;/code&gt;. After working through all three rules, we still haven&amp;rsquo;t figured out what the return type&amp;rsquo;s lifetime is. This is why we got an error trying to compile the code in Listing 10-21: the compiler worked through the lifetime elision rules but still couldn&amp;rsquo;t figure out all the lifetimes of the references in the signature.</source>
          <target state="translated">Вы можете видеть, что второе правило не применяется, потому что существует более одного времени жизни ввода. Третье правило также не применяется, потому что &lt;code&gt;longest&lt;/code&gt; - это функция, а не метод, поэтому ни один из параметров не является &lt;code&gt;self&lt;/code&gt; . После проработки всех трех правил мы так и не выяснили, каков срок жизни возвращаемого типа. Вот почему мы получили ошибку при попытке скомпилировать код из Листинга 10-21: компилятор отработал правила исключения времени жизни, но все равно не смог определить все времена жизни ссылок в подписи.</target>
        </trans-unit>
        <trans-unit id="0e4d508ac715cc3acbfdf122afbf7b9a03cd0107" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; as being a bit like &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; but without any of the run-time tracking and without any of the safety checks.</source>
          <target state="translated">Вы можете думать о &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; как о чем-то вроде &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; но без какого-либо отслеживания времени выполнения и без каких-либо проверок безопасности.</target>
        </trans-unit>
        <trans-unit id="1f606e05dadc0999f11ab48116c48743386a6126" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;flat_map(f)&lt;/code&gt; as the semantic equivalent of &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;ping, and then &lt;a href=&quot;#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt;ing as in &lt;code&gt;map(f).flatten()&lt;/code&gt;.</source>
          <target state="translated">Вы можете думать о &lt;code&gt;flat_map(f)&lt;/code&gt; как о семантическом эквиваленте &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; ping, а затем о &lt;a href=&quot;#method.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt; как о &lt;code&gt;map(f).flatten()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a9642a3aa6b0d4f644c74448c6eb12a20876d4a" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;flat_map(f)&lt;/code&gt; as the semantic equivalent of &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;ping, and then &lt;a href=&quot;trait.iterator#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt;ing as in &lt;code&gt;map(f).flatten()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b8c98aafd60cb333f24479704313af8e17f2d7" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; to build up a &lt;code&gt;PathBuf&lt;/code&gt; from components:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; для создания &lt;code&gt;PathBuf&lt;/code&gt; из компонентов:</target>
        </trans-unit>
        <trans-unit id="79c504057bc14c1c72ecffa07908c9acfa0c3808" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; to implement &quot;out-pointers&quot;: instead of returning data from a function, pass it a pointer to some (uninitialized) memory to put the result into. This can be useful when it is important for the caller to control how the memory the result is stored in gets allocated, and you want to avoid unnecessary moves.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; для реализации &amp;laquo; выходных указателей&amp;raquo;: вместо того, чтобы возвращать данные из функции, передайте ей указатель на некоторую (неинициализированную) память, в которую можно поместить результат. Это может быть полезно, когда для вызывающей стороны важно контролировать, как выделяется память, в которой сохраняется результат, и вы хотите избежать ненужных перемещений.</target>
        </trans-unit>
        <trans-unit id="f06b12f9f33805451b03aa1619046a91b1f0fea9" translate="yes" xml:space="preserve">
          <source>You can use a &lt;a href=&quot;../reference/patterns#slice-patterns&quot;&gt;slice pattern&lt;/a&gt; to move elements out of an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ef701adf9c3ff21ed219e1e0f0ea149a4acfce" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;repr&lt;/code&gt; attribute to tell the compiler how you want a struct or enum to be laid out in memory.</source>
          <target state="translated">Вы можете использовать атрибут &lt;code&gt;repr&lt;/code&gt; , чтобы сообщить компилятору, как вы хотите, чтобы структура или перечисление располагались в памяти.</target>
        </trans-unit>
        <trans-unit id="1b34b5e340a342b7c6e66a1c66e9ad2f86e01083" translate="yes" xml:space="preserve">
          <source>You can use a slice pattern to move elements out of an array:</source>
          <target state="translated">Для перемещения элементов из массива можно использовать срезной шаблон:</target>
        </trans-unit>
        <trans-unit id="8525d6891c1f3e5f989dbf3ba87c59b3e77658c4" translate="yes" xml:space="preserve">
          <source>You can use aliases in order to fix this error. Example:</source>
          <target state="translated">Вы можете использовать псевдонимы для исправления этой ошибки.Пример:</target>
        </trans-unit>
        <trans-unit id="fc67eb4f6c079f25d4b841983f28617d8c247116" translate="yes" xml:space="preserve">
          <source>You can use code specified in a &lt;code&gt;Drop&lt;/code&gt; trait implementation in many ways to make cleanup convenient and safe: for instance, you could use it to create your own memory allocator! With the &lt;code&gt;Drop&lt;/code&gt; trait and Rust&amp;rsquo;s ownership system, you don&amp;rsquo;t have to remember to clean up because Rust does it automatically.</source>
          <target state="translated">Вы можете использовать код, указанный в реализации трейта &lt;code&gt;Drop&lt;/code&gt; , разными способами, чтобы сделать очистку удобной и безопасной: например, вы можете использовать его для создания своего собственного распределителя памяти! Благодаря &lt;code&gt;Drop&lt;/code&gt; и системе владения Rust вам не нужно помнить об очистке, потому что Rust делает это автоматически.</target>
        </trans-unit>
        <trans-unit id="4f312fe97d3268cd00fae0b76a4dae32c526dd97" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt; method to get an &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; from an &lt;code&gt;OsString&lt;/code&gt;; this is effectively a borrowed reference to the whole string.</source>
          <target state="translated">Вы можете использовать метод &lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; ,&lt;/a&gt; чтобы получить &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; из &lt;code&gt;OsString&lt;/code&gt; ; это фактически заимствованная ссылка на всю строку.</target>
        </trans-unit>
        <trans-unit id="1323a49e0cb97eec61d0dde3434ccf676cf86d24" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt; value that &lt;code&gt;format_args!&lt;/code&gt; returns in &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; contexts as seen below. The example also shows that &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; format to the same thing: the interpolated format string in &lt;code&gt;format_args!&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать значение &lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; которое &lt;code&gt;format_args!&lt;/code&gt; возвращается в контекстах &lt;code&gt;Debug&lt;/code&gt; и &lt;code&gt;Display&lt;/code&gt; , как показано ниже. В примере также показано, что формат &lt;code&gt;Debug&lt;/code&gt; и &lt;code&gt;Display&lt;/code&gt; одно и то же: строка интерполированного формата в &lt;code&gt;format_args!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa54acb48af4602e2f37053a7c14e129065a9bd7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;struct.osstring#method.as_os_str&quot;&gt;&lt;code&gt;OsString::as_os_str&lt;/code&gt;&lt;/a&gt; method to get an &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; from an &lt;code&gt;OsString&lt;/code&gt;; this is effectively a borrowed reference to the whole string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f9328d191cf1a4e8041c2b20ff6e3d44a4dd7e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Arguments&amp;lt;'a&amp;gt;&lt;/code&gt; that &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; returns in &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; contexts as seen below. The example also shows that &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; format to the same thing: the interpolated format string in &lt;code&gt;format_args!&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;Arguments&amp;lt;'a&amp;gt;&lt;/code&gt; что &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;возвращается в контекстах &lt;code&gt;Debug&lt;/code&gt; и &lt;code&gt;Display&lt;/code&gt; , как показано ниже. В примере также показано, что формат &lt;code&gt;Debug&lt;/code&gt; и &lt;code&gt;Display&lt;/code&gt; одно и то же: строка интерполированного формата в &lt;code&gt;format_args!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0d2c3ab842592962de40df3105ee889292b2624" translate="yes" xml:space="preserve">
          <source>You can write integer literals in any of the forms shown in Table 3-2. Note that all number literals except the byte literal allow a type suffix, such as &lt;code&gt;57u8&lt;/code&gt;, and &lt;code&gt;_&lt;/code&gt; as a visual separator, such as &lt;code&gt;1_000&lt;/code&gt;.</source>
          <target state="translated">Вы можете записывать целочисленные литералы в любой из форм, показанных в таблице 3-2. Обратите внимание, что все &lt;code&gt;57u8&lt;/code&gt; литералы, кроме байтового, допускают суффикс типа, например 57u8 , и &lt;code&gt;_&lt;/code&gt; в качестве визуального разделителя, например &lt;code&gt;1_000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e3a6a5d5ad9495618c32d7df9601c8b0c36186e" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use the &lt;code&gt;#[should_panic]&lt;/code&gt; annotation on tests that use &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. Instead, you should return an &lt;code&gt;Err&lt;/code&gt; value directly when the test should fail.</source>
          <target state="translated">Вы не можете использовать аннотацию &lt;code&gt;#[should_panic]&lt;/code&gt; в тестах, которые используют &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . Вместо этого вы должны вернуть значение &lt;code&gt;Err&lt;/code&gt; напрямую, когда тест должен завершиться неудачно.</target>
        </trans-unit>
        <trans-unit id="68b6d283a51fc88197c307fe06aa87e325990277" translate="yes" xml:space="preserve">
          <source>You can't import a type or module when the name of the item being imported is the same as another type or submodule defined in the module.</source>
          <target state="translated">Импорт типа или модуля невозможен,если имя импортируемого элемента совпадает с именем другого типа или подмодуля,определенного в модуле.</target>
        </trans-unit>
        <trans-unit id="f50f1788e3104b1887e0fe5929d8e14061698fab" translate="yes" xml:space="preserve">
          <source>You can't import a value whose name is the same as another value defined in the module.</source>
          <target state="translated">Нельзя импортировать значение,имя которого совпадает с другим значением,определенным в модуле.</target>
        </trans-unit>
        <trans-unit id="9a643c6311bbc95c59da6d6b04e51680a574a830" translate="yes" xml:space="preserve">
          <source>You can't use type or const parameters on foreign items. Example of erroneous code:</source>
          <target state="translated">Нельзя использовать параметры типа или константы на посторонних объектах.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="eeb5e1b278da97fda2cc8bf3325f0cdbbec2f73d" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;Drop::drop&lt;/code&gt; yourself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe58ca7fd87be4f97f1122198ed215b1d16ba8fe" translate="yes" xml:space="preserve">
          <source>You cannot define a struct (or enum) &lt;code&gt;Foo&lt;/code&gt; that requires an instance of &lt;code&gt;Foo&lt;/code&gt; in order to make a new &lt;code&gt;Foo&lt;/code&gt; value. This is because there would be no way a first instance of &lt;code&gt;Foo&lt;/code&gt; could be made to initialize another instance!</source>
          <target state="translated">Вы не можете определить структуру (или перечисление) &lt;code&gt;Foo&lt;/code&gt; ,для которой требуется экземпляр &lt;code&gt;Foo&lt;/code&gt; для создания нового значения &lt;code&gt;Foo&lt;/code&gt; . Это потому, что не было бы возможности создать первый экземпляр &lt;code&gt;Foo&lt;/code&gt; для инициализации другого экземпляра!</target>
        </trans-unit>
        <trans-unit id="1777ac4e29f5cc4458b21aa65a1d164c32783aad" translate="yes" xml:space="preserve">
          <source>You cannot implement both &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Drop&lt;/code&gt; on the same type. Types that are &lt;code&gt;Copy&lt;/code&gt; get implicitly duplicated by the compiler, making it very hard to predict when, and how often destructors will be executed. As such, these types cannot have destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d56e44b75bd82612a5c898ab88640b149ae542f" translate="yes" xml:space="preserve">
          <source>You cannot import the current module into itself, please remove this import or verify you didn't misspell it.</source>
          <target state="translated">Вы не можете импортировать текущий модуль в себя,пожалуйста,удалите этот импорт или проверьте,что вы не написали его неправильно.</target>
        </trans-unit>
        <trans-unit id="9637aa7070b2e9b906188f375ead424b0ed1d4bf" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;.assume_init_mut()&lt;/code&gt; to initialize a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4886cf84f3f70749a96d8b14082b6bb665ea1eb" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; hints on a same type. If you want to pack a type to a given size, you should provide a size to packed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e29ffbaea7cbfa903117ea4f8c302e21bcc69bf" translate="yes" xml:space="preserve">
          <source>You cannot use conflicting &lt;code&gt;packed&lt;/code&gt; hints on a same type. If you want to pack a type to a given size, you should provide a size to packed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e46b0f9b1886a75845894deaafd475e2954540" translate="yes" xml:space="preserve">
          <source>You cannot use type or const parameters on foreign items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8026aeec168d950d49b1d853d7fb5eccbde596" translate="yes" xml:space="preserve">
          <source>You choose inheritance for two main reasons. One is for reuse of code: you can implement particular behavior for one type, and inheritance enables you to reuse that implementation for a different type. You can share Rust code using default trait method implementations instead, which you saw in Listing 10-14 when we added a default implementation of the &lt;code&gt;summarize&lt;/code&gt; method on the &lt;code&gt;Summary&lt;/code&gt; trait. Any type implementing the &lt;code&gt;Summary&lt;/code&gt; trait would have the &lt;code&gt;summarize&lt;/code&gt; method available on it without any further code. This is similar to a parent class having an implementation of a method and an inheriting child class also having the implementation of the method. We can also override the default implementation of the &lt;code&gt;summarize&lt;/code&gt; method when we implement the &lt;code&gt;Summary&lt;/code&gt; trait, which is similar to a child class overriding the implementation of a method inherited from a parent class.</source>
          <target state="translated">Вы выбираете наследование по двум основным причинам. Один - для повторного использования кода: вы можете реализовать определенное поведение для одного типа, а наследование позволяет повторно использовать эту реализацию для другого типа. Вместо этого вы можете поделиться кодом Rust, используя реализации метода трейтов по умолчанию, которые вы видели в листинге 10-14, когда мы добавляли реализацию метода &lt;code&gt;summarize&lt;/code&gt; по умолчанию в трейт &lt;code&gt;Summary&lt;/code&gt; . Любой тип, реализующий трейт &lt;code&gt;Summary&lt;/code&gt; , будет иметь доступный метод &lt;code&gt;summarize&lt;/code&gt; без какого-либо дополнительного кода. Это похоже на родительский класс, имеющий реализацию метода, а наследующий дочерний класс также имеет реализацию метода. Мы также можем переопределить реализацию по умолчанию &lt;code&gt;summarize&lt;/code&gt; когда мы реализуем черту &lt;code&gt;Summary&lt;/code&gt; , которая похожа на дочерний класс, переопределяющий реализацию метода, унаследованного от родительского класса.</target>
        </trans-unit>
        <trans-unit id="6eab2426d653eb63791cf922c9fd68c2cf3cc300" translate="yes" xml:space="preserve">
          <source>You could use the &lt;code&gt;while&lt;/code&gt; construct to loop over the elements of a collection, such as an array. For example, let&amp;rsquo;s look at Listing 3-4.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;while&lt;/code&gt; конструкцию для цикла по элементам коллекции, такие как массив. Например, давайте посмотрим на листинг 3-4.</target>
        </trans-unit>
        <trans-unit id="86305ea7dfbd655b97c9fe7b48a6cfa736ccdc12" translate="yes" xml:space="preserve">
          <source>You declare constants using the &lt;code&gt;const&lt;/code&gt; keyword instead of the &lt;code&gt;let&lt;/code&gt; keyword, and the type of the value &lt;em&gt;must&lt;/em&gt; be annotated. We&amp;rsquo;re about to cover types and type annotations in the next section, &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types,&amp;rdquo;&lt;/a&gt; so don&amp;rsquo;t worry about the details right now. Just know that you must always annotate the type.</source>
          <target state="translated">Вы объявляете константы, используя ключевое слово &lt;code&gt;const&lt;/code&gt; вместо ключевого слова &lt;code&gt;let&lt;/code&gt; , а тип значения &lt;em&gt;должен&lt;/em&gt; быть аннотирован. Мы собираемся рассмотреть типы и аннотации типов в следующем разделе &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;laquo;Типы данных&amp;raquo;,&lt;/a&gt; поэтому не беспокойтесь о деталях прямо сейчас. Просто знайте, что вы всегда должны аннотировать тип.</target>
        </trans-unit>
        <trans-unit id="d26c982256875ef965abb7ff2a9ae7d6d8262fa1" translate="yes" xml:space="preserve">
          <source>You declared a pattern as an argument in a foreign function declaration. Erroneous code example:</source>
          <target state="translated">Вы объявили образец в качестве аргумента в декларации о внешней функции.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="3042e33d1a35dfe59f3b5a52b534fe5ccd3ab130" translate="yes" xml:space="preserve">
          <source>You declared an unknown intrinsic function. Erroneous code example:</source>
          <target state="translated">Вы объявили неизвестную внутреннюю функцию.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="209c4b82ebb79e610fb7da013287d442d9de7ccc" translate="yes" xml:space="preserve">
          <source>You declared two fields of a struct with the same name. Erroneous code example:</source>
          <target state="translated">Вы объявили два поля одноименной структуры.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="5681291083d07044a63476be05813904d873a94e" translate="yes" xml:space="preserve">
          <source>You gave an invalid number of type parameters to an intrinsic function. Erroneous code example:</source>
          <target state="translated">Вы дали недействительное количество параметров типа intrinsic-функции.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="73e529ed83de9dd32d08048f27abd6e18e54d03b" translate="yes" xml:space="preserve">
          <source>You gave an unnecessary type or const parameter in a type alias. Erroneous code example:</source>
          <target state="translated">Вы дали ненужный тип или параметр const в псевдониме типа.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="ef290be095bc0ac42be01bd488ced06e1f432faa" translate="yes" xml:space="preserve">
          <source>You gave too few lifetime arguments. Example:</source>
          <target state="translated">Ты слишком мало спорил на всю жизнь.Пример:</target>
        </trans-unit>
        <trans-unit id="3a992fb3e33f43f550919aa8e7cbe12bdd71799a" translate="yes" xml:space="preserve">
          <source>You gave too many lifetime arguments. Erroneous code example:</source>
          <target state="translated">Ты слишком много спорил на протяжении всей жизни.Ошибочный пример кода:</target>
        </trans-unit>
        <trans-unit id="803a897636a53ddcd87076d162300ffab0d90307" translate="yes" xml:space="preserve">
          <source>You have to provide the same number of arguments as expected by the &lt;code&gt;Fn&lt;/code&gt;-based type. So to fix the previous example, we need to remove the &lt;code&gt;y&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8cdc3f699d29b35f63008d1337b75507d28ea4" translate="yes" xml:space="preserve">
          <source>You have two solutions:</source>
          <target state="translated">У тебя есть два решения:</target>
        </trans-unit>
        <trans-unit id="9dce30760c2f61bac673b91333250ea52ecff835" translate="yes" xml:space="preserve">
          <source>You implemented a trait, overriding one or more of its associated types but did not reimplement its default methods.</source>
          <target state="translated">Вы реализовали признак,переопределив один или несколько связанных с ним типов,но не переопределили методы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ca3b4cf5422aeae2f92f99806820d8c1b575cccd" translate="yes" xml:space="preserve">
          <source>You just want a set.</source>
          <target state="translated">Ты просто хочешь набор.</target>
        </trans-unit>
        <trans-unit id="693a8bb9813bf36c49860217c46ff78a91bebee4" translate="yes" xml:space="preserve">
          <source>You just want to remember which keys you've seen.</source>
          <target state="translated">Ты просто хочешь вспомнить,какие ключи ты видел.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
